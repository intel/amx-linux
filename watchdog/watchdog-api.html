
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>The Linux Watchdog driver API &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Linux WatchDog Timer Driver Core kernel API" href="watchdog-kernel-api.html" />
    <link rel="prev" title="Berkshire Products PC Watchdog Card" href="pcwd-watchdog.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="the-linux-watchdog-driver-api">
<h1>The Linux Watchdog driver API<a class="headerlink" href="#the-linux-watchdog-driver-api" title="Permalink to this headline">¶</a></h1>
<p>Last reviewed: 10/05/2007</p>
<p>Copyright 2002 Christer Weingel &lt;<a class="reference external" href="mailto:wingel&#37;&#52;&#48;nano-system&#46;com">wingel<span>&#64;</span>nano-system<span>&#46;</span>com</a>&gt;</p>
<p>Some parts of this document are copied verbatim from the sbc60xxwdt
driver which is (c) Copyright 2000 Jakob Oestergaard &lt;<a class="reference external" href="mailto:jakob&#37;&#52;&#48;ostenfeld&#46;dk">jakob<span>&#64;</span>ostenfeld<span>&#46;</span>dk</a>&gt;</p>
<p>This document describes the state of the Linux 2.4.18 kernel.</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>A Watchdog Timer (WDT) is a hardware circuit that can reset the
computer system in case of a software fault.  You probably knew that
already.</p>
<p>Usually a userspace daemon will notify the kernel watchdog driver via the
/dev/watchdog special device file that userspace is still alive, at
regular intervals.  When such a notification occurs, the driver will
usually tell the hardware watchdog that everything is in order, and
that the watchdog should wait for yet another little while to reset
the system.  If userspace fails (RAM error, kernel bug, whatever), the
notifications cease to occur, and the hardware watchdog will reset the
system (causing a reboot) after the timeout occurs.</p>
<p>The Linux watchdog API is a rather ad-hoc construction and different
drivers implement different, and sometimes incompatible, parts of it.
This file is an attempt to document the existing usage and allow
future driver writers to use it as a reference.</p>
</section>
<section id="the-simplest-api">
<h2>The simplest API<a class="headerlink" href="#the-simplest-api" title="Permalink to this headline">¶</a></h2>
<p>All drivers support the basic mode of operation, where the watchdog
activates as soon as /dev/watchdog is opened and will reboot unless
the watchdog is pinged within a certain time, this time is called the
timeout or margin.  The simplest way to ping the watchdog is to write
some data to the device.  So a very simple watchdog daemon would look
like this source file:  see samples/watchdog/watchdog-simple.c</p>
<p>A more advanced driver could for example check that a HTTP server is
still responding before doing the write call to ping the watchdog.</p>
<p>When the device is closed, the watchdog is disabled, unless the “Magic
Close” feature is supported (see below).  This is not always such a
good idea, since if there is a bug in the watchdog daemon and it
crashes the system will not reboot.  Because of this, some of the
drivers support the configuration option “Disable watchdog shutdown on
close”, CONFIG_WATCHDOG_NOWAYOUT.  If it is set to Y when compiling
the kernel, there is no way of disabling the watchdog once it has been
started.  So, if the watchdog daemon crashes, the system will reboot
after the timeout has passed. Watchdog devices also usually support
the nowayout module parameter so that this option can be controlled at
runtime.</p>
</section>
<section id="magic-close-feature">
<h2>Magic Close feature<a class="headerlink" href="#magic-close-feature" title="Permalink to this headline">¶</a></h2>
<p>If a driver supports “Magic Close”, the driver will not disable the
watchdog unless a specific magic character ‘V’ has been sent to
/dev/watchdog just before closing the file.  If the userspace daemon
closes the file without sending this special character, the driver
will assume that the daemon (and userspace in general) died, and will
stop pinging the watchdog without disabling it first.  This will then
cause a reboot if the watchdog is not re-opened in sufficient time.</p>
</section>
<section id="the-ioctl-api">
<h2>The ioctl API<a class="headerlink" href="#the-ioctl-api" title="Permalink to this headline">¶</a></h2>
<p>All conforming drivers also support an ioctl API.</p>
<p>Pinging the watchdog using an ioctl:</p>
<p>All drivers that have an ioctl interface support at least one ioctl,
KEEPALIVE.  This ioctl does exactly the same thing as a write to the
watchdog device, so the main loop in the above program could be
replaced with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>while (1) {
        ioctl(fd, WDIOC_KEEPALIVE, 0);
        sleep(10);
}
</pre></div>
</div>
<p>the argument to the ioctl is ignored.</p>
</section>
<section id="setting-and-getting-the-timeout">
<h2>Setting and getting the timeout<a class="headerlink" href="#setting-and-getting-the-timeout" title="Permalink to this headline">¶</a></h2>
<p>For some drivers it is possible to modify the watchdog timeout on the
fly with the SETTIMEOUT ioctl, those drivers have the WDIOF_SETTIMEOUT
flag set in their option field.  The argument is an integer
representing the timeout in seconds.  The driver returns the real
timeout used in the same variable, and this timeout might differ from
the requested one due to limitation of the hardware:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int timeout = 45;
ioctl(fd, WDIOC_SETTIMEOUT, &amp;timeout);
printf(&quot;The timeout was set to %d seconds\n&quot;, timeout);
</pre></div>
</div>
<p>This example might actually print “The timeout was set to 60 seconds”
if the device has a granularity of minutes for its timeout.</p>
<p>Starting with the Linux 2.4.18 kernel, it is possible to query the
current timeout using the GETTIMEOUT ioctl:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, WDIOC_GETTIMEOUT, &amp;timeout);
printf(&quot;The timeout was is %d seconds\n&quot;, timeout);
</pre></div>
</div>
</section>
<section id="pretimeouts">
<h2>Pretimeouts<a class="headerlink" href="#pretimeouts" title="Permalink to this headline">¶</a></h2>
<p>Some watchdog timers can be set to have a trigger go off before the
actual time they will reset the system.  This can be done with an NMI,
interrupt, or other mechanism.  This allows Linux to record useful
information (like panic information and kernel coredumps) before it
resets:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pretimeout = 10;
ioctl(fd, WDIOC_SETPRETIMEOUT, &amp;pretimeout);
</pre></div>
</div>
<p>Note that the pretimeout is the number of seconds before the time
when the timeout will go off.  It is not the number of seconds until
the pretimeout.  So, for instance, if you set the timeout to 60 seconds
and the pretimeout to 10 seconds, the pretimeout will go off in 50
seconds.  Setting a pretimeout to zero disables it.</p>
<p>There is also a get function for getting the pretimeout:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, WDIOC_GETPRETIMEOUT, &amp;timeout);
printf(&quot;The pretimeout was is %d seconds\n&quot;, timeout);
</pre></div>
</div>
<p>Not all watchdog drivers will support a pretimeout.</p>
</section>
<section id="get-the-number-of-seconds-before-reboot">
<h2>Get the number of seconds before reboot<a class="headerlink" href="#get-the-number-of-seconds-before-reboot" title="Permalink to this headline">¶</a></h2>
<p>Some watchdog drivers have the ability to report the remaining time
before the system will reboot. The WDIOC_GETTIMELEFT is the ioctl
that returns the number of seconds before reboot:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(fd, WDIOC_GETTIMELEFT, &amp;timeleft);
printf(&quot;The timeout was is %d seconds\n&quot;, timeleft);
</pre></div>
</div>
</section>
<section id="environmental-monitoring">
<h2>Environmental monitoring<a class="headerlink" href="#environmental-monitoring" title="Permalink to this headline">¶</a></h2>
<p>All watchdog drivers are required return more information about the system,
some do temperature, fan and power level monitoring, some can tell you
the reason for the last reboot of the system.  The GETSUPPORT ioctl is
available to ask what the device can do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct watchdog_info ident;
ioctl(fd, WDIOC_GETSUPPORT, &amp;ident);
</pre></div>
</div>
<p>the fields returned in the ident struct are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 74%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>identity</p></td>
<td><p>a string identifying the watchdog driver</p></td>
</tr>
<tr class="row-even"><td><p>firmware_version</p></td>
<td><p>the firmware version of the card if available</p></td>
</tr>
<tr class="row-odd"><td><p>options</p></td>
<td><p>a flags describing what the device supports</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>the options field can have the following bits set, and describes what
kind of information that the GET_STATUS and GET_BOOT_STATUS ioctls can
return.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 39%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>WDIOF_OVERHEAT</p></td>
<td><p>Reset due to CPU overheat</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The machine was last rebooted by the watchdog because the thermal limit was
exceeded:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 58%" />
<col style="width: 42%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>WDIOF_FANFAULT</p></td>
<td><p>Fan failed</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>A system fan monitored by the watchdog card has failed</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>WDIOF_EXTERN1</p></td>
<td><p>External relay 1</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>External monitoring relay/source 1 was triggered. Controllers intended for
real world applications include external monitoring pins that will trigger
a reset.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>WDIOF_EXTERN2</p></td>
<td><p>External relay 2</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>External monitoring relay/source 2 was triggered</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>WDIOF_POWERUNDER</p></td>
<td><p>Power bad/power fault</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The machine is showing an undervoltage status</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 66%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>WDIOF_CARDRESET</p></td>
<td><p>Card previously reset the CPU</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The last reboot was caused by the watchdog card</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>WDIOF_POWEROVER</p></td>
<td><p>Power over voltage</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The machine is showing an overvoltage status. Note that if one level is
under and one over both bits will be set - this may seem odd but makes
sense.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 53%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>WDIOF_KEEPALIVEPING</p></td>
<td><p>Keep alive ping reply</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The watchdog saw a keepalive ping since it was last queried.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>WDIOF_SETTIMEOUT</p></td>
<td><p>Can set/get the timeout</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The watchdog can do pretimeouts.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>WDIOF_PRETIMEOUT</p></td>
<td><p>Pretimeout (in seconds), get/set</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>For those drivers that return any bits set in the option field, the
GETSTATUS and GETBOOTSTATUS ioctls can be used to ask for the current
status, and the status at the last reboot, respectively:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int flags;
ioctl(fd, WDIOC_GETSTATUS, &amp;flags);

or

ioctl(fd, WDIOC_GETBOOTSTATUS, &amp;flags);
</pre></div>
</div>
<p>Note that not all devices support these two calls, and some only
support the GETBOOTSTATUS call.</p>
<p>Some drivers can measure the temperature using the GETTEMP ioctl.  The
returned value is the temperature in degrees fahrenheit:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int temperature;
ioctl(fd, WDIOC_GETTEMP, &amp;temperature);
</pre></div>
</div>
<p>Finally the SETOPTIONS ioctl can be used to control some aspects of
the cards operation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int options = 0;
ioctl(fd, WDIOC_SETOPTIONS, &amp;options);
</pre></div>
</div>
<p>The following options are available:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>WDIOS_DISABLECARD</p></td>
<td><p>Turn off the watchdog timer</p></td>
</tr>
<tr class="row-even"><td><p>WDIOS_ENABLECARD</p></td>
<td><p>Turn on the watchdog timer</p></td>
</tr>
<tr class="row-odd"><td><p>WDIOS_TEMPPANIC</p></td>
<td><p>Kernel panic on temperature trip</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>[FIXME – better explanations]</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The Linux Watchdog driver API</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#the-simplest-api">The simplest API</a></li>
<li><a class="reference internal" href="#magic-close-feature">Magic Close feature</a></li>
<li><a class="reference internal" href="#the-ioctl-api">The ioctl API</a></li>
<li><a class="reference internal" href="#setting-and-getting-the-timeout">Setting and getting the timeout</a></li>
<li><a class="reference internal" href="#pretimeouts">Pretimeouts</a></li>
<li><a class="reference internal" href="#get-the-number-of-seconds-before-reboot">Get the number of seconds before reboot</a></li>
<li><a class="reference internal" href="#environmental-monitoring">Environmental monitoring</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/watchdog/watchdog-api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/watchdog/watchdog-api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>