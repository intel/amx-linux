
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Userland interfaces &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="DRM client usage stats" href="drm-usage-stats.html" />
    <link rel="prev" title="Mode Setting Helper Functions" href="drm-kms-helpers.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="userland-interfaces">
<h1>Userland interfaces<a class="headerlink" href="#userland-interfaces" title="Permalink to this headline">¶</a></h1>
<p>The DRM core exports several interfaces to applications, generally
intended to be used through corresponding libdrm wrapper functions. In
addition, drivers export device-specific interfaces for use by userspace
drivers &amp; device-aware applications through ioctls and sysfs files.</p>
<p>External interfaces include: memory mapping, context management, DMA
operations, AGP management, vblank control, fence management, memory
management, and output management.</p>
<p>Cover generic ioctls and sysfs layout here. We only need high-level
info, since man pages should cover the rest.</p>
<section id="libdrm-device-lookup">
<h2>libdrm Device Lookup<a class="headerlink" href="#libdrm-device-lookup" title="Permalink to this headline">¶</a></h2>
<p>BEWARE THE DRAGONS! MIND THE TRAPDOORS!</p>
<p>In an attempt to warn anyone else who’s trying to figure out what’s going
on here, I’ll try to summarize the story. First things first, let’s clear up
the names, because the kernel internals, libdrm and the ioctls are all named
differently:</p>
<blockquote>
<div><ul class="simple">
<li><p>GET_UNIQUE ioctl, implemented by drm_getunique is wrapped up in libdrm
through the drmGetBusid function.</p></li>
<li><p>The libdrm drmSetBusid function is backed by the SET_UNIQUE ioctl. All
that code is nerved in the kernel with <a class="reference internal" href="#c.drm_invalid_op" title="drm_invalid_op"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_invalid_op()</span></code></a>.</p></li>
<li><p>The internal set_busid kernel functions and driver callbacks are
exclusively use by the SET_VERSION ioctl, because only drm 1.0 (which is
nerved) allowed userspace to set the busid through the above ioctl.</p></li>
<li><p>Other ioctls and functions involved are named consistently.</p></li>
</ul>
</div></blockquote>
<p>For anyone wondering what’s the difference between drm 1.1 and 1.4: Correctly
handling pci domains in the busid on ppc. Doing this correctly was only
implemented in libdrm in 2010, hence can’t be nerved yet. No one knows what’s
special with drm 1.2 and 1.3.</p>
<p>Now the actual horror story of how device lookup in drm works. At large,
there’s 2 different ways, either by busid, or by device driver name.</p>
<p>Opening by busid is fairly simple:</p>
<ol class="arabic simple">
<li><p>First call SET_VERSION to make sure pci domains are handled properly. As a
side-effect this fills out the unique name in the master structure.</p></li>
<li><p>Call GET_UNIQUE to read out the unique name from the master structure,
which matches the busid thanks to step 1. If it doesn’t, proceed to try
the next device node.</p></li>
</ol>
<p>Opening by name is slightly different:</p>
<ol class="arabic simple">
<li><p>Directly call VERSION to get the version and to match against the driver
name returned by that ioctl. Note that SET_VERSION is not called, which
means the unique name for the master node just opening is _not_ filled
out. This despite that with current drm device nodes are always bound to
one device, and can’t be runtime assigned like with drm 1.0.</p></li>
<li><p>Match driver name. If it mismatches, proceed to the next device node.</p></li>
<li><p>Call GET_UNIQUE, and check whether the unique name has length zero (by
checking that the first byte in the string is 0). If that’s not the case
libdrm skips and proceeds to the next device node. Probably this is just
copypasta from drm 1.0 times where a set unique name meant that the driver
was in use already, but that’s just conjecture.</p></li>
</ol>
<p>Long story short: To keep the open by name logic working, GET_UNIQUE must
_not_ return a unique string when SET_VERSION hasn’t been called yet,
otherwise libdrm breaks. Even when that unique string can’t ever change, and
is totally irrelevant for actually opening the device because runtime
assignable device instances were only support in drm 1.0, which is long dead.
But the libdrm code in drmOpenByName somehow survived, hence this can’t be
broken.</p>
</section>
<section id="primary-nodes-drm-master-and-authentication">
<span id="drm-primary-node"></span><h2>Primary Nodes, DRM Master and Authentication<a class="headerlink" href="#primary-nodes-drm-master-and-authentication" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a> is used to track groups of clients with open
primary/legacy device nodes. For every <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> which has had at
least once successfully became the device master (either through the
SET_MASTER IOCTL, or implicitly through opening the primary device node when
no one else is the current master that time) there exists one <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master</span></code></a>.
This is noted in <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_file.is_master</span></code></a>. All other clients have just a pointer
to the <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master</span></code></a> they are associated with.</p>
<p>In addition only one <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master</span></code></a> can be the current master for a <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a>.
It can be switched through the DROP_MASTER and SET_MASTER IOCTL, or
implicitly through closing/opening the primary device node. See also
<a class="reference internal" href="#c.drm_is_current_master" title="drm_is_current_master"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_is_current_master()</span></code></a>.</p>
<p>Clients can authenticate against the current master (if it matches their own)
using the GETMAGIC and AUTHMAGIC IOCTLs. Together with exchanging masters,
this allows controlled access to the device for an entire group of mutually
trusted clients.</p>
<dl class="function">
<dt id="c.drm_is_current_master">
bool <code class="sig-name descname">drm_is_current_master</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a><em> *fpriv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_is_current_master" title="Permalink to this definition">¶</a></dt>
<dd><p>checks whether <strong>priv</strong> is the current master</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*fpriv</span></code></dt><dd><p>DRM file private</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether <strong>fpriv</strong> is current master on its device. This decides whether a
client is allowed to run DRM_MASTER IOCTLs.</p>
<p>Most of the modern IOCTL which require DRM_MASTER are for kernel modesetting
- the current master is assumed to own the non-shareable display hardware.</p>
</div>
<dl class="function">
<dt id="c.drm_master_get">
struct <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a> * <code class="sig-name descname">drm_master_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a><em> *master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_master_get" title="Permalink to this definition">¶</a></dt>
<dd><p>reference a master pointer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span> <span class="pre">*master</span></code></dt><dd><p><a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments the reference count of <strong>master</strong> and returns a pointer to <strong>master</strong>.</p>
</div>
<dl class="function">
<dt id="c.drm_file_get_master">
struct <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a> * <code class="sig-name descname">drm_file_get_master</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a><em> *file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_file_get_master" title="Permalink to this definition">¶</a></dt>
<dd><p>reference <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_file.master</span></code></a> of <strong>file_priv</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>DRM file private</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments the reference count of <strong>file_priv</strong>’s <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_file.master</span></code></a> and returns
the <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_file.master</span></code></a>. If <strong>file_priv</strong> has no <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_file.master</span></code></a>, returns NULL.</p>
<p>Master pointers returned from this function should be unreferenced using
<a class="reference internal" href="#c.drm_master_put" title="drm_master_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_master_put()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_master_put">
void <code class="sig-name descname">drm_master_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a><em> **master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_master_put" title="Permalink to this definition">¶</a></dt>
<dd><p>unreference and clear a master pointer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span> <span class="pre">**master</span></code></dt><dd><p>pointer to a pointer of <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This decrements the <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master</span></code></a> behind <strong>master</strong> and sets it to NULL.</p>
</div>
<dl class="type">
<dt id="c.drm_master">
struct <code class="sig-name descname">drm_master</code><a class="headerlink" href="#c.drm_master" title="Permalink to this definition">¶</a></dt>
<dd><p>drm master structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_master {
    struct kref refcount;
    struct drm_device *dev;
    char *unique;
    int unique_len;
    struct idr magic_map;
    void *driver_priv;
    struct drm_master *lessor;
    int lessee_id;
    struct list_head lessee_list;
    struct list_head lessees;
    struct idr leases;
    struct idr lessee_idr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt><dd><p>Refcount for this master object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Link back to the DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unique</span></code></dt><dd><p>Unique identifier: e.g. busid. Protected by
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.master_mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unique_len</span></code></dt><dd><p>Length of unique field. Protected by
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.master_mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">magic_map</span></code></dt><dd><p>Map of used authentication tokens. Protected by
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.master_mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_priv</span></code></dt><dd><p>Pointer to driver-private information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessor</span></code></dt><dd><p>Lease grantor, only set if this <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a> represents a
lessee holding a lease of objects from <strong>lessor</strong>. Full owners of the
device have this set to NULL.</p>
<p>The lessor does not change once it’s set in drm_lease_create(), and
each lessee holds a reference to its lessor that it releases upon
being destroyed in drm_lease_destroy().</p>
<p>See also the <a class="reference internal" href="#drm-leasing"><span class="std std-ref">section on display resource leasing</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessee_id</span></code></dt><dd><p>ID for lessees. Owners (i.e. <strong>lessor</strong> is NULL) always have ID 0.
Protected by <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.mode_config</span></code></a>’s <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.idr_mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessee_list</span></code></dt><dd><p>List entry of lessees of <strong>lessor</strong>, where they are linked to <strong>lessees</strong>.
Not used for owners. Protected by <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.mode_config</span></code></a>’s
<a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.idr_mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessees</span></code></dt><dd><p>List of drm_masters leasing from this one. Protected by
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.mode_config</span></code></a>’s <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.idr_mutex</span></code></a>.</p>
<p>This list is empty if no leases have been granted, or if all lessees
have been destroyed. Since lessors are referenced by all their
lessees, this master cannot be destroyed unless the list is empty.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">leases</span></code></dt><dd><p>Objects leased to this drm_master. Protected by
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.mode_config</span></code></a>’s <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.idr_mutex</span></code></a>.</p>
<p>Objects are leased all together in drm_lease_create(), and are
removed all together when the lease is revoked.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessee_idr</span></code></dt><dd><p>All lessees under this owner (only used where <strong>lessor</strong> is NULL).
Protected by <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.mode_config</span></code></a>’s <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.idr_mutex</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note that master structures are only relevant for the legacy/primary device
nodes, hence there can only be one per device, not one per drm_minor.</p>
</section>
<section id="drm-display-resource-leasing">
<span id="drm-leasing"></span><h2>DRM Display Resource Leasing<a class="headerlink" href="#drm-display-resource-leasing" title="Permalink to this headline">¶</a></h2>
<p>DRM leases provide information about whether a DRM master may control a DRM
mode setting object. This enables the creation of multiple DRM masters that
manage subsets of display resources.</p>
<p>The original DRM master of a device ‘owns’ the available drm resources. It
may create additional DRM masters and ‘lease’ resources which it controls
to the new DRM master. This gives the new DRM master control over the
leased resources until the owner revokes the lease, or the new DRM master
is closed. Some helpful terminology:</p>
<ul class="simple">
<li><p>An ‘owner’ is a <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a> that is not leasing objects from
another <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a>, and hence ‘owns’ the objects. The owner can be
identified as the <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a> for which <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master.lessor</span></code></a> is NULL.</p></li>
<li><p>A ‘lessor’ is a <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a> which is leasing objects to one or more
other <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a>. Currently, lessees are not allowed to
create sub-leases, hence the lessor is the same as the owner.</p></li>
<li><p>A ‘lessee’ is a <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a> which is leasing objects from some
other <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a>. Each lessee only leases resources from a single
lessor recorded in <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master.lessor</span></code></a>, and holds the set of objects that
it is leasing in <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master.leases</span></code></a>.</p></li>
<li><p>A ‘lease’ is a contract between the lessor and lessee that identifies
which resources may be controlled by the lessee. All of the resources
that are leased must be owned by or leased to the lessor, and lessors are
not permitted to lease the same object to multiple lessees.</p></li>
</ul>
<p>The set of objects any <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a> ‘controls’ is limited to the set
of objects it leases (for lessees) or all objects (for owners).</p>
<p>Objects not controlled by a <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a> cannot be modified through
the various state manipulating ioctls, and any state reported back to user
space will be edited to make them appear idle and/or unusable. For
instance, connectors always report ‘disconnected’, while encoders
report no possible crtcs or clones.</p>
<p>Since each lessee may lease objects from a single lessor, display resource
leases form a tree of <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a>. As lessees are currently not
allowed to create sub-leases, the tree depth is limited to 1. All of
these get activated simultaneously when the top level device owner changes
through the SETMASTER or DROPMASTER IOCTL, so <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.master</span></code></a> points to
the owner at the top of the lease tree (i.e. the <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a> for which
<a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master.lessor</span></code></a> is NULL). The full list of lessees that are leasing
objects from the owner can be searched via the owner’s
<a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_master.lessee_idr</span></code></a>.</p>
</section>
<section id="open-source-userspace-requirements">
<h2>Open-Source Userspace Requirements<a class="headerlink" href="#open-source-userspace-requirements" title="Permalink to this headline">¶</a></h2>
<p>The DRM subsystem has stricter requirements than most other kernel subsystems on
what the userspace side for new uAPI needs to look like. This section here
explains what exactly those requirements are, and why they exist.</p>
<p>The short summary is that any addition of DRM uAPI requires corresponding
open-sourced userspace patches, and those patches must be reviewed and ready for
merging into a suitable and canonical upstream project.</p>
<p>GFX devices (both display and render/GPU side) are really complex bits of
hardware, with userspace and kernel by necessity having to work together really
closely.  The interfaces, for rendering and modesetting, must be extremely wide
and flexible, and therefore it is almost always impossible to precisely define
them for every possible corner case. This in turn makes it really practically
infeasible to differentiate between behaviour that’s required by userspace, and
which must not be changed to avoid regressions, and behaviour which is only an
accidental artifact of the current implementation.</p>
<p>Without access to the full source code of all userspace users that means it
becomes impossible to change the implementation details, since userspace could
depend upon the accidental behaviour of the current implementation in minute
details. And debugging such regressions without access to source code is pretty
much impossible. As a consequence this means:</p>
<ul class="simple">
<li><p>The Linux kernel’s “no regression” policy holds in practice only for
open-source userspace of the DRM subsystem. DRM developers are perfectly fine
if closed-source blob drivers in userspace use the same uAPI as the open
drivers, but they must do so in the exact same way as the open drivers.
Creative (ab)use of the interfaces will, and in the past routinely has, lead
to breakage.</p></li>
<li><p>Any new userspace interface must have an open-source implementation as
demonstration vehicle.</p></li>
</ul>
<p>The other reason for requiring open-source userspace is uAPI review. Since the
kernel and userspace parts of a GFX stack must work together so closely, code
review can only assess whether a new interface achieves its goals by looking at
both sides. Making sure that the interface indeed covers the use-case fully
leads to a few additional requirements:</p>
<ul class="simple">
<li><p>The open-source userspace must not be a toy/test application, but the real
thing. Specifically it needs to handle all the usual error and corner cases.
These are often the places where new uAPI falls apart and hence essential to
assess the fitness of a proposed interface.</p></li>
<li><p>The userspace side must be fully reviewed and tested to the standards of that
userspace project. For e.g. mesa this means piglit testcases and review on the
mailing list. This is again to ensure that the new interface actually gets the
job done.  The userspace-side reviewer should also provide an Acked-by on the
kernel uAPI patch indicating that they believe the proposed uAPI is sound and
sufficiently documented and validated for userspace’s consumption.</p></li>
<li><p>The userspace patches must be against the canonical upstream, not some vendor
fork. This is to make sure that no one cheats on the review and testing
requirements by doing a quick fork.</p></li>
<li><p>The kernel patch can only be merged after all the above requirements are met,
but it <strong>must</strong> be merged to either drm-next or drm-misc-next <strong>before</strong> the
userspace patches land. uAPI always flows from the kernel, doing things the
other way round risks divergence of the uAPI definitions and header files.</p></li>
</ul>
<p>These are fairly steep requirements, but have grown out from years of shared
pain and experience with uAPI added hastily, and almost always regretted about
just as fast. GFX devices change really fast, requiring a paradigm shift and
entire new set of uAPI interfaces every few years at least. Together with the
Linux kernel’s guarantee to keep existing userspace running for 10+ years this
is already rather painful for the DRM subsystem, with multiple different uAPIs
for the same thing co-existing. If we add a few more complete mistakes into the
mix every year it would be entirely unmanageable.</p>
</section>
<section id="render-nodes">
<span id="drm-render-node"></span><h2>Render nodes<a class="headerlink" href="#render-nodes" title="Permalink to this headline">¶</a></h2>
<p>DRM core provides multiple character-devices for user-space to use.
Depending on which device is opened, user-space can perform a different
set of operations (mainly ioctls). The primary node is always created
and called card&lt;num&gt;. Additionally, a currently unused control node,
called controlD&lt;num&gt; is also created. The primary node provides all
legacy operations and historically was the only interface used by
userspace. With KMS, the control node was introduced. However, the
planned KMS control interface has never been written and so the control
node stays unused to date.</p>
<p>With the increased use of offscreen renderers and GPGPU applications,
clients no longer require running compositors or graphics servers to
make use of a GPU. But the DRM API required unprivileged clients to
authenticate to a DRM-Master prior to getting GPU access. To avoid this
step and to grant clients GPU access without authenticating, render
nodes were introduced. Render nodes solely serve render clients, that
is, no modesetting or privileged ioctls can be issued on render nodes.
Only non-global rendering commands are allowed. If a driver supports
render nodes, it must advertise it via the DRIVER_RENDER DRM driver
capability. If not supported, the primary node must be used for render
clients together with the legacy drmAuth authentication procedure.</p>
<p>If a driver advertises render node support, DRM core will create a
separate render node called renderD&lt;num&gt;. There will be one render node
per device. No ioctls except PRIME-related ioctls will be allowed on
this node. Especially GEM_OPEN will be explicitly prohibited. For a
complete list of driver-independent ioctls that can be used on render
nodes, see the ioctls marked DRM_RENDER_ALLOW in drm_ioctl.c  Render
nodes are designed to avoid the buffer-leaks, which occur if clients
guess the flink names or mmap offsets on the legacy interface.
Additionally to this basic interface, drivers must mark their
driver-dependent render-only ioctls as DRM_RENDER_ALLOW so render
clients can use them. Driver authors must be careful not to allow any
privileged ioctls on render nodes.</p>
<p>With render nodes, user-space can now control access to the render node
via basic file-system access-modes. A running graphics server which
authenticates clients on the privileged primary/legacy node is no longer
required. Instead, a client can open the render node and is immediately
granted GPU access. Communication between clients (or servers) is done
via PRIME. FLINK from render node to legacy node is not supported. New
clients must not use the insecure FLINK interface.</p>
<p>Besides dropping all modeset/global ioctls, render nodes also drop the
DRM-Master concept. There is no reason to associate render clients with
a DRM-Master as they are independent of any graphics server. Besides,
they must work without any running master, anyway. Drivers must be able
to run without a master object if they support render nodes. If, on the
other hand, a driver requires shared state between clients which is
visible to user-space and accessible beyond open-file boundaries, they
cannot support render nodes.</p>
</section>
<section id="device-hot-unplug">
<h2>Device Hot-Unplug<a class="headerlink" href="#device-hot-unplug" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following is the plan. Implementation is not there yet
(2020 May).</p>
</div>
<p>Graphics devices (display and/or render) may be connected via USB (e.g.
display adapters or docking stations) or Thunderbolt (e.g. eGPU). An end
user is able to hot-unplug this kind of devices while they are being
used, and expects that the very least the machine does not crash. Any
damage from hot-unplugging a DRM device needs to be limited as much as
possible and userspace must be given the chance to handle it if it wants
to. Ideally, unplugging a DRM device still lets a desktop continue to
run, but that is going to need explicit support throughout the whole
graphics stack: from kernel and userspace drivers, through display
servers, via window system protocols, and in applications and libraries.</p>
<p>Other scenarios that should lead to the same are: unrecoverable GPU
crash, PCI device disappearing off the bus, or forced unbind of a driver
from the physical device.</p>
<p>In other words, from userspace perspective everything needs to keep on
working more or less, until userspace stops using the disappeared DRM
device and closes it completely. Userspace will learn of the device
disappearance from the device removed uevent, ioctls returning ENODEV
(or driver-specific ioctls returning driver-specific things), or open()
returning ENXIO.</p>
<p>Only after userspace has closed all relevant DRM device and dmabuf file
descriptors and removed all mmaps, the DRM driver can tear down its
instance for the device that no longer exists. If the same physical
device somehow comes back in the mean time, it shall be a new DRM
device.</p>
<p>Similar to PIDs, chardev minor numbers are not recycled immediately. A
new DRM device always picks the next free minor number compared to the
previous one allocated, and wraps around when minor numbers are
exhausted.</p>
<p>The goal raises at least the following requirements for the kernel and
drivers.</p>
<section id="requirements-for-kms-uapi">
<h3>Requirements for KMS UAPI<a class="headerlink" href="#requirements-for-kms-uapi" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>KMS connectors must change their status to disconnected.</p></li>
<li><p>Legacy modesets and pageflips, and atomic commits, both real and
TEST_ONLY, and any other ioctls either fail with ENODEV or fake
success.</p></li>
<li><p>Pending non-blocking KMS operations deliver the DRM events userspace
is expecting. This applies also to ioctls that faked success.</p></li>
<li><p>open() on a device node whose underlying device has disappeared will
fail with ENXIO.</p></li>
<li><p>Attempting to create a DRM lease on a disappeared DRM device will
fail with ENODEV. Existing DRM leases remain and work as listed
above.</p></li>
</ul>
</section>
<section id="requirements-for-render-and-cross-device-uapi">
<h3>Requirements for Render and Cross-Device UAPI<a class="headerlink" href="#requirements-for-render-and-cross-device-uapi" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>All GPU jobs that can no longer run must have their fences
force-signalled to avoid inflicting hangs on userspace.
The associated error code is ENODEV.</p></li>
<li><p>Some userspace APIs already define what should happen when the device
disappears (OpenGL, GL ES: <a class="reference external" href="https://www.khronos.org/registry/OpenGL/extensions/KHR/KHR_robustness.txt">GL_KHR_robustness</a>; <a class="reference external" href="https://www.khronos.org/vulkan/">Vulkan</a>:
VK_ERROR_DEVICE_LOST; etc.). DRM drivers are free to implement this
behaviour the way they see best, e.g. returning failures in
driver-specific ioctls and handling those in userspace drivers, or
rely on uevents, and so on.</p></li>
<li><p>dmabuf which point to memory that has disappeared will either fail to
import with ENODEV or continue to be successfully imported if it would
have succeeded before the disappearance. See also about memory maps
below for already imported dmabufs.</p></li>
<li><p>Attempting to import a dmabuf to a disappeared device will either fail
with ENODEV or succeed if it would have succeeded without the
disappearance.</p></li>
<li><p>open() on a device node whose underlying device has disappeared will
fail with ENXIO.</p></li>
</ul>
</section>
<section id="requirements-for-memory-maps">
<h3>Requirements for Memory Maps<a class="headerlink" href="#requirements-for-memory-maps" title="Permalink to this headline">¶</a></h3>
<p>Memory maps have further requirements that apply to both existing maps
and maps created after the device has disappeared. If the underlying
memory disappears, the map is created or modified such that reads and
writes will still complete successfully but the result is undefined.
This applies to both userspace mmap()’d memory and memory pointed to by
dmabuf which might be mapped to other devices (cross-device dmabuf
imports).</p>
<p>Raising SIGBUS is not an option, because userspace cannot realistically
handle it. Signal handlers are global, which makes them extremely
difficult to use correctly from libraries like those that Mesa produces.
Signal handlers are not composable, you can’t have different handlers
for GPU1 and GPU2 from different vendors, and a third handler for
mmapped regular files. Threads cause additional pain with signal
handling as well.</p>
</section>
</section>
<section id="ioctl-support-on-device-nodes">
<span id="drm-driver-ioctl"></span><h2>IOCTL Support on Device Nodes<a class="headerlink" href="#ioctl-support-on-device-nodes" title="Permalink to this headline">¶</a></h2>
<p>First things first, driver private IOCTLs should only be needed for drivers
supporting rendering. Kernel modesetting is all standardized, and extended
through properties. There are a few exceptions in some existing drivers,
which define IOCTL for use by the display DRM master, but they all predate
properties.</p>
<p>Now if you do have a render driver you always have to support it through
driver private properties. There’s a few steps needed to wire all the things
up.</p>
<p>First you need to define the structure for your IOCTL in your driver private
UAPI header in <code class="docutils literal notranslate"><span class="pre">include/uapi/drm/my_driver_drm.h</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct my_driver_operation {
        u32 some_thing;
        u32 another_thing;
};
</pre></div>
</div>
<p>Please make sure that you follow all the best practices from
<code class="docutils literal notranslate"><span class="pre">Documentation/process/botching-up-ioctls.rst</span></code>. Note that <a class="reference internal" href="#c.drm_ioctl" title="drm_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_ioctl()</span></code></a>
automatically zero-extends structures, hence make sure you can add more stuff
at the end, i.e. don’t put a variable sized array there.</p>
<p>Then you need to define your IOCTL number, using one of DRM_IO(), DRM_IOR(),
DRM_IOW() or DRM_IOWR(). It must start with the DRM_IOCTL_ prefix:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>##define DRM_IOCTL_MY_DRIVER_OPERATION  *         DRM_IOW(DRM_COMMAND_BASE, struct my_driver_operation)
</pre></div>
</div>
<p>DRM driver private IOCTL must be in the range from DRM_COMMAND_BASE to
DRM_COMMAND_END. Finally you need an array of <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_ioctl_desc</span></code></a> to wire
up the handlers and set the access rights:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct drm_ioctl_desc my_driver_ioctls[] = {
    DRM_IOCTL_DEF_DRV(MY_DRIVER_OPERATION, my_driver_operation,
            DRM_AUTH|DRM_RENDER_ALLOW),
};
</pre></div>
</div>
<p>And then assign this to the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.ioctls</span></code></a> field in your driver
structure.</p>
<p>See the separate chapter on <a class="reference internal" href="drm-internals.html#drm-driver-fops"><span class="std std-ref">file operations</span></a> for how
the driver-specific IOCTLs are wired up.</p>
<section id="recommended-ioctl-return-values">
<h3>Recommended IOCTL Return Values<a class="headerlink" href="#recommended-ioctl-return-values" title="Permalink to this headline">¶</a></h3>
<p>In theory a driver’s IOCTL callback is only allowed to return very few error
codes. In practice it’s good to abuse a few more. This section documents common
practice within the DRM subsystem:</p>
<dl>
<dt>ENOENT:</dt><dd><p>Strictly this should only be used when a file doesn’t exist e.g. when
calling the open() syscall. We reuse that to signal any kind of object
lookup failure, e.g. for unknown GEM buffer object handles, unknown KMS
object handles and similar cases.</p>
</dd>
<dt>ENOSPC:</dt><dd><p>Some drivers use this to differentiate “out of kernel memory” from “out
of VRAM”. Sometimes also applies to other limited gpu resources used for
rendering (e.g. when you have a special limited compression buffer).
Sometimes resource allocation/reservation issues in command submission
IOCTLs are also signalled through EDEADLK.</p>
<p>Simply running out of kernel/system memory is signalled through ENOMEM.</p>
</dd>
<dt>EPERM/EACCES:</dt><dd><p>Returned for an operation that is valid, but needs more privileges.
E.g. root-only or much more common, DRM master-only operations return
this when called by unpriviledged clients. There’s no clear
difference between EACCES and EPERM.</p>
</dd>
<dt>ENODEV:</dt><dd><p>The device is not present anymore or is not yet fully initialized.</p>
</dd>
<dt>EOPNOTSUPP:</dt><dd><p>Feature (like PRIME, modesetting, GEM) is not supported by the driver.</p>
</dd>
<dt>ENXIO:</dt><dd><p>Remote failure, either a hardware transaction (like i2c), but also used
when the exporting driver of a shared dma-buf or fence doesn’t support a
feature needed.</p>
</dd>
<dt>EINTR:</dt><dd><p>DRM drivers assume that userspace restarts all IOCTLs. Any DRM IOCTL can
return EINTR and in such a case should be restarted with the IOCTL
parameters left unchanged.</p>
</dd>
<dt>EIO:</dt><dd><p>The GPU died and couldn’t be resurrected through a reset. Modesetting
hardware failures are signalled through the “link status” connector
property.</p>
</dd>
<dt>EINVAL:</dt><dd><p>Catch-all for anything that is an invalid argument combination which
cannot work.</p>
</dd>
</dl>
<p>IOCTL also use other error codes like ETIME, EFAULT, EBUSY, ENOTTY but their
usage is in line with the common meanings. The above list tries to just document
DRM specific patterns. Note that ENOTTY has the slightly unintuitive meaning of
“this IOCTL does not exist”, and is used exactly as such in DRM.</p>
<dl class="type">
<dt id="c.drm_ioctl_t">
<code class="sig-name descname">drm_ioctl_t</code><a class="headerlink" href="#c.drm_ioctl_t" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Typedef</strong>: DRM ioctl function type.</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">int</span> <span class="pre">drm_ioctl_t</span> <span class="pre">(struct</span> <span class="pre">drm_device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data,</span> <span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv)</span></code></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device inode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>private pointer of the ioctl call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>DRM file this ioctl was made on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the DRM ioctl typedef. Note that <a class="reference internal" href="#c.drm_ioctl" title="drm_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_ioctl()</span></code></a> has alrady copied <strong>data</strong>
into kernel-space, and will also copy it back, depending upon the read/write
settings in the ioctl command code.</p>
</div>
<dl class="type">
<dt id="c.drm_ioctl_compat_t">
<code class="sig-name descname">drm_ioctl_compat_t</code><a class="headerlink" href="#c.drm_ioctl_compat_t" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Typedef</strong>: compatibility DRM ioctl function type.</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">int</span> <span class="pre">drm_ioctl_compat_t</span> <span class="pre">(struct</span> <span class="pre">file</span> <span class="pre">*filp,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg)</span></code></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl command code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>DRM file this ioctl was made on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Just a typedef to make declaring an array of compatibility handlers easier.
New drivers shouldn’t screw up the structure layout for their ioctl
structures and hence never need this.</p>
</div>
<dl class="type">
<dt id="c.drm_ioctl_flags">
enum <code class="sig-name descname">drm_ioctl_flags</code><a class="headerlink" href="#c.drm_ioctl_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM ioctl flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_AUTH</span></code></dt><dd><p>This is for ioctl which are used for rendering, and require that the
file descriptor is either for a render node, or if it’s a
legacy/primary node, then it must be authenticated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_MASTER</span></code></dt><dd><p>This must be set for any ioctl which can change the modeset or
display state. Userspace must call the ioctl through a primary node,
while it is the active master.</p>
<p>Note that read-only modeset ioctl can also be called by
unauthenticated clients, or when a master is not the currently active
one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_ROOT_ONLY</span></code></dt><dd><p>Anything that could potentially wreak a master file descriptor needs
to have this flag set. Current that’s only for the SETMASTER and
DROPMASTER ioctl, which e.g. logind can call to force a non-behaving
master (display compositor) into compliance.</p>
<p>This is equivalent to callers with the SYSADMIN capability.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_UNLOCKED</span></code></dt><dd><p>Whether <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_ioctl_desc.func</span></code></a> should be called with the DRM BKL held
or not. Enforced as the default for all modern drivers, hence there
should never be a need to set this flag.</p>
<p>Do not use anywhere else than for the VBLANK_WAIT IOCTL, which is the
only legacy IOCTL which needs this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_RENDER_ALLOW</span></code></dt><dd><p>This is used for all ioctl needed for rendering only, for drivers
which support render nodes. This should be all new render drivers,
and hence it should be always set for any ioctl with DRM_AUTH set.
Note though that read-only query ioctl might have this set, but have
not set DRM_AUTH because they do not require authentication.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Various flags that can be set in <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_ioctl_desc.flags</span></code></a> to control how
userspace can use a given ioctl.</p>
<dl class="type">
<dt id="c.drm_ioctl_desc">
struct <code class="sig-name descname">drm_ioctl_desc</code><a class="headerlink" href="#c.drm_ioctl_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM driver ioctl entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_ioctl_desc {
    unsigned int cmd;
    enum drm_ioctl_flags flags;
    drm_ioctl_t *func;
    const char *name;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>ioctl command number, without flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>a bitmask of <a class="reference internal" href="#c.drm_ioctl_flags" title="drm_ioctl_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_ioctl_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">func</span></code></dt><dd><p>handler for this ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>user-readable name for debug output</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>For convenience it’s easier to create these using the <a class="reference internal" href="#c.DRM_IOCTL_DEF_DRV" title="DRM_IOCTL_DEF_DRV"><code class="xref c c-func docutils literal notranslate"><span class="pre">DRM_IOCTL_DEF_DRV()</span></code></a>
macro.</p>
<dl class="function">
<dt id="c.DRM_IOCTL_DEF_DRV">
<code class="sig-name descname">DRM_IOCTL_DEF_DRV</code><span class="sig-paren">(</span><em>ioctl</em>, <em>_func</em>, <em>_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_IOCTL_DEF_DRV" title="Permalink to this definition">¶</a></dt>
<dd><p>helper macro to fill out a <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_ioctl_desc</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ioctl</span></code></dt><dd><p>ioctl command suffix</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_func</span></code></dt><dd><p>handler for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_flags</span></code></dt><dd><p>a bitmask of <a class="reference internal" href="#c.drm_ioctl_flags" title="drm_ioctl_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_ioctl_flags</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Small helper macro to create a <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_ioctl_desc</span></code></a> entry. The ioctl
command number is constructed by prepending <code class="docutils literal notranslate"><span class="pre">DRM_IOCTL\_</span></code> and passing that
to DRM_IOCTL_NR().</p>
</div>
<dl class="function">
<dt id="c.drm_noop">
int <code class="sig-name descname">drm_noop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, void<em> *data</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a><em> *file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_noop" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM no-op ioctl implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data pointer for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>DRM file for the ioctl call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This no-op implementation for drm ioctls is useful for deprecated
functionality where we can’t return a failure code because existing userspace
checks the result of the ioctl, but doesn’t care about the action.</p>
<p>Always returns successfully with 0.</p>
</div>
<dl class="function">
<dt id="c.drm_invalid_op">
int <code class="sig-name descname">drm_invalid_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, void<em> *data</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a><em> *file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_invalid_op" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM invalid ioctl implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data pointer for the ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file_priv</span></code></dt><dd><p>DRM file for the ioctl call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This no-op implementation for drm ioctls is useful for deprecated
functionality where we really don’t want to allow userspace to call the ioctl
any more. This is the case for old ums interfaces for drivers that
transitioned to kms gradually and so kept the old legacy tables around. This
only applies to radeon and i915 kms drivers, other drivers shouldn’t need to
use this function.</p>
<p>Always fails with a return value of -EINVAL.</p>
</div>
<dl class="function">
<dt id="c.drm_ioctl">
long <code class="sig-name descname">drm_ioctl</code><span class="sig-paren">(</span>struct file<em> *filp</em>, unsigned int<em> cmd</em>, unsigned long<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>ioctl callback implementation for DRM drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file this ioctl is called on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl cmd number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>user argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the ioctl function in the DRM core and the driver dispatch table,
stored in <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.ioctls</span></code></a>. It checks for necessary permission by calling
drm_ioctl_permit(), and dispatches to the respective function.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt>
bool <code class="sig-name descname">drm_ioctl_flags</code><span class="sig-paren">(</span>unsigned int<em> nr</em>, unsigned int<em> *flags</em><span class="sig-paren">)</span></dt>
<dd><p>Check for core ioctl and return ioctl permission flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>ioctl number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*flags</span></code></dt><dd><p>where to return the ioctl permission flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This ioctl is only used by the vmwgfx driver to augment the access checks
done by the drm core and insofar a pretty decent layering violation. This
shouldn’t be used by any drivers.</p>
<p><strong>Return</strong></p>
<p>True if the <strong>nr</strong> corresponds to a DRM core ioctl number, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_compat_ioctl">
long <code class="sig-name descname">drm_compat_ioctl</code><span class="sig-paren">(</span>struct file<em> *filp</em>, unsigned int<em> cmd</em>, unsigned long<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_compat_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>32bit IOCTL compatibility handler for DRM drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file this ioctl is called on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl cmd number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>user argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compatibility handler for 32 bit userspace running on 64 kernels. All actual
IOCTL handling is forwarded to <a class="reference internal" href="#c.drm_ioctl" title="drm_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_ioctl()</span></code></a>, while marshalling structures as
appropriate. Note that this only handles DRM core IOCTLs, if the driver has
botched IOCTL itself, it must handle those by wrapping this function.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
</section>
</section>
<section id="testing-and-validation">
<h2>Testing and validation<a class="headerlink" href="#testing-and-validation" title="Permalink to this headline">¶</a></h2>
<section id="testing-requirements-for-userspace-api">
<h3>Testing Requirements for userspace API<a class="headerlink" href="#testing-requirements-for-userspace-api" title="Permalink to this headline">¶</a></h3>
<p>New cross-driver userspace interface extensions, like new IOCTL, new KMS
properties, new files in sysfs or anything else that constitutes an API change
should have driver-agnostic testcases in IGT for that feature, if such a test
can be reasonably made using IGT for the target hardware.</p>
</section>
<section id="validating-changes-with-igt">
<h3>Validating changes with IGT<a class="headerlink" href="#validating-changes-with-igt" title="Permalink to this headline">¶</a></h3>
<p>There’s a collection of tests that aims to cover the whole functionality of
DRM drivers and that can be used to check that changes to DRM drivers or the
core don’t regress existing functionality. This test suite is called IGT and
its code and instructions to build and run can be found in
<a class="reference external" href="https://gitlab.freedesktop.org/drm/igt-gpu-tools/">https://gitlab.freedesktop.org/drm/igt-gpu-tools/</a>.</p>
</section>
<section id="using-vkms-to-test-drm-api">
<h3>Using VKMS to test DRM API<a class="headerlink" href="#using-vkms-to-test-drm-api" title="Permalink to this headline">¶</a></h3>
<p>VKMS is a software-only model of a KMS driver that is useful for testing
and for running compositors. VKMS aims to enable a virtual display without
the need for a hardware display capability. These characteristics made VKMS
a perfect tool for validating the DRM core behavior and also support the
compositor developer. VKMS makes it possible to test DRM functions in a
virtual machine without display, simplifying the validation of some of the
core changes.</p>
<p>To Validate changes in DRM API with VKMS, start setting the kernel: make
sure to enable VKMS module; compile the kernel with the VKMS enabled and
install it in the target machine. VKMS can be run in a Virtual Machine
(QEMU, virtme or similar). It’s recommended the use of KVM with the minimum
of 1GB of RAM and four cores.</p>
<p>It’s possible to run the IGT-tests in a VM in two ways:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Use IGT inside a VM</p></li>
<li><p>Use IGT from the host machine and write the results in a shared directory.</p></li>
</ol>
</div></blockquote>
<p>As follow, there is an example of using a VM with a shared directory with
the host machine to run igt-tests. As an example it’s used virtme:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ virtme-run --rwdir /path/for/shared_dir --kdir=path/for/kernel/directory --mods=auto
</pre></div>
</div>
<p>Run the igt-tests in the guest machine, as example it’s ran the ‘kms_flip’
tests:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ /path/for/igt-gpu-tools/scripts/run-tests.sh -p -s -t &quot;kms_flip.*&quot; -v
</pre></div>
</div>
<p>In this example, instead of build the igt_runner, Piglit is used
(-p option); it’s created html summary of the tests results and it’s saved
in the folder “igt-gpu-tools/results”; it’s executed only the igt-tests
matching the -t option.</p>
</section>
<section id="display-crc-support">
<h3>Display CRC Support<a class="headerlink" href="#display-crc-support" title="Permalink to this headline">¶</a></h3>
<p>DRM device drivers can provide to userspace CRC information of each frame as
it reached a given hardware component (a CRC sampling “source”).</p>
<p>Userspace can control generation of CRCs in a given CRTC by writing to the
file dri/0/crtc-N/crc/control in debugfs, with N being the <a class="reference internal" href="#crtc-index"><span class="std std-ref">index of
the CRTC</span></a>. Accepted values are source names (which are
driver-specific) and the “auto” keyword, which will let the driver select a
default source of frame CRCs for this CRTC.</p>
<p>Once frame CRC generation is enabled, userspace can capture them by reading
the dri/0/crtc-N/crc/data file. Each line in that file contains the frame
number in the first field and then a number of unsigned integer fields
containing the CRC data. Fields are separated by a single space and the number
of CRC fields is source-specific.</p>
<p>Note that though in some cases the CRC is computed in a specified way and on
the frame contents as supplied by userspace (eDP 1.3), in general the CRC
computation is performed in an unspecified way and on frame contents that have
been already processed in also an unspecified way and thus userspace cannot
rely on being able to generate matching CRC values for the frame contents that
it submits. In this general case, the maximum userspace can do is to compare
the reported CRCs of frames that should have the same contents.</p>
<p>On the driver side the implementation effort is minimal, drivers only need to
implement <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.set_crc_source</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.verify_crc_source</span></code></a>.
The debugfs files are automatically set up if those vfuncs are set. CRC samples
need to be captured in the driver by calling <a class="reference internal" href="#c.drm_crtc_add_crc_entry" title="drm_crtc_add_crc_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_add_crc_entry()</span></code></a>.
Depending on the driver and HW requirements, <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.set_crc_source</span></code></a>
may result in a commit (even a full modeset).</p>
<p>CRC results must be reliable across non-full-modeset atomic commits, so if a
commit via DRM_IOCTL_MODE_ATOMIC would disable or otherwise interfere with
CRC generation, then the driver must mark that commit as a full modeset
(<a class="reference internal" href="drm-kms.html#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a> should return true). As a result, to ensure
consistent results, generic userspace must re-setup CRC generation after a
legacy SETCRTC or an atomic commit with DRM_MODE_ATOMIC_ALLOW_MODESET.</p>
<dl class="function">
<dt id="c.drm_crtc_add_crc_entry">
int <code class="sig-name descname">drm_crtc_add_crc_entry</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, bool<em> has_frame</em>, uint32_t<em> frame</em>, uint32_t<em> *crcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_add_crc_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Add entry with CRC information for a frame</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to which the frame belongs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">has_frame</span></code></dt><dd><p>whether this entry has a frame number to go with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">frame</span></code></dt><dd><p>number of the frame these CRCs are about</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">*crcs</span></code></dt><dd><p>array of CRC values, with length matching #drm_crtc_crc.values_cnt</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For each frame, the driver polls the source of CRCs for new data and calls
this function to add them to the buffer from where userspace reads.</p>
</div>
</section>
<section id="debugfs-support">
<h3>Debugfs Support<a class="headerlink" href="#debugfs-support" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_info_list">
struct <code class="sig-name descname">drm_info_list</code><a class="headerlink" href="#c.drm_info_list" title="Permalink to this definition">¶</a></dt>
<dd><p>debugfs info list entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_info_list {
    const char *name;
    int (*show)(struct seq_file*, void*);
    u32 driver_features;
    void *data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>file name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">show</span></code></dt><dd><p>Show callback. <code class="xref c c-type docutils literal notranslate"><span class="pre">seq_file-&gt;private</span></code> will be set to the <a class="reference internal" href="#c.drm_info_node" title="drm_info_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_info_node</span></code></a> corresponding to the instance of this info on a given
<a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_features</span></code></dt><dd><p>Required driver features for this entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Driver-private data, should not be device-specific.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents a debugfs file to be created by the drm
core.</p>
<dl class="type">
<dt id="c.drm_info_node">
struct <code class="sig-name descname">drm_info_node</code><a class="headerlink" href="#c.drm_info_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Per-minor debugfs node structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_info_node {
    struct drm_minor *minor;
    const struct drm_info_list *info_ent;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">minor</span></code></dt><dd><p><a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a> for this node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info_ent</span></code></dt><dd><p>template for this node.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents a debugfs file, as an instantiation of a <a class="reference internal" href="#c.drm_info_list" title="drm_info_list"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_info_list</span></code></a> on a <a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a>.</p>
<p>FIXME:</p>
<p>No it doesn’t make a hole lot of sense that we duplicate debugfs entries for
both the render and the primary nodes, but that’s how this has organically
grown. It should probably be fixed, with a compatibility link, if needed.</p>
<dl class="function">
<dt id="c.drm_debugfs_create_files">
void <code class="sig-name descname">drm_debugfs_create_files</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_info_list" title="drm_info_list">drm_info_list</a><em> *files</em>, int<em> count</em>, struct dentry<em> *root</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor">drm_minor</a><em> *minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_debugfs_create_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a given set of debugfs files for DRM minor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_info_list</span> <span class="pre">*files</span></code></dt><dd><p>The array of files to create</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>The number of files given</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*root</span></code></dt><dd><p>DRI debugfs dir entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_minor</span> <span class="pre">*minor</span></code></dt><dd><p>device minor number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a given set of debugfs files represented by an array of
<a class="reference internal" href="#c.drm_info_list" title="drm_info_list"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_info_list</span></code></a> in the given root directory. These files will be removed
automatically on drm_debugfs_cleanup().</p>
</div>
</section>
</section>
<section id="sysfs-support">
<h2>Sysfs Support<a class="headerlink" href="#sysfs-support" title="Permalink to this headline">¶</a></h2>
<p>DRM provides very little additional support to drivers for sysfs
interactions, beyond just all the standard stuff. Drivers who want to expose
additional sysfs properties and property groups can attach them at either
<a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device.dev</span></code></a> or <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.kdev</span></code></a>.</p>
<p>Registration is automatically handled when calling <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a>, or
<a class="reference internal" href="drm-kms.html#c.drm_connector_register" title="drm_connector_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_register()</span></code></a> in case of hot-plugged connectors. Unregistration is
also automatically handled by <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_unregister()</span></code></a> and
<a class="reference internal" href="drm-kms.html#c.drm_connector_unregister" title="drm_connector_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_unregister()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_sysfs_hotplug_event">
void <code class="sig-name descname">drm_sysfs_hotplug_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sysfs_hotplug_event" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a DRM uevent</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send a uevent for the DRM device specified by <strong>dev</strong>.  Currently we only
set HOTPLUG=1 in the uevent environment, but this could be expanded to
deal with other types of events.</p>
<p>Any new uapi should be using the <a class="reference internal" href="#c.drm_sysfs_connector_status_event" title="drm_sysfs_connector_status_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_sysfs_connector_status_event()</span></code></a>
for uevents on connector status change.</p>
</div>
<dl class="function">
<dt id="c.drm_sysfs_connector_hotplug_event">
void <code class="sig-name descname">drm_sysfs_connector_hotplug_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sysfs_connector_hotplug_event" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a DRM uevent for any connector change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector which has changed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send a uevent for the DRM connector specified by <strong>connector</strong>. This will send
a uevent with the properties HOTPLUG=1 and CONNECTOR.</p>
</div>
<dl class="function">
<dt id="c.drm_sysfs_connector_status_event">
void <code class="sig-name descname">drm_sysfs_connector_status_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_property" title="drm_property">drm_property</a><em> *property</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sysfs_connector_status_event" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a DRM uevent for connector property status change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector on which property status changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*property</span></code></dt><dd><p>connector property whose status changed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send a uevent for the DRM device specified by <strong>dev</strong>.  Currently we
set HOTPLUG=1 and connector id along with the attached property id
related to the status change.</p>
</div>
<dl class="function">
<dt id="c.drm_class_device_register">
int <code class="sig-name descname">drm_class_device_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_class_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register new device with the DRM sysfs class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a new <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> within the DRM sysfs class. Essentially only
used by ttm to have a place for its global settings. Drivers should never use
this.</p>
</div>
<dl class="function">
<dt id="c.drm_class_device_unregister">
void <code class="sig-name descname">drm_class_device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_class_device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister device with the DRM sysfs class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters a <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> from the DRM sysfs class. Essentially only used
by ttm to have a place for its global settings. Drivers should never use
this.</p>
</div>
</section>
<section id="vblank-event-handling">
<h2>VBlank event handling<a class="headerlink" href="#vblank-event-handling" title="Permalink to this headline">¶</a></h2>
<p>The DRM core exposes two vertical blank related ioctls:</p>
<dl class="simple">
<dt>DRM_IOCTL_WAIT_VBLANK</dt><dd><p>This takes a struct drm_wait_vblank structure as its argument, and
it is used to block or request a signal when a specified vblank
event occurs.</p>
</dd>
<dt>DRM_IOCTL_MODESET_CTL</dt><dd><p>This was only used for user-mode-settind drivers around modesetting
changes to allow the kernel to update the vblank interrupt after
mode setting, since on many devices the vertical blank counter is
reset to 0 at some point during modeset. Modern drivers should not
call this any more since with kernel mode setting it is a no-op.</p>
</dd>
</dl>
</section>
<section id="userspace-api-structures">
<h2>Userspace API Structures<a class="headerlink" href="#userspace-api-structures" title="Permalink to this headline">¶</a></h2>
<p>DRM exposes many UAPI and structure definition to have a consistent
and standardized interface with user.
Userspace can refer to these structure definitions and UAPI formats
to communicate to driver</p>
<section id="crtc-index">
<span id="id1"></span><h3>CRTC index<a class="headerlink" href="#crtc-index" title="Permalink to this headline">¶</a></h3>
<p>CRTC’s have both an object ID and an index, and they are not the same thing.
The index is used in cases where a densely packed identifier for a CRTC is
needed, for instance a bitmask of CRTC’s. The member possible_crtcs of <a class="reference internal" href="#c.drm_mode_get_plane" title="drm_mode_get_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_mode_get_plane</span></code></a> is an example.</p>
<p>DRM_IOCTL_MODE_GETRESOURCES populates a structure with an array of CRTC ID’s,
and the CRTC index is its position in this array.</p>
<dl class="function">
<dt id="c.DRM_CAP_DUMB_BUFFER">
<code class="sig-name descname">DRM_CAP_DUMB_BUFFER</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_DUMB_BUFFER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the driver supports creating dumb buffers via the
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_MODE_CREATE_DUMB</span></code> ioctl.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_VBLANK_HIGH_CRTC">
<code class="sig-name descname">DRM_CAP_VBLANK_HIGH_CRTC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_VBLANK_HIGH_CRTC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the kernel supports specifying a <a class="reference internal" href="#crtc-index"><span class="std std-ref">CRTC index</span></a>
in the high bits of <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_wait_vblank_request.type</span></code>.</p>
<p>Starting kernel version 2.6.39, this capability is always set to 1.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_DUMB_PREFERRED_DEPTH">
<code class="sig-name descname">DRM_CAP_DUMB_PREFERRED_DEPTH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_DUMB_PREFERRED_DEPTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>The preferred bit depth for dumb buffers.</p>
<p>The bit depth is the number of bits used to indicate the color of a single
pixel excluding any padding. This is different from the number of bits per
pixel. For instance, XRGB8888 has a bit depth of 24 but has 32 bits per
pixel.</p>
<p>Note that this preference only applies to dumb buffers, it’s irrelevant for
other types of buffers.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_DUMB_PREFER_SHADOW">
<code class="sig-name descname">DRM_CAP_DUMB_PREFER_SHADOW</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_DUMB_PREFER_SHADOW" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the driver prefers userspace to render to a shadow buffer
instead of directly rendering to a dumb buffer. For best speed, userspace
should do streaming ordered memory copies into the dumb buffer and never
read from it.</p>
<p>Note that this preference only applies to dumb buffers, it’s irrelevant for
other types of buffers.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_PRIME">
<code class="sig-name descname">DRM_CAP_PRIME</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_PRIME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Bitfield of supported PRIME sharing capabilities. See <a class="reference internal" href="#c.DRM_PRIME_CAP_IMPORT" title="DRM_PRIME_CAP_IMPORT"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_PRIME_CAP_IMPORT</span></code></a>
and <a class="reference internal" href="#c.DRM_PRIME_CAP_EXPORT" title="DRM_PRIME_CAP_EXPORT"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_PRIME_CAP_EXPORT</span></code></a>.</p>
<p>PRIME buffers are exposed as dma-buf file descriptors. See
<a class="reference internal" href="drm-mm.html"><span class="doc">DRM Memory Management</span></a>, section “PRIME Buffer Sharing”.</p>
</div>
<dl class="function">
<dt id="c.DRM_PRIME_CAP_IMPORT">
<code class="sig-name descname">DRM_PRIME_CAP_IMPORT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_PRIME_CAP_IMPORT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If this bit is set in <a class="reference internal" href="#c.DRM_CAP_PRIME" title="DRM_CAP_PRIME"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_CAP_PRIME</span></code></a>, the driver supports importing PRIME
buffers via the <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_PRIME_FD_TO_HANDLE</span></code> ioctl.</p>
</div>
<dl class="function">
<dt id="c.DRM_PRIME_CAP_EXPORT">
<code class="sig-name descname">DRM_PRIME_CAP_EXPORT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_PRIME_CAP_EXPORT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If this bit is set in <a class="reference internal" href="#c.DRM_CAP_PRIME" title="DRM_CAP_PRIME"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_CAP_PRIME</span></code></a>, the driver supports exporting PRIME
buffers via the <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_PRIME_HANDLE_TO_FD</span></code> ioctl.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_TIMESTAMP_MONOTONIC">
<code class="sig-name descname">DRM_CAP_TIMESTAMP_MONOTONIC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_TIMESTAMP_MONOTONIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 0, the kernel will report timestamps with <code class="docutils literal notranslate"><span class="pre">CLOCK_REALTIME</span></code> in
struct drm_event_vblank. If set to 1, the kernel will report timestamps with
<code class="docutils literal notranslate"><span class="pre">CLOCK_MONOTONIC</span></code>. See <code class="docutils literal notranslate"><span class="pre">clock_gettime(2)</span></code> for the definition of these
clocks.</p>
<p>Starting from kernel version 2.6.39, the default value for this capability
is 1. Starting kernel version 4.15, this capability is always set to 1.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_ASYNC_PAGE_FLIP">
<code class="sig-name descname">DRM_CAP_ASYNC_PAGE_FLIP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_ASYNC_PAGE_FLIP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the driver supports <a class="reference internal" href="#c.DRM_MODE_PAGE_FLIP_ASYNC" title="DRM_MODE_PAGE_FLIP_ASYNC"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_PAGE_FLIP_ASYNC</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_CURSOR_WIDTH">
<code class="sig-name descname">DRM_CAP_CURSOR_WIDTH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_CURSOR_WIDTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">CURSOR_WIDTH</span></code> and <code class="docutils literal notranslate"><span class="pre">CURSOR_HEIGHT</span></code> capabilities return a valid
width x height combination for the hardware cursor. The intention is that a
hardware agnostic userspace can query a cursor plane size to use.</p>
<p>Note that the cross-driver contract is to merely return a valid size;
drivers are free to attach another meaning on top, eg. i915 returns the
maximum plane size.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_CURSOR_HEIGHT">
<code class="sig-name descname">DRM_CAP_CURSOR_HEIGHT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_CURSOR_HEIGHT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="#c.DRM_CAP_CURSOR_WIDTH" title="DRM_CAP_CURSOR_WIDTH"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_CAP_CURSOR_WIDTH</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_ADDFB2_MODIFIERS">
<code class="sig-name descname">DRM_CAP_ADDFB2_MODIFIERS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_ADDFB2_MODIFIERS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the driver supports supplying modifiers in the
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_MODE_ADDFB2</span></code> ioctl.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_PAGE_FLIP_TARGET">
<code class="sig-name descname">DRM_CAP_PAGE_FLIP_TARGET</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_PAGE_FLIP_TARGET" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the driver supports the <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE</span></code> and
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_PAGE_FLIP_TARGET_RELATIVE</span></code> flags in
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_crtc_page_flip_target.flags</span></code> for the <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_MODE_PAGE_FLIP</span></code>
ioctl.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_CRTC_IN_VBLANK_EVENT">
<code class="sig-name descname">DRM_CAP_CRTC_IN_VBLANK_EVENT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_CRTC_IN_VBLANK_EVENT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the kernel supports reporting the CRTC ID in
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_event_vblank.crtc_id</span></code> for the <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_EVENT_VBLANK</span></code> and
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_EVENT_FLIP_COMPLETE</span></code> events.</p>
<p>Starting kernel version 4.12, this capability is always set to 1.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_SYNCOBJ">
<code class="sig-name descname">DRM_CAP_SYNCOBJ</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_SYNCOBJ" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the driver supports sync objects. See
<a class="reference internal" href="drm-mm.html"><span class="doc">DRM Memory Management</span></a>, section “DRM Sync Objects”.</p>
</div>
<dl class="function">
<dt id="c.DRM_CAP_SYNCOBJ_TIMELINE">
<code class="sig-name descname">DRM_CAP_SYNCOBJ_TIMELINE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CAP_SYNCOBJ_TIMELINE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the driver supports timeline operations on sync objects. See
<a class="reference internal" href="drm-mm.html"><span class="doc">DRM Memory Management</span></a>, section “DRM Sync Objects”.</p>
</div>
<dl class="function">
<dt id="c.DRM_CLIENT_CAP_STEREO_3D">
<code class="sig-name descname">DRM_CLIENT_CAP_STEREO_3D</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CLIENT_CAP_STEREO_3D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the DRM core will expose the stereo 3D capabilities of the
monitor by advertising the supported 3D layouts in the flags of <a class="reference internal" href="#c.drm_mode_modeinfo" title="drm_mode_modeinfo"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_mode_modeinfo</span></code></a>. See <code class="docutils literal notranslate"><span class="pre">DRM_MODE_FLAG_3D_*</span></code>.</p>
<p>This capability is always supported for all drivers starting from kernel
version 3.13.</p>
</div>
<dl class="function">
<dt id="c.DRM_CLIENT_CAP_UNIVERSAL_PLANES">
<code class="sig-name descname">DRM_CLIENT_CAP_UNIVERSAL_PLANES</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CLIENT_CAP_UNIVERSAL_PLANES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the DRM core will expose all planes (overlay, primary, and
cursor) to userspace.</p>
<p>This capability has been introduced in kernel version 3.15. Starting from
kernel version 3.17, this capability is always supported for all drivers.</p>
</div>
<dl class="function">
<dt id="c.DRM_CLIENT_CAP_ATOMIC">
<code class="sig-name descname">DRM_CLIENT_CAP_ATOMIC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CLIENT_CAP_ATOMIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the DRM core will expose atomic properties to userspace. This
implicitly enables <a class="reference internal" href="#c.DRM_CLIENT_CAP_UNIVERSAL_PLANES" title="DRM_CLIENT_CAP_UNIVERSAL_PLANES"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_CLIENT_CAP_UNIVERSAL_PLANES</span></code></a> and
<a class="reference internal" href="#c.DRM_CLIENT_CAP_ASPECT_RATIO" title="DRM_CLIENT_CAP_ASPECT_RATIO"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_CLIENT_CAP_ASPECT_RATIO</span></code></a>.</p>
<p>If the driver doesn’t support atomic mode-setting, enabling this capability
will fail with -EOPNOTSUPP.</p>
<p>This capability has been introduced in kernel version 4.0. Starting from
kernel version 4.2, this capability is always supported for atomic-capable
drivers.</p>
</div>
<dl class="function">
<dt id="c.DRM_CLIENT_CAP_ASPECT_RATIO">
<code class="sig-name descname">DRM_CLIENT_CAP_ASPECT_RATIO</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CLIENT_CAP_ASPECT_RATIO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the DRM core will provide aspect ratio information in modes.
See <code class="docutils literal notranslate"><span class="pre">DRM_MODE_FLAG_PIC_AR_*</span></code>.</p>
<p>This capability is always supported for all drivers starting from kernel
version 4.18.</p>
</div>
<dl class="function">
<dt id="c.DRM_CLIENT_CAP_WRITEBACK_CONNECTORS">
<code class="sig-name descname">DRM_CLIENT_CAP_WRITEBACK_CONNECTORS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_CLIENT_CAP_WRITEBACK_CONNECTORS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>If set to 1, the DRM core will expose special connectors to be used for
writing back to memory the scene setup in the commit. The client must enable
<a class="reference internal" href="#c.DRM_CLIENT_CAP_ATOMIC" title="DRM_CLIENT_CAP_ATOMIC"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_CLIENT_CAP_ATOMIC</span></code></a> first.</p>
<p>This capability is always supported for atomic-capable drivers starting from
kernel version 4.19.</p>
</div>
<dl class="function">
<dt id="c.DRM_IOCTL_MODE_RMFB">
<code class="sig-name descname">DRM_IOCTL_MODE_RMFB</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_IOCTL_MODE_RMFB" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a framebuffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This removes a framebuffer previously added via ADDFB/ADDFB2. The IOCTL
argument is a framebuffer object ID.</p>
<p>Warning: removing a framebuffer currently in-use on an enabled plane will
disable that plane. The CRTC the plane is linked to may also be disabled
(depending on driver capabilities).</p>
</div>
<dl class="function">
<dt id="c.DRM_IOCTL_MODE_GETFB2">
<code class="sig-name descname">DRM_IOCTL_MODE_GETFB2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_IOCTL_MODE_GETFB2" title="Permalink to this definition">¶</a></dt>
<dd><p>Get framebuffer metadata.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This queries metadata about a framebuffer. User-space fills
<a class="reference internal" href="#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_fb_cmd2.fb_id</span></code></a> as the input, and the kernels fills the rest of the
struct as the output.</p>
<p>If the client is DRM master or has <code class="xref c c-type docutils literal notranslate"><span class="pre">CAP_SYS_ADMIN</span></code>, <a class="reference internal" href="#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_fb_cmd2.handles</span></code></a>
will be filled with GEM buffer handles. Planes are valid until one has a
zero handle – this can be used to compute the number of planes.</p>
<p>Otherwise, <a class="reference internal" href="#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_fb_cmd2.handles</span></code></a> will be zeroed and planes are valid
until one has a zero <a class="reference internal" href="#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_fb_cmd2.pitches</span></code></a>.</p>
<p>If the framebuffer has a format modifier, <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_FB_MODIFIERS</span></code> will be set
in <a class="reference internal" href="#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_fb_cmd2.flags</span></code></a> and <a class="reference internal" href="#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_fb_cmd2.modifier</span></code></a> will contain the
modifier. Otherwise, user-space must ignore <a class="reference internal" href="#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_fb_cmd2.modifier</span></code></a>.</p>
</div>
<dl class="type">
<dt id="c.drm_mode_modeinfo">
struct <code class="sig-name descname">drm_mode_modeinfo</code><a class="headerlink" href="#c.drm_mode_modeinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Display mode information.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_modeinfo {
    __u32 clock;
    __u16 hdisplay;
    __u16 hsync_start;
    __u16 hsync_end;
    __u16 htotal;
    __u16 hskew;
    __u16 vdisplay;
    __u16 vsync_start;
    __u16 vsync_end;
    __u16 vtotal;
    __u16 vscan;
    __u32 vrefresh;
    __u32 flags;
    __u32 type;
    char name[DRM_DISPLAY_MODE_LEN];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">clock</span></code></dt><dd><p>pixel clock in kHz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdisplay</span></code></dt><dd><p>horizontal display size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hsync_start</span></code></dt><dd><p>horizontal sync start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hsync_end</span></code></dt><dd><p>horizontal sync end</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">htotal</span></code></dt><dd><p>horizontal total size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hskew</span></code></dt><dd><p>horizontal skew</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vdisplay</span></code></dt><dd><p>vertical display size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsync_start</span></code></dt><dd><p>vertical sync start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsync_end</span></code></dt><dd><p>vertical sync end</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vtotal</span></code></dt><dd><p>vertical total size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vscan</span></code></dt><dd><p>vertical scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vrefresh</span></code></dt><dd><p>approximate vertical refresh rate in Hz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>bitmask of misc. flags, see DRM_MODE_FLAG_* defines</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>bitmask of type flags, see DRM_MODE_TYPE_* defines</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>string describing the mode resolution</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is the user-space API display mode information structure. For the
kernel version see <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_mode_get_plane">
struct <code class="sig-name descname">drm_mode_get_plane</code><a class="headerlink" href="#c.drm_mode_get_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Get plane metadata.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_get_plane {
    __u32 plane_id;
    __u32 crtc_id;
    __u32 fb_id;
    __u32 possible_crtcs;
    __u32 gamma_size;
    __u32 count_format_types;
    __u64 format_type_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">plane_id</span></code></dt><dd><p>Object ID of the plane whose information should be
retrieved. Set by caller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_id</span></code></dt><dd><p>Object ID of the current CRTC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb_id</span></code></dt><dd><p>Object ID of the current fb.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">possible_crtcs</span></code></dt><dd><p>Bitmask of CRTC’s compatible with the plane. CRTC’s
are created and they receive an index, which corresponds to their
position in the bitmask. Bit N corresponds to
<a class="reference internal" href="#crtc-index"><span class="std std-ref">CRTC index</span></a> N.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gamma_size</span></code></dt><dd><p>Never used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_format_types</span></code></dt><dd><p>Number of formats.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format_type_ptr</span></code></dt><dd><p>Pointer to <code class="docutils literal notranslate"><span class="pre">__u32</span></code> array of formats that are
supported by the plane. These formats do not require modifiers.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Userspace can perform a GETPLANE ioctl to retrieve information about a
plane.</p>
<p>To retrieve the number of formats supported, set <strong>count_format_types</strong> to zero
and call the ioctl. <strong>count_format_types</strong> will be updated with the value.</p>
<p>To retrieve these formats, allocate an array with the memory needed to store
<strong>count_format_types</strong> formats. Point <strong>format_type_ptr</strong> to this array and call
the ioctl again (with <strong>count_format_types</strong> still set to the value returned in
the first ioctl call).</p>
<dl class="type">
<dt id="c.drm_mode_get_connector">
struct <code class="sig-name descname">drm_mode_get_connector</code><a class="headerlink" href="#c.drm_mode_get_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>Get connector metadata.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_get_connector {
    __u64 encoders_ptr;
    __u64 modes_ptr;
    __u64 props_ptr;
    __u64 prop_values_ptr;
    __u32 count_modes;
    __u32 count_props;
    __u32 count_encoders;
    __u32 encoder_id;
    __u32 connector_id;
    __u32 connector_type;
    __u32 connector_type_id;
    __u32 connection;
    __u32 mm_width;
    __u32 mm_height;
    __u32 subpixel;
    __u32 pad;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">encoders_ptr</span></code></dt><dd><p>Pointer to <code class="docutils literal notranslate"><span class="pre">__u32</span></code> array of object IDs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">modes_ptr</span></code></dt><dd><p>Pointer to <a class="reference internal" href="#c.drm_mode_modeinfo" title="drm_mode_modeinfo"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_modeinfo</span></code></a> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">props_ptr</span></code></dt><dd><p>Pointer to <code class="docutils literal notranslate"><span class="pre">__u32</span></code> array of property IDs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_values_ptr</span></code></dt><dd><p>Pointer to <code class="docutils literal notranslate"><span class="pre">__u64</span></code> array of property values.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_modes</span></code></dt><dd><p>Number of modes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_props</span></code></dt><dd><p>Number of properties.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_encoders</span></code></dt><dd><p>Number of encoders.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder_id</span></code></dt><dd><p>Object ID of the current encoder.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_id</span></code></dt><dd><p>Object ID of the connector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_type</span></code></dt><dd><p>Type of the connector.</p>
<p>See DRM_MODE_CONNECTOR_* defines.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_type_id</span></code></dt><dd><p>Type-specific connector number.</p>
<p>This is not an object ID. This is a per-type connector number. Each
(type, type_id) combination is unique across all connectors of a DRM
device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connection</span></code></dt><dd><p>Status of the connector.</p>
<p>See <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_connector_status</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm_width</span></code></dt><dd><p>Width of the connected sink in millimeters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mm_height</span></code></dt><dd><p>Height of the connected sink in millimeters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subpixel</span></code></dt><dd><p>Subpixel order of the connected sink.</p>
<p>See enum subpixel_order.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Padding, must be zero.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>User-space can perform a GETCONNECTOR ioctl to retrieve information about a
connector. User-space is expected to retrieve encoders, modes and properties
by performing this ioctl at least twice: the first time to retrieve the
number of elements, the second time to retrieve the elements themselves.</p>
<p>To retrieve the number of elements, set <strong>count_props</strong> and <strong>count_encoders</strong> to
zero, set <strong>count_modes</strong> to 1, and set <strong>modes_ptr</strong> to a temporary <a class="reference internal" href="#c.drm_mode_modeinfo" title="drm_mode_modeinfo"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_mode_modeinfo</span></code></a> element.</p>
<p>To retrieve the elements, allocate arrays for <strong>encoders_ptr</strong>, <strong>modes_ptr</strong>,
<strong>props_ptr</strong> and <strong>prop_values_ptr</strong>, then set <strong>count_modes</strong>, <strong>count_props</strong> and
<strong>count_encoders</strong> to their capacity.</p>
<p>Performing the ioctl only twice may be racy: the number of elements may have
changed with a hotplug event in-between the two ioctls. User-space is
expected to retry the last ioctl until the number of elements stabilizes.
The kernel won’t fill any array which doesn’t have the expected length.</p>
<p><strong>Force-probing a connector</strong></p>
<p>If the <strong>count_modes</strong> field is set to zero and the DRM client is the current
DRM master, the kernel will perform a forced probe on the connector to
refresh the connector status, modes and EDID. A forced-probe can be slow,
might cause flickering and the ioctl will block.</p>
<p>User-space needs to force-probe connectors to ensure their metadata is
up-to-date at startup and after receiving a hot-plug event. User-space
may perform a forced-probe when the user explicitly requests it. User-space
shouldn’t perform a forced-probe in other situations.</p>
<dl class="type">
<dt id="c.drm_mode_property_enum">
struct <code class="sig-name descname">drm_mode_property_enum</code><a class="headerlink" href="#c.drm_mode_property_enum" title="Permalink to this definition">¶</a></dt>
<dd><p>Description for an enum/bitfield entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_property_enum {
    __u64 value;
    char name[DRM_PROP_NAME_LEN];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>numeric value for this enum entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>symbolic name for this enum entry.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="drm-kms.html#c.drm_property_enum" title="drm_property_enum"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_property_enum</span></code></a> for details.</p>
<dl class="type">
<dt id="c.drm_mode_get_property">
struct <code class="sig-name descname">drm_mode_get_property</code><a class="headerlink" href="#c.drm_mode_get_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Get property metadata.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_get_property {
    __u64 values_ptr;
    __u64 enum_blob_ptr;
    __u32 prop_id;
    __u32 flags;
    char name[DRM_PROP_NAME_LEN];
    __u32 count_values;
    __u32 count_enum_blobs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">values_ptr</span></code></dt><dd><p>Pointer to a <code class="docutils literal notranslate"><span class="pre">__u64</span></code> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum_blob_ptr</span></code></dt><dd><p>Pointer to a <a class="reference internal" href="#c.drm_mode_property_enum" title="drm_mode_property_enum"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_property_enum</span></code></a> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prop_id</span></code></dt><dd><p>Object ID of the property which should be retrieved. Set
by the caller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">DRM_MODE_PROP_*</span></code> bitfield. See <a class="reference internal" href="drm-kms.html#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property.flags</span></code></a> for
a definition of the flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Symbolic property name. User-space should use this field to
recognize properties.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_values</span></code></dt><dd><p>Number of elements in <strong>values_ptr</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_enum_blobs</span></code></dt><dd><p>Number of elements in <strong>enum_blob_ptr</strong>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>User-space can perform a GETPROPERTY ioctl to retrieve information about a
property. The same property may be attached to multiple objects, see
“Modeset Base Object Abstraction”.</p>
<p>The meaning of the <strong>values_ptr</strong> field changes depending on the property type.
See <a class="reference internal" href="drm-kms.html#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_property.flags</span></code></a> for more details.</p>
<p>The <strong>enum_blob_ptr</strong> and <strong>count_enum_blobs</strong> fields are only meaningful when the
property has the type <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_PROP_ENUM</span></code> or <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_PROP_BITMASK</span></code>. For
backwards compatibility, the kernel will always set <strong>count_enum_blobs</strong> to
zero when the property has the type <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_PROP_BLOB</span></code>. User-space must
ignore these two fields if the property has a different type.</p>
<p>User-space is expected to retrieve values and enums by performing this ioctl
at least twice: the first time to retrieve the number of elements, the
second time to retrieve the elements themselves.</p>
<p>To retrieve the number of elements, set <strong>count_values</strong> and <strong>count_enum_blobs</strong>
to zero, then call the ioctl. <strong>count_values</strong> will be updated with the number
of elements. If the property has the type <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_PROP_ENUM</span></code> or
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_PROP_BITMASK</span></code>, <strong>count_enum_blobs</strong> will be updated as well.</p>
<p>To retrieve the elements themselves, allocate an array for <strong>values_ptr</strong> and
set <strong>count_values</strong> to its capacity. If the property has the type
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_PROP_ENUM</span></code> or <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_PROP_BITMASK</span></code>, allocate an array for
<strong>enum_blob_ptr</strong> and set <strong>count_enum_blobs</strong> to its capacity. Calling the ioctl
again will fill the arrays.</p>
<dl class="type">
<dt id="c.drm_mode_fb_cmd2">
struct <code class="sig-name descname">drm_mode_fb_cmd2</code><a class="headerlink" href="#c.drm_mode_fb_cmd2" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-buffer metadata.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_fb_cmd2 {
    __u32 fb_id;
    __u32 width;
    __u32 height;
    __u32 pixel_format;
    __u32 flags;
    __u32 handles[4];
    __u32 pitches[4];
    __u32 offsets[4];
    __u64 modifier[4];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fb_id</span></code></dt><dd><p>Object ID of the frame-buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code></dt><dd><p>Width of the frame-buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">height</span></code></dt><dd><p>Height of the frame-buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pixel_format</span></code></dt><dd><p>FourCC format code, see <code class="docutils literal notranslate"><span class="pre">DRM_FORMAT_*</span></code> constants in
<code class="docutils literal notranslate"><span class="pre">drm_fourcc.h</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Frame-buffer flags (see <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_FB_INTERLACED</span></code> and
<code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_FB_MODIFIERS</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handles</span></code></dt><dd><p>GEM buffer handle, one per plane. Set to 0 if the plane is
unused. The same handle can be used for multiple planes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pitches</span></code></dt><dd><p>Pitch (aka. stride) in bytes, one per plane.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offsets</span></code></dt><dd><p>Offset into the buffer in bytes, one per plane.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">modifier</span></code></dt><dd><p>Format modifier, one per plane. See <code class="docutils literal notranslate"><span class="pre">DRM_FORMAT_MOD_*</span></code>
constants in <code class="docutils literal notranslate"><span class="pre">drm_fourcc.h</span></code>. All planes must use the same
modifier. Ignored unless <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_FB_MODIFIERS</span></code> is set in <strong>flags</strong>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct holds frame-buffer metadata. There are two ways to use it:</p>
<ul class="simple">
<li><p>User-space can fill this struct and perform a <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_MODE_ADDFB2</span></code>
ioctl to register a new frame-buffer. The new frame-buffer object ID will
be set by the kernel in <strong>fb_id</strong>.</p></li>
<li><p>User-space can set <strong>fb_id</strong> and perform a <a class="reference internal" href="#c.DRM_IOCTL_MODE_GETFB2" title="DRM_IOCTL_MODE_GETFB2"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_MODE_GETFB2</span></code></a> ioctl to
fetch metadata about an existing frame-buffer.</p></li>
</ul>
<p>In case of planar formats, this struct allows up to 4 buffer objects with
offsets and pitches per plane. The pitch and offset order are dictated by
the format FourCC as defined by <code class="docutils literal notranslate"><span class="pre">drm_fourcc.h</span></code>, e.g. NV12 is described as:</p>
<blockquote>
<div><p>YUV 4:2:0 image with a plane of 8-bit Y samples followed by an
interleaved U/V plane containing 8-bit 2x2 subsampled colour difference
samples.</p>
</div></blockquote>
<p>So it would consist of a Y plane at <code class="docutils literal notranslate"><span class="pre">offsets[0]</span></code> and a UV plane at
<code class="docutils literal notranslate"><span class="pre">offsets[1]</span></code>.</p>
<p>To accommodate tiled, compressed, etc formats, a modifier can be specified.
For more information see the “Format Modifiers” section. Note that even
though it looks like we have a modifier per-plane, we in fact do not. The
modifier for each plane must be identical. Thus all combinations of
different data layouts for multi-plane formats must be enumerated as
separate modifiers.</p>
<p>All of the entries in <strong>handles</strong>, <strong>pitches</strong>, <strong>offsets</strong> and <strong>modifier</strong> must be
zero when unused. Warning, for <strong>offsets</strong> and <strong>modifier</strong> zero can’t be used to
figure out whether the entry is used or not since it’s a valid value (a zero
offset is common, and a zero modifier is <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_FORMAT_MOD_LINEAR</span></code>).</p>
<dl class="type">
<dt id="c.hdr_metadata_infoframe">
struct <code class="sig-name descname">hdr_metadata_infoframe</code><a class="headerlink" href="#c.hdr_metadata_infoframe" title="Permalink to this definition">¶</a></dt>
<dd><p>HDR Metadata Infoframe Data.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hdr_metadata_infoframe {
    __u8 eotf;
    __u8 metadata_type;
    struct {
        __u16 x, y;
    } display_primaries[3];
    struct {
        __u16 x, y;
    } white_point;
    __u16 max_display_mastering_luminance;
    __u16 min_display_mastering_luminance;
    __u16 max_cll;
    __u16 max_fall;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">eotf</span></code></dt><dd><p>Electro-Optical Transfer Function (EOTF)
used in the stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">metadata_type</span></code></dt><dd><p>Static_Metadata_Descriptor_ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">display_primaries</span></code></dt><dd><p>Color Primaries of the Data.
These are coded as unsigned 16-bit values in units of
0.00002, where 0x0000 represents zero and 0xC350
represents 1.0000.
<strong>display_primaries.x</strong>: X cordinate of color primary.
<strong>display_primaries.y</strong>: Y cordinate of color primary.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">white_point</span></code></dt><dd><p>White Point of Colorspace Data.
These are coded as unsigned 16-bit values in units of
0.00002, where 0x0000 represents zero and 0xC350
represents 1.0000.
<strong>white_point.x</strong>: X cordinate of whitepoint of color primary.
<strong>white_point.y</strong>: Y cordinate of whitepoint of color primary.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_display_mastering_luminance</span></code></dt><dd><p>Max Mastering Display Luminance.
This value is coded as an unsigned 16-bit value in units of 1 cd/m2,
where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_display_mastering_luminance</span></code></dt><dd><p>Min Mastering Display Luminance.
This value is coded as an unsigned 16-bit value in units of
0.0001 cd/m2, where 0x0001 represents 0.0001 cd/m2 and 0xFFFF
represents 6.5535 cd/m2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_cll</span></code></dt><dd><p>Max Content Light Level.
This value is coded as an unsigned 16-bit value in units of 1 cd/m2,
where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_fall</span></code></dt><dd><p>Max Frame Average Light Level.
This value is coded as an unsigned 16-bit value in units of 1 cd/m2,
where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>HDR Metadata Infoframe as per CTA 861.G spec. This is expected
to match exactly with the spec.</p>
<p>Userspace is expected to pass the metadata information as per
the format described in this structure.</p>
<dl class="type">
<dt id="c.hdr_output_metadata">
struct <code class="sig-name descname">hdr_output_metadata</code><a class="headerlink" href="#c.hdr_output_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>HDR output metadata</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hdr_output_metadata {
    __u32 metadata_type;
    union {
        struct hdr_metadata_infoframe hdmi_metadata_type1;
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">metadata_type</span></code></dt><dd><p>Static_Metadata_Descriptor_ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdmi_metadata_type1</span></code></dt><dd><p>HDR Metadata Infoframe.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Metadata Information to be passed from userspace</p>
<dl class="function">
<dt id="c.DRM_MODE_PAGE_FLIP_EVENT">
<code class="sig-name descname">DRM_MODE_PAGE_FLIP_EVENT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_PAGE_FLIP_EVENT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Request that the kernel sends back a vblank event (see
struct drm_event_vblank) with the <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_EVENT_FLIP_COMPLETE</span></code> type when the
page-flip is done.</p>
</div>
<dl class="function">
<dt id="c.DRM_MODE_PAGE_FLIP_ASYNC">
<code class="sig-name descname">DRM_MODE_PAGE_FLIP_ASYNC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_PAGE_FLIP_ASYNC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Request that the page-flip is performed as soon as possible, ie. with no
delay due to waiting for vblank. This may cause tearing to be visible on
the screen.</p>
</div>
<dl class="function">
<dt id="c.DRM_MODE_PAGE_FLIP_FLAGS">
<code class="sig-name descname">DRM_MODE_PAGE_FLIP_FLAGS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_PAGE_FLIP_FLAGS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Bitmask of flags suitable for <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_crtc_page_flip_target.flags</span></code>.</p>
</div>
<dl class="function">
<dt id="c.DRM_MODE_ATOMIC_TEST_ONLY">
<code class="sig-name descname">DRM_MODE_ATOMIC_TEST_ONLY</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_ATOMIC_TEST_ONLY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Do not apply the atomic commit, instead check whether the hardware supports
this configuration.</p>
<p>See <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> for more details on test-only
commits.</p>
</div>
<dl class="function">
<dt id="c.DRM_MODE_ATOMIC_NONBLOCK">
<code class="sig-name descname">DRM_MODE_ATOMIC_NONBLOCK</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_ATOMIC_NONBLOCK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Do not block while applying the atomic commit. The <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_MODE_ATOMIC</span></code>
IOCTL returns immediately instead of waiting for the changes to be applied
in hardware. Note, the driver will still check that the update can be
applied before retuning.</p>
</div>
<dl class="function">
<dt id="c.DRM_MODE_ATOMIC_ALLOW_MODESET">
<code class="sig-name descname">DRM_MODE_ATOMIC_ALLOW_MODESET</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_ATOMIC_ALLOW_MODESET" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Allow the update to result in temporary or transient visible artifacts while
the update is being applied. Applying the update may also take significantly
more time than a page flip. All visual artifacts will disappear by the time
the update is completed, as signalled through the vblank event’s timestamp
(see struct drm_event_vblank).</p>
<p>This flag must be set when the KMS update might cause visible artifacts.
Without this flag such KMS update will return a EINVAL error. What kind of
update may cause visible artifacts depends on the driver and the hardware.
User-space that needs to know beforehand if an update might cause visible
artifacts can use <a class="reference internal" href="#c.DRM_MODE_ATOMIC_TEST_ONLY" title="DRM_MODE_ATOMIC_TEST_ONLY"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_ATOMIC_TEST_ONLY</span></code></a> without
<a class="reference internal" href="#c.DRM_MODE_ATOMIC_ALLOW_MODESET" title="DRM_MODE_ATOMIC_ALLOW_MODESET"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_MODE_ATOMIC_ALLOW_MODESET</span></code></a> to see if it fails.</p>
<p>To the best of the driver’s knowledge, visual artifacts are guaranteed to
not appear when this flag is not set. Some sinks might display visual
artifacts outside of the driver’s control.</p>
</div>
<dl class="function">
<dt id="c.DRM_MODE_ATOMIC_FLAGS">
<code class="sig-name descname">DRM_MODE_ATOMIC_FLAGS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_ATOMIC_FLAGS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Bitfield of flags accepted by the <code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_IOCTL_MODE_ATOMIC</span></code> IOCTL in
<code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_atomic.flags</span></code>.</p>
</div>
<dl class="type">
<dt id="c.drm_mode_create_blob">
struct <code class="sig-name descname">drm_mode_create_blob</code><a class="headerlink" href="#c.drm_mode_create_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>Create New blob property</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_create_blob {
    __u64 data;
    __u32 length;
    __u32 blob_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Pointer to data to copy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Length of data to copy.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blob_id</span></code></dt><dd><p>Return: new property ID.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Create a new ‘blob’ data property, copying length bytes from data pointer,
and returning new blob ID.</p>
<dl class="type">
<dt id="c.drm_mode_destroy_blob">
struct <code class="sig-name descname">drm_mode_destroy_blob</code><a class="headerlink" href="#c.drm_mode_destroy_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroy user blob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_destroy_blob {
    __u32 blob_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">blob_id</span></code></dt><dd><p>blob_id to destroy</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Destroy a user-created blob property.</p>
<p>User-space can release blobs as soon as they do not need to refer to them by
their blob object ID.  For instance, if you are using a MODE_ID blob in an
atomic commit and you will not make another commit re-using the same ID, you
can destroy the blob as soon as the commit has been issued, without waiting
for it to complete.</p>
<dl class="type">
<dt id="c.drm_mode_create_lease">
struct <code class="sig-name descname">drm_mode_create_lease</code><a class="headerlink" href="#c.drm_mode_create_lease" title="Permalink to this definition">¶</a></dt>
<dd><p>Create lease</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_create_lease {
    __u64 object_ids;
    __u32 object_count;
    __u32 flags;
    __u32 lessee_id;
    __u32 fd;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">object_ids</span></code></dt><dd><p>Pointer to array of object ids (__u32)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">object_count</span></code></dt><dd><p>Number of object ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags for new FD (O_CLOEXEC, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessee_id</span></code></dt><dd><p>Return: unique identifier for lessee.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fd</span></code></dt><dd><p>Return: file descriptor to new drm_master file</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Lease mode resources, creating another drm_master.</p>
<p>The <strong>object_ids</strong> array must reference at least one CRTC, one connector and
one plane if <a class="reference internal" href="#c.DRM_CLIENT_CAP_UNIVERSAL_PLANES" title="DRM_CLIENT_CAP_UNIVERSAL_PLANES"><code class="xref c c-type docutils literal notranslate"><span class="pre">DRM_CLIENT_CAP_UNIVERSAL_PLANES</span></code></a> is enabled. Alternatively,
the lease can be completely empty.</p>
<dl class="type">
<dt id="c.drm_mode_list_lessees">
struct <code class="sig-name descname">drm_mode_list_lessees</code><a class="headerlink" href="#c.drm_mode_list_lessees" title="Permalink to this definition">¶</a></dt>
<dd><p>List lessees</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_list_lessees {
    __u32 count_lessees;
    __u32 pad;
    __u64 lessees_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">count_lessees</span></code></dt><dd><p>Number of lessees.</p>
<p>On input, provides length of the array.
On output, provides total number. No
more than the input number will be written
back, so two calls can be used to get
the size and then the data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Padding.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lessees_ptr</span></code></dt><dd><p>Pointer to lessees.</p>
<p>Pointer to __u64 array of lessee ids</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>List lesses from a drm_master.</p>
<dl class="type">
<dt id="c.drm_mode_get_lease">
struct <code class="sig-name descname">drm_mode_get_lease</code><a class="headerlink" href="#c.drm_mode_get_lease" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Lease</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_get_lease {
    __u32 count_objects;
    __u32 pad;
    __u64 objects_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">count_objects</span></code></dt><dd><p>Number of leased objects.</p>
<p>On input, provides length of the array.
On output, provides total number. No
more than the input number will be written
back, so two calls can be used to get
the size and then the data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Padding.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">objects_ptr</span></code></dt><dd><p>Pointer to objects.</p>
<p>Pointer to __u32 array of object ids.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Get leased objects.</p>
<dl class="type">
<dt id="c.drm_mode_revoke_lease">
struct <code class="sig-name descname">drm_mode_revoke_lease</code><a class="headerlink" href="#c.drm_mode_revoke_lease" title="Permalink to this definition">¶</a></dt>
<dd><p>Revoke lease</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_revoke_lease {
    __u32 lessee_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lessee_id</span></code></dt><dd><p>Unique ID of lessee</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_mode_rect">
struct <code class="sig-name descname">drm_mode_rect</code><a class="headerlink" href="#c.drm_mode_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Two dimensional rectangle.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_rect {
    __s32 x1;
    __s32 y1;
    __s32 x2;
    __s32 y2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x1</span></code></dt><dd><p>Horizontal starting coordinate (inclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y1</span></code></dt><dd><p>Vertical starting coordinate (inclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">x2</span></code></dt><dd><p>Horizontal ending coordinate (exclusive).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y2</span></code></dt><dd><p>Vertical ending coordinate (exclusive).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>With drm subsystem using <a class="reference internal" href="drm-kms-helpers.html#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a> to manage rectangular area this
export it to user-space.</p>
<p>Currently used by drm_mode_atomic blob property FB_DAMAGE_CLIPS.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Userland interfaces</a><ul>
<li><a class="reference internal" href="#libdrm-device-lookup">libdrm Device Lookup</a></li>
<li><a class="reference internal" href="#primary-nodes-drm-master-and-authentication">Primary Nodes, DRM Master and Authentication</a></li>
<li><a class="reference internal" href="#drm-display-resource-leasing">DRM Display Resource Leasing</a></li>
<li><a class="reference internal" href="#open-source-userspace-requirements">Open-Source Userspace Requirements</a></li>
<li><a class="reference internal" href="#render-nodes">Render nodes</a></li>
<li><a class="reference internal" href="#device-hot-unplug">Device Hot-Unplug</a><ul>
<li><a class="reference internal" href="#requirements-for-kms-uapi">Requirements for KMS UAPI</a></li>
<li><a class="reference internal" href="#requirements-for-render-and-cross-device-uapi">Requirements for Render and Cross-Device UAPI</a></li>
<li><a class="reference internal" href="#requirements-for-memory-maps">Requirements for Memory Maps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ioctl-support-on-device-nodes">IOCTL Support on Device Nodes</a><ul>
<li><a class="reference internal" href="#recommended-ioctl-return-values">Recommended IOCTL Return Values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing-and-validation">Testing and validation</a><ul>
<li><a class="reference internal" href="#testing-requirements-for-userspace-api">Testing Requirements for userspace API</a></li>
<li><a class="reference internal" href="#validating-changes-with-igt">Validating changes with IGT</a></li>
<li><a class="reference internal" href="#using-vkms-to-test-drm-api">Using VKMS to test DRM API</a></li>
<li><a class="reference internal" href="#display-crc-support">Display CRC Support</a></li>
<li><a class="reference internal" href="#debugfs-support">Debugfs Support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sysfs-support">Sysfs Support</a></li>
<li><a class="reference internal" href="#vblank-event-handling">VBlank event handling</a></li>
<li><a class="reference internal" href="#userspace-api-structures">Userspace API Structures</a><ul>
<li><a class="reference internal" href="#crtc-index">CRTC index</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/gpu/drm-uapi.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/gpu/drm-uapi.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>