
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Mode Setting Helper Functions &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Userland interfaces" href="drm-uapi.html" />
    <link rel="prev" title="Kernel Mode Setting (KMS)" href="drm-kms.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="mode-setting-helper-functions">
<h1>Mode Setting Helper Functions<a class="headerlink" href="#mode-setting-helper-functions" title="Permalink to this headline">¶</a></h1>
<p>The DRM subsystem aims for a strong separation between core code and helper
libraries. Core code takes care of general setup and teardown and decoding
userspace requests to kernel internal objects. Everything else is handled by a
large set of helper libraries, which can be combined freely to pick and choose
for each driver what fits, and avoid shared code where special behaviour is
needed.</p>
<p>This distinction between core code and helpers is especially strong in the
modesetting code, where there’s a shared userspace ABI for all drivers. This is
in contrast to the render side, where pretty much everything (with very few
exceptions) can be considered optional helper code.</p>
<p>There are a few areas these helpers can grouped into:</p>
<ul class="simple">
<li><p>Helpers to implement modesetting. The important ones here are the atomic
helpers. Old drivers still often use the legacy CRTC helpers. They both share
the same set of common helper vtables. For really simple drivers (anything
that would have been a great fit in the deprecated fbdev subsystem) there’s
also the simple display pipe helpers.</p></li>
<li><p>There’s a big pile of helpers for handling outputs. First the generic bridge
helpers for handling encoder and transcoder IP blocks. Second the panel helpers
for handling panel-related information and logic. Plus then a big set of
helpers for the various sink standards (DisplayPort, HDMI, MIPI DSI). Finally
there’s also generic helpers for handling output probing, and for dealing with
EDIDs.</p></li>
<li><p>The last group of helpers concerns itself with the frontend side of a display
pipeline: Planes, handling rectangles for visibility checking and scissoring,
flip queues and assorted bits.</p></li>
</ul>
<section id="modeset-helper-reference-for-common-vtables">
<h2>Modeset Helper Reference for Common Vtables<a class="headerlink" href="#modeset-helper-reference-for-common-vtables" title="Permalink to this headline">¶</a></h2>
<p>The DRM mode setting helper functions are common code for drivers to use if
they wish.  Drivers are not forced to use this code in their
implementations but it would be useful if the code they do use at least
provides a consistent interface and operation to userspace. Therefore it is
highly recommended to use the provided helpers as much as possible.</p>
<p>Because there is only one pointer per modeset object to hold a vfunc table
for helper libraries they are by necessity shared among the different
helpers.</p>
<p>To make this clear all the helper vtables are pulled together in this location here.</p>
<dl class="type">
<dt id="c.drm_crtc_helper_funcs">
struct <code class="sig-name descname">drm_crtc_helper_funcs</code><a class="headerlink" href="#c.drm_crtc_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for CRTCs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_crtc_helper_funcs {
    void (*dpms)(struct drm_crtc *crtc, int mode);
    void (*prepare)(struct drm_crtc *crtc);
    void (*commit)(struct drm_crtc *crtc);
    enum drm_mode_status (*mode_valid)(struct drm_crtc *crtc, const struct drm_display_mode *mode);
    bool (*mode_fixup)(struct drm_crtc *crtc,const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
    int (*mode_set)(struct drm_crtc *crtc, struct drm_display_mode *mode,struct drm_display_mode *adjusted_mode, int x, int y, struct drm_framebuffer *old_fb);
    void (*mode_set_nofb)(struct drm_crtc *crtc);
    int (*mode_set_base)(struct drm_crtc *crtc, int x, int y, struct drm_framebuffer *old_fb);
    int (*mode_set_base_atomic)(struct drm_crtc *crtc,struct drm_framebuffer *fb, int x, int y, enum mode_set_atomic);
    void (*disable)(struct drm_crtc *crtc);
    int (*atomic_check)(struct drm_crtc *crtc, struct drm_atomic_state *state);
    void (*atomic_begin)(struct drm_crtc *crtc, struct drm_atomic_state *state);
    void (*atomic_flush)(struct drm_crtc *crtc, struct drm_atomic_state *state);
    void (*atomic_enable)(struct drm_crtc *crtc, struct drm_atomic_state *state);
    void (*atomic_disable)(struct drm_crtc *crtc, struct drm_atomic_state *state);
    bool (*get_scanout_position)(struct drm_crtc *crtc,bool in_vblank_irq, int *vpos, int *hpos,ktime_t *stime, ktime_t *etime, const struct drm_display_mode *mode);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dpms</span></code></dt><dd><p>Callback to control power levels on the CRTC.  If the mode passed in
is unsupported, the provider must use the next lowest power level.
This is used by the legacy CRTC helpers to implement DPMS
functionality in <a class="reference internal" href="#c.drm_helper_connector_dpms" title="drm_helper_connector_dpms"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_connector_dpms()</span></code></a>.</p>
<p>This callback is also used to disable a CRTC by calling it with
DRM_MODE_DPMS_OFF if the <strong>disable</strong> hook isn’t used.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling and disabling a CRTC to
facilitate transitions to atomic, but it is deprecated. Instead
<strong>atomic_enable</strong> and <strong>atomic_disable</strong> should be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare</span></code></dt><dd><p>This callback should prepare the CRTC for a subsequent modeset, which
in practice means the driver should disable the CRTC if it is
running. Most drivers ended up implementing this by calling their
<strong>dpms</strong> hook with DRM_MODE_DPMS_OFF.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for disabling a CRTC to facilitate
transitions to atomic, but it is deprecated. Instead <strong>atomic_disable</strong>
should be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit</span></code></dt><dd><p>This callback should commit the new mode on the CRTC after a modeset,
which in practice means the driver should enable the CRTC.  Most
drivers ended up implementing this by calling their <strong>dpms</strong> hook with
DRM_MODE_DPMS_ON.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling a CRTC to facilitate
transitions to atomic, but it is deprecated. Instead <strong>atomic_enable</strong>
should be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid</span></code></dt><dd><p>This callback is used to check if a specific mode is valid in this
crtc. This should be implemented if the crtc has some sort of
restriction in the modes it can display. For example, a given crtc
may be responsible to set a clock value. If the clock can not
produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong> or <strong>atomic_check</strong>.</p>
<p>RETURNS:</p>
<p>drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_fixup</span></code></dt><dd><p>This callback is used to validate a mode. The parameter mode is the
display mode that userspace requested, adjusted_mode is the mode the
encoders need to be fed with. Note that this is the inverse semantics
of the meaning for the <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup</span></code></a>
vfunc. If the CRTC cannot support the requested conversion from mode
to adjusted_mode it should reject the modeset. See also
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This function is used by both legacy CRTC helpers and atomic helpers.
With atomic helpers it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace’s request to
just check whether a configuration would be possible). Atomic drivers
MUST NOT touch any persistent state (hardware or software) or data
structures except the passed in adjusted_mode parameter.</p>
<p>This is in contrast to the legacy CRTC helpers where this was
allowed.</p>
<p>Atomic drivers which need to inspect and adjust more state should
instead use the <strong>atomic_check</strong> callback, but note that they’re not
perfectly equivalent: <strong>mode_valid</strong> is called from
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>, but <strong>atomic_check</strong> is called from
<a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_planes()</span></code></a>, because originally it was meant for
plane update checks only.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any CRTC constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p>True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set</span></code></dt><dd><p>This callback is used by the legacy CRTC helpers to set a new mode,
position and framebuffer. Since it ties the primary plane to every
mode change it is incompatible with universal plane support. And
since it can’t update other planes it’s incompatible with atomic
modeset support.</p>
<p>This callback is only used by CRTC helpers and deprecated.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set_nofb</span></code></dt><dd><p>This callback is used to update the display mode of a CRTC without
changing anything of the primary plane configuration. This fits the
requirement of atomic and hence is used by the atomic helpers. It is
also used by the transitional plane helpers to implement a
<strong>mode_set</strong> hook in drm_helper_crtc_mode_set().</p>
<p>Note that the display pipe is completely off when this function is
called. Atomic drivers which need hardware to be running before they
program the new display mode (e.g. because they implement runtime PM)
should not use this hook. This is because the helper library calls
this hook only once per mode change and not every time the display
pipeline is suspended using either DPMS or the new “ACTIVE” property.
Which means register values set in this callback might get reset when
the CRTC is suspended, but not restored.  Such drivers should instead
move all their CRTC setup into the <strong>atomic_enable</strong> callback.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set_base</span></code></dt><dd><p>This callback is used by the legacy CRTC helpers to set a new
framebuffer and scanout position. It is optional and used as an
optimized fast-path instead of a full mode set operation with all the
resulting flickering. If it is not present
<a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_helper_set_config()</span></code></a> will fall back to a full modeset, using
the <strong>mode_set</strong> callback. Since it can’t update other planes it’s
incompatible with atomic modeset support.</p>
<p>This callback is only used by the CRTC helpers and deprecated.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set_base_atomic</span></code></dt><dd><p>This callback is used by the fbdev helpers to set a new framebuffer
and scanout without sleeping, i.e. from an atomic calling context. It
is only used to implement kgdb support.</p>
<p>This callback is optional and only needed for kgdb support in the fbdev
helpers.</p>
<p>RETURNS:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>This callback should be used to disable the CRTC. With the atomic
drivers it is called after all encoders connected to this CRTC have
been shut off already using their own
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a> hook. If that sequence is too
simple drivers can just add their own hooks and call it from this
CRTC callback here by looping over all encoders connected to it using
for_each_encoder_on_crtc().</p>
<p>This hook is used both by legacy CRTC helpers and atomic helpers.
Atomic drivers don’t need to implement it if there’s no need to
disable anything at the CRTC level. To ensure that runtime PM
handling (using either DPMS or the new “ACTIVE” property) works
<strong>disable</strong> must be the inverse of <strong>atomic_enable</strong> for atomic drivers.
Atomic drivers should consider to use <strong>atomic_disable</strong> instead of
this one.</p>
<p>NOTE:</p>
<p>With legacy CRTC helpers there’s a big semantic difference between
<strong>disable</strong> and other hooks (like <strong>prepare</strong> or <strong>dpms</strong>) used to shut down a
CRTC: <strong>disable</strong> is only called when also logically disabling the
display pipeline and needs to release any resources acquired in
<strong>mode_set</strong> (like shared PLLs, or again release pinned framebuffers).</p>
<p>Therefore <strong>disable</strong> must be the inverse of <strong>mode_set</strong> plus <strong>commit</strong> for
drivers still using legacy CRTC helpers, which is different from the
rules under atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_check</span></code></dt><dd><p>Drivers should check plane-update related CRTC constraints in this
hook. They can also check mode related limitations but need to be
aware of the calling order, since this hook is used by
<a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_planes()</span></code></a> whereas the preparations needed to
check output routing and the display mode is done in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>. Therefore drivers that want to
check output routing and display mode constraints in this callback
must ensure that <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a> has been called
beforehand. This is calling order used by the default helper
implementation in <a class="reference internal" href="#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check()</span></code></a>.</p>
<p>When using <a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_planes()</span></code></a> this hook is called
after the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.atomic_check</span></code></a> hook for planes, which
allows drivers to assign shared resources requested by planes in this
callback here. For more complicated dependencies the driver can call
the provided check helpers multiple times until the computed state
has a final configuration and everything has been checked.</p>
<p>This function is also allowed to inspect any other object’s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state object passed-in.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any CRTC constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the state or the transition can’t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_begin</span></code></dt><dd><p>Drivers should prepare for an atomic update of multiple planes on
a CRTC in this hook. Depending upon hardware this might be vblank
evasion, blocking updates by setting bits or doing preparatory work
for e.g. manual update display.</p>
<p>This hook is called before any plane commit functions are called.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_flush</span></code></dt><dd><p>Drivers should finalize an atomic update of multiple planes on
a CRTC in this hook. Depending upon hardware this might include
checking that vblank evasion was successful, unblocking updates by
setting bits or setting the GO bit to flush out all updates.</p>
<p>Simple hardware or hardware with special requirements can commit and
flush out all updates for all planes from this hook and forgo all the
other commit hooks for plane updates.</p>
<p>This hook is called after any plane commit functions are called.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_enable</span></code></dt><dd><p>This callback should be used to enable the CRTC. With the atomic
drivers it is called before all encoders connected to this CRTC are
enabled through the encoder’s own <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>
hook.  If that sequence is too simple drivers can just add their own
hooks and call it from this CRTC callback here by looping over all
encoders connected to it using for_each_encoder_on_crtc().</p>
<p>This hook is used only by atomic helpers, for symmetry with
<strong>atomic_disable</strong>. Atomic drivers don’t need to implement it if there’s
no need to enable anything at the CRTC level. To ensure that runtime
PM handling (using either DPMS or the new “ACTIVE” property) works
<strong>atomic_enable</strong> must be the inverse of <strong>atomic_disable</strong> for atomic
drivers.</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_disable</span></code></dt><dd><p>This callback should be used to disable the CRTC. With the atomic
drivers it is called after all encoders connected to this CRTC have
been shut off already using their own
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a> hook. If that sequence is too
simple drivers can just add their own hooks and call it from this
CRTC callback here by looping over all encoders connected to it using
for_each_encoder_on_crtc().</p>
<p>This hook is used only by atomic helpers. Atomic drivers don’t
need to implement it if there’s no need to disable anything at the
CRTC level.</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_scanout_position</span></code></dt><dd><p>Called by vblank timestamping code.</p>
<p>Returns the current display scanout position from a CRTC and an
optional accurate <a class="reference internal" href="../core-api/timekeeping.html#c.ktime_get" title="ktime_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">ktime_get()</span></code></a> timestamp of when the position was
measured. Note that this is a helper callback which is only used
if a driver uses <a class="reference internal" href="drm-kms.html#c.drm_crtc_vblank_helper_get_vblank_timestamp" title="drm_crtc_vblank_helper_get_vblank_timestamp"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_vblank_helper_get_vblank_timestamp()</span></code></a>
for the <strong>drm_crtc_funcs.get_vblank_timestamp</strong> callback.</p>
<p>Parameters:</p>
<dl class="simple">
<dt>crtc:</dt><dd><p>The CRTC.</p>
</dd>
<dt>in_vblank_irq:</dt><dd><p>True when called from <a class="reference internal" href="drm-kms.html#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_handle_vblank()</span></code></a>. Some drivers
need to apply some workarounds for gpu-specific vblank irq
quirks if the flag is set.</p>
</dd>
<dt>vpos:</dt><dd><p>Target location for current vertical scanout position.</p>
</dd>
<dt>hpos:</dt><dd><p>Target location for current horizontal scanout position.</p>
</dd>
<dt>stime:</dt><dd><p>Target location for timestamp taken immediately before
scanout position query. Can be NULL to skip timestamp.</p>
</dd>
<dt>etime:</dt><dd><p>Target location for timestamp taken immediately after
scanout position query. Can be NULL to skip timestamp.</p>
</dd>
<dt>mode:</dt><dd><p>Current display timings.</p>
</dd>
</dl>
<p>Returns vpos as a positive number while in active scanout area.
Returns vpos as a negative number inside vblank, counting the number
of scanlines to go until end of vblank, e.g., -1 means “one scanline
until start of active scanout / end of vblank.”</p>
<p>Returns:</p>
<p>True on success, false if a reliable scanout position counter could
not be read out.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These hooks are used by the legacy CRTC helpers, the transitional plane
helpers and the new atomic modesetting helpers.</p>
<dl class="function">
<dt id="c.drm_crtc_helper_add">
void <code class="sig-name descname">drm_crtc_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, const struct <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs">drm_crtc_helper_funcs</a><em> *funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a crtc</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>DRM CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_helper_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>helper vtable to set for <strong>crtc</strong></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_encoder_helper_funcs">
struct <code class="sig-name descname">drm_encoder_helper_funcs</code><a class="headerlink" href="#c.drm_encoder_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for encoders</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_encoder_helper_funcs {
    void (*dpms)(struct drm_encoder *encoder, int mode);
    enum drm_mode_status (*mode_valid)(struct drm_encoder *crtc, const struct drm_display_mode *mode);
    bool (*mode_fixup)(struct drm_encoder *encoder,const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
    void (*prepare)(struct drm_encoder *encoder);
    void (*commit)(struct drm_encoder *encoder);
    void (*mode_set)(struct drm_encoder *encoder,struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
    void (*atomic_mode_set)(struct drm_encoder *encoder,struct drm_crtc_state *crtc_state, struct drm_connector_state *conn_state);
    enum drm_connector_status (*detect)(struct drm_encoder *encoder, struct drm_connector *connector);
    void (*atomic_disable)(struct drm_encoder *encoder, struct drm_atomic_state *state);
    void (*atomic_enable)(struct drm_encoder *encoder, struct drm_atomic_state *state);
    void (*disable)(struct drm_encoder *encoder);
    void (*enable)(struct drm_encoder *encoder);
    int (*atomic_check)(struct drm_encoder *encoder,struct drm_crtc_state *crtc_state, struct drm_connector_state *conn_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dpms</span></code></dt><dd><p>Callback to control power levels on the encoder.  If the mode passed in
is unsupported, the provider must use the next lowest power level.
This is used by the legacy encoder helpers to implement DPMS
functionality in <a class="reference internal" href="#c.drm_helper_connector_dpms" title="drm_helper_connector_dpms"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_connector_dpms()</span></code></a>.</p>
<p>This callback is also used to disable an encoder by calling it with
DRM_MODE_DPMS_OFF if the <strong>disable</strong> hook isn’t used.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling and disabling an encoder to
facilitate transitions to atomic, but it is deprecated. Instead
<strong>enable</strong> and <strong>disable</strong> should be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid</span></code></dt><dd><p>This callback is used to check if a specific mode is valid in this
encoder. This should be implemented if the encoder has some sort
of restriction in the modes it can display. For example, a given
encoder may be responsible to set a clock value. If the clock can
not produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong> or <strong>atomic_check</strong>.</p>
<p>RETURNS:</p>
<p>drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_fixup</span></code></dt><dd><p>This callback is used to validate and adjust a mode. The parameter
mode is the display mode that should be fed to the next element in
the display chain, either the final <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> or a <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a>.
The parameter adjusted_mode is the input mode the encoder requires. It
can be modified by this callback and does not need to match mode. See
also <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This function is used by both legacy CRTC helpers and atomic helpers.
This hook is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace’s request to
just check whether a configuration would be possible). Atomic drivers
MUST NOT touch any persistent state (hardware or software) or data
structures except the passed in adjusted_mode parameter.</p>
<p>This is in contrast to the legacy CRTC helpers where this was
allowed.</p>
<p>Atomic drivers which need to inspect and adjust more state should
instead use the <strong>atomic_check</strong> callback. If <strong>atomic_check</strong> is used,
this hook isn’t called since <strong>atomic_check</strong> allows a strict superset
of the functionality of <strong>mode_fixup</strong>.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any encoder constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p>True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare</span></code></dt><dd><p>This callback should prepare the encoder for a subsequent modeset,
which in practice means the driver should disable the encoder if it
is running. Most drivers ended up implementing this by calling their
<strong>dpms</strong> hook with DRM_MODE_DPMS_OFF.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for disabling an encoder to facilitate
transitions to atomic, but it is deprecated. Instead <strong>disable</strong> should
be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit</span></code></dt><dd><p>This callback should commit the new mode on the encoder after a modeset,
which in practice means the driver should enable the encoder.  Most
drivers ended up implementing this by calling their <strong>dpms</strong> hook with
DRM_MODE_DPMS_ON.</p>
<p>This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling an encoder to facilitate
transitions to atomic, but it is deprecated. Instead <strong>enable</strong> should
be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set</span></code></dt><dd><p>This callback is used to update the display mode of an encoder.</p>
<p>Note that the display pipe is completely off when this function is
called. Drivers which need hardware to be running before they program
the new display mode (because they implement runtime PM) should not
use this hook, because the helper library calls it only once and not
every time the display pipeline is suspend using either DPMS or the
new “ACTIVE” property. Such drivers should instead move all their
encoder setup into the <strong>enable</strong> callback.</p>
<p>This callback is used both by the legacy CRTC helpers and the atomic
modeset helpers. It is optional in the atomic helpers.</p>
<p>NOTE:</p>
<p>If the driver uses the atomic modeset helpers and needs to inspect
the connector state or connector display info during mode setting,
<strong>atomic_mode_set</strong> can be used instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_mode_set</span></code></dt><dd><p>This callback is used to update the display mode of an encoder.</p>
<p>Note that the display pipe is completely off when this function is
called. Drivers which need hardware to be running before they program
the new display mode (because they implement runtime PM) should not
use this hook, because the helper library calls it only once and not
every time the display pipeline is suspended using either DPMS or the
new “ACTIVE” property. Such drivers should instead move all their
encoder setup into the <strong>enable</strong> callback.</p>
<p>This callback is used by the atomic modeset helpers in place of the
<strong>mode_set</strong> callback, if set by the driver. It is optional and should
be used instead of <strong>mode_set</strong> if the driver needs to inspect the
connector state or display info, since there is no direct way to
go from the encoder to the current connector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detect</span></code></dt><dd><p>This callback can be used by drivers who want to do detection on the
encoder object instead of in connector functions.</p>
<p>It is not used by any helper and therefore has purely driver-specific
semantics. New drivers shouldn’t use this and instead just implement
their own private callbacks.</p>
<p>FIXME:</p>
<p>This should just be converted into a pile of driver vfuncs.
Currently radeon, amdgpu and nouveau are using it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_disable</span></code></dt><dd><p>This callback should be used to disable the encoder. With the atomic
drivers it is called before this encoder’s CRTC has been shut off
using their own <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_disable</span></code></a> hook. If that
sequence is too simple drivers can just add their own driver private
encoder hooks and call them from CRTC’s callback by looping over all
encoders connected to it using for_each_encoder_on_crtc().</p>
<p>This callback is a variant of <strong>disable</strong> that provides the atomic state
to the driver. If <strong>atomic_disable</strong> is implemented, <strong>disable</strong> is not
called by the helpers.</p>
<p>This hook is only used by atomic helpers. Atomic drivers don’t need
to implement it if there’s no need to disable anything at the encoder
level. To ensure that runtime PM handling (using either DPMS or the
new “ACTIVE” property) works <strong>atomic_disable</strong> must be the inverse of
<strong>atomic_enable</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_enable</span></code></dt><dd><p>This callback should be used to enable the encoder. It is called
after this encoder’s CRTC has been enabled using their own
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_enable</span></code></a> hook. If that sequence is
too simple drivers can just add their own driver private encoder
hooks and call them from CRTC’s callback by looping over all encoders
connected to it using for_each_encoder_on_crtc().</p>
<p>This callback is a variant of <strong>enable</strong> that provides the atomic state
to the driver. If <strong>atomic_enable</strong> is implemented, <strong>enable</strong> is not
called by the helpers.</p>
<p>This hook is only used by atomic helpers, it is the opposite of
<strong>atomic_disable</strong>. Atomic drivers don’t need to implement it if there’s
no need to enable anything at the encoder level. To ensure that
runtime PM handling works <strong>atomic_enable</strong> must be the inverse of
<strong>atomic_disable</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>This callback should be used to disable the encoder. With the atomic
drivers it is called before this encoder’s CRTC has been shut off
using their own <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.disable</span></code></a> hook.  If that
sequence is too simple drivers can just add their own driver private
encoder hooks and call them from CRTC’s callback by looping over all
encoders connected to it using for_each_encoder_on_crtc().</p>
<p>This hook is used both by legacy CRTC helpers and atomic helpers.
Atomic drivers don’t need to implement it if there’s no need to
disable anything at the encoder level. To ensure that runtime PM
handling (using either DPMS or the new “ACTIVE” property) works
<strong>disable</strong> must be the inverse of <strong>enable</strong> for atomic drivers.</p>
<p>For atomic drivers also consider <strong>atomic_disable</strong> and save yourself
from having to read the NOTE below!</p>
<p>NOTE:</p>
<p>With legacy CRTC helpers there’s a big semantic difference between
<strong>disable</strong> and other hooks (like <strong>prepare</strong> or <strong>dpms</strong>) used to shut down a
encoder: <strong>disable</strong> is only called when also logically disabling the
display pipeline and needs to release any resources acquired in
<strong>mode_set</strong> (like shared PLLs, or again release pinned framebuffers).</p>
<p>Therefore <strong>disable</strong> must be the inverse of <strong>mode_set</strong> plus <strong>commit</strong> for
drivers still using legacy CRTC helpers, which is different from the
rules under atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>This callback should be used to enable the encoder. With the atomic
drivers it is called after this encoder’s CRTC has been enabled using
their own <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.enable</span></code></a> hook.  If that sequence is
too simple drivers can just add their own driver private encoder
hooks and call them from CRTC’s callback by looping over all encoders
connected to it using for_each_encoder_on_crtc().</p>
<p>This hook is only used by atomic helpers, it is the opposite of
<strong>disable</strong>. Atomic drivers don’t need to implement it if there’s no
need to enable anything at the encoder level. To ensure that
runtime PM handling (using either DPMS or the new “ACTIVE” property)
works <strong>enable</strong> must be the inverse of <strong>disable</strong> for atomic drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_check</span></code></dt><dd><p>This callback is used to validate encoder state for atomic drivers.
Since the encoder is the object connecting the CRTC and connector it
gets passed both states, to be able to validate interactions and
update the CRTC to match what the encoder needs for the requested
connector.</p>
<p>Since this provides a strict superset of the functionality of
<strong>mode_fixup</strong> (the requested and adjusted modes are both available
through the passed in <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>) <strong>mode_fixup</strong> is not
called when <strong>atomic_check</strong> is implemented.</p>
<p>This function is used by the atomic helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any encoder constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the state or the transition can’t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These hooks are used by the legacy CRTC helpers, the transitional plane
helpers and the new atomic modesetting helpers.</p>
<dl class="function">
<dt id="c.drm_encoder_helper_add">
void <code class="sig-name descname">drm_encoder_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a><em> *encoder</em>, const struct <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs">drm_encoder_helper_funcs</a><em> *funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for an encoder</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>DRM encoder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder_helper_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>helper vtable to set for <strong>encoder</strong></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_connector_helper_funcs">
struct <code class="sig-name descname">drm_connector_helper_funcs</code><a class="headerlink" href="#c.drm_connector_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for connectors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_connector_helper_funcs {
    int (*get_modes)(struct drm_connector *connector);
    int (*detect_ctx)(struct drm_connector *connector,struct drm_modeset_acquire_ctx *ctx, bool force);
    enum drm_mode_status (*mode_valid)(struct drm_connector *connector, struct drm_display_mode *mode);
    int (*mode_valid_ctx)(struct drm_connector *connector,struct drm_display_mode *mode,struct drm_modeset_acquire_ctx *ctx, enum drm_mode_status *status);
    struct drm_encoder *(*best_encoder)(struct drm_connector *connector);
    struct drm_encoder *(*atomic_best_encoder)(struct drm_connector *connector, struct drm_atomic_state *state);
    int (*atomic_check)(struct drm_connector *connector, struct drm_atomic_state *state);
    void (*atomic_commit)(struct drm_connector *connector, struct drm_atomic_state *state);
    int (*prepare_writeback_job)(struct drm_writeback_connector *connector, struct drm_writeback_job *job);
    void (*cleanup_writeback_job)(struct drm_writeback_connector *connector, struct drm_writeback_job *job);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">get_modes</span></code></dt><dd><p>This function should fill in all modes currently valid for the sink
into the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.probed_modes</span></code></a> list. It should also update the
EDID property by calling <a class="reference internal" href="#c.drm_connector_update_edid_property" title="drm_connector_update_edid_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_update_edid_property()</span></code></a>.</p>
<p>The usual way to implement this is to cache the EDID retrieved in the
probe callback somewhere in the driver-private connector structure.
In this function drivers then parse the modes in the EDID and add
them by calling <a class="reference internal" href="#c.drm_add_edid_modes" title="drm_add_edid_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_add_edid_modes()</span></code></a>. But connectors that drive a
fixed panel can also manually add specific modes using
<a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_probed_add()</span></code></a>. Drivers which manually add modes should also
make sure that the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.display_info</span></code></a>,
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.width_mm</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.height_mm</span></code></a> fields are
filled in.</p>
<p>Note that the caller function will automatically add standard VESA
DMT modes up to 1024x768 if the .get_modes() helper operation returns
no mode and if the connector status is connector_status_connected or
connector_status_unknown. There is no need to call
<a class="reference internal" href="#c.drm_add_modes_noedid" title="drm_add_modes_noedid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_add_modes_noedid()</span></code></a> manually in that case.</p>
<p>Virtual drivers that just want some standard VESA mode with a given
resolution can call <a class="reference internal" href="#c.drm_add_modes_noedid" title="drm_add_modes_noedid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_add_modes_noedid()</span></code></a>, and mark the preferred
one using <a class="reference internal" href="#c.drm_set_preferred_mode" title="drm_set_preferred_mode"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_set_preferred_mode()</span></code></a>.</p>
<p>This function is only called after the <strong>detect</strong> hook has indicated
that a sink is connected and when the EDID isn’t overridden through
sysfs or the kernel commandline.</p>
<p>This callback is used by the probe helpers in e.g.
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>.</p>
<p>To avoid races with concurrent connector state updates, the helper
libraries always call this with the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connection_mutex</span></code></a>
held. Because of this it’s safe to inspect <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector-&gt;state</span></code></a>.</p>
<p>RETURNS:</p>
<p>The number of modes added by calling <a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_probed_add()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detect_ctx</span></code></dt><dd><p>Check to see if anything is attached to the connector. The parameter
force is set to false whilst polling, true when checking the
connector due to a user request. force can be used by the driver to
avoid expensive, destructive operations during automated probing.</p>
<p>This callback is optional, if not implemented the connector will be
considered as always being attached.</p>
<p>This is the atomic version of <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.detect</span></code></a>.</p>
<p>To avoid races against concurrent connector state updates, the
helper libraries always call this with ctx set to a valid context,
and <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connection_mutex</span></code></a> will always be locked with
the ctx parameter set to this ctx. This allows taking additional
locks as required.</p>
<p>RETURNS:</p>
<p><a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_status</span></code></a> indicating the connector’s status,
or the error code returned by <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_lock()</span></code></a>, -EDEADLK.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid</span></code></dt><dd><p>Callback to validate a mode for a connector, irrespective of the
specific display configuration.</p>
<p>This callback is used by the probe helpers to filter the mode list
(which is usually derived from the EDID data block from the sink).
See e.g. <a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>This only filters the mode list supplied to userspace in the
GETCONNECTOR IOCTL. Compared to <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.mode_valid</span></code></a>,
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.mode_valid</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a>,
which are also called by the atomic helpers from
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>. This allows userspace to force and
ignore sink constraint (like the pixel clock limits in the screen’s
EDID), which is useful for e.g. testing, or working around a broken
EDID. Any source hardware constraint (which always need to be
enforced) therefore should be checked in one of the above callbacks,
and not this one here.</p>
<p>To avoid races with concurrent connector state updates, the helper
libraries always call this with the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connection_mutex</span></code></a>
held. Because of this it’s safe to inspect <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector-&gt;state</span></code></a>.</p>
<p>RETURNS:</p>
<p>Either <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_status.MODE_OK</span></code></a> or one of the failure reasons in <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span>
<span class="pre">drm_mode_status</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid_ctx</span></code></dt><dd><p>Callback to validate a mode for a connector, irrespective of the
specific display configuration.</p>
<p>This callback is used by the probe helpers to filter the mode list
(which is usually derived from the EDID data block from the sink).
See e.g. <a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>.</p>
<p>This function is optional, and is the atomic version of
<a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.mode_valid</span></code></a>.</p>
<p>To allow for accessing the atomic state of modesetting objects, the
helper libraries always call this with ctx set to a valid context,
and <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.connection_mutex</span></code></a> will always be locked with
the ctx parameter set to <strong>ctx</strong>. This allows for taking additional
locks as required.</p>
<p>Even though additional locks may be acquired, this callback is
still expected not to take any constraints into account which would
be influenced by the currently set display state - such constraints
should be handled in the driver’s atomic check. For example, if a
connector shares display bandwidth with other connectors then it
would be ok to validate the minimum bandwidth requirement of a mode
against the maximum possible bandwidth of the connector. But it
wouldn’t be ok to take the current bandwidth usage of other
connectors into account, as this would change depending on the
display state.</p>
<p>Returns:
0 if <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.mode_valid_ctx</span></code></a> succeeded and wrote
the <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_mode_status</span></code></a> value to <strong>status</strong>, or a negative error
code otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">best_encoder</span></code></dt><dd><p>This function should select the best encoder for the given connector.</p>
<p>This function is used by both the atomic helpers (in the
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a> function) and in the legacy CRTC
helpers.</p>
<p>NOTE:</p>
<p>In atomic drivers this function is called in the check phase of an
atomic update. The driver is not allowed to change or inspect
anything outside of arguments passed-in. Atomic drivers which need to
inspect dynamic configuration state should instead use
<strong>atomic_best_encoder</strong>.</p>
<p>You can leave this function to NULL if the connector is only
attached to a single encoder. In this case, the core will call
drm_connector_get_single_encoder() for you.</p>
<p>RETURNS:</p>
<p>Encoder that should be used for the given connector and connector
state, or NULL if no suitable encoder exists. Note that the helpers
will ensure that encoders aren’t used twice, drivers should not check
for this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_best_encoder</span></code></dt><dd><p>This is the atomic version of <strong>best_encoder</strong> for atomic drivers which
need to select the best encoder depending upon the desired
configuration and can’t select it statically.</p>
<p>This function is used by <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.
If it is not implemented, the core will fallback to <strong>best_encoder</strong>
(or drm_connector_get_single_encoder() if <strong>best_encoder</strong> is NULL).</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the
<a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> update tracking structure passed in.</p>
<p>RETURNS:</p>
<p>Encoder that should be used for the given connector and connector
state, or NULL if no suitable encoder exists. Note that the helpers
will ensure that encoders aren’t used twice, drivers should not check
for this.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_check</span></code></dt><dd><p>This hook is used to validate connector state. This function is
called from <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset</span></code></a>, and is called when
a connector property is set, or a modeset on the crtc is forced.</p>
<p>Because <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset</span></code></a> may be called multiple times,
this function should handle being called multiple times as well.</p>
<p>This function is also allowed to inspect any other object’s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the state or the transition can’t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_commit</span></code></dt><dd><p>This hook is to be used by drivers implementing writeback connectors
that need a point when to commit the writeback job to the hardware.
The writeback_job to commit is available in the new connector state,
in <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.writeback_job</span></code></a>.</p>
<p>This hook is optional.</p>
<p>This callback is used by the atomic modeset helpers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_writeback_job</span></code></dt><dd><p>As writeback jobs contain a framebuffer, drivers may need to
prepare and clean them up the same way they can prepare and
clean up framebuffers for planes. This optional connector operation
is used to support the preparation of writeback jobs. The job
prepare operation is called from <a class="reference internal" href="#c.drm_atomic_helper_prepare_planes" title="drm_atomic_helper_prepare_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_prepare_planes()</span></code></a>
for struct <a class="reference internal" href="drm-kms.html#c.drm_writeback_connector" title="drm_writeback_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_writeback_connector</span></code></a> connectors only.</p>
<p>This operation is optional.</p>
<p>This callback is used by the atomic modeset helpers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup_writeback_job</span></code></dt><dd><p>This optional connector operation is used to support the
cleanup of writeback jobs. The job cleanup operation is called
from the existing drm_writeback_cleanup_job() function, invoked
both when destroying the job as part of an aborted commit, or when
the job completes.</p>
<p>This operation is optional.</p>
<p>This callback is used by the atomic modeset helpers.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These functions are used by the atomic and legacy modeset helpers and by the
probe helpers.</p>
<dl class="function">
<dt id="c.drm_connector_helper_add">
void <code class="sig-name descname">drm_connector_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, const struct <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs">drm_connector_helper_funcs</a><em> *funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a connector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>DRM connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_helper_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>helper vtable to set for <strong>connector</strong></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_plane_helper_funcs">
struct <code class="sig-name descname">drm_plane_helper_funcs</code><a class="headerlink" href="#c.drm_plane_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for planes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_plane_helper_funcs {
    int (*prepare_fb)(struct drm_plane *plane, struct drm_plane_state *new_state);
    void (*cleanup_fb)(struct drm_plane *plane, struct drm_plane_state *old_state);
    int (*begin_fb_access)(struct drm_plane *plane, struct drm_plane_state *new_plane_state);
    void (*end_fb_access)(struct drm_plane *plane, struct drm_plane_state *new_plane_state);
    int (*atomic_check)(struct drm_plane *plane, struct drm_atomic_state *state);
    void (*atomic_update)(struct drm_plane *plane, struct drm_atomic_state *state);
    void (*atomic_disable)(struct drm_plane *plane, struct drm_atomic_state *state);
    int (*atomic_async_check)(struct drm_plane *plane, struct drm_atomic_state *state);
    void (*atomic_async_update)(struct drm_plane *plane, struct drm_atomic_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_fb</span></code></dt><dd><p>This hook is to prepare a framebuffer for scanout by e.g. pinning
its backing storage or relocating it into a contiguous block of
VRAM. Other possible preparatory work includes flushing caches.</p>
<p>This function must not block for outstanding rendering, since it is
called in the context of the atomic IOCTL even for async commits to
be able to return any errors to userspace. Instead the recommended
way is to fill out the <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state.fence</span></code></a> of the passed-in
<a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state</span></code></a>. If the driver doesn’t support native fences then
equivalent functionality should be implemented through private
members in the plane structure.</p>
<p>For GEM drivers who neither have a <strong>prepare_fb</strong> nor <strong>cleanup_fb</strong> hook
set <a class="reference internal" href="#c.drm_gem_plane_helper_prepare_fb" title="drm_gem_plane_helper_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_plane_helper_prepare_fb()</span></code></a> is called automatically to
implement this. Other drivers which need additional plane processing
can call <a class="reference internal" href="#c.drm_gem_plane_helper_prepare_fb" title="drm_gem_plane_helper_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_plane_helper_prepare_fb()</span></code></a> from their <strong>prepare_fb</strong>
hook.</p>
<p>The resources acquired in <strong>prepare_fb</strong> persist after the end of
the atomic commit. Resources that can be release at the commit’s end
should be acquired in <strong>begin_fb_access</strong> and released in <strong>end_fb_access</strong>.
For example, a GEM buffer’s pin operation belongs into <strong>prepare_fb</strong> to
keep the buffer pinned after the commit. But a vmap operation for
shadow-plane helpers belongs into <strong>begin_fb_access</strong>, so that atomic
helpers remove the mapping at the end of the commit.</p>
<p>The helpers will call <strong>cleanup_fb</strong> with matching arguments for every
successful call to this hook.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional. See <strong>begin_fb_access</strong>
for preparing per-commit resources.</p>
<p>RETURNS:</p>
<p>0 on success or one of the following negative error codes allowed by
the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a> vfunc. When using helpers
this callback is the only one which can fail an atomic commit,
everything else must complete successfully.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup_fb</span></code></dt><dd><p>This hook is called to clean up any resources allocated for the given
framebuffer and plane configuration in <strong>prepare_fb</strong>.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">begin_fb_access</span></code></dt><dd><p>This hook prepares the plane for access during an atomic commit.
In contrast to <strong>prepare_fb</strong>, resources acquired in <strong>begin_fb_access</strong>,
are released at the end of the atomic commit in <strong>end_fb_access</strong>.</p>
<p>For example, with shadow-plane helpers, the GEM buffer’s vmap
operation belongs into <strong>begin_fb_access</strong>, so that the buffer’s
memory will be unmapped at the end of the commit in <strong>end_fb_access</strong>.
But a GEM buffer’s pin operation belongs into <strong>prepare_fb</strong>
to keep the buffer pinned after the commit.</p>
<p>The callback is used by the atomic modeset helpers, but it is optional.
See <strong>end_fb_cleanup</strong> for undoing the effects of <strong>begin_fb_access</strong> and
<strong>prepare_fb</strong> for acquiring resources until the next pageflip.</p>
<p>Returns:
0 on success, or a negative errno code otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end_fb_access</span></code></dt><dd><p>This hook cleans up resources allocated by <strong>begin_fb_access</strong>. It it called
at the end of a commit for the new plane state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_check</span></code></dt><dd><p>Drivers should check plane specific constraints in this hook.</p>
<p>When using <a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_planes()</span></code></a> plane’s <strong>atomic_check</strong>
hooks are called before the ones for CRTCs, which allows drivers to
request shared resources that the CRTC controls here. For more
complicated dependencies the driver can call the provided check helpers
multiple times until the computed state has a final configuration and
everything has been checked.</p>
<p>This function is also allowed to inspect any other object’s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the
<a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> update tracking structure.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the state or the transition can’t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_update</span></code></dt><dd><p>Drivers should use this function to update the plane state.  This
hook is called in-between the <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_begin</span></code></a> and
drm_crtc_helper_funcs.atomic_flush callbacks.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_disable</span></code></dt><dd><p>Drivers should use this function to unconditionally disable a plane.
This hook is called in-between the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_begin</span></code></a> and
drm_crtc_helper_funcs.atomic_flush callbacks. It is an alternative to
<strong>atomic_update</strong>, which will be called for disabling planes, too, if
the <strong>atomic_disable</strong> hook isn’t implemented.</p>
<p>This hook is also useful to disable planes in preparation of a modeset,
by calling <a class="reference internal" href="#c.drm_atomic_helper_disable_planes_on_crtc" title="drm_atomic_helper_disable_planes_on_crtc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_planes_on_crtc()</span></code></a> from the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.disable</span></code></a> hook.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_async_check</span></code></dt><dd><p>Drivers should set this function pointer to check if the plane’s
atomic state can be updated in a async fashion. Here async means
“not vblank synchronized”.</p>
<p>This hook is called by drm_atomic_async_check() to establish if a
given update can be committed asynchronously, that is, if it can
jump ahead of the state currently queued for update.</p>
<p>RETURNS:</p>
<p>Return 0 on success and any error returned indicates that the update
can not be applied in asynchronous manner.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_async_update</span></code></dt><dd><p>Drivers should set this function pointer to perform asynchronous
updates of planes, that is, jump ahead of the currently queued
state and update the plane. Here async means “not vblank
synchronized”.</p>
<p>This hook is called by <a class="reference internal" href="#c.drm_atomic_helper_async_commit" title="drm_atomic_helper_async_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_async_commit()</span></code></a>.</p>
<p>An async update will happen on legacy cursor updates. An async
update won’t happen if there is an outstanding commit modifying
the same plane.</p>
<p>When doing async_update drivers shouldn’t replace the
<a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state</span></code></a> but update the current one with the new plane
configurations in the new plane_state.</p>
<p>Drivers should also swap the framebuffers between current plane
state (<a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane.state</span></code></a>) and new_state.
This is required since cleanup for async commits is performed on
the new state, rather than old state like for traditional commits.
Since we want to give up the reference on the current (old) fb
instead of our brand new one, swap them in the driver during the
async commit.</p>
<dl class="simple">
<dt>FIXME:</dt><dd><ul class="simple">
<li><p>It only works for single plane updates</p></li>
<li><p>Async Pageflips are not supported yet</p></li>
<li><p>Some hw might still scan out the old buffer until the next
vblank, however we let go of the fb references as soon as
we run this hook. For now drivers must implement their own workers
for deferring if needed, until a common solution is created.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These functions are used by the atomic helpers and by the transitional plane
helpers.</p>
<dl class="function">
<dt id="c.drm_plane_helper_add">
void <code class="sig-name descname">drm_plane_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, const struct <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs">drm_plane_helper_funcs</a><em> *funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a plane</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>DRM plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>helper vtable to set for <strong>plane</strong></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_mode_config_helper_funcs">
struct <code class="sig-name descname">drm_mode_config_helper_funcs</code><a class="headerlink" href="#c.drm_mode_config_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>global modeset helper operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_mode_config_helper_funcs {
    void (*atomic_commit_tail)(struct drm_atomic_state *state);
    int (*atomic_commit_setup)(struct drm_atomic_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_commit_tail</span></code></dt><dd><p>This hook is used by the default atomic_commit() hook implemented in
<a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a> together with the nonblocking commit
helpers (see <a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for a starting point)
to implement blocking and nonblocking commits easily. It is not used
by the atomic helpers</p>
<p>This function is called when the new atomic state has already been
swapped into the various state pointers. The passed in state
therefore contains copies of the old/previous state. This hook should
commit the new state into hardware. Note that the helpers have
already waited for preceeding atomic commits and fences, but drivers
can add more waiting calls at the start of their implementation, e.g.
to wait for driver-internal request for implicit syncing, before
starting to commit the update to the hardware.</p>
<p>After the atomic update is committed to the hardware this hook needs
to call <a class="reference internal" href="#c.drm_atomic_helper_commit_hw_done" title="drm_atomic_helper_commit_hw_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code></a>. Then wait for the update
to be executed by the hardware, for example using
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_vblanks" title="drm_atomic_helper_wait_for_vblanks"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_vblanks()</span></code></a> or
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_flip_done" title="drm_atomic_helper_wait_for_flip_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_flip_done()</span></code></a>, and then clean up the old
framebuffers using <a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>.</p>
<p>When disabling a CRTC this hook _must_ stall for the commit to
complete. Vblank waits don’t work on disabled CRTC, hence the core
can’t take care of this. And it also can’t rely on the vblank event,
since that can be signalled already when the screen shows black,
which can happen much earlier than the last hardware access needed to
shut off the display pipeline completely.</p>
<p>This hook is optional, the default implementation is
<a class="reference internal" href="#c.drm_atomic_helper_commit_tail" title="drm_atomic_helper_commit_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_commit_setup</span></code></dt><dd><p>This hook is used by the default atomic_commit() hook implemented in
<a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a> together with the nonblocking helpers (see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a>) to extend the DRM commit setup. It
is not used by the atomic helpers.</p>
<p>This function is called at the end of
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a>, so once the commit has been
properly setup across the generic DRM object states. It allows
drivers to do some additional commit tracking that isn’t related to a
CRTC, plane or connector, tracked in a <a class="reference internal" href="drm-kms.html#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_obj</span></code></a> structure.</p>
<p>Note that the documentation of <a class="reference internal" href="drm-kms.html#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_obj</span></code></a> has more details on
how one should implement this.</p>
<p>This hook is optional.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These helper functions are used by the atomic helpers.</p>
</section>
<section id="atomic-modeset-helper-functions-reference">
<span id="drm-atomic-helper"></span><h2>Atomic Modeset Helper Functions Reference<a class="headerlink" href="#atomic-modeset-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<section id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>This helper library provides implementations of check and commit functions on
top of the CRTC modeset helper callbacks and the plane helper callbacks. It
also provides convenience implementations for the atomic state handling
callbacks for drivers which don’t need to subclass the drm core structures to
add their own additional internal state.</p>
<p>This library also provides default implementations for the check callback in
<a class="reference internal" href="#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check()</span></code></a> and for the commit callback with
<a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a>. But the individual stages and callbacks are
exposed to allow drivers to mix and match and e.g. use the plane helpers only
together with a driver private modeset implementation.</p>
<p>This library also provides implementations for all the legacy driver
interfaces on top of the atomic interface. See <a class="reference internal" href="#c.drm_atomic_helper_set_config" title="drm_atomic_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_set_config()</span></code></a>,
<a class="reference internal" href="#c.drm_atomic_helper_disable_plane" title="drm_atomic_helper_disable_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_plane()</span></code></a>, and the various functions to implement
set_property callbacks. New drivers must not implement these functions
themselves but must use the provided helpers.</p>
<p>The atomic helper uses the same function table structures as all other
modesetting helpers. See the documentation for <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_helper_funcs</span></code></a>,
struct <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs</span></code></a> and <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_helper_funcs</span></code></a>. It
also shares the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a> function table with the plane
helpers.</p>
</section>
<section id="implementing-asynchronous-atomic-commit">
<h3>Implementing Asynchronous Atomic Commit<a class="headerlink" href="#implementing-asynchronous-atomic-commit" title="Permalink to this headline">¶</a></h3>
<p>Nonblocking atomic commits should use struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_commit</span></code></a> to sequence
different operations against each another. Locks, especially struct
<a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>, should not be held in worker threads or any other
asynchronous context used to commit the hardware state.</p>
<p><a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a> implements the recommended sequence for
nonblocking commits, using <a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> internally:</p>
<p>1. Run <a class="reference internal" href="#c.drm_atomic_helper_prepare_planes" title="drm_atomic_helper_prepare_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_prepare_planes()</span></code></a>. Since this can fail and we
need to propagate out of memory/VRAM errors to userspace, it must be called
synchronously.</p>
<p>2. Synchronize with any outstanding nonblocking commit worker threads which
might be affected by the new state update. This is handled by
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a>.</p>
<p>Asynchronous workers need to have sufficient parallelism to be able to run
different atomic commits on different CRTCs in parallel. The simplest way to
achieve this is by running them on the <code class="xref c c-type docutils literal notranslate"><span class="pre">system_unbound_wq</span></code> work queue. Note
that drivers are not required to split up atomic commits and run an
individual commit in parallel - userspace is supposed to do that if it cares.
But it might be beneficial to do that for modesets, since those necessarily
must be done as one global operation, and enabling or disabling a CRTC can
take a long time. But even that is not required.</p>
<p>IMPORTANT: A <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_state</span></code></a> update for multiple CRTCs is sequenced
against all CRTCs therein. Therefore for atomic state updates which only flip
planes the driver must not get the struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state</span></code></a> of unrelated CRTCs
in its atomic check code: This would prevent committing of atomic updates to
multiple CRTCs in parallel. In general, adding additional state structures
should be avoided as much as possible, because this reduces parallelism in
(nonblocking) commits, both due to locking and due to commit sequencing
requirements.</p>
<p>3. The software state is updated synchronously with
<a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>. Doing this under the protection of all modeset
locks means concurrent callers never see inconsistent state. Note that commit
workers do not hold any locks; their access is only coordinated through
ordering. If workers would access state only through the pointers in the
free-standing state objects (currently not the case for any driver) then even
multiple pending commits could be in-flight at the same time.</p>
<p>4. Schedule a work item to do all subsequent steps, using the split-out
commit helpers: a) pre-plane commit b) plane commit c) post-plane commit and
then cleaning up the framebuffers after the old framebuffer is no longer
being displayed. The scheduled work should synchronize against other workers
using the <a class="reference internal" href="drm-kms.html#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_commit</span></code></a> infrastructure as needed. See
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for more details.</p>
</section>
<section id="helper-functions-reference">
<h3>Helper Functions Reference<a class="headerlink" href="#helper-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.drm_atomic_crtc_for_each_plane">
<code class="sig-name descname">drm_atomic_crtc_for_each_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_for_each_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over planes currently attached to CRTC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>the CRTC whose planes are iterated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over the current state, useful (for example) when applying
atomic state after it has been checked and swapped.  To iterate over the
planes which <em>will</em> be attached (more useful in code called from
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>) see
<a class="reference internal" href="#c.drm_atomic_crtc_state_for_each_plane" title="drm_atomic_crtc_state_for_each_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_state_for_each_plane()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_crtc_state_for_each_plane">
<code class="sig-name descname">drm_atomic_crtc_state_for_each_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_state_for_each_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over attached planes in new state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_state</span></code></dt><dd><p>the incoming CRTC state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to drm_crtc_for_each_plane(), but iterates the planes that will be
attached if the specified state is applied.  Useful during for example
in code called from <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> operations, to
validate the incoming state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_crtc_state_for_each_plane_state">
<code class="sig-name descname">drm_atomic_crtc_state_for_each_plane_state</code><span class="sig-paren">(</span><em>plane</em>, <em>plane_state</em>, <em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_state_for_each_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over attached planes in new state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>the loop cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane_state</span></code></dt><dd><p>loop cursor for the plane’s state, must be const</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc_state</span></code></dt><dd><p>the incoming CRTC state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to drm_crtc_for_each_plane(), but iterates the planes that will be
attached if the specified state is applied.  Useful during for example
in code called from <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> operations, to
validate the incoming state.</p>
<p>Compared to just <a class="reference internal" href="#c.drm_atomic_crtc_state_for_each_plane" title="drm_atomic_crtc_state_for_each_plane"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_state_for_each_plane()</span></code></a> this also fills in a
const plane_state. This is useful when a driver just wants to peek at other
active planes on this CRTC, but does not need to change it.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_plane_disabling">
bool <code class="sig-name descname">drm_atomic_plane_disabling</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *old_plane_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *new_plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_plane_disabling" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether a plane is being disabled</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*old_plane_state</span></code></dt><dd><p>old atomic plane state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*new_plane_state</span></code></dt><dd><p>new atomic plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks the atomic state of a plane to determine whether it’s being disabled
or not. This also WARNs if it detects an invalid state (both CRTC and FB
need to either both be NULL or both be non-NULL).</p>
<p><strong>Return</strong></p>
<p>True if the plane is being disabled, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_check_modeset">
int <code class="sig-name descname">drm_atomic_helper_check_modeset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check_modeset" title="Permalink to this definition">¶</a></dt>
<dd><p>validate state object for modeset changes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>the driver state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the state object to see if the requested state is physically possible.
This does all the CRTC and connector related computations for an atomic
update and adds any additional connectors needed for full modesets. It calls
the various per-object callbacks in the follow order:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.atomic_best_encoder</span></code></a> for determining the new encoder.</p></li>
<li><p><a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.atomic_check</span></code></a> to validate the connector state.</p></li>
<li><p>If it’s determined a modeset is needed then all connectors on the affected
CRTC are added and <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.atomic_check</span></code></a> is run on them.</p></li>
<li><p><a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.mode_valid</span></code></a>, <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.mode_valid</span></code></a> are called on the affected components.</p></li>
<li><p><a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup</span></code></a> is called on all encoder bridges.</p></li>
<li><p><a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_check</span></code></a> is called to validate any encoder state.
This function is only called when the encoder will be part of a configured CRTC,
it must not be used for implementing connector property validation.
If this function is NULL, <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_encoder_helper_funcs.mode_fixup</span></code> is called
instead.</p></li>
<li><p><a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.mode_fixup</span></code></a> is called last, to fix up the mode with CRTC constraints.</p></li>
</ol>
<p><a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.mode_changed</span></code></a> is set when the input mode is changed.
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.connectors_changed</span></code></a> is set when a connector is added or
removed from the CRTC.  <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.active_changed</span></code></a> is set when
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.active</span></code></a> changes, which is used for DPMS.
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.no_vblank</span></code></a> is set from the result of <a class="reference internal" href="drm-kms.html#c.drm_dev_has_vblank" title="drm_dev_has_vblank"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_has_vblank()</span></code></a>.
See also: <a class="reference internal" href="drm-kms.html#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a></p>
<p>IMPORTANT:</p>
<p>Drivers which set <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.mode_changed</span></code></a> (e.g. in their
<a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.atomic_check</span></code></a> hooks if a plane update can’t be done
without a full modeset) _must_ call this function after that change. It is
permitted to call this function multiple times for the same update, e.g.
when the <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_check</span></code></a> functions depend upon the
adjusted dotclock for fifo space allocation and watermark computation.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_check_wb_encoder_state">
int <code class="sig-name descname">drm_atomic_helper_check_wb_encoder_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a><em> *encoder</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a><em> *conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check_wb_encoder_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Check writeback encoder state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder state to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*conn_state</span></code></dt><dd><p>connector state to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks if the writeback connector state is valid, and returns an error if it
isn’t.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_check_plane_state">
int <code class="sig-name descname">drm_atomic_helper_check_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *plane_state</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *crtc_state</em>, int<em> min_scale</em>, int<em> max_scale</em>, bool<em> can_position</em>, bool<em> can_update_disabled</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Check plane state for validity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>plane state to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>CRTC state to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_scale</span></code></dt><dd><p>minimum <strong>src</strong>:<strong>dest</strong> scaling factor in 16.16 fixed point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_scale</span></code></dt><dd><p>maximum <strong>src</strong>:<strong>dest</strong> scaling factor in 16.16 fixed point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">can_position</span></code></dt><dd><p>is it legal to position the plane such that it
doesn’t cover the entire CRTC?  This will generally
only be false for primary planes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">can_update_disabled</span></code></dt><dd><p>can the plane be updated while the CRTC
is disabled?</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that a desired plane update is valid, and updates various
bits of derived state (clipped coordinates etc.). Drivers that provide
their own plane handling rather than helper-provided implementations may
still wish to call this function to avoid duplication of error checking
code.</p>
<p><strong>Return</strong></p>
<p>Zero if update appears valid, error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_check_crtc_primary_plane">
int <code class="sig-name descname">drm_atomic_helper_check_crtc_primary_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check_crtc_primary_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Check CRTC state for primary plane</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>CRTC state to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that a CRTC has at least one primary plane attached to it, which is
a requirement on some hardware. Note that this only involves the CRTC side
of the test. To test if the primary plane is visible or if it can be updated
without the CRTC being enabled, use <a class="reference internal" href="#c.drm_atomic_helper_check_plane_state" title="drm_atomic_helper_check_plane_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_plane_state()</span></code></a> in
the plane’s atomic check.</p>
<p><strong>Return</strong></p>
<p>0 if a primary plane is attached to the CRTC, or an error code otherwise</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_check_planes">
int <code class="sig-name descname">drm_atomic_helper_check_planes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>validate state object for planes changes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>the driver state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the state object to see if the requested state is physically possible.
This does all the plane update related checks using by calling into the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.atomic_check</span></code></a> and <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.atomic_check</span></code></a>
hooks provided by the driver.</p>
<p>It also sets <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.planes_changed</span></code></a> to indicate that a CRTC has
updated planes.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_check">
int <code class="sig-name descname">drm_atomic_helper_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_check" title="Permalink to this definition">¶</a></dt>
<dd><p>validate state object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>the driver state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the state object to see if the requested state is physically possible.
Only CRTCs and planes have check callbacks, so for any additional (global)
checking that a driver needs it can simply wrap that around this function.
Drivers without such needs can directly use this as their
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> callback.</p>
<p>This just wraps the two parts of the state checking for planes and modeset
state in the default order: First it calls <a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>
and then <a class="reference internal" href="#c.drm_atomic_helper_check_planes" title="drm_atomic_helper_check_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_planes()</span></code></a>. The assumption is that the
<strong>drm_plane_helper_funcs.atomic_check</strong> and <strong>drm_crtc_helper_funcs.atomic_check</strong>
functions depend upon an updated adjusted_mode.clock to e.g. properly compute
watermarks.</p>
<p>Note that zpos normalization will add all enable planes to the state which
might not desired for some drivers.
For example enable/disable of a cursor plane which have fixed zpos value
would trigger all other enabled planes to be forced to the state change.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_update_legacy_modeset_state">
void <code class="sig-name descname">drm_atomic_helper_update_legacy_modeset_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_update_legacy_modeset_state" title="Permalink to this definition">¶</a></dt>
<dd><p>update legacy modeset state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function updates all the various legacy modeset state pointers in
connectors, encoders and CRTCs.</p>
<p>Drivers can use this for building their own atomic commit if they don’t have
a pure helper-based modeset implementation.</p>
<p>Since these updates are not synchronized with lockings, only code paths
called from <a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_tail</span></code></a> can look at the
legacy state filled out by this helper. Defacto this means this helper and
the legacy state pointers are only really useful for transitioning an
existing driver to the atomic world.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_calc_timestamping_constants">
void <code class="sig-name descname">drm_atomic_helper_calc_timestamping_constants</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_calc_timestamping_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>update vblank timestamping constants</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates the timestamping constants used for precise vblank timestamps
by calling <a class="reference internal" href="drm-kms.html#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_calc_timestamping_constants()</span></code></a> for all enabled crtcs in <strong>state</strong>.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_modeset_disables">
void <code class="sig-name descname">drm_atomic_helper_commit_modeset_disables</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_modeset_disables" title="Permalink to this definition">¶</a></dt>
<dd><p>modeset commit to disable outputs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function shuts down all the outputs that need to be shut down and
prepares them (if required) with the new mode.</p>
<p>For compatibility with legacy CRTC helpers this should be called before
<a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a>, which is what the default commit function
does. But drivers with different needs can group the modeset commits together
and do the plane commits at the end. This is useful for drivers doing runtime
PM since planes updates then only happen when the CRTC is actually enabled.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_modeset_enables">
void <code class="sig-name descname">drm_atomic_helper_commit_modeset_enables</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_modeset_enables" title="Permalink to this definition">¶</a></dt>
<dd><p>modeset commit to enable outputs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables all the outputs with the new configuration which had to
be turned off for the update.</p>
<p>For compatibility with legacy CRTC helpers this should be called after
<a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a>, which is what the default commit function
does. But drivers with different needs can group the modeset commits together
and do the plane commits at the end. This is useful for drivers doing runtime
PM since planes updates then only happen when the CRTC is actually enabled.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_wait_for_fences">
int <code class="sig-name descname">drm_atomic_helper_wait_for_fences</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, bool<em> pre_swap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_wait_for_fences" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for fences stashed in plane state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">pre_swap</span></code></dt><dd><p>If true, do an interruptible wait, and <strong>state</strong> is the new state.
Otherwise <strong>state</strong> is the old state.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For implicit sync, driver should fish the exclusive fence out from the
incoming fb’s and stash it in the drm_plane_state.  This is called after
<a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_swap_state()</span></code></a> so it uses the current plane state (and
just uses the atomic state to find the changed planes)</p>
<p>Note that <strong>pre_swap</strong> is needed since the point where we block for fences moves
around depending upon whether an atomic commit is blocking or
non-blocking. For non-blocking commit all waiting needs to happen after
<a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_swap_state()</span></code></a> is called, but for blocking commits we want
to wait <strong>before</strong> we do anything that can’t be easily rolled back. That is
before we call <a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>.</p>
<p>Returns zero if success or &lt; 0 if <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> fails.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_wait_for_vblanks">
void <code class="sig-name descname">drm_atomic_helper_wait_for_vblanks</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_wait_for_vblanks" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for vblank on CRTCs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to, after atomic commit, wait for vblanks on all affected
CRTCs (ie. before cleaning up old framebuffers using
<a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>). It will only wait on CRTCs where the
framebuffers have actually changed to optimize for the legacy cursor and
plane update use-case.</p>
<p>Drivers using the nonblocking commit tracking support initialized by calling
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> should look at
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_flip_done" title="drm_atomic_helper_wait_for_flip_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_flip_done()</span></code></a> as an alternative.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_wait_for_flip_done">
void <code class="sig-name descname">drm_atomic_helper_wait_for_flip_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_wait_for_flip_done" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for all page flips to be done</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to, after atomic commit, wait for page flips on all affected
crtcs (ie. before cleaning up old framebuffers using
<a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>). Compared to
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_vblanks" title="drm_atomic_helper_wait_for_vblanks"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_vblanks()</span></code></a> this waits for the completion on all
CRTCs, assuming that cursors-only updates are signalling their completion
immediately (or using a different path).</p>
<p>This requires that drivers use the nonblocking commit tracking support
initialized using <a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_tail">
void <code class="sig-name descname">drm_atomic_helper_commit_tail</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>commit atomic update to hardware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default implementation for the
<a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_tail</span></code></a> hook, for drivers
that do not support runtime_pm or do not need the CRTC to be
enabled to perform a commit. Otherwise, see
<a class="reference internal" href="#c.drm_atomic_helper_commit_tail_rpm" title="drm_atomic_helper_commit_tail_rpm"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail_rpm()</span></code></a>.</p>
<p>Note that the default ordering of how the various stages are called is to
match the legacy modeset helper library closest.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_tail_rpm">
void <code class="sig-name descname">drm_atomic_helper_commit_tail_rpm</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_tail_rpm" title="Permalink to this definition">¶</a></dt>
<dd><p>commit atomic update to hardware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>new modeset state to be committed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is an alternative implementation for the
<a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_tail</span></code></a> hook, for drivers
that support runtime_pm or need the CRTC to be enabled to perform a
commit. Otherwise, one should use the default implementation
<a class="reference internal" href="#c.drm_atomic_helper_commit_tail" title="drm_atomic_helper_commit_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_async_check">
int <code class="sig-name descname">drm_atomic_helper_async_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_async_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check if state can be committed asynchronously</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>the driver state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper will check if it is possible to commit the state asynchronously.
Async commits are not supposed to swap the states like normal sync commits
but just do in-place changes on the current state.</p>
<p>It will return 0 if the commit can happen in an asynchronous fashion or error
if not. Note that error just mean it can’t be committed asynchronously, if it
fails the commit should be treated like a normal synchronous commit.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_async_commit">
void <code class="sig-name descname">drm_atomic_helper_async_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_async_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>commit state asynchronously</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>the driver state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits a state asynchronously, i.e., not vblank
synchronized. It should be used on a state only when
drm_atomic_async_check() succeeds. Async commits are not supposed to swap
the states like normal sync commits, but just do in-place changes on the
current state.</p>
<p>TODO: Implement full swap instead of doing in-place changes.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_commit">
int <code class="sig-name descname">drm_atomic_helper_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, bool<em> nonblock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>commit validated state object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>the driver state object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">nonblock</span></code></dt><dd><p>whether nonblocking behavior is requested.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits a with <a class="reference internal" href="#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check()</span></code></a> pre-validated state
object. This can still fail when e.g. the framebuffer reservation fails. This
function implements nonblocking commits, using
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> and related functions.</p>
<p>Committing the actual hardware state is done through the
<a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_tail</span></code></a> callback, or its default
implementation <a class="reference internal" href="#c.drm_atomic_helper_commit_tail" title="drm_atomic_helper_commit_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_setup_commit">
int <code class="sig-name descname">drm_atomic_helper_setup_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, bool<em> nonblock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_setup_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>setup possibly nonblocking commit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>new modeset state to be committed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">nonblock</span></code></dt><dd><p>whether nonblocking behavior is requested.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function prepares <strong>state</strong> to be used by the atomic helper’s support for
nonblocking commits. Drivers using the nonblocking commit infrastructure
should always call this function from their
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a> hook.</p>
<p>Drivers that need to extend the commit setup to private objects can use the
<a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_setup</span></code></a> hook.</p>
<p>To be able to use this support drivers need to use a few more helper
functions. <a class="reference internal" href="#c.drm_atomic_helper_wait_for_dependencies" title="drm_atomic_helper_wait_for_dependencies"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_dependencies()</span></code></a> must be called before
actually committing the hardware state, and for nonblocking commits this call
must be placed in the async worker. See also <a class="reference internal" href="#c.drm_atomic_helper_swap_state" title="drm_atomic_helper_swap_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_swap_state()</span></code></a>
and its stall parameter, for when a driver’s commit hooks look at the
<a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.state</span></code></a>, <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane.state</span></code></a> or <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.state</span></code></a> pointer directly.</p>
<p>Completion of the hardware commit step must be signalled using
<a class="reference internal" href="#c.drm_atomic_helper_commit_hw_done" title="drm_atomic_helper_commit_hw_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code></a>. After this step the driver is not allowed
to read or change any permanent software or hardware modeset state. The only
exception is state protected by other means than <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a> locks.
Only the free standing <strong>state</strong> with pointers to the old state structures can
be inspected, e.g. to clean up old buffers using
<a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>.</p>
<p>At the very end, before cleaning up <strong>state</strong> drivers must call
<a class="reference internal" href="#c.drm_atomic_helper_commit_cleanup_done" title="drm_atomic_helper_commit_cleanup_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_cleanup_done()</span></code></a>.</p>
<p>This is all implemented by in <a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a>, giving drivers a
complete and easy-to-use default implementation of the atomic_commit() hook.</p>
<p>The tracking of asynchronously executed and still pending commits is done
using the core structure <a class="reference internal" href="drm-kms.html#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_commit</span></code></a>.</p>
<p>By default there’s no need to clean up resources allocated by this function
explicitly: <a class="reference internal" href="drm-kms.html#c.drm_atomic_state_default_clear" title="drm_atomic_state_default_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_state_default_clear()</span></code></a> will take care of that
automatically.</p>
<p>0 on success. -EBUSY when userspace schedules nonblocking commits too fast,
-ENOMEM on allocation failures and -EINTR when a signal is pending.</p>
<p><strong>Return</strong></p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_wait_for_dependencies">
void <code class="sig-name descname">drm_atomic_helper_wait_for_dependencies</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_wait_for_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for required preceeding commits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function waits for all preceeding commits that touch the same CRTC as
<strong>old_state</strong> to both be committed to the hardware (as signalled by
<a class="reference internal" href="#c.drm_atomic_helper_commit_hw_done" title="drm_atomic_helper_commit_hw_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code></a>) and executed by the hardware (as signalled
by calling <a class="reference internal" href="drm-kms.html#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> on the <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.event</span></code></a>).</p>
<p>This is part of the atomic helper support for nonblocking commits, see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for an overview.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_fake_vblank">
void <code class="sig-name descname">drm_atomic_helper_fake_vblank</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_fake_vblank" title="Permalink to this definition">¶</a></dt>
<dd><p>fake VBLANK events if needed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks all CRTCs and fakes VBLANK events on those with
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.no_vblank</span></code></a> set to true and <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.event</span></code></a> != NULL.
The primary use of this function is writeback connectors working in oneshot
mode and faking VBLANK events. In this case they only fake the VBLANK event
when a job is queued, and any change to the pipeline that does not touch the
connector is leading to timeouts when calling
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_vblanks" title="drm_atomic_helper_wait_for_vblanks"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_vblanks()</span></code></a> or
<a class="reference internal" href="#c.drm_atomic_helper_wait_for_flip_done" title="drm_atomic_helper_wait_for_flip_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_flip_done()</span></code></a>. In addition to writeback
connectors, this function can also fake VBLANK events for CRTCs without
VBLANK interrupt.</p>
<p>This is part of the atomic helper support for nonblocking commits, see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for an overview.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_hw_done">
void <code class="sig-name descname">drm_atomic_helper_commit_hw_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_hw_done" title="Permalink to this definition">¶</a></dt>
<dd><p>setup possible nonblocking commit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to signal completion of the hardware commit step. After
this step the driver is not allowed to read or change any permanent software
or hardware modeset state. The only exception is state protected by other
means than <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a> locks.</p>
<p>Drivers should try to postpone any expensive or delayed cleanup work after
this function is called.</p>
<p>This is part of the atomic helper support for nonblocking commits, see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for an overview.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_cleanup_done">
void <code class="sig-name descname">drm_atomic_helper_commit_cleanup_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_cleanup_done" title="Permalink to this definition">¶</a></dt>
<dd><p>signal completion of commit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This signals completion of the atomic update <strong>old_state</strong>, including any
cleanup work. If used, it must be called right before calling
<a class="reference internal" href="drm-kms.html#c.drm_atomic_state_put" title="drm_atomic_state_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_state_put()</span></code></a>.</p>
<p>This is part of the atomic helper support for nonblocking commits, see
<a class="reference internal" href="#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> for an overview.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_prepare_planes">
int <code class="sig-name descname">drm_atomic_helper_prepare_planes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_prepare_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare plane resources before commit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state object with new state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function prepares plane state, specifically framebuffers, for the new
configuration, by calling <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a>. If any failure
is encountered this function will call <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a> on
any already successfully prepared framebuffer.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_planes">
void <code class="sig-name descname">drm_atomic_helper_commit_planes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em>, uint32_t<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>commit plane state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt><dd><p>flags for committing plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits the new plane state using the plane and atomic helper
functions for planes and CRTCs. It assumes that the atomic state has already
been pushed into the relevant object state pointers, since this step can no
longer fail.</p>
<p>It still requires the global state object <strong>old_state</strong> to know which planes and
crtcs need to be updated though.</p>
<p>Note that this function does all plane updates across all CRTCs in one step.
If the hardware can’t support this approach look at
<a class="reference internal" href="#c.drm_atomic_helper_commit_planes_on_crtc" title="drm_atomic_helper_commit_planes_on_crtc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes_on_crtc()</span></code></a> instead.</p>
<p>Plane parameters can be updated by applications while the associated CRTC is
disabled. The DRM/KMS core will store the parameters in the plane state,
which will be available to the driver when the CRTC is turned on. As a result
most drivers don’t need to be immediately notified of plane updates for a
disabled CRTC.</p>
<p>Unless otherwise needed, drivers are advised to set the ACTIVE_ONLY flag in
<strong>flags</strong> in order not to receive plane update notifications related to a
disabled CRTC. This avoids the need to manually ignore plane updates in
driver code when the driver and/or hardware can’t or just don’t need to deal
with updates on disabled CRTCs, for example when supporting runtime PM.</p>
<p>Drivers may set the NO_DISABLE_AFTER_MODESET flag in <strong>flags</strong> if the relevant
display controllers require to disable a CRTC’s planes when the CRTC is
disabled. This function would skip the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.atomic_disable</span></code></a>
call for a plane if the CRTC of the old plane state needs a modesetting
operation. Of course, the drivers need to disable the planes in their CRTC
disable callbacks since no one else would do that.</p>
<p>The <a class="reference internal" href="#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit()</span></code></a> default implementation doesn’t set the
ACTIVE_ONLY flag to most closely match the behaviour of the legacy helpers.
This should not be copied blindly by drivers.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_planes_on_crtc">
void <code class="sig-name descname">drm_atomic_helper_commit_planes_on_crtc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *old_crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_planes_on_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>commit plane state for a CRTC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*old_crtc_state</span></code></dt><dd><p>atomic state object with the old CRTC state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits the new plane state using the plane and atomic helper
functions for planes on the specific CRTC. It assumes that the atomic state
has already been pushed into the relevant object state pointers, since this
step can no longer fail.</p>
<p>This function is useful when plane updates should be done CRTC-by-CRTC
instead of one global step like <a class="reference internal" href="#c.drm_atomic_helper_commit_planes" title="drm_atomic_helper_commit_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_planes()</span></code></a> does.</p>
<p>This function can only be savely used when planes are not allowed to move
between different CRTCs because this function doesn’t handle inter-CRTC
dependencies. Callers need to ensure that either no such dependencies exist,
resolve them through ordering of commit calls or through some other means.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_disable_planes_on_crtc">
void <code class="sig-name descname">drm_atomic_helper_disable_planes_on_crtc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *old_crtc_state</em>, bool<em> atomic</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_disable_planes_on_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to disable CRTC’s planes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*old_crtc_state</span></code></dt><dd><p>atomic state object with the old CRTC state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">atomic</span></code></dt><dd><p>if set, synchronize with CRTC’s atomic_begin/flush hooks</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables all planes associated with the given CRTC. This can be
used for instance in the CRTC helper atomic_disable callback to disable
all planes.</p>
<p>If the atomic-parameter is set the function calls the CRTC’s
atomic_begin hook before and atomic_flush hook after disabling the
planes.</p>
<p>It is a bug to call this function without having implemented the
<a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.atomic_disable</span></code></a> plane hook.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_cleanup_planes">
void <code class="sig-name descname">drm_atomic_helper_cleanup_planes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_cleanup_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup plane resources after commit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>atomic state object with old state structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up plane state, specifically framebuffers, from the old
configuration. Hence the old configuration must be perserved in <strong>old_state</strong> to
be able to call this function.</p>
<p>This function must also be called on the new state when the atomic update
fails at any point after calling <a class="reference internal" href="#c.drm_atomic_helper_prepare_planes" title="drm_atomic_helper_prepare_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_prepare_planes()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_swap_state">
int <code class="sig-name descname">drm_atomic_helper_swap_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, bool<em> stall</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_swap_state" title="Permalink to this definition">¶</a></dt>
<dd><p>store atomic state into current sw state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">stall</span></code></dt><dd><p>stall for preceding commits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function stores the atomic state into the current state pointers in all
driver objects. It should be called after all failing steps have been done
and succeeded, but before the actual hardware state is committed.</p>
<p>For cleanup and error recovery the current state for all changed objects will
be swapped into <strong>state</strong>.</p>
<p>With that sequence it fits perfectly into the plane prepare/cleanup sequence:</p>
<ol class="arabic simple">
<li><p>Call <a class="reference internal" href="#c.drm_atomic_helper_prepare_planes" title="drm_atomic_helper_prepare_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_prepare_planes()</span></code></a> with the staged atomic state.</p></li>
<li><p>Do any other steps that might fail.</p></li>
<li><p>Put the staged state into the current state pointers with this function.</p></li>
<li><p>Actually commit the hardware state.</p></li>
</ol>
<p>5. Call <a class="reference internal" href="#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a> with <strong>state</strong>, which since step 3
contains the old state. Also do any other cleanup required with that state.</p>
<p><strong>stall</strong> must be set when nonblocking commits for this driver directly access
the <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane.state</span></code></a>, <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc.state</span></code></a> or <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.state</span></code></a> pointer. With
the current atomic helpers this is almost always the case, since the helpers
don’t pass the right state structures to the callbacks.</p>
<p>Returns 0 on success. Can return -ERESTARTSYS when <strong>stall</strong> is true and the
waiting for the previous commits has been interrupted.</p>
<p><strong>Return</strong></p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_update_plane">
int <code class="sig-name descname">drm_atomic_helper_update_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, int<em> crtc_x</em>, int<em> crtc_y</em>, unsigned int<em> crtc_w</em>, unsigned int<em> crtc_h</em>, uint32_t<em> src_x</em>, uint32_t<em> src_y</em>, uint32_t<em> src_w</em>, uint32_t<em> src_h</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_update_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for primary plane update using atomic</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane object to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>owning CRTC of owning plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>framebuffer to flip onto plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">crtc_x</span></code></dt><dd><p>x offset of primary plane on <strong>crtc</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">crtc_y</span></code></dt><dd><p>y offset of primary plane on <strong>crtc</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_w</span></code></dt><dd><p>width of primary plane rectangle on <strong>crtc</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_h</span></code></dt><dd><p>height of primary plane rectangle on <strong>crtc</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_x</span></code></dt><dd><p>x offset of <strong>fb</strong> for panning</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_y</span></code></dt><dd><p>y offset of <strong>fb</strong> for panning</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_w</span></code></dt><dd><p>width of source rectangle in <strong>fb</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_h</span></code></dt><dd><p>height of source rectangle in <strong>fb</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>lock acquire context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane update handler using the atomic driver interface.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_disable_plane">
int <code class="sig-name descname">drm_atomic_helper_disable_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_disable_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for primary plane disable using * atomic</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to disable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>lock acquire context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane disable handler using the atomic driver interface.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_set_config">
int <code class="sig-name descname">drm_atomic_helper_set_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_mode_set" title="drm_mode_set">drm_mode_set</a><em> *set</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>set a new config from userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_set</span> <span class="pre">*set</span></code></dt><dd><p>mode set configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>lock acquisition context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default CRTC set_config handler using the atomic driver interface.</p>
<p><strong>NOTE</strong></p>
<p>For backwards compatibility with old userspace this automatically
resets the “link-status” property to GOOD, to force any link
re-training. The SETCRTC ioctl does not define whether an update does
need a full modeset or just a plane update, hence we’re allowed to do
that. See also <a class="reference internal" href="drm-kms.html#c.drm_connector_set_link_status_property" title="drm_connector_set_link_status_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_link_status_property()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_disable_all">
int <code class="sig-name descname">drm_atomic_helper_disable_all</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_disable_all" title="Permalink to this definition">¶</a></dt>
<dd><p>disable all currently active outputs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>lock acquisition context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Loops through all connectors, finding those that aren’t turned off and then
turns them off by setting their DPMS mode to OFF and deactivating the CRTC
that they are connected to.</p>
<p>This is used for example in suspend/resume to disable all currently active
functions when suspending. If you just want to shut down everything at e.g.
driver unload, look at <a class="reference internal" href="#c.drm_atomic_helper_shutdown" title="drm_atomic_helper_shutdown"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_shutdown()</span></code></a>.</p>
<p>Note that if callers haven’t already acquired all modeset locks this might
return -EDEADLK, which must be handled by calling <a class="reference internal" href="drm-kms.html#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_helper_shutdown" title="drm_atomic_helper_shutdown"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_shutdown()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_shutdown">
void <code class="sig-name descname">drm_atomic_helper_shutdown</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>shutdown all CRTC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This shuts down all CRTC, which is useful for driver unloading. Shutdown on
suspend should instead be handled with <a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, since
that also takes a snapshot of the modeset state to be restored on resume.</p>
<p>This is just a convenience wrapper around <a class="reference internal" href="#c.drm_atomic_helper_disable_all" title="drm_atomic_helper_disable_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_all()</span></code></a>,
and it is the atomic version of drm_crtc_force_disable_all().</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> * <code class="sig-name descname">drm_atomic_helper_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate an atomic state object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>lock acquisition context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes a copy of the current atomic state by looping over all objects and
duplicating their respective states. This is used for example by suspend/
resume support code to save the state prior to suspend such that it can
be restored upon resume.</p>
<p>Note that this treats atomic state as persistent between save and restore.
Drivers must make sure that this is possible and won’t result in confusion
or erroneous behaviour.</p>
<p>Note that if callers haven’t already acquired all modeset locks this might
return -EDEADLK, which must be handled by calling <a class="reference internal" href="drm-kms.html#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a></p>
<p><strong>Return</strong></p>
<p>A pointer to the copy of the atomic state object on success or an
ERR_PTR()-encoded error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_suspend">
struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> * <code class="sig-name descname">drm_atomic_helper_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>subsystem-level suspend helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Duplicates the current atomic state, disables all active outputs and then
returns a pointer to the original atomic state to the caller. Drivers can
pass this pointer to the <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a> helper upon resume to
restore the output configuration that was active at the time the system
entered suspend.</p>
<p>Note that it is potentially unsafe to use this. The atomic state object
returned by this function is assumed to be persistent. Drivers must ensure
that this holds true. Before calling this function, drivers must make sure
to suspend fbdev emulation so that nothing can be using the device.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_duplicate_state" title="drm_atomic_helper_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_duplicate_state()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_disable_all" title="drm_atomic_helper_disable_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_disable_all()</span></code></a>,
<a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_commit_duplicated_state" title="drm_atomic_helper_commit_duplicated_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_duplicated_state()</span></code></a></p>
<p><strong>Return</strong></p>
<p>A pointer to a copy of the state before suspend on success or an ERR_PTR()-
encoded error code on failure. Drivers should store the returned atomic
state object and pass it to the <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a> helper upon
resume.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_commit_duplicated_state">
int <code class="sig-name descname">drm_atomic_helper_commit_duplicated_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_commit_duplicated_state" title="Permalink to this definition">¶</a></dt>
<dd><p>commit duplicated state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>duplicated atomic state to commit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>pointer to acquire_ctx to use for commit.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The state returned by <a class="reference internal" href="#c.drm_atomic_helper_duplicate_state" title="drm_atomic_helper_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_duplicate_state()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a> is partially invalid, and needs to
be fixed up before commit.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a></p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_resume">
int <code class="sig-name descname">drm_atomic_helper_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>subsystem-level resume helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state to resume to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="drm-kms.html#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a> to synchronize hardware and software states,
grabs all modeset locks and commits the atomic state object. This can be
used in conjunction with the <a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a> helper to
implement suspend/resume for drivers that support atomic mode-setting.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a></p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_page_flip">
int <code class="sig-name descname">drm_atomic_helper_page_flip</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a><em> *event</em>, uint32_t<em> flags</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_page_flip" title="Permalink to this definition">¶</a></dt>
<dd><p>execute a legacy page flip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>DRM CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*event</span></code></dt><dd><p>optional DRM event to signal upon completion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt><dd><p>flip flags for non-vblank sync’ed updates</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>lock acquisition context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.page_flip</span></code></a> implementation
using the atomic driver interface.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_page_flip_target" title="drm_atomic_helper_page_flip_target"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_page_flip_target()</span></code></a></p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_page_flip_target">
int <code class="sig-name descname">drm_atomic_helper_page_flip_target</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a><em> *event</em>, uint32_t<em> flags</em>, uint32_t<em> target</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_page_flip_target" title="Permalink to this definition">¶</a></dt>
<dd><p>do page flip on target vblank period.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>DRM CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*event</span></code></dt><dd><p>optional DRM event to signal upon completion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt><dd><p>flip flags for non-vblank sync’ed updates</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">target</span></code></dt><dd><p>specifying the target vblank period when the flip to take effect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>lock acquisition context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.page_flip_target</span></code></a> implementation.
Similar to <a class="reference internal" href="#c.drm_atomic_helper_page_flip" title="drm_atomic_helper_page_flip"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_page_flip()</span></code></a> with extra parameter to specify
target vblank period to flip.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_bridge_propagate_bus_fmt">
u32 * <code class="sig-name descname">drm_atomic_helper_bridge_propagate_bus_fmt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a><em> *bridge_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *crtc_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a><em> *conn_state</em>, u32<em> output_fmt</em>, unsigned int<em> *num_input_fmts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_bridge_propagate_bus_fmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate output format to the input end of a bridge</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge_state</span> <span class="pre">*bridge_state</span></code></dt><dd><p>new bridge state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>new CRTC state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*conn_state</span></code></dt><dd><p>new connector state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">output_fmt</span></code></dt><dd><p>tested output bus format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*num_input_fmts</span></code></dt><dd><p>will contain the size of the returned array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper is a pluggable implementation of the
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_get_input_bus_fmts</span></code></a> operation for bridges that don’t
modify the bus configuration between their input and their output. It
returns an array of input formats with a single element set to <strong>output_fmt</strong>.</p>
<p><strong>Return</strong></p>
<p>a valid format array of size <strong>num_input_fmts</strong>, or NULL if the allocation
failed</p>
</div>
</section>
<section id="atomic-state-reset-and-initialization">
<h3>Atomic State Reset and Initialization<a class="headerlink" href="#atomic-state-reset-and-initialization" title="Permalink to this headline">¶</a></h3>
<p>Both the drm core and the atomic helpers assume that there is always the full
and correct atomic software state for all connectors, CRTCs and planes
available. Which is a bit a problem on driver load and also after system
suspend. One way to solve this is to have a hardware state read-out
infrastructure which reconstructs the full software state (e.g. the i915
driver).</p>
<p>The simpler solution is to just reset the software state to everything off,
which is easiest to do by calling <a class="reference internal" href="drm-kms.html#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a>. To facilitate this
the atomic helpers provide default reset implementations for all hooks.</p>
<p>On the upside the precise state tracking of atomic simplifies system suspend
and resume a lot. For drivers using <a class="reference internal" href="drm-kms.html#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a> a complete recipe
is implemented in <a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a> and <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a>.
For other drivers the building blocks are split out, see the documentation
for these functions.</p>
</section>
<section id="atomic-state-helper-reference">
<h3>Atomic State Helper Reference<a class="headerlink" href="#atomic-state-helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.__drm_atomic_helper_crtc_state_reset">
void <code class="sig-name descname">__drm_atomic_helper_crtc_state_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *crtc_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_crtc_state_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the CRTC state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>atomic CRTC state, must not be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC object, must not be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>crtc_state</strong> with default
values. This is useful for drivers that subclass the CRTC state.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_crtc_reset">
void <code class="sig-name descname">__drm_atomic_helper_crtc_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_crtc_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset state on CRTC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>drm CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>CRTC state to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>crtc_state</strong> and assigns it to
the <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc-&gt;state</span></code></a> pointer of <strong>crtc</strong>, usually required when
initializing the drivers or when called from the <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.reset</span></code></a>
hook.</p>
<p>This is useful for drivers that subclass the CRTC state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_crtc_reset">
void <code class="sig-name descname">drm_atomic_helper_crtc_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_crtc_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>default <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.reset</span></code></a> hook for CRTCs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>drm CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the atomic state for <strong>crtc</strong> by freeing the state pointer (which might
be NULL, e.g. at driver load time) and allocating a new empty state object.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_crtc_duplicate_state">
void <code class="sig-name descname">__drm_atomic_helper_crtc_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_crtc_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>copy atomic CRTC state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic CRTC state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a CRTC’s current state and resets inferred values.
This is useful for drivers that subclass the CRTC state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_crtc_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="sig-name descname">drm_atomic_helper_crtc_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_crtc_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state duplicate hook</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>drm CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default CRTC state duplicate hook for drivers which don’t have their own
subclassed CRTC state structure.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_crtc_destroy_state">
void <code class="sig-name descname">__drm_atomic_helper_crtc_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_crtc_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>release CRTC state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*state</span></code></dt><dd><p>CRTC state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all resources stored in the CRTC state without actually freeing
the memory of the CRTC state. This is useful for drivers that subclass the
CRTC state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_crtc_destroy_state">
void <code class="sig-name descname">drm_atomic_helper_crtc_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_crtc_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state destroy hook</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>drm CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*state</span></code></dt><dd><p>CRTC state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default CRTC state destroy hook for drivers which don’t have their own
subclassed CRTC state structure.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_plane_state_reset">
void <code class="sig-name descname">__drm_atomic_helper_plane_state_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *plane_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_plane_state_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>resets plane state to default values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>atomic plane state, must not be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane object, must not be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>plane_state</strong> with default
values. This is useful for drivers that subclass the CRTC state.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_plane_reset">
void <code class="sig-name descname">__drm_atomic_helper_plane_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_plane_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset state on plane</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>plane state to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>plane_state</strong> and assigns it to
the <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc-&gt;state</span></code></a> pointer of <strong>plane</strong>, usually required when
initializing the drivers or when called from the <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.reset</span></code></a>
hook.</p>
<p>This is useful for drivers that subclass the plane state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_plane_reset">
void <code class="sig-name descname">drm_atomic_helper_plane_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_plane_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>default <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.reset</span></code></a> hook for planes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the atomic state for <strong>plane</strong> by freeing the state pointer (which might
be NULL, e.g. at driver load time) and allocating a new empty state object.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_plane_duplicate_state">
void <code class="sig-name descname">__drm_atomic_helper_plane_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_plane_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>copy atomic plane state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a plane’s current state. This is useful for
drivers that subclass the plane state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_plane_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="sig-name descname">drm_atomic_helper_plane_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_plane_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state duplicate hook</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default plane state duplicate hook for drivers which don’t have their own
subclassed plane state structure.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_plane_destroy_state">
void <code class="sig-name descname">__drm_atomic_helper_plane_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_plane_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>release plane state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>plane state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all resources stored in the plane state without actually freeing
the memory of the plane state. This is useful for drivers that subclass the
plane state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_plane_destroy_state">
void <code class="sig-name descname">drm_atomic_helper_plane_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_plane_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state destroy hook</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>drm plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>plane state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default plane state destroy hook for drivers which don’t have their own
subclassed plane state structure.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_connector_state_reset">
void <code class="sig-name descname">__drm_atomic_helper_connector_state_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a><em> *conn_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_connector_state_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the connector state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*conn_state</span></code></dt><dd><p>atomic connector state, must not be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connectotr object, must not be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>conn_state</strong> with default
values. This is useful for drivers that subclass the connector state.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_connector_reset">
void <code class="sig-name descname">__drm_atomic_helper_connector_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a><em> *conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_connector_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset state on connector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*conn_state</span></code></dt><dd><p>connector state to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the newly allocated <strong>conn_state</strong> and assigns it to
the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector-&gt;state</span></code></a> pointer of <strong>connector</strong>, usually required when
initializing the drivers or when called from the <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.reset</span></code></a>
hook.</p>
<p>This is useful for drivers that subclass the connector state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_reset">
void <code class="sig-name descname">drm_atomic_helper_connector_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>default <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.reset</span></code></a> hook for connectors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the atomic state for <strong>connector</strong> by freeing the state pointer (which
might be NULL, e.g. at driver load time) and allocating a new empty state
object.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_tv_margins_reset">
void <code class="sig-name descname">drm_atomic_helper_connector_tv_margins_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_tv_margins_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets TV connector properties</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>DRM connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the TV-related properties attached to a connector.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_connector_duplicate_state">
void <code class="sig-name descname">__drm_atomic_helper_connector_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_connector_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>copy atomic connector state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic connector state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a connector’s current state. This is useful for
drivers that subclass the connector state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="sig-name descname">drm_atomic_helper_connector_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state duplicate hook</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default connector state duplicate hook for drivers which don’t have their own
subclassed connector state structure.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_connector_destroy_state">
void <code class="sig-name descname">__drm_atomic_helper_connector_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_connector_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>release connector state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*state</span></code></dt><dd><p>connector state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all resources stored in the connector state without actually
freeing the memory of the connector state. This is useful for drivers that
subclass the connector state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_connector_destroy_state">
void <code class="sig-name descname">drm_atomic_helper_connector_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_connector_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>default state destroy hook</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*state</span></code></dt><dd><p>connector state object to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default connector state destroy hook for drivers which don’t have their own
subclassed connector state structure.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_private_obj_duplicate_state">
void <code class="sig-name descname">__drm_atomic_helper_private_obj_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_private_obj" title="drm_private_obj">drm_private_obj</a><em> *obj</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_private_state" title="drm_private_state">drm_private_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_private_obj_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>copy atomic private state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span> <span class="pre">*obj</span></code></dt><dd><p>CRTC object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_state</span> <span class="pre">*state</span></code></dt><dd><p>new private object state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a private objects’s current state and resets inferred values.
This is useful for drivers that subclass the private state.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_bridge_duplicate_state">
void <code class="sig-name descname">__drm_atomic_helper_bridge_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_bridge_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy atomic bridge state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic bridge state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies atomic state from a bridge’s current state and resets inferred values.
This is useful for drivers that subclass the bridge state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_bridge_duplicate_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a> * <code class="sig-name descname">drm_atomic_helper_bridge_duplicate_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_bridge_duplicate_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate a bridge state object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a new bridge state and initializes it with the current bridge
state values. This helper is meant to be used as a bridge
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_duplicate_state</span></code></a> hook for bridges that don’t
subclass the bridge state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_bridge_destroy_state">
void <code class="sig-name descname">drm_atomic_helper_bridge_destroy_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_bridge_destroy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroy a bridge state object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>the bridge this state refers to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge_state</span> <span class="pre">*state</span></code></dt><dd><p>bridge state to destroy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroys a bridge state previously created by
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_helper_bridge_reset`()</span> <span class="pre">or</span>
<span class="pre">:c:type:`drm_atomic_helper_bridge_duplicate_state`().</span> <span class="pre">This</span> <span class="pre">helper</span> <span class="pre">is</span> <span class="pre">meant</span> <span class="pre">to</span> <span class="pre">be</span>
<span class="pre">used</span> <span class="pre">as</span> <span class="pre">a</span> <span class="pre">bridge</span> <span class="pre">:c:type:`drm_bridge_funcs.atomic_destroy_state</span></code></a> hook for bridges
that don’t subclass the bridge state.</p>
</div>
<dl class="function">
<dt id="c.__drm_atomic_helper_bridge_reset">
void <code class="sig-name descname">__drm_atomic_helper_bridge_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_helper_bridge_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a bridge state to its default</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>the bridge this state refers to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge_state</span> <span class="pre">*state</span></code></dt><dd><p>bridge state to initialize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the bridge state to default values. This is meant to be called
by the bridge <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_reset</span></code></a> hook for bridges that subclass
the bridge state.</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_helper_bridge_reset">
struct <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state">drm_bridge_state</a> * <code class="sig-name descname">drm_atomic_helper_bridge_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_helper_bridge_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and initialize a bridge state to its default</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>the bridge this state refers to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates the bridge state and initializes it to default values. This helper
is meant to be used as a bridge <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_reset</span></code></a> hook for
bridges that don’t subclass the bridge state.</p>
</div>
</section>
<section id="gem-atomic-helper-reference">
<h3>GEM Atomic Helper Reference<a class="headerlink" href="#gem-atomic-helper-reference" title="Permalink to this headline">¶</a></h3>
<p>The GEM atomic helpers library implements generic atomic-commit
functions for drivers that use GEM objects. Currently, it provides
synchronization helpers, and plane state and framebuffer BO mappings
for planes with shadow buffers.</p>
<p>Before scanout, a plane’s framebuffer needs to be synchronized with
possible writers that draw into the framebuffer. All drivers should
call <a class="reference internal" href="#c.drm_gem_plane_helper_prepare_fb" title="drm_gem_plane_helper_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_plane_helper_prepare_fb()</span></code></a> from their implementation of
struct <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper.prepare_fb</span></code> . It sets the plane’s fence from
the framebuffer so that the DRM core can synchronize access automatically.</p>
<p><a class="reference internal" href="#c.drm_gem_plane_helper_prepare_fb" title="drm_gem_plane_helper_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_plane_helper_prepare_fb()</span></code></a> can also be used directly as
implementation of prepare_fb. For drivers based on
<a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span></code></a>, <a class="reference internal" href="#c.drm_gem_simple_display_pipe_prepare_fb" title="drm_gem_simple_display_pipe_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_simple_display_pipe_prepare_fb()</span></code></a>
provides equivalent functionality.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;drm/drm_gem_atomic_helper.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="nc">drm_plane_helper_funcs</span><span class="w"> </span><span class="n">driver_plane_helper_funcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="w"> </span><span class="n">prepare_fb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">drm_gem_plane_helper_prepare_fb</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">drm_simple_display_pipe_funcs</span><span class="w"> </span><span class="n">driver_pipe_funcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="w"> </span><span class="n">prepare_fb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">drm_gem_simple_display_pipe_prepare_fb</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>A driver using a shadow buffer copies the content of the shadow buffers
into the HW’s framebuffer memory during an atomic update. This requires
a mapping of the shadow buffer into kernel address space. The mappings
cannot be established by commit-tail functions, such as atomic_update,
as this would violate locking rules around <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_vmap" title="dma_buf_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_vmap()</span></code></a>.</p>
<p>The helpers for shadow-buffered planes establish and release mappings,
and provide <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a>, which stores the plane’s mapping
for commit-tail functions.</p>
<p>Shadow-buffered planes can easily be enabled by using the provided macros
<code class="docutils literal notranslate"><span class="pre">DRM_GEM_SHADOW_PLANE_FUNCS</span></code> and <code class="docutils literal notranslate"><span class="pre">DRM_GEM_SHADOW_PLANE_HELPER_FUNCS</span></code>.
These macros set up the plane and plane-helper callbacks to point to the
shadow-buffer helpers.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;drm/drm_gem_atomic_helper.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="nc">drm_plane_funcs</span><span class="w"> </span><span class="n">driver_plane_funcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...,</span><span class="w"></span>
<span class="w">        </span><span class="n">DRM_GEM_SHADOW_PLANE_FUNCS</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">drm_plane_helper_funcs</span><span class="w"> </span><span class="n">driver_plane_helper_funcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...,</span><span class="w"></span>
<span class="w">        </span><span class="n">DRM_GEM_SHADOW_PLANE_HELPER_FUNCS</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>In the driver’s atomic-update function, shadow-buffer mappings are available
from the plane state. Use <a class="reference internal" href="#c.to_drm_shadow_plane_state" title="to_drm_shadow_plane_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">to_drm_shadow_plane_state()</span></code></a> to upcast from
<a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">driver_plane_atomic_update</span><span class="p">(</span><span class="k">struct</span> <span class="nc">drm_plane</span><span class="w"> </span><span class="o">*</span><span class="n">plane</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">struct</span> <span class="nc">drm_plane_state</span><span class="w"> </span><span class="o">*</span><span class="n">old_plane_state</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">drm_plane_state</span><span class="w"> </span><span class="o">*</span><span class="n">plane_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plane</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">drm_shadow_plane_state</span><span class="w"> </span><span class="o">*</span><span class="n">shadow_plane_state</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">                </span><span class="n">to_drm_shadow_plane_state</span><span class="p">(</span><span class="n">plane_state</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// access shadow buffer via shadow_plane_state-&gt;map</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A mapping address for each of the framebuffer’s buffer object is stored in
struct <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_shadow_plane_state.map</span></code></a>. The mappings are valid while the state
is being used.</p>
<p>Drivers that use <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span></code></a> can use
<code class="docutils literal notranslate"><span class="pre">DRM_GEM_SIMPLE_DISPLAY_PIPE_SHADOW_PLANE_FUNCS</span></code> to initialize the rsp
callbacks. Access to shadow-buffer mappings is similar to regular
atomic_update.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">drm_simple_display_pipe_funcs</span><span class="w"> </span><span class="n">driver_pipe_funcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...,</span><span class="w"></span>
<span class="w">        </span><span class="n">DRM_GEM_SIMPLE_DISPLAY_PIPE_SHADOW_PLANE_FUNCS</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">driver_pipe_enable</span><span class="p">(</span><span class="k">struct</span> <span class="nc">drm_simple_display_pipe</span><span class="w"> </span><span class="o">*</span><span class="n">pipe</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">struct</span> <span class="nc">drm_crtc_state</span><span class="w"> </span><span class="o">*</span><span class="n">crtc_state</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">struct</span> <span class="nc">drm_plane_state</span><span class="w"> </span><span class="o">*</span><span class="n">plane_state</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">drm_shadow_plane_state</span><span class="w"> </span><span class="o">*</span><span class="n">shadow_plane_state</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">                </span><span class="n">to_drm_shadow_plane_state</span><span class="p">(</span><span class="n">plane_state</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// access shadow buffer via shadow_plane_state-&gt;map</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<dl class="function">
<dt id="c.DRM_SHADOW_PLANE_MAX_WIDTH">
<code class="sig-name descname">DRM_SHADOW_PLANE_MAX_WIDTH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_SHADOW_PLANE_MAX_WIDTH" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum width of a plane’s shadow buffer in pixels</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>For drivers with shadow planes, the maximum width of the framebuffer is
usually independent from hardware limitations. Drivers can initialize <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_mode_config</span></code></a>.max_width from DRM_SHADOW_PLANE_MAX_WIDTH.</p>
</div>
<dl class="function">
<dt id="c.DRM_SHADOW_PLANE_MAX_HEIGHT">
<code class="sig-name descname">DRM_SHADOW_PLANE_MAX_HEIGHT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_SHADOW_PLANE_MAX_HEIGHT" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum height of a plane’s shadow buffer in scanlines</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>For drivers with shadow planes, the maximum height of the framebuffer is
usually independent from hardware limitations. Drivers can initialize <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_mode_config</span></code></a>.max_height from DRM_SHADOW_PLANE_MAX_HEIGHT.</p>
</div>
<dl class="type">
<dt id="c.drm_shadow_plane_state">
struct <code class="sig-name descname">drm_shadow_plane_state</code><a class="headerlink" href="#c.drm_shadow_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>plane state for planes with shadow buffers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_shadow_plane_state {
    struct drm_plane_state base;
    struct iosys_map map[DRM_FORMAT_MAX_PLANES];
    struct iosys_map data[DRM_FORMAT_MAX_PLANES];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>plane state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map</span></code></dt><dd><p>Mappings of the plane’s framebuffer BOs in to kernel address space</p>
<p>The memory mappings stored in map should be established in the plane’s
prepare_fb callback and removed in the cleanup_fb callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Address of each framebuffer BO’s data</p>
<p>The address of the data stored in each mapping. This is different
for framebuffers with non-zero offset fields.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>For planes that use a shadow buffer, <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a>
provides the regular plane state plus mappings of the shadow buffer
into kernel address space.</p>
<dl class="function">
<dt id="c.to_drm_shadow_plane_state">
struct <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state">drm_shadow_plane_state</a> * <code class="sig-name descname">to_drm_shadow_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.to_drm_shadow_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>upcasts from <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>the plane state</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.DRM_GEM_SHADOW_PLANE_FUNCS">
<code class="sig-name descname">DRM_GEM_SHADOW_PLANE_FUNCS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_GEM_SHADOW_PLANE_FUNCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_funcs</span></code></a> for shadow-buffered planes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Drivers may use GEM BOs as shadow buffers over the framebuffer memory. This
macro initializes <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_funcs</span></code></a> to use the rsp helper functions.</p>
</div>
<dl class="function">
<dt id="c.DRM_GEM_SHADOW_PLANE_HELPER_FUNCS">
<code class="sig-name descname">DRM_GEM_SHADOW_PLANE_HELPER_FUNCS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_GEM_SHADOW_PLANE_HELPER_FUNCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a> for shadow-buffered planes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Drivers may use GEM BOs as shadow buffers over the framebuffer memory. This
macro initializes <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a> to use the rsp helper
functions.</p>
</div>
<dl class="function">
<dt id="c.DRM_GEM_SIMPLE_DISPLAY_PIPE_SHADOW_PLANE_FUNCS">
<code class="sig-name descname">DRM_GEM_SIMPLE_DISPLAY_PIPE_SHADOW_PLANE_FUNCS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_GEM_SIMPLE_DISPLAY_PIPE_SHADOW_PLANE_FUNCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span></code></a> for shadow-buffered planes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Drivers may use GEM BOs as shadow buffers over the framebuffer memory. This
macro initializes <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span></code></a> to use the rsp helper
functions.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_plane_helper_prepare_fb">
int <code class="sig-name descname">drm_gem_plane_helper_prepare_fb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_plane_helper_prepare_fb" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a GEM backed framebuffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>Plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>Plane state the fence will be attached to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function extracts the exclusive fence from <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object.resv</span></code></a> and
attaches it to plane state for the atomic helper to wait on. This is
necessary to correctly implement implicit synchronization for any buffers
shared as a struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>. This function can be used as the
<a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a> callback.</p>
<p>There is no need for <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a> hook for simple
GEM based framebuffer drivers which have their buffers always pinned in
memory.</p>
<p>This function is the default implementation for GEM drivers of
<a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a> if no callback is provided.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_simple_display_pipe_prepare_fb">
int <code class="sig-name descname">drm_gem_simple_display_pipe_prepare_fb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a><em> *pipe</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_simple_display_pipe_prepare_fb" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare_fb helper for <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>Simple display pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>Plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function uses <a class="reference internal" href="#c.drm_gem_plane_helper_prepare_fb" title="drm_gem_plane_helper_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_plane_helper_prepare_fb()</span></code></a> to extract the fences
from <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object.resv</span></code></a> and attaches them to the plane state for the atomic
helper to wait on. This is necessary to correctly implement implicit
synchronization for any buffers shared as a struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>. Drivers can use
this as their <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe_funcs.prepare_fb</span></code></a> callback.</p>
<p>See <a class="reference internal" href="#c.drm_gem_plane_helper_prepare_fb" title="drm_gem_plane_helper_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_plane_helper_prepare_fb()</span></code></a> for a discussion of implicit and
explicit fencing in atomic modeset updates.</p>
</div>
<dl class="function">
<dt id="c.__drm_gem_duplicate_shadow_plane_state">
void <code class="sig-name descname">__drm_gem_duplicate_shadow_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state">drm_shadow_plane_state</a><em> *new_shadow_plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_gem_duplicate_shadow_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicates shadow-buffered plane state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>the plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span> <span class="pre">*new_shadow_plane_state</span></code></dt><dd><p>the new shadow-buffered plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function duplicates shadow-buffered plane state. This is helpful for drivers
that subclass <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a>.</p>
<p>The function does not duplicate existing mappings of the shadow buffers.
Mappings are maintained during the atomic commit by the plane’s prepare_fb
and cleanup_fb helpers. See drm_gem_prepare_shadow_fb() and drm_gem_cleanup_shadow_fb()
for corresponding helpers.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_duplicate_shadow_plane_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="sig-name descname">drm_gem_duplicate_shadow_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_duplicate_shadow_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicates shadow-buffered plane state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>the plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements struct <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.atomic_duplicate_state</span></code></a> for
shadow-buffered planes. It assumes the existing state to be of type
<a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a> and it allocates the new state to be of this
type.</p>
<p>The function does not duplicate existing mappings of the shadow buffers.
Mappings are maintained during the atomic commit by the plane’s prepare_fb
and cleanup_fb helpers. See drm_gem_prepare_shadow_fb() and drm_gem_cleanup_shadow_fb()
for corresponding helpers.</p>
<p><strong>Return</strong></p>
<p>A pointer to a new plane state on success, or NULL otherwise.</p>
</div>
<dl class="function">
<dt id="c.__drm_gem_destroy_shadow_plane_state">
void <code class="sig-name descname">__drm_gem_destroy_shadow_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state">drm_shadow_plane_state</a><em> *shadow_plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_gem_destroy_shadow_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up shadow-buffered plane state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span> <span class="pre">*shadow_plane_state</span></code></dt><dd><p>the shadow-buffered plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up shadow-buffered plane state. Helpful for drivers that
subclass <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_destroy_shadow_plane_state">
void <code class="sig-name descname">drm_gem_destroy_shadow_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_destroy_shadow_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes shadow-buffered plane state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>the plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>the plane state of type <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements struct <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.atomic_destroy_state</span></code></a>
for shadow-buffered planes. It expects that mappings of shadow buffers
have been released already.</p>
</div>
<dl class="function">
<dt id="c.__drm_gem_reset_shadow_plane">
void <code class="sig-name descname">__drm_gem_reset_shadow_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state">drm_shadow_plane_state</a><em> *shadow_plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_gem_reset_shadow_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>resets a shadow-buffered plane</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>the plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span> <span class="pre">*shadow_plane_state</span></code></dt><dd><p>the shadow-buffered plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function resets state for shadow-buffered planes. Helpful
for drivers that subclass <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_reset_shadow_plane">
void <code class="sig-name descname">drm_gem_reset_shadow_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_reset_shadow_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>resets a shadow-buffered plane</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>the plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements struct <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.reset_plane</span></code></a> for
shadow-buffered planes. It assumes the current plane state to be
of type struct drm_shadow_plane and it allocates the new state of
this type.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_begin_shadow_fb_access">
int <code class="sig-name descname">drm_gem_begin_shadow_fb_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_begin_shadow_fb_access" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares shadow framebuffers for CPU access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>the plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>the plane state of type <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements struct <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.begin_fb_access</span></code></a>. It
maps all buffer objects of the plane’s framebuffer into kernel address
space and stores them in struct <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_shadow_plane_state.map</span></code></a>. The first data
bytes are available in struct <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_shadow_plane_state.data</span></code></a>.</p>
<p>See <a class="reference internal" href="#c.drm_gem_end_shadow_fb_access" title="drm_gem_end_shadow_fb_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_end_shadow_fb_access()</span></code></a> for cleanup.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_end_shadow_fb_access">
void <code class="sig-name descname">drm_gem_end_shadow_fb_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_end_shadow_fb_access" title="Permalink to this definition">¶</a></dt>
<dd><p>releases shadow framebuffers from CPU access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>the plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>the plane state of type <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements struct <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.end_fb_access</span></code></a>. It
undoes all effects of <a class="reference internal" href="#c.drm_gem_begin_shadow_fb_access" title="drm_gem_begin_shadow_fb_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_begin_shadow_fb_access()</span></code></a> in reverse order.</p>
<p>See <a class="reference internal" href="#c.drm_gem_begin_shadow_fb_access" title="drm_gem_begin_shadow_fb_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_begin_shadow_fb_access()</span></code></a> for more information.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_simple_kms_begin_shadow_fb_access">
int <code class="sig-name descname">drm_gem_simple_kms_begin_shadow_fb_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a><em> *pipe</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_simple_kms_begin_shadow_fb_access" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares shadow framebuffers for CPU access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>the simple display pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>the plane state of type <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements struct drm_simple_display_funcs.begin_fb_access.</p>
<p>See <a class="reference internal" href="#c.drm_gem_begin_shadow_fb_access" title="drm_gem_begin_shadow_fb_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_begin_shadow_fb_access()</span></code></a> for details and
drm_gem_simple_kms_cleanup_shadow_fb() for cleanup.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_simple_kms_end_shadow_fb_access">
void <code class="sig-name descname">drm_gem_simple_kms_end_shadow_fb_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a><em> *pipe</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_simple_kms_end_shadow_fb_access" title="Permalink to this definition">¶</a></dt>
<dd><p>releases shadow framebuffers from CPU access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>the simple display pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>the plane state of type <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements struct drm_simple_display_funcs.end_fb_access.
It undoes all effects of <a class="reference internal" href="#c.drm_gem_simple_kms_begin_shadow_fb_access" title="drm_gem_simple_kms_begin_shadow_fb_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_simple_kms_begin_shadow_fb_access()</span></code></a> in
reverse order.</p>
<p>See <a class="reference internal" href="#c.drm_gem_simple_kms_begin_shadow_fb_access" title="drm_gem_simple_kms_begin_shadow_fb_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_simple_kms_begin_shadow_fb_access()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_simple_kms_reset_shadow_plane">
void <code class="sig-name descname">drm_gem_simple_kms_reset_shadow_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a><em> *pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_simple_kms_reset_shadow_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>resets a shadow-buffered plane</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>the simple display pipe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements struct drm_simple_display_funcs.reset_plane
for shadow-buffered planes.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_simple_kms_duplicate_shadow_plane_state">
struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="sig-name descname">drm_gem_simple_kms_duplicate_shadow_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a><em> *pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_simple_kms_duplicate_shadow_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicates shadow-buffered plane state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>the simple display pipe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements struct drm_simple_display_funcs.duplicate_plane_state
for shadow-buffered planes. It does not duplicate existing mappings of the shadow
buffers. Mappings are maintained during the atomic commit by the plane’s prepare_fb
and cleanup_fb helpers.</p>
<p><strong>Return</strong></p>
<p>A pointer to a new plane state on success, or NULL otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_simple_kms_destroy_shadow_plane_state">
void <code class="sig-name descname">drm_gem_simple_kms_destroy_shadow_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a><em> *pipe</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_simple_kms_destroy_shadow_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>resets shadow-buffered plane state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>the simple display pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>the plane state of type <a class="reference internal" href="#c.drm_shadow_plane_state" title="drm_shadow_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_shadow_plane_state</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements struct drm_simple_display_funcs.destroy_plane_state
for shadow-buffered planes. It expects that mappings of shadow buffers
have been released already.</p>
</div>
</section>
</section>
<section id="simple-kms-helper-reference">
<h2>Simple KMS Helper Reference<a class="headerlink" href="#simple-kms-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>This helper library provides helpers for drivers for simple display
hardware.</p>
<p><a class="reference internal" href="#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_display_pipe_init()</span></code></a> initializes a simple display pipeline
which has only one full-screen scanout buffer feeding one output. The
pipeline is represented by <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span></code></a> and binds
together <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a>, <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> structures into one fixed
entity. Some flexibility for code reuse is provided through a separately
allocated <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> object and supporting optional <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a>
encoder drivers.</p>
<p>Many drivers require only a very simple encoder that fulfills the minimum
requirements of the display pipeline and does not add additional
functionality. The function <a class="reference internal" href="#c.drm_simple_encoder_init" title="drm_simple_encoder_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_encoder_init()</span></code></a> provides an
implementation of such an encoder.</p>
<dl class="type">
<dt id="c.drm_simple_display_pipe_funcs">
struct <code class="sig-name descname">drm_simple_display_pipe_funcs</code><a class="headerlink" href="#c.drm_simple_display_pipe_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for a simple display pipeline</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_simple_display_pipe_funcs {
    enum drm_mode_status (*mode_valid)(struct drm_simple_display_pipe *pipe, const struct drm_display_mode *mode);
    void (*enable)(struct drm_simple_display_pipe *pipe,struct drm_crtc_state *crtc_state, struct drm_plane_state *plane_state);
    void (*disable)(struct drm_simple_display_pipe *pipe);
    int (*check)(struct drm_simple_display_pipe *pipe,struct drm_plane_state *plane_state, struct drm_crtc_state *crtc_state);
    void (*update)(struct drm_simple_display_pipe *pipe, struct drm_plane_state *old_plane_state);
    int (*prepare_fb)(struct drm_simple_display_pipe *pipe, struct drm_plane_state *plane_state);
    void (*cleanup_fb)(struct drm_simple_display_pipe *pipe, struct drm_plane_state *plane_state);
    int (*begin_fb_access)(struct drm_simple_display_pipe *pipe, struct drm_plane_state *new_plane_state);
    void (*end_fb_access)(struct drm_simple_display_pipe *pipe, struct drm_plane_state *plane_state);
    int (*enable_vblank)(struct drm_simple_display_pipe *pipe);
    void (*disable_vblank)(struct drm_simple_display_pipe *pipe);
    void (*reset_crtc)(struct drm_simple_display_pipe *pipe);
    struct drm_crtc_state * (*duplicate_crtc_state)(struct drm_simple_display_pipe *pipe);
    void (*destroy_crtc_state)(struct drm_simple_display_pipe *pipe, struct drm_crtc_state *crtc_state);
    void (*reset_plane)(struct drm_simple_display_pipe *pipe);
    struct drm_plane_state * (*duplicate_plane_state)(struct drm_simple_display_pipe *pipe);
    void (*destroy_plane_state)(struct drm_simple_display_pipe *pipe, struct drm_plane_state *plane_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid</span></code></dt><dd><p>This callback is used to check if a specific mode is valid in the
crtc used in this simple display pipe. This should be implemented
if the display pipe has some sort of restriction in the modes
it can display. For example, a given display pipe may be responsible
to set a clock value. If the clock can not produce all the values
for the available modes then this callback can be used to restrict
the number of modes to only the ones that can be displayed. Another
reason can be bandwidth mitigation: the memory port on the display
controller can have bandwidth limitations not allowing pixel data
to be fetched at any rate.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardware constraints.</p>
<p>RETURNS:</p>
<p>drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>This function should be used to enable the pipeline.
It is called when the underlying crtc is enabled.
This hook is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>This function should be used to disable the pipeline.
It is called when the underlying crtc is disabled.
This hook is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">check</span></code></dt><dd><p>This function is called in the check phase of an atomic update,
specifically when the underlying plane is checked.
The simple display pipeline helpers already check that the plane is
not scaled, fills the entire visible area and is always enabled
when the crtc is also enabled.
This hook is optional.</p>
<p>RETURNS:</p>
<p>0 on success, -EINVAL if the state or the transition can’t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">update</span></code></dt><dd><p>This function is called when the underlying plane state is updated.
This hook is optional.</p>
<p>This is the function drivers should submit the
<a class="reference internal" href="drm-kms.html#c.drm_pending_vblank_event" title="drm_pending_vblank_event"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_pending_vblank_event</span></code></a> from. Using either
<a class="reference internal" href="drm-kms.html#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a>, when the driver supports vblank
interrupt handling, or <a class="reference internal" href="drm-kms.html#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> for more
complex case. In case the hardware lacks vblank support entirely,
drivers can set <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>.no_vblank in
<a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span></code></a>.check and let DRM’s
atomic helper fake a vblank event.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_fb</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a>.  Please read
the documentation for the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a> hook for
more details.</p>
<p>For GEM drivers who neither have a <strong>prepare_fb</strong> nor <strong>cleanup_fb</strong> hook
set <a class="reference internal" href="#c.drm_gem_simple_display_pipe_prepare_fb" title="drm_gem_simple_display_pipe_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_simple_display_pipe_prepare_fb()</span></code></a> is called automatically
to implement this. Other drivers which need additional plane
processing can call <a class="reference internal" href="#c.drm_gem_simple_display_pipe_prepare_fb" title="drm_gem_simple_display_pipe_prepare_fb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_simple_display_pipe_prepare_fb()</span></code></a> from
their <strong>prepare_fb</strong> hook.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup_fb</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a>.  Please read
the documentation for the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a> hook for
more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">begin_fb_access</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.begin_fb_access</span></code></a>. Please read
the documentation for the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.begin_fb_access</span></code></a> hook for
more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end_fb_access</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.end_fb_access</span></code></a>. Please read
the documentation for the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_helper_funcs.end_fb_access</span></code></a> hook for
more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_vblank</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.enable_vblank</span></code></a>. Please read
the documentation for the <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.enable_vblank</span></code></a> hook for
more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_vblank</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.disable_vblank</span></code></a>. Please read
the documentation for the <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.disable_vblank</span></code></a> hook for
more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_crtc</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.reset</span></code></a>. Please read the
documentation for the <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.reset</span></code></a> hook for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duplicate_crtc_state</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.atomic_duplicate_state</span></code></a>. Please
read the documentation for the <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.atomic_duplicate_state</span></code></a>
hook for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy_crtc_state</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.atomic_destroy_state</span></code></a>. Please
read the documentation for the <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.atomic_destroy_state</span></code></a>
hook for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_plane</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.reset</span></code></a>. Please read the
documentation for the <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.reset</span></code></a> hook for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duplicate_plane_state</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.atomic_duplicate_state</span></code></a>.  Please
read the documentation for the <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.atomic_duplicate_state</span></code></a>
hook for more details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy_plane_state</span></code></dt><dd><p>Optional, called by <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.atomic_destroy_state</span></code></a>.  Please
read the documentation for the <a class="reference internal" href="drm-kms.html#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_funcs.atomic_destroy_state</span></code></a>
hook for more details.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_simple_display_pipe">
struct <code class="sig-name descname">drm_simple_display_pipe</code><a class="headerlink" href="#c.drm_simple_display_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>simple display pipeline</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_simple_display_pipe {
    struct drm_crtc crtc;
    struct drm_plane plane;
    struct drm_encoder encoder;
    struct drm_connector *connector;
    const struct drm_simple_display_pipe_funcs *funcs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>CRTC control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>Plane control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder</span></code></dt><dd><p>Encoder control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p>Connector control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>Pipeline control functions (optional)</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Simple display pipeline with plane, crtc and encoder collapsed into one
entity. It should be initialized by calling <a class="reference internal" href="#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_display_pipe_init()</span></code></a>.</p>
<dl class="function">
<dt id="c.drmm_simple_encoder_alloc">
<code class="sig-name descname">drmm_simple_encoder_alloc</code><span class="sig-paren">(</span><em>dev</em>, <em>type</em>, <em>member</em>, <em>encoder_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drmm_simple_encoder_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and initialize an encoder with basic functionality.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the struct which contains struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> within <strong>type</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder_type</span></code></dt><dd><p>user visible type of the encoder</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and initializes an encoder that has no further functionality.
Settings for possible CRTC and clones are left to their initial values.
Cleanup is automatically handled through registering <a class="reference internal" href="drm-kms.html#c.drm_encoder_cleanup" title="drm_encoder_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_encoder_cleanup()</span></code></a>
with <a class="reference internal" href="drm-internals.html#c.drmm_add_action" title="drmm_add_action"><code class="xref c c-func docutils literal notranslate"><span class="pre">drmm_add_action()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Pointer to new encoder, or ERR_PTR on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_simple_encoder_init">
int <code class="sig-name descname">drm_simple_encoder_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a><em> *encoder</em>, int<em> encoder_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_simple_encoder_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a preallocated encoder with basic functionality.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>the encoder to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">encoder_type</span></code></dt><dd><p>user visible type of the encoder</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises a preallocated encoder that has no further functionality.
Settings for possible CRTC and clones are left to their initial values.
The encoder will be cleaned up automatically as part of the mode-setting
cleanup.</p>
<p>The caller of <a class="reference internal" href="#c.drm_simple_encoder_init" title="drm_simple_encoder_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_encoder_init()</span></code></a> is responsible for freeing
the encoder’s memory after the encoder has been cleaned up. At the
moment this only works reliably if the encoder data structure is
stored in the device structure. Free the encoder’s memory as part of
the device release function.</p>
<p><strong>Note</strong></p>
<p>consider using <a class="reference internal" href="#c.drmm_simple_encoder_alloc" title="drmm_simple_encoder_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drmm_simple_encoder_alloc()</span></code></a> instead of
<a class="reference internal" href="#c.drm_simple_encoder_init" title="drm_simple_encoder_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_encoder_init()</span></code></a> to let the DRM managed resource infrastructure
take care of cleanup and deallocation.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_simple_display_pipe_attach_bridge">
int <code class="sig-name descname">drm_simple_display_pipe_attach_bridge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a><em> *pipe</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_simple_display_pipe_attach_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a bridge to the display pipe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>simple display pipe object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge to attach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes it possible to still use the drm_simple_display_pipe helpers when
a DRM bridge has to be used.</p>
<p>Note that you probably want to initialize the pipe by passing a NULL
connector to <a class="reference internal" href="#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_display_pipe_init()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_simple_display_pipe_init">
int <code class="sig-name descname">drm_simple_display_pipe_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a><em> *pipe</em>, const struct <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs">drm_simple_display_pipe_funcs</a><em> *funcs</em>, const uint32_t<em> *formats</em>, unsigned int<em> format_count</em>, const uint64_t<em> *format_modifiers</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_simple_display_pipe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a simple display pipeline</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>simple display pipe object to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>callbacks for the display pipe (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*formats</span></code></dt><dd><p>array of supported formats (DRM_FORMAT_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">format_count</span></code></dt><dd><p>number of elements in <strong>formats</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint64_t</span> <span class="pre">*format_modifiers</span></code></dt><dd><p>array of formats modifiers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to attach and register (optional)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up a display pipeline which consist of a really simple
plane-crtc-encoder pipe.</p>
<p>If a connector is supplied, the pipe will be coupled with the provided
connector. You may supply a NULL connector when using drm bridges, that
handle connectors themselves (see <a class="reference internal" href="#c.drm_simple_display_pipe_attach_bridge" title="drm_simple_display_pipe_attach_bridge"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_simple_display_pipe_attach_bridge()</span></code></a>).</p>
<p>Teardown of a simple display pipe is all handled automatically by the drm
core through calling <a class="reference internal" href="drm-kms.html#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a>. Drivers afterwards need to
release the memory for the structure themselves.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
</section>
<section id="fbdev-helper-functions-reference">
<h2>fbdev Helper Functions Reference<a class="headerlink" href="#fbdev-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>The fb helper functions are useful to provide an fbdev on top of a drm kernel
mode setting driver. They can be used mostly independently from the crtc
helper functions used by many drivers to implement the kernel mode setting
interfaces.</p>
<p>Drivers that support a dumb buffer with a virtual address and mmap support,
should try out the generic fbdev emulation using <a class="reference internal" href="#c.drm_fbdev_generic_setup" title="drm_fbdev_generic_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fbdev_generic_setup()</span></code></a>.
It will automatically set up deferred I/O if the driver requires a shadow
buffer.</p>
<p>Existing fbdev implementations should restore the fbdev console by using
<a class="reference internal" href="#c.drm_fb_helper_lastclose" title="drm_fb_helper_lastclose"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_lastclose()</span></code></a> as their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.lastclose</span></code></a> callback.
They should also notify the fb helper code from updates to the output
configuration by using <a class="reference internal" href="#c.drm_fb_helper_output_poll_changed" title="drm_fb_helper_output_poll_changed"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_output_poll_changed()</span></code></a> as their
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.output_poll_changed</span></code></a> callback. New implementations
of fbdev should be build on top of struct <a class="reference internal" href="drm-client.html#c.drm_client_funcs" title="drm_client_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_client_funcs</span></code></a>, which handles
this automatically. Setting the old callbacks should be avoided.</p>
<p>For suspend/resume consider using <a class="reference internal" href="#c.drm_mode_config_helper_suspend" title="drm_mode_config_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_helper_suspend()</span></code></a> and
<a class="reference internal" href="#c.drm_mode_config_helper_resume" title="drm_mode_config_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_helper_resume()</span></code></a> which takes care of fbdev as well.</p>
<p>All other functions exported by the fb helper library can be used to
implement the fbdev driver interface by the driver.</p>
<p>It is possible, though perhaps somewhat tricky, to implement race-free
hotplug detection using the fbdev helpers. The <a class="reference internal" href="#c.drm_fb_helper_prepare" title="drm_fb_helper_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_prepare()</span></code></a>
helper must be called first to initialize the minimum required to make
hotplug detection work. Drivers also need to make sure to properly set up
the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config.funcs</span></code></a> member. After calling <a class="reference internal" href="#c.drm_kms_helper_poll_init" title="drm_kms_helper_poll_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_init()</span></code></a>
it is safe to enable interrupts and start processing hotplug events. At the
same time, drivers should initialize all modeset objects such as CRTCs,
encoders and connectors. To finish up the fbdev helper initialization, the
<a class="reference internal" href="#c.drm_fb_helper_init" title="drm_fb_helper_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_init()</span></code></a> function is called. To probe for all attached displays
and set up an initial configuration using the detected hardware, drivers
should call <a class="reference internal" href="#c.drm_fb_helper_initial_config" title="drm_fb_helper_initial_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_initial_config()</span></code></a>.</p>
<p>If <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs.dirty</span></code></a> is set, the
drm_fb_helper_{cfb,sys}_{write,fillrect,copyarea,imageblit} functions will
accumulate changes and schedule <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_fb_helper.dirty_work</span></code></a> to run right
away. This worker then calls the dirty() function ensuring that it will
always run in process context since the fb_*() function could be running in
atomic context. If <a class="reference internal" href="#c.drm_fb_helper_deferred_io" title="drm_fb_helper_deferred_io"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_deferred_io()</span></code></a> is used as the deferred_io
callback it will also schedule dirty_work with the damage collected from the
mmap page writes.</p>
<p>Deferred I/O is not compatible with SHMEM. Such drivers should request an
fbdev shadow buffer and call <a class="reference internal" href="#c.drm_fbdev_generic_setup" title="drm_fbdev_generic_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fbdev_generic_setup()</span></code></a> instead.</p>
<dl class="type">
<dt id="c.drm_fb_helper_surface_size">
struct <code class="sig-name descname">drm_fb_helper_surface_size</code><a class="headerlink" href="#c.drm_fb_helper_surface_size" title="Permalink to this definition">¶</a></dt>
<dd><p>describes fbdev size and scanout surface size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_fb_helper_surface_size {
    u32 fb_width;
    u32 fb_height;
    u32 surface_width;
    u32 surface_height;
    u32 surface_bpp;
    u32 surface_depth;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fb_width</span></code></dt><dd><p>fbdev width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb_height</span></code></dt><dd><p>fbdev height</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">surface_width</span></code></dt><dd><p>scanout buffer width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">surface_height</span></code></dt><dd><p>scanout buffer height</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">surface_bpp</span></code></dt><dd><p>scanout buffer bpp</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">surface_depth</span></code></dt><dd><p>scanout buffer depth</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note that the scanout surface width/height may be larger than the fbdev
width/height.  In case of multiple displays, the scanout surface is sized
according to the largest width/height (so it is large enough for all CRTCs
to scanout).  But the fbdev width/height is sized to the minimum width/
height of all the displays.  This ensures that fbcon fits on the smallest
of the attached displays. fb_width/fb_height is used by
<a class="reference internal" href="#c.drm_fb_helper_fill_info" title="drm_fb_helper_fill_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_fill_info()</span></code></a> to fill out the <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_info.var</span></code> structure.</p>
<dl class="type">
<dt id="c.drm_fb_helper_funcs">
struct <code class="sig-name descname">drm_fb_helper_funcs</code><a class="headerlink" href="#c.drm_fb_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>driver callbacks for the fbdev emulation library</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_fb_helper_funcs {
    int (*fb_probe)(struct drm_fb_helper *helper, struct drm_fb_helper_surface_size *sizes);
    int (*fb_dirty)(struct drm_fb_helper *helper, struct drm_clip_rect *clip);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">fb_probe</span></code></dt><dd><p>Driver callback to allocate and initialize the fbdev info structure.
Furthermore it also needs to allocate the DRM framebuffer used to
back the fbdev.</p>
<p>This callback is mandatory.</p>
<p>RETURNS:</p>
<p>The driver should return 0 on success and a negative error code on
failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb_dirty</span></code></dt><dd><p>Driver callback to update the framebuffer memory. If set, fbdev
emulation will invoke this callback in regular intervals after
the framebuffer has been written.</p>
<p>This callback is optional.</p>
<p>Returns:
0 on success, or an error code otherwise.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Driver callbacks used by the fbdev emulation helper library.</p>
<dl class="type">
<dt id="c.drm_fb_helper">
struct <code class="sig-name descname">drm_fb_helper</code><a class="headerlink" href="#c.drm_fb_helper" title="Permalink to this definition">¶</a></dt>
<dd><p>main structure to emulate fbdev on top of KMS</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_fb_helper {
    struct drm_client_dev client;
    struct drm_client_buffer *buffer;
    struct drm_framebuffer *fb;
    struct drm_device *dev;
    const struct drm_fb_helper_funcs *funcs;
    struct fb_info *info;
    u32 pseudo_palette[17];
    struct drm_clip_rect damage_clip;
    spinlock_t damage_lock;
    struct work_struct damage_work;
    struct work_struct resume_work;
    struct mutex lock;
    struct list_head kernel_fb_list;
    bool delayed_hotplug;
    bool deferred_setup;
    int preferred_bpp;
    bool hint_leak_smem_start;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">client</span></code></dt><dd><p>DRM client used by the generic fbdev emulation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>Framebuffer used by the generic fbdev emulation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fb</span></code></dt><dd><p>Scanout framebuffer object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>driver callbacks for fb helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>emulated fbdev device info struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pseudo_palette</span></code></dt><dd><p>fake palette of 16 colors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">damage_clip</span></code></dt><dd><p>clip rectangle used with deferred_io to accumulate damage to
the screen buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">damage_lock</span></code></dt><dd><p>spinlock protecting <strong>damage_clip</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">damage_work</span></code></dt><dd><p>worker used to flush the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume_work</span></code></dt><dd><p>worker used during resume if the console lock is already taken</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Top-level FBDEV helper lock. This protects all internal data
structures and lists, such as <strong>connector_info</strong> and <strong>crtc_info</strong>.</p>
<p>FIXME: fbdev emulation locking is a mess and long term we want to
protect all helper internal state with this lock as well as reduce
core KMS locking as much as possible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_fb_list</span></code></dt><dd><p>Entry on the global kernel_fb_helper_list, used for kgdb entry/exit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delayed_hotplug</span></code></dt><dd><p>A hotplug was received while fbdev wasn’t in control of the DRM
device, i.e. another KMS master was active. The output configuration
needs to be reprobe when fbdev is in control again.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deferred_setup</span></code></dt><dd><p>If no outputs are connected (disconnected or unknown) the FB helper
code will defer setup until at least one of the outputs shows up.
This field keeps track of the status so that setup can be retried
at every hotplug event until it succeeds eventually.</p>
<p>Protected by <strong>lock</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">preferred_bpp</span></code></dt><dd><p>Temporary storage for the driver’s preferred BPP setting passed to
FB helper initialization. This needs to be tracked so that deferred
FB helper setup can pass this on.</p>
<p>See also: <strong>deferred_setup</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hint_leak_smem_start</span></code></dt><dd><p>Hint to the fbdev emulation to store the framebuffer’s physical
address in struct <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_info.fix</span></code>.smem_start. If the hint is unset,
the smem_start field should always be cleared to zero.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is the main structure used by the fbdev helpers. Drivers supporting
fbdev emulation should embedded this into their overall driver structure.
Drivers must also fill out a <a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper_funcs</span></code></a> with a few
operations.</p>
<dl class="function">
<dt id="c.DRM_FB_HELPER_DEFAULT_OPS">
<code class="sig-name descname">DRM_FB_HELPER_DEFAULT_OPS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_FB_HELPER_DEFAULT_OPS" title="Permalink to this definition">¶</a></dt>
<dd><p>helper define for drm drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Helper define to register default implementations of drm_fb_helper
functions. To be used in struct fb_ops of drm drivers.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_debug_enter">
int <code class="sig-name descname">drm_fb_helper_debug_enter</code><span class="sig-paren">(</span>struct fb_info<em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_debug_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_debug_enter</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_debug_leave">
int <code class="sig-name descname">drm_fb_helper_debug_leave</code><span class="sig-paren">(</span>struct fb_info<em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_debug_leave" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_debug_leave</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_restore_fbdev_mode_unlocked">
int <code class="sig-name descname">drm_fb_helper_restore_fbdev_mode_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a><em> *fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_restore_fbdev_mode_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>restore fbdev configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called from driver’s drm <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver.lastclose</span></code></a> callback
when implementing an fbcon on top of kms using this helper. This ensures that
the user isn’t greeted with a black screen when e.g. X dies.</p>
<p><strong>Return</strong></p>
<p>Zero if everything went ok, negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_blank">
int <code class="sig-name descname">drm_fb_helper_blank</code><span class="sig-paren">(</span>int<em> blank</em>, struct fb_info<em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_blank" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_blank</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">blank</span></code></dt><dd><p>desired blanking state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_prepare">
void <code class="sig-name descname">drm_fb_helper_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a><em> *helper</em>, const struct <a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs">drm_fb_helper_funcs</a><em> *funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a drm_fb_helper structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*helper</span></code></dt><dd><p>driver-allocated fbdev helper structure to set up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_fb_helper_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>pointer to structure of functions associate with this helper</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up the bare minimum to make the framebuffer helper usable. This is
useful to implement race-free initialization of the polling helpers.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_init">
int <code class="sig-name descname">drm_fb_helper_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a><em> *fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper structure to initialize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allocates the structures for the fbdev helper with the given limits.
Note that this won’t yet touch the hardware (through the driver interfaces)
nor register the fbdev. This is only done in <a class="reference internal" href="#c.drm_fb_helper_initial_config" title="drm_fb_helper_initial_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_initial_config()</span></code></a>
to allow driver writes more control over the exact init sequence.</p>
<p>Drivers must call <a class="reference internal" href="#c.drm_fb_helper_prepare" title="drm_fb_helper_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_prepare()</span></code></a> before calling this function.</p>
<p><strong>Return</strong></p>
<p>Zero if everything went ok, nonzero otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_alloc_info">
struct fb_info * <code class="sig-name descname">drm_fb_helper_alloc_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a><em> *fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_alloc_info" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate fb_info and some of its members</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A helper to alloc fb_info and the members cmap and apertures. Called
by the driver within the fb_probe fb_helper callback function. Drivers do not
need to release the allocated fb_info structure themselves, this is
automatically done when calling <a class="reference internal" href="#c.drm_fb_helper_fini" title="drm_fb_helper_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_fini()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>fb_info pointer if things went okay, pointer containing error code
otherwise</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_unregister_info">
void <code class="sig-name descname">drm_fb_helper_unregister_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a><em> *fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_unregister_info" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister fb_info framebuffer device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around unregister_framebuffer, to release the fb_info
framebuffer device. This must be called before releasing all resources for
<strong>fb_helper</strong> by calling <a class="reference internal" href="#c.drm_fb_helper_fini" title="drm_fb_helper_fini"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_fini()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_fini">
void <code class="sig-name descname">drm_fb_helper_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a><em> *fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>finialize a <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This cleans up all remaining resources associated with <strong>fb_helper</strong>.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_deferred_io">
void <code class="sig-name descname">drm_fb_helper_deferred_io</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, struct list_head<em> *pagereflist</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_deferred_io" title="Permalink to this definition">¶</a></dt>
<dd><p>fbdev deferred_io callback function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fb_info struct pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*pagereflist</span></code></dt><dd><p>list of mmap framebuffer pages that have to be flushed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used as the <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_deferred_io.deferred_io</span></code>
callback function for flushing the fbdev mmap writes.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_sys_read">
ssize_t <code class="sig-name descname">drm_fb_helper_sys_read</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, char __user<em> *buf</em>, size_t<em> count</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements struct <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_read</span></code> for system memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fb_info struct pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>userspace buffer to read from framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to read from framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>read offset within framebuffer memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bytes read on success, or an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_sys_write">
ssize_t <code class="sig-name descname">drm_fb_helper_sys_write</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, const char __user<em> *buf</em>, size_t<em> count</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements struct <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_write</span></code> for system memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fb_info struct pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>userspace buffer to write to framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to write to framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>write offset within framebuffer memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bytes written on success, or an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_sys_fillrect">
void <code class="sig-name descname">drm_fb_helper_sys_fillrect</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, const struct fb_fillrect<em> *rect</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_fillrect" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around sys_fillrect</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_fillrect</span> <span class="pre">*rect</span></code></dt><dd><p>info about rectangle to fill</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around sys_fillrect implemented by fbdev core</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_sys_copyarea">
void <code class="sig-name descname">drm_fb_helper_sys_copyarea</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, const struct fb_copyarea<em> *area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_copyarea" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around sys_copyarea</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_copyarea</span> <span class="pre">*area</span></code></dt><dd><p>info about area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around sys_copyarea implemented by fbdev core</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_sys_imageblit">
void <code class="sig-name descname">drm_fb_helper_sys_imageblit</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, const struct fb_image<em> *image</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_sys_imageblit" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around sys_imageblit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_image</span> <span class="pre">*image</span></code></dt><dd><p>info about image to blit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around sys_imageblit implemented by fbdev core</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_cfb_read">
ssize_t <code class="sig-name descname">drm_fb_helper_cfb_read</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, char __user<em> *buf</em>, size_t<em> count</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_cfb_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements struct <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_read</span></code> for I/O memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fb_info struct pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>userspace buffer to read from framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to read from framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>read offset within framebuffer memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bytes read on success, or an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_cfb_write">
ssize_t <code class="sig-name descname">drm_fb_helper_cfb_write</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, const char __user<em> *buf</em>, size_t<em> count</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_cfb_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements struct <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_write</span></code> for I/O memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fb_info struct pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>userspace buffer to write to framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to write to framebuffer memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>write offset within framebuffer memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bytes written on success, or an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_cfb_fillrect">
void <code class="sig-name descname">drm_fb_helper_cfb_fillrect</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, const struct fb_fillrect<em> *rect</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_cfb_fillrect" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around cfb_fillrect</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_fillrect</span> <span class="pre">*rect</span></code></dt><dd><p>info about rectangle to fill</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around cfb_fillrect implemented by fbdev core</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_cfb_copyarea">
void <code class="sig-name descname">drm_fb_helper_cfb_copyarea</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, const struct fb_copyarea<em> *area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_cfb_copyarea" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around cfb_copyarea</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_copyarea</span> <span class="pre">*area</span></code></dt><dd><p>info about area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around cfb_copyarea implemented by fbdev core</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_cfb_imageblit">
void <code class="sig-name descname">drm_fb_helper_cfb_imageblit</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, const struct fb_image<em> *image</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_cfb_imageblit" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around cfb_imageblit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fb_image</span> <span class="pre">*image</span></code></dt><dd><p>info about image to blit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around cfb_imageblit implemented by fbdev core</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_set_suspend">
void <code class="sig-name descname">drm_fb_helper_set_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a><em> *fb_helper</em>, bool<em> suspend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_set_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around fb_set_suspend</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">suspend</span></code></dt><dd><p>whether to suspend or resume</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around fb_set_suspend implemented by fbdev core.
Use <a class="reference internal" href="#c.drm_fb_helper_set_suspend_unlocked" title="drm_fb_helper_set_suspend_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_set_suspend_unlocked()</span></code></a> if you don’t need to take
the lock yourself</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_set_suspend_unlocked">
void <code class="sig-name descname">drm_fb_helper_set_suspend_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a><em> *fb_helper</em>, bool<em> suspend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_set_suspend_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper around fb_set_suspend that also takes the console lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">suspend</span></code></dt><dd><p>whether to suspend or resume</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A wrapper around <a class="reference internal" href="../driver-api/frame-buffer.html#c.fb_set_suspend" title="fb_set_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">fb_set_suspend()</span></code></a> that takes the console lock. If the lock
isn’t available on resume, a worker is tasked with waiting for the lock
to become available. The console lock can be pretty contented on resume
due to all the printk activity.</p>
<p>This function can be called multiple times with the same state since
<code class="xref c c-type docutils literal notranslate"><span class="pre">fb_info.state</span></code> is checked to see if fbdev is running or not before locking.</p>
<p>Use <a class="reference internal" href="#c.drm_fb_helper_set_suspend" title="drm_fb_helper_set_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_set_suspend()</span></code></a> if you need to take the lock yourself.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_setcmap">
int <code class="sig-name descname">drm_fb_helper_setcmap</code><span class="sig-paren">(</span>struct fb_cmap<em> *cmap</em>, struct fb_info<em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_setcmap" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_setcmap</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_cmap</span> <span class="pre">*cmap</span></code></dt><dd><p>cmap to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_ioctl">
int <code class="sig-name descname">drm_fb_helper_ioctl</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, unsigned int<em> cmd</em>, unsigned long<em> arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>legacy ioctl implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt><dd><p>ioctl argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A helper to implement the standard fbdev ioctl. Only
FBIO_WAITFORVSYNC is implemented for now.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_check_var">
int <code class="sig-name descname">drm_fb_helper_check_var</code><span class="sig-paren">(</span>struct fb_var_screeninfo<em> *var</em>, struct fb_info<em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_check_var" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_check_var</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_var_screeninfo</span> <span class="pre">*var</span></code></dt><dd><p>screeninfo to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_set_par">
int <code class="sig-name descname">drm_fb_helper_set_par</code><span class="sig-paren">(</span>struct fb_info<em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_set_par" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_set_par</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will let fbcon do the mode init and is called at initialization time by
the fbdev core when registering the driver, and later on through the hotplug
callback.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_pan_display">
int <code class="sig-name descname">drm_fb_helper_pan_display</code><span class="sig-paren">(</span>struct fb_var_screeninfo<em> *var</em>, struct fb_info<em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_pan_display" title="Permalink to this definition">¶</a></dt>
<dd><p>implementation for <code class="xref c c-type docutils literal notranslate"><span class="pre">fb_ops.fb_pan_display</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_var_screeninfo</span> <span class="pre">*var</span></code></dt><dd><p>updated screen information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev registered by the helper</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_fill_info">
void <code class="sig-name descname">drm_fb_helper_fill_info</code><span class="sig-paren">(</span>struct fb_info<em> *info</em>, struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a><em> *fb_helper</em>, struct <a class="reference internal" href="#c.drm_fb_helper_surface_size" title="drm_fb_helper_surface_size">drm_fb_helper_surface_size</a><em> *sizes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_fill_info" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes fbdev information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*info</span></code></dt><dd><p>fbdev instance to set up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*fb_helper</span></code></dt><dd><p>fb helper instance to use as template</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper_surface_size</span> <span class="pre">*sizes</span></code></dt><dd><p>describes fbdev size and scanout surface size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up the variable and fixed fbdev metainformation from the given fb helper
instance and the drm framebuffer allocated in <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_fb_helper.fb</span></code></a>.</p>
<p>Drivers should call this (or their equivalent setup code) from their
<a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_fb_helper_funcs.fb_probe</span></code></a> callback after having allocated the fbdev
backing storage framebuffer.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_initial_config">
int <code class="sig-name descname">drm_fb_helper_initial_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a><em> *fb_helper</em>, int<em> bpp_sel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_initial_config" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a sane initial connector configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*fb_helper</span></code></dt><dd><p>fb_helper device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bpp_sel</span></code></dt><dd><p>bpp value to use for the framebuffer configuration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scans the CRTCs and connectors and tries to put together an initial setup.
At the moment, this is a cloned configuration across all heads with
a new framebuffer object as the backing store.</p>
<p>Note that this also registers the fbdev and so allows userspace to call into
the driver through the fbdev interfaces.</p>
<p>This function will call down into the <a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_fb_helper_funcs.fb_probe</span></code></a> callback
to let the driver allocate and initialize the fbdev info structure and the
drm framebuffer used to back the fbdev. <a class="reference internal" href="#c.drm_fb_helper_fill_info" title="drm_fb_helper_fill_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_fill_info()</span></code></a> is provided
as a helper to setup simple default values for the fbdev info structure.</p>
<p>HANG DEBUGGING:</p>
<p>When you have fbcon support built-in or already loaded, this function will do
a full modeset to setup the fbdev console. Due to locking misdesign in the
VT/fbdev subsystem that entire modeset sequence has to be done while holding
console_lock. Until console_unlock is called no dmesg lines will be sent out
to consoles, not even serial console. This means when your driver crashes,
you will see absolutely nothing else but a system stuck in this function,
with no further output. Any kind of <a class="reference internal" href="../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> you place within your own driver
or in the drm core modeset code will also never show up.</p>
<p>Standard debug practice is to run the fbcon setup without taking the
console_lock as a hack, to be able to see backtraces and crashes on the
serial line. This can be done by setting the fb.lockless_register_fb=1 kernel
cmdline option.</p>
<p>The other option is to just disable fbdev emulation since very likely the
first modeset from userspace will crash in the same way, and is even easier
to debug. This can be done by setting the drm_kms_helper.fbdev_emulation=0
kernel cmdline option.</p>
<p><strong>Return</strong></p>
<p>Zero if everything went ok, nonzero otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_hotplug_event">
int <code class="sig-name descname">drm_fb_helper_hotplug_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_fb_helper" title="drm_fb_helper">drm_fb_helper</a><em> *fb_helper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_hotplug_event" title="Permalink to this definition">¶</a></dt>
<dd><p>respond to a hotplug notification by probing all the outputs attached to the fb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_fb_helper</span> <span class="pre">*fb_helper</span></code></dt><dd><p>driver-allocated fbdev helper, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan the connectors attached to the fb_helper and try to put together a
setup after notification of a change in output configuration.</p>
<p>Called at runtime, takes the mode config locks to be able to check/change the
modeset configuration. Must be run from process context (which usually means
either the output polling work or a work item launched from the driver’s
hotplug interrupt).</p>
<p>Note that drivers may call this even before calling
drm_fb_helper_initial_config but only after drm_fb_helper_init. This allows
for a race-free fbcon setup and will make sure that the fbdev emulation will
not miss any hotplug events.</p>
<p><strong>Return</strong></p>
<p>0 on success and a non-zero error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_lastclose">
void <code class="sig-name descname">drm_fb_helper_lastclose</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_lastclose" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM driver lastclose helper for fbdev emulation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver-&gt;lastclose</span></code></a> callback for drivers
that only need to call <a class="reference internal" href="#c.drm_fb_helper_restore_fbdev_mode_unlocked" title="drm_fb_helper_restore_fbdev_mode_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_restore_fbdev_mode_unlocked()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_helper_output_poll_changed">
void <code class="sig-name descname">drm_fb_helper_output_poll_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_helper_output_poll_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM mode config .output_poll_changed helper for fbdev emulation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as the
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.output_poll_changed</span></code></a> callback for drivers that only
need to call drm_fbdev.hotplug_event().</p>
</div>
<dl class="function">
<dt id="c.drm_fbdev_generic_setup">
void <code class="sig-name descname">drm_fbdev_generic_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, unsigned int<em> preferred_bpp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fbdev_generic_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup generic fbdev emulation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">preferred_bpp</span></code></dt><dd><p>Preferred bits per pixel for the device.
<strong>dev-&gt;mode_config.preferred_depth</strong> is used if this is zero.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets up generic fbdev emulation for drivers that supports
dumb buffers with a virtual address and that can be mmap’ed.
<a class="reference internal" href="#c.drm_fbdev_generic_setup" title="drm_fbdev_generic_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fbdev_generic_setup()</span></code></a> shall be called after the DRM driver registered
the new DRM device with <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_register()</span></code></a>.</p>
<p>Restore, hotplug events and teardown are all taken care of. Drivers that do
suspend/resume need to call <a class="reference internal" href="#c.drm_fb_helper_set_suspend_unlocked" title="drm_fb_helper_set_suspend_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_set_suspend_unlocked()</span></code></a> themselves.
Simple drivers might use <a class="reference internal" href="#c.drm_mode_config_helper_suspend" title="drm_mode_config_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_helper_suspend()</span></code></a>.</p>
<p>Drivers that set the dirty callback on their framebuffer will get a shadow
fbdev buffer that is blitted onto the real buffer. This is done in order to
make deferred I/O work with all kinds of buffers. A shadow buffer can be
requested explicitly by setting <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_config</span></code></a>.prefer_shadow or
<a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_config</span></code></a>.prefer_shadow_fbdev to true beforehand. This is
required to use generic fbdev emulation with SHMEM helpers.</p>
<p>This function is safe to call even when there are no connectors present.
Setup will be retried on the next hotplug event.</p>
<p>The fbdev is destroyed by <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dev_unregister()</span></code></a>.</p>
</div>
</section>
<section id="format-helper-functions-reference">
<h2>format Helper Functions Reference<a class="headerlink" href="#format-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.drm_fb_clip_offset">
unsigned int <code class="sig-name descname">drm_fb_clip_offset</code><span class="sig-paren">(</span>unsigned int<em> pitch</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_format_info" title="drm_format_info">drm_format_info</a><em> *format</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_clip_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the clipping rectangles byte-offset in a framebuffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pitch</span></code></dt><dd><p>Framebuffer line pitch in byte</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*format</span></code></dt><dd><p>Framebuffer format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>Clip rectangle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The byte offset of the clip rectangle’s top-left corner within the framebuffer.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_memcpy">
void <code class="sig-name descname">drm_fb_memcpy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *dst</em>, const unsigned int<em> *dst_pitch</em>, const struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *src</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_memcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy clip buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*dst</span></code></dt><dd><p>Array of destination buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*dst_pitch</span></code></dt><dd><p>Array of numbers of bytes between the start of two consecutive scanlines
within <strong>dst</strong>; can be NULL if scanlines are stored next to each other.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*src</span></code></dt><dd><p>Array of source buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies parts of a framebuffer to display memory. Destination and
framebuffer formats must match. No conversion takes place. The parameters <strong>dst</strong>,
<strong>dst_pitch</strong> and <strong>src</strong> refer to arrays. Each array must have at least as many entries
as there are planes in <strong>fb</strong>’s format. Each entry stores the value for the format’s
respective color plane at the same index.</p>
<p>This function does not apply clipping on <strong>dst</strong> (i.e. the destination is at the
top-left corner).</p>
</div>
<dl class="function">
<dt id="c.drm_fb_swab">
void <code class="sig-name descname">drm_fb_swab</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *dst</em>, const unsigned int<em> *dst_pitch</em>, const struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *src</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em>, bool<em> cached</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_swab" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap bytes into clip buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*dst</span></code></dt><dd><p>Array of destination buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*dst_pitch</span></code></dt><dd><p>Array of numbers of bytes between the start of two consecutive scanlines
within <strong>dst</strong>; can be NULL if scanlines are stored next to each other.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*src</span></code></dt><dd><p>Array of source buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">cached</span></code></dt><dd><p>Source buffer is mapped cached (eg. not write-combined)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies parts of a framebuffer to display memory and swaps per-pixel
bytes during the process. Destination and framebuffer formats must match. The
parameters <strong>dst</strong>, <strong>dst_pitch</strong> and <strong>src</strong> refer to arrays. Each array must have at
least as many entries as there are planes in <strong>fb</strong>’s format. Each entry stores the
value for the format’s respective color plane at the same index. If <strong>cached</strong> is
false a temporary buffer is used to cache one pixel line at a time to speed up
slow uncached reads.</p>
<p>This function does not apply clipping on <strong>dst</strong> (i.e. the destination is at the
top-left corner).</p>
</div>
<dl class="function">
<dt id="c.drm_fb_xrgb8888_to_rgb332">
void <code class="sig-name descname">drm_fb_xrgb8888_to_rgb332</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *dst</em>, const unsigned int<em> *dst_pitch</em>, const struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *src</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_xrgb8888_to_rgb332" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XRGB8888 to RGB332 clip buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*dst</span></code></dt><dd><p>Array of RGB332 destination buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*dst_pitch</span></code></dt><dd><p>Array of numbers of bytes between the start of two consecutive scanlines
within <strong>dst</strong>; can be NULL if scanlines are stored next to each other.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*src</span></code></dt><dd><p>Array of XRGB8888 source buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies parts of a framebuffer to display memory and converts the
color format during the process. Destination and framebuffer formats must match. The
parameters <strong>dst</strong>, <strong>dst_pitch</strong> and <strong>src</strong> refer to arrays. Each array must have at
least as many entries as there are planes in <strong>fb</strong>’s format. Each entry stores the
value for the format’s respective color plane at the same index.</p>
<p>This function does not apply clipping on <strong>dst</strong> (i.e. the destination is at the
top-left corner).</p>
<p>Drivers can use this function for RGB332 devices that don’t support XRGB8888 natively.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_xrgb8888_to_rgb565">
void <code class="sig-name descname">drm_fb_xrgb8888_to_rgb565</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *dst</em>, const unsigned int<em> *dst_pitch</em>, const struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *src</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em>, bool<em> swab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_xrgb8888_to_rgb565" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XRGB8888 to RGB565 clip buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*dst</span></code></dt><dd><p>Array of RGB565 destination buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*dst_pitch</span></code></dt><dd><p>Array of numbers of bytes between the start of two consecutive scanlines
within <strong>dst</strong>; can be NULL if scanlines are stored next to each other.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*src</span></code></dt><dd><p>Array of XRGB8888 source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">swab</span></code></dt><dd><p>Swap bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies parts of a framebuffer to display memory and converts the
color format during the process. Destination and framebuffer formats must match. The
parameters <strong>dst</strong>, <strong>dst_pitch</strong> and <strong>src</strong> refer to arrays. Each array must have at
least as many entries as there are planes in <strong>fb</strong>’s format. Each entry stores the
value for the format’s respective color plane at the same index.</p>
<p>This function does not apply clipping on <strong>dst</strong> (i.e. the destination is at the
top-left corner).</p>
<p>Drivers can use this function for RGB565 devices that don’t support XRGB8888 natively.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_xrgb8888_to_rgb888">
void <code class="sig-name descname">drm_fb_xrgb8888_to_rgb888</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *dst</em>, const unsigned int<em> *dst_pitch</em>, const struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *src</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_xrgb8888_to_rgb888" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XRGB8888 to RGB888 clip buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*dst</span></code></dt><dd><p>Array of RGB888 destination buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*dst_pitch</span></code></dt><dd><p>Array of numbers of bytes between the start of two consecutive scanlines
within <strong>dst</strong>; can be NULL if scanlines are stored next to each other.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*src</span></code></dt><dd><p>Array of XRGB8888 source buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies parts of a framebuffer to display memory and converts the
color format during the process. Destination and framebuffer formats must match. The
parameters <strong>dst</strong>, <strong>dst_pitch</strong> and <strong>src</strong> refer to arrays. Each array must have at
least as many entries as there are planes in <strong>fb</strong>’s format. Each entry stores the
value for the format’s respective color plane at the same index.</p>
<p>This function does not apply clipping on <strong>dst</strong> (i.e. the destination is at the
top-left corner).</p>
<p>Drivers can use this function for RGB888 devices that don’t natively
support XRGB8888.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_xrgb8888_to_xrgb2101010">
void <code class="sig-name descname">drm_fb_xrgb8888_to_xrgb2101010</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *dst</em>, const unsigned int<em> *dst_pitch</em>, const struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *src</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_xrgb8888_to_xrgb2101010" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XRGB8888 to XRGB2101010 clip buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*dst</span></code></dt><dd><p>Array of XRGB2101010 destination buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*dst_pitch</span></code></dt><dd><p>Array of numbers of bytes between the start of two consecutive scanlines
within <strong>dst</strong>; can be NULL if scanlines are stored next to each other.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*src</span></code></dt><dd><p>Array of XRGB8888 source buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies parts of a framebuffer to display memory and converts the
color format during the process. Destination and framebuffer formats must match. The
parameters <strong>dst</strong>, <strong>dst_pitch</strong> and <strong>src</strong> refer to arrays. Each array must have at
least as many entries as there are planes in <strong>fb</strong>’s format. Each entry stores the
value for the format’s respective color plane at the same index.</p>
<p>This function does not apply clipping on <strong>dst</strong> (i.e. the destination is at the
top-left corner).</p>
<p>Drivers can use this function for XRGB2101010 devices that don’t support XRGB8888
natively.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_xrgb8888_to_gray8">
void <code class="sig-name descname">drm_fb_xrgb8888_to_gray8</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *dst</em>, const unsigned int<em> *dst_pitch</em>, const struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *src</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_xrgb8888_to_gray8" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XRGB8888 to grayscale</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*dst</span></code></dt><dd><p>Array of 8-bit grayscale destination buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*dst_pitch</span></code></dt><dd><p>Array of numbers of bytes between the start of two consecutive scanlines
within <strong>dst</strong>; can be NULL if scanlines are stored next to each other.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*src</span></code></dt><dd><p>Array of XRGB8888 source buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies parts of a framebuffer to display memory and converts the
color format during the process. Destination and framebuffer formats must match. The
parameters <strong>dst</strong>, <strong>dst_pitch</strong> and <strong>src</strong> refer to arrays. Each array must have at
least as many entries as there are planes in <strong>fb</strong>’s format. Each entry stores the
value for the format’s respective color plane at the same index.</p>
<p>This function does not apply clipping on <strong>dst</strong> (i.e. the destination is at the
top-left corner).</p>
<p>DRM doesn’t have native monochrome or grayscale support. Drivers can use this
function for grayscale devices that don’t support XRGB8888 natively.Such
drivers can announce the commonly supported XR24 format to userspace and use
this function to convert to the native format. Monochrome drivers will use the
most significant bit, where 1 means foreground color and 0 background color.
ITU BT.601 is being used for the RGB -&gt; luma (brightness) conversion.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_blit">
int <code class="sig-name descname">drm_fb_blit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *dst</em>, const unsigned int<em> *dst_pitch</em>, uint32_t<em> dst_format</em>, const struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *src</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_blit" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy parts of a framebuffer to display memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*dst</span></code></dt><dd><p>Array of display-memory addresses to copy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*dst_pitch</span></code></dt><dd><p>Array of numbers of bytes between the start of two consecutive scanlines
within <strong>dst</strong>; can be NULL if scanlines are stored next to each other.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">dst_format</span></code></dt><dd><p>FOURCC code of the display’s color format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*src</span></code></dt><dd><p>The framebuffer memory to copy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>The framebuffer to copy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies parts of a framebuffer to display memory. If the
formats of the display and the framebuffer mismatch, the blit function
will attempt to convert between them during the process. The parameters <strong>dst</strong>,
<strong>dst_pitch</strong> and <strong>src</strong> refer to arrays. Each array must have at least as many
entries as there are planes in <strong>dst_format</strong>’s format. Each entry stores the
value for the format’s respective color plane at the same index.</p>
<p>This function does not apply clipping on <strong>dst</strong> (i.e. the destination is at the
top-left corner).</p>
<p><strong>Return</strong></p>
<p>0 on success, or
-EINVAL if the color-format conversion failed, or
a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_xrgb8888_to_mono">
void <code class="sig-name descname">drm_fb_xrgb8888_to_mono</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *dst</em>, const unsigned int<em> *dst_pitch</em>, const struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *src</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_xrgb8888_to_mono" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert XRGB8888 to monochrome</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*dst</span></code></dt><dd><p>Array of monochrome destination buffers (0=black, 1=white)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*dst_pitch</span></code></dt><dd><p>Array of numbers of bytes between the start of two consecutive scanlines
within <strong>dst</strong>; can be NULL if scanlines are stored next to each other.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*src</span></code></dt><dd><p>Array of XRGB8888 source buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>DRM framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>Clip rectangle area to copy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function copies parts of a framebuffer to display memory and converts the
color format during the process. Destination and framebuffer formats must match. The
parameters <strong>dst</strong>, <strong>dst_pitch</strong> and <strong>src</strong> refer to arrays. Each array must have at
least as many entries as there are planes in <strong>fb</strong>’s format. Each entry stores the
value for the format’s respective color plane at the same index.</p>
<p>This function does not apply clipping on <strong>dst</strong> (i.e. the destination is at the
top-left corner). The first pixel (upper left corner of the clip rectangle) will
be converted and copied to the first bit (LSB) in the first byte of the monochrome
destination buffer. If the caller requires that the first pixel in a byte must
be located at an x-coordinate that is a multiple of 8, then the caller must take
care itself of supplying a suitable clip rectangle.</p>
<p>DRM doesn’t have native monochrome support. Drivers can use this function for
monochrome devices that don’t support XRGB8888 natively. Such drivers can
announce the commonly supported XR24 format to userspace and use this function
to convert to the native format.</p>
<p>This function uses <a class="reference internal" href="#c.drm_fb_xrgb8888_to_gray8" title="drm_fb_xrgb8888_to_gray8"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_xrgb8888_to_gray8()</span></code></a> to convert to grayscale and
then the result is converted from grayscale to monochrome.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_build_fourcc_list">
size_t <code class="sig-name descname">drm_fb_build_fourcc_list</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, const u32<em> *native_fourccs</em>, size_t<em> native_nfourccs</em>, const u32<em> *driver_fourccs</em>, size_t<em> driver_nfourccs</em>, u32<em> *fourccs_out</em>, size_t<em> nfourccs_out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_build_fourcc_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters a list of supported color formats against the device’s native formats</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*native_fourccs</span></code></dt><dd><p>4CC codes of natively supported color formats</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">native_nfourccs</span></code></dt><dd><p>The number of entries in <strong>native_fourccs</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*driver_fourccs</span></code></dt><dd><p>4CC codes of all driver-supported color formats</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">driver_nfourccs</span></code></dt><dd><p>The number of entries in <strong>driver_fourccs</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*fourccs_out</span></code></dt><dd><p>Returns 4CC codes of supported color formats</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nfourccs_out</span></code></dt><dd><p>The number of available entries in <strong>fourccs_out</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function create a list of supported color format from natively
supported formats and the emulated formats.
At a minimum, most userspace programs expect at least support for
XRGB8888 on the primary plane. Devices that have to emulate the
format, and possibly others, can use <a class="reference internal" href="#c.drm_fb_build_fourcc_list" title="drm_fb_build_fourcc_list"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_build_fourcc_list()</span></code></a> to
create a list of supported color formats. The returned list can
be handed over to <a class="reference internal" href="drm-kms.html#c.drm_universal_plane_init" title="drm_universal_plane_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_universal_plane_init()</span></code></a> et al. Native formats
will go before emulated formats. Other heuristics might be applied
to optimize the order. Formats near the beginning of the list are
usually preferred over formats near the end of the list. Formats
without conversion helpers will be skipped. New drivers should only
pass in XRGB8888 and avoid exposing additional emulated formats.</p>
<p><strong>Return</strong></p>
<p>The number of color-formats 4CC codes returned in <strong>fourccs_out</strong>.</p>
</div>
</section>
<section id="framebuffer-dma-helper-functions-reference">
<h2>Framebuffer DMA Helper Functions Reference<a class="headerlink" href="#framebuffer-dma-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>Provides helper functions for creating a DMA-contiguous framebuffer.</p>
<p>Depending on the platform, the buffers may be physically non-contiguous and
mapped through an IOMMU or a similar mechanism, or allocated from
physically-contiguous memory (using, for instance, CMA or a pool of memory
reserved at early boot). This is handled behind the scenes by the DMA mapping
API.</p>
<p><a class="reference internal" href="#c.drm_gem_fb_create" title="drm_gem_fb_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create()</span></code></a> is used in the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a>
callback function to create a DMA-contiguous framebuffer.</p>
<dl class="function">
<dt id="c.drm_fb_dma_get_gem_obj">
struct <a class="reference internal" href="drm-mm.html#c.drm_gem_dma_object" title="drm_gem_dma_object">drm_gem_dma_object</a> * <code class="sig-name descname">drm_fb_dma_get_gem_obj</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, unsigned int<em> plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_dma_get_gem_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Get DMA GEM object for framebuffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>The framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>Which plane</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the DMA GEM object for given framebuffer.</p>
<p>This function will usually be called from the CRTC callback functions.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_dma_get_gem_addr">
dma_addr_t <code class="sig-name descname">drm_fb_dma_get_gem_addr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *state</em>, unsigned int<em> plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_dma_get_gem_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get DMA (bus) address for framebuffer, for pixel formats where values are grouped in blocks this will get you the beginning of the block</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>The framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>Which state of drm plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>Which plane
Return the DMA GEM address for given framebuffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will usually be called from the PLANE callback functions.</p>
</div>
<dl class="function">
<dt id="c.drm_fb_dma_sync_non_coherent">
void <code class="sig-name descname">drm_fb_dma_sync_non_coherent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *drm</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *old_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_fb_dma_sync_non_coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Sync GEM object to non-coherent backing memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*drm</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*old_state</span></code></dt><dd><p>Old plane state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*state</span></code></dt><dd><p>New plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by drivers that use damage clips and have
DMA GEM objects backed by non-coherent memory. Calling this function
in a plane’s .atomic_update ensures that all the data in the backing
memory have been written to RAM.</p>
</div>
</section>
<section id="framebuffer-gem-helper-reference">
<h2>Framebuffer GEM Helper Reference<a class="headerlink" href="#framebuffer-gem-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>This library provides helpers for drivers that don’t subclass
<a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> and use <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> for their backing storage.</p>
<p>Drivers without additional needs to validate framebuffers can simply use
<a class="reference internal" href="#c.drm_gem_fb_create" title="drm_gem_fb_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create()</span></code></a> and everything is wired up automatically. Other drivers
can use all parts independently.</p>
<dl class="function">
<dt id="c.drm_gem_fb_get_obj">
struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="sig-name descname">drm_gem_fb_get_obj</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, unsigned int<em> plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_get_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Get GEM object backing the framebuffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>Framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>Plane index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>No additional reference is taken beyond the one that the <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_frambuffer</span></code>
already holds.</p>
<p><strong>Return</strong></p>
<p>Pointer to <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_gem_object</span></code></a> for the given framebuffer and plane index or NULL
if it does not exist.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_fb_destroy">
void <code class="sig-name descname">drm_gem_fb_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Free GEM backed framebuffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>Framebuffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees a GEM backed framebuffer with its backing buffer(s) and the structure
itself. Drivers can use this as their <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs-&gt;destroy</span></code></a>
callback.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_fb_create_handle">
int <code class="sig-name descname">drm_gem_fb_create_handle</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a><em> *file</em>, unsigned int<em> *handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_create_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Create handle for GEM backed framebuffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>Framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>DRM file to register the handle for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*handle</span></code></dt><dd><p>Pointer to return the created handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a handle for the GEM object backing the framebuffer.
Drivers can use this as their <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs-&gt;create_handle</span></code></a>
callback. The GETFB IOCTL calls into this callback.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_fb_init_with_funcs">
int <code class="sig-name descname">drm_gem_fb_init_with_funcs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a><em> *file</em>, const struct <a class="reference internal" href="drm-uapi.html#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2">drm_mode_fb_cmd2</a><em> *mode_cmd</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs">drm_framebuffer_funcs</a><em> *funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_init_with_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for implementing <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback in cases when the driver allocates a subclass of <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>framebuffer object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>DRM file that holds the GEM handle(s) backing the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*mode_cmd</span></code></dt><dd><p>Metadata from the userspace framebuffer creation request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>vtable to be used for the new framebuffer object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used to set <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs</span></code></a> for drivers that need
custom framebuffer callbacks. Use <a class="reference internal" href="#c.drm_gem_fb_create" title="drm_gem_fb_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create()</span></code></a> if you don’t need to
change <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs</span></code></a>. The function does buffer size validation.
The buffer size validation is for a general case, though, so users should
pay attention to the checks being appropriate for them or, at least,
non-conflicting.</p>
<p><strong>Return</strong></p>
<p>Zero or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_fb_create_with_funcs">
struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> * <code class="sig-name descname">drm_gem_fb_create_with_funcs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a><em> *file</em>, const struct <a class="reference internal" href="drm-uapi.html#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2">drm_mode_fb_cmd2</a><em> *mode_cmd</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs">drm_framebuffer_funcs</a><em> *funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_create_with_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>DRM file that holds the GEM handle(s) backing the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*mode_cmd</span></code></dt><dd><p>Metadata from the userspace framebuffer creation request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>vtable to be used for the new framebuffer object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used to set <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs</span></code></a> for drivers that need
custom framebuffer callbacks. Use <a class="reference internal" href="#c.drm_gem_fb_create" title="drm_gem_fb_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create()</span></code></a> if you don’t need to
change <a class="reference internal" href="drm-kms.html#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer_funcs</span></code></a>. The function does buffer size validation.</p>
<p><strong>Return</strong></p>
<p>Pointer to a <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> on success or an error pointer on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_fb_create">
struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> * <code class="sig-name descname">drm_gem_fb_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a><em> *file</em>, const struct <a class="reference internal" href="drm-uapi.html#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2">drm_mode_fb_cmd2</a><em> *mode_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>DRM file that holds the GEM handle(s) backing the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*mode_cmd</span></code></dt><dd><p>Metadata from the userspace framebuffer creation request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a new framebuffer object described by
<a class="reference internal" href="drm-uapi.html#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_fb_cmd2</span></code></a>. This description includes handles for the buffer(s)
backing the framebuffer.</p>
<p>If your hardware has special alignment or pitch requirements these should be
checked before calling this function. The function does buffer size
validation. Use <a class="reference internal" href="#c.drm_gem_fb_create_with_dirty" title="drm_gem_fb_create_with_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create_with_dirty()</span></code></a> if you need framebuffer
flushing.</p>
<p>Drivers can use this as their <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback.
The ADDFB2 IOCTL calls into this callback.</p>
<p><strong>Return</strong></p>
<p>Pointer to a <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> on success or an error pointer on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_fb_create_with_dirty">
struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> * <code class="sig-name descname">drm_gem_fb_create_with_dirty</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a><em> *file</em>, const struct <a class="reference internal" href="drm-uapi.html#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2">drm_mode_fb_cmd2</a><em> *mode_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_create_with_dirty" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*file</span></code></dt><dd><p>DRM file that holds the GEM handle(s) backing the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*mode_cmd</span></code></dt><dd><p>Metadata from the userspace framebuffer creation request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a new framebuffer object described by
<a class="reference internal" href="drm-uapi.html#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_fb_cmd2</span></code></a>. This description includes handles for the buffer(s)
backing the framebuffer. <a class="reference internal" href="drm-kms.html#c.drm_atomic_helper_dirtyfb" title="drm_atomic_helper_dirtyfb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_dirtyfb()</span></code></a> is used for the dirty
callback giving framebuffer flushing through the atomic machinery. Use
<a class="reference internal" href="#c.drm_gem_fb_create" title="drm_gem_fb_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_create()</span></code></a> if you don’t need the dirty callback.
The function does buffer size validation.</p>
<p>Drivers should also call <a class="reference internal" href="drm-kms.html#c.drm_plane_enable_fb_damage_clips" title="drm_plane_enable_fb_damage_clips"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_enable_fb_damage_clips()</span></code></a> on all planes
to enable userspace to use damage clips also with the ATOMIC IOCTL.</p>
<p>Drivers can use this as their <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a> callback.
The ADDFB2 IOCTL calls into this callback.</p>
<p><strong>Return</strong></p>
<p>Pointer to a <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a> on success or an error pointer on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_fb_vmap">
int <code class="sig-name descname">drm_gem_fb_vmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *map</em>, struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_vmap" title="Permalink to this definition">¶</a></dt>
<dd><p>maps all framebuffer BOs into kernel address space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>returns the mapping’s address for each BO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*data</span></code></dt><dd><p>returns the data address for each BO, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function maps all buffer objects of the given framebuffer into
kernel address space and stores them in <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span></code></a>. If the
mapping operation fails for one of the BOs, the function unmaps the
already established mappings automatically.</p>
<p>Callers that want to access a BO’s stored data should pass <strong>data</strong>.
The argument returns the addresses of the data stored in each BO. This
is different from <strong>map</strong> if the framebuffer’s offsets field is non-zero.</p>
<p>Both, <strong>map</strong> and <strong>data</strong>, must each refer to arrays with at least
fb-&gt;format-&gt;num_planes elements.</p>
<p>See <a class="reference internal" href="#c.drm_gem_fb_vunmap" title="drm_gem_fb_vunmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_vunmap()</span></code></a> for unmapping.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_fb_vunmap">
void <code class="sig-name descname">drm_gem_fb_vunmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, struct <a class="reference internal" href="../driver-api/device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *map</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_vunmap" title="Permalink to this definition">¶</a></dt>
<dd><p>unmaps framebuffer BOs from kernel address space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>mapping addresses as returned by <a class="reference internal" href="#c.drm_gem_fb_vmap" title="drm_gem_fb_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_vmap()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unmaps all buffer objects of the given framebuffer.</p>
<p>See <a class="reference internal" href="#c.drm_gem_fb_vmap" title="drm_gem_fb_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_vmap()</span></code></a> for more information.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_fb_begin_cpu_access">
int <code class="sig-name descname">drm_gem_fb_begin_cpu_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, enum dma_data_direction<em> dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_begin_cpu_access" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares GEM buffer objects for CPU access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>access mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepares a framebuffer’s GEM buffer objects for CPU access. This function
must be called before accessing the BO data within the kernel. For imported
BOs, the function calls <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_begin_cpu_access" title="dma_buf_begin_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_begin_cpu_access()</span></code></a>.</p>
<p>See <a class="reference internal" href="#c.drm_gem_fb_end_cpu_access" title="drm_gem_fb_end_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_end_cpu_access()</span></code></a> for signalling the end of CPU access.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_fb_end_cpu_access">
void <code class="sig-name descname">drm_gem_fb_end_cpu_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, enum dma_data_direction<em> dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_end_cpu_access" title="Permalink to this definition">¶</a></dt>
<dd><p>signals end of CPU access to GEM buffer objects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>the framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>access mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signals the end of CPU access to the given framebuffer’s GEM buffer objects. This
function must be paired with a corresponding call to <a class="reference internal" href="#c.drm_gem_fb_begin_cpu_access" title="drm_gem_fb_begin_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_begin_cpu_access()</span></code></a>.
For imported BOs, the function calls <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_end_cpu_access" title="dma_buf_end_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_end_cpu_access()</span></code></a>.</p>
<p>See also <a class="reference internal" href="#c.drm_gem_fb_begin_cpu_access" title="drm_gem_fb_begin_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_begin_cpu_access()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_gem_fb_afbc_init">
int <code class="sig-name descname">drm_gem_fb_afbc_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, const struct <a class="reference internal" href="drm-uapi.html#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2">drm_mode_fb_cmd2</a><em> *mode_cmd</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_afbc_framebuffer" title="drm_afbc_framebuffer">drm_afbc_framebuffer</a><em> *afbc_fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_fb_afbc_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drivers using afbc to fill and validate all the afbc-specific <a class="reference internal" href="drm-kms.html#c.drm_afbc_framebuffer" title="drm_afbc_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_afbc_framebuffer</span></code></a> members</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*mode_cmd</span></code></dt><dd><p>Metadata from the userspace framebuffer creation request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_afbc_framebuffer</span> <span class="pre">*afbc_fb</span></code></dt><dd><p>afbc framebuffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by drivers which support afbc to complete
the preparation of <a class="reference internal" href="drm-kms.html#c.drm_afbc_framebuffer" title="drm_afbc_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_afbc_framebuffer</span></code></a>. It must be called after
allocating the said struct and calling <a class="reference internal" href="#c.drm_gem_fb_init_with_funcs" title="drm_gem_fb_init_with_funcs"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_gem_fb_init_with_funcs()</span></code></a>.
It is caller’s responsibility to put afbc_fb-&gt;base.obj objects in case
the call is unsuccessful.</p>
<p><strong>Return</strong></p>
<p>Zero on success or a negative error value on failure.</p>
</div>
</section>
<section id="bridges">
<span id="drm-bridges"></span><h2>Bridges<a class="headerlink" href="#bridges" title="Permalink to this headline">¶</a></h2>
<section id="id1">
<h3>Overview<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span></code></a> represents a device that hangs on to an encoder. These are
handy when a regular <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> entity isn’t enough to represent the entire
encoder chain.</p>
<p>A bridge is always attached to a single <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> at a time, but can be
either connected to it directly, or through a chain of bridges:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[ CRTC ---&gt; ] Encoder ---&gt; Bridge A ---&gt; Bridge B
</pre></div>
</div>
<p>Here, the output of the encoder feeds to bridge A, and that furthers feeds to
bridge B. Bridge chains can be arbitrarily long, and shall be fully linear:
Chaining multiple bridges to the output of a bridge, or the same bridge to
the output of different bridges, is not supported.</p>
<p><a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a>, like <a class="reference internal" href="#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel</span></code></a>, aren’t <a class="reference internal" href="drm-kms.html#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_object</span></code></a> entities like planes,
CRTCs, encoders or connectors and hence are not visible to userspace. They
just provide additional hooks to get the desired output at the end of the
encoder chain.</p>
</section>
<section id="display-driver-integration">
<h3>Display Driver Integration<a class="headerlink" href="#display-driver-integration" title="Permalink to this headline">¶</a></h3>
<p>Display drivers are responsible for linking encoders with the first bridge
in the chains. This is done by acquiring the appropriate bridge with
<a class="reference internal" href="#c.devm_drm_of_get_bridge" title="devm_drm_of_get_bridge"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_of_get_bridge()</span></code></a>. Once acquired, the bridge shall be attached to the
encoder with a call to <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a>.</p>
<p>Bridges are responsible for linking themselves with the next bridge in the
chain, if any. This is done the same way as for encoders, with the call to
<a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a> occurring in the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.attach</span></code></a> operation.</p>
<p>Once these links are created, the bridges can participate along with encoder
functions to perform mode validation and fixup (through
<a class="reference internal" href="#c.drm_bridge_chain_mode_valid" title="drm_bridge_chain_mode_valid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_chain_mode_valid()</span></code></a> and <a class="reference internal" href="#c.drm_atomic_bridge_chain_check" title="drm_atomic_bridge_chain_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_check()</span></code></a>), mode
setting (through <a class="reference internal" href="#c.drm_bridge_chain_mode_set" title="drm_bridge_chain_mode_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_chain_mode_set()</span></code></a>), enable (through
<a class="reference internal" href="#c.drm_atomic_bridge_chain_pre_enable" title="drm_atomic_bridge_chain_pre_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_pre_enable()</span></code></a> and <a class="reference internal" href="#c.drm_atomic_bridge_chain_enable" title="drm_atomic_bridge_chain_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_enable()</span></code></a>)
and disable (through <a class="reference internal" href="#c.drm_atomic_bridge_chain_disable" title="drm_atomic_bridge_chain_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_disable()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_bridge_chain_post_disable" title="drm_atomic_bridge_chain_post_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_post_disable()</span></code></a>). Those functions call the
corresponding operations provided in <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs</span></code></a> in sequence for all
bridges in the chain.</p>
<p>For display drivers that use the atomic helpers
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>,
<a class="reference internal" href="#c.drm_atomic_helper_commit_modeset_enables" title="drm_atomic_helper_commit_modeset_enables"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_modeset_enables()</span></code></a> and
<a class="reference internal" href="#c.drm_atomic_helper_commit_modeset_disables" title="drm_atomic_helper_commit_modeset_disables"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_modeset_disables()</span></code></a> (either directly in hand-rolled
commit check and commit tail handlers, or through the higher-level
<a class="reference internal" href="#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check()</span></code></a> and <a class="reference internal" href="#c.drm_atomic_helper_commit_tail" title="drm_atomic_helper_commit_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail()</span></code></a> or
<a class="reference internal" href="#c.drm_atomic_helper_commit_tail_rpm" title="drm_atomic_helper_commit_tail_rpm"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_commit_tail_rpm()</span></code></a> helpers), this is done transparently and
requires no intervention from the driver. For other drivers, the relevant
DRM bridge chain functions shall be called manually.</p>
<p>Bridges also participate in implementing the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> at the end of
the bridge chain. Display drivers may use the <a class="reference internal" href="#c.drm_bridge_connector_init" title="drm_bridge_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_connector_init()</span></code></a>
helper to create the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>, or implement it manually on top of the
connector-related operations exposed by the bridge (see the overview
documentation of bridge operations for more details).</p>
</section>
<section id="special-care-with-mipi-dsi-bridges">
<h3>Special Care with MIPI-DSI bridges<a class="headerlink" href="#special-care-with-mipi-dsi-bridges" title="Permalink to this headline">¶</a></h3>
<p>The interaction between the bridges and other frameworks involved in
the probing of the upstream driver and the bridge driver can be
challenging. Indeed, there’s multiple cases that needs to be
considered:</p>
<ul class="simple">
<li><p>The upstream driver doesn’t use the component framework and isn’t a
MIPI-DSI host. In this case, the bridge driver will probe at some
point and the upstream driver should try to probe again by returning
EPROBE_DEFER as long as the bridge driver hasn’t probed.</p></li>
<li><p>The upstream driver doesn’t use the component framework, but is a
MIPI-DSI host. The bridge device uses the MIPI-DCS commands to be
controlled. In this case, the bridge device is a child of the
display device and when it will probe it’s assured that the display
device (and MIPI-DSI host) is present. The upstream driver will be
assured that the bridge driver is connected between the
<a class="reference internal" href="#c.mipi_dsi_host_ops" title="mipi_dsi_host_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dsi_host_ops.attach</span></code></a> and <a class="reference internal" href="#c.mipi_dsi_host_ops" title="mipi_dsi_host_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dsi_host_ops.detach</span></code></a> operations.
Therefore, it must run mipi_dsi_host_register() in its probe
function, and then run <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a> in its
<a class="reference internal" href="#c.mipi_dsi_host_ops" title="mipi_dsi_host_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dsi_host_ops.attach</span></code></a> hook.</p></li>
<li><p>The upstream driver uses the component framework and is a MIPI-DSI
host. The bridge device uses the MIPI-DCS commands to be
controlled. This is the same situation than above, and can run
mipi_dsi_host_register() in either its probe or bind hooks.</p></li>
<li><p>The upstream driver uses the component framework and is a MIPI-DSI
host. The bridge device uses a separate bus (such as I2C) to be
controlled. In this case, there’s no correlation between the probe
of the bridge and upstream drivers, so care must be taken to avoid
an endless EPROBE_DEFER loop, with each driver waiting for the
other to probe.</p></li>
</ul>
<p>The ideal pattern to cover the last item (and all the others in the
MIPI-DSI host driver case) is to split the operations like this:</p>
<ul class="simple">
<li><p>The MIPI-DSI host driver must run mipi_dsi_host_register() in its
probe hook. It will make sure that the MIPI-DSI host sticks around,
and that the driver’s bind can be called.</p></li>
<li><p>In its probe hook, the bridge driver must try to find its MIPI-DSI
host, register as a MIPI-DSI device and attach the MIPI-DSI device
to its host. The bridge driver is now functional.</p></li>
<li><p>In its <a class="reference internal" href="#c.mipi_dsi_host_ops" title="mipi_dsi_host_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_host_ops</span></code></a>.attach hook, the MIPI-DSI host can
now add its component. Its bind hook will now be called and since
the bridge driver is attached and registered, we can now look for
and attach it.</p></li>
</ul>
<p>At this point, we’re now certain that both the upstream driver and
the bridge driver are functional and we can’t have a deadlock-like
situation when probing.</p>
</section>
<section id="bridge-operations">
<h3>Bridge Operations<a class="headerlink" href="#bridge-operations" title="Permalink to this headline">¶</a></h3>
<p>Bridge drivers expose operations through the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs</span></code></a> structure.
The DRM internals (atomic and CRTC helpers) use the helpers defined in
drm_bridge.c to call bridge operations. Those operations are divided in
three big categories to support different parts of the bridge usage.</p>
<ul>
<li><p>The encoder-related operations support control of the bridges in the
chain, and are roughly counterparts to the <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs</span></code></a>
operations. They are used by the legacy CRTC and the atomic modeset
helpers to perform mode validation, fixup and setting, and enable and
disable the bridge automatically.</p>
<p>The enable and disable operations are split in
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.pre_enable</span></code></a>, <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.enable</span></code></a>,
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.disable</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.post_disable</span></code></a> to provide
finer-grained control.</p>
<p>Bridge drivers may implement the legacy version of those operations, or
the atomic version (prefixed with atomic_), in which case they shall also
implement the atomic state bookkeeping operations
(<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_duplicate_state</span></code></a>,
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_destroy_state</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.reset</span></code></a>).
Mixing atomic and non-atomic versions of the operations is not supported.</p>
</li>
<li><p>The bus format negotiation operations
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_get_output_bus_fmts</span></code></a> and
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_get_input_bus_fmts</span></code></a> allow bridge drivers to
negotiate the formats transmitted between bridges in the chain when
multiple formats are supported. Negotiation for formats is performed
transparently for display drivers by the atomic modeset helpers. Only
atomic versions of those operations exist, bridge drivers that need to
implement them shall thus also implement the atomic version of the
encoder-related operations. This feature is not supported by the legacy
CRTC helpers.</p></li>
<li><p>The connector-related operations support implementing a <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>
based on a chain of bridges. DRM bridges traditionally create a
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> for bridges meant to be used at the end of the chain. This
puts additional burden on bridge drivers, especially for bridges that may
be used in the middle of a chain or at the end of it. Furthermore, it
requires all operations of the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> to be handled by a single
bridge, which doesn’t always match the hardware architecture.</p>
<p>To simplify bridge drivers and make the connector implementation more
flexible, a new model allows bridges to unconditionally skip creation of
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> and instead expose <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs</span></code></a> operations to support
an externally-implemented <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>. Those operations are
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.detect</span></code></a>, <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.get_modes</span></code></a>,
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.get_edid</span></code></a>, <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.hpd_notify</span></code></a>,
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.hpd_enable</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.hpd_disable</span></code></a>. When
implemented, display drivers shall create a <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> instance for
each chain of bridges, and implement those connector instances based on
the bridge connector operations.</p>
<p>Bridge drivers shall implement the connector-related operations for all
the features that the bridge hardware support. For instance, if a bridge
supports reading EDID, the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.get_edid</span></code></a> shall be
implemented. This however doesn’t mean that the DDC lines are wired to the
bridge on a particular platform, as they could also be connected to an I2C
controller of the SoC. Support for the connector-related operations on the
running platform is reported through the <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge.ops</span></code></a> flags. Bridge
drivers shall detect which operations they can support on the platform
(usually this information is provided by ACPI or DT), and set the
<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge.ops</span></code></a> flags for all supported operations. A flag shall only be
set if the corresponding <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs</span></code></a> operation is implemented, but
an implemented operation doesn’t necessarily imply that the corresponding
flag will be set. Display drivers shall use the <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge.ops</span></code></a> flags to
decide which bridge to delegate a connector operation to. This mechanism
allows providing a single static const <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs</span></code></a> instance in
bridge drivers, improving security by storing function pointers in
read-only memory.</p>
<p>In order to ease transition, bridge drivers may support both the old and
new models by making connector creation optional and implementing the
connected-related bridge operations. Connector creation is then controlled
by the flags argument to the <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a> function. Display drivers
that support the new model and create connectors themselves shall set the
<code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_ATTACH_NO_CONNECTOR</span></code> flag, and bridge drivers shall then skip
connector creation. For intermediate bridges in the chain, the flag shall
be passed to the <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a> call for the downstream bridge.
Bridge drivers that implement the new model only shall return an error
from their <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.attach</span></code></a> handler when the
<code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_ATTACH_NO_CONNECTOR</span></code> flag is not set. New display drivers
should use the new model, and convert the bridge drivers they use if
needed, in order to gradually transition to the new model.</p>
</li>
</ul>
</section>
<section id="bridge-connector-helper">
<h3>Bridge Connector Helper<a class="headerlink" href="#bridge-connector-helper" title="Permalink to this headline">¶</a></h3>
<p>The DRM bridge connector helper object provides a DRM connector
implementation that wraps a chain of <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span></code></a>. The connector
operations are fully implemented based on the operations of the bridges in
the chain, and don’t require any intervention from the display controller
driver at runtime.</p>
<p>To use the helper, display controller drivers create a bridge connector with
a call to <a class="reference internal" href="#c.drm_bridge_connector_init" title="drm_bridge_connector_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_connector_init()</span></code></a>. This associates the newly created
connector with the chain of bridges passed to the function and registers it
with the DRM device. At that point the connector becomes fully usable, no
further operation is needed.</p>
<p>The DRM bridge connector operations are implemented based on the operations
provided by the bridges in the chain. Each connector operation is delegated
to the bridge closest to the connector (at the end of the chain) that
provides the relevant functionality.</p>
<p>To make use of this helper, all bridges in the chain shall report bridge
operation flags (<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>) and bridge output type
(<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;type</span></code></a>), as well as the DRM_BRIDGE_ATTACH_NO_CONNECTOR attach
flag (none of the bridges shall create a DRM connector directly).</p>
</section>
<section id="bridge-helper-reference">
<h3>Bridge Helper Reference<a class="headerlink" href="#bridge-helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_bridge_attach_flags">
enum <code class="sig-name descname">drm_bridge_attach_flags</code><a class="headerlink" href="#c.drm_bridge_attach_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags for <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.attach</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_ATTACH_NO_CONNECTOR</span></code></dt><dd><p>When this flag is set the bridge
shall not create a drm_connector.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_bridge_funcs">
struct <code class="sig-name descname">drm_bridge_funcs</code><a class="headerlink" href="#c.drm_bridge_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>drm_bridge control functions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_bridge_funcs {
    int (*attach)(struct drm_bridge *bridge, enum drm_bridge_attach_flags flags);
    void (*detach)(struct drm_bridge *bridge);
    enum drm_mode_status (*mode_valid)(struct drm_bridge *bridge,const struct drm_display_info *info, const struct drm_display_mode *mode);
    bool (*mode_fixup)(struct drm_bridge *bridge,const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
    void (*disable)(struct drm_bridge *bridge);
    void (*post_disable)(struct drm_bridge *bridge);
    void (*mode_set)(struct drm_bridge *bridge,const struct drm_display_mode *mode, const struct drm_display_mode *adjusted_mode);
    void (*pre_enable)(struct drm_bridge *bridge);
    void (*enable)(struct drm_bridge *bridge);
    void (*atomic_pre_enable)(struct drm_bridge *bridge, struct drm_bridge_state *old_bridge_state);
    void (*atomic_enable)(struct drm_bridge *bridge, struct drm_bridge_state *old_bridge_state);
    void (*atomic_disable)(struct drm_bridge *bridge, struct drm_bridge_state *old_bridge_state);
    void (*atomic_post_disable)(struct drm_bridge *bridge, struct drm_bridge_state *old_bridge_state);
    struct drm_bridge_state *(*atomic_duplicate_state)(struct drm_bridge *bridge);
    void (*atomic_destroy_state)(struct drm_bridge *bridge, struct drm_bridge_state *state);
    u32 *(*atomic_get_output_bus_fmts)(struct drm_bridge *bridge,struct drm_bridge_state *bridge_state,struct drm_crtc_state *crtc_state,struct drm_connector_state *conn_state, unsigned int *num_output_fmts);
    u32 *(*atomic_get_input_bus_fmts)(struct drm_bridge *bridge,struct drm_bridge_state *bridge_state,struct drm_crtc_state *crtc_state,struct drm_connector_state *conn_state,u32 output_fmt, unsigned int *num_input_fmts);
    int (*atomic_check)(struct drm_bridge *bridge,struct drm_bridge_state *bridge_state,struct drm_crtc_state *crtc_state, struct drm_connector_state *conn_state);
    struct drm_bridge_state *(*atomic_reset)(struct drm_bridge *bridge);
    enum drm_connector_status (*detect)(struct drm_bridge *bridge);
    int (*get_modes)(struct drm_bridge *bridge, struct drm_connector *connector);
    struct edid *(*get_edid)(struct drm_bridge *bridge, struct drm_connector *connector);
    void (*hpd_notify)(struct drm_bridge *bridge, enum drm_connector_status status);
    void (*hpd_enable)(struct drm_bridge *bridge);
    void (*hpd_disable)(struct drm_bridge *bridge);
    void (*debugfs_init)(struct drm_bridge *bridge, struct dentry *root);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">attach</span></code></dt><dd><p>This callback is invoked whenever our bridge is being attached to a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a>. The flags argument tunes the behaviour of the attach
operation (see DRM_BRIDGE_ATTACH_*).</p>
<p>The <strong>attach</strong> callback is optional.</p>
<p>RETURNS:</p>
<p>Zero on success, error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach</span></code></dt><dd><p>This callback is invoked whenever our bridge is being detached from a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a>.</p>
<p>The <strong>detach</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_valid</span></code></dt><dd><p>This callback is used to check if a specific mode is valid in this
bridge. This should be implemented if the bridge has some sort of
restriction in the modes it can display. For example, a given bridge
may be responsible to set a clock value. If the clock can not
produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<a class="reference internal" href="#c.drm_atomic_helper_check_modeset" title="drm_atomic_helper_check_modeset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_check_modeset()</span></code></a>.</p>
<p>The <strong>mode_valid</strong> callback is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong>.</p>
<p>RETURNS:</p>
<p>drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_fixup</span></code></dt><dd><p>This callback is used to validate and adjust a mode. The parameter
mode is the display mode that should be fed to the next element in
the display chain, either the final <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> or the next
<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a>. The parameter adjusted_mode is the input mode the bridge
requires. It can be modified by this callback and does not need to
match mode. See also <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This is the only hook that allows a bridge to reject a modeset. If
this function passes all other callbacks must succeed for this
configuration.</p>
<p>The mode_fixup callback is optional. <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup()</span></code></a>
is not called when <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_check()</span></code></a> is implemented,
so only one of them should be provided.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace’s request to
just check whether a configuration would be possible). Drivers MUST
NOT touch any persistent state (hardware or software) or data
structures except the passed in <strong>state</strong> parameter.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any bridge constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p>True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>This callback should disable the bridge. It is called right before
the preceding element in the display pipe is disabled. If the
preceding element is a bridge this means it’s called before that
bridge’s <strong>disable</strong> vfunc. If the preceding element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a>
it’s called right before the <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a>,
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.prepare</span></code></a> or <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a>
hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is still running when this callback is called.</p>
<p>The <strong>disable</strong> callback is optional.</p>
<p>NOTE:</p>
<p>This is deprecated, do not use!
New drivers shall use <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_disable</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">post_disable</span></code></dt><dd><p>This callback should disable the bridge. It is called right after the
preceding element in the display pipe is disabled. If the preceding
element is a bridge this means it’s called after that bridge’s
<strong>post_disable</strong> function. If the preceding element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a>
it’s called right after the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.prepare</span></code></a>
or <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The bridge must assume that the display pipe (i.e. clocks and timing
singals) feeding it is no longer running when this callback is
called.</p>
<p>The <strong>post_disable</strong> callback is optional.</p>
<p>NOTE:</p>
<p>This is deprecated, do not use!
New drivers shall use <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_post_disable</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_set</span></code></dt><dd><p>This callback should set the given mode on the bridge. It is called
after the <strong>mode_set</strong> callback for the preceding element in the display
pipeline has been called already. If the bridge is the first element
then this would be <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.mode_set</span></code></a>. The display
pipe (i.e.  clocks and timing signals) is off when this function is
called.</p>
<p>The adjusted_mode parameter is the mode output by the CRTC for the
first bridge in the chain. It can be different from the mode
parameter that contains the desired mode for the connector at the end
of the bridges chain, for instance when the first bridge in the chain
performs scaling. The adjusted mode is mostly useful for the first
bridge in the chain and is likely irrelevant for the other bridges.</p>
<p>For atomic drivers the adjusted_mode is the mode stored in
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a>.</p>
<p>NOTE:</p>
<p>This is deprecated, do not use!
New drivers shall set their mode in the
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_enable</span></code></a> operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pre_enable</span></code></dt><dd><p>This callback should enable the bridge. It is called right before
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it’s called before that
bridge’s <strong>pre_enable</strong> function. If the preceding element is a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right before the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.commit</span></code></a> or
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The display pipe (i.e. clocks and timing signals) feeding this bridge
will not yet be running when this callback is called. The bridge must
not enable the display link feeding the next bridge in the chain (if
there is one) when this callback is called.</p>
<p>The <strong>pre_enable</strong> callback is optional.</p>
<p>NOTE:</p>
<p>This is deprecated, do not use!
New drivers shall use <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_pre_enable</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>This callback should enable the bridge. It is called right after
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it’s called after that
bridge’s <strong>enable</strong> function. If the preceding element is a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right after the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.commit</span></code></a> or
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is running when this callback is called. This
callback must enable the display link feeding the next bridge in the
chain if there is one.</p>
<p>The <strong>enable</strong> callback is optional.</p>
<p>NOTE:</p>
<p>This is deprecated, do not use!
New drivers shall use <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_enable</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_pre_enable</span></code></dt><dd><p>This callback should enable the bridge. It is called right before
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it’s called before that
bridge’s <strong>atomic_pre_enable</strong> or <strong>pre_enable</strong> function. If the preceding
element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right before the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_enable</span></code></a> hook.</p>
<p>The display pipe (i.e. clocks and timing signals) feeding this bridge
will not yet be running when this callback is called. The bridge must
not enable the display link feeding the next bridge in the chain (if
there is one) when this callback is called.</p>
<p>Note that this function will only be invoked in the context of an
atomic commit. It will not be invoked from
<a class="reference internal" href="#c.drm_bridge_chain_pre_enable" title="drm_bridge_chain_pre_enable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_pre_enable</span></code></a>. It would be prudent to also provide an
implementation of <strong>pre_enable</strong> if you are expecting driver calls into
<a class="reference internal" href="#c.drm_bridge_chain_pre_enable" title="drm_bridge_chain_pre_enable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_pre_enable</span></code></a>.</p>
<p>The <strong>atomic_pre_enable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_enable</span></code></dt><dd><p>This callback should enable the bridge. It is called right after
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it’s called after that
bridge’s <strong>atomic_enable</strong> or <strong>enable</strong> function. If the preceding element
is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right after the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_enable</span></code></a> hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is running when this callback is called. This
callback must enable the display link feeding the next bridge in the
chain if there is one.</p>
<p>Note that this function will only be invoked in the context of an
atomic commit. It will not be invoked from <a class="reference internal" href="#c.drm_bridge_chain_enable" title="drm_bridge_chain_enable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_enable</span></code></a>.
It would be prudent to also provide an implementation of <strong>enable</strong> if
you are expecting driver calls into <a class="reference internal" href="#c.drm_bridge_chain_enable" title="drm_bridge_chain_enable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_enable</span></code></a>.</p>
<p>The <strong>atomic_enable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_disable</span></code></dt><dd><p>This callback should disable the bridge. It is called right before
the preceding element in the display pipe is disabled. If the
preceding element is a bridge this means it’s called before that
bridge’s <strong>atomic_disable</strong> or <strong>disable</strong> vfunc. If the preceding element
is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right before the
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_disable</span></code></a> hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is still running when this callback is called.</p>
<p>Note that this function will only be invoked in the context of an
atomic commit. It will not be invoked from
<a class="reference internal" href="#c.drm_bridge_chain_disable" title="drm_bridge_chain_disable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_disable</span></code></a>. It would be prudent to also provide an
implementation of <strong>disable</strong> if you are expecting driver calls into
<a class="reference internal" href="#c.drm_bridge_chain_disable" title="drm_bridge_chain_disable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_disable</span></code></a>.</p>
<p>The <strong>atomic_disable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_post_disable</span></code></dt><dd><p>This callback should disable the bridge. It is called right after the
preceding element in the display pipe is disabled. If the preceding
element is a bridge this means it’s called after that bridge’s
<strong>atomic_post_disable</strong> or <strong>post_disable</strong> function. If the preceding
element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> it’s called right after the encoder’s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_disable</span></code></a> hook.</p>
<p>The bridge must assume that the display pipe (i.e. clocks and timing
signals) feeding it is no longer running when this callback is
called.</p>
<p>Note that this function will only be invoked in the context of an
atomic commit. It will not be invoked from
<a class="reference internal" href="#c.drm_bridge_chain_post_disable" title="drm_bridge_chain_post_disable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_post_disable</span></code></a>.
It would be prudent to also provide an implementation of
<strong>post_disable</strong> if you are expecting driver calls into
<a class="reference internal" href="#c.drm_bridge_chain_post_disable" title="drm_bridge_chain_post_disable"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_chain_post_disable</span></code></a>.</p>
<p>The <strong>atomic_post_disable</strong> callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_duplicate_state</span></code></dt><dd><p>Duplicate the current bridge state object (which is guaranteed to be
non-NULL).</p>
<p>The atomic_duplicate_state hook is mandatory if the bridge
implements any of the atomic hooks, and should be left unassigned
otherwise. For bridges that don’t subclass <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state</span></code></a>, the
<a class="reference internal" href="#c.drm_atomic_helper_bridge_duplicate_state" title="drm_atomic_helper_bridge_duplicate_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_bridge_duplicate_state()</span></code></a> helper function shall be
used to implement this hook.</p>
<p>RETURNS:
A valid drm_bridge_state object or NULL if the allocation fails.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_destroy_state</span></code></dt><dd><p>Destroy a bridge state object previously allocated by
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_duplicate_state()</span></code></a>.</p>
<p>The atomic_destroy_state hook is mandatory if the bridge implements
any of the atomic hooks, and should be left unassigned otherwise.
For bridges that don’t subclass <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state</span></code></a>, the
<a class="reference internal" href="#c.drm_atomic_helper_bridge_destroy_state" title="drm_atomic_helper_bridge_destroy_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_bridge_destroy_state()</span></code></a> helper function shall be
used to implement this hook.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_get_output_bus_fmts</span></code></dt><dd><p>Return the supported bus formats on the output end of a bridge.
The returned array must be allocated with <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> and will be
freed by the caller. If the allocation fails, NULL should be
returned. num_output_fmts must be set to the returned array size.
Formats listed in the returned array should be listed in decreasing
preference order (the core will try all formats until it finds one
that works).</p>
<p>This method is only called on the last element of the bridge chain
as part of the bus format negotiation process that happens in
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_atomic_bridge_chain_select_bus_fmts`().</span>
<span class="pre">This</span> <span class="pre">method</span> <span class="pre">is</span> <span class="pre">optional.</span> <span class="pre">When</span> <span class="pre">not</span> <span class="pre">implemented,</span> <span class="pre">the</span> <span class="pre">core</span> <span class="pre">will</span>
<span class="pre">fall</span> <span class="pre">back</span> <span class="pre">to</span> <span class="pre">:c:type:`drm_connector.display_info</span></code></a>.bus_formats[0] if
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.display_info</span></code></a>.num_bus_formats &gt; 0,
or to MEDIA_BUS_FMT_FIXED otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_get_input_bus_fmts</span></code></dt><dd><p>Return the supported bus formats on the input end of a bridge for
a specific output bus format.</p>
<p>The returned array must be allocated with <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> and will be
freed by the caller. If the allocation fails, NULL should be
returned. num_output_fmts must be set to the returned array size.
Formats listed in the returned array should be listed in decreasing
preference order (the core will try all formats until it finds one
that works). When the format is not supported NULL should be
returned and num_output_fmts should be set to 0.</p>
<p>This method is called on all elements of the bridge chain as part of
the bus format negotiation process that happens in
drm_atomic_bridge_chain_select_bus_fmts().
This method is optional. When not implemented, the core will bypass
bus format negotiation on this element of the bridge without
failing, and the previous element in the chain will be passed
MEDIA_BUS_FMT_FIXED as its output bus format.</p>
<p>Bridge drivers that need to support being linked to bridges that are
not supporting bus format negotiation should handle the
output_fmt == MEDIA_BUS_FMT_FIXED case appropriately, by selecting a
sensible default value or extracting this information from somewhere
else (FW property, <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_mode</span></code></a>, <a class="reference internal" href="drm-kms.html#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info</span></code></a>, …)</p>
<p>Note: Even if input format selection on the first bridge has no
impact on the negotiation process (bus format negotiation stops once
we reach the first element of the chain), drivers are expected to
return accurate input formats as the input format may be used to
configure the CRTC output appropriately.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_check</span></code></dt><dd><p>This method is responsible for checking bridge state correctness.
It can also check the state of the surrounding components in chain
to make sure the whole pipeline can work properly.</p>
<p><a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_check()</span></code></a> hooks are called in reverse
order (from the last to the first bridge).</p>
<p>This method is optional. <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup()</span></code></a> is not
called when <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_check()</span></code></a> is implemented, so only
one of them should be provided.</p>
<p>If drivers need to tweak <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state.input_bus_cfg</span></code></a>.flags or
<a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state.output_bus_cfg</span></code></a>.flags it should happen in
this function. By default the <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state.output_bus_cfg</span></code></a>.flags
field is set to the next bridge
<a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state.input_bus_cfg</span></code></a>.flags value or
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector.display_info</span></code></a>.bus_flags if the bridge is the last
element in the chain.</p>
<p>RETURNS:
zero if the check passed, a negative error code otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_reset</span></code></dt><dd><p>Reset the bridge to a predefined state (or retrieve its current
state) and return a <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state</span></code></a> object matching this state.
This function is called at attach time.</p>
<p>The atomic_reset hook is mandatory if the bridge implements any of
the atomic hooks, and should be left unassigned otherwise. For
bridges that don’t subclass <a class="reference internal" href="drm-kms.html#c.drm_bridge_state" title="drm_bridge_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_state</span></code></a>, the
<a class="reference internal" href="#c.drm_atomic_helper_bridge_reset" title="drm_atomic_helper_bridge_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_bridge_reset()</span></code></a> helper function shall be used to
implement this hook.</p>
<p>Note that the atomic_reset() semantics is not exactly matching the
reset() semantics found on other components (connector, plane, …).</p>
<ol class="arabic simple">
<li><p>The reset operation happens when the bridge is attached, not when
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_reset()</span></code></a> is called</p></li>
<li><p>It’s meant to be used exclusively on bridges that have been
converted to the ATOMIC API</p></li>
</ol>
<p>RETURNS:
A valid drm_bridge_state object in case of success, an ERR_PTR()
giving the reason of the failure otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detect</span></code></dt><dd><p>Check if anything is attached to the bridge output.</p>
<p>This callback is optional, if not implemented the bridge will be
considered as always having a component attached to its output.
Bridges that implement this callback shall set the
DRM_BRIDGE_OP_DETECT flag in their <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>.</p>
<p>RETURNS:</p>
<p>drm_connector_status indicating the bridge output status.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_modes</span></code></dt><dd><p>Fill all modes currently valid for the sink into the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>
with <a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_probed_add()</span></code></a>.</p>
<p>The <strong>get_modes</strong> callback is mostly intended to support non-probeable
displays such as many fixed panels. Bridges that support reading
EDID shall leave <strong>get_modes</strong> unimplemented and implement the
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;get_edid</span></code></a> callback instead.</p>
<p>This callback is optional. Bridges that implement it shall set the
DRM_BRIDGE_OP_MODES flag in their <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>.</p>
<p>The connector parameter shall be used for the sole purpose of
filling modes, and shall not be stored internally by bridge drivers
for future usage.</p>
<p>RETURNS:</p>
<p>The number of modes added by calling <a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_probed_add()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_edid</span></code></dt><dd><p>Read and parse the EDID data of the connected display.</p>
<p>The <strong>get_edid</strong> callback is the preferred way of reporting mode
information for a display connected to the bridge output. Bridges
that support reading EDID shall implement this callback and leave
the <strong>get_modes</strong> callback unimplemented.</p>
<p>The caller of this operation shall first verify the output
connection status and refrain from reading EDID from a disconnected
output.</p>
<p>This callback is optional. Bridges that implement it shall set the
DRM_BRIDGE_OP_EDID flag in their <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>.</p>
<p>The connector parameter shall be used for the sole purpose of EDID
retrieval and parsing, and shall not be stored internally by bridge
drivers for future usage.</p>
<p>RETURNS:</p>
<p>An edid structure newly allocated with <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> (or similar) on
success, or NULL otherwise. The caller is responsible for freeing
the returned edid structure with <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_notify</span></code></dt><dd><p>Notify the bridge of hot plug detection.</p>
<p>This callback is optional, it may be implemented by bridges that
need to be notified of display connection or disconnection for
internal reasons. One use case is to reset the internal state of CEC
controllers for HDMI bridges.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_enable</span></code></dt><dd><p>Enable hot plug detection. From now on the bridge shall call
<a class="reference internal" href="#c.drm_bridge_hpd_notify" title="drm_bridge_hpd_notify"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_notify()</span></code></a> each time a change is detected in the output
connection status, until hot plug detection gets disabled with
<strong>hpd_disable</strong>.</p>
<p>This callback is optional and shall only be implemented by bridges
that support hot-plug notification without polling. Bridges that
implement it shall also implement the <strong>hpd_disable</strong> callback and set
the DRM_BRIDGE_OP_HPD flag in their <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_disable</span></code></dt><dd><p>Disable hot plug detection. Once this function returns the bridge
shall not call <a class="reference internal" href="#c.drm_bridge_hpd_notify" title="drm_bridge_hpd_notify"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_notify()</span></code></a> when a change in the output
connection status occurs.</p>
<p>This callback is optional and shall only be implemented by bridges
that support hot-plug notification without polling. Bridges that
implement it shall also implement the <strong>hpd_enable</strong> callback and set
the DRM_BRIDGE_OP_HPD flag in their <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debugfs_init</span></code></dt><dd><p>Allows bridges to create bridge-specific debugfs files.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_bridge_timings">
struct <code class="sig-name descname">drm_bridge_timings</code><a class="headerlink" href="#c.drm_bridge_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>timing information for the bridge</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_bridge_timings {
    u32 input_bus_flags;
    u32 setup_time_ps;
    u32 hold_time_ps;
    bool dual_link;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">input_bus_flags</span></code></dt><dd><p>Tells what additional settings for the pixel data on the bus
this bridge requires (like pixel signal polarity). See also
<a class="reference internal" href="drm-kms.html#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info-&gt;bus_flags</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup_time_ps</span></code></dt><dd><p>Defines the time in picoseconds the input data lines must be
stable before the clock edge.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hold_time_ps</span></code></dt><dd><p>Defines the time in picoseconds taken for the bridge to sample the
input signal after the clock edge.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dual_link</span></code></dt><dd><p>True if the bus operates in dual-link mode. The exact meaning is
dependent on the bus type. For LVDS buses, this indicates that even-
and odd-numbered pixels are received on separate links.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_bridge_ops">
enum <code class="sig-name descname">drm_bridge_ops</code><a class="headerlink" href="#c.drm_bridge_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitmask of operations supported by the bridge</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_OP_DETECT</span></code></dt><dd><p>The bridge can detect displays connected to
its output. Bridges that set this flag shall implement the
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;detect</span></code></a> callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_OP_EDID</span></code></dt><dd><p>The bridge can retrieve the EDID of the display
connected to its output. Bridges that set this flag shall implement
the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;get_edid</span></code></a> callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_OP_HPD</span></code></dt><dd><p>The bridge can detect hot-plug and hot-unplug
without requiring polling. Bridges that set this flag shall
implement the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;hpd_enable</span></code></a> and
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;hpd_disable</span></code></a> callbacks if they support enabling
and disabling hot-plug detection dynamically.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_BRIDGE_OP_MODES</span></code></dt><dd><p>The bridge can retrieve the modes supported
by the display at its output. This does not include reading EDID
which is separately covered by <strong>DRM_BRIDGE_OP_EDID</strong>. Bridges that set
this flag shall implement the <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs-&gt;get_modes</span></code></a> callback.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_bridge">
struct <code class="sig-name descname">drm_bridge</code><a class="headerlink" href="#c.drm_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM bridge control structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_bridge {
    struct drm_private_obj base;
    struct drm_device *dev;
    struct drm_encoder *encoder;
    struct list_head chain_node;
#ifdef CONFIG_OF;
    struct device_node *of_node;
#endif;
    struct list_head list;
    const struct drm_bridge_timings *timings;
    const struct drm_bridge_funcs *funcs;
    void *driver_private;
    enum drm_bridge_ops ops;
    int type;
    bool interlace_allowed;
    struct i2c_adapter *ddc;
    struct mutex hpd_mutex;
    void (*hpd_cb)(void *data, enum drm_connector_status status);
    void *hpd_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>inherit from <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_object</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>DRM device this bridge belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoder</span></code></dt><dd><p>encoder to which this bridge is connected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chain_node</span></code></dt><dd><p>used to form a bridge chain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt><dd><p>device node pointer to the bridge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>to keep track of all added bridges</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timings</span></code></dt><dd><p>the timing specification for the bridge, if any (may be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>control functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_private</span></code></dt><dd><p>pointer to the bridge driver’s internal context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>bitmask of operations supported by the bridge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type of the connection at the bridge output
(DRM_MODE_CONNECTOR_*). For bridges at the end of this chain this
identifies the type of connected display.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interlace_allowed</span></code></dt><dd><p>Indicate that the bridge can handle interlaced
modes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ddc</span></code></dt><dd><p>Associated I2C adapter for DDC access, if any.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_mutex</span></code></dt><dd><p>Protects the <strong>hpd_cb</strong> and <strong>hpd_data</strong> fields.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_cb</span></code></dt><dd><p>Hot plug detection callback, registered with
<a class="reference internal" href="#c.drm_bridge_hpd_enable" title="drm_bridge_hpd_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_enable()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hpd_data</span></code></dt><dd><p>Private data passed to the Hot plug detection callback
<strong>hpd_cb</strong>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_bridge_get_next_bridge">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drm_bridge_get_next_bridge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_get_next_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next bridge in the chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the next bridge in the chain after <strong>bridge</strong>, or NULL if <strong>bridge</strong> is the last.</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_get_prev_bridge">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drm_bridge_get_prev_bridge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_get_prev_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the previous bridge in the chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the previous bridge in the chain, or NULL if <strong>bridge</strong> is the first.</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_chain_get_first_bridge">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drm_bridge_chain_get_first_bridge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a><em> *encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_get_first_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first bridge in the chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the first bridge in the chain, or NULL if <strong>encoder</strong> has no bridge attached
to it.</p>
</div>
<dl class="function">
<dt id="c.drm_for_each_bridge_in_chain">
<code class="sig-name descname">drm_for_each_bridge_in_chain</code><span class="sig-paren">(</span><em>encoder</em>, <em>bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_bridge_in_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all bridges present in a chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">encoder</span></code></dt><dd><p>the encoder to iterate bridges on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bridge</span></code></dt><dd><p>a bridge pointer updated to point to the current bridge at each
iteration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all bridges present in the bridge chain attached to <strong>encoder</strong>.</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_add">
void <code class="sig-name descname">drm_bridge_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the given bridge to the global bridge list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.devm_drm_bridge_add">
int <code class="sig-name descname">devm_drm_bridge_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_drm_bridge_add" title="Permalink to this definition">¶</a></dt>
<dd><p>devm managed version of <a class="reference internal" href="#c.drm_bridge_add" title="drm_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_add()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to tie the bridge lifetime to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the managed version of <a class="reference internal" href="#c.drm_bridge_add" title="drm_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_add()</span></code></a> which automatically
calls <a class="reference internal" href="#c.drm_bridge_remove" title="drm_bridge_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_remove()</span></code></a> when <strong>dev</strong> is unbound.</p>
<p><strong>Return</strong></p>
<p>0 if no error or negative error code.</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_remove">
void <code class="sig-name descname">drm_bridge_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the given bridge from the global bridge list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_bridge_attach">
int <code class="sig-name descname">drm_bridge_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a><em> *encoder</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *previous</em>, enum <a class="reference internal" href="#c.drm_bridge_attach_flags" title="drm_bridge_attach_flags">drm_bridge_attach_flags</a><em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach the bridge to an encoder’s chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>DRM encoder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*previous</span></code></dt><dd><p>previous bridge in the chain (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_bridge_attach_flags</span> <span class="pre">flags</span></code></dt><dd><p>DRM_BRIDGE_ATTACH_* flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a kms driver to link the bridge to an encoder’s chain. The previous
argument specifies the previous bridge in the chain. If NULL, the bridge is
linked directly at the encoder’s output. Otherwise it is linked at the
previous bridge’s output.</p>
<p>If non-NULL the previous bridge must be already attached by a call to this
function.</p>
<p>Note that bridges attached to encoders are auto-detached during encoder
cleanup in <a class="reference internal" href="drm-kms.html#c.drm_encoder_cleanup" title="drm_encoder_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_encoder_cleanup()</span></code></a>, so <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a> should generally
<em>not</em> be balanced with a drm_bridge_detach() in driver code.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_chain_mode_fixup">
bool <code class="sig-name descname">drm_bridge_chain_mode_fixup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *adjusted_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_mode_fixup" title="Permalink to this definition">¶</a></dt>
<dd><p>fixup proposed mode for all bridges in the encoder chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>desired mode to be set for the bridge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*adjusted_mode</span></code></dt><dd><p>updated mode that works for this bridge</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup</span></code></a> for all the bridges in the
encoder chain, starting from the first bridge to the last.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
<p><strong>Return</strong></p>
<p>true on success, false on failure</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_chain_mode_valid">
enum <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="sig-name descname">drm_bridge_chain_mode_valid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_info" title="drm_display_info">drm_display_info</a><em> *info</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_mode_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the mode against all bridges in the encoder chain.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_info</span> <span class="pre">*info</span></code></dt><dd><p>display info against which the mode shall be validated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>desired mode to be validated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a> for all the bridges in the encoder
chain, starting from the first bridge to the last. If at least one bridge
does not accept the mode the function returns the error code.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder.</p>
<p><strong>Return</strong></p>
<p>MODE_OK on success, drm_mode_status Enum error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_chain_disable">
void <code class="sig-name descname">drm_bridge_chain_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disables all bridges in the encoder chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.disable</span></code></a> op for all the bridges in the encoder
chain, starting from the last bridge to the first. These are called before
calling the encoder’s prepare op.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_chain_post_disable">
void <code class="sig-name descname">drm_bridge_chain_post_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_post_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up after disabling all bridges in the encoder chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.post_disable</span></code></a> op for all the bridges in the
encoder chain, starting from the first bridge to the last. These are called
after completing the encoder’s prepare op.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_chain_mode_set">
void <code class="sig-name descname">drm_bridge_chain_mode_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *adjusted_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_mode_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set proposed mode for all bridges in the encoder chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>desired mode to be set for the encoder chain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*adjusted_mode</span></code></dt><dd><p>updated mode that works for this encoder chain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_set</span></code></a> op for all the bridges in the
encoder chain, starting from the first bridge to the last.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_chain_pre_enable">
void <code class="sig-name descname">drm_bridge_chain_pre_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_pre_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares for enabling all bridges in the encoder chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.pre_enable</span></code></a> op for all the bridges in the encoder
chain, starting from the last bridge to the first. These are called
before calling the encoder’s commit op.</p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_chain_enable">
void <code class="sig-name descname">drm_bridge_chain_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_chain_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enables all bridges in the encoder chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.enable</span></code></a> op for all the bridges in the encoder
chain, starting from the first bridge to the last. These are called
after completing the encoder’s commit op.</p>
<p>Note that the bridge passed should be the one closest to the encoder</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_bridge_chain_disable">
void <code class="sig-name descname">drm_atomic_bridge_chain_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_bridge_chain_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disables all bridges in the encoder chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>old atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_disable</span></code></a> (falls back on
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.disable</span></code></a>) op for all the bridges in the encoder chain,
starting from the last bridge to the first. These are called before calling
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_disable</span></code></a></p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_bridge_chain_post_disable">
void <code class="sig-name descname">drm_atomic_bridge_chain_post_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_bridge_chain_post_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up after disabling all bridges in the encoder chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>old atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_post_disable</span></code></a> (falls back on
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.post_disable</span></code></a>) op for all the bridges in the encoder chain,
starting from the first bridge to the last. These are called after completing
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_disable</span></code></a></p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_bridge_chain_pre_enable">
void <code class="sig-name descname">drm_atomic_bridge_chain_pre_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_bridge_chain_pre_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares for enabling all bridges in the encoder chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>old atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_pre_enable</span></code></a> (falls back on
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.pre_enable</span></code></a>) op for all the bridges in the encoder chain,
starting from the last bridge to the first. These are called before calling
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_enable</span></code></a></p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_bridge_chain_enable">
void <code class="sig-name descname">drm_atomic_bridge_chain_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_bridge_chain_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enables all bridges in the encoder chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*old_state</span></code></dt><dd><p>old atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_enable</span></code></a> (falls back on
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.enable</span></code></a>) op for all the bridges in the encoder chain,
starting from the first bridge to the last. These are called after completing
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_enable</span></code></a></p>
<p><strong>Note</strong></p>
<p>the bridge passed should be the one closest to the encoder</p>
</div>
<dl class="function">
<dt id="c.drm_atomic_bridge_chain_check">
int <code class="sig-name descname">drm_atomic_bridge_chain_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *crtc_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a><em> *conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_bridge_chain_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Do an atomic check on the bridge chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>new CRTC state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*conn_state</span></code></dt><dd><p>new connector state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>First trigger a bus format negotiation before calling
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.atomic_check()</span></code></a> (falls back on
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_fixup()</span></code></a>) op for all the bridges in the encoder chain,
starting from the last bridge to the first. These are called before calling
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_check()</span></code></a></p>
<p><strong>Return</strong></p>
<p>0 on success, a negative error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_detect">
enum <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status">drm_connector_status</a> <code class="sig-name descname">drm_bridge_detect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>check if anything is attached to the bridge output</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the bridge supports output detection, as reported by the
DRM_BRIDGE_OP_DETECT bridge ops flag, call <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.detect</span></code></a> for the
bridge and return the connection status. Otherwise return
connector_status_unknown.</p>
<p><strong>Return</strong></p>
<p>The detection status on success, or connector_status_unknown if the bridge
doesn’t support output detection.</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_get_modes">
int <code class="sig-name descname">drm_bridge_get_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_get_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>fill all modes currently valid for the sink into the <strong>connector</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector to fill with modes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the bridge supports output modes retrieval, as reported by the
DRM_BRIDGE_OP_MODES bridge ops flag, call <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.get_modes</span></code></a> to
fill the connector with all valid modes and return the number of modes
added. Otherwise return 0.</p>
<p><strong>Return</strong></p>
<p>The number of modes added to the connector.</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_get_edid">
struct edid * <code class="sig-name descname">drm_bridge_get_edid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_get_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>get the EDID data of the connected display</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector to read EDID for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the bridge supports output EDID retrieval, as reported by the
DRM_BRIDGE_OP_EDID bridge ops flag, call <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.get_edid</span></code></a> to
get the EDID and return it. Otherwise return NULL.</p>
<p><strong>Return</strong></p>
<p>The retrieved EDID on success, or NULL otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_hpd_enable">
void <code class="sig-name descname">drm_bridge_hpd_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, void (<em>*cb</em>)(void *data, enum <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status">drm_connector_status</a> status), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_hpd_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable hot plug detection for the bridge</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*cb)(void</span> <span class="pre">*data,</span> <span class="pre">enum</span> <span class="pre">drm_connector_status</span> <span class="pre">status)</span></code></dt><dd><p>hot-plug detection callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data to be passed to the hot-plug detection callback</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.hpd_enable</span></code></a> if implemented and register the given <strong>cb</strong>
and <strong>data</strong> as hot plug notification callback. From now on the <strong>cb</strong> will be
called with <strong>data</strong> when an output status change is detected by the bridge,
until hot plug notification gets disabled with <a class="reference internal" href="#c.drm_bridge_hpd_disable" title="drm_bridge_hpd_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_disable()</span></code></a>.</p>
<p>Hot plug detection is supported only if the DRM_BRIDGE_OP_HPD flag is set in
bridge-&gt;ops. This function shall not be called when the flag is not set.</p>
<p>Only one hot plug detection callback can be registered at a time, it is an
error to call this function when hot plug detection is already enabled for
the bridge.</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_hpd_disable">
void <code class="sig-name descname">drm_bridge_hpd_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_hpd_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable hot plug detection for the bridge</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.hpd_disable</span></code></a> if implemented and unregister the hot
plug detection callback previously registered with <a class="reference internal" href="#c.drm_bridge_hpd_enable" title="drm_bridge_hpd_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_enable()</span></code></a>.
Once this function returns the callback will not be called by the bridge
when an output status change occurs.</p>
<p>Hot plug detection is supported only if the DRM_BRIDGE_OP_HPD flag is set in
bridge-&gt;ops. This function shall not be called when the flag is not set.</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_hpd_notify">
void <code class="sig-name descname">drm_bridge_hpd_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em>, enum <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status">drm_connector_status</a><em> status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_hpd_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notify hot plug detection events</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>bridge control structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_connector_status</span> <span class="pre">status</span></code></dt><dd><p>output connection status</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Bridge drivers shall call this function to report hot plug events when they
detect a change in the output status, when hot plug detection has been
enabled by <a class="reference internal" href="#c.drm_bridge_hpd_enable" title="drm_bridge_hpd_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_hpd_enable()</span></code></a>.</p>
<p>This function shall be called in a context that can sleep.</p>
</div>
<dl class="function">
<dt id="c.of_drm_find_bridge">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">of_drm_find_bridge</code><span class="sig-paren">(</span>struct device_node<em> *np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_drm_find_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>find the bridge corresponding to the device node in the global bridge list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>device node</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>drm_bridge control struct on success, NULL on failure</p>
</div>
</section>
<section id="bridge-connector-helper-reference">
<h3>Bridge Connector Helper Reference<a class="headerlink" href="#bridge-connector-helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.drm_bridge_connector_enable_hpd">
void <code class="sig-name descname">drm_bridge_connector_enable_hpd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_connector_enable_hpd" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable hot-plug detection for the connector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>The DRM bridge connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables hot-plug detection for the given bridge connector.
This is typically used by display drivers in their resume handler.</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_connector_disable_hpd">
void <code class="sig-name descname">drm_bridge_connector_disable_hpd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_connector_disable_hpd" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable hot-plug detection for the connector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>The DRM bridge connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disables hot-plug detection for the given bridge connector.
This is typically used by display drivers in their suspend handler.</p>
</div>
<dl class="function">
<dt id="c.drm_bridge_connector_init">
struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> * <code class="sig-name descname">drm_bridge_connector_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *drm</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a><em> *encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_connector_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise a connector for a chain of bridges</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*drm</span></code></dt><dd><p>the DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>the encoder where the bridge chain starts</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate, initialise and register a <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_connector</span></code> with the <strong>drm</strong>
device. The connector is associated with a chain of bridges that starts at
the <strong>encoder</strong>. All bridges in the chain shall report bridge operation flags
(<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;ops</span></code></a>) and bridge output type (<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge-&gt;type</span></code></a>), and none of
them may create a DRM connector directly.</p>
<p>Returns a pointer to the new connector on success, or a negative error
pointer otherwise.</p>
</div>
</section>
<section id="panel-bridge-helper-reference">
<h3>Panel-Bridge Helper Reference<a class="headerlink" href="#panel-bridge-helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.drm_bridge_is_panel">
bool <code class="sig-name descname">drm_bridge_is_panel</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bridge_is_panel" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a drm_bridge is a panel_bridge.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>The drm_bridge to be checked.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the bridge is a panel bridge, or false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_bridge_add">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drm_panel_bridge_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_bridge_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> that just calls the appropriate functions from <a class="reference internal" href="#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>The drm_panel being wrapped.  Must be non-NULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For drivers converting from directly using drm_panel: The expected
usage pattern is that during either encoder module probe or DSI
host attach, a drm_panel will be looked up through
<a class="reference internal" href="#c.drm_of_find_panel_or_bridge" title="drm_of_find_panel_or_bridge"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_of_find_panel_or_bridge()</span></code></a>.  <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a> is used to
wrap that panel in the new bridge, and the result can then be
passed to <a class="reference internal" href="#c.drm_bridge_attach" title="drm_bridge_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_bridge_attach()</span></code></a>.  The <a class="reference internal" href="#c.drm_panel_prepare" title="drm_panel_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_prepare()</span></code></a> and related
functions can be dropped from the encoder driver (they’re now
called by the KMS helpers before calling into the encoder), along
with connector creation.  When done with the bridge (after
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_config_cleanup()</span></code></a> if the bridge has already been attached), then
<a class="reference internal" href="#c.drm_panel_bridge_remove" title="drm_panel_bridge_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_remove()</span></code></a> to free it.</p>
<p>The connector type is set to <strong>panel-&gt;connector_type</strong>, which must be set to a
known type. Calling this function with a panel whose connector type is
DRM_MODE_CONNECTOR_Unknown will return ERR_PTR(-EINVAL).</p>
<p>See <a class="reference internal" href="#c.devm_drm_panel_bridge_add" title="devm_drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_panel_bridge_add()</span></code></a> for an automatically managed version of this
function.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_bridge_add_typed">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drm_panel_bridge_add_typed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em>, u32<em> connector_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_bridge_add_typed" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> with an explicit connector type.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>The drm_panel being wrapped.  Must be non-NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">connector_type</span></code></dt><dd><p>The connector type (DRM_MODE_CONNECTOR_*)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is just like <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a>, but forces the connector type to
<strong>connector_type</strong> instead of infering it from the panel.</p>
<p>This function is deprecated and should not be used in new drivers. Use
<a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a> instead, and fix panel drivers as necessary if they
don’t report a connector type.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_bridge_remove">
void <code class="sig-name descname">drm_panel_bridge_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_bridge_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters and frees a drm_bridge created by <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>The drm_bridge being freed.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_panel_bridge_set_orientation">
int <code class="sig-name descname">drm_panel_bridge_set_orientation</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_bridge_set_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the connector’s panel orientation from the bridge that can be transformed to panel bridge.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>The connector to be set panel orientation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>The drm_bridge to be transformed to panel bridge.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, negative errno on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_drm_panel_bridge_add">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">devm_drm_panel_bridge_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_drm_panel_bridge_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a managed <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> that just calls the appropriate functions from <a class="reference internal" href="#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to tie the bridge lifetime to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>The drm_panel being wrapped.  Must be non-NULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the managed version of <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a> which automatically
calls <a class="reference internal" href="#c.drm_panel_bridge_remove" title="drm_panel_bridge_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_remove()</span></code></a> when <strong>dev</strong> is unbound.</p>
</div>
<dl class="function">
<dt id="c.devm_drm_panel_bridge_add_typed">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">devm_drm_panel_bridge_add_typed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em>, u32<em> connector_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_drm_panel_bridge_add_typed" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a managed <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> with an explicit connector type.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to tie the bridge lifetime to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>The drm_panel being wrapped.  Must be non-NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">connector_type</span></code></dt><dd><p>The connector type (DRM_MODE_CONNECTOR_*)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is just like <a class="reference internal" href="#c.devm_drm_panel_bridge_add" title="devm_drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_panel_bridge_add()</span></code></a>, but forces the connector type
to <strong>connector_type</strong> instead of infering it from the panel.</p>
<p>This function is deprecated and should not be used in new drivers. Use
<a class="reference internal" href="#c.devm_drm_panel_bridge_add" title="devm_drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_panel_bridge_add()</span></code></a> instead, and fix panel drivers as necessary if
they don’t report a connector type.</p>
</div>
<dl class="function">
<dt id="c.drmm_panel_bridge_add">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drmm_panel_bridge_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *drm</em>, struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drmm_panel_bridge_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a DRM-managed <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> that just calls the appropriate functions from <a class="reference internal" href="#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*drm</span></code></dt><dd><p>DRM device to tie the bridge lifetime to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>The drm_panel being wrapped.  Must be non-NULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the DRM-managed version of <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a> which
automatically calls <a class="reference internal" href="#c.drm_panel_bridge_remove" title="drm_panel_bridge_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_remove()</span></code></a> when <strong>dev</strong> is cleaned
up.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_bridge_connector">
struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> * <code class="sig-name descname">drm_panel_bridge_connector</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> *bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_bridge_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>return the connector for the panel bridge</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">*bridge</span></code></dt><dd><p>The drm_bridge.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>drm_panel_bridge creates the connector.
This function gives external access to the connector.</p>
<p><strong>Return</strong></p>
<p>Pointer to drm_connector</p>
</div>
<dl class="function">
<dt id="c.devm_drm_of_get_bridge">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">devm_drm_of_get_bridge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct device_node<em> *np</em>, u32<em> port</em>, u32<em> endpoint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_drm_of_get_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return next bridge in the chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to tie the bridge lifetime to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>device tree node containing encoder output ports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">port</span></code></dt><dd><p>port in the device tree node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">endpoint</span></code></dt><dd><p>endpoint in the device tree node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a DT node’s port and endpoint number, finds the connected node
and returns the associated bridge if any, or creates and returns a
drm panel bridge instance if a panel is connected.</p>
<p>Returns a pointer to the bridge if successful, or an error pointer
otherwise.</p>
</div>
<dl class="function">
<dt id="c.drmm_of_get_bridge">
struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a> * <code class="sig-name descname">drmm_of_get_bridge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *drm</em>, struct device_node<em> *np</em>, u32<em> port</em>, u32<em> endpoint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drmm_of_get_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return next bridge in the chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*drm</span></code></dt><dd><p>device to tie the bridge lifetime to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>device tree node containing encoder output ports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">port</span></code></dt><dd><p>port in the device tree node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">endpoint</span></code></dt><dd><p>endpoint in the device tree node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a DT node’s port and endpoint number, finds the connected node
and returns the associated bridge if any, or creates and returns a
drm panel bridge instance if a panel is connected.</p>
<p>Returns a drmm managed pointer to the bridge if successful, or an error
pointer otherwise.</p>
</div>
</section>
</section>
<section id="panel-helper-reference">
<span id="drm-panel-helper"></span><h2>Panel Helper Reference<a class="headerlink" href="#panel-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>The DRM panel helpers allow drivers to register panel objects with a
central registry and provide functions to retrieve those panels in display
drivers.</p>
<p>For easy integration into drivers using the <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge</span></code></a> infrastructure please
take look at <a class="reference internal" href="#c.drm_panel_bridge_add" title="drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_bridge_add()</span></code></a> and <a class="reference internal" href="#c.devm_drm_panel_bridge_add" title="devm_drm_panel_bridge_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_panel_bridge_add()</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_panel_funcs">
struct <code class="sig-name descname">drm_panel_funcs</code><a class="headerlink" href="#c.drm_panel_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>perform operations on a given panel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panel_funcs {
    int (*prepare)(struct drm_panel *panel);
    int (*enable)(struct drm_panel *panel);
    int (*disable)(struct drm_panel *panel);
    int (*unprepare)(struct drm_panel *panel);
    int (*get_modes)(struct drm_panel *panel, struct drm_connector *connector);
    enum drm_panel_orientation (*get_orientation)(struct drm_panel *panel);
    int (*get_timings)(struct drm_panel *panel, unsigned int num_timings, struct display_timing *timings);
    void (*debugfs_init)(struct drm_panel *panel, struct dentry *root);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">prepare</span></code></dt><dd><p>Turn on panel and perform set up.</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>Enable panel (turn on back light, etc.).</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>Disable panel (turn off back light, etc.).</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unprepare</span></code></dt><dd><p>Turn off panel.</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_modes</span></code></dt><dd><p>Add modes to the connector that the panel is attached to
and returns the number of modes added.</p>
<p>This function is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_orientation</span></code></dt><dd><p>Return the panel orientation set by device tree or EDID.</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_timings</span></code></dt><dd><p>Copy display timings into the provided array and return
the number of display timings available.</p>
<p>This function is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debugfs_init</span></code></dt><dd><p>Allows panels to create panels-specific debugfs files.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The .prepare() function is typically called before the display controller
starts to transmit video data. Panel drivers can use this to turn the panel
on and wait for it to become ready. If additional configuration is required
(via a control bus such as I2C, SPI or DSI for example) this is a good time
to do that.</p>
<p>After the display controller has started transmitting video data, it’s safe
to call the .enable() function. This will typically enable the backlight to
make the image on screen visible. Some panels require a certain amount of
time or frames before the image is displayed. This function is responsible
for taking this into account before enabling the backlight to avoid visual
glitches.</p>
<p>Before stopping video transmission from the display controller it can be
necessary to turn off the panel to avoid visual glitches. This is done in
the .disable() function. Analogously to .enable() this typically involves
turning off the backlight and waiting for some time to make sure no image
is visible on the panel. It is then safe for the display controller to
cease transmission of video data.</p>
<p>To save power when no video data is transmitted, a driver can power down
the panel. This is the job of the .unprepare() function.</p>
<p>Backlight can be handled automatically if configured using
<a class="reference internal" href="#c.drm_panel_of_backlight" title="drm_panel_of_backlight"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_of_backlight()</span></code></a> or <a class="reference internal" href="#c.drm_panel_dp_aux_backlight" title="drm_panel_dp_aux_backlight"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_dp_aux_backlight()</span></code></a>. Then the driver
does not need to implement the functionality to enable/disable backlight.</p>
<dl class="type">
<dt id="c.drm_panel">
struct <code class="sig-name descname">drm_panel</code><a class="headerlink" href="#c.drm_panel" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM panel object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_panel {
    struct device *dev;
    struct backlight_device *backlight;
    const struct drm_panel_funcs *funcs;
    int connector_type;
    struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Parent device of the panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlight</span></code></dt><dd><p>Backlight device, used to turn on backlight after the call
to enable(), and to turn off backlight before the call to
disable().
backlight is set by <a class="reference internal" href="#c.drm_panel_of_backlight" title="drm_panel_of_backlight"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_of_backlight()</span></code></a> or
<a class="reference internal" href="#c.drm_panel_dp_aux_backlight" title="drm_panel_dp_aux_backlight"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_dp_aux_backlight()</span></code></a> and drivers shall not assign it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>Operations that can be performed on the panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector_type</span></code></dt><dd><p>Type of the panel as a DRM_MODE_CONNECTOR_* value. This is used to
initialise the drm_connector corresponding to the panel with the
correct connector type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>Panel entry in registry.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_panel_init">
void <code class="sig-name descname">drm_panel_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct <a class="reference internal" href="#c.drm_panel_funcs" title="drm_panel_funcs">drm_panel_funcs</a><em> *funcs</em>, int<em> connector_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a panel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>DRM panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>parent device of the panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_panel_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>panel operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">connector_type</span></code></dt><dd><p>the connector type (DRM_MODE_CONNECTOR_*) corresponding to
the panel interface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the panel structure for subsequent registration with
<a class="reference internal" href="#c.drm_panel_add" title="drm_panel_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_add()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_add">
void <code class="sig-name descname">drm_panel_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a panel to the global registry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>panel to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a panel to the global registry so that it can be looked up by display
drivers.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_remove">
void <code class="sig-name descname">drm_panel_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a panel from the global registry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a panel from the global registry.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_prepare">
int <code class="sig-name descname">drm_panel_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>power on a panel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will enable power and deassert any reset signals to
the panel. After this has completed it is possible to communicate with any
integrated circuitry via a command bus.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_unprepare">
int <code class="sig-name descname">drm_panel_unprepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_unprepare" title="Permalink to this definition">¶</a></dt>
<dd><p>power off a panel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will completely power off a panel (assert the panel’s
reset, turn off power supplies, …). After this function has completed, it
is usually no longer possible to communicate with the panel until another
call to <a class="reference internal" href="#c.drm_panel_prepare" title="drm_panel_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_prepare()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_enable">
int <code class="sig-name descname">drm_panel_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable a panel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will cause the panel display drivers to be turned on
and the backlight to be enabled. Content will be visible on screen after
this call completes.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_disable">
int <code class="sig-name descname">drm_panel_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable a panel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will typically turn off the panel’s backlight or disable the display
drivers. For smart panels it should still be possible to communicate with
the integrated circuitry via any command bus after this call.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_get_modes">
int <code class="sig-name descname">drm_panel_get_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_get_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>probe the available display modes of a panel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>DRM panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>DRM connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The modes probed from the panel are automatically added to the connector
that the panel is attached to.</p>
<p><strong>Return</strong></p>
<p>The number of modes available from the panel on success or a
negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.of_drm_find_panel">
struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> * <code class="sig-name descname">of_drm_find_panel</code><span class="sig-paren">(</span>const struct device_node<em> *np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_drm_find_panel" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a panel using a device tree node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>device tree node of the panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Searches the set of registered panels for one that matches the given device
tree node. If a matching panel is found, return a pointer to it.</p>
<p>Possible error codes returned by this function:</p>
<ul class="simple">
<li><p>EPROBE_DEFER: the panel device has not been probed yet, and the caller
should retry later</p></li>
<li><p>ENODEV: the device is not available (status != “okay” or “ok”)</p></li>
</ul>
<p><strong>Return</strong></p>
<p>A pointer to the panel registered for the specified device tree
node or an ERR_PTR() if no panel matching the device tree node can be found.</p>
</div>
<dl class="function">
<dt id="c.of_drm_get_panel_orientation">
int <code class="sig-name descname">of_drm_get_panel_orientation</code><span class="sig-paren">(</span>const struct device_node<em> *np</em>, enum <a class="reference internal" href="drm-kms.html#c.drm_panel_orientation" title="drm_panel_orientation">drm_panel_orientation</a><em> *orientation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_drm_get_panel_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>look up the orientation of the panel through the “rotation” binding from a device tree node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>device tree node of the panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_panel_orientation</span> <span class="pre">*orientation</span></code></dt><dd><p>orientation enum to be filled in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the rotation of a panel in the device tree. The orientation of the
panel is expressed as a property name “rotation” in the device tree. The
rotation in the device tree is counter clockwise.</p>
<p><strong>Return</strong></p>
<p>0 when a valid rotation value (0, 90, 180, or 270) is read or the
rotation property doesn’t exist. Return a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_of_backlight">
int <code class="sig-name descname">drm_panel_of_backlight</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_of_backlight" title="Permalink to this definition">¶</a></dt>
<dd><p>use backlight device node for backlight</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>DRM panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this function to enable backlight handling if your panel
uses device tree and has a backlight phandle.</p>
<p>When the panel is enabled backlight will be enabled after a
successful call to <a class="reference internal" href="#c.drm_panel_funcs" title="drm_panel_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel_funcs.enable()</span></code></a></p>
<p>When the panel is disabled backlight will be disabled before the
call to <a class="reference internal" href="#c.drm_panel_funcs" title="drm_panel_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel_funcs.disable()</span></code></a>.</p>
<p>A typical implementation for a panel driver supporting device tree
will call this function at probe time. Backlight will then be handled
transparently without requiring any intervention from the driver.
<a class="reference internal" href="#c.drm_panel_of_backlight" title="drm_panel_of_backlight"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_of_backlight()</span></code></a> must be called after the call to <a class="reference internal" href="#c.drm_panel_init" title="drm_panel_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_init()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_get_panel_orientation_quirk">
int <code class="sig-name descname">drm_get_panel_orientation_quirk</code><span class="sig-paren">(</span>int<em> width</em>, int<em> height</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_panel_orientation_quirk" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for panel orientation quirks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>width in pixels of the panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">height</span></code></dt><dd><p>height in pixels of the panel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks for platform specific (e.g. DMI based) quirks
providing info on panel_orientation for systems where this cannot be
probed from the hard-/firm-ware. To avoid false-positive this function
takes the panel resolution as argument and checks that against the
resolution expected by the quirk-table entry.</p>
<p>Note this function is also used outside of the drm-subsys, by for example
the efifb code. Because of this this function gets compiled into its own
kernel-module when built as a module.</p>
<p><strong>Return</strong></p>
<p>A DRM_MODE_PANEL_ORIENTATION_* value if there is a quirk for this system,
or DRM_MODE_PANEL_ORIENTATION_UNKNOWN if there is no quirk.</p>
</div>
</section>
<section id="panel-self-refresh-helper-reference">
<h2>Panel Self Refresh Helper Reference<a class="headerlink" href="#panel-self-refresh-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>This helper library provides an easy way for drivers to leverage the atomic
framework to implement panel self refresh (SR) support. Drivers are
responsible for initializing and cleaning up the SR helpers on load/unload
(see <a class="reference internal" href="#c.drm_self_refresh_helper_init" title="drm_self_refresh_helper_init"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_self_refresh_helper_init</span></code></a>/<a class="reference internal" href="#c.drm_self_refresh_helper_cleanup" title="drm_self_refresh_helper_cleanup"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_self_refresh_helper_cleanup</span></code></a>).
The connector is responsible for setting
<a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.self_refresh_aware</span></code></a> to true at runtime if it is SR-aware
(meaning it knows how to initiate self refresh on the panel).</p>
<p>Once a crtc has enabled SR using <a class="reference internal" href="#c.drm_self_refresh_helper_init" title="drm_self_refresh_helper_init"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_self_refresh_helper_init</span></code></a>, the
helpers will monitor activity and call back into the driver to enable/disable
SR as appropriate. The best way to think about this is that it’s a DPMS
on/off request with <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.self_refresh_active</span></code></a> set in crtc state
that tells you to disable/enable SR on the panel instead of power-cycling it.</p>
<p>During SR, drivers may choose to fully disable their crtc/encoder/bridge
hardware (in which case no driver changes are necessary), or they can inspect
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.self_refresh_active</span></code></a> if they want to enter low power mode
without full disable (in case full disable/enable is too slow).</p>
<p>SR will be deactivated if there are any atomic updates affecting the
pipe that is in SR mode. If a crtc is driving multiple connectors, all
connectors must be SR aware and all will enter/exit SR mode at the same time.</p>
<p>If the crtc and connector are SR aware, but the panel connected does not
support it (or is otherwise unable to enter SR), the driver should fail
atomic_check when <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state.self_refresh_active</span></code></a> is true.</p>
<dl class="function">
<dt id="c.drm_self_refresh_helper_update_avg_times">
void <code class="sig-name descname">drm_self_refresh_helper_update_avg_times</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, unsigned int<em> commit_time_ms</em>, unsigned int<em> new_self_refresh_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_self_refresh_helper_update_avg_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates a crtc’s SR time averages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>the state which has just been applied to hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">commit_time_ms</span></code></dt><dd><p>the amount of time in ms that this commit took to complete</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">new_self_refresh_mask</span></code></dt><dd><p>bitmask of crtc’s that have self_refresh_active in
new state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called after <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_commit_tail</span></code></a>, this function will
update the average entry/exit self refresh times on self refresh transitions.
These averages will be used when calculating how long to delay before
entering self refresh mode after activity.</p>
</div>
<dl class="function">
<dt id="c.drm_self_refresh_helper_alter_state">
void <code class="sig-name descname">drm_self_refresh_helper_alter_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_self_refresh_helper_alter_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Alters the atomic state for SR exit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>the state currently being checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at the end of atomic check. This function checks the state for flags
incompatible with self refresh exit and changes them. This is a bit
disingenuous since userspace is expecting one thing and we’re giving it
another. However in order to keep self refresh entirely hidden from
userspace, this is required.</p>
<p>At the end, we queue up the self refresh entry work so we can enter PSR after
the desired delay.</p>
</div>
<dl class="function">
<dt id="c.drm_self_refresh_helper_init">
int <code class="sig-name descname">drm_self_refresh_helper_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_self_refresh_helper_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes self refresh helpers for a crtc</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>the crtc which supports self refresh supported displays</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero if successful or -errno on failure</p>
</div>
<dl class="function">
<dt id="c.drm_self_refresh_helper_cleanup">
void <code class="sig-name descname">drm_self_refresh_helper_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_self_refresh_helper_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Cleans up self refresh helpers for a crtc</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>the crtc to cleanup</p>
</dd>
</dl>
</div>
</section>
<section id="hdcp-helper-functions-reference">
<h2>HDCP Helper Functions Reference<a class="headerlink" href="#hdcp-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.drm_hdcp_check_ksvs_revoked">
int <code class="sig-name descname">drm_hdcp_check_ksvs_revoked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *drm_dev</em>, u8<em> *ksvs</em>, u32<em> ksv_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdcp_check_ksvs_revoked" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the revoked status of the IDs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*drm_dev</span></code></dt><dd><p>drm_device for which HDCP revocation check is requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*ksvs</span></code></dt><dd><p>List of KSVs (HDCP receiver IDs)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">ksv_count</span></code></dt><dd><p>KSV count passed in through <strong>ksvs</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function reads the HDCP System renewability Message(SRM Table)
from userspace as a firmware and parses it for the revoked HDCP
KSVs(Receiver IDs) detected by DCP LLC. Once the revoked KSVs are known,
revoked state of the KSVs in the list passed in by display drivers are
decided and response is sent.</p>
<p>SRM should be presented in the name of “display_hdcp_srm.bin”.</p>
<p>Format of the SRM table, that userspace needs to write into the binary file,
is defined at:
1. Renewability chapter on 55th page of HDCP 1.4 specification
<a class="reference external" href="https://www.digital-cp.com/sites/default/files/specifications">https://www.digital-cp.com/sites/default/files/specifications</a>/HDCP``20Specification````20Rev1_4_Secure``.pdf
2. Renewability chapter on 63rd page of HDCP 2.2 specification
<a class="reference external" href="https://www.digital-cp.com/sites/default/files/specifications">https://www.digital-cp.com/sites/default/files/specifications</a>/HDCP``20on````20HDMI````20Specification````20Rev2_2_Final1``.pdf</p>
<p><strong>Return</strong></p>
<p>Count of the revoked KSVs or -ve error number in case of the failure.</p>
</div>
<dl class="function">
<dt id="c.drm_connector_attach_content_protection_property">
int <code class="sig-name descname">drm_connector_attach_content_protection_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, bool<em> hdcp_content_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_content_protection_property" title="Permalink to this definition">¶</a></dt>
<dd><p>attach content protection property</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to attach CP property on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">hdcp_content_type</span></code></dt><dd><p>is HDCP Content Type property needed for connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to add support for content protection on select connectors.
Content Protection is intentionally vague to allow for different underlying
technologies, however it is most implemented by HDCP.</p>
<p>When hdcp_content_type is true enum property called HDCP Content Type is
created (if it is not already) and attached to the connector.</p>
<p>This property is used for sending the protected content’s stream type
from userspace to kernel on selected connectors. Protected content provider
will decide their type of their content and declare the same to kernel.</p>
<p>Content type will be used during the HDCP 2.2 authentication.
Content type will be set to <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.hdcp_content_type</span></code></a>.</p>
<p>The content protection will be set to <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_state.content_protection</span></code></a></p>
<p>When kernel triggered content protection state change like DESIRED-&gt;ENABLED
and ENABLED-&gt;DESIRED, will use <a class="reference internal" href="#c.drm_hdcp_update_content_protection" title="drm_hdcp_update_content_protection"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_hdcp_update_content_protection()</span></code></a> to update
the content protection state of a connector.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_hdcp_update_content_protection">
void <code class="sig-name descname">drm_hdcp_update_content_protection</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, u64<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdcp_update_content_protection" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the content protection state of a connector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm_connector on which content protection state needs an update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">val</span></code></dt><dd><p>New state of the content protection property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by display drivers, to update the kernel triggered
content protection state changes of a drm_connector such as DESIRED-&gt;ENABLED
and ENABLED-&gt;DESIRED. No uevent for DESIRED-&gt;UNDESIRED or ENABLED-&gt;UNDESIRED,
as userspace is triggering such state change and kernel performs it without
fail.This function update the new state of the property into the connector’s
state and generate an uevent to notify the userspace.</p>
</div>
</section>
<section id="display-port-helper-functions-reference">
<h2>Display Port Helper Functions Reference<a class="headerlink" href="#display-port-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>These functions contain some common logic and helpers at various abstraction
levels to deal with Display Port sink devices and related things like DP aux
channel transfers, EDID reading over DP aux channels, decoding certain DPCD
blocks, …</p>
<p>The DisplayPort AUX channel is an abstraction to allow generic, driver-
independent access to AUX functionality. Drivers can take advantage of
this by filling in the fields of the drm_dp_aux structure.</p>
<p>Transactions are described using a hardware-independent drm_dp_aux_msg
structure, which is passed into a driver’s .transfer() implementation.
Both native and I2C-over-AUX transactions are supported.</p>
<dl class="type">
<dt id="c.dp_sdp_header">
struct <code class="sig-name descname">dp_sdp_header</code><a class="headerlink" href="#c.dp_sdp_header" title="Permalink to this definition">¶</a></dt>
<dd><p>DP secondary data packet header</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dp_sdp_header {
    u8 HB0;
    u8 HB1;
    u8 HB2;
    u8 HB3;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">HB0</span></code></dt><dd><p>Secondary Data Packet ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HB1</span></code></dt><dd><p>Secondary Data Packet Type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HB2</span></code></dt><dd><p>Secondary Data Packet Specific header, Byte 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HB3</span></code></dt><dd><p>Secondary Data packet Specific header, Byte 1</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dp_sdp">
struct <code class="sig-name descname">dp_sdp</code><a class="headerlink" href="#c.dp_sdp" title="Permalink to this definition">¶</a></dt>
<dd><p>DP secondary data packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dp_sdp {
    struct dp_sdp_header sdp_header;
    u8 db[32];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sdp_header</span></code></dt><dd><p>DP secondary data packet header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">db</span></code></dt><dd><p>DP secondaray data packet data blocks
VSC SDP Payload for PSR
db[0]: Stereo Interface
db[1]: 0 - PSR State; 1 - Update RFB; 2 - CRC Valid
db[2]: CRC value bits 7:0 of the R or Cr component
db[3]: CRC value bits 15:8 of the R or Cr component
db[4]: CRC value bits 7:0 of the G or Y component
db[5]: CRC value bits 15:8 of the G or Y component
db[6]: CRC value bits 7:0 of the B or Cb component
db[7]: CRC value bits 15:8 of the B or Cb component
db[8] - db[31]: Reserved
VSC SDP Payload for Pixel Encoding/Colorimetry Format
db[0] - db[15]: Reserved
db[16]: Pixel Encoding and Colorimetry Formats
db[17]: Dynamic Range and Component Bit Depth
db[18]: Content Type
db[19] - db[31]: Reserved</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dp_pixelformat">
enum <code class="sig-name descname">dp_pixelformat</code><a class="headerlink" href="#c.dp_pixelformat" title="Permalink to this definition">¶</a></dt>
<dd><p>drm DP Pixel encoding formats</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DP_PIXELFORMAT_RGB</span></code></dt><dd><p>RGB pixel encoding format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_PIXELFORMAT_YUV444</span></code></dt><dd><p>YCbCr 4:4:4 pixel encoding format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_PIXELFORMAT_YUV422</span></code></dt><dd><p>YCbCr 4:2:2 pixel encoding format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_PIXELFORMAT_YUV420</span></code></dt><dd><p>YCbCr 4:2:0 pixel encoding format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_PIXELFORMAT_Y_ONLY</span></code></dt><dd><p>Y Only pixel encoding format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_PIXELFORMAT_RAW</span></code></dt><dd><p>RAW pixel encoding format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_PIXELFORMAT_RESERVED</span></code></dt><dd><p>Reserved pixel encoding format</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This enum is used to indicate DP VSC SDP Pixel encoding formats.
It is based on DP 1.4 spec [Table 2-117: VSC SDP Payload for DB16 through
DB18]</p>
<dl class="type">
<dt id="c.dp_colorimetry">
enum <code class="sig-name descname">dp_colorimetry</code><a class="headerlink" href="#c.dp_colorimetry" title="Permalink to this definition">¶</a></dt>
<dd><p>drm DP Colorimetry formats</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_DEFAULT</span></code></dt><dd><p>sRGB (IEC 61966-2-1) or
ITU-R BT.601 colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_RGB_WIDE_FIXED</span></code></dt><dd><p>RGB wide gamut fixed point colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_BT709_YCC</span></code></dt><dd><p>ITU-R BT.709 colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_RGB_WIDE_FLOAT</span></code></dt><dd><p>RGB wide gamut floating point
(scRGB (IEC 61966-2-2)) colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_XVYCC_601</span></code></dt><dd><p>xvYCC601 colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_OPRGB</span></code></dt><dd><p>OpRGB colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_XVYCC_709</span></code></dt><dd><p>xvYCC709 colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_DCI_P3_RGB</span></code></dt><dd><p>DCI-P3 (SMPTE RP 431-2) colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_SYCC_601</span></code></dt><dd><p>sYCC601 colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_RGB_CUSTOM</span></code></dt><dd><p>RGB Custom Color Profile colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_OPYCC_601</span></code></dt><dd><p>opYCC601 colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_BT2020_RGB</span></code></dt><dd><p>ITU-R BT.2020 R’ G’ B’ colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_BT2020_CYCC</span></code></dt><dd><p>ITU-R BT.2020 Y’c C’bc C’rc colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_COLORIMETRY_BT2020_YCC</span></code></dt><dd><p>ITU-R BT.2020 Y’ C’b C’r colorimetry format</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This enum is used to indicate DP VSC SDP Colorimetry formats.
It is based on DP 1.4 spec [Table 2-117: VSC SDP Payload for DB16 through
DB18] and a name of enum member follows DRM_MODE_COLORIMETRY definition.</p>
<dl class="type">
<dt id="c.dp_dynamic_range">
enum <code class="sig-name descname">dp_dynamic_range</code><a class="headerlink" href="#c.dp_dynamic_range" title="Permalink to this definition">¶</a></dt>
<dd><p>drm DP Dynamic Range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DP_DYNAMIC_RANGE_VESA</span></code></dt><dd><p>VESA range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_DYNAMIC_RANGE_CTA</span></code></dt><dd><p>CTA range</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This enum is used to indicate DP VSC SDP Dynamic Range.
It is based on DP 1.4 spec [Table 2-117: VSC SDP Payload for DB16 through
DB18]</p>
<dl class="type">
<dt id="c.dp_content_type">
enum <code class="sig-name descname">dp_content_type</code><a class="headerlink" href="#c.dp_content_type" title="Permalink to this definition">¶</a></dt>
<dd><p>drm DP Content Type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DP_CONTENT_TYPE_NOT_DEFINED</span></code></dt><dd><p>Not defined type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_CONTENT_TYPE_GRAPHICS</span></code></dt><dd><p>Graphics type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_CONTENT_TYPE_PHOTO</span></code></dt><dd><p>Photo type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_CONTENT_TYPE_VIDEO</span></code></dt><dd><p>Video type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_CONTENT_TYPE_GAME</span></code></dt><dd><p>Game type</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This enum is used to indicate DP VSC SDP Content Types.
It is based on DP 1.4 spec [Table 2-117: VSC SDP Payload for DB16 through
DB18]
CTA-861-G defines content types and expected processing by a sink device</p>
<dl class="type">
<dt id="c.drm_dp_vsc_sdp">
struct <code class="sig-name descname">drm_dp_vsc_sdp</code><a class="headerlink" href="#c.drm_dp_vsc_sdp" title="Permalink to this definition">¶</a></dt>
<dd><p>drm DP VSC SDP</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_vsc_sdp {
    unsigned char sdp_type;
    unsigned char revision;
    unsigned char length;
    enum dp_pixelformat pixelformat;
    enum dp_colorimetry colorimetry;
    int bpc;
    enum dp_dynamic_range dynamic_range;
    enum dp_content_type content_type;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sdp_type</span></code></dt><dd><p>secondary-data packet type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">revision</span></code></dt><dd><p>revision number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>number of valid data bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pixelformat</span></code></dt><dd><p>pixel encoding format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">colorimetry</span></code></dt><dd><p>colorimetry format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpc</span></code></dt><dd><p>bit per color</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dynamic_range</span></code></dt><dd><p>dynamic range information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">content_type</span></code></dt><dd><p>CTA-861-G defines content types and expected processing by a sink device</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents a DP VSC SDP of drm
It is based on DP 1.4 spec [Table 2-116: VSC SDP Header Bytes] and
[Table 2-117: VSC SDP Payload for DB16 through DB18]</p>
<dl class="function">
<dt id="c.drm_edp_backlight_supported">
bool <code class="sig-name descname">drm_edp_backlight_supported</code><span class="sig-paren">(</span>const u8<em> edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edp_backlight_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>Check an eDP DPCD for VESA backlight support</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE]</span></code></dt><dd><p>The DPCD to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that currently this function will return <code class="docutils literal notranslate"><span class="pre">false</span></code> for panels which support various DPCD
backlight features but which require the brightness be set through PWM, and don’t support setting
the brightness level via the DPCD.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <strong>edp_dpcd</strong> indicates that VESA backlight controls are supported, <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise</p>
</div>
<dl class="type">
<dt id="c.drm_dp_aux_msg">
struct <code class="sig-name descname">drm_dp_aux_msg</code><a class="headerlink" href="#c.drm_dp_aux_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort AUX channel transaction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_aux_msg {
    unsigned int address;
    u8 request;
    u8 reply;
    void *buffer;
    size_t size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">address</span></code></dt><dd><p>address of the (first) register to access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request</span></code></dt><dd><p>contains the type of transaction (see DP_AUX_* macros)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reply</span></code></dt><dd><p>upon completion, contains the reply type of the transaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>pointer to a transmission or reception buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>size of <strong>buffer</strong></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_dp_aux_cec">
struct <code class="sig-name descname">drm_dp_aux_cec</code><a class="headerlink" href="#c.drm_dp_aux_cec" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort CEC-Tunneling-over-AUX</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_aux_cec {
    struct mutex lock;
    struct cec_adapter *adap;
    struct drm_connector *connector;
    struct delayed_work unregister_work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>mutex protecting this struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adap</span></code></dt><dd><p>the CEC adapter for CEC-Tunneling-over-AUX support.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p>the connector this CEC adapter is associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unregister_work</span></code></dt><dd><p>unregister the CEC adapter</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_dp_aux">
struct <code class="sig-name descname">drm_dp_aux</code><a class="headerlink" href="#c.drm_dp_aux" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort AUX channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_aux {
    const char *name;
    struct i2c_adapter ddc;
    struct device *dev;
    struct drm_device *drm_dev;
    struct drm_crtc *crtc;
    struct mutex hw_mutex;
    struct work_struct crc_work;
    u8 crc_count;
    ssize_t (*transfer)(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg);
    int (*wait_hpd_asserted)(struct drm_dp_aux *aux, unsigned long wait_us);
    unsigned i2c_nack_count;
    unsigned i2c_defer_count;
    struct drm_dp_aux_cec cec;
    bool is_remote;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>user-visible name of this AUX channel and the
I2C-over-AUX adapter.</p>
<p>It’s also used to specify the name of the I2C adapter. If set
to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, dev_name() of <strong>dev</strong> will be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ddc</span></code></dt><dd><p>I2C adapter that can be used for I2C-over-AUX
communication</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>pointer to <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> that is the parent for this
AUX channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drm_dev</span></code></dt><dd><p>pointer to the <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> that owns this AUX channel.
Beware, this may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> before <a class="reference internal" href="#c.drm_dp_aux_register" title="drm_dp_aux_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_register()</span></code></a> has been
called.</p>
<p>It should be set to the <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> that will be using this AUX
channel as early as possible. For many graphics drivers this should
happen before <a class="reference internal" href="#c.drm_dp_aux_init" title="drm_dp_aux_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_init()</span></code></a>, however it’s perfectly fine to set
this field later so long as it’s assigned before calling
<a class="reference internal" href="#c.drm_dp_aux_register" title="drm_dp_aux_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_register()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>backpointer to the crtc that is currently using this
AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_mutex</span></code></dt><dd><p>internal mutex used for locking transfers.</p>
<p>Note that if the underlying hardware is shared among multiple
channels, the driver needs to do additional locking to
prevent concurrent access.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crc_work</span></code></dt><dd><p>worker that captures CRCs for each frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crc_count</span></code></dt><dd><p>counter of captured frame CRCs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer</span></code></dt><dd><p>transfers a message representing a single AUX
transaction.</p>
<p>This is a hardware-specific implementation of how
transactions are executed that the drivers must provide.</p>
<p>A pointer to a <a class="reference internal" href="#c.drm_dp_aux_msg" title="drm_dp_aux_msg"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_aux_msg</span></code></a> structure describing the
transaction is passed into this function. Upon success, the
implementation should return the number of payload bytes that
were transferred, or a negative error-code on failure.</p>
<p>Helpers will propagate these errors, with the exception of
the <code class="docutils literal notranslate"><span class="pre">-EBUSY</span></code> error, which causes a transaction to be retried.
On a short, helpers will return <code class="docutils literal notranslate"><span class="pre">-EPROTO</span></code> to make it simpler
to check for failure.</p>
<p>The <strong>transfer()</strong> function must only modify the reply field of
the <a class="reference internal" href="#c.drm_dp_aux_msg" title="drm_dp_aux_msg"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_aux_msg</span></code></a> structure. The retry logic and i2c
helpers assume this is the case.</p>
<p>Also note that this callback can be called no matter the
state <strong>dev</strong> is in and also no matter what state the panel is
in. It’s expected:</p>
<ul class="simple">
<li><p>If the <strong>dev</strong> providing the AUX bus is currently unpowered then
it will power itself up for the transfer.</p></li>
<li><p>If we’re on eDP (using a drm_panel) and the panel is not in a
state where it can respond (it’s not powered or it’s in a
low power state) then this function may return an error, but
not crash. It’s up to the caller of this code to make sure that
the panel is powered on if getting an error back is not OK. If a
drm_panel driver is initiating a DP AUX transfer it may power
itself up however it wants. All other code should ensure that
the pre_enable() bridge chain (which eventually calls the
drm_panel prepare function) has powered the panel.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_hpd_asserted</span></code></dt><dd><p>wait for HPD to be asserted</p>
<p>This is mainly useful for eDP panels drivers to wait for an eDP
panel to finish powering on. This is an optional function.</p>
<p>This function will efficiently wait for the HPD signal to be
asserted. The <cite>wait_us</cite> parameter that is passed in says that we
know that the HPD signal is expected to be asserted within <cite>wait_us</cite>
microseconds. This function could wait for longer than <cite>wait_us</cite> if
the logic in the DP controller has a long debouncing time. The
important thing is that if this function returns success that the
DP controller is ready to send AUX transactions.</p>
<p>This function returns 0 if HPD was asserted or -ETIMEDOUT if time
expired and HPD wasn’t asserted. This function should not print
timeout errors to the log.</p>
<p>The semantics of this function are designed to match the
readx_poll_timeout() function. That means a <cite>wait_us</cite> of 0 means
to wait forever. Like readx_poll_timeout(), this function may sleep.</p>
<p>NOTE: this function specifically reports the state of the HPD pin
that’s associated with the DP AUX channel. This is different from
the HPD concept in much of the rest of DRM which is more about
physical presence of a display. For eDP, for instance, a display is
assumed always present even if the HPD pin is deasserted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i2c_nack_count</span></code></dt><dd><p>Counts I2C NACKs, used for DP validation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i2c_defer_count</span></code></dt><dd><p>Counts I2C DEFERs, used for DP validation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cec</span></code></dt><dd><p>struct containing fields used for CEC-Tunneling-over-AUX.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_remote</span></code></dt><dd><p>Is this AUX CH actually using sideband messaging.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>An AUX channel can also be used to transport I2C messages to a sink. A
typical application of that is to access an EDID that’s present in the sink
device. The <strong>transfer()</strong> function can also be used to execute such
transactions. The <a class="reference internal" href="#c.drm_dp_aux_register" title="drm_dp_aux_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_register()</span></code></a> function registers an I2C adapter
that can be passed to <a class="reference internal" href="#c.drm_probe_ddc" title="drm_probe_ddc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_probe_ddc()</span></code></a>. Upon removal, drivers should call
<a class="reference internal" href="#c.drm_dp_aux_unregister" title="drm_dp_aux_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_unregister()</span></code></a> to remove the I2C adapter. The I2C adapter uses long
transfers by default; if a partial response is received, the adapter will
drop down to the size given by the partial response for this transaction
only.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_readb">
ssize_t <code class="sig-name descname">drm_dp_dpcd_readb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, unsigned int<em> offset</em>, u8<em> *valuep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_readb" title="Permalink to this definition">¶</a></dt>
<dd><p>read a single byte from the DPCD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>address of the register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*valuep</span></code></dt><dd><p>location where the value of the register will be stored</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred (1) on success, or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dpcd_writeb">
ssize_t <code class="sig-name descname">drm_dp_dpcd_writeb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, unsigned int<em> offset</em>, u8<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_writeb" title="Permalink to this definition">¶</a></dt>
<dd><p>write a single byte to the DPCD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>address of the register to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">value</span></code></dt><dd><p>value to write to the register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred (1) on success, or a negative
error code on failure.</p>
</div>
<dl class="type">
<dt id="c.drm_dp_desc">
struct <code class="sig-name descname">drm_dp_desc</code><a class="headerlink" href="#c.drm_dp_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>DP branch/sink device descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_desc {
    struct drm_dp_dpcd_ident ident;
    u32 quirks;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ident</span></code></dt><dd><p>DP device identification from DPCD 0x400 (sink) or 0x500 (branch).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quirks</span></code></dt><dd><p>Quirks; use <a class="reference internal" href="#c.drm_dp_has_quirk" title="drm_dp_has_quirk"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_has_quirk()</span></code></a> to query for the quirks.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_dp_quirk">
enum <code class="sig-name descname">drm_dp_quirk</code><a class="headerlink" href="#c.drm_dp_quirk" title="Permalink to this definition">¶</a></dt>
<dd><p>Display Port sink/branch device specific quirks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DP_DPCD_QUIRK_CONSTANT_N</span></code></dt><dd><p>The device requires main link attributes Mvid and Nvid to be limited
to 16 bits. So will give a constant value (0x8000) for compatability.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_DPCD_QUIRK_NO_PSR</span></code></dt><dd><p>The device does not support PSR even if reports that it supports or
driver still need to implement proper handling for such device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_DPCD_QUIRK_NO_SINK_COUNT</span></code></dt><dd><p>The device does not set SINK_COUNT to a non-zero value.
The driver should ignore SINK_COUNT during detection. Note that
<a class="reference internal" href="#c.drm_dp_read_sink_count_cap" title="drm_dp_read_sink_count_cap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_read_sink_count_cap()</span></code></a> automatically checks for this quirk.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD</span></code></dt><dd><p>The device supports MST DSC despite not supporting Virtual DPCD.
The DSC caps can be read from the physical aux instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS</span></code></dt><dd><p>The device supports a link rate of 3.24 Gbps (multiplier 0xc) despite
the DP_MAX_LINK_RATE register reporting a lower max multiplier.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Display Port sink and branch devices in the wild have a variety of bugs, try
to collect them here. The quirks are shared, but it’s up to the drivers to
implement workarounds for them.</p>
<dl class="function">
<dt id="c.drm_dp_has_quirk">
bool <code class="sig-name descname">drm_dp_has_quirk</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_dp_desc" title="drm_dp_desc">drm_dp_desc</a><em> *desc</em>, enum <a class="reference internal" href="#c.drm_dp_quirk" title="drm_dp_quirk">drm_dp_quirk</a><em> quirk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_has_quirk" title="Permalink to this definition">¶</a></dt>
<dd><p>does the DP device have a specific quirk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_dp_desc</span> <span class="pre">*desc</span></code></dt><dd><p>Device descriptor filled by <a class="reference internal" href="#c.drm_dp_read_desc" title="drm_dp_read_desc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_read_desc()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_quirk</span> <span class="pre">quirk</span></code></dt><dd><p>Quirk to query for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if DP device identified by <strong>desc</strong> has <strong>quirk</strong>.</p>
</div>
<dl class="type">
<dt id="c.drm_edp_backlight_info">
struct <code class="sig-name descname">drm_edp_backlight_info</code><a class="headerlink" href="#c.drm_edp_backlight_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Probed eDP backlight info struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_edp_backlight_info {
    u8 pwmgen_bit_count;
    u8 pwm_freq_pre_divider;
    u16 max;
    bool lsb_reg_used : 1;
    bool aux_enable : 1;
    bool aux_set : 1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pwmgen_bit_count</span></code></dt><dd><p>The pwmgen bit count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pwm_freq_pre_divider</span></code></dt><dd><p>The PWM frequency pre-divider value being used for this backlight, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max</span></code></dt><dd><p>The maximum backlight level that may be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lsb_reg_used</span></code></dt><dd><p>Do we also write values to the DP_EDP_BACKLIGHT_BRIGHTNESS_LSB register?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aux_enable</span></code></dt><dd><p>Does the panel support the AUX enable cap?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aux_set</span></code></dt><dd><p>Does the panel support setting the brightness through AUX?</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure contains various data about an eDP backlight, which can be populated by using
<a class="reference internal" href="#c.drm_edp_backlight_init" title="drm_edp_backlight_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edp_backlight_init()</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_dp_phy_test_params">
struct <code class="sig-name descname">drm_dp_phy_test_params</code><a class="headerlink" href="#c.drm_dp_phy_test_params" title="Permalink to this definition">¶</a></dt>
<dd><p>DP Phy Compliance parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_phy_test_params {
    int link_rate;
    u8 num_lanes;
    u8 phy_pattern;
    u8 hbr2_reset[2];
    u8 custom80[10];
    bool enhanced_frame_cap;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">link_rate</span></code></dt><dd><p>Requested Link rate from DPCD 0x219</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_lanes</span></code></dt><dd><p>Number of lanes requested by sing through DPCD 0x220</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_pattern</span></code></dt><dd><p>DP Phy test pattern from DPCD 0x248</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hbr2_reset</span></code></dt><dd><p>DP HBR2_COMPLIANCE_SCRAMBLER_RESET from DCPD 0x24A and 0x24B</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">custom80</span></code></dt><dd><p>DP Test_80BIT_CUSTOM_PATTERN from DPCDs 0x250 through 0x259</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enhanced_frame_cap</span></code></dt><dd><p>flag for enhanced frame capability.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_dp_phy_name">
const char * <code class="sig-name descname">drm_dp_phy_name</code><span class="sig-paren">(</span>enum drm_dp_phy<em> dp_phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_phy_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of the given DP PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_phy</span> <span class="pre">dp_phy</span></code></dt><dd><p>The DP PHY identifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given the <strong>dp_phy</strong>, get a user friendly name of the DP PHY, either “DPRX” or
“LTTPR &lt;N&gt;”, or “&lt;INVALID DP PHY&gt;” on errors. The returned string is always
non-NULL and valid.</p>
<p><strong>Return</strong></p>
<p>Name of the DP PHY.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dpcd_probe">
int <code class="sig-name descname">drm_dp_dpcd_probe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>probe a given DPCD address with a 1-byte read access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel (SST)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>address of the register to probe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Probe the provided DPCD address by reading 1 byte from it. The function can
be used to trigger some side-effect the read access has, like waking up the
sink, without the need for the read-out value.</p>
<p>Returns 0 if the read access suceeded, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dpcd_read">
ssize_t <code class="sig-name descname">drm_dp_dpcd_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, unsigned int<em> offset</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read a series of bytes from the DPCD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel (SST or MST)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>address of the (first) register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>buffer to store the register values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>number of bytes in <strong>buffer</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred on success, or a negative error
code on failure. -EIO is returned if the request was NAKed by the sink or
if the retry count was exceeded. If not all bytes were transferred, this
function returns -EPROTO. Errors from the underlying AUX channel transfer
function, with the exception of -EBUSY (which causes the transaction to
be retried), are propagated to the caller.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dpcd_write">
ssize_t <code class="sig-name descname">drm_dp_dpcd_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, unsigned int<em> offset</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a series of bytes to the DPCD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel (SST or MST)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>address of the (first) register to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>buffer containing the values to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>number of bytes in <strong>buffer</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred on success, or a negative error
code on failure. -EIO is returned if the request was NAKed by the sink or
if the retry count was exceeded. If not all bytes were transferred, this
function returns -EPROTO. Errors from the underlying AUX channel transfer
function, with the exception of -EBUSY (which causes the transaction to
be retried), are propagated to the caller.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dpcd_read_link_status">
int <code class="sig-name descname">drm_dp_dpcd_read_link_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, u8<em> status[DP_LINK_STATUS_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_read_link_status" title="Permalink to this definition">¶</a></dt>
<dd><p>read DPCD link status (bytes 0x202-0x207)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">status[DP_LINK_STATUS_SIZE]</span></code></dt><dd><p>buffer to store the link status in (must be at least 6 bytes)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred on success or a negative error
code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dpcd_read_phy_link_status">
int <code class="sig-name descname">drm_dp_dpcd_read_phy_link_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, enum drm_dp_phy<em> dp_phy</em>, u8<em> link_status[DP_LINK_STATUS_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_read_phy_link_status" title="Permalink to this definition">¶</a></dt>
<dd><p>get the link status information for a DP PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_phy</span> <span class="pre">dp_phy</span></code></dt><dd><p>the DP PHY to get the link status for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">link_status[DP_LINK_STATUS_SIZE]</span></code></dt><dd><p>buffer to return the status in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fetch the AUX DPCD registers for the DPRX or an LTTPR PHY link status. The
layout of the returned <strong>link_status</strong> matches the DPCD register layout of the
DPRX PHY link status.</p>
<p>Returns 0 if the information was read successfully or a negative error code
on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_is_type">
bool <code class="sig-name descname">drm_dp_downstream_is_type</code><span class="sig-paren">(</span>const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em>, u8<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_is_type" title="Permalink to this definition">¶</a></dt>
<dd><p>is the downstream facing port of certain type?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>port capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">type</span></code></dt><dd><p>port type to be checked. Can be:
<code class="docutils literal notranslate"><span class="pre">DP_DS_PORT_TYPE_DP</span></code>, <code class="docutils literal notranslate"><span class="pre">DP_DS_PORT_TYPE_VGA</span></code>, <code class="docutils literal notranslate"><span class="pre">DP_DS_PORT_TYPE_DVI</span></code>,
<code class="docutils literal notranslate"><span class="pre">DP_DS_PORT_TYPE_HDMI</span></code>, <code class="docutils literal notranslate"><span class="pre">DP_DS_PORT_TYPE_NON_EDID</span></code>,
<code class="docutils literal notranslate"><span class="pre">DP_DS_PORT_TYPE_DP_DUALMODE</span></code> or <code class="docutils literal notranslate"><span class="pre">DP_DS_PORT_TYPE_WIRELESS</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caveat: Only works with DPCD 1.1+ port caps.</p>
<p><strong>Return</strong></p>
<p>whether the downstream facing port matches the type.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_is_tmds">
bool <code class="sig-name descname">drm_dp_downstream_is_tmds</code><span class="sig-paren">(</span>const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em>, const struct edid<em> *edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_is_tmds" title="Permalink to this definition">¶</a></dt>
<dd><p>is the downstream facing port TMDS?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>port capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>EDID</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>whether the downstream facing port is TMDS (HDMI/DVI).</p>
</div>
<dl class="function">
<dt id="c.drm_dp_send_real_edid_checksum">
bool <code class="sig-name descname">drm_dp_send_real_edid_checksum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, u8<em> real_edid_checksum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_send_real_edid_checksum" title="Permalink to this definition">¶</a></dt>
<dd><p>send back real edid checksum value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">real_edid_checksum</span></code></dt><dd><p>real edid checksum for the last block</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True on success</p>
</div>
<dl class="function">
<dt id="c.drm_dp_read_dpcd_caps">
int <code class="sig-name descname">drm_dp_read_dpcd_caps</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_read_dpcd_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>read DPCD caps and extended DPCD caps if available</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>Buffer to store the resulting DPCD in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempts to read the base DPCD caps for <strong>aux</strong>. Additionally, this function
checks for and reads the extended DPRX caps (<code class="docutils literal notranslate"><span class="pre">DP_DP13_DPCD_REV</span></code>) if
present.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> if the DPCD was read successfully, negative error code
otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_read_downstream_info">
int <code class="sig-name descname">drm_dp_read_downstream_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, u8<em> downstream_ports[DP_MAX_DOWNSTREAM_PORTS]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_read_downstream_info" title="Permalink to this definition">¶</a></dt>
<dd><p>read DPCD downstream port info if available</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>A cached copy of the port’s DPCD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">downstream_ports[DP_MAX_DOWNSTREAM_PORTS]</span></code></dt><dd><p>buffer to store the downstream port info in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See also:
drm_dp_downstream_max_clock()
<a class="reference internal" href="#c.drm_dp_downstream_max_bpc" title="drm_dp_downstream_max_bpc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_downstream_max_bpc()</span></code></a></p>
<p><strong>Return</strong></p>
<p>0 if either the downstream port info was read successfully or
there was no downstream info to read, or a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_max_dotclock">
int <code class="sig-name descname">drm_dp_downstream_max_dotclock</code><span class="sig-paren">(</span>const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_max_dotclock" title="Permalink to this definition">¶</a></dt>
<dd><p>extract downstream facing port max dot clock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>port capabilities</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Downstream facing port max dot clock in kHz on success,
or 0 if max clock not defined</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_max_tmds_clock">
int <code class="sig-name descname">drm_dp_downstream_max_tmds_clock</code><span class="sig-paren">(</span>const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em>, const struct edid<em> *edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_max_tmds_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>extract downstream facing port max TMDS clock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>port capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>EDID</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>HDMI/DVI downstream facing port max TMDS clock in kHz on success,
or 0 if max TMDS clock not defined</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_min_tmds_clock">
int <code class="sig-name descname">drm_dp_downstream_min_tmds_clock</code><span class="sig-paren">(</span>const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em>, const struct edid<em> *edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_min_tmds_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>extract downstream facing port min TMDS clock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>port capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>EDID</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>HDMI/DVI downstream facing port min TMDS clock in kHz on success,
or 0 if max TMDS clock not defined</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_max_bpc">
int <code class="sig-name descname">drm_dp_downstream_max_bpc</code><span class="sig-paren">(</span>const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em>, const struct edid<em> *edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_max_bpc" title="Permalink to this definition">¶</a></dt>
<dd><p>extract downstream facing port max bits per component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>downstream facing port capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>EDID</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Max bpc on success or 0 if max bpc not defined</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_420_passthrough">
bool <code class="sig-name descname">drm_dp_downstream_420_passthrough</code><span class="sig-paren">(</span>const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_420_passthrough" title="Permalink to this definition">¶</a></dt>
<dd><p>determine downstream facing port YCbCr 4:2:0 pass-through capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>downstream facing port capabilities</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>whether the downstream facing port can pass through YCbCr 4:2:0</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_444_to_420_conversion">
bool <code class="sig-name descname">drm_dp_downstream_444_to_420_conversion</code><span class="sig-paren">(</span>const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_444_to_420_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>determine downstream facing port YCbCr 4:4:4-&gt;4:2:0 conversion capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>downstream facing port capabilities</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>whether the downstream facing port can convert YCbCr 4:4:4 to 4:2:0</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_rgb_to_ycbcr_conversion">
bool <code class="sig-name descname">drm_dp_downstream_rgb_to_ycbcr_conversion</code><span class="sig-paren">(</span>const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em>, u8<em> color_spc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_rgb_to_ycbcr_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>determine downstream facing port RGB-&gt;YCbCr conversion capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>downstream facing port capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">color_spc</span></code></dt><dd><p>Colorspace for which conversion cap is sought</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>whether the downstream facing port can convert RGB-&gt;YCbCr for a given
colorspace.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_mode">
struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="sig-name descname">drm_dp_downstream_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>return a mode for downstream facing port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>port capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a suitable mode for downstream facing ports without EDID.</p>
<p><strong>Return</strong></p>
<p>A new drm_display_mode on success or NULL on failure</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_id">
int <code class="sig-name descname">drm_dp_downstream_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, char<em> id[6]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_id" title="Permalink to this definition">¶</a></dt>
<dd><p>identify branch device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">id[6]</span></code></dt><dd><p>DisplayPort branch device id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns branch device id on success or NULL on failure</p>
</div>
<dl class="function">
<dt id="c.drm_dp_downstream_debug">
void <code class="sig-name descname">drm_dp_downstream_debug</code><span class="sig-paren">(</span>struct seq_file<em> *m</em>, const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em>, const struct edid<em> *edid</em>, struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_downstream_debug" title="Permalink to this definition">¶</a></dt>
<dd><p>debug DP branch devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m</span></code></dt><dd><p>pointer for debugfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>port capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>EDID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_dp_subconnector_type">
enum drm_mode_subconnector <code class="sig-name descname">drm_dp_subconnector_type</code><span class="sig-paren">(</span>const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_subconnector_type" title="Permalink to this definition">¶</a></dt>
<dd><p>get DP branch device type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>port capabilities</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_dp_set_subconnector_property">
void <code class="sig-name descname">drm_dp_set_subconnector_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, enum <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status">drm_connector_status</a><em> status</em>, const u8<em> *dpcd</em>, const u8<em> port_cap[4]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_set_subconnector_property" title="Permalink to this definition">¶</a></dt>
<dd><p>set subconnector for DP connector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to set property on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_connector_status</span> <span class="pre">status</span></code></dt><dd><p>connector status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*dpcd</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>port capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver on every detect event.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_read_sink_count_cap">
bool <code class="sig-name descname">drm_dp_read_sink_count_cap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const struct <a class="reference internal" href="#c.drm_dp_desc" title="drm_dp_desc">drm_dp_desc</a><em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_read_sink_count_cap" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a given connector has a valid sink count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>The DRM connector to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>A cached copy of the connector’s DPCD RX capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_dp_desc</span> <span class="pre">*desc</span></code></dt><dd><p>A cached copy of the connector’s DP descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See also: <a class="reference internal" href="#c.drm_dp_read_sink_count" title="drm_dp_read_sink_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_read_sink_count()</span></code></a></p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the (e)DP connector has a valid sink count that should
be probed, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_read_sink_count">
int <code class="sig-name descname">drm_dp_read_sink_count</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_read_sink_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the sink count for a given sink</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>The DP AUX channel to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See also: <a class="reference internal" href="#c.drm_dp_read_sink_count_cap" title="drm_dp_read_sink_count_cap"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_read_sink_count_cap()</span></code></a></p>
<p><strong>Return</strong></p>
<p>The current sink count reported by <strong>aux</strong>, or a negative error code
otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_remote_aux_init">
void <code class="sig-name descname">drm_dp_remote_aux_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_remote_aux_init" title="Permalink to this definition">¶</a></dt>
<dd><p>minimally initialise a remote aux channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used for remote aux channel in general. Merely initialize the crc work
struct.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_aux_init">
void <code class="sig-name descname">drm_dp_aux_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_aux_init" title="Permalink to this definition">¶</a></dt>
<dd><p>minimally initialise an aux channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you need to use the drm_dp_aux’s i2c adapter prior to registering it with
the outside world, call <a class="reference internal" href="#c.drm_dp_aux_init" title="drm_dp_aux_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_init()</span></code></a> first. For drivers which are
grandparents to their AUX adapters (e.g. the AUX adapter is parented by a
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a>), you must still call <a class="reference internal" href="#c.drm_dp_aux_register" title="drm_dp_aux_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_register()</span></code></a> once the connector
has been registered to allow userspace access to the auxiliary DP channel.
Likewise, for such drivers you should also assign <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_aux.drm_dev</span></code></a> as
early as possible so that the <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> that corresponds to the AUX adapter
may be mentioned in debugging output from the DRM DP helpers.</p>
<p>For devices which use a separate platform device for their AUX adapters, this
may be called as early as required by the driver.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_aux_register">
int <code class="sig-name descname">drm_dp_aux_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_aux_register" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise and register aux channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Automatically calls <a class="reference internal" href="#c.drm_dp_aux_init" title="drm_dp_aux_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_init()</span></code></a> if this hasn’t been done yet. This
should only be called once the parent of <strong>aux</strong>, <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_aux.dev</span></code></a>, is
initialized. For devices which are grandparents of their AUX channels,
<a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_aux.dev</span></code></a> will typically be the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a> which
corresponds to <strong>aux</strong>. For these devices, it’s advised to call
<a class="reference internal" href="#c.drm_dp_aux_register" title="drm_dp_aux_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_register()</span></code></a> in <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.late_register</span></code></a>, and likewise to
call <a class="reference internal" href="#c.drm_dp_aux_unregister" title="drm_dp_aux_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_unregister()</span></code></a> in <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.early_unregister</span></code></a>.
Functions which don’t follow this will likely Oops when
<code class="docutils literal notranslate"><span class="pre">CONFIG_DRM_DP_AUX_CHARDEV</span></code> is enabled.</p>
<p>For devices where the AUX channel is a device that exists independently of
the <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> that uses it, such as SoCs and bridge devices, it is
recommended to call <a class="reference internal" href="#c.drm_dp_aux_register" title="drm_dp_aux_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_register()</span></code></a> after a <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> has been
assigned to <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_aux.drm_dev</span></code></a>, and likewise to call
<a class="reference internal" href="#c.drm_dp_aux_unregister" title="drm_dp_aux_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_unregister()</span></code></a> once the <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> should no longer be associated
with the AUX channel (e.g. on bridge detach).</p>
<p>Drivers which need to use the aux channel before either of the two points
mentioned above need to call <a class="reference internal" href="#c.drm_dp_aux_init" title="drm_dp_aux_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_aux_init()</span></code></a> in order to use the AUX
channel before registration.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_aux_unregister">
void <code class="sig-name descname">drm_dp_aux_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_aux_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an AUX adapter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_dp_psr_setup_time">
int <code class="sig-name descname">drm_dp_psr_setup_time</code><span class="sig-paren">(</span>const u8<em> psr_cap[EDP_PSR_RECEIVER_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_psr_setup_time" title="Permalink to this definition">¶</a></dt>
<dd><p>PSR setup in time usec</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">psr_cap[EDP_PSR_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>PSR capabilities from DPCD</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>PSR setup time for the panel in microseconds,  negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_start_crc">
int <code class="sig-name descname">drm_dp_start_crc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_start_crc" title="Permalink to this definition">¶</a></dt>
<dd><p>start capture of frame CRCs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC displaying the frames whose CRCs are to be captured</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_stop_crc">
int <code class="sig-name descname">drm_dp_stop_crc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_stop_crc" title="Permalink to this definition">¶</a></dt>
<dd><p>stop capture of frame CRCs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_read_desc">
int <code class="sig-name descname">drm_dp_read_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, struct <a class="reference internal" href="#c.drm_dp_desc" title="drm_dp_desc">drm_dp_desc</a><em> *desc</em>, bool<em> is_branch</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_read_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>read sink/branch descriptor from DPCD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_desc</span> <span class="pre">*desc</span></code></dt><dd><p>Device descriptor to fill from DPCD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_branch</span></code></dt><dd><p>true for branch devices, false for sink devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read DPCD 0x400 (sink) or 0x500 (branch) into <strong>desc</strong>. Also debug log the
identification.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dsc_sink_max_slice_count">
u8 <code class="sig-name descname">drm_dp_dsc_sink_max_slice_count</code><span class="sig-paren">(</span>const u8<em> dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE]</em>, bool<em> is_edp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dsc_sink_max_slice_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the max slice count supported by the DSC sink.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DSC capabilities from DPCD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_edp</span></code></dt><dd><p>true if its eDP, false for DP</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the slice capabilities DPCD register from DSC sink to get
the maximum slice count supported. This is used to populate
the DSC parameters in the <a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span></code></a> by the driver.
Driver creates an infoframe using these parameters to populate
<a class="reference internal" href="#c.drm_dsc_pps_infoframe" title="drm_dsc_pps_infoframe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_pps_infoframe</span></code></a>. These are sent to the sink using DSC
infoframe using the helper function drm_dsc_pps_infoframe_pack()</p>
<p><strong>Return</strong></p>
<p>Maximum slice count supported by DSC sink or 0 its invalid</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dsc_sink_line_buf_depth">
u8 <code class="sig-name descname">drm_dp_dsc_sink_line_buf_depth</code><span class="sig-paren">(</span>const u8<em> dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dsc_sink_line_buf_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the line buffer depth in bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DSC capabilities from DPCD</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the DSC DPCD register to parse the line buffer depth in bits which is
number of bits of precision within the decoder line buffer supported by
the DSC sink. This is used to populate the DSC parameters in the
<a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span></code></a> by the driver.
Driver creates an infoframe using these parameters to populate
<a class="reference internal" href="#c.drm_dsc_pps_infoframe" title="drm_dsc_pps_infoframe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_pps_infoframe</span></code></a>. These are sent to the sink using DSC
infoframe using the helper function drm_dsc_pps_infoframe_pack()</p>
<p><strong>Return</strong></p>
<p>Line buffer depth supported by DSC panel or 0 its invalid</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dsc_sink_supported_input_bpcs">
int <code class="sig-name descname">drm_dp_dsc_sink_supported_input_bpcs</code><span class="sig-paren">(</span>const u8<em> dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE]</em>, u8<em> dsc_bpc[3]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dsc_sink_supported_input_bpcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the input bits per component values supported by the DSC sink.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DSC capabilities from DPCD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">dsc_bpc[3]</span></code></dt><dd><p>An array to be filled by this helper with supported
input bpcs.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the DSC DPCD from the sink device to parse the supported bits per
component values. This is used to populate the DSC parameters
in the <a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span></code></a> by the driver.
Driver creates an infoframe using these parameters to populate
<a class="reference internal" href="#c.drm_dsc_pps_infoframe" title="drm_dsc_pps_infoframe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_pps_infoframe</span></code></a>. These are sent to the sink using DSC
infoframe using the helper function drm_dsc_pps_infoframe_pack()</p>
<p><strong>Return</strong></p>
<p>Number of input BPC values parsed from the DPCD</p>
</div>
<dl class="function">
<dt id="c.drm_dp_read_lttpr_common_caps">
int <code class="sig-name descname">drm_dp_read_lttpr_common_caps</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, u8<em> caps[DP_LTTPR_COMMON_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_read_lttpr_common_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>read the LTTPR common capabilities</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">caps[DP_LTTPR_COMMON_CAP_SIZE]</span></code></dt><dd><p>buffer to return the capability info in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read capabilities common to all LTTPRs.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_read_lttpr_phy_caps">
int <code class="sig-name descname">drm_dp_read_lttpr_phy_caps</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, enum drm_dp_phy<em> dp_phy</em>, u8<em> caps[DP_LTTPR_PHY_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_read_lttpr_phy_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>read the capabilities for a given LTTPR PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_phy</span> <span class="pre">dp_phy</span></code></dt><dd><p>LTTPR PHY to read the capabilities for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">caps[DP_LTTPR_PHY_CAP_SIZE]</span></code></dt><dd><p>buffer to return the capability info in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the capabilities for the given LTTPR PHY.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_lttpr_count">
int <code class="sig-name descname">drm_dp_lttpr_count</code><span class="sig-paren">(</span>const u8<em> caps[DP_LTTPR_COMMON_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_lttpr_count" title="Permalink to this definition">¶</a></dt>
<dd><p>get the number of detected LTTPRs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">caps[DP_LTTPR_COMMON_CAP_SIZE]</span></code></dt><dd><p>LTTPR common capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the number of detected LTTPRs from the LTTPR common capabilities info.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>-ERANGE if more than supported number (8) of LTTPRs are detected
-EINVAL if the DP_PHY_REPEATER_CNT register contains an invalid value
otherwise the number of detected LTTPRs</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.drm_dp_lttpr_max_link_rate">
int <code class="sig-name descname">drm_dp_lttpr_max_link_rate</code><span class="sig-paren">(</span>const u8<em> caps[DP_LTTPR_COMMON_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_lttpr_max_link_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>get the maximum link rate supported by all LTTPRs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">caps[DP_LTTPR_COMMON_CAP_SIZE]</span></code></dt><dd><p>LTTPR common capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the maximum link rate supported by all detected LTTPRs.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_lttpr_max_lane_count">
int <code class="sig-name descname">drm_dp_lttpr_max_lane_count</code><span class="sig-paren">(</span>const u8<em> caps[DP_LTTPR_COMMON_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_lttpr_max_lane_count" title="Permalink to this definition">¶</a></dt>
<dd><p>get the maximum lane count supported by all LTTPRs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">caps[DP_LTTPR_COMMON_CAP_SIZE]</span></code></dt><dd><p>LTTPR common capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the maximum lane count supported by all detected LTTPRs.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_lttpr_voltage_swing_level_3_supported">
bool <code class="sig-name descname">drm_dp_lttpr_voltage_swing_level_3_supported</code><span class="sig-paren">(</span>const u8<em> caps[DP_LTTPR_PHY_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_lttpr_voltage_swing_level_3_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>check for LTTPR vswing3 support</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">caps[DP_LTTPR_PHY_CAP_SIZE]</span></code></dt><dd><p>LTTPR PHY capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the <strong>caps</strong> for an LTTPR TX PHY indicate support for
voltage swing level 3.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_lttpr_pre_emphasis_level_3_supported">
bool <code class="sig-name descname">drm_dp_lttpr_pre_emphasis_level_3_supported</code><span class="sig-paren">(</span>const u8<em> caps[DP_LTTPR_PHY_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_lttpr_pre_emphasis_level_3_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>check for LTTPR preemph3 support</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">caps[DP_LTTPR_PHY_CAP_SIZE]</span></code></dt><dd><p>LTTPR PHY capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the <strong>caps</strong> for an LTTPR TX PHY indicate support for
pre-emphasis level 3.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_get_phy_test_pattern">
int <code class="sig-name descname">drm_dp_get_phy_test_pattern</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, struct <a class="reference internal" href="#c.drm_dp_phy_test_params" title="drm_dp_phy_test_params">drm_dp_phy_test_params</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_get_phy_test_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>get the requested pattern from the sink.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_phy_test_params</span> <span class="pre">*data</span></code></dt><dd><p>DP phy compliance test parameters.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_set_phy_test_pattern">
int <code class="sig-name descname">drm_dp_set_phy_test_pattern</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, struct <a class="reference internal" href="#c.drm_dp_phy_test_params" title="drm_dp_phy_test_params">drm_dp_phy_test_params</a><em> *data</em>, u8<em> dp_rev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_set_phy_test_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>set the pattern to the sink.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_phy_test_params</span> <span class="pre">*data</span></code></dt><dd><p>DP phy compliance test parameters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">dp_rev</span></code></dt><dd><p>DP revision to use for compliance testing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_get_pcon_max_frl_bw">
int <code class="sig-name descname">drm_dp_get_pcon_max_frl_bw</code><span class="sig-paren">(</span>const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em>, const u8<em> port_cap[4]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_get_pcon_max_frl_bw" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum frl supported by PCON</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>DisplayPort configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">port_cap[4]</span></code></dt><dd><p>port capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns maximum frl bandwidth supported by PCON in GBPS,
returns 0 if not supported.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_pcon_frl_prepare">
int <code class="sig-name descname">drm_dp_pcon_frl_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, bool<em> enable_frl_ready_hpd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_pcon_frl_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare PCON for FRL.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable_frl_ready_hpd</span></code></dt><dd><p>Configure DP_PCON_ENABLE_HPD_READY.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 if success, else returns negative error code.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_pcon_is_frl_ready">
bool <code class="sig-name descname">drm_dp_pcon_is_frl_ready</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_pcon_is_frl_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>Is PCON ready for FRL</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if success, else returns false.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_pcon_frl_configure_1">
int <code class="sig-name descname">drm_dp_pcon_frl_configure_1</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, int<em> max_frl_gbps</em>, u8<em> frl_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_pcon_frl_configure_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Set HDMI LINK Configuration-Step1</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_frl_gbps</span></code></dt><dd><p>maximum frl bw to be configured between PCON and HDMI sink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">frl_mode</span></code></dt><dd><p>FRL Training mode, it can be either Concurrent or Sequential.
In Concurrent Mode, the FRL link bring up can be done along with
DP Link training. In Sequential mode, the FRL link bring up is done prior to
the DP Link training.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 if success, else returns negative error code.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_pcon_frl_configure_2">
int <code class="sig-name descname">drm_dp_pcon_frl_configure_2</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, int<em> max_frl_mask</em>, u8<em> frl_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_pcon_frl_configure_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Set HDMI Link configuration Step-2</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_frl_mask</span></code></dt><dd><p>Max FRL BW to be tried by the PCON with HDMI Sink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">frl_type</span></code></dt><dd><p>FRL training type, can be Extended, or Normal.
In Normal FRL training, the PCON tries each frl bw from the max_frl_mask
starting from min, and stops when link training is successful. In Extended
FRL training, all frl bw selected in the mask are trained by the PCON.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 if success, else returns negative error code.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_pcon_reset_frl_config">
int <code class="sig-name descname">drm_dp_pcon_reset_frl_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_pcon_reset_frl_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-Set HDMI Link configuration.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 if success, else returns negative error code.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_pcon_frl_enable">
int <code class="sig-name descname">drm_dp_pcon_frl_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_pcon_frl_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable HDMI link through FRL</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 if success, else returns negative error code.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_pcon_hdmi_link_active">
bool <code class="sig-name descname">drm_dp_pcon_hdmi_link_active</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_pcon_hdmi_link_active" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the PCON HDMI LINK status is active.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if link is active else returns false.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_pcon_hdmi_link_mode">
int <code class="sig-name descname">drm_dp_pcon_hdmi_link_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, u8<em> *frl_trained_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_pcon_hdmi_link_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>get the PCON HDMI LINK MODE</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*frl_trained_mask</span></code></dt><dd><p>pointer to store bitmask of the trained bw configuration.
Valid only if the MODE returned is FRL. For Normal Link training mode
only 1 of the bits will be set, but in case of Extended mode, more than
one bits can be set.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the link mode : TMDS or FRL on success, else returns negative error
code.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_pcon_hdmi_frl_link_error_count">
void <code class="sig-name descname">drm_dp_pcon_hdmi_frl_link_error_count</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_pcon_hdmi_frl_link_error_count" title="Permalink to this definition">¶</a></dt>
<dd><p>print the error count per lane during link failure between PCON and HDMI sink</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>DRM connector
code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_dp_pcon_pps_default">
int <code class="sig-name descname">drm_dp_pcon_pps_default</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_pcon_pps_default" title="Permalink to this definition">¶</a></dt>
<dd><p>Let PCON fill the default pps parameters for DSC1.2 between PCON &amp; HDMI2.1 sink</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, else returns negative error code.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_pcon_pps_override_buf">
int <code class="sig-name descname">drm_dp_pcon_pps_override_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, u8<em> pps_buf[128]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_pcon_pps_override_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure PPS encoder override buffer for HDMI sink</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">pps_buf[128]</span></code></dt><dd><p>128 bytes to be written into PPS buffer for HDMI sink by PCON.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, else returns negative error code.</p>
</div>
<dl class="function">
<dt id="c.drm_edp_backlight_set_level">
int <code class="sig-name descname">drm_edp_backlight_set_level</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, const struct <a class="reference internal" href="#c.drm_edp_backlight_info" title="drm_edp_backlight_info">drm_edp_backlight_info</a><em> *bl</em>, u16<em> level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edp_backlight_set_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the backlight level of an eDP panel via AUX</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>The DP AUX channel to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_edp_backlight_info</span> <span class="pre">*bl</span></code></dt><dd><p>Backlight capability info from <a class="reference internal" href="#c.drm_edp_backlight_init" title="drm_edp_backlight_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edp_backlight_init()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">level</span></code></dt><dd><p>The brightness level to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the brightness level of an eDP panel’s backlight. Note that the panel’s backlight must
already have been enabled by the driver by calling <a class="reference internal" href="#c.drm_edp_backlight_enable" title="drm_edp_backlight_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edp_backlight_enable()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_edp_backlight_enable">
int <code class="sig-name descname">drm_edp_backlight_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, const struct <a class="reference internal" href="#c.drm_edp_backlight_info" title="drm_edp_backlight_info">drm_edp_backlight_info</a><em> *bl</em>, const u16<em> level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edp_backlight_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable an eDP panel’s backlight using DPCD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>The DP AUX channel to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_edp_backlight_info</span> <span class="pre">*bl</span></code></dt><dd><p>Backlight capability info from <a class="reference internal" href="#c.drm_edp_backlight_init" title="drm_edp_backlight_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edp_backlight_init()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">level</span></code></dt><dd><p>The initial backlight level to set via AUX, if there is one</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles enabling DPCD backlight controls on a panel over DPCD, while additionally
restoring any important backlight state such as the given backlight level, the brightness byte
count, backlight frequency, etc.</p>
<p>Note that certain panels do not support being enabled or disabled via DPCD, but instead require
that the driver handle enabling/disabling the panel through implementation-specific means using
the EDP_BL_PWR GPIO. For such panels, <a class="reference internal" href="#c.drm_edp_backlight_info" title="drm_edp_backlight_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_edp_backlight_info.aux_enable</span></code></a> will be set to <code class="docutils literal notranslate"><span class="pre">false</span></code>,
this function becomes a no-op, and the driver is expected to handle powering the panel on using
the EDP_BL_PWR GPIO.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_edp_backlight_disable">
int <code class="sig-name descname">drm_edp_backlight_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, const struct <a class="reference internal" href="#c.drm_edp_backlight_info" title="drm_edp_backlight_info">drm_edp_backlight_info</a><em> *bl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edp_backlight_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable an eDP backlight using DPCD, if supported</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>The DP AUX channel to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_edp_backlight_info</span> <span class="pre">*bl</span></code></dt><dd><p>Backlight capability info from <a class="reference internal" href="#c.drm_edp_backlight_init" title="drm_edp_backlight_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edp_backlight_init()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles disabling DPCD backlight controls on a panel over AUX.</p>
<p>Note that certain panels do not support being enabled or disabled via DPCD, but instead require
that the driver handle enabling/disabling the panel through implementation-specific means using
the EDP_BL_PWR GPIO. For such panels, <a class="reference internal" href="#c.drm_edp_backlight_info" title="drm_edp_backlight_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_edp_backlight_info.aux_enable</span></code></a> will be set to <code class="docutils literal notranslate"><span class="pre">false</span></code>,
this function becomes a no-op, and the driver is expected to handle powering the panel off using
the EDP_BL_PWR GPIO.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success or no-op, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_edp_backlight_init">
int <code class="sig-name descname">drm_edp_backlight_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, struct <a class="reference internal" href="#c.drm_edp_backlight_info" title="drm_edp_backlight_info">drm_edp_backlight_info</a><em> *bl</em>, u16<em> driver_pwm_freq_hz</em>, const u8<em> edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE]</em>, u16<em> *current_level</em>, u8<em> *current_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edp_backlight_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Probe a display panel’s TCON using the standard VESA eDP backlight interface.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>The DP aux device to use for probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_edp_backlight_info</span> <span class="pre">*bl</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_edp_backlight_info" title="drm_edp_backlight_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_edp_backlight_info</span></code></a> struct to fill out with information on the backlight</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">driver_pwm_freq_hz</span></code></dt><dd><p>Optional PWM frequency from the driver in hz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE]</span></code></dt><dd><p>A cached copy of the eDP DPCD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*current_level</span></code></dt><dd><p>Where to store the probed brightness level, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*current_mode</span></code></dt><dd><p>Where to store the currently set backlight control mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes a <a class="reference internal" href="#c.drm_edp_backlight_info" title="drm_edp_backlight_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_edp_backlight_info</span></code></a> struct by probing <strong>aux</strong> for it’s backlight capabilities,
along with also probing the current and maximum supported brightness levels.</p>
<p>If <strong>driver_pwm_freq_hz</strong> is non-zero, this will be used as the backlight frequency. Otherwise, the
default frequency from the panel is used.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code> on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_panel_dp_aux_backlight">
int <code class="sig-name descname">drm_panel_dp_aux_backlight</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> *panel</em>, struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_dp_aux_backlight" title="Permalink to this definition">¶</a></dt>
<dd><p>create and use DP AUX backlight</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*panel</span></code></dt><dd><p>DRM panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>The DP AUX channel to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this function to create and handle backlight if your panel
supports backlight control over DP AUX channel using DPCD
registers as per VESA’s standard backlight control interface.</p>
<p>When the panel is enabled backlight will be enabled after a
successful call to <a class="reference internal" href="#c.drm_panel_funcs" title="drm_panel_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel_funcs.enable()</span></code></a></p>
<p>When the panel is disabled backlight will be disabled before the
call to <a class="reference internal" href="#c.drm_panel_funcs" title="drm_panel_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_panel_funcs.disable()</span></code></a>.</p>
<p>A typical implementation for a panel driver supporting backlight
control over DP AUX will call this function at probe time.
Backlight will then be handled transparently without requiring
any intervention from the driver.</p>
<p><a class="reference internal" href="#c.drm_panel_dp_aux_backlight" title="drm_panel_dp_aux_backlight"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_dp_aux_backlight()</span></code></a> must be called after the call to <a class="reference internal" href="#c.drm_panel_init" title="drm_panel_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_panel_init()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
</section>
<section id="display-port-cec-helper-functions-reference">
<h2>Display Port CEC Helper Functions Reference<a class="headerlink" href="#display-port-cec-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>These functions take care of supporting the CEC-Tunneling-over-AUX
feature of DisplayPort-to-HDMI adapters.</p>
<dl class="function">
<dt id="c.drm_dp_cec_irq">
void <code class="sig-name descname">drm_dp_cec_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_cec_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>handle CEC interrupt, if any</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called when handling an IRQ_HPD request. If CEC-tunneling-over-AUX
is present, then it will check for a CEC_IRQ and handle it accordingly.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_cec_register_connector">
void <code class="sig-name descname">drm_dp_cec_register_connector</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_cec_register_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new connector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A new connector was registered with associated CEC adapter name and
CEC adapter parent device. After registering the name and parent
drm_dp_cec_set_edid() is called to check if the connector supports
CEC and to register a CEC adapter if that is the case.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_cec_unregister_connector">
void <code class="sig-name descname">drm_dp_cec_unregister_connector</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_cec_unregister_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister the CEC adapter, if any</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DisplayPort AUX channel</p>
</dd>
</dl>
</div>
</section>
<section id="display-port-dual-mode-adaptor-helper-functions-reference">
<h2>Display Port Dual Mode Adaptor Helper Functions Reference<a class="headerlink" href="#display-port-dual-mode-adaptor-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>Helper functions to deal with DP dual mode (aka. DP++) adaptors.</p>
<p>Type 1:
Adaptor registers (if any) and the sink DDC bus may be accessed via I2C.</p>
<p>Type 2:
Adaptor registers and sink DDC bus can be accessed either via I2C or
I2C-over-AUX. Source devices may choose to implement either of these
access methods.</p>
<dl class="type">
<dt id="c.drm_lspcon_mode">
enum <code class="sig-name descname">drm_lspcon_mode</code><a class="headerlink" href="#c.drm_lspcon_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_LSPCON_MODE_INVALID</span></code></dt><dd><p>No LSPCON.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_LSPCON_MODE_LS</span></code></dt><dd><p>Level shifter mode of LSPCON
which drives DP++ to HDMI 1.4 conversion.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_LSPCON_MODE_PCON</span></code></dt><dd><p>Protocol converter mode of LSPCON
which drives DP++ to HDMI 2.0 active conversion.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_dp_dual_mode_type">
enum <code class="sig-name descname">drm_dp_dual_mode_type</code><a class="headerlink" href="#c.drm_dp_dual_mode_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of the DP dual mode adaptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_NONE</span></code></dt><dd><p>No DP dual mode adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_UNKNOWN</span></code></dt><dd><p>Could be either none or type 1 DVI adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_TYPE1_DVI</span></code></dt><dd><p>Type 1 DVI adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_TYPE1_HDMI</span></code></dt><dd><p>Type 1 HDMI adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_TYPE2_DVI</span></code></dt><dd><p>Type 2 DVI adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_TYPE2_HDMI</span></code></dt><dd><p>Type 2 HDMI adaptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRM_DP_DUAL_MODE_LSPCON</span></code></dt><dd><p>Level shifter / protocol converter</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_dp_dual_mode_read">
ssize_t <code class="sig-name descname">drm_dp_dual_mode_read</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, u8<em> offset</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from the DP dual mode adaptor register(s)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>register offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>buffer for return data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>sizo of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads <strong>size</strong> bytes from the DP dual mode adaptor registers
starting at <strong>offset</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dual_mode_write">
ssize_t <code class="sig-name descname">drm_dp_dual_mode_write</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, u8<em> offset</em>, const void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write to the DP dual mode adaptor register(s)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>register offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>buffer for write data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>sizo of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes <strong>size</strong> bytes to the DP dual mode adaptor registers
starting at <strong>offset</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dual_mode_detect">
enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a> <code class="sig-name descname">drm_dp_dual_mode_detect</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct i2c_adapter<em> *adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify the DP dual mode adaptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to identify the type of the DP dual mode adaptor used.</p>
<p>Note that when the answer is <strong>DRM_DP_DUAL_MODE_UNKNOWN</strong> it’s not
certain whether we’re dealing with a native HDMI port or
a type 1 DVI dual mode adaptor. The driver will have to use
some other hardware/driver specific mechanism to make that
distinction.</p>
<p><strong>Return</strong></p>
<p>The type of the DP dual mode adaptor used</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dual_mode_max_tmds_clock">
int <code class="sig-name descname">drm_dp_dual_mode_max_tmds_clock</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em> type</em>, struct i2c_adapter<em> *adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_max_tmds_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>Max TMDS clock for DP dual mode adaptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt><dd><p>DP dual mode adaptor type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the max TMDS clock the adaptor supports based on the
type of the dual mode adaptor and the DP_DUAL_MODE_MAX_TMDS_CLOCK
register (on type2 adaptors). As some type 1 adaptors have
problems with registers (see comments in <a class="reference internal" href="#c.drm_dp_dual_mode_detect" title="drm_dp_dual_mode_detect"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_dual_mode_detect()</span></code></a>)
we don’t read the register on those, instead we simply assume
a 165 MHz limit based on the specification.</p>
<p><strong>Return</strong></p>
<p>Maximum supported TMDS clock rate for the DP dual mode adaptor in kHz.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dual_mode_get_tmds_output">
int <code class="sig-name descname">drm_dp_dual_mode_get_tmds_output</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em> type</em>, struct i2c_adapter<em> *adapter</em>, bool<em> *enabled</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_get_tmds_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the state of the TMDS output buffers in the DP dual mode adaptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt><dd><p>DP dual mode adaptor type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*enabled</span></code></dt><dd><p>current state of the TMDS output buffers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the state of the TMDS output buffers in the adaptor. For
type2 adaptors this is queried from the DP_DUAL_MODE_TMDS_OEN
register. As some type 1 adaptors have problems with registers
(see comments in <a class="reference internal" href="#c.drm_dp_dual_mode_detect" title="drm_dp_dual_mode_detect"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_dual_mode_detect()</span></code></a>) we don’t read the
register on those, instead we simply assume that the buffers
are always enabled.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_dp_dual_mode_set_tmds_output">
int <code class="sig-name descname">drm_dp_dual_mode_set_tmds_output</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em> type</em>, struct i2c_adapter<em> *adapter</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dual_mode_set_tmds_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable/disable TMDS output buffers in the DP dual mode adaptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt><dd><p>DP dual mode adaptor type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter for the DDC bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>enable (as opposed to disable) the TMDS output buffers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the state of the TMDS output buffers in the adaptor. For
type2 this is set via the DP_DUAL_MODE_TMDS_OEN register.
Type1 adaptors do not support any register writes.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_dp_get_dual_mode_type_name">
const char * <code class="sig-name descname">drm_dp_get_dual_mode_type_name</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.drm_dp_dual_mode_type" title="drm_dp_dual_mode_type">drm_dp_dual_mode_type</a><em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_get_dual_mode_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of the DP dual mode adaptor type as a string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_dp_dual_mode_type</span> <span class="pre">type</span></code></dt><dd><p>DP dual mode adaptor type</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>String representation of the DP dual mode adaptor type</p>
</div>
<dl class="function">
<dt id="c.drm_lspcon_get_mode">
int <code class="sig-name descname">drm_lspcon_get_mode</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct i2c_adapter<em> *adapter</em>, enum <a class="reference internal" href="#c.drm_lspcon_mode" title="drm_lspcon_mode">drm_lspcon_mode</a><em> *mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_lspcon_get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get LSPCON’s current mode of operation by reading offset (0x80, 0x41)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C-over-aux adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_lspcon_mode</span> <span class="pre">*mode</span></code></dt><dd><p>current lspcon mode of operation output variable</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, sets the current_mode value to appropriate mode
-error on failure</p>
</div>
<dl class="function">
<dt id="c.drm_lspcon_set_mode">
int <code class="sig-name descname">drm_lspcon_set_mode</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct i2c_adapter<em> *adapter</em>, enum <a class="reference internal" href="#c.drm_lspcon_mode" title="drm_lspcon_mode">drm_lspcon_mode</a><em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_lspcon_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Change LSPCON’s mode of operation by writing offset (0x80, 0x40)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p><a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_device</span></code></a> to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C-over-aux adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_lspcon_mode</span> <span class="pre">mode</span></code></dt><dd><p>required mode of operation</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, -error on failure/timeout</p>
</div>
</section>
<section id="display-port-mst-helpers">
<h2>Display Port MST Helpers<a class="headerlink" href="#display-port-mst-helpers" title="Permalink to this headline">¶</a></h2>
<section id="id2">
<h3>Overview<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>These functions contain parts of the DisplayPort 1.2a MultiStream Transport
protocol. The helpers contain a topology manager and bandwidth manager.
The helpers encapsulate the sending and received of sideband msgs.</p>
<section id="topology-refcount-overview">
<h4>Topology refcount overview<a class="headerlink" href="#topology-refcount-overview" title="Permalink to this headline">¶</a></h4>
<p>The refcounting schemes for <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> and <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_dp_mst_port</span></code></a> are somewhat unusual. Both ports and branch devices have
two different kinds of refcounts: topology refcounts, and malloc refcounts.</p>
<p>Topology refcounts are not exposed to drivers, and are handled internally
by the DP MST helpers. The helpers use them in order to prevent the
in-memory topology state from being changed in the middle of critical
operations like changing the internal state of payload allocations. This
means each branch and port will be considered to be connected to the rest
of the topology until its topology refcount reaches zero. Additionally,
for ports this means that their associated <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> will stay
registered with userspace until the port’s refcount reaches 0.</p>
</section>
<section id="malloc-refcount-overview">
<h4>Malloc refcount overview<a class="headerlink" href="#malloc-refcount-overview" title="Permalink to this headline">¶</a></h4>
<p>Malloc references are used to keep a <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> or <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_dp_mst_branch</span></code></a> allocated even after all of its topology references have
been dropped, so that the driver or MST helpers can safely access each
branch’s last known state before it was disconnected from the topology.
When the malloc refcount of a port or branch reaches 0, the memory
allocation containing the <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> or <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_dp_mst_port</span></code></a> respectively will be freed.</p>
<p>For <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a>, malloc refcounts are not currently exposed
to drivers. As of writing this documentation, there are no drivers that
have a usecase for accessing <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> outside of the MST
helpers. Exposing this API to drivers in a race-free manner would take more
tweaking of the refcounting scheme, however patches are welcome provided
there is a legitimate driver usecase for this.</p>
</section>
<section id="refcount-relationships-in-a-topology">
<h4>Refcount relationships in a topology<a class="headerlink" href="#refcount-relationships-in-a-topology" title="Permalink to this headline">¶</a></h4>
<p>Let’s take a look at why the relationship between topology and malloc
refcounts is designed the way it is.</p>
<figure class="align-default" id="id3">
<img alt="../_images/topology-figure-1.svg" src="../_images/topology-figure-1.svg" /><figcaption>
<p><span class="caption-text">An example of topology and malloc refs in a DP MST topology with two
active payloads. Topology refcount increments are indicated by solid
lines, and malloc refcount increments are indicated by dashed lines.
Each starts from the branch which incremented the refcount, and ends at
the branch to which the refcount belongs to, i.e. the arrow points the
same way as the C pointers used to reference a structure.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>As you can see in the above figure, every branch increments the topology
refcount of its children, and increments the malloc refcount of its
parent. Additionally, every payload increments the malloc refcount of its
assigned port by 1.</p>
<p>So, what would happen if MSTB #3 from the above figure was unplugged from
the system, but the driver hadn’t yet removed payload #2 from port #3? The
topology would start to look like the figure below.</p>
<figure class="align-default" id="id4">
<img alt="../_images/topology-figure-2.svg" src="../_images/topology-figure-2.svg" /><figcaption>
<p><span class="caption-text">Ports and branch devices which have been released from memory are
colored grey, and references which have been removed are colored red.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Whenever a port or branch device’s topology refcount reaches zero, it will
decrement the topology refcounts of all its children, the malloc refcount
of its parent, and finally its own malloc refcount. For MSTB #4 and port
#4, this means they both have been disconnected from the topology and freed
from memory. But, because payload #2 is still holding a reference to port
#3, port #3 is removed from the topology but its <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a>
is still accessible from memory. This also means port #3 has not yet
decremented the malloc refcount of MSTB #3, so its <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_dp_mst_branch</span></code></a> will also stay allocated in memory until port #3’s
malloc refcount reaches 0.</p>
<p>This relationship is necessary because in order to release payload #2, we
need to be able to figure out the last relative of port #3 that’s still
connected to the topology. In this case, we would travel up the topology as
shown below.</p>
<figure class="align-default">
<img alt="../_images/topology-figure-3.svg" src="../_images/topology-figure-3.svg" /></figure>
<p>And finally, remove payload #2 by communicating with port #2 through
sideband transactions.</p>
</section>
</section>
<section id="functions-reference">
<h3>Functions Reference<a class="headerlink" href="#functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_dp_mst_port">
struct <code class="sig-name descname">drm_dp_mst_port</code><a class="headerlink" href="#c.drm_dp_mst_port" title="Permalink to this definition">¶</a></dt>
<dd><p>MST port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_mst_port {
    struct kref topology_kref;
    struct kref malloc_kref;
#if IS_ENABLED(CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS);
    struct drm_dp_mst_topology_ref_history topology_ref_history;
#endif;
    u8 port_num;
    bool input;
    bool mcs;
    bool ddps;
    u8 pdt;
    bool ldps;
    u8 dpcd_rev;
    u8 num_sdp_streams;
    u8 num_sdp_stream_sinks;
    uint16_t full_pbn;
    struct list_head next;
    struct drm_dp_mst_branch *mstb;
    struct drm_dp_aux aux;
    struct drm_dp_aux *passthrough_aux;
    struct drm_dp_mst_branch *parent;
    struct drm_connector *connector;
    struct drm_dp_mst_topology_mgr *mgr;
    struct edid *cached_edid;
    bool has_audio;
    bool fec_capable;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">topology_kref</span></code></dt><dd><p>refcount for this port’s lifetime in the topology,
only the DP MST helpers should need to touch this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">malloc_kref</span></code></dt><dd><p>refcount for the memory allocation containing this
structure. See <a class="reference internal" href="#c.drm_dp_mst_get_port_malloc" title="drm_dp_mst_get_port_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_get_port_malloc()</span></code></a> and
<a class="reference internal" href="#c.drm_dp_mst_put_port_malloc" title="drm_dp_mst_put_port_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_put_port_malloc()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">topology_ref_history</span></code></dt><dd><p>A history of each topology
reference/dereference. See CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port_num</span></code></dt><dd><p>port number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input</span></code></dt><dd><p>if this port is an input port. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mcs</span></code></dt><dd><p>message capability status - DP 1.2 spec. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ddps</span></code></dt><dd><p>DisplayPort Device Plug Status - DP 1.2. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pdt</span></code></dt><dd><p>Peer Device Type. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ldps</span></code></dt><dd><p>Legacy Device Plug Status. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpcd_rev</span></code></dt><dd><p>DPCD revision of device on this port. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_sdp_streams</span></code></dt><dd><p>Number of simultaneous streams. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_sdp_stream_sinks</span></code></dt><dd><p>Number of stream sinks. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">full_pbn</span></code></dt><dd><p>Max possible bandwidth for this port. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><p>link to next port on this branch device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mstb</span></code></dt><dd><p>the branch device connected to this port, if there is one.
This should be considered protected for reading by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.lock</span></code></a>. There are two exceptions to this:
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.up_req_work</span></code></a> and
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.work</span></code></a>, which do not grab
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.lock</span></code></a> during reads but are the only
updaters of this list and are protected from writing concurrently
by <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.probe_lock</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aux</span></code></dt><dd><p>i2c aux transport to talk to device connected to this port, protected
by <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">passthrough_aux</span></code></dt><dd><p>parent aux to which DSC pass-through requests should be
sent, only set if DSC pass-through is possible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>branch device parent of this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p>DRM connector this port is connected to. Protected by
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.base</span></code></a>.lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgr</span></code></dt><dd><p>topology manager this port lives under.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cached_edid</span></code></dt><dd><p>for DP logical ports - make tiling work by ensuring
that the EDID for all connectors is read immediately.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">has_audio</span></code></dt><dd><p>Tracks whether the sink connector to this port is
audio-capable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fec_capable</span></code></dt><dd><p>bool indicating if FEC can be supported up to that
point in the MST topology.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents an MST port endpoint on a device somewhere
in the MST topology.</p>
<dl class="type">
<dt id="c.drm_dp_mst_branch">
struct <code class="sig-name descname">drm_dp_mst_branch</code><a class="headerlink" href="#c.drm_dp_mst_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>MST branch device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_mst_branch {
    struct kref topology_kref;
    struct kref malloc_kref;
#if IS_ENABLED(CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS);
    struct drm_dp_mst_topology_ref_history topology_ref_history;
#endif;
    struct list_head destroy_next;
    u8 rad[8];
    u8 lct;
    int num_ports;
    struct list_head ports;
    struct drm_dp_mst_port *port_parent;
    struct drm_dp_mst_topology_mgr *mgr;
    bool link_address_sent;
    u8 guid[16];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">topology_kref</span></code></dt><dd><p>refcount for this branch device’s lifetime in the
topology, only the DP MST helpers should need to touch this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">malloc_kref</span></code></dt><dd><p>refcount for the memory allocation containing this
structure. See <a class="reference internal" href="#c.drm_dp_mst_get_mstb_malloc" title="drm_dp_mst_get_mstb_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_get_mstb_malloc()</span></code></a> and
<a class="reference internal" href="#c.drm_dp_mst_put_mstb_malloc" title="drm_dp_mst_put_mstb_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_put_mstb_malloc()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">topology_ref_history</span></code></dt><dd><p>A history of each topology
reference/dereference. See CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy_next</span></code></dt><dd><p>linked-list entry used by
drm_dp_delayed_destroy_work()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rad</span></code></dt><dd><p>Relative Address to talk to this branch device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lct</span></code></dt><dd><p>Link count total to talk to this branch device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ports</span></code></dt><dd><p>number of ports on the branch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ports</span></code></dt><dd><p>the list of ports on this branch device. This should be
considered protected for reading by <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.lock</span></code></a>.
There are two exceptions to this:
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.up_req_work</span></code></a> and
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.work</span></code></a>, which do not grab
<a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr.lock</span></code></a> during reads but are the only
updaters of this list and are protected from updating the list
concurrently by <strong>drm_dp_mst_topology_mgr.probe_lock</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port_parent</span></code></dt><dd><p>pointer to the port parent, NULL if toplevel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgr</span></code></dt><dd><p>topology manager for this branch device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_address_sent</span></code></dt><dd><p>if a link address message has been sent to this device yet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">guid</span></code></dt><dd><p>guid for DP 1.2 branch device. port under this branch can be
identified by port #.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents an MST branch device, there is one
primary branch device at the root, along with any other branches connected
to downstream port of parent branches.</p>
<dl class="type">
<dt id="c.drm_dp_mst_atomic_payload">
struct <code class="sig-name descname">drm_dp_mst_atomic_payload</code><a class="headerlink" href="#c.drm_dp_mst_atomic_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic state struct for an MST payload</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_mst_atomic_payload {
    struct drm_dp_mst_port *port;
    s8 vc_start_slot;
    u8 vcpi;
    int time_slots;
    int pbn;
    bool delete : 1;
    bool dsc_enabled : 1;
    struct list_head next;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt><dd><p>The MST port assigned to this payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vc_start_slot</span></code></dt><dd><p>The time slot that this payload starts on. Because payload start slots
can’t be determined ahead of time, the contents of this value are UNDEFINED at atomic
check time. This shouldn’t usually matter, as the start slot should never be relevant for
atomic state computations.</p>
<p>Since this value is determined at commit time instead of check time, this value is
protected by the MST helpers ensuring that async commits operating on the given topology
never run in parallel. In the event that a driver does need to read this value (e.g. to
inform hardware of the starting timeslot for a payload), the driver may either:</p>
<ul class="simple">
<li><p>Read this field during the atomic commit after
<a class="reference internal" href="#c.drm_dp_mst_atomic_wait_for_dependencies" title="drm_dp_mst_atomic_wait_for_dependencies"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_atomic_wait_for_dependencies()</span></code></a> has been called, which will ensure the
previous MST states payload start slots have been copied over to the new state. Note
that a new start slot won’t be assigned/removed from this payload until
<a class="reference internal" href="#c.drm_dp_add_payload_part1" title="drm_dp_add_payload_part1"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_add_payload_part1()</span></code></a>/<a class="reference internal" href="#c.drm_dp_remove_payload" title="drm_dp_remove_payload"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_remove_payload()</span></code></a> have been called.</p></li>
<li><p>Acquire the MST modesetting lock, and then wait for any pending MST-related commits to
get committed to hardware by calling <a class="reference internal" href="drm-kms.html#c.drm_crtc_commit_wait" title="drm_crtc_commit_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_commit_wait()</span></code></a> on each of the
<a class="reference internal" href="drm-kms.html#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_commit</span></code></a> structs in <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_state.commit_deps</span></code></a>.</p></li>
</ul>
<p>If neither of the two above solutions suffice (e.g. the driver needs to read the start
slot in the middle of an atomic commit without waiting for some reason), then drivers
should cache this value themselves after changing payloads.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vcpi</span></code></dt><dd><p>The Virtual Channel Payload Identifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">time_slots</span></code></dt><dd><p>The number of timeslots allocated to this payload from the source DP Tx to
the immediate downstream DP Rx</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pbn</span></code></dt><dd><p>The payload bandwidth for this payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delete</span></code></dt><dd><p>Whether or not we intend to delete this payload during this atomic commit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dsc_enabled</span></code></dt><dd><p>Whether or not this payload has DSC enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><p>The list node for this payload</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The primary atomic state structure for a given MST payload. Stores information like current
bandwidth allocation, intended action for this payload, etc.</p>
<dl class="type">
<dt id="c.drm_dp_mst_topology_state">
struct <code class="sig-name descname">drm_dp_mst_topology_state</code><a class="headerlink" href="#c.drm_dp_mst_topology_state" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort MST topology atomic state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_mst_topology_state {
    struct drm_private_state base;
    struct drm_dp_mst_topology_mgr *mgr;
    u32 pending_crtc_mask;
    struct drm_crtc_commit **commit_deps;
    size_t num_commit_deps;
    u32 payload_mask;
    struct list_head payloads;
    u8 total_avail_slots;
    u8 start_slot;
    int pbn_div;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base private state for atomic</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgr</span></code></dt><dd><p>The topology manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pending_crtc_mask</span></code></dt><dd><p>A bitmask of all CRTCs this topology state touches, drivers may
modify this to add additional dependencies if needed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commit_deps</span></code></dt><dd><p>A list of all CRTC commits affecting this topology, this field isn’t
populated until <a class="reference internal" href="#c.drm_dp_mst_atomic_wait_for_dependencies" title="drm_dp_mst_atomic_wait_for_dependencies"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_atomic_wait_for_dependencies()</span></code></a> is called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_commit_deps</span></code></dt><dd><p>The number of CRTC commits in <strong>commit_deps</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payload_mask</span></code></dt><dd><p>A bitmask of allocated VCPIs, used for VCPI assignments</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payloads</span></code></dt><dd><p>The list of payloads being created/destroyed in this state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total_avail_slots</span></code></dt><dd><p>The total number of slots this topology can handle (63 or 64)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_slot</span></code></dt><dd><p>The first usable time slot in this topology (1 or 0)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pbn_div</span></code></dt><dd><p>The current PBN divisor for this topology. The driver is expected to fill this
out itself.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct represents the atomic state of the toplevel DisplayPort MST manager</p>
<dl class="type">
<dt id="c.drm_dp_mst_topology_mgr">
struct <code class="sig-name descname">drm_dp_mst_topology_mgr</code><a class="headerlink" href="#c.drm_dp_mst_topology_mgr" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort MST manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dp_mst_topology_mgr {
    struct drm_private_obj base;
    struct drm_device *dev;
    const struct drm_dp_mst_topology_cbs *cbs;
    int max_dpcd_transaction_bytes;
    struct drm_dp_aux *aux;
    int max_payloads;
    int conn_base_id;
    struct drm_dp_sideband_msg_rx up_req_recv;
    struct drm_dp_sideband_msg_rx down_rep_recv;
    struct mutex lock;
    struct mutex probe_lock;
    bool mst_state : 1;
    bool payload_id_table_cleared : 1;
    u8 payload_count;
    u8 next_start_slot;
    struct drm_dp_mst_branch *mst_primary;
    u8 dpcd[DP_RECEIVER_CAP_SIZE];
    u8 sink_count;
    const struct drm_private_state_funcs *funcs;
    struct mutex qlock;
    struct list_head tx_msg_downq;
    wait_queue_head_t tx_waitq;
    struct work_struct work;
    struct work_struct tx_work;
    struct list_head destroy_port_list;
    struct list_head destroy_branch_device_list;
    struct mutex delayed_destroy_lock;
    struct workqueue_struct *delayed_destroy_wq;
    struct work_struct delayed_destroy_work;
    struct list_head up_req_list;
    struct mutex up_req_lock;
    struct work_struct up_req_work;
#if IS_ENABLED(CONFIG_DRM_DEBUG_DP_MST_TOPOLOGY_REFS);
    struct mutex topology_ref_history_lock;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base private object for atomic</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device pointer for adding i2c devices etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cbs</span></code></dt><dd><p>callbacks for connector addition and destruction.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_dpcd_transaction_bytes</span></code></dt><dd><p>maximum number of bytes to read/write
in one go.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aux</span></code></dt><dd><p>AUX channel for the DP MST connector this topolgy mgr is
controlling.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_payloads</span></code></dt><dd><p>maximum number of payloads the GPU can generate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">conn_base_id</span></code></dt><dd><p>DRM connector ID this mgr is connected to. Only used
to build the MST connector path value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">up_req_recv</span></code></dt><dd><p>Message receiver state for up requests.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">down_rep_recv</span></code></dt><dd><p>Message receiver state for replies to down
requests.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>protects <strong>mst_state</strong>, <strong>mst_primary</strong>, <strong>dpcd</strong>, and
<strong>payload_id_table_cleared</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_lock</span></code></dt><dd><p>Prevents <strong>work</strong> and <strong>up_req_work</strong>, the only writers of
<a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.mstb</span></code></a> and <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.ports</span></code></a>, from racing
while they update the topology.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mst_state</span></code></dt><dd><p>If this manager is enabled for an MST capable port. False
if no MST sink/branch devices is connected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payload_id_table_cleared</span></code></dt><dd><p>Whether or not we’ve cleared the payload
ID table for <strong>mst_primary</strong>. Protected by <strong>lock</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payload_count</span></code></dt><dd><p>The number of currently active payloads in hardware. This value is only
intended to be used internally by MST helpers for payload tracking, and is only safe to
read/write from the atomic commit (not check) context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next_start_slot</span></code></dt><dd><p>The starting timeslot to use for new VC payloads. This value is used
internally by MST helpers for payload tracking, and is only safe to read/write from the
atomic commit (not check) context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mst_primary</span></code></dt><dd><p>Pointer to the primary/first branch device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpcd</span></code></dt><dd><p>Cache of DPCD for primary port.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sink_count</span></code></dt><dd><p>Sink count from DEVICE_SERVICE_IRQ_VECTOR_ESI0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>Atomic helper callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qlock</span></code></dt><dd><p>protects <strong>tx_msg_downq</strong> and <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_sideband_msg_tx.state</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_msg_downq</span></code></dt><dd><p>List of pending down requests</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_waitq</span></code></dt><dd><p>Wait to queue stall for the tx worker.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>Probe work.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_work</span></code></dt><dd><p>Sideband transmit worker. This can nest within the main
<strong>work</strong> worker for each transaction <strong>work</strong> launches.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy_port_list</span></code></dt><dd><p>List of to be destroyed connectors.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destroy_branch_device_list</span></code></dt><dd><p>List of to be destroyed branch
devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delayed_destroy_lock</span></code></dt><dd><p>Protects <strong>destroy_port_list</strong> and
<strong>destroy_branch_device_list</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delayed_destroy_wq</span></code></dt><dd><p>Workqueue used for delayed_destroy_work items.
A dedicated WQ makes it possible to drain any requeued work items
on it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delayed_destroy_work</span></code></dt><dd><p>Work item to destroy MST port and branch
devices, needed to avoid locking inversion.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">up_req_list</span></code></dt><dd><p>List of pending up requests from the topology that
need to be processed, in chronological order.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">up_req_lock</span></code></dt><dd><p>Protects <strong>up_req_list</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">up_req_work</span></code></dt><dd><p>Work item to process up requests received from the
topology. Needed to avoid blocking hotplug handling and sideband
transmissions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">topology_ref_history_lock</span></code></dt><dd><p>protects
<a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.topology_ref_history</span></code></a> and
<a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.topology_ref_history</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct represents the toplevel displayport MST topology manager.
There should be one instance of this for every MST capable DP connector
on the GPU.</p>
<dl class="function">
<dt id="c.__drm_dp_mst_state_iter_get">
bool <code class="sig-name descname">__drm_dp_mst_state_iter_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> **mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state">drm_dp_mst_topology_state</a><em> **old_state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state">drm_dp_mst_topology_state</a><em> **new_state</em>, int<em> i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_dp_mst_state_iter_get" title="Permalink to this definition">¶</a></dt>
<dd><p>private atomic state iterator function for macro-internal use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">**mgr</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span> <span class="pre">**old_state</span></code></dt><dd><p>optional pointer to the old <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code></a>
iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span> <span class="pre">**new_state</span></code></dt><dd><p>optional pointer to the new <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code></a>
iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by <a class="reference internal" href="#c.for_each_oldnew_mst_mgr_in_state" title="for_each_oldnew_mst_mgr_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_oldnew_mst_mgr_in_state()</span></code></a>,
<a class="reference internal" href="#c.for_each_old_mst_mgr_in_state" title="for_each_old_mst_mgr_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_old_mst_mgr_in_state()</span></code></a>, and <a class="reference internal" href="#c.for_each_new_mst_mgr_in_state" title="for_each_new_mst_mgr_in_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_new_mst_mgr_in_state()</span></code></a>. Don’t
call this directly.</p>
<p><strong>Return</strong></p>
<p>True if the current <a class="reference internal" href="drm-kms.html#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_private_obj</span></code></a> is a <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_dp_mst_topology_mgr</span></code></a>, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.for_each_oldnew_mst_mgr_in_state">
<code class="sig-name descname">for_each_oldnew_mst_mgr_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>mgr</em>, <em>old_state</em>, <em>new_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_mst_mgr_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all DP MST topology managers in an atomic update</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgr</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code></a> iteration cursor for the old
state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code></a> iteration cursor for the new
state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all DRM DP MST topology managers in an atomic update,
tracking both old and new state. This is useful in places where the state
delta needs to be considered, for example in atomic check functions.</p>
</div>
<dl class="function">
<dt id="c.for_each_old_mst_mgr_in_state">
<code class="sig-name descname">for_each_old_mst_mgr_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>mgr</em>, <em>old_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_mst_mgr_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all DP MST topology managers in an atomic update</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgr</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code></a> iteration cursor for the old
state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all DRM DP MST topology managers in an atomic update,
tracking only the old state. This is useful in disable functions, where we
need the old state the hardware is still in.</p>
</div>
<dl class="function">
<dt id="c.for_each_new_mst_mgr_in_state">
<code class="sig-name descname">for_each_new_mst_mgr_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>mgr</em>, <em>new_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_mst_mgr_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all DP MST topology managers in an atomic update</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__state</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mgr</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span></code></a> iteration cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">new_state</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code></a> iteration cursor for the new
state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__i</span></code></dt><dd><p>int iteration cursor, for macro-internal use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all DRM DP MST topology managers in an atomic update,
tracking only the new state. This is useful in enable functions, where we
need the new state the hardware should be in when the atomic commit
operation has completed.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_get_port_malloc">
void <code class="sig-name descname">drm_dp_mst_get_port_malloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_get_port_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the malloc refcount of an MST port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> to increment the malloc refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a>. When <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a>
reaches 0, the memory allocation for <strong>port</strong> will be released and <strong>port</strong> may
no longer be used.</p>
<p>Because <strong>port</strong> could potentially be freed at any time by the DP MST helpers
if <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a> reaches 0, including during a call to this
function, drivers that which to make use of <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> should
ensure that they grab at least one main malloc reference to their MST ports
in <code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_cbs.add_connector</span></code>. This callback is called before
there is any chance for <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a> to reach 0.</p>
<p>See also: <a class="reference internal" href="#c.drm_dp_mst_put_port_malloc" title="drm_dp_mst_put_port_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_put_port_malloc()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_put_port_malloc">
void <code class="sig-name descname">drm_dp_mst_put_port_malloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_put_port_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement the malloc refcount of an MST port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> to decrement the malloc refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrements <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a>. When <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.malloc_kref</span></code></a>
reaches 0, the memory allocation for <strong>port</strong> will be released and <strong>port</strong> may
no longer be used.</p>
<p>See also: <a class="reference internal" href="#c.drm_dp_mst_get_port_malloc" title="drm_dp_mst_get_port_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_get_port_malloc()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_connector_late_register">
int <code class="sig-name descname">drm_dp_mst_connector_late_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_connector_late_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Late MST connector registration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>The MST connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>The MST port for this connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to register the remote aux device for this MST port. Drivers should
call this from their mst connector’s late_register hook to enable MST aux
devices.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_connector_early_unregister">
void <code class="sig-name descname">drm_dp_mst_connector_early_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_connector_early_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Early MST connector unregistration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>The MST connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>The MST port for this connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to unregister the remote aux device for this MST port, registered by
<a class="reference internal" href="#c.drm_dp_mst_connector_late_register" title="drm_dp_mst_connector_late_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_connector_late_register()</span></code></a>. Drivers should call this from their mst
connector’s early_unregister hook.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_add_payload_part1">
int <code class="sig-name descname">drm_dp_add_payload_part1</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state">drm_dp_mst_topology_state</a><em> *mst_state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_atomic_payload" title="drm_dp_mst_atomic_payload">drm_dp_mst_atomic_payload</a><em> *payload</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_add_payload_part1" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute payload update part 1</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>Manager to use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span> <span class="pre">*mst_state</span></code></dt><dd><p>The MST atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_atomic_payload</span> <span class="pre">*payload</span></code></dt><dd><p>The payload to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determines the starting time slot for the given payload, and programs the VCPI for this payload
into hardware. After calling this, the driver should generate ACT and payload packets.</p>
<p><strong>Return</strong></p>
<p>0 on success, error code on failure. In the event that this fails,
<strong>payload.vc_start_slot</strong> will also be set to -1.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_remove_payload">
void <code class="sig-name descname">drm_dp_remove_payload</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state">drm_dp_mst_topology_state</a><em> *mst_state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_atomic_payload" title="drm_dp_mst_atomic_payload">drm_dp_mst_atomic_payload</a><em> *payload</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_remove_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an MST payload</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>Manager to use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span> <span class="pre">*mst_state</span></code></dt><dd><p>The MST atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_atomic_payload</span> <span class="pre">*payload</span></code></dt><dd><p>The payload to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a payload from an MST topology if it was successfully assigned a start slot. Also updates
the starting time slots of all other payloads which would have been shifted towards the start of
the VC table as a result. After calling this, the driver should generate ACT and payload packets.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_add_payload_part2">
int <code class="sig-name descname">drm_dp_add_payload_part2</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_atomic_payload" title="drm_dp_mst_atomic_payload">drm_dp_mst_atomic_payload</a><em> *payload</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_add_payload_part2" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute payload update part 2</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>Manager to use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>The global atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_atomic_payload</span> <span class="pre">*payload</span></code></dt><dd><p>The payload to update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>payload</strong> was successfully assigned a starting time slot by <a class="reference internal" href="#c.drm_dp_add_payload_part1" title="drm_dp_add_payload_part1"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_add_payload_part1()</span></code></a>, this
function will send the sideband messages to finish allocating this payload.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_get_vc_payload_bw">
int <code class="sig-name descname">drm_dp_get_vc_payload_bw</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, int<em> link_rate</em>, int<em> link_lane_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_get_vc_payload_bw" title="Permalink to this definition">¶</a></dt>
<dd><p>get the VC payload BW for an MST link</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_mgr</span></code></a> to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">link_rate</span></code></dt><dd><p>link rate in 10kbits/s units</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">link_lane_count</span></code></dt><dd><p>lane count</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the total bandwidth of a MultiStream Transport link. The returned
value is in units of PBNs/(timeslots/1 MTP). This value can be used to
convert the number of PBNs required for a given stream to the number of
timeslots this stream requires in each MTP.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_read_mst_cap">
bool <code class="sig-name descname">drm_dp_read_mst_cap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, const u8<em> dpcd[DP_RECEIVER_CAP_SIZE]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_read_mst_cap" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether or not a sink supports MST</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>The DP AUX channel to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">dpcd[DP_RECEIVER_CAP_SIZE]</span></code></dt><dd><p>A cached copy of the DPCD capabilities for this sink</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the sink supports MST, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_set_mst">
int <code class="sig-name descname">drm_dp_mst_topology_mgr_set_mst</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, bool<em> mst_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_set_mst" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the MST state for a topology manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>manager to set state for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">mst_state</span></code></dt><dd><p>true to enable MST on this connector - false to disable.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called by the driver when it detects an MST capable device plugged
into a DP MST capable port, or when a DP MST capable device is unplugged.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_suspend">
void <code class="sig-name descname">drm_dp_mst_topology_mgr_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>suspend the MST manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>manager to suspend</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tells the MST device that we can’t handle UP messages
anymore. This should stop it from sending any since we are suspended.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_resume">
int <code class="sig-name descname">drm_dp_mst_topology_mgr_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, bool<em> sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>resume the MST manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>manager to resume</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">sync</span></code></dt><dd><p>whether or not to perform topology reprobing synchronously</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will fetch DPCD and see if the device is still there,
if it is, it will rewrite the MSTM control bits, and return.</p>
<p>If the device fails this returns -1, and the driver should do
a full MST reprobe, in case we were undocked.</p>
<p>During system resume (where it is assumed that the driver will be calling
<a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a>) this function should be called beforehand with
<strong>sync</strong> set to true. In contexts like runtime resume where the driver is not
expected to be calling <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a>, this function should be
called with <strong>sync</strong> set to false in order to avoid deadlocking.</p>
<p><strong>Return</strong></p>
<p>-1 if the MST topology was removed while we were suspended, 0
otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_hpd_irq">
int <code class="sig-name descname">drm_dp_mst_hpd_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, u8<em> *esi</em>, bool<em> *handled</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_hpd_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>MST hotplug IRQ notify</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>manager to notify irq for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*esi</span></code></dt><dd><p>4 bytes from SINK_COUNT_ESI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*handled</span></code></dt><dd><p>whether the hpd interrupt was consumed or not</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called from the driver when it detects a short IRQ,
along with the value of the DEVICE_SERVICE_IRQ_VECTOR_ESI0. The
topology manager will process the sideband messages received as a result
of this.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_detect_port">
int <code class="sig-name descname">drm_dp_mst_detect_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_detect_port" title="Permalink to this definition">¶</a></dt>
<dd><p>get connection status for an MST port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>DRM connector for this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>The acquisition context to use for grabbing locks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>manager for this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>pointer to a port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the current connection state for a port.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_get_edid">
struct edid * <code class="sig-name descname">drm_dp_mst_get_edid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_get_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID for an MST port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>toplevel connector to get EDID for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>manager for this port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>unverified pointer to a port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns an EDID for the port connected to a connector,
It validates the pointer still exists so the caller doesn’t require a
reference.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_atomic_find_time_slots">
int <code class="sig-name descname">drm_dp_atomic_find_time_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em>, int<em> pbn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_atomic_find_time_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and add time slots to the state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>MST topology manager for the port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>port to find time slots for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pbn</span></code></dt><dd><p>bandwidth required for the mode in PBN</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates time slots to <strong>port</strong>, replacing any previous time slot allocations it may
have had. Any atomic drivers which support MST must call this function in
their <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.atomic_check()</span></code></a> callback unconditionally to
change the current time slot allocation for the new state, and ensure the MST
atomic state is added whenever the state of payloads in the topology changes.</p>
<p>Allocations set by this function are not checked against the bandwidth
restraints of <strong>mgr</strong> until the driver calls <a class="reference internal" href="#c.drm_dp_mst_atomic_check" title="drm_dp_mst_atomic_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_atomic_check()</span></code></a>.</p>
<p>Additionally, it is OK to call this function multiple times on the same
<strong>port</strong> as needed. It is not OK however, to call this function and
<a class="reference internal" href="#c.drm_dp_atomic_release_time_slots" title="drm_dp_atomic_release_time_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_release_time_slots()</span></code></a> in the same atomic check phase.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_atomic_release_time_slots" title="drm_dp_atomic_release_time_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_release_time_slots()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_atomic_check" title="drm_dp_mst_atomic_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_atomic_check()</span></code></a></p>
<p><strong>Return</strong></p>
<p>Total slots in the atomic state assigned for this port, or a negative error
code if the port no longer exists</p>
</div>
<dl class="function">
<dt id="c.drm_dp_atomic_release_time_slots">
int <code class="sig-name descname">drm_dp_atomic_release_time_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_atomic_release_time_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>Release allocated time slots</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>MST topology manager for the port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>The port to release the time slots from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases any time slots that have been allocated to a port in the atomic
state. Any atomic drivers which support MST must call this function
unconditionally in their <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.atomic_check()</span></code></a> callback.
This helper will check whether time slots would be released by the new state and
respond accordingly, along with ensuring the MST state is always added to the
atomic state whenever a new state would modify the state of payloads on the
topology.</p>
<p>It is OK to call this even if <strong>port</strong> has been removed from the system.
Additionally, it is OK to call this function multiple times on the same
<strong>port</strong> as needed. It is not OK however, to call this function and
<a class="reference internal" href="#c.drm_dp_atomic_find_time_slots" title="drm_dp_atomic_find_time_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_find_time_slots()</span></code></a> on the same <strong>port</strong> in a single atomic check
phase.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_atomic_find_time_slots" title="drm_dp_atomic_find_time_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_find_time_slots()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_atomic_check" title="drm_dp_mst_atomic_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_atomic_check()</span></code></a></p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_atomic_setup_commit">
int <code class="sig-name descname">drm_dp_mst_atomic_setup_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_atomic_setup_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>setup_commit hook for MST helpers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function saves all of the <a class="reference internal" href="drm-kms.html#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_commit</span></code></a> structs in an atomic state that touch any CRTCs
currently assigned to an MST topology. Drivers must call this hook from their
<a class="reference internal" href="#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_helper_funcs.atomic_commit_setup</span></code></a> hook.</p>
<p><strong>Return</strong></p>
<p>0 if all CRTC commits were retrieved successfully, negative error code otherwise</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_atomic_wait_for_dependencies">
void <code class="sig-name descname">drm_dp_mst_atomic_wait_for_dependencies</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_atomic_wait_for_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for all pending commits on MST topologies, prepare new MST state for commit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Goes through any MST topologies in this atomic state, and waits for any pending commits which
touched CRTCs that were/are on an MST topology to be programmed to hardware and flipped to before
returning. This is to prevent multiple non-blocking commits affecting an MST topology from racing
with eachother by forcing them to be executed sequentially in situations where the only resources
the modeset objects in these commits share are an MST topology.</p>
<p>This function also prepares the new MST state for commit by performing some state preparation
which can’t be done until this point, such as reading back the final VC start slots (which are
determined at commit-time) from the previous state.</p>
<p>All MST drivers must call this function after calling <a class="reference internal" href="#c.drm_atomic_helper_wait_for_dependencies" title="drm_atomic_helper_wait_for_dependencies"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_wait_for_dependencies()</span></code></a>,
or whatever their equivalent of that is.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_root_conn_atomic_check">
int <code class="sig-name descname">drm_dp_mst_root_conn_atomic_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a><em> *new_conn_state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_root_conn_atomic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize CRTC commits on MST-capable connectors operating in SST mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*new_conn_state</span></code></dt><dd><p>The new connector state of the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>The MST topology manager for the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Since MST uses fake <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a> structs, the generic atomic modesetting code isn’t able to
serialize non-blocking commits happening on the real DP connector of an MST topology switching
into/away from MST mode - as the CRTC on the real DP connector and the CRTCs on the connector’s
MST topology will never share the same <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder</span></code></a>.</p>
<p>This function takes care of this serialization issue, by checking a root MST connector’s atomic
state to determine if it is about to have a modeset - and then pulling in the MST topology state
if so, along with adding any relevant CRTCs to <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_topology_state.pending_crtc_mask</span></code></a>.</p>
<p>Drivers implementing MST must call this function from the
<a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.atomic_check</span></code></a> hook of any physical DP <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> capable of
driving MST sinks.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_update_slots">
void <code class="sig-name descname">drm_dp_mst_update_slots</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state">drm_dp_mst_topology_state</a><em> *mst_state</em>, uint8_t<em> link_encoding_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_update_slots" title="Permalink to this definition">¶</a></dt>
<dd><p>updates the slot info depending on the DP ecoding format</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span> <span class="pre">*mst_state</span></code></dt><dd><p>mst_state to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">link_encoding_cap</span></code></dt><dd><p>the ecoding format on the link</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_dp_check_act_status">
int <code class="sig-name descname">drm_dp_check_act_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_check_act_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Polls for ACT handled status.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>manager to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tries waiting for the MST hub to finish updating it’s payload table by
polling for the ACT handled bit for up to 3 seconds (yes-some hubs really
take that long).</p>
<p><strong>Return</strong></p>
<p>0 if the ACT was handled in time, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_calc_pbn_mode">
int <code class="sig-name descname">drm_dp_calc_pbn_mode</code><span class="sig-paren">(</span>int<em> clock</em>, int<em> bpp</em>, bool<em> dsc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_calc_pbn_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the PBN for a mode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">clock</span></code></dt><dd><p>dot clock for the mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bpp</span></code></dt><dd><p>bpp for the mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">dsc</span></code></dt><dd><p>DSC mode. If true, bpp has units of 1/16 of a bit per pixel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This uses the formula in the spec to calculate the PBN value for a mode.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_dump_topology">
void <code class="sig-name descname">drm_dp_mst_dump_topology</code><span class="sig-paren">(</span>struct seq_file<em> *m</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_dump_topology" title="Permalink to this definition">¶</a></dt>
<dd><p>dump topology to seq file.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m</span></code></dt><dd><p>seq_file to dump output to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>manager to dump current topology for.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>helper to dump MST topology to a seq file for debugfs.</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_add_affected_dsc_crtcs">
int <code class="sig-name descname">drm_dp_mst_add_affected_dsc_crtcs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_add_affected_dsc_crtcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>Pointer to the new <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>MST topology manager</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Whenever there is a change in mst topology
DSC configuration would have to be recalculated
therefore we need to trigger modeset on all affected
CRTCs in that topology</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_atomic_enable_dsc" title="drm_dp_mst_atomic_enable_dsc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_atomic_enable_dsc()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_atomic_enable_dsc">
int <code class="sig-name descname">drm_dp_mst_atomic_enable_dsc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em>, int<em> pbn</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_atomic_enable_dsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Set DSC Enable Flag to On/Off</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>Pointer to the new drm_atomic_state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>Pointer to the affected MST Port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pbn</span></code></dt><dd><p>Newly recalculated bw required for link with DSC enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>Boolean flag to enable or disable DSC on the port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables DSC on the given Port
by recalculating its vcpi from pbn provided
and sets dsc_enable flag to keep track of which
ports have DSC enabled</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_atomic_check">
int <code class="sig-name descname">drm_dp_mst_atomic_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_atomic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that the new state of an MST topology in an atomic update is valid</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>Pointer to the new <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_state</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks the given topology state for an atomic update to ensure that it’s
valid. This includes checking whether there’s enough bandwidth to support
the new timeslot allocations in the atomic update.</p>
<p>Any atomic drivers supporting DP MST must make sure to call this after
checking the rest of their state in their
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.atomic_check()</span></code></a> callback.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_atomic_find_time_slots" title="drm_dp_atomic_find_time_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_find_time_slots()</span></code></a>
<a class="reference internal" href="#c.drm_dp_atomic_release_time_slots" title="drm_dp_atomic_release_time_slots"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_atomic_release_time_slots()</span></code></a></p>
<p>0 if the new state is valid, negative error code otherwise.</p>
<p><strong>Return</strong></p>
</div>
<dl class="function">
<dt id="c.drm_atomic_get_mst_topology_state">
struct <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state">drm_dp_mst_topology_state</a> * <code class="sig-name descname">drm_atomic_get_mst_topology_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_mst_topology_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get MST topology state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>MST topology manager, also the private object in this case</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps drm_atomic_get_priv_obj_state() passing in the MST atomic
state vtable so that the private object state returned is that of a MST
topology object.</p>
<p>The MST topology state or error pointer.</p>
<p><strong>Return</strong></p>
</div>
<dl class="function">
<dt id="c.drm_atomic_get_new_mst_topology_state">
struct <a class="reference internal" href="#c.drm_dp_mst_topology_state" title="drm_dp_mst_topology_state">drm_dp_mst_topology_state</a> * <code class="sig-name descname">drm_atomic_get_new_mst_topology_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em>, struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_mst_topology_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get new MST topology state in atomic state, if any</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>global atomic state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>MST topology manager, also the private object in this case</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function wraps drm_atomic_get_priv_obj_state() passing in the MST atomic
state vtable so that the private object state returned is that of a MST
topology object.</p>
<p>The MST topology state, or NULL if there’s no topology state for this MST mgr
in the global atomic state</p>
<p><strong>Return</strong></p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_init">
int <code class="sig-name descname">drm_dp_mst_topology_mgr_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a><em> *aux</em>, int<em> max_dpcd_transaction_bytes</em>, int<em> max_payloads</em>, int<em> conn_base_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a topology manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>manager struct to initialise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>device providing this structure - for i2c addition.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*aux</span></code></dt><dd><p>DP helper aux channel to talk to this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_dpcd_transaction_bytes</span></code></dt><dd><p>hw specific DPCD transaction limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_payloads</span></code></dt><dd><p>maximum number of payloads this GPU can source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">conn_base_id</span></code></dt><dd><p>the connector object ID the MST device is connected to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 for success, or negative error code on failure</p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_topology_mgr_destroy">
void <code class="sig-name descname">drm_dp_mst_topology_mgr_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_topology_mgr" title="drm_dp_mst_topology_mgr">drm_dp_mst_topology_mgr</a><em> *mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_mgr_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy topology manager.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_topology_mgr</span> <span class="pre">*mgr</span></code></dt><dd><p>manager to destroy</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_dsc_aux_for_port">
struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> * <code class="sig-name descname">drm_dp_mst_dsc_aux_for_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_dsc_aux_for_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the correct aux for DSC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>The port to check. A leaf of the MST tree with an attached display.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Depending on the situation, DSC may be enabled via the endpoint aux,
the immediately upstream aux, or the connector’s physical aux.</p>
<p>This is both the correct aux to read DSC_CAPABILITY and the
correct aux to write DSC_ENABLED.</p>
<p>This operation can be expensive (up to four aux reads), so
the caller should cache the return.</p>
<p><strong>Return</strong></p>
<p>NULL if DSC cannot be enabled on this port, otherwise the aux device</p>
</div>
</section>
<section id="topology-lifetime-internals">
<h3>Topology Lifetime Internals<a class="headerlink" href="#topology-lifetime-internals" title="Permalink to this headline">¶</a></h3>
<p>These functions aren’t exported to drivers, but are documented here to help make
the MST topology helpers easier to understand</p>
<dl class="function">
<dt id="c.drm_dp_mst_get_mstb_malloc">
void <code class="sig-name descname">drm_dp_mst_get_mstb_malloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch">drm_dp_mst_branch</a><em> *mstb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_get_mstb_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the malloc refcount of a branch device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span> <span class="pre">*mstb</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> to increment the malloc refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.malloc_kref</span></code></a>. When
<a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.malloc_kref</span></code></a> reaches 0, the memory allocation for <strong>mstb</strong>
will be released and <strong>mstb</strong> may no longer be used.</p>
<p>See also: <a class="reference internal" href="#c.drm_dp_mst_put_mstb_malloc" title="drm_dp_mst_put_mstb_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_put_mstb_malloc()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_put_mstb_malloc">
void <code class="sig-name descname">drm_dp_mst_put_mstb_malloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch">drm_dp_mst_branch</a><em> *mstb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_put_mstb_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement the malloc refcount of a branch device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span> <span class="pre">*mstb</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> to decrement the malloc refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrements <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.malloc_kref</span></code></a>. When
<a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.malloc_kref</span></code></a> reaches 0, the memory allocation for <strong>mstb</strong>
will be released and <strong>mstb</strong> may no longer be used.</p>
<p>See also: <a class="reference internal" href="#c.drm_dp_mst_get_mstb_malloc" title="drm_dp_mst_get_mstb_malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_get_mstb_malloc()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_topology_try_get_mstb">
int <code class="sig-name descname">drm_dp_mst_topology_try_get_mstb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch">drm_dp_mst_branch</a><em> *mstb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_try_get_mstb" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the topology refcount of a branch device unless it’s zero</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span> <span class="pre">*mstb</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> to increment the topology refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempts to grab a topology reference to <strong>mstb</strong>, if it hasn’t yet been
removed from the topology (e.g. <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.topology_kref</span></code></a> has
reached 0). Holding a topology reference implies that a malloc reference
will be held to <strong>mstb</strong> as long as the user holds the topology reference.</p>
<p>Care should be taken to ensure that the user has at least one malloc
reference to <strong>mstb</strong>. If you already have a topology reference to <strong>mstb</strong>, you
should use <a class="reference internal" href="#c.drm_dp_mst_topology_get_mstb" title="drm_dp_mst_topology_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_mstb()</span></code></a> instead.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_get_mstb" title="drm_dp_mst_topology_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_mstb()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_put_mstb" title="drm_dp_mst_topology_put_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_put_mstb()</span></code></a></p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>1: A topology reference was grabbed successfully</p></li>
<li><p>0: <strong>port</strong> is no longer in the topology, no reference was grabbed</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_topology_get_mstb">
void <code class="sig-name descname">drm_dp_mst_topology_get_mstb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch">drm_dp_mst_branch</a><em> *mstb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_get_mstb" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the topology refcount of a branch device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span> <span class="pre">*mstb</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> to increment the topology refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.topology_refcount</span></code></a> without checking whether or
not it’s already reached 0. This is only valid to use in scenarios where
you are already guaranteed to have at least one active topology reference
to <strong>mstb</strong>. Otherwise, <a class="reference internal" href="#c.drm_dp_mst_topology_try_get_mstb" title="drm_dp_mst_topology_try_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_mstb()</span></code></a> must be used.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_try_get_mstb" title="drm_dp_mst_topology_try_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_mstb()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_put_mstb" title="drm_dp_mst_topology_put_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_put_mstb()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_topology_put_mstb">
void <code class="sig-name descname">drm_dp_mst_topology_put_mstb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch">drm_dp_mst_branch</a><em> *mstb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_put_mstb" title="Permalink to this definition">¶</a></dt>
<dd><p>release a topology reference to a branch device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span> <span class="pre">*mstb</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_branch</span></code></a> to release the topology reference from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a topology reference from <strong>mstb</strong> by decrementing
<a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_branch.topology_kref</span></code></a>.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_try_get_mstb" title="drm_dp_mst_topology_try_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_mstb()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_get_mstb" title="drm_dp_mst_topology_get_mstb"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_mstb()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_topology_try_get_port">
int <code class="sig-name descname">drm_dp_mst_topology_try_get_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_try_get_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the topology refcount of a port unless it’s zero</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p><a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> to increment the topology refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempts to grab a topology reference to <strong>port</strong>, if it hasn’t yet been
removed from the topology (e.g. <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.topology_kref</span></code></a> has reached
0). Holding a topology reference implies that a malloc reference will be
held to <strong>port</strong> as long as the user holds the topology reference.</p>
<p>Care should be taken to ensure that the user has at least one malloc
reference to <strong>port</strong>. If you already have a topology reference to <strong>port</strong>, you
should use <a class="reference internal" href="#c.drm_dp_mst_topology_get_port" title="drm_dp_mst_topology_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_port()</span></code></a> instead.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_get_port" title="drm_dp_mst_topology_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_port()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_put_port" title="drm_dp_mst_topology_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_put_port()</span></code></a></p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>1: A topology reference was grabbed successfully</p></li>
<li><p>0: <strong>port</strong> is no longer in the topology, no reference was grabbed</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_topology_get_port">
void <code class="sig-name descname">drm_dp_mst_topology_get_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_get_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the topology refcount of a port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> to increment the topology refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.topology_refcount</span></code></a> without checking whether or
not it’s already reached 0. This is only valid to use in scenarios where
you are already guaranteed to have at least one active topology reference
to <strong>port</strong>. Otherwise, <a class="reference internal" href="#c.drm_dp_mst_topology_try_get_port" title="drm_dp_mst_topology_try_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_port()</span></code></a> must be used.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_try_get_port" title="drm_dp_mst_topology_try_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_port()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_put_port" title="drm_dp_mst_topology_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_put_port()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.drm_dp_mst_topology_put_port">
void <code class="sig-name descname">drm_dp_mst_topology_put_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port">drm_dp_mst_port</a><em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_mst_topology_put_port" title="Permalink to this definition">¶</a></dt>
<dd><p>release a topology reference to a port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span> <span class="pre">*port</span></code></dt><dd><p>The <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dp_mst_port</span></code></a> to release the topology reference from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a topology reference from <strong>port</strong> by decrementing
<a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_dp_mst_port.topology_kref</span></code></a>.</p>
<p>See also:
<a class="reference internal" href="#c.drm_dp_mst_topology_try_get_port" title="drm_dp_mst_topology_try_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_try_get_port()</span></code></a>
<a class="reference internal" href="#c.drm_dp_mst_topology_get_port" title="drm_dp_mst_topology_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_dp_mst_topology_get_port()</span></code></a></p>
</div>
</section>
</section>
<section id="mipi-dbi-helper-functions-reference">
<h2>MIPI DBI Helper Functions Reference<a class="headerlink" href="#mipi-dbi-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>This library provides helpers for MIPI Display Bus Interface (DBI)
compatible display controllers.</p>
<p>Many controllers for tiny lcd displays are MIPI compliant and can use this
library. If a controller uses registers 0x2A and 0x2B to set the area to
update and uses register 0x2C to write to frame memory, it is most likely
MIPI compliant.</p>
<p>Only MIPI Type 1 displays are supported since a full frame memory is needed.</p>
<p>There are 3 MIPI DBI implementation types:</p>
<ol class="upperalpha simple">
<li><p>Motorola 6800 type parallel bus</p></li>
<li><p>Intel 8080 type parallel bus</p></li>
<li><p>SPI type with 3 options:</p>
<ol class="arabic simple">
<li><p>9-bit with the Data/Command signal as the ninth bit</p></li>
<li><p>Same as above except it’s sent as 16 bits</p></li>
<li><p>8-bit with the Data/Command signal as a separate D/CX pin</p></li>
</ol>
</li>
</ol>
<p>Currently mipi_dbi only supports Type C options 1 and 3 with
<a class="reference internal" href="#c.mipi_dbi_spi_init" title="mipi_dbi_spi_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_spi_init()</span></code></a>.</p>
<dl class="type">
<dt id="c.mipi_dbi">
struct <code class="sig-name descname">mipi_dbi</code><a class="headerlink" href="#c.mipi_dbi" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dbi {
    struct mutex cmdlock;
    int (*command)(struct mipi_dbi *dbi, u8 *cmd, u8 *param, size_t num);
    const u8 *read_commands;
    bool swap_bytes;
    struct gpio_desc *reset;
    struct spi_device *spi;
    struct gpio_desc *dc;
    void *tx_buf9;
    size_t tx_buf9_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cmdlock</span></code></dt><dd><p>Command lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">command</span></code></dt><dd><p>Bus specific callback executing commands.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_commands</span></code></dt><dd><dl class="simple">
<dt>Array of read commands terminated by a zero entry.</dt><dd><p>Reading is disabled if this is NULL.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swap_bytes</span></code></dt><dd><p>Swap bytes in buffer before transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset</span></code></dt><dd><p>Optional reset gpio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spi</span></code></dt><dd><p>SPI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dc</span></code></dt><dd><p>Optional D/C gpio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_buf9</span></code></dt><dd><p>Buffer used for Option 1 9-bit conversion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_buf9_len</span></code></dt><dd><p>Size of tx_buf9.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.mipi_dbi_dev">
struct <code class="sig-name descname">mipi_dbi_dev</code><a class="headerlink" href="#c.mipi_dbi_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dbi_dev {
    struct drm_device drm;
    struct drm_simple_display_pipe pipe;
    struct drm_connector connector;
    struct drm_display_mode mode;
    u16 *tx_buf;
    unsigned int rotation;
    unsigned int left_offset;
    unsigned int top_offset;
    struct backlight_device *backlight;
    struct regulator *regulator;
    struct mipi_dbi dbi;
    void *driver_private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">drm</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pipe</span></code></dt><dd><p>Display pipe structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connector</span></code></dt><dd><p>Connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>Fixed display mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_buf</span></code></dt><dd><p>Buffer used for transfer (copy clip rect area)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rotation</span></code></dt><dd><p>initial rotation in degrees Counter Clock Wise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">left_offset</span></code></dt><dd><dl class="simple">
<dt>Horizontal offset of the display relative to the</dt><dd><p>controller’s driver array</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">top_offset</span></code></dt><dd><dl class="simple">
<dt>Vertical offset of the display relative to the</dt><dd><p>controller’s driver array</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlight</span></code></dt><dd><p>backlight device (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regulator</span></code></dt><dd><p>power regulator (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dbi</span></code></dt><dd><p>MIPI DBI interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_private</span></code></dt><dd><dl class="simple">
<dt>Driver private data.</dt><dd><p>Necessary for drivers with private data since <a class="reference internal" href="drm-internals.html#c.devm_drm_dev_alloc" title="devm_drm_dev_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_dev_alloc()</span></code></a>
can’t allocate structures that embed a structure which then again
embeds drm_device.</p>
</dd>
</dl>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.mipi_dbi_command">
<code class="sig-name descname">mipi_dbi_command</code><span class="sig-paren">(</span><em>dbi</em>, <em>cmd</em>, <em>seq…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_command" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DCS command with optional parameter(s)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dbi</span></code></dt><dd><p>MIPI DBI structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>Command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seq...</span></code></dt><dd><p>Optional parameter(s)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send MIPI DCS command to the controller. Use <a class="reference internal" href="#c.mipi_dbi_command_read" title="mipi_dbi_command_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_command_read()</span></code></a> for
get/read.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_command_read">
int <code class="sig-name descname">mipi_dbi_command_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi">mipi_dbi</a><em> *dbi</em>, u8<em> cmd</em>, u8<em> *val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_command_read" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DCS read command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi</span> <span class="pre">*dbi</span></code></dt><dd><p>MIPI DBI structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>Command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*val</span></code></dt><dd><p>Value read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send MIPI DCS read command to the controller.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_command_buf">
int <code class="sig-name descname">mipi_dbi_command_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi">mipi_dbi</a><em> *dbi</em>, u8<em> cmd</em>, u8<em> *data</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_command_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DCS command with parameter(s) in an array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi</span> <span class="pre">*dbi</span></code></dt><dd><p>MIPI DBI structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>Command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*data</span></code></dt><dd><p>Parameter buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>Buffer length</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_buf_copy">
int <code class="sig-name descname">mipi_dbi_buf_copy</code><span class="sig-paren">(</span>void<em> *dst</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em>, bool<em> swap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_buf_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a framebuffer, transforming it if necessary</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dst</span></code></dt><dd><p>The destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>The source framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>Clipping rectangle of the area to be copied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">swap</span></code></dt><dd><p>When true, swap MSB/LSB of 16-bit values</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_pipe_mode_valid">
enum <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="sig-name descname">mipi_dbi_pipe_mode_valid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a><em> *pipe</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_pipe_mode_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI mode-valid helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>Simple display pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>The mode to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function validates a given display mode against the MIPI DBI’s hardware
display. Drivers can use this as their <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe_funcs-&gt;mode_valid</span></code></a>
callback.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_pipe_update">
void <code class="sig-name descname">mipi_dbi_pipe_update</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a><em> *pipe</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *old_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_pipe_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Display pipe update helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>Simple display pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*old_state</span></code></dt><dd><p>Old plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles framebuffer flushing and vblank events. Drivers can use
this as their <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe_funcs-&gt;update</span></code></a> callback.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_enable_flush">
void <code class="sig-name descname">mipi_dbi_enable_flush</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi_dev" title="mipi_dbi_dev">mipi_dbi_dev</a><em> *dbidev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a><em> *crtc_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a><em> *plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_enable_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI enable helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi_dev</span> <span class="pre">*dbidev</span></code></dt><dd><p>MIPI DBI device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*crtc_state</span></code></dt><dd><p>CRTC state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*plane_state</span></code></dt><dd><p>Plane state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flushes the whole framebuffer and enables the backlight. Drivers can use this
in their <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe_funcs-&gt;enable</span></code></a> callback.</p>
<p><strong>Note</strong></p>
<p>Drivers which don’t use <a class="reference internal" href="#c.mipi_dbi_pipe_update" title="mipi_dbi_pipe_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_pipe_update()</span></code></a> because they have custom
framebuffer flushing, can’t use this function since they both use the same
flushing code.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_pipe_disable">
void <code class="sig-name descname">mipi_dbi_pipe_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe">drm_simple_display_pipe</a><em> *pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_pipe_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI pipe disable helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_simple_display_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>Display pipe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disables backlight if present, if not the display memory is
blanked. The regulator is disabled if in use. Drivers can use this as their
<a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe_funcs-&gt;disable</span></code></a> callback.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_dev_init_with_formats">
int <code class="sig-name descname">mipi_dbi_dev_init_with_formats</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi_dev" title="mipi_dbi_dev">mipi_dbi_dev</a><em> *dbidev</em>, const struct <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs">drm_simple_display_pipe_funcs</a><em> *funcs</em>, const uint32_t<em> *formats</em>, unsigned int<em> format_count</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em>, unsigned int<em> rotation</em>, size_t<em> tx_buf_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_dev_init_with_formats" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI device initialization with custom formats</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi_dev</span> <span class="pre">*dbidev</span></code></dt><dd><p>MIPI DBI device structure to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>Display pipe functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*formats</span></code></dt><dd><p>Array of supported formats (DRM_FORMAT_*).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">format_count</span></code></dt><dd><p>Number of elements in <strong>formats</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>Display mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt><dd><p>Initial rotation in degrees Counter Clock Wise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">tx_buf_size</span></code></dt><dd><p>Allocate a transmit buffer of this size.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets up a <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe</span></code></a> with a <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> that
has one fixed <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_mode</span></code></a> which is rotated according to <strong>rotation</strong>.
This mode is used to set the mode config min/max width/height properties.</p>
<p>Use <a class="reference internal" href="#c.mipi_dbi_dev_init" title="mipi_dbi_dev_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_dev_init()</span></code></a> if you don’t need custom formats.</p>
<p><strong>Note</strong></p>
<p>Some of the helper functions expects RGB565 to be the default format and the
transmit buffer sized to fit that.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_dev_init">
int <code class="sig-name descname">mipi_dbi_dev_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi_dev" title="mipi_dbi_dev">mipi_dbi_dev</a><em> *dbidev</em>, const struct <a class="reference internal" href="#c.drm_simple_display_pipe_funcs" title="drm_simple_display_pipe_funcs">drm_simple_display_pipe_funcs</a><em> *funcs</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em>, unsigned int<em> rotation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_dev_init" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI device initialization</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi_dev</span> <span class="pre">*dbidev</span></code></dt><dd><p>MIPI DBI device structure to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_simple_display_pipe_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>Display pipe functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>Display mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt><dd><p>Initial rotation in degrees Counter Clock Wise</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets up a <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_simple_display_pipe</span></code></a> with a <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector</span></code></a> that
has one fixed <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_mode</span></code></a> which is rotated according to <strong>rotation</strong>.
This mode is used to set the mode config min/max width/height properties.
Additionally <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dbi.tx_buf</span></code></a> is allocated.</p>
<p>Supported formats: Native RGB565 and emulated XRGB8888.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_hw_reset">
void <code class="sig-name descname">mipi_dbi_hw_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi">mipi_dbi</a><em> *dbi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_hw_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Hardware reset of controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi</span> <span class="pre">*dbi</span></code></dt><dd><p>MIPI DBI structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset controller if the <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dbi-&gt;reset</span></code></a> gpio is set.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_display_is_on">
bool <code class="sig-name descname">mipi_dbi_display_is_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi">mipi_dbi</a><em> *dbi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_display_is_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if display is on</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi</span> <span class="pre">*dbi</span></code></dt><dd><p>MIPI DBI structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks the Power Mode register (if readable) to see if
display output is turned on. This can be used to see if the bootloader
has already turned on the display avoiding flicker when the pipeline is
enabled.</p>
<p><strong>Return</strong></p>
<p>true if the display can be verified to be on, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_poweron_reset">
int <code class="sig-name descname">mipi_dbi_poweron_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi_dev" title="mipi_dbi_dev">mipi_dbi_dev</a><em> *dbidev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_poweron_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI poweron and reset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi_dev</span> <span class="pre">*dbidev</span></code></dt><dd><p>MIPI DBI device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables the regulator if used and does a hardware and software
reset.</p>
<p><strong>Return</strong></p>
<p>Zero on success, or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_poweron_conditional_reset">
int <code class="sig-name descname">mipi_dbi_poweron_conditional_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dbi_dev" title="mipi_dbi_dev">mipi_dbi_dev</a><em> *dbidev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_poweron_conditional_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>MIPI DBI poweron and conditional reset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi_dev</span> <span class="pre">*dbidev</span></code></dt><dd><p>MIPI DBI device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function enables the regulator if used and if the display is off, it
does a hardware and software reset. If <a class="reference internal" href="#c.mipi_dbi_display_is_on" title="mipi_dbi_display_is_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_display_is_on()</span></code></a> determines
that the display is on, no reset is performed.</p>
<p><strong>Return</strong></p>
<p>Zero if the controller was reset, 1 if the display was already on, or a
negative error code.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_spi_cmd_max_speed">
u32 <code class="sig-name descname">mipi_dbi_spi_cmd_max_speed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/spi.html#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_spi_cmd_max_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>get the maximum SPI bus speed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>SPI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>The transfer buffer length.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Many controllers have a max speed of 10MHz, but can be pushed way beyond
that. Increase reliability by running pixel data at max speed and the rest
at 10MHz, preventing transfer glitches from messing up the init settings.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_spi_init">
int <code class="sig-name descname">mipi_dbi_spi_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/spi.html#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, struct <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi">mipi_dbi</a><em> *dbi</em>, struct gpio_desc<em> *dc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_spi_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize MIPI DBI SPI interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>SPI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dbi</span> <span class="pre">*dbi</span></code></dt><dd><p>MIPI DBI structure to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*dc</span></code></dt><dd><p>D/C gpio (optional)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dbi-&gt;command</span></code></a>, enables <a class="reference internal" href="#c.mipi_dbi" title="mipi_dbi"><code class="xref c c-type docutils literal notranslate"><span class="pre">mipi_dbi-&gt;read_commands</span></code></a> for the
usual read commands. It should be followed by a call to <a class="reference internal" href="#c.mipi_dbi_dev_init" title="mipi_dbi_dev_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dbi_dev_init()</span></code></a> or
a driver-specific init.</p>
<p>If <strong>dc</strong> is set, a Type C Option 3 interface is assumed, if not
Type C Option 1.</p>
<p>If the SPI master driver doesn’t support the necessary bits per word,
the following transformation is used:</p>
<ul class="simple">
<li><p>9-bit: reorder buffer as 9x 8-bit words, padded with no-op command.</p></li>
<li><p>16-bit: if big endian send as 8-bit, if little endian swap bytes</p></li>
</ul>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_spi_transfer">
int <code class="sig-name descname">mipi_dbi_spi_transfer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/spi.html#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, u32<em> speed_hz</em>, u8<em> bpw</em>, const void<em> *buf</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_spi_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI transfer helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>SPI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">speed_hz</span></code></dt><dd><p>Override speed (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">bpw</span></code></dt><dd><p>Bits per word</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer to transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>Buffer length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This SPI transfer helper breaks up the transfer of <strong>buf</strong> into chunks which
the SPI controller driver can handle.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dbi_debugfs_init">
void <code class="sig-name descname">mipi_dbi_debugfs_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor">drm_minor</a><em> *minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dbi_debugfs_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Create debugfs entries</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_minor</span> <span class="pre">*minor</span></code></dt><dd><p>DRM minor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a ‘command’ debugfs file for sending commands to the
controller or getting the read command values.
Drivers can use this as their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_driver-&gt;debugfs_init</span></code></a> callback.</p>
</div>
</section>
<section id="mipi-dsi-helper-functions-reference">
<h2>MIPI DSI Helper Functions Reference<a class="headerlink" href="#mipi-dsi-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>These functions contain some common logic and helpers to deal with MIPI DSI
peripherals.</p>
<p>Helpers are provided for a number of standard MIPI DSI command as well as a
subset of the MIPI DCS command set.</p>
<dl class="type">
<dt id="c.mipi_dsi_msg">
struct <code class="sig-name descname">mipi_dsi_msg</code><a class="headerlink" href="#c.mipi_dsi_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>read/write DSI buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_msg {
    u8 channel;
    u8 type;
    u16 flags;
    size_t tx_len;
    const void *tx_buf;
    size_t rx_len;
    void *rx_buf;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>virtual channel id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>payload data type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags controlling this message transmission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_len</span></code></dt><dd><p>length of <strong>tx_buf</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_buf</span></code></dt><dd><p>data to be written</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_len</span></code></dt><dd><p>length of <strong>rx_buf</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_buf</span></code></dt><dd><p>data to be read, or NULL</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.mipi_dsi_packet">
struct <code class="sig-name descname">mipi_dsi_packet</code><a class="headerlink" href="#c.mipi_dsi_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a MIPI DSI packet in protocol format</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_packet {
    size_t size;
    u8 header[4];
    size_t payload_length;
    const u8 *payload;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>size (in bytes) of the packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header</span></code></dt><dd><p>the four bytes that make up the header (Data ID, Word Count or
Packet Data, and ECC)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payload_length</span></code></dt><dd><p>number of bytes in the payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">payload</span></code></dt><dd><p>a pointer to a buffer containing the payload, if any</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.mipi_dsi_host_ops">
struct <code class="sig-name descname">mipi_dsi_host_ops</code><a class="headerlink" href="#c.mipi_dsi_host_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI bus operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_host_ops {
    int (*attach)(struct mipi_dsi_host *host, struct mipi_dsi_device *dsi);
    int (*detach)(struct mipi_dsi_host *host, struct mipi_dsi_device *dsi);
    ssize_t (*transfer)(struct mipi_dsi_host *host, const struct mipi_dsi_msg *msg);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">attach</span></code></dt><dd><p>attach DSI device to DSI host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach</span></code></dt><dd><p>detach DSI device from DSI host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer</span></code></dt><dd><p>transmit a DSI packet</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>DSI packets transmitted by .transfer() are passed in as mipi_dsi_msg
structures. This structure contains information about the type of packet
being transmitted as well as the transmit and receive buffers. When an
error is encountered during transmission, this function will return a
negative error code. On success it shall return the number of bytes
transmitted for write packets or the number of bytes received for read
packets.</p>
<p>Note that typically DSI packet transmission is atomic, so the .transfer()
function will seldomly return anything other than the number of bytes
contained in the transmit buffer on success.</p>
<p>Also note that those callbacks can be called no matter the state the
host is in. Drivers that need the underlying device to be powered to
perform these operations will first need to make sure it’s been
properly enabled.</p>
<dl class="type">
<dt id="c.mipi_dsi_host">
struct <code class="sig-name descname">mipi_dsi_host</code><a class="headerlink" href="#c.mipi_dsi_host" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI host device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_host {
    struct device *dev;
    const struct mipi_dsi_host_ops *ops;
    struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>driver model device node for this DSI host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>DSI host operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>list management</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.mipi_dsi_device_info">
struct <code class="sig-name descname">mipi_dsi_device_info</code><a class="headerlink" href="#c.mipi_dsi_device_info" title="Permalink to this definition">¶</a></dt>
<dd><p>template for creating a mipi_dsi_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_device_info {
    char type[DSI_DEV_NAME_SIZE];
    u32 channel;
    struct device_node *node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>DSI peripheral chip type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>DSI virtual channel assigned to peripheral</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>pointer to OF device node or NULL</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is populated and passed to mipi_dsi_device_new to create a new
DSI device</p>
<dl class="type">
<dt id="c.mipi_dsi_device">
struct <code class="sig-name descname">mipi_dsi_device</code><a class="headerlink" href="#c.mipi_dsi_device" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI peripheral device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_device {
    struct mipi_dsi_host *host;
    struct device dev;
    char name[DSI_DEV_NAME_SIZE];
    unsigned int channel;
    unsigned int lanes;
    enum mipi_dsi_pixel_format format;
    unsigned long mode_flags;
    unsigned long hs_rate;
    unsigned long lp_rate;
    struct drm_dsc_config *dsc;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">host</span></code></dt><dd><p>DSI host for this peripheral</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>driver model device node for this peripheral</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>DSI peripheral chip type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>virtual channel assigned to the peripheral</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lanes</span></code></dt><dd><p>number of active data lanes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format</span></code></dt><dd><p>pixel format for video mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_flags</span></code></dt><dd><p>DSI operation mode related flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hs_rate</span></code></dt><dd><p>maximum lane frequency for high speed mode in hertz, this should
be set to the real limits of the hardware, zero is only accepted for
legacy drivers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lp_rate</span></code></dt><dd><p>maximum lane frequency for low power mode in hertz, this should
be set to the real limits of the hardware, zero is only accepted for
legacy drivers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dsc</span></code></dt><dd><p>panel/bridge DSC pps payload to be sent</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.mipi_dsi_pixel_format_to_bpp">
int <code class="sig-name descname">mipi_dsi_pixel_format_to_bpp</code><span class="sig-paren">(</span>enum mipi_dsi_pixel_format<em> fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_pixel_format_to_bpp" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the number of bits per pixel for any given pixel format defined by the MIPI DSI specification</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">mipi_dsi_pixel_format</span> <span class="pre">fmt</span></code></dt><dd><p>MIPI DSI pixel format</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bits per pixel of the given pixel format.</p>
</div>
<dl class="type">
<dt id="c.mipi_dsi_dcs_tear_mode">
enum <code class="sig-name descname">mipi_dsi_dcs_tear_mode</code><a class="headerlink" href="#c.mipi_dsi_dcs_tear_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Tearing Effect Output Line mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MIPI_DSI_DCS_TEAR_MODE_VBLANK</span></code></dt><dd><p>the TE output line consists of V-Blanking
information only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MIPI_DSI_DCS_TEAR_MODE_VHBLANK</span></code></dt><dd><p>the TE output line consists of both
V-Blanking and H-Blanking information</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_write_seq">
<code class="sig-name descname">mipi_dsi_dcs_write_seq</code><span class="sig-paren">(</span><em>dsi</em>, <em>cmd</em>, <em>seq…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_write_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit a DCS command with payload</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>Command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seq...</span></code></dt><dd><p>buffer containing data to be transmitted</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.mipi_dsi_driver">
struct <code class="sig-name descname">mipi_dsi_driver</code><a class="headerlink" href="#c.mipi_dsi_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mipi_dsi_driver {
    struct device_driver driver;
    int(*probe)(struct mipi_dsi_device *dsi);
    void (*remove)(struct mipi_dsi_device *dsi);
    void (*shutdown)(struct mipi_dsi_device *dsi);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>device driver model driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>callback for device binding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p>callback for device unbinding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p>called at shutdown time to quiesce the device</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.of_find_mipi_dsi_device_by_node">
struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> * <code class="sig-name descname">of_find_mipi_dsi_device_by_node</code><span class="sig-paren">(</span>struct device_node<em> *np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_mipi_dsi_device_by_node" title="Permalink to this definition">¶</a></dt>
<dd><p>find the MIPI DSI device matching a device tree node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>device tree node</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>A pointer to the MIPI DSI device corresponding to <strong>np</strong> or NULL if no</dt><dd><p>such device exists (or has not been registered yet).</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.mipi_dsi_device_register_full">
struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> * <code class="sig-name descname">mipi_dsi_device_register_full</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_host" title="mipi_dsi_host">mipi_dsi_host</a><em> *host</em>, const struct <a class="reference internal" href="#c.mipi_dsi_device_info" title="mipi_dsi_device_info">mipi_dsi_device_info</a><em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_device_register_full" title="Permalink to this definition">¶</a></dt>
<dd><p>create a MIPI DSI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_host</span> <span class="pre">*host</span></code></dt><dd><p>DSI host to which this device is connected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mipi_dsi_device_info</span> <span class="pre">*info</span></code></dt><dd><p>pointer to template containing DSI device information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a MIPI DSI device by using the device information provided by
mipi_dsi_device_info template</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created MIPI DSI device, or, a pointer encoded
with an error</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_device_unregister">
void <code class="sig-name descname">mipi_dsi_device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister MIPI DSI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.devm_mipi_dsi_device_register_full">
struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a> * <code class="sig-name descname">devm_mipi_dsi_device_register_full</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.mipi_dsi_host" title="mipi_dsi_host">mipi_dsi_host</a><em> *host</em>, const struct <a class="reference internal" href="#c.mipi_dsi_device_info" title="mipi_dsi_device_info">mipi_dsi_device_info</a><em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_mipi_dsi_device_register_full" title="Permalink to this definition">¶</a></dt>
<dd><p>create a managed MIPI DSI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to tie the MIPI-DSI device lifetime to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_host</span> <span class="pre">*host</span></code></dt><dd><p>DSI host to which this device is connected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mipi_dsi_device_info</span> <span class="pre">*info</span></code></dt><dd><p>pointer to template containing DSI device information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a MIPI DSI device by using the device information provided by
mipi_dsi_device_info template</p>
<p>This is the managed version of <a class="reference internal" href="#c.mipi_dsi_device_register_full" title="mipi_dsi_device_register_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dsi_device_register_full()</span></code></a> which
automatically calls <a class="reference internal" href="#c.mipi_dsi_device_unregister" title="mipi_dsi_device_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dsi_device_unregister()</span></code></a> when <strong>dev</strong> is
unbound.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created MIPI DSI device, or, a pointer encoded
with an error</p>
</div>
<dl class="function">
<dt id="c.of_find_mipi_dsi_host_by_node">
struct <a class="reference internal" href="#c.mipi_dsi_host" title="mipi_dsi_host">mipi_dsi_host</a> * <code class="sig-name descname">of_find_mipi_dsi_host_by_node</code><span class="sig-paren">(</span>struct device_node<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_find_mipi_dsi_host_by_node" title="Permalink to this definition">¶</a></dt>
<dd><p>find the MIPI DSI host matching a device tree node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt><dd><p>device tree node</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the MIPI DSI host corresponding to <strong>node</strong> or NULL if no
such device exists (or has not been registered yet).</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_attach">
int <code class="sig-name descname">mipi_dsi_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a DSI device to its DSI host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.mipi_dsi_detach">
int <code class="sig-name descname">mipi_dsi_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>detach a DSI device from its DSI host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.devm_mipi_dsi_attach">
int <code class="sig-name descname">devm_mipi_dsi_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_mipi_dsi_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a MIPI-DSI device to its DSI Host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to tie the MIPI-DSI device attachment lifetime to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the managed version of <a class="reference internal" href="#c.mipi_dsi_attach" title="mipi_dsi_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dsi_attach()</span></code></a> which automatically
calls <a class="reference internal" href="#c.mipi_dsi_detach" title="mipi_dsi_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">mipi_dsi_detach()</span></code></a> when <strong>dev</strong> is unbound.</p>
<p><strong>Return</strong></p>
<p>0 on success, a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_packet_format_is_short">
bool <code class="sig-name descname">mipi_dsi_packet_format_is_short</code><span class="sig-paren">(</span>u8<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_packet_format_is_short" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a packet is of the short format</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">type</span></code></dt><dd><p>MIPI DSI data type of the packet</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the packet for the given data type is a short packet, false
otherwise.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_packet_format_is_long">
bool <code class="sig-name descname">mipi_dsi_packet_format_is_long</code><span class="sig-paren">(</span>u8<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_packet_format_is_long" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a packet is of the long format</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">type</span></code></dt><dd><p>MIPI DSI data type of the packet</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the packet for the given data type is a long packet, false
otherwise.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_create_packet">
int <code class="sig-name descname">mipi_dsi_create_packet</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_packet" title="mipi_dsi_packet">mipi_dsi_packet</a><em> *packet</em>, const struct <a class="reference internal" href="#c.mipi_dsi_msg" title="mipi_dsi_msg">mipi_dsi_msg</a><em> *msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_create_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>create a packet from a message according to the DSI protocol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_packet</span> <span class="pre">*packet</span></code></dt><dd><p>pointer to a DSI packet structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">mipi_dsi_msg</span> <span class="pre">*msg</span></code></dt><dd><p>message to translate into a packet</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_shutdown_peripheral">
int <code class="sig-name descname">mipi_dsi_shutdown_peripheral</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_shutdown_peripheral" title="Permalink to this definition">¶</a></dt>
<dd><p>sends a Shutdown Peripheral command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_turn_on_peripheral">
int <code class="sig-name descname">mipi_dsi_turn_on_peripheral</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_turn_on_peripheral" title="Permalink to this definition">¶</a></dt>
<dd><p>sends a Turn On Peripheral command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_compression_mode">
ssize_t <code class="sig-name descname">mipi_dsi_compression_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_compression_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>enable/disable DSC on the peripheral</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>Whether to enable or disable the DSC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable or disable Display Stream Compression on the peripheral using the
default Picture Parameter Set and VESA DSC 1.1 algorithm.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_picture_parameter_set">
ssize_t <code class="sig-name descname">mipi_dsi_picture_parameter_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, const struct <a class="reference internal" href="#c.drm_dsc_picture_parameter_set" title="drm_dsc_picture_parameter_set">drm_dsc_picture_parameter_set</a><em> *pps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_picture_parameter_set" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit the DSC PPS to the peripheral</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_dsc_picture_parameter_set</span> <span class="pre">*pps</span></code></dt><dd><p>VESA DSC 1.1 Picture Parameter Set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Transmit the VESA DSC 1.1 Picture Parameter Set to the peripheral.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_generic_write">
ssize_t <code class="sig-name descname">mipi_dsi_generic_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, const void<em> *payload</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_generic_write" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit data using a generic write packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*payload</span></code></dt><dd><p>buffer containing the payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of payload buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the payload length.</p>
<p><strong>Return</strong></p>
<p>The number of bytes transmitted on success or a negative error code
on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_generic_read">
ssize_t <code class="sig-name descname">mipi_dsi_generic_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, const void<em> *params</em>, size_t<em> num_params</em>, void<em> *data</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_generic_read" title="Permalink to this definition">¶</a></dt>
<dd><p>receive data using a generic read packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*params</span></code></dt><dd><p>buffer containing the request parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num_params</span></code></dt><dd><p>number of request parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>buffer in which to return the received data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of receive buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the number of parameters passed in.</p>
<p><strong>Return</strong></p>
<p>The number of bytes successfully read or a negative error code on
failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_write_buffer">
ssize_t <code class="sig-name descname">mipi_dsi_dcs_write_buffer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, const void<em> *data</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_write_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit a DCS command with payload</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>buffer containing data to be transmitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>size of transmission buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the command payload length.</p>
<p><strong>Return</strong></p>
<p>The number of bytes successfully transmitted or a negative error
code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_write">
ssize_t <code class="sig-name descname">mipi_dsi_dcs_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, u8<em> cmd</em>, const void<em> *data</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_write" title="Permalink to this definition">¶</a></dt>
<dd><p>send DCS write command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>DCS command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>buffer containing the command payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>command payload length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will automatically choose the right data type depending on
the command payload length.</p>
<p><strong>Return</strong></p>
<p>The number of bytes successfully transmitted or a negative error
code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_read">
ssize_t <code class="sig-name descname">mipi_dsi_dcs_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, u8<em> cmd</em>, void<em> *data</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_read" title="Permalink to this definition">¶</a></dt>
<dd><p>send DCS read request command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>DCS command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>buffer in which to receive data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>size of receive buffer</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bytes read or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_nop">
int <code class="sig-name descname">mipi_dsi_dcs_nop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_nop" title="Permalink to this definition">¶</a></dt>
<dd><p>send DCS nop packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_soft_reset">
int <code class="sig-name descname">mipi_dsi_dcs_soft_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_soft_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a software reset of the display module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_get_power_mode">
int <code class="sig-name descname">mipi_dsi_dcs_get_power_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, u8<em> *mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_get_power_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>query the display module’s current power mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*mode</span></code></dt><dd><p>return location for the current power mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_get_pixel_format">
int <code class="sig-name descname">mipi_dsi_dcs_get_pixel_format</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, u8<em> *format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_get_pixel_format" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the pixel format for the RGB image data used by the interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*format</span></code></dt><dd><p>return location for the pixel format</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_enter_sleep_mode">
int <code class="sig-name descname">mipi_dsi_dcs_enter_sleep_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_enter_sleep_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>disable all unnecessary blocks inside the display module except interface communication</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_exit_sleep_mode">
int <code class="sig-name descname">mipi_dsi_dcs_exit_sleep_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_exit_sleep_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>enable all blocks inside the display module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_display_off">
int <code class="sig-name descname">mipi_dsi_dcs_set_display_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_display_off" title="Permalink to this definition">¶</a></dt>
<dd><p>stop displaying the image data on the display device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_display_on">
int <code class="sig-name descname">mipi_dsi_dcs_set_display_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_display_on" title="Permalink to this definition">¶</a></dt>
<dd><p>start displaying the image data on the display device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_column_address">
int <code class="sig-name descname">mipi_dsi_dcs_set_column_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, u16<em> start</em>, u16<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_column_address" title="Permalink to this definition">¶</a></dt>
<dd><p>define the column extent of the frame memory accessed by the host processor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">start</span></code></dt><dd><p>first column of frame memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">end</span></code></dt><dd><p>last column of frame memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_page_address">
int <code class="sig-name descname">mipi_dsi_dcs_set_page_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, u16<em> start</em>, u16<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_page_address" title="Permalink to this definition">¶</a></dt>
<dd><p>define the page extent of the frame memory accessed by the host processor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">start</span></code></dt><dd><p>first page of frame memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">end</span></code></dt><dd><p>last page of frame memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_tear_off">
int <code class="sig-name descname">mipi_dsi_dcs_set_tear_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_tear_off" title="Permalink to this definition">¶</a></dt>
<dd><p>turn off the display module’s Tearing Effect output signal on the TE signal line</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_tear_on">
int <code class="sig-name descname">mipi_dsi_dcs_set_tear_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, enum <a class="reference internal" href="#c.mipi_dsi_dcs_tear_mode" title="mipi_dsi_dcs_tear_mode">mipi_dsi_dcs_tear_mode</a><em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_tear_on" title="Permalink to this definition">¶</a></dt>
<dd><p>turn on the display module’s Tearing Effect output signal on the TE signal line.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">mipi_dsi_dcs_tear_mode</span> <span class="pre">mode</span></code></dt><dd><p>the Tearing Effect Output Line mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_pixel_format">
int <code class="sig-name descname">mipi_dsi_dcs_set_pixel_format</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, u8<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_pixel_format" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the pixel format for the RGB image data used by the interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">format</span></code></dt><dd><p>pixel format</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_tear_scanline">
int <code class="sig-name descname">mipi_dsi_dcs_set_tear_scanline</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, u16<em> scanline</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_tear_scanline" title="Permalink to this definition">¶</a></dt>
<dd><p>set the scanline to use as trigger for the Tearing Effect output signal of the display module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">scanline</span></code></dt><dd><p>scanline to use as trigger</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_set_display_brightness">
int <code class="sig-name descname">mipi_dsi_dcs_set_display_brightness</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, u16<em> brightness</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_set_display_brightness" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the brightness value of the display</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">brightness</span></code></dt><dd><p>brightness value</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_dcs_get_display_brightness">
int <code class="sig-name descname">mipi_dsi_dcs_get_display_brightness</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_device" title="mipi_dsi_device">mipi_dsi_device</a><em> *dsi</em>, u16<em> *brightness</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_dcs_get_display_brightness" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the current brightness value of the display</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_device</span> <span class="pre">*dsi</span></code></dt><dd><p>DSI peripheral device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*brightness</span></code></dt><dd><p>brightness value</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_driver_register_full">
int <code class="sig-name descname">mipi_dsi_driver_register_full</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_driver" title="mipi_dsi_driver">mipi_dsi_driver</a><em> *drv</em>, struct module<em> *owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_driver_register_full" title="Permalink to this definition">¶</a></dt>
<dd><p>register a driver for DSI devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_driver</span> <span class="pre">*drv</span></code></dt><dd><p>DSI driver structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owner module</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.mipi_dsi_driver_unregister">
void <code class="sig-name descname">mipi_dsi_driver_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mipi_dsi_driver" title="mipi_dsi_driver">mipi_dsi_driver</a><em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_driver_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a driver for DSI devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mipi_dsi_driver</span> <span class="pre">*drv</span></code></dt><dd><p>DSI driver structure</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
</section>
<section id="display-stream-compression-helper-functions-reference">
<h2>Display Stream Compression Helper Functions Reference<a class="headerlink" href="#display-stream-compression-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>VESA specification for DP 1.4 adds a new feature called Display Stream
Compression (DSC) used to compress the pixel bits before sending it on
DP/eDP/MIPI DSI interface. DSC is required to be enabled so that the existing
display interfaces can support high resolutions at higher frames rates uisng
the maximum available link capacity of these interfaces.</p>
<p>These functions contain some common logic and helpers to deal with VESA
Display Stream Compression standard required for DSC on Display Port/eDP or
MIPI display interfaces.</p>
<dl class="type">
<dt id="c.drm_dsc_rc_range_parameters">
struct <code class="sig-name descname">drm_dsc_rc_range_parameters</code><a class="headerlink" href="#c.drm_dsc_rc_range_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>DSC Rate Control range parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dsc_rc_range_parameters {
    u8 range_min_qp;
    u8 range_max_qp;
    u8 range_bpg_offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">range_min_qp</span></code></dt><dd><p>Min Quantization Parameters allowed for this range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">range_max_qp</span></code></dt><dd><p>Max Quantization Parameters allowed for this range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">range_bpg_offset</span></code></dt><dd><p>Bits/group offset to apply to target for this group</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This defines different rate control parameters used by the DSC engine
to compress the frame.</p>
<dl class="type">
<dt id="c.drm_dsc_config">
struct <code class="sig-name descname">drm_dsc_config</code><a class="headerlink" href="#c.drm_dsc_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters required to configure DSC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dsc_config {
    u8 line_buf_depth;
    u8 bits_per_component;
    bool convert_rgb;
    u8 slice_count;
    u16 slice_width;
    u16 slice_height;
    bool simple_422;
    u16 pic_width;
    u16 pic_height;
    u8 rc_tgt_offset_high;
    u8 rc_tgt_offset_low;
    u16 bits_per_pixel;
    u8 rc_edge_factor;
    u8 rc_quant_incr_limit1;
    u8 rc_quant_incr_limit0;
    u16 initial_xmit_delay;
    u16 initial_dec_delay;
    bool block_pred_enable;
    u8 first_line_bpg_offset;
    u16 initial_offset;
    u16 rc_buf_thresh[DSC_NUM_BUF_RANGES - 1];
    struct drm_dsc_rc_range_parameters rc_range_params[DSC_NUM_BUF_RANGES];
    u16 rc_model_size;
    u8 flatness_min_qp;
    u8 flatness_max_qp;
    u8 initial_scale_value;
    u16 scale_decrement_interval;
    u16 scale_increment_interval;
    u16 nfl_bpg_offset;
    u16 slice_bpg_offset;
    u16 final_offset;
    bool vbr_enable;
    u8 mux_word_size;
    u16 slice_chunk_size;
    u16 rc_bits;
    u8 dsc_version_minor;
    u8 dsc_version_major;
    bool native_422;
    bool native_420;
    u8 second_line_bpg_offset;
    u16 nsl_bpg_offset;
    u16 second_line_offset_adj;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">line_buf_depth</span></code></dt><dd><p>Bits per component for previous reconstructed line buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_component</span></code></dt><dd><p>Bits per component to code (8/10/12)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">convert_rgb</span></code></dt><dd><p>Flag to indicate if RGB - YCoCg conversion is needed
True if RGB input, False if YCoCg input</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_count</span></code></dt><dd><p>Number fo slices per line used by the DSC encoder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_width</span></code></dt><dd><p>Width of each slice in pixels</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_height</span></code></dt><dd><p>Slice height in pixels</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">simple_422</span></code></dt><dd><p>True if simple 4_2_2 mode is enabled else False</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pic_width</span></code></dt><dd><p>Width of the input display frame in pixels</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pic_height</span></code></dt><dd><p>Vertical height of the input display frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_tgt_offset_high</span></code></dt><dd><p>Offset to bits/group used by RC to determine QP adjustment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_tgt_offset_low</span></code></dt><dd><p>Offset to bits/group used by RC to determine QP adjustment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_pixel</span></code></dt><dd><p>Target bits per pixel with 4 fractional bits, bits_per_pixel &lt;&lt; 4</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_edge_factor</span></code></dt><dd><p>Factor to determine if an edge is present based on the bits produced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_quant_incr_limit1</span></code></dt><dd><p>Slow down incrementing once the range reaches this value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_quant_incr_limit0</span></code></dt><dd><p>Slow down incrementing once the range reaches this value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_xmit_delay</span></code></dt><dd><p>Number of pixels to delay the initial transmission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_dec_delay</span></code></dt><dd><p>Initial decoder delay, number of pixel times that the decoder
accumulates data in its rate buffer before starting to decode
and output pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block_pred_enable</span></code></dt><dd><p>True if block prediction is used to code any groups within the
picture. False if BP not used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">first_line_bpg_offset</span></code></dt><dd><p>Number of additional bits allocated for each group on the first
line of slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_offset</span></code></dt><dd><p>Value to use for RC model offset at slice start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_buf_thresh</span></code></dt><dd><p>Thresholds defining each of the buffer ranges</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_range_params</span></code></dt><dd><p>Parameters for each of the RC ranges defined in
<a class="reference internal" href="#c.drm_dsc_rc_range_parameters" title="drm_dsc_rc_range_parameters"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_rc_range_parameters</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_model_size</span></code></dt><dd><p>Total size of RC model</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flatness_min_qp</span></code></dt><dd><p>Minimum QP where flatness information is sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flatness_max_qp</span></code></dt><dd><p>Maximum QP where flatness information is sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_scale_value</span></code></dt><dd><p>Initial value for the scale factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scale_decrement_interval</span></code></dt><dd><p>Specifies number of group times between decrementing the scale factor
at beginning of a slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scale_increment_interval</span></code></dt><dd><p>Number of group times between incrementing the scale factor value
used at the beginning of a slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nfl_bpg_offset</span></code></dt><dd><p>Non first line BPG offset to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_bpg_offset</span></code></dt><dd><p>BPG offset used to enforce slice bit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">final_offset</span></code></dt><dd><p>Final RC linear transformation offset value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vbr_enable</span></code></dt><dd><p>True if VBR mode is enabled, false if disabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mux_word_size</span></code></dt><dd><p>Mux word size (in bits) for SSM mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_chunk_size</span></code></dt><dd><p>The (max) size in bytes of the “chunks” that are used in slice
multiplexing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_bits</span></code></dt><dd><p>Rate control buffer size in bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dsc_version_minor</span></code></dt><dd><p>DSC minor version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dsc_version_major</span></code></dt><dd><p>DSC major version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">native_422</span></code></dt><dd><p>True if Native 4:2:2 supported, else false</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">native_420</span></code></dt><dd><p>True if Native 4:2:0 supported else false.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">second_line_bpg_offset</span></code></dt><dd><p>Additional bits/grp for seconnd line of slice for native 4:2:0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nsl_bpg_offset</span></code></dt><dd><p>Num of bits deallocated for each grp that is not in second line of
slice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">second_line_offset_adj</span></code></dt><dd><p>Offset adjustment for second line in Native 4:2:0 mode</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Driver populates this structure with all the parameters required
to configure the display stream compression on the source.</p>
<dl class="type">
<dt id="c.drm_dsc_picture_parameter_set">
struct <code class="sig-name descname">drm_dsc_picture_parameter_set</code><a class="headerlink" href="#c.drm_dsc_picture_parameter_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents 128 bytes of Picture Parameter Set</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dsc_picture_parameter_set {
    u8 dsc_version;
    u8 pps_identifier;
    u8 pps_reserved;
    u8 pps_3;
    u8 pps_4;
    u8 bits_per_pixel_low;
    __be16 pic_height;
    __be16 pic_width;
    __be16 slice_height;
    __be16 slice_width;
    __be16 chunk_size;
    u8 initial_xmit_delay_high;
    u8 initial_xmit_delay_low;
    __be16 initial_dec_delay;
    u8 pps20_reserved;
    u8 initial_scale_value;
    __be16 scale_increment_interval;
    u8 scale_decrement_interval_high;
    u8 scale_decrement_interval_low;
    u8 pps26_reserved;
    u8 first_line_bpg_offset;
    __be16 nfl_bpg_offset;
    __be16 slice_bpg_offset;
    __be16 initial_offset;
    __be16 final_offset;
    u8 flatness_min_qp;
    u8 flatness_max_qp;
    __be16 rc_model_size;
    u8 rc_edge_factor;
    u8 rc_quant_incr_limit0;
    u8 rc_quant_incr_limit1;
    u8 rc_tgt_offset;
    u8 rc_buf_thresh[DSC_NUM_BUF_RANGES - 1];
    __be16 rc_range_parameters[DSC_NUM_BUF_RANGES];
    u8 native_422_420;
    u8 second_line_bpg_offset;
    __be16 nsl_bpg_offset;
    __be16 second_line_offset_adj;
    u32 pps_long_94_reserved;
    u32 pps_long_98_reserved;
    u32 pps_long_102_reserved;
    u32 pps_long_106_reserved;
    u32 pps_long_110_reserved;
    u32 pps_long_114_reserved;
    u32 pps_long_118_reserved;
    u32 pps_long_122_reserved;
    __be16 pps_short_126_reserved;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dsc_version</span></code></dt><dd><p>PPS0[3:0] - dsc_version_minor: Contains Minor version of DSC
PPS0[7:4] - dsc_version_major: Contains major version of DSC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_identifier</span></code></dt><dd><p>PPS1[7:0] - Application specific identifier that can be
used to differentiate between different PPS tables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_reserved</span></code></dt><dd><p>PPS2[7:0]- RESERVED Byte</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_3</span></code></dt><dd><p>PPS3[3:0] - linebuf_depth: Contains linebuffer bit depth used to
generate the bitstream. (0x0 - 16 bits for DSC 1.2, 0x8 - 8 bits,
0xA - 10 bits, 0xB - 11 bits, 0xC - 12 bits, 0xD - 13 bits,
0xE - 14 bits for DSC1.2, 0xF - 14 bits for DSC 1.2.
PPS3[7:4] - bits_per_component: Bits per component for the original
pixels of the encoded picture.
0x0 = 16bpc (allowed only when dsc_version_minor = 0x2)
0x8 = 8bpc, 0xA = 10bpc, 0xC = 12bpc, 0xE = 14bpc (also
allowed only when dsc_minor_version = 0x2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_4</span></code></dt><dd><p>PPS4[1:0] -These are the most significant 2 bits of
compressed BPP bits_per_pixel[9:0] syntax element.
PPS4[2] - vbr_enable: 0 = VBR disabled, 1 = VBR enabled
PPS4[3] - simple_422: Indicates if decoder drops samples to
reconstruct the 4:2:2 picture.
PPS4[4] - Convert_rgb: Indicates if DSC color space conversion is
active.
PPS4[5] - blobk_pred_enable: Indicates if BP is used to code any
groups in picture
PPS4[7:6] - Reseved bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_pixel_low</span></code></dt><dd><p>PPS5[7:0] - This indicates the lower significant 8 bits of
the compressed BPP bits_per_pixel[9:0] element.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pic_height</span></code></dt><dd><p>PPS6[7:0], PPS7[7:0] -pic_height: Specifies the number of pixel rows
within the raster.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pic_width</span></code></dt><dd><p>PPS8[7:0], PPS9[7:0] - pic_width: Number of pixel columns within
the raster.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_height</span></code></dt><dd><p>PPS10[7:0], PPS11[7:0] - Slice height in units of pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_width</span></code></dt><dd><p>PPS12[7:0], PPS13[7:0] - Slice width in terms of pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chunk_size</span></code></dt><dd><p>PPS14[7:0], PPS15[7:0] - Size in units of bytes of the chunks
that are used for slice multiplexing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_xmit_delay_high</span></code></dt><dd><p>PPS16[1:0] - Most Significant two bits of initial transmission delay.
It specifies the number of pixel times that the encoder waits before
transmitting data from its rate buffer.
PPS16[7:2] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_xmit_delay_low</span></code></dt><dd><p>PPS17[7:0] - Least significant 8 bits of initial transmission delay.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_dec_delay</span></code></dt><dd><p>PPS18[7:0], PPS19[7:0] - Initial decoding delay which is the number
of pixel times that the decoder accumulates data in its rate buffer
before starting to decode and output pixels.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps20_reserved</span></code></dt><dd><p>PPS20[7:0] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_scale_value</span></code></dt><dd><p>PPS21[5:0] - Initial rcXformScale factor used at beginning
of a slice.
PPS21[7:6] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scale_increment_interval</span></code></dt><dd><p>PPS22[7:0], PPS23[7:0] - Number of group times between incrementing
the rcXformScale factor at end of a slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scale_decrement_interval_high</span></code></dt><dd><p>PPS24[3:0] - Higher 4 bits indicating number of group times between
decrementing the rcXformScale factor at beginning of a slice.
PPS24[7:4] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scale_decrement_interval_low</span></code></dt><dd><p>PPS25[7:0] - Lower 8 bits of scale decrement interval</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps26_reserved</span></code></dt><dd><p>PPS26[7:0]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">first_line_bpg_offset</span></code></dt><dd><p>PPS27[4:0] - Number of additional bits that are allocated
for each group on first line of a slice.
PPS27[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nfl_bpg_offset</span></code></dt><dd><p>PPS28[7:0], PPS29[7:0] - Number of bits including frac bits
deallocated for each group for groups after the first line of slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slice_bpg_offset</span></code></dt><dd><p>PPS30, PPS31[7:0] - Number of bits that are deallocated for each
group to enforce the slice constraint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_offset</span></code></dt><dd><p>PPS32,33[7:0] - Initial value for rcXformOffset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">final_offset</span></code></dt><dd><p>PPS34,35[7:0] - Maximum end-of-slice value for rcXformOffset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flatness_min_qp</span></code></dt><dd><p>PPS36[4:0] - Minimum QP at which flatness is signaled and
flatness QP adjustment is made.
PPS36[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flatness_max_qp</span></code></dt><dd><p>PPS37[4:0] - Max QP at which flatness is signalled and
the flatness adjustment is made.
PPS37[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_model_size</span></code></dt><dd><p>PPS38,39[7:0] - Number of bits within RC Model.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_edge_factor</span></code></dt><dd><p>PPS40[3:0] - Ratio of current activity vs, previous
activity to determine presence of edge.
PPS40[7:4] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_quant_incr_limit0</span></code></dt><dd><p>PPS41[4:0] - QP threshold used in short term RC
PPS41[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_quant_incr_limit1</span></code></dt><dd><p>PPS42[4:0] - QP threshold used in short term RC
PPS42[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_tgt_offset</span></code></dt><dd><p>PPS43[3:0] - Lower end of the variability range around the target
bits per group that is allowed by short term RC.
PPS43[7:4]- Upper end of the variability range around the target
bits per group that i allowed by short term rc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_buf_thresh</span></code></dt><dd><p>PPS44[7:0] - PPS57[7:0] - Specifies the thresholds in RC model for
the 15 ranges defined by 14 thresholds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_range_parameters</span></code></dt><dd><p>PPS58[7:0] - PPS87[7:0]
Parameters that correspond to each of the 15 ranges.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">native_422_420</span></code></dt><dd><p>PPS88[0] - 0 = Native 4:2:2 not used
1 = Native 4:2:2 used
PPS88[1] - 0 = Native 4:2:0 not use
1 = Native 4:2:0 used
PPS88[7:2] - Reserved 6 bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">second_line_bpg_offset</span></code></dt><dd><p>PPS89[4:0] - Additional bits/group budget for the
second line of a slice in Native 4:2:0 mode.
Set to 0 if DSC minor version is 1 or native420 is 0.
PPS89[7:5] - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nsl_bpg_offset</span></code></dt><dd><p>PPS90[7:0], PPS91[7:0] - Number of bits that are deallocated
for each group that is not in the second line of a slice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">second_line_offset_adj</span></code></dt><dd><p>PPS92[7:0], PPS93[7:0] - Used as offset adjustment for the second
line in Native 4:2:0 mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_94_reserved</span></code></dt><dd><p>PPS 94, 95, 96, 97 - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_98_reserved</span></code></dt><dd><p>PPS 98, 99, 100, 101 - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_102_reserved</span></code></dt><dd><p>PPS 102, 103, 104, 105 - Reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_106_reserved</span></code></dt><dd><p>PPS 106, 107, 108, 109 - reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_110_reserved</span></code></dt><dd><p>PPS 110, 111, 112, 113 - reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_114_reserved</span></code></dt><dd><p>PPS 114 - 117 - reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_118_reserved</span></code></dt><dd><p>PPS 118 - 121 - reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_long_122_reserved</span></code></dt><dd><p>PPS 122- 125 - reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_short_126_reserved</span></code></dt><dd><p>PPS 126, 127 - reserved</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The VESA DSC standard defines picture parameter set (PPS) which display
stream compression encoders must communicate to decoders.
The PPS is encapsulated in 128 bytes (PPS 0 through PPS 127). The fields in
this structure are as per Table 4.1 in Vesa DSC specification v1.1/v1.2.
The PPS fields that span over more than a byte should be stored in Big Endian
format.</p>
<dl class="type">
<dt id="c.drm_dsc_pps_infoframe">
struct <code class="sig-name descname">drm_dsc_pps_infoframe</code><a class="headerlink" href="#c.drm_dsc_pps_infoframe" title="Permalink to this definition">¶</a></dt>
<dd><p>DSC infoframe carrying the Picture Parameter Set Metadata</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_dsc_pps_infoframe {
    struct dp_sdp_header pps_header;
    struct drm_dsc_picture_parameter_set pps_payload;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pps_header</span></code></dt><dd><p>Header for PPS as per DP SDP header format of type
<a class="reference internal" href="#c.dp_sdp_header" title="dp_sdp_header"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dp_sdp_header</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps_payload</span></code></dt><dd><p>PPS payload fields as per DSC specification Table 4-1
as represented in <a class="reference internal" href="#c.drm_dsc_picture_parameter_set" title="drm_dsc_picture_parameter_set"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_picture_parameter_set</span></code></a></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure represents the DSC PPS infoframe required to send the Picture
Parameter Set metadata required before enabling VESA Display Stream
Compression. This is based on the DP Secondary Data Packet structure and
comprises of SDP Header as defined <a class="reference internal" href="#c.dp_sdp_header" title="dp_sdp_header"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dp_sdp_header</span></code></a> in drm_dp_helper.h
and PPS payload defined in <a class="reference internal" href="#c.drm_dsc_picture_parameter_set" title="drm_dsc_picture_parameter_set"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_picture_parameter_set</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_dsc_dp_pps_header_init">
void <code class="sig-name descname">drm_dsc_dp_pps_header_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dp_sdp_header" title="dp_sdp_header">dp_sdp_header</a><em> *pps_header</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dsc_dp_pps_header_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the PPS Header for DisplayPort as per the DP 1.4 spec.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dp_sdp_header</span> <span class="pre">*pps_header</span></code></dt><dd><p>Secondary data packet header for DSC Picture
Parameter Set as defined in <a class="reference internal" href="#c.dp_sdp_header" title="dp_sdp_header"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dp_sdp_header</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>DP 1.4 spec defines the secondary data packet for sending the
picture parameter infoframes from the source to the sink.
This function populates the SDP header defined in
<a class="reference internal" href="#c.dp_sdp_header" title="dp_sdp_header"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dp_sdp_header</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_dsc_dp_rc_buffer_size">
int <code class="sig-name descname">drm_dsc_dp_rc_buffer_size</code><span class="sig-paren">(</span>u8<em> rc_buffer_block_size</em>, u8<em> rc_buffer_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dsc_dp_rc_buffer_size" title="Permalink to this definition">¶</a></dt>
<dd><p>get rc buffer size in bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">rc_buffer_block_size</span></code></dt><dd><p>block size code, according to DPCD offset 62h</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">rc_buffer_size</span></code></dt><dd><p>number of blocks - 1, according to DPCD offset 63h</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>buffer size in bytes, or 0 on invalid input</p>
</div>
<dl class="function">
<dt id="c.drm_dsc_pps_payload_pack">
void <code class="sig-name descname">drm_dsc_pps_payload_pack</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dsc_picture_parameter_set" title="drm_dsc_picture_parameter_set">drm_dsc_picture_parameter_set</a><em> *pps_payload</em>, const struct <a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config">drm_dsc_config</a><em> *dsc_cfg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dsc_pps_payload_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>Populates the DSC PPS</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_picture_parameter_set</span> <span class="pre">*pps_payload</span></code></p>
<blockquote>
<div><p>Bitwise struct for DSC Picture Parameter Set. This is defined
by <a class="reference internal" href="#c.drm_dsc_picture_parameter_set" title="drm_dsc_picture_parameter_set"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_picture_parameter_set</span></code></a></p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_dsc_config</span> <span class="pre">*dsc_cfg</span></code></p>
<blockquote>
<div><p>DSC Configuration data filled by driver as defined by
<a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span></code></a></p>
</div></blockquote>
<p><strong>Description</strong></p>
<p>DSC source device sends a picture parameter set (PPS) containing the
information required by the sink to decode the compressed frame. Driver
populates the DSC PPS struct using the DSC configuration parameters in
the order expected by the DSC Display Sink device. For the DSC, the sink
device expects the PPS payload in big endian format for fields
that span more than 1 byte.</p>
</div>
<dl class="function">
<dt id="c.drm_dsc_compute_rc_parameters">
int <code class="sig-name descname">drm_dsc_compute_rc_parameters</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config">drm_dsc_config</a><em> *vdsc_cfg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dsc_compute_rc_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Write rate control parameters to the dsc configuration defined in <a class="reference internal" href="#c.drm_dsc_config" title="drm_dsc_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span></code></a> in accordance with the DSC 1.2 specification. Some configuration fields must be present beforehand.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_dsc_config</span> <span class="pre">*vdsc_cfg</span></code></p>
<blockquote>
<div><p>DSC Configuration data partially filled by driver</p>
</div></blockquote>
</div>
</section>
<section id="output-probing-helper-functions-reference">
<h2>Output Probing Helper Functions Reference<a class="headerlink" href="#output-probing-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>This library provides some helper code for output probing. It provides an
implementation of the core <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.fill_modes</span></code></a> interface with
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a>.</p>
<p>It also provides support for polling connectors with a work item and for
generic hotplug interrupt handling where the driver doesn’t or cannot keep
track of a per-connector hpd interrupt.</p>
<p>This helper library can be used independently of the modeset helper library.
Drivers can also overwrite different parts e.g. use their own hotplug
handling code to avoid probing unrelated outputs.</p>
<p>The probe helpers share the function table structures with other display
helper libraries. See <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector_helper_funcs</span></code></a> for the details.</p>
<dl class="function">
<dt id="c.drm_kms_helper_poll_enable">
void <code class="sig-name descname">drm_kms_helper_poll_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>re-enable output polling.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function re-enables the output polling work, after it has been
temporarily disabled using <a class="reference internal" href="#c.drm_kms_helper_poll_disable" title="drm_kms_helper_poll_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_disable()</span></code></a>, for example over
suspend/resume.</p>
<p>Drivers can call this helper from their device resume implementation. It is
not an error to call this even when output polling isn’t enabled.</p>
<p>Note that calls to enable and disable polling must be strictly ordered, which
is automatically the case when they’re only call from suspend/resume
callbacks.</p>
</div>
<dl class="function">
<dt id="c.drm_helper_probe_detect">
int <code class="sig-name descname">drm_helper_probe_detect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em>, bool<em> force</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_probe_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>probe connector status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to probe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>acquire_ctx, or NULL to let this function handle locking.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force</span></code></dt><dd><p>Whether destructive probe operations should be performed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function calls the detect callbacks of the connector.
This function returns <a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_status</span></code></a>, or
if <strong>ctx</strong> is set, it might also return -EDEADLK.</p>
</div>
<dl class="function">
<dt id="c.drm_helper_probe_single_connector_modes">
int <code class="sig-name descname">drm_helper_probe_single_connector_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, uint32_t<em> maxX</em>, uint32_t<em> maxY</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_probe_single_connector_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>get complete set of display modes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector to probe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">maxX</span></code></dt><dd><p>max width for modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">maxY</span></code></dt><dd><p>max height for modes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Based on the helper callbacks implemented by <strong>connector</strong> in struct
<a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs</span></code></a> try to detect all valid modes.  Modes will first
be added to the connector’s probed_modes list, then culled (based on validity
and the <strong>maxX</strong>, <strong>maxY</strong> parameters) and put into the normal modes list.</p>
<p>Intended to be used as a generic implementation of the
<a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.fill_modes()</span></code></a> vfunc for drivers that use the CRTC helpers
for output mode filtering and detection.</p>
<p>The basic procedure is as follows</p>
<ol class="arabic">
<li><p>All modes currently on the connector’s modes list are marked as stale</p></li>
<li><p>New modes are added to the connector’s probed_modes list with
<a class="reference internal" href="drm-kms.html#c.drm_mode_probed_add" title="drm_mode_probed_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_probed_add()</span></code></a>. New modes start their life with status as OK.
Modes are added from a single source using the following priority order.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.get_modes</span></code></a> vfunc</p></li>
<li><p>if the connector status is connector_status_connected, standard
VESA DMT modes up to 1024x768 are automatically added
(<a class="reference internal" href="#c.drm_add_modes_noedid" title="drm_add_modes_noedid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_add_modes_noedid()</span></code></a>)</p></li>
</ul>
<p>Finally modes specified via the kernel command line (video=…) are
added in addition to what the earlier probes produced
(drm_helper_probe_add_cmdline_mode()). These modes are generated
using the VESA GTF/CVT formulas.</p>
</li>
<li><p>Modes are moved from the probed_modes list to the modes list. Potential
duplicates are merged together (see <a class="reference internal" href="drm-kms.html#c.drm_connector_list_update" title="drm_connector_list_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_list_update()</span></code></a>).
After this step the probed_modes list will be empty again.</p></li>
<li><p>Any non-stale mode on the modes list then undergoes validation</p>
<ul class="simple">
<li><p>drm_mode_validate_basic() performs basic sanity checks</p></li>
<li><p><a class="reference internal" href="drm-kms.html#c.drm_mode_validate_size" title="drm_mode_validate_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_validate_size()</span></code></a> filters out modes larger than <strong>maxX</strong> and <strong>maxY</strong>
(if specified)</p></li>
<li><p>drm_mode_validate_flag() checks the modes against basic connector
capabilities (interlace_allowed,doublescan_allowed,stereo_allowed)</p></li>
<li><p>the optional <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.mode_valid</span></code></a> or
<a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.mode_valid_ctx</span></code></a> helpers can perform driver
and/or sink specific checks</p></li>
<li><p>the optional <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.mode_valid</span></code></a>,
<a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a> and <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.mode_valid</span></code></a>
helpers can perform driver and/or source specific checks which are also
enforced by the modeset/atomic helpers</p></li>
</ul>
</li>
<li><p>Any mode whose status is not OK is pruned from the connector’s modes list,
accompanied by a debug message indicating the reason for the mode’s
rejection (see <a class="reference internal" href="drm-kms.html#c.drm_mode_prune_invalid" title="drm_mode_prune_invalid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_mode_prune_invalid()</span></code></a>).</p></li>
</ol>
<p><strong>Return</strong></p>
<p>The number of modes found on <strong>connector</strong>.</p>
</div>
<dl class="function">
<dt id="c.drm_kms_helper_hotplug_event">
void <code class="sig-name descname">drm_kms_helper_hotplug_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_hotplug_event" title="Permalink to this definition">¶</a></dt>
<dd><p>fire off KMS hotplug events</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device whose connector state changed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function fires off the uevent for userspace and also calls the
output_poll_changed function, which is most commonly used to inform the fbdev
emulation code and allow it to update the fbcon output configuration.</p>
<p>Drivers should call this from their hotplug handling code when a change is
detected. Note that this function does not do any output detection of its
own, like <a class="reference internal" href="#c.drm_helper_hpd_irq_event" title="drm_helper_hpd_irq_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_hpd_irq_event()</span></code></a> does - this is assumed to be done by the
driver already.</p>
<p>This function must be called from process context with no mode
setting locks held.</p>
<p>If only a single connector has changed, consider calling
<a class="reference internal" href="#c.drm_kms_helper_connector_hotplug_event" title="drm_kms_helper_connector_hotplug_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_connector_hotplug_event()</span></code></a> instead.</p>
</div>
<dl class="function">
<dt id="c.drm_kms_helper_connector_hotplug_event">
void <code class="sig-name descname">drm_kms_helper_connector_hotplug_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_connector_hotplug_event" title="Permalink to this definition">¶</a></dt>
<dd><p>fire off a KMS connector hotplug event</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm_connector which has changed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.drm_kms_helper_hotplug_event" title="drm_kms_helper_hotplug_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_hotplug_event()</span></code></a>, except it fires a more
fine-grained uevent for a single connector.</p>
</div>
<dl class="function">
<dt id="c.drm_kms_helper_is_poll_worker">
bool <code class="sig-name descname">drm_kms_helper_is_poll_worker</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_is_poll_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>is <code class="docutils literal notranslate"><span class="pre">current</span></code> task an output poll worker?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if <code class="docutils literal notranslate"><span class="pre">current</span></code> task is an output poll worker.  This can be used
to select distinct code paths for output polling versus other contexts.</p>
<p>One use case is to avoid a deadlock between the output poll worker and
the autosuspend worker wherein the latter waits for polling to finish
upon calling <a class="reference internal" href="#c.drm_kms_helper_poll_disable" title="drm_kms_helper_poll_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_disable()</span></code></a>, while the former waits for
runtime suspend to finish upon calling pm_runtime_get_sync() in a
connector -&gt;detect hook.</p>
</div>
<dl class="function">
<dt id="c.drm_kms_helper_poll_disable">
void <code class="sig-name descname">drm_kms_helper_poll_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable output polling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function disables the output polling work.</p>
<p>Drivers can call this helper from their device suspend implementation. It is
not an error to call this even when output polling isn’t enabled or already
disabled. Polling is re-enabled by calling <a class="reference internal" href="#c.drm_kms_helper_poll_enable" title="drm_kms_helper_poll_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_enable()</span></code></a>.</p>
<p>Note that calls to enable and disable polling must be strictly ordered, which
is automatically the case when they’re only call from suspend/resume
callbacks.</p>
</div>
<dl class="function">
<dt id="c.drm_kms_helper_poll_init">
void <code class="sig-name descname">drm_kms_helper_poll_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize and enable output polling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes and then also enables output polling support for
<strong>dev</strong>. Drivers which do not have reliable hotplug support in hardware can use
this helper infrastructure to regularly poll such connectors for changes in
their connection state.</p>
<p>Drivers can control which connectors are polled by setting the
DRM_CONNECTOR_POLL_CONNECT and DRM_CONNECTOR_POLL_DISCONNECT flags. On
connectors where probing live outputs can result in visual distortion drivers
should not set the DRM_CONNECTOR_POLL_DISCONNECT flag to avoid this.
Connectors which have no flag or only DRM_CONNECTOR_POLL_HPD set are
completely ignored by the polling logic.</p>
<p>Note that a connector can be both polled and probed from the hotplug handler,
in case the hotplug interrupt is known to be unreliable.</p>
</div>
<dl class="function">
<dt id="c.drm_kms_helper_poll_fini">
void <code class="sig-name descname">drm_kms_helper_poll_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_kms_helper_poll_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>disable output polling and clean it up</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_connector_helper_hpd_irq_event">
bool <code class="sig-name descname">drm_connector_helper_hpd_irq_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_helper_hpd_irq_event" title="Permalink to this definition">¶</a></dt>
<dd><p>hotplug processing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm_connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this helper function to run a detect cycle on a connector
which has the DRM_CONNECTOR_POLL_HPD flag set in its <code class="xref c c-type docutils literal notranslate"><span class="pre">polled</span></code> member.</p>
<p>This helper function is useful for drivers which can track hotplug
interrupts for a single connector. Drivers that want to send a
hotplug event for all connectors or can’t track hotplug interrupts
per connector need to use <a class="reference internal" href="#c.drm_helper_hpd_irq_event" title="drm_helper_hpd_irq_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_hpd_irq_event()</span></code></a>.</p>
<p>This function must be called from process context with no mode
setting locks held.</p>
<p>Note that a connector can be both polled and probed from the hotplug
handler, in case the hotplug interrupt is known to be unreliable.</p>
<p><strong>Return</strong></p>
<p>A boolean indicating whether the connector status changed or not</p>
</div>
<dl class="function">
<dt id="c.drm_helper_hpd_irq_event">
bool <code class="sig-name descname">drm_helper_hpd_irq_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_hpd_irq_event" title="Permalink to this definition">¶</a></dt>
<dd><p>hotplug processing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this helper function to run a detect cycle on all connectors
which have the DRM_CONNECTOR_POLL_HPD flag set in their <code class="xref c c-type docutils literal notranslate"><span class="pre">polled</span></code> member. All
other connectors are ignored, which is useful to avoid reprobing fixed
panels.</p>
<p>This helper function is useful for drivers which can’t or don’t track hotplug
interrupts for each connector.</p>
<p>Drivers which support hotplug interrupts for each connector individually and
which have a more fine-grained detect logic can use
<a class="reference internal" href="#c.drm_connector_helper_hpd_irq_event" title="drm_connector_helper_hpd_irq_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_helper_hpd_irq_event()</span></code></a>. Alternatively, they should bypass this
code and directly call <a class="reference internal" href="#c.drm_kms_helper_hotplug_event" title="drm_kms_helper_hotplug_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_hotplug_event()</span></code></a> in case the connector
state changed.</p>
<p>This function must be called from process context with no mode
setting locks held.</p>
<p>Note that a connector can be both polled and probed from the hotplug handler,
in case the hotplug interrupt is known to be unreliable.</p>
<p><strong>Return</strong></p>
<p>A boolean indicating whether the connector status changed or not</p>
</div>
<dl class="function">
<dt id="c.drm_crtc_helper_mode_valid_fixed">
enum <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="sig-name descname">drm_crtc_helper_mode_valid_fixed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *fixed_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_mode_valid_fixed" title="Permalink to this definition">¶</a></dt>
<dd><p>Validates a display mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>the crtc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>the mode to validate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*fixed_mode</span></code></dt><dd><p>the display hardware’s mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>MODE_OK on success, or another mode-status code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_connector_helper_get_modes_from_ddc">
int <code class="sig-name descname">drm_connector_helper_get_modes_from_ddc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_helper_get_modes_from_ddc" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the connector’s EDID property from the connector’s DDC channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>The connector</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of detected display modes.</p>
<p><strong>Description</strong></p>
<p>Uses a connector’s DDC channel to retrieve EDID data and update the
connector’s EDID property and display modes. Drivers can use this
function to implement struct <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs.get_modes</span></code></a>
for connectors with a DDC channel.</p>
</div>
<dl class="function">
<dt id="c.drm_connector_helper_get_modes_fixed">
int <code class="sig-name descname">drm_connector_helper_get_modes_fixed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *fixed_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_helper_get_modes_fixed" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicates a display mode for a connector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*fixed_mode</span></code></dt><dd><p>the display hardware’s mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function duplicates a display modes for a connector. Drivers for hardware
that only supports a single fixed mode can use this function in their connector’s
get_modes helper.</p>
<p><strong>Return</strong></p>
<p>The number of created modes.</p>
</div>
<dl class="function">
<dt id="c.drm_connector_helper_get_modes">
int <code class="sig-name descname">drm_connector_helper_get_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_helper_get_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Read EDID and update connector.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>The connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the EDID using <a class="reference internal" href="#c.drm_edid_read" title="drm_edid_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_read()</span></code></a> (which requires that connector-&gt;ddc is
set), and update the connector using the EDID.</p>
<p>This can be used as the “default” connector helper .get_modes() hook if the
driver does not need any special processing. This is sets the example what
custom .get_modes() hooks should do regarding EDID read and connector update.</p>
<p><strong>Return</strong></p>
<p>Number of modes.</p>
</div>
</section>
<section id="edid-helper-functions-reference">
<h2>EDID Helper Functions Reference<a class="headerlink" href="#edid-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.drm_eld_mnl">
int <code class="sig-name descname">drm_eld_mnl</code><span class="sig-paren">(</span>const uint8_t<em> *eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_mnl" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD monitor name length in bytes.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*eld</span></code></dt><dd><p>pointer to an eld memory structure with mnl set</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_eld_sad">
const uint8_t * <code class="sig-name descname">drm_eld_sad</code><span class="sig-paren">(</span>const uint8_t<em> *eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_sad" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD SAD structures.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*eld</span></code></dt><dd><p>pointer to an eld memory structure with sad_count set</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_eld_sad_count">
int <code class="sig-name descname">drm_eld_sad_count</code><span class="sig-paren">(</span>const uint8_t<em> *eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_sad_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD SAD count.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*eld</span></code></dt><dd><p>pointer to an eld memory structure with sad_count set</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_eld_calc_baseline_block_size">
int <code class="sig-name descname">drm_eld_calc_baseline_block_size</code><span class="sig-paren">(</span>const uint8_t<em> *eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_calc_baseline_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate baseline block size in bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*eld</span></code></dt><dd><p>pointer to an eld memory structure with mnl and sad_count set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper for determining the payload size of the baseline block, in
bytes, for e.g. setting the Baseline_ELD_Len field in the ELD header block.</p>
</div>
<dl class="function">
<dt id="c.drm_eld_size">
int <code class="sig-name descname">drm_eld_size</code><span class="sig-paren">(</span>const uint8_t<em> *eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD size in bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*eld</span></code></dt><dd><p>pointer to a complete eld memory structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned value does not include the vendor block. It’s vendor specific,
and comprises of the remaining bytes in the ELD memory buffer after
<a class="reference internal" href="#c.drm_eld_size" title="drm_eld_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_eld_size()</span></code></a> bytes of header and baseline block.</p>
<p>The returned value is guaranteed to be a multiple of 4.</p>
</div>
<dl class="function">
<dt id="c.drm_eld_get_spk_alloc">
u8 <code class="sig-name descname">drm_eld_get_spk_alloc</code><span class="sig-paren">(</span>const uint8_t<em> *eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_get_spk_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get speaker allocation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*eld</span></code></dt><dd><p>pointer to an ELD memory structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned value is the speakers mask. User has to use <code class="docutils literal notranslate"><span class="pre">DRM_ELD_SPEAKER</span></code>
field definitions to identify speakers.</p>
</div>
<dl class="function">
<dt id="c.drm_eld_get_conn_type">
u8 <code class="sig-name descname">drm_eld_get_conn_type</code><span class="sig-paren">(</span>const uint8_t<em> *eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_get_conn_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Get device type hdmi/dp connected</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*eld</span></code></dt><dd><p>pointer to an ELD memory structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller need to use <code class="docutils literal notranslate"><span class="pre">DRM_ELD_CONN_TYPE_HDMI</span></code> or <code class="docutils literal notranslate"><span class="pre">DRM_ELD_CONN_TYPE_DP</span></code> to
identify the display type connected.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_decode_mfg_id">
const char * <code class="sig-name descname">drm_edid_decode_mfg_id</code><span class="sig-paren">(</span>u16<em> mfg_id</em>, char<em> vend[4]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_decode_mfg_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode the manufacturer ID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mfg_id</span></code></dt><dd><p>The manufacturer ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">vend[4]</span></code></dt><dd><p>A 4-byte buffer to store the 3-letter vendor string plus a ‘0’
termination</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_edid_encode_panel_id">
<code class="sig-name descname">drm_edid_encode_panel_id</code><span class="sig-paren">(</span><em>vend_chr_0</em>, <em>vend_chr_1</em>, <em>vend_chr_2</em>, <em>product_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_encode_panel_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode an ID for matching against <a class="reference internal" href="#c.drm_edid_get_panel_id" title="drm_edid_get_panel_id"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_get_panel_id()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vend_chr_0</span></code></dt><dd><p>First character of the vendor string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vend_chr_1</span></code></dt><dd><p>Second character of the vendor string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vend_chr_2</span></code></dt><dd><p>Third character of the vendor string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">product_id</span></code></dt><dd><p>The 16-bit product ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a macro so that it can be calculated at compile time and used
as an initializer.</p>
<dl class="simple">
<dt>For instance:</dt><dd><p>drm_edid_encode_panel_id(‘B’, ‘O’, ‘E’, 0x2d08) =&gt; 0x09e52d08</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a 32-bit ID per panel.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_decode_panel_id">
void <code class="sig-name descname">drm_edid_decode_panel_id</code><span class="sig-paren">(</span>u32<em> panel_id</em>, char<em> vend[4]</em>, u16<em> *product_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_decode_panel_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a panel ID from <a class="reference internal" href="#c.drm_edid_encode_panel_id" title="drm_edid_encode_panel_id"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_encode_panel_id()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">panel_id</span></code></dt><dd><p>The panel ID to decode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">vend[4]</span></code></dt><dd><p>A 4-byte buffer to store the 3-letter vendor string plus a ‘0’
termination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*product_id</span></code></dt><dd><p>The product ID will be returned here.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>For instance, after:</dt><dd><p>drm_edid_decode_panel_id(0x09e52d08, vend, <code class="xref c c-type docutils literal notranslate"><span class="pre">product_id</span></code>)</p>
</dd>
<dt>These will be true:</dt><dd><p>vend[0] = ‘B’
vend[1] = ‘O’
vend[2] = ‘E’
vend[3] = ‘0’
product_id = 0x2d08</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_edid_header_is_valid">
int <code class="sig-name descname">drm_edid_header_is_valid</code><span class="sig-paren">(</span>const void<em> *_edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_header_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>sanity check the header of the base EDID block</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*_edid</span></code></dt><dd><p>pointer to raw base EDID block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sanity check the header of the base EDID block.</p>
<p><strong>Return</strong></p>
<p>8 if the header is perfect, down to 0 if it’s totally wrong.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_are_equal">
bool <code class="sig-name descname">drm_edid_are_equal</code><span class="sig-paren">(</span>const struct edid<em> *edid1</em>, const struct edid<em> *edid2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_are_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>compare two edid blobs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid1</span></code></dt><dd><p>pointer to first blob</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid2</span></code></dt><dd><p>pointer to second blob
This helper can be used during probing to determine if
edid had changed.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_edid_block_valid">
bool <code class="sig-name descname">drm_edid_block_valid</code><span class="sig-paren">(</span>u8<em> *_block</em>, int<em> block_num</em>, bool<em> print_bad_edid</em>, bool<em> *edid_corrupt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_block_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check the EDID block (base or extension)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*_block</span></code></dt><dd><p>pointer to raw EDID block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_num</span></code></dt><dd><p>type of block to validate (0 for base, extension otherwise)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">print_bad_edid</span></code></dt><dd><p>if true, dump bad EDID blocks to the console</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*edid_corrupt</span></code></dt><dd><p>if true, the header or checksum is invalid</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validate a base or extension EDID block and optionally dump bad blocks to
the console.</p>
<p><strong>Return</strong></p>
<p>True if the block is valid, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_is_valid">
bool <code class="sig-name descname">drm_edid_is_valid</code><span class="sig-paren">(</span>struct edid<em> *edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>sanity check EDID data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>EDID data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sanity-check an entire EDID record (including extensions)</p>
<p><strong>Return</strong></p>
<p>True if the EDID data is valid, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_valid">
bool <code class="sig-name descname">drm_edid_valid</code><span class="sig-paren">(</span>const struct drm_edid<em> *drm_edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>sanity check EDID data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_edid</span> <span class="pre">*drm_edid</span></code></dt><dd><p>EDID data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sanity check an EDID. Cross check block count against allocated size and
checksum the blocks.</p>
<p><strong>Return</strong></p>
<p>True if the EDID data is valid, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_override_connector_update">
int <code class="sig-name descname">drm_edid_override_connector_update</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_override_connector_update" title="Permalink to this definition">¶</a></dt>
<dd><p>add modes from override/firmware EDID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add modes from the override/firmware EDID, if available. Only to be used from
<a class="reference internal" href="#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a> as a fallback for when DDC probe
failed during <a class="reference internal" href="#c.drm_get_edid" title="drm_get_edid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_get_edid()</span></code></a> and caused the override/firmware EDID to be
skipped.</p>
<p><strong>Return</strong></p>
<p>The number of modes added or 0 if we couldn’t find any.</p>
</div>
<dl class="function">
<dt id="c.drm_do_get_edid">
struct edid * <code class="sig-name descname">drm_do_get_edid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, read_block_fn<em> read_block</em>, void<em> *context</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_do_get_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID data using a custom EDID block read function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_block_fn</span> <span class="pre">read_block</span></code></dt><dd><p>EDID block read function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*context</span></code></dt><dd><p>private data passed to the block read function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the I2C adapter connected to the DDC bus is hidden behind a device that
exposes a different interface to read EDID blocks this function can be used
to get EDID data using a custom block read function.</p>
<p>As in the general case the DDC bus is accessible by the kernel at the I2C
level, drivers must make all reasonable efforts to expose it as an I2C
adapter and use <a class="reference internal" href="#c.drm_get_edid" title="drm_get_edid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_get_edid()</span></code></a> instead of abusing this function.</p>
<p>The EDID may be overridden using debugfs override_edid or firmware EDID
(drm_edid_load_firmware() and drm.edid_firmware parameter), in this priority
order. Having either of them bypasses actual EDID reads.</p>
<p><strong>Return</strong></p>
<p>Pointer to valid EDID or NULL if we couldn’t find any.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_raw">
const struct edid * <code class="sig-name descname">drm_edid_raw</code><span class="sig-paren">(</span>const struct drm_edid<em> *drm_edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a pointer to the raw EDID data.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_edid</span> <span class="pre">*drm_edid</span></code></dt><dd><p>drm_edid container</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a pointer to the raw EDID data.</p>
<p>This is for transition only. Avoid using this like the plague.</p>
<p><strong>Return</strong></p>
<p>Pointer to raw EDID data.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_alloc">
const struct drm_edid * <code class="sig-name descname">drm_edid_alloc</code><span class="sig-paren">(</span>const void<em> *edid</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a new drm_edid container</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*edid</span></code></dt><dd><p>Pointer to raw EDID data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of memory allocated for EDID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a new drm_edid container. Do not calculate edid size from edid, pass
the actual size that has been allocated for the data. There is no validation
of the raw EDID data against the size, but at least the EDID base block must
fit in the buffer.</p>
<p>The returned pointer must be freed using <a class="reference internal" href="#c.drm_edid_free" title="drm_edid_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_free()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>drm_edid container, or NULL on errors</p>
</div>
<dl class="function">
<dt id="c.drm_edid_dup">
const struct drm_edid * <code class="sig-name descname">drm_edid_dup</code><span class="sig-paren">(</span>const struct drm_edid<em> *drm_edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_dup" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate a drm_edid container</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_edid</span> <span class="pre">*drm_edid</span></code></dt><dd><p>EDID to duplicate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned pointer must be freed using <a class="reference internal" href="#c.drm_edid_free" title="drm_edid_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_free()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>drm_edid container copy, or NULL on errors</p>
</div>
<dl class="function">
<dt id="c.drm_edid_free">
void <code class="sig-name descname">drm_edid_free</code><span class="sig-paren">(</span>const struct drm_edid<em> *drm_edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free the drm_edid container</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_edid</span> <span class="pre">*drm_edid</span></code></dt><dd><p>EDID to free</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_probe_ddc">
bool <code class="sig-name descname">drm_probe_ddc</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_probe_ddc" title="Permalink to this definition">¶</a></dt>
<dd><p>probe DDC presence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter to probe</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True on success, false on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_get_edid">
struct edid * <code class="sig-name descname">drm_get_edid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct i2c_adapter<em> *adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID data, if available</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter to use for DDC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Poke the given I2C channel to grab EDID data if possible.  If found,
attach it to the connector.</p>
<p><strong>Return</strong></p>
<p>Pointer to valid EDID or NULL if we couldn’t find any.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_read_custom">
const struct drm_edid * <code class="sig-name descname">drm_edid_read_custom</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, read_block_fn<em> read_block</em>, void<em> *context</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_read_custom" title="Permalink to this definition">¶</a></dt>
<dd><p>Read EDID data using given EDID block read function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>Connector to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_block_fn</span> <span class="pre">read_block</span></code></dt><dd><p>EDID block read function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*context</span></code></dt><dd><p>Private data passed to the block read function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the I2C adapter connected to the DDC bus is hidden behind a device that
exposes a different interface to read EDID blocks this function can be used
to get EDID data using a custom block read function.</p>
<p>As in the general case the DDC bus is accessible by the kernel at the I2C
level, drivers must make all reasonable efforts to expose it as an I2C
adapter and use <a class="reference internal" href="#c.drm_edid_read" title="drm_edid_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_read()</span></code></a> or <a class="reference internal" href="#c.drm_edid_read_ddc" title="drm_edid_read_ddc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_read_ddc()</span></code></a> instead of abusing
this function.</p>
<p>The EDID may be overridden using debugfs override_edid or firmware EDID
(drm_edid_load_firmware() and drm.edid_firmware parameter), in this priority
order. Having either of them bypasses actual EDID reads.</p>
<p>The returned pointer must be freed using <a class="reference internal" href="#c.drm_edid_free" title="drm_edid_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_free()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Pointer to EDID, or NULL if probe/read failed.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_read_ddc">
const struct drm_edid * <code class="sig-name descname">drm_edid_read_ddc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct i2c_adapter<em> *adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_read_ddc" title="Permalink to this definition">¶</a></dt>
<dd><p>Read EDID data using given I2C adapter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>Connector to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter to use for DDC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read EDID using the given I2C adapter.</p>
<p>The EDID may be overridden using debugfs override_edid or firmware EDID
(drm_edid_load_firmware() and drm.edid_firmware parameter), in this priority
order. Having either of them bypasses actual EDID reads.</p>
<p>Prefer initializing connector-&gt;ddc with <a class="reference internal" href="drm-kms.html#c.drm_connector_init_with_ddc" title="drm_connector_init_with_ddc"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_init_with_ddc()</span></code></a> and
using <a class="reference internal" href="#c.drm_edid_read" title="drm_edid_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_read()</span></code></a> instead of this function.</p>
<p>The returned pointer must be freed using <a class="reference internal" href="#c.drm_edid_free" title="drm_edid_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_free()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Pointer to EDID, or NULL if probe/read failed.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_read">
const struct drm_edid * <code class="sig-name descname">drm_edid_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read EDID data using connector’s I2C adapter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>Connector to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read EDID using the connector’s I2C adapter.</p>
<p>The EDID may be overridden using debugfs override_edid or firmware EDID
(drm_edid_load_firmware() and drm.edid_firmware parameter), in this priority
order. Having either of them bypasses actual EDID reads.</p>
<p>The returned pointer must be freed using <a class="reference internal" href="#c.drm_edid_free" title="drm_edid_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_free()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Pointer to EDID, or NULL if probe/read failed.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_get_panel_id">
u32 <code class="sig-name descname">drm_edid_get_panel_id</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_get_panel_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a panel’s ID through DDC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter to use for DDC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function reads the first block of the EDID of a panel and (assuming
that the EDID is valid) extracts the ID out of it. The ID is a 32-bit value
(16 bits of manufacturer ID and 16 bits of per-manufacturer ID) that’s
supposed to be different for each different modem of panel.</p>
<p>This function is intended to be used during early probing on devices where
more than one panel might be present. Because of its intended use it must
assume that the EDID of the panel is correct, at least as far as the ID
is concerned (in other words, we don’t process any overrides here).</p>
<p><strong>NOTE</strong></p>
<p>it’s expected that this function and <a class="reference internal" href="#c.drm_do_get_edid" title="drm_do_get_edid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_do_get_edid()</span></code></a> will both
be read the EDID, but there is no caching between them. Since we’re only
reading the first block, hopefully this extra overhead won’t be too big.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>A 32-bit ID that should be different for each make/model of panel.</dt><dd><p>See the functions <a class="reference internal" href="#c.drm_edid_encode_panel_id" title="drm_edid_encode_panel_id"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_encode_panel_id()</span></code></a> and
<a class="reference internal" href="#c.drm_edid_decode_panel_id" title="drm_edid_decode_panel_id"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_decode_panel_id()</span></code></a> for some details on the structure of this
ID.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_get_edid_switcheroo">
struct edid * <code class="sig-name descname">drm_get_edid_switcheroo</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct i2c_adapter<em> *adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_edid_switcheroo" title="Permalink to this definition">¶</a></dt>
<dd><p>get EDID data for a vga_switcheroo output</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter to use for DDC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper around <a class="reference internal" href="#c.drm_get_edid" title="drm_get_edid"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_get_edid()</span></code></a> for laptops with dual GPUs using one set of
outputs. The wrapper adds the requisite vga_switcheroo calls to temporarily
switch DDC to the GPU which is retrieving EDID.</p>
<p><strong>Return</strong></p>
<p>Pointer to valid EDID or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if we couldn’t find any.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_duplicate">
struct edid * <code class="sig-name descname">drm_edid_duplicate</code><span class="sig-paren">(</span>const struct edid<em> *edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate an EDID and the extensions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>EDID to duplicate</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to duplicated EDID or NULL on allocation failure.</p>
</div>
<dl class="function">
<dt id="c.drm_match_cea_mode">
u8 <code class="sig-name descname">drm_match_cea_mode</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *to_match</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_match_cea_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>look for a CEA mode matching given mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*to_match</span></code></dt><dd><p>display mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The CEA Video ID (VIC) of the mode or 0 if it isn’t a CEA-861
mode.</p>
</div>
<dl class="function">
<dt id="c.drm_display_mode_from_cea_vic">
struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="sig-name descname">drm_display_mode_from_cea_vic</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, u8<em> video_code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_display_mode_from_cea_vic" title="Permalink to this definition">¶</a></dt>
<dd><p>return a mode for CEA VIC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">video_code</span></code></dt><dd><p>CEA VIC of the mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new mode matching the specified CEA VIC.</p>
<p><strong>Return</strong></p>
<p>A new drm_display_mode on success or NULL on failure</p>
</div>
<dl class="function">
<dt id="c.drm_edid_get_monitor_name">
void <code class="sig-name descname">drm_edid_get_monitor_name</code><span class="sig-paren">(</span>const struct edid<em> *edid</em>, char<em> *name</em>, int<em> bufsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_get_monitor_name" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch the monitor name from the edid</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>monitor EDID information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>pointer to a character array to hold the name of the monitor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bufsize</span></code></dt><dd><p>The size of the name buffer (should be at least 14 chars.)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_edid_to_sad">
int <code class="sig-name descname">drm_edid_to_sad</code><span class="sig-paren">(</span>const struct edid<em> *edid</em>, struct cea_sad<em> **sads</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_to_sad" title="Permalink to this definition">¶</a></dt>
<dd><p>extracts SADs from EDID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>EDID to parse</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cea_sad</span> <span class="pre">**sads</span></code></dt><dd><p>pointer that will be set to the extracted SADs</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks for CEA EDID block and extracts SADs (Short Audio Descriptors) from it.</p>
<p><strong>Note</strong></p>
<p>The returned pointer needs to be freed using <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>The number of found SADs or negative number on error.</p>
</div>
<dl class="function">
<dt id="c.drm_edid_to_speaker_allocation">
int <code class="sig-name descname">drm_edid_to_speaker_allocation</code><span class="sig-paren">(</span>const struct edid<em> *edid</em>, u8<em> **sadb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_to_speaker_allocation" title="Permalink to this definition">¶</a></dt>
<dd><p>extracts Speaker Allocation Data Blocks from EDID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>EDID to parse</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">**sadb</span></code></dt><dd><p>pointer to the speaker block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks for CEA EDID block and extracts the Speaker Allocation Data Block from it.</p>
<p><strong>Note</strong></p>
<p>The returned pointer needs to be freed using <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>The number of found Speaker Allocation Blocks or negative number on
error.</p>
</div>
<dl class="function">
<dt id="c.drm_av_sync_delay">
int <code class="sig-name descname">drm_av_sync_delay</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_av_sync_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the HDMI/DP sink audio-video sync delay</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector associated with the HDMI/DP sink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>the display mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The HDMI/DP sink’s audio-video sync delay in milliseconds or 0 if
the sink doesn’t support audio or video.</p>
</div>
<dl class="function">
<dt id="c.drm_detect_hdmi_monitor">
bool <code class="sig-name descname">drm_detect_hdmi_monitor</code><span class="sig-paren">(</span>const struct edid<em> *edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_detect_hdmi_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>detect whether monitor is HDMI</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>monitor EDID information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the CEA extension according to CEA-861-B.</p>
<p>Drivers that have added the modes parsed from EDID to drm_display_info
should use <a class="reference internal" href="drm-kms.html#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info.is_hdmi</span></code></a> instead of calling this function.</p>
<p><strong>Return</strong></p>
<p>True if the monitor is HDMI, false if not or unknown.</p>
</div>
<dl class="function">
<dt id="c.drm_detect_monitor_audio">
bool <code class="sig-name descname">drm_detect_monitor_audio</code><span class="sig-paren">(</span>const struct edid<em> *edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_detect_monitor_audio" title="Permalink to this definition">¶</a></dt>
<dd><p>check monitor audio capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>EDID block to scan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Monitor should have CEA extension block.
If monitor has ‘basic audio’, but no CEA audio blocks, it’s ‘basic
audio’ only. If there is any audio extension block and supported
audio format, assume at least ‘basic audio’ support, even if ‘basic
audio’ is not defined in EDID.</p>
<p><strong>Return</strong></p>
<p>True if the monitor supports audio, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_default_rgb_quant_range">
enum hdmi_quantization_range <code class="sig-name descname">drm_default_rgb_quant_range</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_default_rgb_quant_range" title="Permalink to this definition">¶</a></dt>
<dd><p>default RGB quantization range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>display mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the default RGB quantization range for the mode,
as specified in CEA-861.</p>
<p><strong>Return</strong></p>
<p>The default RGB quantization range for the mode</p>
</div>
<dl class="function">
<dt id="c.drm_edid_connector_update">
int <code class="sig-name descname">drm_edid_connector_update</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, const struct drm_edid<em> *drm_edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_edid_connector_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update connector information from EDID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>Connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_edid</span> <span class="pre">*drm_edid</span></code></dt><dd><p>EDID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the connector mode list, display info, ELD, HDR metadata, relevant
properties, etc. from the passed in EDID.</p>
<p>If EDID is NULL, reset the information.</p>
<p><strong>Return</strong></p>
<p>The number of modes added or 0 if we couldn’t find any.</p>
</div>
<dl class="function">
<dt id="c.drm_connector_update_edid_property">
int <code class="sig-name descname">drm_connector_update_edid_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, const struct edid<em> *edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_update_edid_property" title="Permalink to this definition">¶</a></dt>
<dd><p>update the edid property of a connector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>drm connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>new value of the edid property</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a new blob modeset object and assigns its id to the
connector’s edid property.
Since we also parse tile information from EDID’s displayID block, we also
set the connector’s tile property here. See <a class="reference internal" href="drm-kms.html#c.drm_connector_set_tile_property" title="drm_connector_set_tile_property"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_set_tile_property()</span></code></a>
for more details.</p>
<p>This function is deprecated. Use <a class="reference internal" href="#c.drm_edid_connector_update" title="drm_edid_connector_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_connector_update()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_add_edid_modes">
int <code class="sig-name descname">drm_add_edid_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, struct edid<em> *edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_add_edid_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>add modes from EDID data, if available</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*edid</span></code></dt><dd><p>EDID data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the specified modes to the connector’s mode list. Also fills out the
<a class="reference internal" href="drm-kms.html#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_display_info</span></code></a> structure and ELD in <strong>connector</strong> with any information which
can be derived from the edid.</p>
<p>This function is deprecated. Use <a class="reference internal" href="#c.drm_edid_connector_update" title="drm_edid_connector_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_edid_connector_update()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>The number of modes added or 0 if we couldn’t find any.</p>
</div>
<dl class="function">
<dt id="c.drm_add_modes_noedid">
int <code class="sig-name descname">drm_add_modes_noedid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, int<em> hdisplay</em>, int<em> vdisplay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_add_modes_noedid" title="Permalink to this definition">¶</a></dt>
<dd><p>add modes for the connectors without EDID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector we’re probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt><dd><p>the horizontal display limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt><dd><p>the vertical display limit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the specified modes to the connector’s mode list. Only when the
hdisplay/vdisplay is not beyond the given limit, it will be added.</p>
<p><strong>Return</strong></p>
<p>The number of modes added or 0 if we couldn’t find any.</p>
</div>
<dl class="function">
<dt id="c.drm_set_preferred_mode">
void <code class="sig-name descname">drm_set_preferred_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, int<em> hpref</em>, int<em> vpref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_set_preferred_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the preferred mode of a connector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>connector whose mode list should be processed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">hpref</span></code></dt><dd><p>horizontal resolution of preferred mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vpref</span></code></dt><dd><p>vertical resolution of preferred mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks a mode as preferred if it matches the resolution specified by <strong>hpref</strong>
and <strong>vpref</strong>.</p>
</div>
<dl class="function">
<dt id="c.drm_hdmi_avi_infoframe_from_display_mode">
int <code class="sig-name descname">drm_hdmi_avi_infoframe_from_display_mode</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe<em> *frame</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_avi_infoframe_from_display_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>fill an HDMI AVI infoframe with data from a DRM display mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>DRM display mode</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_hdmi_avi_infoframe_quant_range">
void <code class="sig-name descname">drm_hdmi_avi_infoframe_quant_range</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe<em> *frame</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em>, enum hdmi_quantization_range<em> rgb_quant_range</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_avi_infoframe_quant_range" title="Permalink to this definition">¶</a></dt>
<dd><p>fill the HDMI AVI infoframe quantization range information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>DRM display mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hdmi_quantization_range</span> <span class="pre">rgb_quant_range</span></code></dt><dd><p>RGB quantization range (Q)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_hdmi_vendor_infoframe_from_display_mode">
int <code class="sig-name descname">drm_hdmi_vendor_infoframe_from_display_mode</code><span class="sig-paren">(</span>struct hdmi_vendor_infoframe<em> *frame</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_vendor_infoframe_from_display_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>fill an HDMI infoframe with data from a DRM display mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI vendor infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>the connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>DRM display mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that there’s is a need to send HDMI vendor infoframes only when using a
4k or stereoscopic 3D mode. So when giving any other mode as input this
function will return -EINVAL, error that can be safely ignored.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
</section>
<section id="scdc-helper-functions-reference">
<h2>SCDC Helper Functions Reference<a class="headerlink" href="#scdc-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>Status and Control Data Channel (SCDC) is a mechanism introduced by the
HDMI 2.0 specification. It is a point-to-point protocol that allows the
HDMI source and HDMI sink to exchange data. The same I2C interface that
is used to access EDID serves as the transport mechanism for SCDC.</p>
<p>Note: The SCDC status is going to be lost when the display is
disconnected. This can happen physically when the user disconnects
the cable, but also when a display is switched on (such as waking up
a TV).</p>
<p>This is further complicated by the fact that, upon a disconnection /
reconnection, KMS won’t change the mode on its own. This means that
one can’t just rely on setting the SCDC status on enable, but also
has to track the connector status changes using interrupts and
restore the SCDC status. The typical solution for this is to trigger an
empty modeset in drm_connector_helper_funcs.detect_ctx(), like what vc4 does
in vc4_hdmi_reset_link().</p>
<dl class="function">
<dt id="c.drm_scdc_readb">
int <code class="sig-name descname">drm_scdc_readb</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, u8<em> offset</em>, u8<em> *value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_readb" title="Permalink to this definition">¶</a></dt>
<dd><p>read a single byte from SCDC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>offset of register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*value</span></code></dt><dd><p>return location for the register value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a single byte from SCDC. This is a convenience wrapper around the
<a class="reference internal" href="#c.drm_scdc_read" title="drm_scdc_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_scdc_read()</span></code></a> function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_scdc_writeb">
int <code class="sig-name descname">drm_scdc_writeb</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, u8<em> offset</em>, u8<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_writeb" title="Permalink to this definition">¶</a></dt>
<dd><p>write a single byte to SCDC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>offset of register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">value</span></code></dt><dd><p>return location for the register value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a single byte to SCDC. This is a convenience wrapper around the
<a class="reference internal" href="#c.drm_scdc_write" title="drm_scdc_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_scdc_write()</span></code></a> function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_scdc_read">
ssize_t <code class="sig-name descname">drm_scdc_read</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, u8<em> offset</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read a block of data from SCDC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>start offset of block to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>return location for the block to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the block to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a block of data from SCDC, starting at a given offset.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_scdc_write">
ssize_t <code class="sig-name descname">drm_scdc_write</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, u8<em> offset</em>, const void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a block of data to SCDC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">offset</span></code></dt><dd><p>start offset of block to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>block of data to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of the block to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a block of data to SCDC, starting at a given offset.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_scdc_get_scrambling_status">
bool <code class="sig-name descname">drm_scdc_get_scrambling_status</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_get_scrambling_status" title="Permalink to this definition">¶</a></dt>
<dd><p>what is status of scrambling?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter for DDC channel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads the scrambler status over SCDC, and checks the
scrambling status.</p>
<p><strong>Return</strong></p>
<p>True if the scrambling is enabled, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_scdc_set_scrambling">
bool <code class="sig-name descname">drm_scdc_set_scrambling</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_set_scrambling" title="Permalink to this definition">¶</a></dt>
<dd><p>enable scrambling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter for DDC channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>bool to indicate if scrambling is to be enabled/disabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes the TMDS config register over SCDC channel, and:
enables scrambling when enable = 1
disables scrambling when enable = 0</p>
<p><strong>Return</strong></p>
<p>True if scrambling is set/reset successfully, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_scdc_set_high_tmds_clock_ratio">
bool <code class="sig-name descname">drm_scdc_set_high_tmds_clock_ratio</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, bool<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_set_high_tmds_clock_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>set TMDS clock ratio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>I2C adapter for DDC channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">set</span></code></dt><dd><p>ret or reset the high clock ratio</p>
<dl>
<dt>TMDS clock ratio calculations go like this:</dt><dd><p>TMDS character = 10 bit TMDS encoded value</p>
<p>TMDS character rate = The rate at which TMDS characters are
transmitted (Mcsc)</p>
<p>TMDS bit rate = 10x TMDS character rate</p>
</dd>
<dt>As per the spec:</dt><dd><p>TMDS clock rate for pixel clock &lt; 340 MHz = 1x the character
rate = 1/10 pixel clock rate</p>
<p>TMDS clock rate for pixel clock &gt; 340 MHz = 0.25x the character
rate = 1/40 pixel clock rate</p>
</dd>
<dt>Writes to the TMDS config register over SCDC channel, and:</dt><dd><p>sets TMDS clock ratio to 1/40 when set = 1</p>
<p>sets TMDS clock ratio to 1/10 when set = 0</p>
</dd>
</dl>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if write is successful, false otherwise.</p>
</div>
</section>
<section id="hdmi-infoframes-helper-reference">
<h2>HDMI Infoframes Helper Reference<a class="headerlink" href="#hdmi-infoframes-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>Strictly speaking this is not a DRM helper library but generally useable
by any driver interfacing with HDMI outputs like v4l or alsa drivers.
But it nicely fits into the overall topic of mode setting helper
libraries and hence is also included here.</p>
<dl class="type">
<dt id="c.hdr_sink_metadata">
struct <code class="sig-name descname">hdr_sink_metadata</code><a class="headerlink" href="#c.hdr_sink_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>HDR sink metadata</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hdr_sink_metadata {
    __u32 metadata_type;
    union {
        struct hdr_static_metadata hdmi_type1;
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">metadata_type</span></code></dt><dd><p>Static_Metadata_Descriptor_ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdmi_type1</span></code></dt><dd><p>HDR Metadata Infoframe.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Metadata Information read from Sink’s EDID</p>
<dl class="type">
<dt id="c.hdmi_infoframe">
union <code class="sig-name descname">hdmi_infoframe</code><a class="headerlink" href="#c.hdmi_infoframe" title="Permalink to this definition">¶</a></dt>
<dd><p>overall union of all abstract infoframe representations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>union hdmi_infoframe {
    struct hdmi_any_infoframe any;
    struct hdmi_avi_infoframe avi;
    struct hdmi_spd_infoframe spd;
    union hdmi_vendor_any_infoframe vendor;
    struct hdmi_audio_infoframe audio;
    struct hdmi_drm_infoframe drm;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">any</span></code></dt><dd><p>generic infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">avi</span></code></dt><dd><p>avi infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spd</span></code></dt><dd><p>spd infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vendor</span></code></dt><dd><p>union of all vendor infoframes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audio</span></code></dt><dd><p>audio infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drm</span></code></dt><dd><p>Dynamic Range and Mastering infoframe</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is used by the generic pack function. This works since all infoframes
have the same header which also indicates which type of infoframe should be
packed.</p>
<dl class="function">
<dt id="c.hdmi_avi_infoframe_init">
void <code class="sig-name descname">hdmi_avi_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe<em> *frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_avi_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI AVI infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.hdmi_avi_infoframe_check">
int <code class="sig-name descname">hdmi_avi_infoframe_check</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe<em> *frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_avi_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI AVI infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_avi_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_avi_infoframe_pack_only</code><span class="sig-paren">(</span>const struct hdmi_avi_infoframe<em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_avi_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write HDMI AVI infoframe to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_avi_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_avi_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe<em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_avi_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI AVI infoframe, and write it to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI AVI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_spd_infoframe_init">
int <code class="sig-name descname">hdmi_spd_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_spd_infoframe<em> *frame</em>, const char<em> *vendor</em>, const char<em> *product</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_spd_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI SPD infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_spd_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI SPD infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*vendor</span></code></dt><dd><p>vendor string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*product</span></code></dt><dd><p>product string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_spd_infoframe_check">
int <code class="sig-name descname">hdmi_spd_infoframe_check</code><span class="sig-paren">(</span>struct hdmi_spd_infoframe<em> *frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_spd_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI SPD infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_spd_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI SPD infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_spd_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_spd_infoframe_pack_only</code><span class="sig-paren">(</span>const struct hdmi_spd_infoframe<em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_spd_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write HDMI SPD infoframe to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_spd_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI SPD infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_spd_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_spd_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_spd_infoframe<em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_spd_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI SPD infoframe, and write it to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_spd_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI SPD infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_audio_infoframe_init">
int <code class="sig-name descname">hdmi_audio_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_audio_infoframe<em> *frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_audio_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI audio infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_audio_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI audio infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_audio_infoframe_check">
int <code class="sig-name descname">hdmi_audio_infoframe_check</code><span class="sig-paren">(</span>const struct hdmi_audio_infoframe<em> *frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_audio_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI audio infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_audio_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI audio infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_audio_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_audio_infoframe_pack_only</code><span class="sig-paren">(</span>const struct hdmi_audio_infoframe<em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_audio_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write HDMI audio infoframe to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_audio_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI audio infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_audio_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_audio_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_audio_infoframe<em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_audio_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI Audio infoframe, and write it to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_audio_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI Audio infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_audio_infoframe_pack_for_dp">
ssize_t <code class="sig-name descname">hdmi_audio_infoframe_pack_for_dp</code><span class="sig-paren">(</span>const struct hdmi_audio_infoframe<em> *frame</em>, struct <a class="reference internal" href="#c.dp_sdp" title="dp_sdp">dp_sdp</a><em> *sdp</em>, u8<em> dp_version</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_audio_infoframe_pack_for_dp" title="Permalink to this definition">¶</a></dt>
<dd><p>Pack a HDMI Audio infoframe for DisplayPort</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_audio_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI Audio infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dp_sdp</span> <span class="pre">*sdp</span></code></dt><dd><p>Secondary data packet for DisplayPort.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">dp_version</span></code></dt><dd><p>DisplayPort version to be encoded in the header</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs a HDMI Audio Infoframe to be sent over DisplayPort. This function
fills the secondary data packet to be used for DisplayPort.</p>
<p><strong>Return</strong></p>
<p>Number of total written bytes or a negative errno on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_vendor_infoframe_init">
int <code class="sig-name descname">hdmi_vendor_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_vendor_infoframe<em> *frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_vendor_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI vendor infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI vendor infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_vendor_infoframe_check">
int <code class="sig-name descname">hdmi_vendor_infoframe_check</code><span class="sig-paren">(</span>struct hdmi_vendor_infoframe<em> *frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_vendor_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI vendor infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_vendor_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_vendor_infoframe_pack_only</code><span class="sig-paren">(</span>const struct hdmi_vendor_infoframe<em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_vendor_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write a HDMI vendor infoframe to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_vendor_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_vendor_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_vendor_infoframe<em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_vendor_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI Vendor infoframe, and write it to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_vendor_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI Vendor infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_drm_infoframe_init">
int <code class="sig-name descname">hdmi_drm_infoframe_init</code><span class="sig-paren">(</span>struct hdmi_drm_infoframe<em> *frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_drm_infoframe_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an HDMI Dynaminc Range and mastering infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_drm_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI DRM infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_drm_infoframe_check">
int <code class="sig-name descname">hdmi_drm_infoframe_check</code><span class="sig-paren">(</span>struct hdmi_drm_infoframe<em> *frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_drm_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI DRM infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_drm_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI DRM infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent.
Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_drm_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_drm_infoframe_pack_only</code><span class="sig-paren">(</span>const struct hdmi_drm_infoframe<em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_drm_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write HDMI DRM infoframe to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hdmi_drm_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI DRM infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_drm_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_drm_infoframe_pack</code><span class="sig-paren">(</span>struct hdmi_drm_infoframe<em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_drm_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI DRM infoframe, and write it to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_drm_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI DRM infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_infoframe_check">
int <code class="sig-name descname">hdmi_infoframe_check</code><span class="sig-paren">(</span>union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a><em> *frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_infoframe_pack_only">
ssize_t <code class="sig-name descname">hdmi_infoframe_pack_only</code><span class="sig-paren">(</span>const union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a><em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_pack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>write a HDMI infoframe to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Packs the information contained in the <strong>frame</strong> structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_infoframe_pack">
ssize_t <code class="sig-name descname">hdmi_infoframe_pack</code><span class="sig-paren">(</span>union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a><em> *frame</em>, void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>check a HDMI infoframe, and write it to binary buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validates that the infoframe is consistent and updates derived fields
(eg. length) based on other fields, after which it packs the information
contained in the <strong>frame</strong> structure into a binary representation that
can be written into the corresponding controller registers. This function
also computes the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns the number of bytes packed into the binary buffer or a negative
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_infoframe_log">
void <code class="sig-name descname">hdmi_infoframe_log</code><span class="sig-paren">(</span>const char<em> *level</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a><em> *frame</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_log" title="Permalink to this definition">¶</a></dt>
<dd><p>log info of HDMI infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*level</span></code></dt><dd><p>logging level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.hdmi_drm_infoframe_unpack_only">
int <code class="sig-name descname">hdmi_drm_infoframe_unpack_only</code><span class="sig-paren">(</span>struct hdmi_drm_infoframe<em> *frame</em>, const void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_drm_infoframe_unpack_only" title="Permalink to this definition">¶</a></dt>
<dd><p>unpack binary buffer of CTA-861-G DRM infoframe DataBytes to a HDMI DRM infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hdmi_drm_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI DRM infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unpacks CTA-861-G DRM infoframe DataBytes contained in the binary <strong>buffer</strong>
into a structured <strong>frame</strong> of the HDMI Dynamic Range and Mastering (DRM)
infoframe.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.hdmi_infoframe_unpack">
int <code class="sig-name descname">hdmi_infoframe_unpack</code><span class="sig-paren">(</span>union <a class="reference internal" href="#c.hdmi_infoframe" title="hdmi_infoframe">hdmi_infoframe</a><em> *frame</em>, const void<em> *buffer</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hdmi_infoframe_unpack" title="Permalink to this definition">¶</a></dt>
<dd><p>unpack binary buffer to a HDMI infoframe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">hdmi_infoframe</span> <span class="pre">*frame</span></code></dt><dd><p>HDMI infoframe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unpacks the information contained in binary buffer <strong>buffer</strong> into a structured
<strong>frame</strong> of a HDMI infoframe.
Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
specification.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
</div>
</section>
<section id="rectangle-utilities-reference">
<h2>Rectangle Utilities Reference<a class="headerlink" href="#rectangle-utilities-reference" title="Permalink to this headline">¶</a></h2>
<p>Utility functions to help manage rectangular areas for
clipping, scaling, etc. calculations.</p>
<dl class="type">
<dt id="c.drm_rect">
struct <code class="sig-name descname">drm_rect</code><a class="headerlink" href="#c.drm_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>two dimensional rectangle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_rect {
    int x1, y1, x2, y2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x1</span></code></dt><dd><p>horizontal starting coordinate (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y1</span></code></dt><dd><p>vertical starting coordinate (inclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">x2</span></code></dt><dd><p>horizontal ending coordinate (exclusive)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y2</span></code></dt><dd><p>vertical ending coordinate (exclusive)</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note that this must match the layout of <a class="reference internal" href="drm-uapi.html#c.drm_mode_rect" title="drm_mode_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_rect</span></code></a> or the damage
helpers like <a class="reference internal" href="drm-kms.html#c.drm_atomic_helper_damage_iter_init" title="drm_atomic_helper_damage_iter_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_damage_iter_init()</span></code></a> break.</p>
<dl class="function">
<dt id="c.DRM_RECT_INIT">
<code class="sig-name descname">DRM_RECT_INIT</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>w</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_INIT" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a rectangle from x/y/w/h</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>x coordinate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">y</span></code></dt><dd><p>y coordinate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">w</span></code></dt><dd><p>width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h</span></code></dt><dd><p>height</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A new rectangle of the specified size.</p>
</div>
<dl class="function">
<dt id="c.DRM_RECT_FMT">
<code class="sig-name descname">DRM_RECT_FMT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FMT" title="Permalink to this definition">¶</a></dt>
<dd><p>printf string for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
</div>
<dl class="function">
<dt id="c.DRM_RECT_ARG">
<code class="sig-name descname">DRM_RECT_ARG</code><span class="sig-paren">(</span><em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_ARG" title="Permalink to this definition">¶</a></dt>
<dd><p>printf arguments for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">r</span></code></dt><dd><p>rectangle struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.DRM_RECT_FP_FMT">
<code class="sig-name descname">DRM_RECT_FP_FMT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FP_FMT" title="Permalink to this definition">¶</a></dt>
<dd><p>printf string for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a> in 16.16 fixed point</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
</div>
<dl class="function">
<dt id="c.DRM_RECT_FP_ARG">
<code class="sig-name descname">DRM_RECT_FP_ARG</code><span class="sig-paren">(</span><em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FP_ARG" title="Permalink to this definition">¶</a></dt>
<dd><p>printf arguments for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a> in 16.16 fixed point</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">r</span></code></dt><dd><p>rectangle struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is useful for e.g. printing plane source rectangles, which are in 16.16
fixed point.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_init">
void <code class="sig-name descname">drm_rect_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r</em>, int<em> x</em>, int<em> y</em>, int<em> width</em>, int<em> height</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the rectangle from x/y/w/h</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r</span></code></dt><dd><p>rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span></code></dt><dd><p>x coordinate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">y</span></code></dt><dd><p>y coordinate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">height</span></code></dt><dd><p>height</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_rect_adjust_size">
void <code class="sig-name descname">drm_rect_adjust_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r</em>, int<em> dw</em>, int<em> dh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_adjust_size" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the size of the rectangle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r</span></code></dt><dd><p>rectangle to be adjusted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dw</span></code></dt><dd><p>horizontal adjustment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dh</span></code></dt><dd><p>vertical adjustment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Change the size of rectangle <strong>r</strong> by <strong>dw</strong> in the horizontal direction,
and by <strong>dh</strong> in the vertical direction, while keeping the center
of <strong>r</strong> stationary.</p>
<p>Positive <strong>dw</strong> and <strong>dh</strong> increase the size, negative values decrease it.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_translate">
void <code class="sig-name descname">drm_rect_translate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r</em>, int<em> dx</em>, int<em> dy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_translate" title="Permalink to this definition">¶</a></dt>
<dd><p>translate the rectangle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r</span></code></dt><dd><p>rectangle to be tranlated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dx</span></code></dt><dd><p>horizontal translation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dy</span></code></dt><dd><p>vertical translation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move rectangle <strong>r</strong> by <strong>dx</strong> in the horizontal direction,
and by <strong>dy</strong> in the vertical direction.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_translate_to">
void <code class="sig-name descname">drm_rect_translate_to</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r</em>, int<em> x</em>, int<em> y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_translate_to" title="Permalink to this definition">¶</a></dt>
<dd><p>translate the rectangle to an absolute position</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r</span></code></dt><dd><p>rectangle to be tranlated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span></code></dt><dd><p>horizontal position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">y</span></code></dt><dd><p>vertical position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move rectangle <strong>r</strong> to <strong>x</strong> in the horizontal direction,
and to <strong>y</strong> in the vertical direction.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_downscale">
void <code class="sig-name descname">drm_rect_downscale</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r</em>, int<em> horz</em>, int<em> vert</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_downscale" title="Permalink to this definition">¶</a></dt>
<dd><p>downscale a rectangle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r</span></code></dt><dd><p>rectangle to be downscaled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">horz</span></code></dt><dd><p>horizontal downscale factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vert</span></code></dt><dd><p>vertical downscale factor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Divide the coordinates of rectangle <strong>r</strong> by <strong>horz</strong> and <strong>vert</strong>.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_width">
int <code class="sig-name descname">drm_rect_width</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_width" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the rectangle width</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r</span></code></dt><dd><p>rectangle whose width is returned</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The width of the rectangle.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_height">
int <code class="sig-name descname">drm_rect_height</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_height" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the rectangle height</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r</span></code></dt><dd><p>rectangle whose height is returned</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The height of the rectangle.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_visible">
bool <code class="sig-name descname">drm_rect_visible</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_visible" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if the rectangle is visible</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r</span></code></dt><dd><p>rectangle whose visibility is returned</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the rectangle is visible, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_equals">
bool <code class="sig-name descname">drm_rect_equals</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r1</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_equals" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if two rectangles are equal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r1</span></code></dt><dd><p>first rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r2</span></code></dt><dd><p>second rectangle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if the rectangles are equal, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_fp_to_int">
void <code class="sig-name descname">drm_rect_fp_to_int</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *dst</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_fp_to_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a rect in 16.16 fixed point form to int form.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*dst</span></code></dt><dd><p>rect to be stored the converted value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*src</span></code></dt><dd><p>rect in 16.16 fixed point form</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_rect_intersect">
bool <code class="sig-name descname">drm_rect_intersect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r1</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_intersect" title="Permalink to this definition">¶</a></dt>
<dd><p>intersect two rectangles</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r1</span></code></dt><dd><p>first rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r2</span></code></dt><dd><p>second rectangle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the intersection of rectangles <strong>r1</strong> and <strong>r2</strong>.
<strong>r1</strong> will be overwritten with the intersection.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if rectangle <strong>r1</strong> is still visible after the operation,
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_clip_scaled">
bool <code class="sig-name descname">drm_rect_clip_scaled</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *src</em>, struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *dst</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *clip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_clip_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a scaled clip operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*src</span></code></dt><dd><p>source window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*dst</span></code></dt><dd><p>destination window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*clip</span></code></dt><dd><p>clip rectangle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clip rectangle <strong>dst</strong> by rectangle <strong>clip</strong>. Clip rectangle <strong>src</strong> by
the corresponding amounts, retaining the vertical and horizontal scaling
factors from <strong>src</strong> to <strong>dst</strong>.</p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if rectangle <strong>dst</strong> is still visible after being clipped,
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<p><strong>Return</strong></p>
</div>
<dl class="function">
<dt id="c.drm_rect_calc_hscale">
int <code class="sig-name descname">drm_rect_calc_hscale</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *src</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *dst</em>, int<em> min_hscale</em>, int<em> max_hscale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_calc_hscale" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the horizontal scaling factor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*src</span></code></dt><dd><p>source window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*dst</span></code></dt><dd><p>destination window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_hscale</span></code></dt><dd><p>minimum allowed horizontal scaling factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_hscale</span></code></dt><dd><p>maximum allowed horizontal scaling factor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the horizontal scaling factor as
(<strong>src</strong> width) / (<strong>dst</strong> width).</p>
<p>If the scale is below 1 &lt;&lt; 16, round down. If the scale is above
1 &lt;&lt; 16, round up. This will calculate the scale with the most
pessimistic limit calculation.</p>
<p><strong>Return</strong></p>
<p>The horizontal scaling factor, or errno of out of limits.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_calc_vscale">
int <code class="sig-name descname">drm_rect_calc_vscale</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *src</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *dst</em>, int<em> min_vscale</em>, int<em> max_vscale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_calc_vscale" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the vertical scaling factor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*src</span></code></dt><dd><p>source window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*dst</span></code></dt><dd><p>destination window rectangle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_vscale</span></code></dt><dd><p>minimum allowed vertical scaling factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_vscale</span></code></dt><dd><p>maximum allowed vertical scaling factor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the vertical scaling factor as
(<strong>src</strong> height) / (<strong>dst</strong> height).</p>
<p>If the scale is below 1 &lt;&lt; 16, round down. If the scale is above
1 &lt;&lt; 16, round up. This will calculate the scale with the most
pessimistic limit calculation.</p>
<p><strong>Return</strong></p>
<p>The vertical scaling factor, or errno of out of limits.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_debug_print">
void <code class="sig-name descname">drm_rect_debug_print</code><span class="sig-paren">(</span>const char<em> *prefix</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r</em>, bool<em> fixed_point</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_debug_print" title="Permalink to this definition">¶</a></dt>
<dd><p>print the rectangle information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*prefix</span></code></dt><dd><p>prefix string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r</span></code></dt><dd><p>rectangle to print</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">fixed_point</span></code></dt><dd><p>rectangle is in 16.16 fixed point format</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_rect_rotate">
void <code class="sig-name descname">drm_rect_rotate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r</em>, int<em> width</em>, int<em> height</em>, unsigned int<em> rotation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the rectangle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r</span></code></dt><dd><p>rectangle to be rotated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>Width of the coordinate space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">height</span></code></dt><dd><p>Height of the coordinate space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt><dd><p>Transformation to be applied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply <strong>rotation</strong> to the coordinates of rectangle <strong>r</strong>.</p>
<p><strong>width</strong> and <strong>height</strong> combined with <strong>rotation</strong> define
the location of the new origin.</p>
<p><strong>width</strong> correcsponds to the horizontal and <strong>height</strong>
to the vertical axis of the untransformed coordinate
space.</p>
</div>
<dl class="function">
<dt id="c.drm_rect_rotate_inv">
void <code class="sig-name descname">drm_rect_rotate_inv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a><em> *r</em>, int<em> width</em>, int<em> height</em>, unsigned int<em> rotation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_rotate_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse rotate the rectangle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*r</span></code></dt><dd><p>rectangle to be rotated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>Width of the coordinate space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">height</span></code></dt><dd><p>Height of the coordinate space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt><dd><p>Transformation whose inverse is to be applied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the inverse of <strong>rotation</strong> to the coordinates
of rectangle <strong>r</strong>.</p>
<p><strong>width</strong> and <strong>height</strong> combined with <strong>rotation</strong> define
the location of the new origin.</p>
<p><strong>width</strong> correcsponds to the horizontal and <strong>height</strong>
to the vertical axis of the original untransformed
coordinate space, so that you never have to flip
them when doing a rotatation and its inverse.
That is, if you do</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>drm_rect_rotate(&amp;r, width, height, rotation);
drm_rect_rotate_inv(&amp;r, width, height, rotation);
</pre></div>
</div>
<p>you will always get back the original rectangle.</p>
</div>
</section>
<section id="flip-work-helper-reference">
<h2>Flip-work Helper Reference<a class="headerlink" href="#flip-work-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>Util to queue up work to run from work-queue context after flip/vblank.
Typically this can be used to defer unref of framebuffer’s, cursor
bo’s, etc until after vblank.  The APIs are all thread-safe.
Moreover, drm_flip_work_queue_task and drm_flip_work_queue can be called
in atomic context.</p>
<dl class="type">
<dt id="c.drm_flip_task">
struct <code class="sig-name descname">drm_flip_task</code><a class="headerlink" href="#c.drm_flip_task" title="Permalink to this definition">¶</a></dt>
<dd><p>flip work task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_flip_task {
    struct list_head node;
    void *data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>list entry element</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>data to pass to <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_flip_work.func</span></code></a></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_flip_work">
struct <code class="sig-name descname">drm_flip_work</code><a class="headerlink" href="#c.drm_flip_work" title="Permalink to this definition">¶</a></dt>
<dd><p>flip work queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_flip_work {
    const char *name;
    drm_flip_func_t func;
    struct work_struct worker;
    struct list_head queued;
    struct list_head commited;
    spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>debug name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">func</span></code></dt><dd><p>callback fxn called for each committed item</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">worker</span></code></dt><dd><p>worker which calls <strong>func</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queued</span></code></dt><dd><p>queued tasks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">commited</span></code></dt><dd><p>commited tasks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>lock to access queued and commited lists</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_flip_work_allocate_task">
struct <a class="reference internal" href="#c.drm_flip_task" title="drm_flip_task">drm_flip_task</a> * <code class="sig-name descname">drm_flip_work_allocate_task</code><span class="sig-paren">(</span>void<em> *data</em>, gfp_t<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_allocate_task" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a flip-work task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data associated to the task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt><dd><p>allocator flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a drm_flip_task object and attach private data to it.</p>
</div>
<dl class="function">
<dt id="c.drm_flip_work_queue_task">
void <code class="sig-name descname">drm_flip_work_queue_task</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a><em> *work</em>, struct <a class="reference internal" href="#c.drm_flip_task" title="drm_flip_task">drm_flip_task</a><em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_queue_task" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a specific task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*work</span></code></dt><dd><p>the flip-work</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_task</span> <span class="pre">*task</span></code></dt><dd><p>the task to handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queues task, that will later be run (passed back to drm_flip_func_t
func) on a work queue after <a class="reference internal" href="#c.drm_flip_work_commit" title="drm_flip_work_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_flip_work_commit()</span></code></a> is called.</p>
</div>
<dl class="function">
<dt id="c.drm_flip_work_queue">
void <code class="sig-name descname">drm_flip_work_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a><em> *work</em>, void<em> *val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>queue work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*work</span></code></dt><dd><p>the flip-work</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*val</span></code></dt><dd><p>the value to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queues work, that will later be run (passed back to drm_flip_func_t
func) on a work queue after <a class="reference internal" href="#c.drm_flip_work_commit" title="drm_flip_work_commit"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_flip_work_commit()</span></code></a> is called.</p>
</div>
<dl class="function">
<dt id="c.drm_flip_work_commit">
void <code class="sig-name descname">drm_flip_work_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a><em> *work</em>, struct workqueue_struct<em> *wq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>commit queued work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*work</span></code></dt><dd><p>the flip-work</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*wq</span></code></dt><dd><p>the work-queue to run the queued work on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Trigger work previously queued by <a class="reference internal" href="#c.drm_flip_work_queue" title="drm_flip_work_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_flip_work_queue()</span></code></a> to run
on a workqueue.  The typical usage would be to queue work (via
<a class="reference internal" href="#c.drm_flip_work_queue" title="drm_flip_work_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_flip_work_queue()</span></code></a>) at any point (from vblank irq and/or
prior), and then from vblank irq commit the queued work.</p>
</div>
<dl class="function">
<dt id="c.drm_flip_work_init">
void <code class="sig-name descname">drm_flip_work_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a><em> *work</em>, const char<em> *name</em>, drm_flip_func_t<em> func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize flip-work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*work</span></code></dt><dd><p>the flip-work to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>debug name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drm_flip_func_t</span> <span class="pre">func</span></code></dt><dd><p>the callback work function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes/allocates resources for the flip-work</p>
</div>
<dl class="function">
<dt id="c.drm_flip_work_cleanup">
void <code class="sig-name descname">drm_flip_work_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work">drm_flip_work</a><em> *work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_flip_work_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up flip-work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_flip_work</span> <span class="pre">*work</span></code></dt><dd><p>the flip-work to cleanup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroy resources allocated for the flip-work</p>
</div>
</section>
<section id="auxiliary-modeset-helpers">
<h2>Auxiliary Modeset Helpers<a class="headerlink" href="#auxiliary-modeset-helpers" title="Permalink to this headline">¶</a></h2>
<p>This helper library contains various one-off functions which don’t really fit
anywhere else in the DRM modeset helper library.</p>
<dl class="function">
<dt id="c.drm_helper_move_panel_connectors_to_head">
void <code class="sig-name descname">drm_helper_move_panel_connectors_to_head</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_move_panel_connectors_to_head" title="Permalink to this definition">¶</a></dt>
<dd><p>move panels to the front in the connector list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some userspace presumes that the first connected connector is the main
display, where it’s supposed to display e.g. the login screen. For
laptops, this should be the main panel. Use this function to sort all
(eDP/LVDS/DSI) panels to the front of the connector list, instead of
painstakingly trying to initialize them in the right order.</p>
</div>
<dl class="function">
<dt id="c.drm_helper_mode_fill_fb_struct">
void <code class="sig-name descname">drm_helper_mode_fill_fb_struct</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, const struct <a class="reference internal" href="drm-uapi.html#c.drm_mode_fb_cmd2" title="drm_mode_fb_cmd2">drm_mode_fb_cmd2</a><em> *mode_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_mode_fill_fb_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>fill out framebuffer metadata</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>drm_framebuffer object to fill out</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*mode_cmd</span></code></dt><dd><p>metadata from the userspace fb creation request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper can be used in a drivers fb_create callback to pre-fill the fb’s
metadata fields.</p>
</div>
<dl class="function">
<dt id="c.drm_crtc_init">
int <code class="sig-name descname">drm_crtc_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, const struct <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs">drm_crtc_funcs</a><em> *funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Legacy CRTC initialization function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC object to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_funcs</span> <span class="pre">*funcs</span></code></dt><dd><p>callbacks for the new CRTC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a CRTC object with a default helper-provided primary plane and no
cursor plane.</p>
<p>Note that we make some assumptions about hardware limitations that may not be
true for all hardware:</p>
<ol class="arabic simple">
<li><p>Primary plane cannot be repositioned.</p></li>
<li><p>Primary plane cannot be scaled.</p></li>
<li><p>Primary plane must cover the entire CRTC.</p></li>
<li><p>Subpixel positioning is not supported.</p></li>
<li><p>The primary plane must always be on if the CRTC is enabled.</p></li>
</ol>
<p>This is purely a backwards compatibility helper for old drivers. Drivers
should instead implement their own primary plane. Atomic drivers must do so.
Drivers with the above hardware restriction can look into using <a class="reference internal" href="#c.drm_simple_display_pipe" title="drm_simple_display_pipe"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_simple_display_pipe</span></code></a>, which encapsulates the above limitations into a nice
interface.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_mode_config_helper_suspend">
int <code class="sig-name descname">drm_mode_config_helper_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_helper_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Modeset suspend helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function takes care of suspending the modeset side. It disables
output polling if initialized, suspends fbdev if used and finally calls
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a>.
If suspending fails, fbdev and polling is re-enabled.</p>
<p>See also:
<a class="reference internal" href="#c.drm_kms_helper_poll_disable" title="drm_kms_helper_poll_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_disable()</span></code></a> and <a class="reference internal" href="#c.drm_fb_helper_set_suspend_unlocked" title="drm_fb_helper_set_suspend_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_set_suspend_unlocked()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on error.</p>
</div>
<dl class="function">
<dt id="c.drm_mode_config_helper_resume">
int <code class="sig-name descname">drm_mode_config_helper_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_helper_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Modeset resume helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function takes care of resuming the modeset side. It calls
<a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a>, resumes fbdev if used and enables output polling
if initiaized.</p>
<p>See also:
<a class="reference internal" href="#c.drm_fb_helper_set_suspend_unlocked" title="drm_fb_helper_set_suspend_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_fb_helper_set_suspend_unlocked()</span></code></a> and <a class="reference internal" href="#c.drm_kms_helper_poll_enable" title="drm_kms_helper_poll_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_kms_helper_poll_enable()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on error.</p>
</div>
</section>
<section id="of-dt-helpers">
<h2>OF/DT Helpers<a class="headerlink" href="#of-dt-helpers" title="Permalink to this headline">¶</a></h2>
<p>A set of helper functions to aid DRM drivers in parsing standard DT
properties.</p>
<dl class="function">
<dt id="c.drm_of_crtc_port_mask">
uint32_t <code class="sig-name descname">drm_of_crtc_port_mask</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct device_node<em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_crtc_port_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>find the mask of a registered CRTC by port OF node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*port</span></code></dt><dd><p>port OF node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a port OF node, return the possible mask of the corresponding
CRTC within a device’s list of CRTCs.  Returns zero if not found.</p>
</div>
<dl class="function">
<dt id="c.drm_of_find_possible_crtcs">
uint32_t <code class="sig-name descname">drm_of_find_possible_crtcs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em>, struct device_node<em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_find_possible_crtcs" title="Permalink to this definition">¶</a></dt>
<dd><p>find the possible CRTCs for an encoder port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*port</span></code></dt><dd><p>encoder port to scan for endpoints</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan all endpoints attached to a port, locate their attached CRTCs,
and generate the DRM mask of CRTCs which may be attached to this
encoder.</p>
<p>See Documentation/devicetree/bindings/graph.txt for the bindings.</p>
</div>
<dl class="function">
<dt id="c.drm_of_component_match_add">
void <code class="sig-name descname">drm_of_component_match_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *master</em>, struct component_match<em> **matchptr</em>, int (<em>*compare</em>)(struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *, void *), struct device_node<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_component_match_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a component helper OF node match rule</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*master</span></code></dt><dd><p>master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">component_match</span> <span class="pre">**matchptr</span></code></dt><dd><p>component match pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*compare)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>compare function used for matching component</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt><dd><p>of_node</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.drm_of_component_probe">
int <code class="sig-name descname">drm_of_component_probe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, int (<em>*compare_of</em>)(struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *, void *), const struct <a class="reference internal" href="../driver-api/component.html#c.component_master_ops" title="component_master_ops">component_master_ops</a><em> *m_ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_component_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic probe function for a component based master</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>master device containing the OF node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*compare_of)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>compare function used for matching components</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">component_master_ops</span> <span class="pre">*m_ops</span></code></dt><dd><p>component master ops to be used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the platform device OF node and bind all the components associated
with the master. Interface ports are added before the encoders in order to
satisfy their .bind requirements
See Documentation/devicetree/bindings/graph.txt for the bindings.</p>
<p>Returns zero if successful, or one of the standard error codes if it fails.</p>
</div>
<dl class="function">
<dt id="c.drm_of_find_panel_or_bridge">
int <code class="sig-name descname">drm_of_find_panel_or_bridge</code><span class="sig-paren">(</span>const struct device_node<em> *np</em>, int<em> port</em>, int<em> endpoint</em>, struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a><em> **panel</em>, struct <a class="reference internal" href="#c.drm_bridge" title="drm_bridge">drm_bridge</a><em> **bridge</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_find_panel_or_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>return connected panel or bridge device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>device tree node containing encoder output ports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">port</span></code></dt><dd><p>port in the device tree node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">endpoint</span></code></dt><dd><p>endpoint in the device tree node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">**panel</span></code></dt><dd><p>pointer to hold returned drm_panel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_bridge</span> <span class="pre">**bridge</span></code></dt><dd><p>pointer to hold returned drm_bridge</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a DT node’s port and endpoint number, find the connected node and
return either the associated <a class="reference internal" href="#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_panel</span></code></a> or drm_bridge device. Either
<strong>panel</strong> or <strong>bridge</strong> must not be NULL.</p>
<p>This function is deprecated and should not be used in new drivers. Use
<a class="reference internal" href="#c.devm_drm_of_get_bridge" title="devm_drm_of_get_bridge"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_drm_of_get_bridge()</span></code></a> instead.</p>
<p>Returns zero if successful, or one of the standard error codes if it fails.</p>
</div>
<dl class="function">
<dt id="c.drm_of_lvds_get_dual_link_pixel_order">
int <code class="sig-name descname">drm_of_lvds_get_dual_link_pixel_order</code><span class="sig-paren">(</span>const struct device_node<em> *port1</em>, const struct device_node<em> *port2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_lvds_get_dual_link_pixel_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Get LVDS dual-link pixel order</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*port1</span></code></dt><dd><p>First DT port node of the Dual-link LVDS source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*port2</span></code></dt><dd><p>Second DT port node of the Dual-link LVDS source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An LVDS dual-link connection is made of two links, with even pixels
transitting on one link, and odd pixels on the other link. This function
returns, for two ports of an LVDS dual-link source, which port shall transmit
the even and odd pixels, based on the requirements of the connected sink.</p>
<p>The pixel order is determined from the dual-lvds-even-pixels and
dual-lvds-odd-pixels properties in the sink’s DT port nodes. If those
properties are not present, or if their usage is not valid, this function
returns -EINVAL.</p>
<p>If either port is not connected, this function returns -EPIPE.</p>
<p><strong>port1</strong> and <strong>port2</strong> are typically DT sibling nodes, but may have different
parents when, for instance, two separate LVDS encoders carry the even and odd
pixels.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS - <strong>port1</strong> carries even pixels and <strong>port2</strong>
carries odd pixels</p></li>
<li><p>DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS - <strong>port1</strong> carries odd pixels and <strong>port2</strong>
carries even pixels</p></li>
<li><p>-EINVAL - <strong>port1</strong> and <strong>port2</strong> are not connected to a dual-link LVDS sink, or
the sink configuration is invalid</p></li>
<li><p>-EPIPE - when <strong>port1</strong> or <strong>port2</strong> are not connected</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.drm_of_lvds_get_data_mapping">
int <code class="sig-name descname">drm_of_lvds_get_data_mapping</code><span class="sig-paren">(</span>const struct device_node<em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_lvds_get_data_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Get LVDS data mapping</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*port</span></code></dt><dd><p>DT port node of the LVDS source or sink</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convert DT “data-mapping” property string value into media bus format value.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>MEDIA_BUS_FMT_RGB666_1X7X3_SPWG - data-mapping is “jeida-18”</p></li>
<li><p>MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA - data-mapping is “jeida-24”</p></li>
<li><p>MEDIA_BUS_FMT_RGB888_1X7X4_SPWG - data-mapping is “vesa-24”</p></li>
<li><p>-EINVAL - the “data-mapping” property is unsupported</p></li>
<li><p>-ENODEV - the “data-mapping” property is missing</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.drm_of_get_data_lanes_count">
int <code class="sig-name descname">drm_of_get_data_lanes_count</code><span class="sig-paren">(</span>const struct device_node<em> *endpoint</em>, const unsigned int<em> min</em>, const unsigned int<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_get_data_lanes_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Get DSI/(e)DP data lane count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*endpoint</span></code></dt><dd><p>DT endpoint node of the DSI/(e)DP source or sink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>minimum supported number of data lanes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt><dd><p>maximum supported number of data lanes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Count DT “data-lanes” property elements and check for validity.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>min..max - positive integer count of “data-lanes” elements</p></li>
<li><p>-ve - the “data-lanes” property is missing or invalid</p></li>
<li><p>-EINVAL - the “data-lanes” property is unsupported</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.drm_of_get_data_lanes_count_ep">
int <code class="sig-name descname">drm_of_get_data_lanes_count_ep</code><span class="sig-paren">(</span>const struct device_node<em> *port</em>, int<em> port_reg</em>, int<em> reg</em>, const unsigned int<em> min</em>, const unsigned int<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_of_get_data_lanes_count_ep" title="Permalink to this definition">¶</a></dt>
<dd><p>Get DSI/(e)DP data lane count by endpoint</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*port</span></code></dt><dd><p>DT port node of the DSI/(e)DP source or sink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">port_reg</span></code></dt><dd><p>identifier (value of reg property) of the parent port node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">reg</span></code></dt><dd><p>identifier (value of reg property) of the endpoint node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>minimum supported number of data lanes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt><dd><p>maximum supported number of data lanes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Count DT “data-lanes” property elements and check for validity.
This variant uses endpoint specifier.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>min..max - positive integer count of “data-lanes” elements</p></li>
<li><p>-EINVAL - the “data-mapping” property is unsupported</p></li>
<li><p>-ENODEV - the “data-mapping” property is missing</p></li>
</ul>
</div>
</section>
<section id="legacy-plane-helper-reference">
<h2>Legacy Plane Helper Reference<a class="headerlink" href="#legacy-plane-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>This helper library has two parts. The first part has support to implement
primary plane support on top of the normal CRTC configuration interface.
Since the legacy <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_mode_config_funcs.set_config</span></code></a> interface ties the primary
plane together with the CRTC state this does not allow userspace to disable
the primary plane itself. The default primary plane only expose XRBG8888 and
ARGB8888 as valid pixel formats for the attached framebuffer.</p>
<p>Drivers are highly recommended to implement proper support for primary
planes, and newly merged drivers must not rely upon these transitional
helpers.</p>
<p>The second part also implements transitional helpers which allow drivers to
gradually switch to the atomic helper infrastructure for plane updates. Once
that switch is complete drivers shouldn’t use these any longer, instead using
the proper legacy implementations for update and disable plane hooks provided
by the atomic helpers.</p>
<p>Again drivers are strongly urged to switch to the new interfaces.</p>
<p>The plane helpers share the function table structures with other helpers,
specifically also the atomic helpers. See <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span></code></a> for
the details.</p>
<dl class="function">
<dt id="c.drm_plane_helper_update_primary">
int <code class="sig-name descname">drm_plane_helper_update_primary</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *fb</em>, int<em> crtc_x</em>, int<em> crtc_y</em>, unsigned int<em> crtc_w</em>, unsigned int<em> crtc_h</em>, uint32_t<em> src_x</em>, uint32_t<em> src_y</em>, uint32_t<em> src_w</em>, uint32_t<em> src_h</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_update_primary" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for updating primary planes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>the plane’s new CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*fb</span></code></dt><dd><p>the plane’s new framebuffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">crtc_x</span></code></dt><dd><p>x coordinate within CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">crtc_y</span></code></dt><dd><p>y coordinate within CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_w</span></code></dt><dd><p>width coordinate within CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">crtc_h</span></code></dt><dd><p>height coordinate within CRTC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_x</span></code></dt><dd><p>x coordinate within source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_y</span></code></dt><dd><p>y coordinate within source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_w</span></code></dt><dd><p>width coordinate within source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">src_h</span></code></dt><dd><p>height coordinate within source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>modeset locking context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper validates the given parameters and updates the primary plane.</p>
<p>This function is only useful for non-atomic modesetting. Don’t use
it in new drivers.</p>
<p><strong>Return</strong></p>
<p>Zero on success, or an errno code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_plane_helper_disable_primary">
int <code class="sig-name descname">drm_plane_helper_disable_primary</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_disable_primary" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for disabling primary planes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to disable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>modeset locking context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper returns an error when trying to disable the primary
plane.</p>
<p>This function is only useful for non-atomic modesetting. Don’t use
it in new drivers.</p>
<p><strong>Return</strong></p>
<p>An errno code.</p>
</div>
<dl class="function">
<dt id="c.drm_plane_helper_destroy">
void <code class="sig-name descname">drm_plane_helper_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for primary plane destruction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to destroy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane destroy handler for primary planes.  This handler
is called during CRTC destruction.  We disable the primary plane, remove
it from the DRM plane list, and deallocate the plane structure.</p>
</div>
<dl class="function">
<dt id="c.drm_plane_helper_atomic_check">
int <code class="sig-name descname">drm_plane_helper_atomic_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_atomic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to check plane atomic-state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>plane to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default plane-state check handler for planes whose atomic-state
scale and positioning are not expected to change since the plane is always
a fullscreen scanout buffer.</p>
<p>This is often the case for the primary plane of simple framebuffers. See
also <a class="reference internal" href="#c.drm_crtc_helper_atomic_check" title="drm_crtc_helper_atomic_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_helper_atomic_check()</span></code></a> for the respective CRTC-state check
helper function.</p>
<p><strong>Return</strong></p>
<p>Zero on success, or an errno code otherwise.</p>
</div>
</section>
<section id="legacy-crtc-modeset-helper-functions-reference">
<h2>Legacy CRTC/Modeset Helper Functions Reference<a class="headerlink" href="#legacy-crtc-modeset-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<p>The CRTC modeset helper library provides a default set_config implementation
in <a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_helper_set_config()</span></code></a>. Plus a few other convenience functions using
the same callbacks which drivers can use to e.g. restore the modeset
configuration on resume with <a class="reference internal" href="#c.drm_helper_resume_force_mode" title="drm_helper_resume_force_mode"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_resume_force_mode()</span></code></a>.</p>
<p>Note that this helper library doesn’t track the current power state of CRTCs
and encoders. It can call callbacks like <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> even
though the hardware is already in the desired state. This deficiency has been
fixed in the atomic helpers.</p>
<p>The driver callbacks are mostly compatible with the atomic modeset helpers,
except for the handling of the primary plane: Atomic helpers require that the
primary plane is implemented as a real standalone plane and not directly tied
to the CRTC state. For easier transition this library provides functions to
implement the old semantics required by the CRTC helpers using the new plane
and atomic helper callbacks.</p>
<p>Drivers are strongly urged to convert to the atomic helpers (by way of first
converting to the plane helpers). New drivers must not use these functions
but need to implement the atomic interface instead, potentially using the
atomic helpers for that.</p>
<p>These legacy modeset helpers use the same function table structures as
all other modesetting helpers. See the documentation for struct
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder_helper_funcs</span></code></a> and struct
<a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_helper_funcs</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_helper_encoder_in_use">
bool <code class="sig-name descname">drm_helper_encoder_in_use</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a><em> *encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_encoder_in_use" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a given encoder is in use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*encoder</span></code></dt><dd><p>encoder to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether <strong>encoder</strong> is with the current mode setting output configuration
in use by any connector. This doesn’t mean that it is actually enabled since
the DPMS state is tracked separately.</p>
<p><strong>Return</strong></p>
<p>True if <strong>encoder</strong> is used, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_helper_crtc_in_use">
bool <code class="sig-name descname">drm_helper_crtc_in_use</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_crtc_in_use" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a given CRTC is in a mode_config</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether <strong>crtc</strong> is with the current mode setting output configuration
in use by any connector. This doesn’t mean that it is actually enabled since
the DPMS state is tracked separately.</p>
<p><strong>Return</strong></p>
<p>True if <strong>crtc</strong> is used, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_helper_disable_unused_functions">
void <code class="sig-name descname">drm_helper_disable_unused_functions</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_disable_unused_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>disable unused objects</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks through the entire mode setting configuration of <strong>dev</strong>. It
will remove any CRTC links of unused encoders and encoder links of
disconnected connectors. Then it will disable all unused encoders and CRTCs
either by calling their disable callback if available or by calling their
dpms callback with DRM_MODE_DPMS_OFF.</p>
<p>This function is part of the legacy modeset helper library and will cause
major confusion with atomic drivers. This is because atomic helpers guarantee
to never call -&gt;disable() hooks on a disabled function, or -&gt;enable() hooks
on an enabled functions. <a class="reference internal" href="#c.drm_helper_disable_unused_functions" title="drm_helper_disable_unused_functions"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_disable_unused_functions()</span></code></a> on the other
hand throws such guarantees into the wind and calls disable hooks
unconditionally on unused functions.</p>
<p><strong>NOTE</strong></p>
</div>
<dl class="function">
<dt id="c.drm_crtc_helper_set_mode">
bool <code class="sig-name descname">drm_crtc_helper_set_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a><em> *mode</em>, int<em> x</em>, int<em> y</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a><em> *old_fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>internal helper to set a mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to program</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*mode</span></code></dt><dd><p>mode to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span></code></dt><dd><p>horizontal offset into the surface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">y</span></code></dt><dd><p>vertical offset into the surface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*old_fb</span></code></dt><dd><p>old framebuffer, for cleanup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to set <strong>mode</strong> on <strong>crtc</strong>.  Give <strong>crtc</strong> and its associated connectors a chance
to fixup or reject the mode prior to trying to set it. This is an internal
helper that drivers could e.g. use to update properties that require the
entire output pipe to be disabled and re-enabled in a new configuration. For
example for changing whether audio is enabled on a hdmi link or for changing
panel fitter or dither attributes. It is also called by the
<a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_helper_set_config()</span></code></a> helper function to drive the mode setting
sequence.</p>
<p><strong>Return</strong></p>
<p>True if the mode was set successfully, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_crtc_helper_atomic_check">
int <code class="sig-name descname">drm_crtc_helper_atomic_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_atomic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to check CRTC atomic-state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>CRTC to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>atomic state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides a default CRTC-state check handler for CRTCs that only have
one primary plane attached to it.</p>
<p>This is often the case for the CRTC of simple framebuffers. See also
<a class="reference internal" href="#c.drm_plane_helper_atomic_check" title="drm_plane_helper_atomic_check"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_plane_helper_atomic_check()</span></code></a> for the respective plane-state check
helper function.</p>
<p><strong>Return</strong></p>
<p>Zero on success, or an errno code otherwise.</p>
</div>
<dl class="function">
<dt id="c.drm_crtc_helper_set_config">
int <code class="sig-name descname">drm_crtc_helper_set_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_mode_set" title="drm_mode_set">drm_mode_set</a><em> *set</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>set a new config from userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_mode_set</span> <span class="pre">*set</span></code></dt><dd><p>mode set configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>lock acquire context, not used here</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_helper_set_config()</span></code></a> helper function implements the of
<a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_funcs.set_config</span></code></a> callback for drivers using the legacy CRTC
helpers.</p>
<p>It first tries to locate the best encoder for each connector by calling the
connector <strong>drm_connector_helper_funcs.best_encoder</strong> helper operation.</p>
<p>After locating the appropriate encoders, the helper function will call the
mode_fixup encoder and CRTC helper operations to adjust the requested mode,
or reject it completely in which case an error will be returned to the
application. If the new configuration after mode adjustment is identical to
the current configuration the helper function will return without performing
any other operation.</p>
<p>If the adjusted mode is identical to the current mode but changes to the
frame buffer need to be applied, the <a class="reference internal" href="#c.drm_crtc_helper_set_config" title="drm_crtc_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_crtc_helper_set_config()</span></code></a> function
will call the CRTC <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.mode_set_base</span></code></a> helper operation.</p>
<p>If the adjusted mode differs from the current mode, or if the
-&gt;mode_set_base() helper operation is not provided, the helper function
performs a full mode set sequence by calling the -&gt;prepare(), -&gt;mode_set()
and -&gt;commit() CRTC and encoder helper operations, in that order.
Alternatively it can also use the dpms and disable helper operations. For
details see <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc_helper_funcs</span></code></a> and struct
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs</span></code></a>.</p>
<p>This function is deprecated.  New drivers must implement atomic modeset
support, for which this function is unsuitable. Instead drivers should use
<a class="reference internal" href="#c.drm_atomic_helper_set_config" title="drm_atomic_helper_set_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_set_config()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Returns 0 on success, negative errno numbers on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_helper_connector_dpms">
int <code class="sig-name descname">drm_helper_connector_dpms</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a><em> *connector</em>, int<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_connector_dpms" title="Permalink to this definition">¶</a></dt>
<dd><p>connector dpms helper implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*connector</span></code></dt><dd><p>affected connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>DPMS mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.drm_helper_connector_dpms" title="drm_helper_connector_dpms"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_helper_connector_dpms()</span></code></a> helper function implements the
<a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_connector_funcs.dpms</span></code></a> callback for drivers using the legacy CRTC
helpers.</p>
<p>This is the main helper function provided by the CRTC helper framework for
implementing the DPMS connector attribute. It computes the new desired DPMS
state for all encoders and CRTCs in the output mesh and calls the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_helper_funcs.dpms</span></code></a> and <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> callbacks
provided by the driver.</p>
<p>This function is deprecated.  New drivers must implement atomic modeset
support, where DPMS is handled in the DRM core.</p>
<p><strong>Return</strong></p>
<p>Always returns 0.</p>
</div>
<dl class="function">
<dt id="c.drm_helper_resume_force_mode">
void <code class="sig-name descname">drm_helper_resume_force_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_resume_force_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>force-restore mode setting configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>drm_device which should be restored</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers which use the mode setting helpers can use this function to
force-restore the mode setting configuration e.g. on resume or when something
else might have trampled over the hw state (like some overzealous old BIOSen
tended to do).</p>
<p>This helper doesn’t provide a error return value since restoring the old
config should never fail due to resource allocation issues since the driver
has successfully set the restored configuration already. Hence this should
boil down to the equivalent of a few dpms on calls, which also don’t provide
an error code.</p>
<p>Drivers where simply restoring an old configuration again might fail (e.g.
due to slight differences in allocating shared resources when the
configuration is restored in a different order than when userspace set it up)
need to use their own restore logic.</p>
<p>This function is deprecated. New drivers should implement atomic mode-
setting and use the atomic suspend/resume helpers.</p>
<p>See also:
<a class="reference internal" href="#c.drm_atomic_helper_suspend" title="drm_atomic_helper_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_suspend()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_helper_resume" title="drm_atomic_helper_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_resume()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.drm_helper_force_disable_all">
int <code class="sig-name descname">drm_helper_force_disable_all</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_device" title="drm_device">drm_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_helper_force_disable_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Forcibly turn off all enabled CRTCs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*dev</span></code></dt><dd><p>DRM device whose CRTCs to turn off</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers may want to call this on unload to ensure that all displays are
unlit and the GPU is in a consistent, low power state. Takes modeset locks.</p>
<p><strong>Note</strong></p>
<p>This should only be used by non-atomic legacy drivers. For an atomic
version look at <a class="reference internal" href="#c.drm_atomic_helper_shutdown" title="drm_atomic_helper_shutdown"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_atomic_helper_shutdown()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
</div>
</section>
<section id="privacy-screen-class">
<h2>Privacy-screen class<a class="headerlink" href="#privacy-screen-class" title="Permalink to this headline">¶</a></h2>
<p>This class allows non KMS drivers, from e.g. drivers/platform/x86 to
register a privacy-screen device, which the KMS drivers can then use
to implement the standard privacy-screen properties, see
<a class="reference internal" href="drm-kms.html#standard-connector-properties"><span class="std std-ref">Standard Connector Properties</span></a>.</p>
<p>KMS drivers using a privacy-screen class device are advised to use the
<a class="reference internal" href="drm-kms.html#c.drm_connector_attach_privacy_screen_provider" title="drm_connector_attach_privacy_screen_provider"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_attach_privacy_screen_provider()</span></code></a> and
<a class="reference internal" href="drm-kms.html#c.drm_connector_update_privacy_screen" title="drm_connector_update_privacy_screen"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_connector_update_privacy_screen()</span></code></a> helpers for dealing with this.</p>
<dl class="type">
<dt id="c.drm_privacy_screen_ops">
struct <code class="sig-name descname">drm_privacy_screen_ops</code><a class="headerlink" href="#c.drm_privacy_screen_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>drm_privacy_screen operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_privacy_screen_ops {
    int (*set_sw_state)(struct drm_privacy_screen *priv, enum drm_privacy_screen_status sw_state);
    void (*get_hw_state)(struct drm_privacy_screen *priv);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">set_sw_state</span></code></dt><dd><p>Called to request a change of the privacy-screen
state. The privacy-screen class code contains a check to avoid this
getting called when the hw_state reports the state is locked.
It is the driver’s responsibility to update sw_state and hw_state.
This is always called with the drm_privacy_screen’s lock held.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_hw_state</span></code></dt><dd><p>Called to request that the driver gets the current
privacy-screen state from the hardware and then updates sw_state and
hw_state accordingly. This will be called by the core just before
the privacy-screen is registered in sysfs.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Defines the operations which the privacy-screen class code may call.
These functions should be implemented by the privacy-screen driver.</p>
<dl class="type">
<dt id="c.drm_privacy_screen">
struct <code class="sig-name descname">drm_privacy_screen</code><a class="headerlink" href="#c.drm_privacy_screen" title="Permalink to this definition">¶</a></dt>
<dd><p>central privacy-screen structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_privacy_screen {
    struct device dev;
    struct mutex lock;
    struct list_head list;
    struct blocking_notifier_head notifier_head;
    const struct drm_privacy_screen_ops *ops;
    enum drm_privacy_screen_status sw_state;
    enum drm_privacy_screen_status hw_state;
    void *drvdata;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device used to register the privacy-screen in sysfs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>mutex protection all fields in this struct.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>privacy-screen devices list list-entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notifier_head</span></code></dt><dd><p>privacy-screen notifier head.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p><a class="reference internal" href="#c.drm_privacy_screen_ops" title="drm_privacy_screen_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen_ops</span></code></a> for this privacy-screen.
This is NULL if the driver has unregistered the privacy-screen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sw_state</span></code></dt><dd><p>The privacy-screen’s software state, see
<a class="reference internal" href="drm-kms.html#standard-connector-properties"><span class="std std-ref">Standard Connector Properties</span></a>
for more info.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_state</span></code></dt><dd><p>The privacy-screen’s hardware state, see
<a class="reference internal" href="drm-kms.html#standard-connector-properties"><span class="std std-ref">Standard Connector Properties</span></a>
for more info.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drvdata</span></code></dt><dd><p>Private data owned by the privacy screen provider</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Central privacy-screen structure, this contains the <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> used
to register the screen in sysfs, the screen’s state, ops, etc.</p>
<dl class="type">
<dt id="c.drm_privacy_screen_lookup">
struct <code class="sig-name descname">drm_privacy_screen_lookup</code><a class="headerlink" href="#c.drm_privacy_screen_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>static privacy-screen lookup list entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_privacy_screen_lookup {
    struct list_head list;
    const char *dev_id;
    const char *con_id;
    const char *provider;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>Lookup list list-entry.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_id</span></code></dt><dd><p>Consumer device name or NULL to match all devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">con_id</span></code></dt><dd><p>Consumer connector name or NULL to match all connectors.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">provider</span></code></dt><dd><p>dev_name() of the privacy_screen provider.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Used for the static lookup-list for mapping privacy-screen consumer
dev-connector pairs to a privacy-screen provider.</p>
<dl class="function">
<dt id="c.drm_privacy_screen_lookup_add">
void <code class="sig-name descname">drm_privacy_screen_lookup_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_privacy_screen_lookup" title="drm_privacy_screen_lookup">drm_privacy_screen_lookup</a><em> *lookup</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_privacy_screen_lookup_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add an entry to the static privacy-screen lookup list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen_lookup</span> <span class="pre">*lookup</span></code></dt><dd><p>lookup list entry to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an entry to the static privacy-screen lookup list. Note the
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> which is part of the <a class="reference internal" href="#c.drm_privacy_screen_lookup" title="drm_privacy_screen_lookup"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen_lookup</span></code></a>
gets added to a list owned by the privacy-screen core. So the passed in
<a class="reference internal" href="#c.drm_privacy_screen_lookup" title="drm_privacy_screen_lookup"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen_lookup</span></code></a> must not be free-ed until it is removed
from the lookup list by calling <a class="reference internal" href="#c.drm_privacy_screen_lookup_remove" title="drm_privacy_screen_lookup_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_privacy_screen_lookup_remove()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.drm_privacy_screen_lookup_remove">
void <code class="sig-name descname">drm_privacy_screen_lookup_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_privacy_screen_lookup" title="drm_privacy_screen_lookup">drm_privacy_screen_lookup</a><em> *lookup</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_privacy_screen_lookup_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an entry to the static privacy-screen lookup list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen_lookup</span> <span class="pre">*lookup</span></code></dt><dd><p>lookup list entry to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove an entry previously added with <a class="reference internal" href="#c.drm_privacy_screen_lookup_add" title="drm_privacy_screen_lookup_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_privacy_screen_lookup_add()</span></code></a>
from the static privacy-screen lookup list.</p>
</div>
<dl class="function">
<dt id="c.drm_privacy_screen_get">
struct <a class="reference internal" href="#c.drm_privacy_screen" title="drm_privacy_screen">drm_privacy_screen</a> * <code class="sig-name descname">drm_privacy_screen_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_privacy_screen_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a privacy-screen provider</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>consumer-device for which to get a privacy-screen provider</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>(video)connector name for which to get a privacy-screen provider</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a privacy-screen provider for a privacy-screen attached to the
display described by the <strong>dev</strong> and <strong>con_id</strong> parameters.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>A pointer to a <a class="reference internal" href="#c.drm_privacy_screen" title="drm_privacy_screen"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen</span></code></a> on success.</p></li>
<li><p>ERR_PTR(-ENODEV) if no matching privacy-screen is found</p></li>
<li><dl class="simple">
<dt>ERR_PTR(-EPROBE_DEFER) if there is a matching privacy-screen,</dt><dd><p>but it has not been registered yet.</p>
</dd>
</dl>
</li>
</ul>
</div>
<dl class="function">
<dt id="c.drm_privacy_screen_put">
void <code class="sig-name descname">drm_privacy_screen_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_privacy_screen" title="drm_privacy_screen">drm_privacy_screen</a><em> *priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_privacy_screen_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a privacy-screen reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen</span> <span class="pre">*priv</span></code></dt><dd><p>privacy screen reference to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release a privacy-screen provider reference gotten through
<a class="reference internal" href="#c.drm_privacy_screen_get" title="drm_privacy_screen_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_privacy_screen_get()</span></code></a>. May be called with a NULL or ERR_PTR,
in which case it is a no-op.</p>
</div>
<dl class="function">
<dt id="c.drm_privacy_screen_set_sw_state">
int <code class="sig-name descname">drm_privacy_screen_set_sw_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_privacy_screen" title="drm_privacy_screen">drm_privacy_screen</a><em> *priv</em>, enum <a class="reference internal" href="drm-kms.html#c.drm_privacy_screen_status" title="drm_privacy_screen_status">drm_privacy_screen_status</a><em> sw_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_privacy_screen_set_sw_state" title="Permalink to this definition">¶</a></dt>
<dd><p>set a privacy-screen’s sw-state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen</span> <span class="pre">*priv</span></code></dt><dd><p>privacy screen to set the sw-state for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_privacy_screen_status</span> <span class="pre">sw_state</span></code></dt><dd><p>new sw-state value to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the sw-state of a privacy screen. If the privacy-screen is not
in a locked hw-state, then the actual and hw-state of the privacy-screen
will be immediately updated to the new value. If the privacy-screen is
in a locked hw-state, then the new sw-state will be remembered as the
requested state to put the privacy-screen in when it becomes unlocked.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_privacy_screen_get_state">
void <code class="sig-name descname">drm_privacy_screen_get_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_privacy_screen" title="drm_privacy_screen">drm_privacy_screen</a><em> *priv</em>, enum <a class="reference internal" href="drm-kms.html#c.drm_privacy_screen_status" title="drm_privacy_screen_status">drm_privacy_screen_status</a><em> *sw_state_ret</em>, enum <a class="reference internal" href="drm-kms.html#c.drm_privacy_screen_status" title="drm_privacy_screen_status">drm_privacy_screen_status</a><em> *hw_state_ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_privacy_screen_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get privacy-screen’s current state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen</span> <span class="pre">*priv</span></code></dt><dd><p>privacy screen to get the state for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_privacy_screen_status</span> <span class="pre">*sw_state_ret</span></code></dt><dd><p>address where to store the privacy-screens current sw-state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_privacy_screen_status</span> <span class="pre">*hw_state_ret</span></code></dt><dd><p>address where to store the privacy-screens current hw-state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the current state of a privacy-screen, both the sw-state and the
hw-state.</p>
</div>
<dl class="function">
<dt id="c.drm_privacy_screen_register_notifier">
int <code class="sig-name descname">drm_privacy_screen_register_notifier</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_privacy_screen" title="drm_privacy_screen">drm_privacy_screen</a><em> *priv</em>, struct notifier_block<em> *nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_privacy_screen_register_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>register a notifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen</span> <span class="pre">*priv</span></code></dt><dd><p>Privacy screen to register the notifier with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>Notifier-block for the notifier to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a notifier with the privacy-screen to be notified of changes made
to the privacy-screen state from outside of the privacy-screen class.
E.g. the state may be changed by the hardware itself in response to a
hotkey press.</p>
<p>The notifier is called with no locks held. The new hw_state and sw_state
can be retrieved using the <a class="reference internal" href="#c.drm_privacy_screen_get_state" title="drm_privacy_screen_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_privacy_screen_get_state()</span></code></a> function.
A pointer to the drm_privacy_screen’s struct is passed as the <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code>
argument of the notifier_block’s notifier_call.</p>
<p>The notifier will NOT be called when changes are made through
<a class="reference internal" href="#c.drm_privacy_screen_set_sw_state" title="drm_privacy_screen_set_sw_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_privacy_screen_set_sw_state()</span></code></a>. It is only called for external changes.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_privacy_screen_unregister_notifier">
int <code class="sig-name descname">drm_privacy_screen_unregister_notifier</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_privacy_screen" title="drm_privacy_screen">drm_privacy_screen</a><em> *priv</em>, struct notifier_block<em> *nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_privacy_screen_unregister_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a notifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen</span> <span class="pre">*priv</span></code></dt><dd><p>Privacy screen to register the notifier with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>Notifier-block for the notifier to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister a notifier registered with <a class="reference internal" href="#c.drm_privacy_screen_register_notifier" title="drm_privacy_screen_register_notifier"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_privacy_screen_register_notifier()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.drm_privacy_screen_register">
struct <a class="reference internal" href="#c.drm_privacy_screen" title="drm_privacy_screen">drm_privacy_screen</a> * <code class="sig-name descname">drm_privacy_screen_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *parent</em>, const struct <a class="reference internal" href="#c.drm_privacy_screen_ops" title="drm_privacy_screen_ops">drm_privacy_screen_ops</a><em> *ops</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_privacy_screen_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a privacy-screen</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent-device for the privacy-screen</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_privacy_screen_ops</span> <span class="pre">*ops</span></code></dt><dd><p><a class="reference internal" href="#c.drm_privacy_screen_ops" title="drm_privacy_screen_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen_ops</span></code></a> pointer with ops for the privacy-screen</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Private data owned by the privacy screen provider</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create and register a privacy-screen.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>A pointer to the created privacy-screen on success.</p></li>
<li><p>An ERR_PTR(errno) on failure.</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.drm_privacy_screen_unregister">
void <code class="sig-name descname">drm_privacy_screen_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_privacy_screen" title="drm_privacy_screen">drm_privacy_screen</a><em> *priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_privacy_screen_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister privacy-screen</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen</span> <span class="pre">*priv</span></code></dt><dd><p>privacy-screen to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister a privacy-screen registered with <a class="reference internal" href="#c.drm_privacy_screen_register" title="drm_privacy_screen_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_privacy_screen_register()</span></code></a>.
May be called with a NULL or ERR_PTR, in which case it is a no-op.</p>
</div>
<dl class="function">
<dt id="c.drm_privacy_screen_call_notifier_chain">
void <code class="sig-name descname">drm_privacy_screen_call_notifier_chain</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_privacy_screen" title="drm_privacy_screen">drm_privacy_screen</a><em> *priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_privacy_screen_call_notifier_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>notify consumers of state change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_privacy_screen</span> <span class="pre">*priv</span></code></dt><dd><p>Privacy screen to register the notifier with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A privacy-screen provider driver can call this functions upon external
changes to the privacy-screen state. E.g. the state may be changed by the
hardware itself in response to a hotkey press.
This function must be called without holding the privacy-screen lock.
the driver must update sw_state and hw_state to reflect the new state before
calling this function.
The expected behavior from the driver upon receiving an external state
change event is: 1. Take the lock; 2. Update sw_state and hw_state;
3. Release the lock. 4. Call <a class="reference internal" href="#c.drm_privacy_screen_call_notifier_chain" title="drm_privacy_screen_call_notifier_chain"><code class="xref c c-func docutils literal notranslate"><span class="pre">drm_privacy_screen_call_notifier_chain()</span></code></a>.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Mode Setting Helper Functions</a><ul>
<li><a class="reference internal" href="#modeset-helper-reference-for-common-vtables">Modeset Helper Reference for Common Vtables</a></li>
<li><a class="reference internal" href="#atomic-modeset-helper-functions-reference">Atomic Modeset Helper Functions Reference</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#implementing-asynchronous-atomic-commit">Implementing Asynchronous Atomic Commit</a></li>
<li><a class="reference internal" href="#helper-functions-reference">Helper Functions Reference</a></li>
<li><a class="reference internal" href="#atomic-state-reset-and-initialization">Atomic State Reset and Initialization</a></li>
<li><a class="reference internal" href="#atomic-state-helper-reference">Atomic State Helper Reference</a></li>
<li><a class="reference internal" href="#gem-atomic-helper-reference">GEM Atomic Helper Reference</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simple-kms-helper-reference">Simple KMS Helper Reference</a></li>
<li><a class="reference internal" href="#fbdev-helper-functions-reference">fbdev Helper Functions Reference</a></li>
<li><a class="reference internal" href="#format-helper-functions-reference">format Helper Functions Reference</a></li>
<li><a class="reference internal" href="#framebuffer-dma-helper-functions-reference">Framebuffer DMA Helper Functions Reference</a></li>
<li><a class="reference internal" href="#framebuffer-gem-helper-reference">Framebuffer GEM Helper Reference</a></li>
<li><a class="reference internal" href="#bridges">Bridges</a><ul>
<li><a class="reference internal" href="#id1">Overview</a></li>
<li><a class="reference internal" href="#display-driver-integration">Display Driver Integration</a></li>
<li><a class="reference internal" href="#special-care-with-mipi-dsi-bridges">Special Care with MIPI-DSI bridges</a></li>
<li><a class="reference internal" href="#bridge-operations">Bridge Operations</a></li>
<li><a class="reference internal" href="#bridge-connector-helper">Bridge Connector Helper</a></li>
<li><a class="reference internal" href="#bridge-helper-reference">Bridge Helper Reference</a></li>
<li><a class="reference internal" href="#bridge-connector-helper-reference">Bridge Connector Helper Reference</a></li>
<li><a class="reference internal" href="#panel-bridge-helper-reference">Panel-Bridge Helper Reference</a></li>
</ul>
</li>
<li><a class="reference internal" href="#panel-helper-reference">Panel Helper Reference</a></li>
<li><a class="reference internal" href="#panel-self-refresh-helper-reference">Panel Self Refresh Helper Reference</a></li>
<li><a class="reference internal" href="#hdcp-helper-functions-reference">HDCP Helper Functions Reference</a></li>
<li><a class="reference internal" href="#display-port-helper-functions-reference">Display Port Helper Functions Reference</a></li>
<li><a class="reference internal" href="#display-port-cec-helper-functions-reference">Display Port CEC Helper Functions Reference</a></li>
<li><a class="reference internal" href="#display-port-dual-mode-adaptor-helper-functions-reference">Display Port Dual Mode Adaptor Helper Functions Reference</a></li>
<li><a class="reference internal" href="#display-port-mst-helpers">Display Port MST Helpers</a><ul>
<li><a class="reference internal" href="#id2">Overview</a><ul>
<li><a class="reference internal" href="#topology-refcount-overview">Topology refcount overview</a></li>
<li><a class="reference internal" href="#malloc-refcount-overview">Malloc refcount overview</a></li>
<li><a class="reference internal" href="#refcount-relationships-in-a-topology">Refcount relationships in a topology</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functions-reference">Functions Reference</a></li>
<li><a class="reference internal" href="#topology-lifetime-internals">Topology Lifetime Internals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mipi-dbi-helper-functions-reference">MIPI DBI Helper Functions Reference</a></li>
<li><a class="reference internal" href="#mipi-dsi-helper-functions-reference">MIPI DSI Helper Functions Reference</a></li>
<li><a class="reference internal" href="#display-stream-compression-helper-functions-reference">Display Stream Compression Helper Functions Reference</a></li>
<li><a class="reference internal" href="#output-probing-helper-functions-reference">Output Probing Helper Functions Reference</a></li>
<li><a class="reference internal" href="#edid-helper-functions-reference">EDID Helper Functions Reference</a></li>
<li><a class="reference internal" href="#scdc-helper-functions-reference">SCDC Helper Functions Reference</a></li>
<li><a class="reference internal" href="#hdmi-infoframes-helper-reference">HDMI Infoframes Helper Reference</a></li>
<li><a class="reference internal" href="#rectangle-utilities-reference">Rectangle Utilities Reference</a></li>
<li><a class="reference internal" href="#flip-work-helper-reference">Flip-work Helper Reference</a></li>
<li><a class="reference internal" href="#auxiliary-modeset-helpers">Auxiliary Modeset Helpers</a></li>
<li><a class="reference internal" href="#of-dt-helpers">OF/DT Helpers</a></li>
<li><a class="reference internal" href="#legacy-plane-helper-reference">Legacy Plane Helper Reference</a></li>
<li><a class="reference internal" href="#legacy-crtc-modeset-helper-functions-reference">Legacy CRTC/Modeset Helper Functions Reference</a></li>
<li><a class="reference internal" href="#privacy-screen-class">Privacy-screen class</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/gpu/drm-kms-helpers.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/gpu/drm-kms-helpers.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>