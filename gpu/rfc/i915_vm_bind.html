
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>I915 VM_BIND feature design and use cases &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Compute Accelerators" href="../../accel/index.html" />
    <link rel="prev" title="I915 Small BAR RFC Section" href="i915_small_bar.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="i915-vm-bind-feature-design-and-use-cases">
<h1>I915 VM_BIND feature design and use cases<a class="headerlink" href="#i915-vm-bind-feature-design-and-use-cases" title="Permalink to this headline">¶</a></h1>
<section id="vm-bind-feature">
<h2>VM_BIND feature<a class="headerlink" href="#vm-bind-feature" title="Permalink to this headline">¶</a></h2>
<p>DRM_I915_GEM_VM_BIND/UNBIND ioctls allows UMD to bind/unbind GEM buffer
objects (BOs) or sections of a BOs at specified GPU virtual addresses on a
specified address space (VM). These mappings (also referred to as persistent
mappings) will be persistent across multiple GPU submissions (execbuf calls)
issued by the UMD, without user having to provide a list of all required
mappings during each submission (as required by older execbuf mode).</p>
<p>The VM_BIND/UNBIND calls allow UMDs to request a timeline out fence for
signaling the completion of bind/unbind operation.</p>
<p>VM_BIND feature is advertised to user via I915_PARAM_VM_BIND_VERSION.
User has to opt-in for VM_BIND mode of binding for an address space (VM)
during VM creation time via I915_VM_CREATE_FLAGS_USE_VM_BIND extension.</p>
<p>VM_BIND/UNBIND ioctl calls executed on different CPU threads concurrently are
not ordered. Furthermore, parts of the VM_BIND/UNBIND operations can be done
asynchronously, when valid out fence is specified.</p>
<p>VM_BIND features include:</p>
<ul class="simple">
<li><p>Multiple Virtual Address (VA) mappings can map to the same physical pages
of an object (aliasing).</p></li>
<li><p>VA mapping can map to a partial section of the BO (partial binding).</p></li>
<li><p>Support capture of persistent mappings in the dump upon GPU error.</p></li>
<li><p>Support for userptr gem objects (no special uapi is required for this).</p></li>
</ul>
<section id="tlb-flush-consideration">
<h3>TLB flush consideration<a class="headerlink" href="#tlb-flush-consideration" title="Permalink to this headline">¶</a></h3>
<p>The i915 driver flushes the TLB for each submission and when an object’s
pages are released. The VM_BIND/UNBIND operation will not do any additional
TLB flush. Any VM_BIND mapping added will be in the working set for subsequent
submissions on that VM and will not be in the working set for currently running
batches (which would require additional TLB flushes, which is not supported).</p>
</section>
<section id="execbuf-ioctl-in-vm-bind-mode">
<h3>Execbuf ioctl in VM_BIND mode<a class="headerlink" href="#execbuf-ioctl-in-vm-bind-mode" title="Permalink to this headline">¶</a></h3>
<p>A VM in VM_BIND mode will not support older execbuf mode of binding.
The execbuf ioctl handling in VM_BIND mode differs significantly from the
older execbuf2 ioctl (See <a class="reference internal" href="../driver-uapi.html#c.drm_i915_gem_execbuffer2" title="drm_i915_gem_execbuffer2"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_execbuffer2</span></code></a>).
Hence, a new execbuf3 ioctl has been added to support VM_BIND mode. (See
<a class="reference internal" href="#c.drm_i915_gem_execbuffer3" title="drm_i915_gem_execbuffer3"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_execbuffer3</span></code></a>). The execbuf3 ioctl will not accept any
execlist. Hence, no support for implicit sync. It is expected that the below
work will be able to support requirements of object dependency setting in all
use cases:</p>
<p>“dma-buf: Add an API for exporting sync files”
(<a class="reference external" href="https://lwn.net/Articles/859290/">https://lwn.net/Articles/859290/</a>)</p>
<p>The new execbuf3 ioctl only works in VM_BIND mode and the VM_BIND mode only
works with execbuf3 ioctl for submission. All BOs mapped on that VM (through
VM_BIND call) at the time of execbuf3 call are deemed required for that
submission.</p>
<p>The execbuf3 ioctl directly specifies the batch addresses instead of as
object handles as in execbuf2 ioctl. The execbuf3 ioctl will also not
support many of the older features like in/out/submit fences, fence array,
default gem context and many more (See <a class="reference internal" href="#c.drm_i915_gem_execbuffer3" title="drm_i915_gem_execbuffer3"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_execbuffer3</span></code></a>).</p>
<p>In VM_BIND mode, VA allocation is completely managed by the user instead of
the i915 driver. Hence all VA assignment, eviction are not applicable in
VM_BIND mode. Also, for determining object activeness, VM_BIND mode will not
be using the i915_vma active reference tracking. It will instead use dma-resv
object for that (See <a class="reference internal" href="#vm-bind-dma-resv-usage">VM_BIND dma_resv usage</a>).</p>
<p>So, a lot of existing code supporting execbuf2 ioctl, like relocations, VA
evictions, vma lookup table, implicit sync, vma active reference tracking etc.,
are not applicable for execbuf3 ioctl. Hence, all execbuf3 specific handling
should be in a separate file and only functionalities common to these ioctls
can be the shared code where possible.</p>
</section>
<section id="vm-private-objects">
<h3>VM_PRIVATE objects<a class="headerlink" href="#vm-private-objects" title="Permalink to this headline">¶</a></h3>
<p>By default, BOs can be mapped on multiple VMs and can also be dma-buf
exported. Hence these BOs are referred to as Shared BOs.
During each execbuf submission, the request fence must be added to the
dma-resv fence list of all shared BOs mapped on the VM.</p>
<p>VM_BIND feature introduces an optimization where user can create BO which
is private to a specified VM via I915_GEM_CREATE_EXT_VM_PRIVATE flag during
BO creation. Unlike Shared BOs, these VM private BOs can only be mapped on
the VM they are private to and can’t be dma-buf exported.
All private BOs of a VM share the dma-resv object. Hence during each execbuf
submission, they need only one dma-resv fence list updated. Thus, the fast
path (where required mappings are already bound) submission latency is O(1)
w.r.t the number of VM private BOs.</p>
</section>
<section id="vm-bind-locking-hirarchy">
<h3>VM_BIND locking hirarchy<a class="headerlink" href="#vm-bind-locking-hirarchy" title="Permalink to this headline">¶</a></h3>
<p>The locking design here supports the older (execlist based) execbuf mode, the
newer VM_BIND mode, the VM_BIND mode with GPU page faults and possible future
system allocator support (See <a class="reference internal" href="#shared-virtual-memory-svm-support">Shared Virtual Memory (SVM) support</a>).
The older execbuf mode and the newer VM_BIND mode without page faults manages
residency of backing storage using dma_fence. The VM_BIND mode with page faults
and the system allocator support do not use any dma_fence at all.</p>
<p>VM_BIND locking order is as below.</p>
<ol class="arabic">
<li><p>Lock-A: A vm_bind mutex will protect vm_bind lists. This lock is taken in
vm_bind/vm_unbind ioctl calls, in the execbuf path and while releasing the
mapping.</p>
<p>In future, when GPU page faults are supported, we can potentially use a
rwsem instead, so that multiple page fault handlers can take the read side
lock to lookup the mapping and hence can run in parallel.
The older execbuf mode of binding do not need this lock.</p>
</li>
<li><p>Lock-B: The object’s dma-resv lock will protect i915_vma state and needs to
be held while binding/unbinding a vma in the async worker and while updating
dma-resv fence list of an object. Note that private BOs of a VM will all
share a dma-resv object.</p>
<p>The future system allocator support will use the HMM prescribed locking
instead.</p>
</li>
<li><p>Lock-C: Spinlock/s to protect some of the VM’s lists like the list of
invalidated vmas (due to eviction and userptr invalidation) etc.</p></li>
</ol>
<p>When GPU page faults are supported, the execbuf path do not take any of these
locks. There we will simply smash the new batch buffer address into the ring and
then tell the scheduler run that. The lock taking only happens from the page
fault handler, where we take lock-A in read mode, whichever lock-B we need to
find the backing storage (dma_resv lock for gem objects, and hmm/core mm for
system allocator) and some additional locks (lock-D) for taking care of page
table races. Page fault mode should not need to ever manipulate the vm lists,
so won’t ever need lock-C.</p>
</section>
<section id="vm-bind-lru-handling">
<h3>VM_BIND LRU handling<a class="headerlink" href="#vm-bind-lru-handling" title="Permalink to this headline">¶</a></h3>
<p>We need to ensure VM_BIND mapped objects are properly LRU tagged to avoid
performance degradation. We will also need support for bulk LRU movement of
VM_BIND objects to avoid additional latencies in execbuf path.</p>
<p>The page table pages are similar to VM_BIND mapped objects (See
<a class="reference internal" href="#evictable-page-table-allocations">Evictable page table allocations</a>) and are maintained per VM and needs to
be pinned in memory when VM is made active (ie., upon an execbuf call with
that VM). So, bulk LRU movement of page table pages is also needed.</p>
</section>
<section id="vm-bind-dma-resv-usage">
<h3>VM_BIND dma_resv usage<a class="headerlink" href="#vm-bind-dma-resv-usage" title="Permalink to this headline">¶</a></h3>
<p>Fences needs to be added to all VM_BIND mapped objects. During each execbuf
submission, they are added with DMA_RESV_USAGE_BOOKKEEP usage to prevent
over sync (See <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_resv_usage" title="dma_resv_usage"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span></code></a>). One can override it with either
DMA_RESV_USAGE_READ or DMA_RESV_USAGE_WRITE usage during explicit object
dependency setting.</p>
<p>Note that DRM_I915_GEM_WAIT and DRM_I915_GEM_BUSY ioctls do not check for
DMA_RESV_USAGE_BOOKKEEP usage and hence should not be used for end of batch
check. Instead, the execbuf3 out fence should be used for end of batch check
(See <a class="reference internal" href="#c.drm_i915_gem_execbuffer3" title="drm_i915_gem_execbuffer3"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_execbuffer3</span></code></a>).</p>
<p>Also, in VM_BIND mode, use dma-resv apis for determining object activeness
(See <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_resv_test_signaled" title="dma_resv_test_signaled"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_test_signaled()</span></code></a> and <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_resv_wait_timeout" title="dma_resv_wait_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_wait_timeout()</span></code></a>) and do not use the
older i915_vma active reference tracking which is deprecated. This should be
easier to get it working with the current TTM backend.</p>
</section>
<section id="mesa-use-case">
<h3>Mesa use case<a class="headerlink" href="#mesa-use-case" title="Permalink to this headline">¶</a></h3>
<p>VM_BIND can potentially reduce the CPU overhead in Mesa (both Vulkan and Iris),
hence improving performance of CPU-bound applications. It also allows us to
implement Vulkan’s Sparse Resources. With increasing GPU hardware performance,
reducing CPU overhead becomes more impactful.</p>
</section>
</section>
<section id="other-vm-bind-use-cases">
<h2>Other VM_BIND use cases<a class="headerlink" href="#other-vm-bind-use-cases" title="Permalink to this headline">¶</a></h2>
<section id="long-running-compute-contexts">
<h3>Long running Compute contexts<a class="headerlink" href="#long-running-compute-contexts" title="Permalink to this headline">¶</a></h3>
<p>Usage of dma-fence expects that they complete in reasonable amount of time.
Compute on the other hand can be long running. Hence it is appropriate for
compute to use user/memory fence (See <a class="reference internal" href="#user-memory-fence">User/Memory Fence</a>) and dma-fence usage
must be limited to in-kernel consumption only.</p>
<p>Where GPU page faults are not available, kernel driver upon buffer invalidation
will initiate a suspend (preemption) of long running context, finish the
invalidation, revalidate the BO and then resume the compute context. This is
done by having a per-context preempt fence which is enabled when someone tries
to wait on it and triggers the context preemption.</p>
<section id="user-memory-fence">
<h4>User/Memory Fence<a class="headerlink" href="#user-memory-fence" title="Permalink to this headline">¶</a></h4>
<p>User/Memory fence is a &lt;address, value&gt; pair. To signal the user fence, the
specified value will be written at the specified virtual address and wakeup the
waiting process. User fence can be signaled either by the GPU or kernel async
worker (like upon bind completion). User can wait on a user fence with a new
user fence wait ioctl.</p>
<p>Here is some prior work on this:
<a class="reference external" href="https://patchwork.freedesktop.org/patch/349417/">https://patchwork.freedesktop.org/patch/349417/</a></p>
</section>
<section id="low-latency-submission">
<h4>Low Latency Submission<a class="headerlink" href="#low-latency-submission" title="Permalink to this headline">¶</a></h4>
<p>Allows compute UMD to directly submit GPU jobs instead of through execbuf
ioctl. This is made possible by VM_BIND is not being synchronized against
execbuf. VM_BIND allows bind/unbind of mappings required for the directly
submitted jobs.</p>
</section>
</section>
<section id="debugger">
<h3>Debugger<a class="headerlink" href="#debugger" title="Permalink to this headline">¶</a></h3>
<p>With debug event interface user space process (debugger) is able to keep track
of and act upon resources created by another process (debugged) and attached
to GPU via vm_bind interface.</p>
</section>
<section id="gpu-page-faults">
<h3>GPU page faults<a class="headerlink" href="#gpu-page-faults" title="Permalink to this headline">¶</a></h3>
<p>GPU page faults when supported (in future), will only be supported in the
VM_BIND mode. While both the older execbuf mode and the newer VM_BIND mode of
binding will require using dma-fence to ensure residency, the GPU page faults
mode when supported, will not use any dma-fence as residency is purely managed
by installing and removing/invalidating page table entries.</p>
</section>
<section id="page-level-hints-settings">
<h3>Page level hints settings<a class="headerlink" href="#page-level-hints-settings" title="Permalink to this headline">¶</a></h3>
<p>VM_BIND allows any hints setting per mapping instead of per BO. Possible hints
include placement and atomicity. Sub-BO level placement hint will be even more
relevant with upcoming GPU on-demand page fault support.</p>
</section>
<section id="page-level-cache-clos-settings">
<h3>Page level Cache/CLOS settings<a class="headerlink" href="#page-level-cache-clos-settings" title="Permalink to this headline">¶</a></h3>
<p>VM_BIND allows cache/CLOS settings per mapping instead of per BO.</p>
</section>
<section id="evictable-page-table-allocations">
<h3>Evictable page table allocations<a class="headerlink" href="#evictable-page-table-allocations" title="Permalink to this headline">¶</a></h3>
<p>Make pagetable allocations evictable and manage them similar to VM_BIND
mapped objects. Page table pages are similar to persistent mappings of a
VM (difference here are that the page table pages will not have an i915_vma
structure and after swapping pages back in, parent page link needs to be
updated).</p>
</section>
<section id="shared-virtual-memory-svm-support">
<h3>Shared Virtual Memory (SVM) support<a class="headerlink" href="#shared-virtual-memory-svm-support" title="Permalink to this headline">¶</a></h3>
<p>VM_BIND interface can be used to map system memory directly (without gem BO
abstraction) using the HMM interface. SVM is only supported with GPU page
faults enabled.</p>
</section>
</section>
<section id="vm-bind-uapi">
<h2>VM_BIND UAPI<a class="headerlink" href="#vm-bind-uapi" title="Permalink to this headline">¶</a></h2>
<p id="i915-param-vm-bind-version"><strong>I915_PARAM_VM_BIND_VERSION</strong></p>
<p>VM_BIND feature version supported.
See <a class="reference internal" href="../driver-uapi.html#c.drm_i915_getparam_t" title="drm_i915_getparam_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">drm_i915_getparam_t</span></code></a> param.</p>
<p>Specifies the VM_BIND feature version supported.
The following versions of VM_BIND have been defined:</p>
<p>0: No VM_BIND support.</p>
<dl class="simple">
<dt>1: In VM_UNBIND calls, the UMD must specify the exact mappings created</dt><dd><p>previously with VM_BIND, the ioctl will not support unbinding multiple
mappings or splitting them. Similarly, VM_BIND calls will not replace
any existing mappings.</p>
</dd>
<dt>2: The restrictions on unbinding partial or multiple mappings is</dt><dd><p>lifted, Similarly, binding will replace any mappings in the given range.</p>
</dd>
</dl>
<p>See <a class="reference internal" href="#c.drm_i915_gem_vm_bind" title="drm_i915_gem_vm_bind"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_vm_bind</span></code></a> and <a class="reference internal" href="#c.drm_i915_gem_vm_unbind" title="drm_i915_gem_vm_unbind"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_vm_unbind</span></code></a>.</p>
<p id="i915-vm-create-flags-use-vm-bind"><strong>I915_VM_CREATE_FLAGS_USE_VM_BIND</strong></p>
<p>Flag to opt-in for VM_BIND mode of binding during VM creation.
See <a class="reference internal" href="../driver-uapi.html#c.drm_i915_gem_vm_control" title="drm_i915_gem_vm_control"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_vm_control</span></code></a> flags.</p>
<p>The older execbuf2 ioctl will not support VM_BIND mode of operation.
For VM_BIND mode, we have new execbuf3 ioctl which will not accept any
execlist (See <a class="reference internal" href="#c.drm_i915_gem_execbuffer3" title="drm_i915_gem_execbuffer3"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_execbuffer3</span></code></a> for more details).</p>
<dl class="type">
<dt id="c.drm_i915_gem_timeline_fence">
struct <code class="sig-name descname">drm_i915_gem_timeline_fence</code><a class="headerlink" href="#c.drm_i915_gem_timeline_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>An input or output timeline fence.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_timeline_fence {
    __u32 handle;
    __u32 flags;
#define I915_TIMELINE_FENCE_WAIT            (1 &lt;&lt; 0);
#define I915_TIMELINE_FENCE_SIGNAL          (1 &lt;&lt; 1);
#define __I915_TIMELINE_FENCE_UNKNOWN_FLAGS (-(I915_TIMELINE_FENCE_SIGNAL &lt;&lt; 1));
    __u64 value;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>User’s handle for a drm_syncobj to wait on or signal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Supported flags are:</p>
<p>I915_TIMELINE_FENCE_WAIT:
Wait for the input fence before the operation.</p>
<p>I915_TIMELINE_FENCE_SIGNAL:
Return operation completion fence as output.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>A point in the timeline.
Value must be 0 for a binary drm_syncobj. A Value of 0 for a
timeline drm_syncobj is invalid as it turns a drm_syncobj into a
binary one.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The operation will wait for input fence to signal.</p>
<p>The returned output fence will be signaled after the completion of the
operation.</p>
<dl class="type">
<dt id="c.drm_i915_gem_vm_bind">
struct <code class="sig-name descname">drm_i915_gem_vm_bind</code><a class="headerlink" href="#c.drm_i915_gem_vm_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>VA to object mapping to bind.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_vm_bind {
    __u32 vm_id;
    __u32 handle;
    __u64 start;
    __u64 offset;
    __u64 length;
    __u64 flags;
#define I915_GEM_VM_BIND_CAPTURE        (1 &lt;&lt; 0);
    struct drm_i915_gem_timeline_fence fence;
    __u64 extensions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>VM (address space) id to bind</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Object handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>Virtual Address start to bind</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>Offset in object to bind</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Length of mapping to bind</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Supported flags are:</p>
<p>I915_GEM_VM_BIND_CAPTURE:
Capture this mapping in the dump upon GPU error.</p>
<p>Note that <strong>fence</strong> carries its own flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>Timeline fence for bind completion signaling.</p>
<p>Timeline fence is of format <a class="reference internal" href="#c.drm_i915_gem_timeline_fence" title="drm_i915_gem_timeline_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_timeline_fence</span></code></a>.</p>
<p>It is an out fence, hence using I915_TIMELINE_FENCE_WAIT flag
is invalid, and an error will be returned.</p>
<p>If I915_TIMELINE_FENCE_SIGNAL flag is not set, then out fence
is not requested and binding is completed synchronously.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Zero-terminated chain of extensions.</p>
<p>For future extensions. See <a class="reference internal" href="../driver-uapi.html#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is passed to VM_BIND ioctl and specifies the mapping of GPU
virtual address (VA) range to the section of an object that should be bound
in the device page table of the specified address space (VM).
The VA range specified must be unique (ie., not currently bound) and can
be mapped to whole object or a section of the object (partial binding).
Multiple VA mappings can be created to the same section of the object
(aliasing).</p>
<p>The <strong>start</strong>, <strong>offset</strong> and <strong>length</strong> must be 4K page aligned. However the DG2
and XEHPSDV has 64K page size for device local memory and has compact page
table. On those platforms, for binding device local-memory objects, the
<strong>start</strong>, <strong>offset</strong> and <strong>length</strong> must be 64K aligned. Also, UMDs should not mix
the local memory 64K page and the system memory 4K page bindings in the same
2M range.</p>
<p>Error code -EINVAL will be returned if <strong>start</strong>, <strong>offset</strong> and <strong>length</strong> are not
properly aligned. In version 1 (See I915_PARAM_VM_BIND_VERSION), error code
-ENOSPC will be returned if the VA range specified can’t be reserved.</p>
<p>VM_BIND/UNBIND ioctl calls executed on different CPU threads concurrently
are not ordered. Furthermore, parts of the VM_BIND operation can be done
asynchronously, if valid <strong>fence</strong> is specified.</p>
<dl class="type">
<dt id="c.drm_i915_gem_vm_unbind">
struct <code class="sig-name descname">drm_i915_gem_vm_unbind</code><a class="headerlink" href="#c.drm_i915_gem_vm_unbind" title="Permalink to this definition">¶</a></dt>
<dd><p>VA to object mapping to unbind.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_vm_unbind {
    __u32 vm_id;
    __u32 rsvd;
    __u64 start;
    __u64 length;
    __u64 flags;
    struct drm_i915_gem_timeline_fence fence;
    __u64 extensions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>VM (address space) id to bind</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd</span></code></dt><dd><p>Reserved, MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>Virtual Address start to unbind</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Length of mapping to unbind</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Currently reserved, MBZ.</p>
<p>Note that <strong>fence</strong> carries its own flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>Timeline fence for unbind completion signaling.</p>
<p>Timeline fence is of format <a class="reference internal" href="#c.drm_i915_gem_timeline_fence" title="drm_i915_gem_timeline_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_timeline_fence</span></code></a>.</p>
<p>It is an out fence, hence using I915_TIMELINE_FENCE_WAIT flag
is invalid, and an error will be returned.</p>
<p>If I915_TIMELINE_FENCE_SIGNAL flag is not set, then out fence
is not requested and unbinding is completed synchronously.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Zero-terminated chain of extensions.</p>
<p>For future extensions. See <a class="reference internal" href="../driver-uapi.html#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is passed to VM_UNBIND ioctl and specifies the GPU virtual
address (VA) range that should be unbound from the device page table of the
specified address space (VM). VM_UNBIND will force unbind the specified
range from device page table without waiting for any GPU job to complete.
It is UMDs responsibility to ensure the mapping is no longer in use before
calling VM_UNBIND.</p>
<p>If the specified mapping is not found, the ioctl will simply return without
any error.</p>
<p>VM_BIND/UNBIND ioctl calls executed on different CPU threads concurrently
are not ordered. Furthermore, parts of the VM_UNBIND operation can be done
asynchronously, if valid <strong>fence</strong> is specified.</p>
<dl class="type">
<dt id="c.drm_i915_gem_execbuffer3">
struct <code class="sig-name descname">drm_i915_gem_execbuffer3</code><a class="headerlink" href="#c.drm_i915_gem_execbuffer3" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure for DRM_I915_GEM_EXECBUFFER3 ioctl.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_execbuffer3 {
    __u32 ctx_id;
    __u32 engine_idx;
    __u64 batch_address;
    __u64 flags;
    __u32 rsvd1;
    __u32 fence_count;
    __u64 timeline_fences;
    __u64 rsvd2;
    __u64 extensions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ctx_id</span></code></dt><dd><p>Context id</p>
<p>Only contexts with user engine map are allowed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engine_idx</span></code></dt><dd><p>Engine index</p>
<p>An index in the user engine map of the context specified by <strong>ctx_id</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">batch_address</span></code></dt><dd><p>Batch gpu virtual address/es.</p>
<p>For normal submission, it is the gpu virtual address of the batch
buffer. For parallel submission, it is a pointer to an array of
batch buffer gpu virtual addresses with array size equal to the
number of (parallel) engines involved in that submission (See
<a class="reference internal" href="../driver-uapi.html#c.i915_context_engines_parallel_submit" title="i915_context_engines_parallel_submit"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_context_engines_parallel_submit</span></code></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Currently reserved, MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd1</span></code></dt><dd><p>Reserved, MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_count</span></code></dt><dd><p>Number of fences in <strong>timeline_fences</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeline_fences</span></code></dt><dd><p>Pointer to an array of timeline fences.</p>
<p>Timeline fences are of format <a class="reference internal" href="#c.drm_i915_gem_timeline_fence" title="drm_i915_gem_timeline_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_timeline_fence</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd2</span></code></dt><dd><p>Reserved, MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Zero-terminated chain of extensions.</p>
<p>For future extensions. See <a class="reference internal" href="../driver-uapi.html#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>DRM_I915_GEM_EXECBUFFER3 ioctl only works in VM_BIND mode and VM_BIND mode
only works with this ioctl for submission.
See I915_VM_CREATE_FLAGS_USE_VM_BIND.</p>
<dl class="type">
<dt id="c.drm_i915_gem_create_ext_vm_private">
struct <code class="sig-name descname">drm_i915_gem_create_ext_vm_private</code><a class="headerlink" href="#c.drm_i915_gem_create_ext_vm_private" title="Permalink to this definition">¶</a></dt>
<dd><p>Extension to make the object private to the specified VM.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_create_ext_vm_private {
#define I915_GEM_CREATE_EXT_VM_PRIVATE          2;
    struct i915_user_extension base;
    __u32 vm_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Extension link. See <a class="reference internal" href="../driver-uapi.html#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>Id of the VM to which the object is private</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>See <a class="reference internal" href="../driver-uapi.html#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_create_ext</span></code></a>.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">I915 VM_BIND feature design and use cases</a><ul>
<li><a class="reference internal" href="#vm-bind-feature">VM_BIND feature</a><ul>
<li><a class="reference internal" href="#tlb-flush-consideration">TLB flush consideration</a></li>
<li><a class="reference internal" href="#execbuf-ioctl-in-vm-bind-mode">Execbuf ioctl in VM_BIND mode</a></li>
<li><a class="reference internal" href="#vm-private-objects">VM_PRIVATE objects</a></li>
<li><a class="reference internal" href="#vm-bind-locking-hirarchy">VM_BIND locking hirarchy</a></li>
<li><a class="reference internal" href="#vm-bind-lru-handling">VM_BIND LRU handling</a></li>
<li><a class="reference internal" href="#vm-bind-dma-resv-usage">VM_BIND dma_resv usage</a></li>
<li><a class="reference internal" href="#mesa-use-case">Mesa use case</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-vm-bind-use-cases">Other VM_BIND use cases</a><ul>
<li><a class="reference internal" href="#long-running-compute-contexts">Long running Compute contexts</a><ul>
<li><a class="reference internal" href="#user-memory-fence">User/Memory Fence</a></li>
<li><a class="reference internal" href="#low-latency-submission">Low Latency Submission</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debugger">Debugger</a></li>
<li><a class="reference internal" href="#gpu-page-faults">GPU page faults</a></li>
<li><a class="reference internal" href="#page-level-hints-settings">Page level hints settings</a></li>
<li><a class="reference internal" href="#page-level-cache-clos-settings">Page level Cache/CLOS settings</a></li>
<li><a class="reference internal" href="#evictable-page-table-allocations">Evictable page table allocations</a></li>
<li><a class="reference internal" href="#shared-virtual-memory-svm-support">Shared Virtual Memory (SVM) support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vm-bind-uapi">VM_BIND UAPI</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/gpu/rfc/i915_vm_bind.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/gpu/rfc/i915_vm_bind.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>