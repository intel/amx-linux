
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>DRM Driver uAPI &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Kernel clients" href="drm-client.html" />
    <link rel="prev" title="DRM client usage stats" href="drm-usage-stats.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="drm-driver-uapi">
<h1>DRM Driver uAPI<a class="headerlink" href="#drm-driver-uapi" title="Permalink to this headline">¶</a></h1>
<section id="drm-i915-uapi">
<h2>drm/i915 uAPI<a class="headerlink" href="#drm-i915-uapi" title="Permalink to this headline">¶</a></h2>
<p id="uevents-generated-by-i915-on-it-s-device-node"><strong>uevents generated by i915 on it’s device node</strong></p>
<dl class="simple">
<dt>I915_L3_PARITY_UEVENT - Generated when the driver receives a parity mismatch</dt><dd><p>event from the gpu l3 cache. Additional information supplied is ROW,
BANK, SUBBANK, SLICE of the affected cacheline. Userspace should keep
track of these events and if a specific cache-line seems to have a
persistent error remap it with the l3 remapping tool supplied in
intel-gpu-tools.  The value supplied with the event is always 1.</p>
</dd>
<dt>I915_ERROR_UEVENT - Generated upon error detection, currently only via</dt><dd><p>hangcheck. The error detection event is a good indicator of when things
began to go badly. The value supplied with the event is a 1 upon error
detection, and a 0 upon reset completion, signifying no more error
exists. NOTE: Disabling hangcheck or reset via module parameter will
cause the related events to not be seen.</p>
</dd>
<dt>I915_RESET_UEVENT - Event is generated just before an attempt to reset the</dt><dd><p>GPU. The value supplied with the event is always 1. NOTE: Disable
reset via module parameter will cause this event to not be seen.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.i915_user_extension">
struct <code class="sig-name descname">i915_user_extension</code><a class="headerlink" href="#c.i915_user_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for defining a chain of extensions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_user_extension {
    __u64 next_extension;
    __u32 name;
    __u32 flags;
    __u32 rsvd[4];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">next_extension</span></code></dt><dd><p>Pointer to the next <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>, or zero if the end.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the extension.</p>
<p>Note that the name here is just some integer.</p>
<p>Also note that the name space for this is not global for the whole
driver, but rather its scope/meaning is limited to the specific piece
of uAPI which has embedded the <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>MBZ</p>
<p>All undefined bits must be zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd</span></code></dt><dd><p>MBZ</p>
<p>Reserved for future use; must be zero.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Many interfaces need to grow over time. In most cases we can simply
extend the struct and have userspace pass in more data. Another option,
as demonstrated by Vulkan’s approach to providing extensions for forward
and backward compatibility, is to use a list of optional structs to
provide those extra details.</p>
<p>The key advantage to using an extension chain is that it allows us to
redefine the interface more easily than an ever growing struct of
increasing complexity, and for large parts of that interface to be
entirely optional. The downside is more pointer chasing; chasing across
the __user boundary with pointers encapsulated inside u64.</p>
<p>Example chaining:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">i915_user_extension</span><span class="w"> </span><span class="n">ext3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">next_extension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// end</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">i915_user_extension</span><span class="w"> </span><span class="n">ext2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">next_extension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ext3</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">i915_user_extension</span><span class="w"> </span><span class="n">ext1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">next_extension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ext2</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Typically the <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a> would be embedded in some uAPI
struct, and in this case we would feed it the head of the chain(i.e ext1),
which would then apply all of the above extensions.</p>
<dl class="type">
<dt id="c.drm_i915_gem_engine_class">
enum <code class="sig-name descname">drm_i915_gem_engine_class</code><a class="headerlink" href="#c.drm_i915_gem_engine_class" title="Permalink to this definition">¶</a></dt>
<dd><p>uapi engine type enumeration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_RENDER</span></code></dt><dd><p>Render engines support instructions used for 3D, Compute (GPGPU),
and programmable media workloads.  These instructions fetch data and
dispatch individual work items to threads that operate in parallel.
The threads run small programs (called “kernels” or “shaders”) on
the GPU’s execution units (EUs).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_COPY</span></code></dt><dd><p>Copy engines (also referred to as “blitters”) support instructions
that move blocks of data from one location in memory to another,
or that fill a specified location of memory with fixed data.
Copy engines can perform pre-defined logical or bitwise operations
on the source, destination, or pattern data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_VIDEO</span></code></dt><dd><p>Video engines (also referred to as “bit stream decode” (BSD) or
“vdbox”) support instructions that perform fixed-function media
decode and encode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_VIDEO_ENHANCE</span></code></dt><dd><p>Video enhancement engines (also referred to as “vebox”) support
instructions related to image enhancement.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_COMPUTE</span></code></dt><dd><p>Compute engines support a subset of the instructions available
on render engines:  compute engines support Compute (GPGPU) and
programmable media workloads, but do not support the 3D pipeline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_ENGINE_CLASS_INVALID</span></code></dt><dd><p>Placeholder value to represent an invalid engine class assignment.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Different engines serve different roles, and there may be more than one
engine serving each role.  This enum provides a classification of the role
of the engine, which may be used when requesting operations to be performed
on a certain subset of engines, or for providing information about that
group.</p>
<dl class="type">
<dt id="c.i915_engine_class_instance">
struct <code class="sig-name descname">i915_engine_class_instance</code><a class="headerlink" href="#c.i915_engine_class_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Engine class/instance identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_engine_class_instance {
    __u16 engine_class;
#define I915_ENGINE_CLASS_INVALID_NONE -1;
#define I915_ENGINE_CLASS_INVALID_VIRTUAL -2;
    __u16 engine_instance;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">engine_class</span></code></dt><dd><p>Engine class from <a class="reference internal" href="#c.drm_i915_gem_engine_class" title="drm_i915_gem_engine_class"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_i915_gem_engine_class</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engine_instance</span></code></dt><dd><p>Engine instance.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>There may be more than one engine fulfilling any role within the system.
Each engine of a class is given a unique instance number and therefore
any engine can be specified by its class:instance tuplet. APIs that allow
access to any engine in the system will use <a class="reference internal" href="#c.i915_engine_class_instance" title="i915_engine_class_instance"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_engine_class_instance</span></code></a>
for this identification.</p>
<p id="perf-events-exposed-by-i915-through-sys-bus-event-sources-drivers-i915"><strong>perf_events exposed by i915 through /sys/bus/event_sources/drivers/i915</strong></p>
<dl class="type">
<dt id="c.drm_i915_getparam">
struct <code class="sig-name descname">drm_i915_getparam</code><a class="headerlink" href="#c.drm_i915_getparam" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver parameter query structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_getparam {
    __s32 param;
    int __user *value;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">param</span></code></dt><dd><p>Driver parameter to query.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>Address of memory where queried value should be put.</p>
<p>WARNING: Using pointers instead of fixed-size u64 means we need to write
compat32 code. Don’t repeat this mistake.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_i915_getparam_t">
typedef <code class="sig-name descname">drm_i915_getparam_t</code><a class="headerlink" href="#c.drm_i915_getparam_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver parameter query structure. See <a class="reference internal" href="#c.drm_i915_getparam" title="drm_i915_getparam"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_getparam</span></code></a>.</p>
</dd></dl>

<dl class="type">
<dt id="c.drm_i915_gem_mmap_offset">
struct <code class="sig-name descname">drm_i915_gem_mmap_offset</code><a class="headerlink" href="#c.drm_i915_gem_mmap_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve an offset so we can mmap this buffer object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_mmap_offset {
    __u32 handle;
    __u32 pad;
    __u64 offset;
    __u64 flags;
#define I915_MMAP_OFFSET_GTT    0;
#define I915_MMAP_OFFSET_WC     1;
#define I915_MMAP_OFFSET_WB     2;
#define I915_MMAP_OFFSET_UC     3;
#define I915_MMAP_OFFSET_FIXED  4;
    __u64 extensions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle for the object being mapped.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>Must be zero</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>The fake offset to use for subsequent mmap call</p>
<p>This is a fixed-size type for 32/64 compatibility.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Flags for extended behaviour.</p>
<p>It is mandatory that one of the <cite>MMAP_OFFSET</cite> types
should be included:</p>
<ul class="simple">
<li><p><cite>I915_MMAP_OFFSET_GTT</cite>: Use mmap with the object bound to GTT. (Write-Combined)</p></li>
<li><p><cite>I915_MMAP_OFFSET_WC</cite>: Use Write-Combined caching.</p></li>
<li><p><cite>I915_MMAP_OFFSET_WB</cite>: Use Write-Back caching.</p></li>
<li><p><cite>I915_MMAP_OFFSET_FIXED</cite>: Use object placement to determine caching.</p></li>
</ul>
<p>On devices with local memory <cite>I915_MMAP_OFFSET_FIXED</cite> is the only valid
type. On devices without local memory, this caching mode is invalid.</p>
<p>As caching mode when specifying <cite>I915_MMAP_OFFSET_FIXED</cite>, WC or WB will
be used, depending on the object placement on creation. WB will be used
when the object can only exist in system memory, WC otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Zero-terminated chain of extensions.</p>
<p>No current extensions defined; mbz.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct is passed as argument to the <cite>DRM_IOCTL_I915_GEM_MMAP_OFFSET</cite> ioctl,
and is used to retrieve the fake offset to mmap an object specified by <code class="xref c c-type docutils literal notranslate"><span class="pre">handle</span></code>.</p>
<p>The legacy way of using <cite>DRM_IOCTL_I915_GEM_MMAP</cite> is removed on gen12+.
<cite>DRM_IOCTL_I915_GEM_MMAP_GTT</cite> is an older supported alias to this struct, but will behave
as setting the <code class="xref c c-type docutils literal notranslate"><span class="pre">extensions</span></code> to 0, and <code class="xref c c-type docutils literal notranslate"><span class="pre">flags</span></code> to <cite>I915_MMAP_OFFSET_GTT</cite>.</p>
<dl class="type">
<dt id="c.drm_i915_gem_set_domain">
struct <code class="sig-name descname">drm_i915_gem_set_domain</code><a class="headerlink" href="#c.drm_i915_gem_set_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust the objects write or read domain, in preparation for accessing the pages via some CPU domain.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_set_domain {
    __u32 handle;
    __u32 read_domains;
    __u32 write_domain;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle for the object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_domains</span></code></dt><dd><p>New read domains.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_domain</span></code></dt><dd><p>New write domain.</p>
<p>Note that having something in the write domain implies it’s in the
read domain, and only that read domain.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Specifying a new write or read domain will flush the object out of the
previous domain(if required), before then updating the objects domain
tracking with the new domain.</p>
<p>Note this might involve waiting for the object first if it is still active on
the GPU.</p>
<p>Supported values for <strong>read_domains</strong> and <strong>write_domain</strong>:</p>
<blockquote>
<div><ul class="simple">
<li><p>I915_GEM_DOMAIN_WC: Uncached write-combined domain</p></li>
<li><p>I915_GEM_DOMAIN_CPU: CPU cache domain</p></li>
<li><p>I915_GEM_DOMAIN_GTT: Mappable aperture domain</p></li>
</ul>
</div></blockquote>
<p>All other domains are rejected.</p>
<p>Note that for discrete, starting from DG1, this is no longer supported, and
is instead rejected. On such platforms the CPU domain is effectively static,
where we also only support a single <a class="reference internal" href="#c.drm_i915_gem_mmap_offset" title="drm_i915_gem_mmap_offset"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_mmap_offset</span></code></a> cache mode,
which can’t be set explicitly and instead depends on the object placements,
as per the below.</p>
<p>Implicit caching rules, starting from DG1:</p>
<blockquote>
<div><ul class="simple">
<li><p>If any of the object placements (see <a class="reference internal" href="#c.drm_i915_gem_create_ext_memory_regions" title="drm_i915_gem_create_ext_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext_memory_regions</span></code></a>)
contain I915_MEMORY_CLASS_DEVICE then the object will be allocated and
mapped as write-combined only.</p></li>
<li><p>Everything else is always allocated and mapped as write-back, with the
guarantee that everything is also coherent with the GPU.</p></li>
</ul>
</div></blockquote>
<p>Note that this is likely to change in the future again, where we might need
more flexibility on future devices, so making this all explicit as part of a
new <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext</span></code></a> extension is probable.</p>
<dl class="type">
<dt id="c.drm_i915_gem_exec_fence">
struct <code class="sig-name descname">drm_i915_gem_exec_fence</code><a class="headerlink" href="#c.drm_i915_gem_exec_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>An input or output fence for the execbuf ioctl.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_exec_fence {
    __u32 handle;
    __u32 flags;
#define I915_EXEC_FENCE_WAIT            (1&lt;&lt;0);
#define I915_EXEC_FENCE_SIGNAL          (1&lt;&lt;1);
#define __I915_EXEC_FENCE_UNKNOWN_FLAGS (-(I915_EXEC_FENCE_SIGNAL &lt;&lt; 1));
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>User’s handle for a drm_syncobj to wait on or signal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Supported flags are:</p>
<p>I915_EXEC_FENCE_WAIT:
Wait for the input fence before request submission.</p>
<p>I915_EXEC_FENCE_SIGNAL:
Return request completion fence as output</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The request will wait for input fence to signal before submission.</p>
<p>The returned output fence will be signaled after the completion of the
request.</p>
<dl class="type">
<dt id="c.drm_i915_gem_execbuffer_ext_timeline_fences">
struct <code class="sig-name descname">drm_i915_gem_execbuffer_ext_timeline_fences</code><a class="headerlink" href="#c.drm_i915_gem_execbuffer_ext_timeline_fences" title="Permalink to this definition">¶</a></dt>
<dd><p>Timeline fences for execbuf ioctl.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_execbuffer_ext_timeline_fences {
#define DRM_I915_GEM_EXECBUFFER_EXT_TIMELINE_FENCES 0;
    struct i915_user_extension base;
    __u64 fence_count;
    __u64 handles_ptr;
    __u64 values_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Extension link. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_count</span></code></dt><dd><p>Number of elements in the <strong>handles_ptr</strong> &amp; <strong>value_ptr</strong>
arrays.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handles_ptr</span></code></dt><dd><p>Pointer to an array of <a class="reference internal" href="#c.drm_i915_gem_exec_fence" title="drm_i915_gem_exec_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_exec_fence</span></code></a>
of length <strong>fence_count</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">values_ptr</span></code></dt><dd><p>Pointer to an array of u64 values of length
<strong>fence_count</strong>.
Values must be 0 for a binary drm_syncobj. A Value of 0 for a
timeline drm_syncobj is invalid as it turns a drm_syncobj into a
binary one.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure describes an array of drm_syncobj and associated points for
timeline variants of drm_syncobj. It is invalid to append this structure to
the execbuf if I915_EXEC_FENCE_ARRAY is set.</p>
<dl class="type">
<dt id="c.drm_i915_gem_execbuffer2">
struct <code class="sig-name descname">drm_i915_gem_execbuffer2</code><a class="headerlink" href="#c.drm_i915_gem_execbuffer2" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure for DRM_I915_GEM_EXECBUFFER2 ioctl.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_execbuffer2 {
    __u64 buffers_ptr;
    __u32 buffer_count;
    __u32 batch_start_offset;
    __u32 batch_len;
    __u32 DR1;
    __u32 DR4;
    __u32 num_cliprects;
    __u64 cliprects_ptr;
    __u64 flags;
#define I915_EXEC_RING_MASK              (0x3f);
#define I915_EXEC_DEFAULT                (0&lt;&lt;0);
#define I915_EXEC_RENDER                 (1&lt;&lt;0);
#define I915_EXEC_BSD                    (2&lt;&lt;0);
#define I915_EXEC_BLT                    (3&lt;&lt;0);
#define I915_EXEC_VEBOX                  (4&lt;&lt;0);
#define I915_EXEC_CONSTANTS_MASK        (3&lt;&lt;6);
#define I915_EXEC_CONSTANTS_REL_GENERAL (0&lt;&lt;6) ;
#define I915_EXEC_CONSTANTS_ABSOLUTE    (1&lt;&lt;6);
#define I915_EXEC_CONSTANTS_REL_SURFACE (2&lt;&lt;6) ;
#define I915_EXEC_GEN7_SOL_RESET        (1&lt;&lt;8);
#define I915_EXEC_SECURE                (1&lt;&lt;9);
#define I915_EXEC_IS_PINNED             (1&lt;&lt;10);
#define I915_EXEC_NO_RELOC              (1&lt;&lt;11);
#define I915_EXEC_HANDLE_LUT            (1&lt;&lt;12);
#define I915_EXEC_BSD_SHIFT      (13);
#define I915_EXEC_BSD_MASK       (3 &lt;&lt; I915_EXEC_BSD_SHIFT);
#define I915_EXEC_BSD_DEFAULT    (0 &lt;&lt; I915_EXEC_BSD_SHIFT);
#define I915_EXEC_BSD_RING1      (1 &lt;&lt; I915_EXEC_BSD_SHIFT);
#define I915_EXEC_BSD_RING2      (2 &lt;&lt; I915_EXEC_BSD_SHIFT);
#define I915_EXEC_RESOURCE_STREAMER     (1&lt;&lt;15);
#define I915_EXEC_FENCE_IN              (1&lt;&lt;16);
#define I915_EXEC_FENCE_OUT             (1&lt;&lt;17);
#define I915_EXEC_BATCH_FIRST           (1&lt;&lt;18);
#define I915_EXEC_FENCE_ARRAY   (1&lt;&lt;19);
#define I915_EXEC_FENCE_SUBMIT          (1 &lt;&lt; 20);
#define I915_EXEC_USE_EXTENSIONS        (1 &lt;&lt; 21);
#define __I915_EXEC_UNKNOWN_FLAGS (-(I915_EXEC_USE_EXTENSIONS &lt;&lt; 1));
    __u64 rsvd1;
    __u64 rsvd2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">buffers_ptr</span></code></dt><dd><p>Pointer to a list of gem_exec_object2 structs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer_count</span></code></dt><dd><p>Number of elements in <strong>buffers_ptr</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">batch_start_offset</span></code></dt><dd><p>Offset in the batchbuffer to start execution
from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">batch_len</span></code></dt><dd><p>Length in bytes of the batch buffer, starting from the
<strong>batch_start_offset</strong>. If 0, length is assumed to be the batch buffer
object size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DR1</span></code></dt><dd><p>deprecated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DR4</span></code></dt><dd><p>deprecated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_cliprects</span></code></dt><dd><p>See <strong>cliprects_ptr</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cliprects_ptr</span></code></dt><dd><p>Kernel clipping was a DRI1 misfeature.</p>
<p>It is invalid to use this field if I915_EXEC_FENCE_ARRAY or
I915_EXEC_USE_EXTENSIONS flags are not set.</p>
<p>If I915_EXEC_FENCE_ARRAY is set, then this is a pointer to an array
of <a class="reference internal" href="#c.drm_i915_gem_exec_fence" title="drm_i915_gem_exec_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_exec_fence</span></code></a> and <strong>num_cliprects</strong> is the length of the
array.</p>
<p>If I915_EXEC_USE_EXTENSIONS is set, then this is a pointer to a
single <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">i915_user_extension</span></code></a> and num_cliprects is 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Execbuf flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd1</span></code></dt><dd><p>Context id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd2</span></code></dt><dd><p>in and out sync_file file descriptors.</p>
<p>When I915_EXEC_FENCE_IN or I915_EXEC_FENCE_SUBMIT flag is set, the
lower 32 bits of this field will have the in sync_file fd (input).</p>
<p>When I915_EXEC_FENCE_OUT flag is set, the upper 32 bits of this
field will have the out sync_file fd (output).</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_i915_gem_caching">
struct <code class="sig-name descname">drm_i915_gem_caching</code><a class="headerlink" href="#c.drm_i915_gem_caching" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or get the caching for given object handle.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_caching {
    __u32 handle;
#define I915_CACHING_NONE               0;
#define I915_CACHING_CACHED             1;
#define I915_CACHING_DISPLAY            2;
    __u32 caching;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle of the buffer to set/get the caching level.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">caching</span></code></dt><dd><p>The GTT caching level to apply or possible return value.</p>
<p>The supported <strong>caching</strong> values:</p>
<p>I915_CACHING_NONE:</p>
<p>GPU access is not coherent with CPU caches.  Default for machines
without an LLC. This means manual flushing might be needed, if we
want GPU access to be coherent.</p>
<p>I915_CACHING_CACHED:</p>
<p>GPU access is coherent with CPU caches and furthermore the data is
cached in last-level caches shared between CPU cores and the GPU GT.</p>
<p>I915_CACHING_DISPLAY:</p>
<p>Special GPU caching mode which is coherent with the scanout engines.
Transparently falls back to I915_CACHING_NONE on platforms where no
special cache mode (like write-through or gfdt flushing) is
available. The kernel automatically sets this mode when using a
buffer as a scanout target.  Userspace can manually set this mode to
avoid a costly stall and clflush in the hotpath of drawing the first
frame.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Allow userspace to control the GTT caching bits for a given object when the
object is later mapped through the ppGTT(or GGTT on older platforms lacking
ppGTT support, or if the object is used for scanout). Note that this might
require unbinding the object from the GTT first, if its current caching value
doesn’t match.</p>
<p>Note that this all changes on discrete platforms, starting from DG1, the
set/get caching is no longer supported, and is now rejected.  Instead the CPU
caching attributes(WB vs WC) will become an immutable creation time property
for the object, along with the GTT caching level. For now we don’t expose any
new uAPI for this, instead on DG1 this is all implicit, although this largely
shouldn’t matter since DG1 is coherent by default(without any way of
controlling it).</p>
<p>Implicit caching rules, starting from DG1:</p>
<blockquote>
<div><ul class="simple">
<li><p>If any of the object placements (see <a class="reference internal" href="#c.drm_i915_gem_create_ext_memory_regions" title="drm_i915_gem_create_ext_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext_memory_regions</span></code></a>)
contain I915_MEMORY_CLASS_DEVICE then the object will be allocated and
mapped as write-combined only.</p></li>
<li><p>Everything else is always allocated and mapped as write-back, with the
guarantee that everything is also coherent with the GPU.</p></li>
</ul>
</div></blockquote>
<p>Note that this is likely to change in the future again, where we might need
more flexibility on future devices, so making this all explicit as part of a
new <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext</span></code></a> extension is probable.</p>
<p>Side note: Part of the reason for this is that changing the at-allocation-time CPU
caching attributes for the pages might be required(and is expensive) if we
need to then CPU map the pages later with different caching attributes. This
inconsistent caching behaviour, while supported on x86, is not universally
supported on other architectures. So for simplicity we opt for setting
everything at creation time, whilst also making it immutable, on discrete
platforms.</p>
<dl class="type">
<dt id="c.drm_i915_gem_context_create_ext">
struct <code class="sig-name descname">drm_i915_gem_context_create_ext</code><a class="headerlink" href="#c.drm_i915_gem_context_create_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure for creating contexts.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_context_create_ext {
    __u32 ctx_id;
    __u32 flags;
#define I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS        (1u &lt;&lt; 0);
#define I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE       (1u &lt;&lt; 1);
#define I915_CONTEXT_CREATE_FLAGS_UNKNOWN       (-(I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE &lt;&lt; 1));
    __u64 extensions;
#define I915_CONTEXT_CREATE_EXT_SETPARAM 0;
#define I915_CONTEXT_CREATE_EXT_CLONE 1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ctx_id</span></code></dt><dd><p>Id of the created context (output)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Supported flags are:</p>
<p>I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS:</p>
<p>Extensions may be appended to this structure and driver must check
for those. See <strong>extensions</strong>.</p>
<p>I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE</p>
<p>Created context will have single timeline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Zero-terminated chain of extensions.</p>
<p>I915_CONTEXT_CREATE_EXT_SETPARAM:
Context parameter to set or query during context creation.
See <a class="reference internal" href="#c.drm_i915_gem_context_create_ext_setparam" title="drm_i915_gem_context_create_ext_setparam"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_context_create_ext_setparam</span></code></a>.</p>
<p>I915_CONTEXT_CREATE_EXT_CLONE:
This extension has been removed. On the off chance someone somewhere
has attempted to use it, never re-use this extension number.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_i915_gem_context_param">
struct <code class="sig-name descname">drm_i915_gem_context_param</code><a class="headerlink" href="#c.drm_i915_gem_context_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Context parameter to set or query.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_context_param {
    __u32 ctx_id;
    __u32 size;
    __u64 param;
#define I915_CONTEXT_PARAM_BAN_PERIOD   0x1;
#define I915_CONTEXT_PARAM_NO_ZEROMAP   0x2;
#define I915_CONTEXT_PARAM_GTT_SIZE     0x3;
#define I915_CONTEXT_PARAM_NO_ERROR_CAPTURE     0x4;
#define I915_CONTEXT_PARAM_BANNABLE     0x5;
#define I915_CONTEXT_PARAM_PRIORITY     0x6;
#define I915_CONTEXT_MAX_USER_PRIORITY        1023 ;
#define I915_CONTEXT_DEFAULT_PRIORITY         0;
#define I915_CONTEXT_MIN_USER_PRIORITY        -1023 ;
#define I915_CONTEXT_PARAM_SSEU         0x7;
#define I915_CONTEXT_PARAM_RECOVERABLE  0x8;
#define I915_CONTEXT_PARAM_VM           0x9;
#define I915_CONTEXT_PARAM_ENGINES      0xa;
#define I915_CONTEXT_PARAM_PERSISTENCE  0xb;
#define I915_CONTEXT_PARAM_RINGSIZE     0xc;
#define I915_CONTEXT_PARAM_PROTECTED_CONTENT    0xd;
    __u64 value;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ctx_id</span></code></dt><dd><p>Context id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the parameter <strong>value</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">param</span></code></dt><dd><p>Parameter to set or query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>Context parameter value to be set or queried</p>
</dd>
</dl>
</div>
<p id="virtual-engine-uapi"><strong>Virtual Engine uAPI</strong></p>
<p>Virtual engine is a concept where userspace is able to configure a set of
physical engines, submit a batch buffer, and let the driver execute it on any
engine from the set as it sees fit.</p>
<p>This is primarily useful on parts which have multiple instances of a same
class engine, like for example GT3+ Skylake parts with their two VCS engines.</p>
<p>For instance userspace can enumerate all engines of a certain class using the
previously described <a class="reference internal" href="#engine-discovery-uapi">Engine Discovery uAPI</a>. After that userspace can
create a GEM context with a placeholder slot for the virtual engine (using
<cite>I915_ENGINE_CLASS_INVALID</cite> and <cite>I915_ENGINE_CLASS_INVALID_NONE</cite> for class
and instance respectively) and finally using the
<cite>I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE</cite> extension place a virtual engine in
the same reserved slot.</p>
<p>Example of creating a virtual engine and submitting a batch buffer to it:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">I915_DEFINE_CONTEXT_ENGINES_LOAD_BALANCE</span><span class="p">(</span><span class="n">virtual</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">engine_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// Place this virtual engine into engine map slot 0</span>
<span class="w">        </span><span class="p">.</span><span class="n">num_siblings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">engines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">I915_ENGINE_CLASS_VIDEO</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">                     </span><span class="p">{</span><span class="w"> </span><span class="n">I915_ENGINE_CLASS_VIDEO</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">I915_DEFINE_CONTEXT_PARAM_ENGINES</span><span class="p">(</span><span class="n">engines</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">engines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">I915_ENGINE_CLASS_INVALID</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">I915_ENGINE_CLASS_INVALID_NONE</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">virtual</span><span class="p">),</span><span class="w"> </span><span class="c1">// Chains after load_balance extension</span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">drm_i915_gem_context_create_ext_setparam</span><span class="w"> </span><span class="n">p_engines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_CREATE_EXT_SETPARAM</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_PARAM_ENGINES</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engines</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">engines</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">drm_i915_gem_context_create_ext</span><span class="w"> </span><span class="n">create</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_engines</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">ctx_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gem_context_create_ext</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">create</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Now we have created a GEM context with its engine map containing a</span>
<span class="c1">// single virtual engine. Submissions to this slot can go either to</span>
<span class="c1">// vcs0 or vcs1, depending on the load balancing algorithm used inside</span>
<span class="c1">// the driver. The load balancing is dynamic from one batch buffer to</span>
<span class="c1">// another and transparent to userspace.</span>

<span class="p">...</span><span class="w"></span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">rsvd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx_id</span><span class="p">;</span><span class="w"></span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Submits to index 0 which is the virtual engine</span>
<span class="n">gem_execbuf</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">execbuf</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<dl class="type">
<dt id="c.i915_context_engines_parallel_submit">
struct <code class="sig-name descname">i915_context_engines_parallel_submit</code><a class="headerlink" href="#c.i915_context_engines_parallel_submit" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure engine for parallel submission.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i915_context_engines_parallel_submit {
    struct i915_user_extension base;
    __u16 engine_index;
    __u16 width;
    __u16 num_siblings;
    __u16 mbz16;
    __u64 flags;
    __u64 mbz64[3];
    struct i915_engine_class_instance engines[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base user extension.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engine_index</span></code></dt><dd><p>slot for parallel engine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code></dt><dd><p>number of contexts per parallel engine or in other words the
number of batches in each submission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_siblings</span></code></dt><dd><p>number of siblings per context or in other words the
number of possible placements for each submission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mbz16</span></code></dt><dd><p>reserved for future use; must be zero</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>all undefined flags must be zero, currently not defined flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mbz64</span></code></dt><dd><p>reserved for future use; must be zero</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engines</span></code></dt><dd><p>2-d array of engine instances to configure parallel engine</p>
<p>length = width (i) * num_siblings (j)
index = j + i * num_siblings</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Setup a slot in the context engine map to allow multiple BBs to be submitted
in a single execbuf IOCTL. Those BBs will then be scheduled to run on the GPU
in parallel. Multiple hardware contexts are created internally in the i915 to
run these BBs. Once a slot is configured for N BBs only N BBs can be
submitted in each execbuf IOCTL and this is implicit behavior e.g. The user
doesn’t tell the execbuf IOCTL there are N BBs, the execbuf IOCTL knows how
many BBs there are based on the slot’s configuration. The N BBs are the last
N buffer objects or first N if I915_EXEC_BATCH_FIRST is set.</p>
<p>The default placement behavior is to create implicit bonds between each
context if each context maps to more than 1 physical engine (e.g. context is
a virtual engine). Also we only allow contexts of same engine class and these
contexts must be in logically contiguous order. Examples of the placement
behavior are described below. Lastly, the default is to not allow BBs to be
preempted mid-batch. Rather insert coordinated preemption points on all
hardware contexts between each set of BBs. Flags could be added in the future
to change both of these default behaviors.</p>
<p>Returns -EINVAL if hardware context placement configuration is invalid or if
the placement configuration isn’t supported on the platform / submission
interface.
Returns -ENODEV if extension isn’t supported on the platform / submission
interface.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Examples syntax:
CS[X] = generic engine of same class, logical instance X
INVALID = I915_ENGINE_CLASS_INVALID, I915_ENGINE_CLASS_INVALID_NONE

Example 1 pseudo code:
set_engines(INVALID)
set_parallel(engine_index=0, width=2, num_siblings=1,
             engines=CS[0],CS[1])

Results in the following valid placement:
CS[0], CS[1]

Example 2 pseudo code:
set_engines(INVALID)
set_parallel(engine_index=0, width=2, num_siblings=2,
             engines=CS[0],CS[2],CS[1],CS[3])

Results in the following valid placements:
CS[0], CS[1]
CS[2], CS[3]

This can be thought of as two virtual engines, each containing two
engines thereby making a 2D array. However, there are bonds tying the
entries together and placing restrictions on how they can be scheduled.
Specifically, the scheduler can choose only vertical columns from the 2D
array. That is, CS[0] is bonded to CS[1] and CS[2] to CS[3]. So if the
scheduler wants to submit to CS[0], it must also choose CS[1] and vice
versa. Same for CS[2] requires also using CS[3].
VE[0] = CS[0], CS[2]
VE[1] = CS[1], CS[3]

Example 3 pseudo code:
set_engines(INVALID)
set_parallel(engine_index=0, width=2, num_siblings=2,
             engines=CS[0],CS[1],CS[1],CS[3])

Results in the following valid and invalid placements:
CS[0], CS[1]
CS[1], CS[3] - Not logically contiguous, return -EINVAL
</pre></div>
</div>
<p id="context-engine-map-uapi"><strong>Context Engine Map uAPI</strong></p>
<p>Context engine map is a new way of addressing engines when submitting batch-
buffers, replacing the existing way of using identifiers like <cite>I915_EXEC_BLT</cite>
inside the flags field of <cite><a class="reference internal" href="#c.drm_i915_gem_execbuffer2" title="drm_i915_gem_execbuffer2"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_execbuffer2</span></code></a></cite>.</p>
<p>To use it created GEM contexts need to be configured with a list of engines
the user is intending to submit to. This is accomplished using the
<cite>I915_CONTEXT_PARAM_ENGINES</cite> parameter and <cite>struct
i915_context_param_engines</cite>.</p>
<p>For such contexts the <cite>I915_EXEC_RING_MASK</cite> field becomes an index into the
configured map.</p>
<p>Example of creating such context and submitting against it:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">I915_DEFINE_CONTEXT_PARAM_ENGINES</span><span class="p">(</span><span class="n">engines</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">engines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">I915_ENGINE_CLASS_RENDER</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">                     </span><span class="p">{</span><span class="w"> </span><span class="n">I915_ENGINE_CLASS_COPY</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">drm_i915_gem_context_create_ext_setparam</span><span class="w"> </span><span class="n">p_engines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_CREATE_EXT_SETPARAM</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_PARAM_ENGINES</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engines</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">engines</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">drm_i915_gem_context_create_ext</span><span class="w"> </span><span class="n">create</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">to_user_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_engines</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">ctx_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gem_context_create_ext</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">create</span><span class="p">);</span><span class="w"></span>

<span class="c1">// We have now created a GEM context with two engines in the map:</span>
<span class="c1">// Index 0 points to rcs0 while index 1 points to bcs0. Other engines</span>
<span class="c1">// will not be accessible from this context.</span>

<span class="p">...</span><span class="w"></span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">rsvd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx_id</span><span class="p">;</span><span class="w"></span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Submits to index 0, which is rcs0 for this context</span>
<span class="n">gem_execbuf</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">execbuf</span><span class="p">);</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">rsvd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx_id</span><span class="p">;</span><span class="w"></span>
<span class="n">execbuf</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Submits to index 0, which is bcs0 for this context</span>
<span class="n">gem_execbuf</span><span class="p">(</span><span class="n">drm_fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">execbuf</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<dl class="type">
<dt id="c.drm_i915_gem_context_create_ext_setparam">
struct <code class="sig-name descname">drm_i915_gem_context_create_ext_setparam</code><a class="headerlink" href="#c.drm_i915_gem_context_create_ext_setparam" title="Permalink to this definition">¶</a></dt>
<dd><p>Context parameter to set or query during context creation.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_context_create_ext_setparam {
    struct i915_user_extension base;
    struct drm_i915_gem_context_param param;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Extension link. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">param</span></code></dt><dd><p>Context parameter to set or query.
See <a class="reference internal" href="#c.drm_i915_gem_context_param" title="drm_i915_gem_context_param"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_context_param</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_i915_gem_vm_control">
struct <code class="sig-name descname">drm_i915_gem_vm_control</code><a class="headerlink" href="#c.drm_i915_gem_vm_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure to create or destroy VM.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_vm_control {
    __u64 extensions;
    __u32 flags;
    __u32 vm_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>Zero-terminated chain of extensions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>reserved for future usage, currently MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vm_id</span></code></dt><dd><p>Id of the VM created or to be destroyed</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>DRM_I915_GEM_VM_CREATE -</p>
<p>Create a new virtual memory address space (ppGTT) for use within a context
on the same file. Extensions can be provided to configure exactly how the
address space is setup upon creation.</p>
<p>The id of new VM (bound to the fd) for use with I915_CONTEXT_PARAM_VM is
returned in the outparam <strong>id</strong>.</p>
<p>An extension chain maybe provided, starting with <strong>extensions</strong>, and terminated
by the <strong>next_extension</strong> being 0. Currently, no extensions are defined.</p>
<p>DRM_I915_GEM_VM_DESTROY -</p>
<p>Destroys a previously created VM id, specified in <strong>vm_id</strong>.</p>
<p>No extensions or flags are allowed currently, and so must be zero.</p>
<dl class="type">
<dt id="c.drm_i915_gem_userptr">
struct <code class="sig-name descname">drm_i915_gem_userptr</code><a class="headerlink" href="#c.drm_i915_gem_userptr" title="Permalink to this definition">¶</a></dt>
<dd><p>Create GEM object from user allocated memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_userptr {
    __u64 user_ptr;
    __u64 user_size;
    __u32 flags;
#define I915_USERPTR_READ_ONLY 0x1;
#define I915_USERPTR_PROBE 0x2;
#define I915_USERPTR_UNSYNCHRONIZED 0x80000000;
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">user_ptr</span></code></dt><dd><p>The pointer to the allocated memory.</p>
<p>Needs to be aligned to PAGE_SIZE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">user_size</span></code></dt><dd><p>The size in bytes for the allocated memory. This will also become the
object size.</p>
<p>Needs to be aligned to PAGE_SIZE, and should be at least PAGE_SIZE,
or larger.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Supported flags:</p>
<p>I915_USERPTR_READ_ONLY:</p>
<p>Mark the object as readonly, this also means GPU access can only be
readonly. This is only supported on HW which supports readonly access
through the GTT. If the HW can’t support readonly access, an error is
returned.</p>
<p>I915_USERPTR_PROBE:</p>
<p>Probe the provided <strong>user_ptr</strong> range and validate that the <strong>user_ptr</strong> is
indeed pointing to normal memory and that the range is also valid.
For example if some garbage address is given to the kernel, then this
should complain.</p>
<p>Returns -EFAULT if the probe failed.</p>
<p>Note that this doesn’t populate the backing pages, and also doesn’t
guarantee that the object will remain valid when the object is
eventually used.</p>
<p>The kernel supports this feature if I915_PARAM_HAS_USERPTR_PROBE
returns a non-zero value.</p>
<p>I915_USERPTR_UNSYNCHRONIZED:</p>
<p>NOT USED. Setting this flag will result in an error.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Returned handle for the object.</p>
<p>Object handles are nonzero.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Userptr objects have several restrictions on what ioctls can be used with the
object handle.</p>
<dl class="type">
<dt id="c.drm_i915_perf_oa_config">
struct <code class="sig-name descname">drm_i915_perf_oa_config</code><a class="headerlink" href="#c.drm_i915_perf_oa_config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_perf_oa_config {
    char uuid[36];
    __u32 n_mux_regs;
    __u32 n_boolean_regs;
    __u32 n_flex_regs;
    __u64 mux_regs_ptr;
    __u64 boolean_regs_ptr;
    __u64 flex_regs_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uuid</span></code></dt><dd><p>String formatted like “%08x-%04x-%04x-%04x-%012x”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_mux_regs</span></code></dt><dd><p>Number of mux regs in <code class="xref c c-type docutils literal notranslate"><span class="pre">mux_regs_ptr</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_boolean_regs</span></code></dt><dd><p>Number of boolean regs in <code class="xref c c-type docutils literal notranslate"><span class="pre">boolean_regs_ptr</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_flex_regs</span></code></dt><dd><p>Number of flex regs in <code class="xref c c-type docutils literal notranslate"><span class="pre">flex_regs_ptr</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mux_regs_ptr</span></code></dt><dd><p>Pointer to tuples of u32 values (register address, value) for mux
registers.  Expected length of buffer is (2 * sizeof(u32) *
<code class="xref c c-type docutils literal notranslate"><span class="pre">n_mux_regs</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">boolean_regs_ptr</span></code></dt><dd><p>Pointer to tuples of u32 values (register address, value) for mux
registers.  Expected length of buffer is (2 * sizeof(u32) *
<code class="xref c c-type docutils literal notranslate"><span class="pre">n_boolean_regs</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flex_regs_ptr</span></code></dt><dd><p>Pointer to tuples of u32 values (register address, value) for mux
registers.  Expected length of buffer is (2 * sizeof(u32) *
<code class="xref c c-type docutils literal notranslate"><span class="pre">n_flex_regs</span></code>).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Structure to upload perf dynamic configuration into the kernel.</p>
<dl class="type">
<dt id="c.drm_i915_query_item">
struct <code class="sig-name descname">drm_i915_query_item</code><a class="headerlink" href="#c.drm_i915_query_item" title="Permalink to this definition">¶</a></dt>
<dd><p>An individual query for the kernel to process.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_item {
    __u64 query_id;
#define DRM_I915_QUERY_TOPOLOGY_INFO            1;
#define DRM_I915_QUERY_ENGINE_INFO              2;
#define DRM_I915_QUERY_PERF_CONFIG              3;
#define DRM_I915_QUERY_MEMORY_REGIONS           4;
#define DRM_I915_QUERY_HWCONFIG_BLOB            5;
#define DRM_I915_QUERY_GEOMETRY_SUBSLICES       6;
    __s32 length;
    __u32 flags;
#define DRM_I915_QUERY_PERF_CONFIG_LIST          1;
#define DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID 2;
#define DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID   3;
    __u64 data_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">query_id</span></code></dt><dd><dl class="simple">
<dt>The id for this query.  Currently accepted query IDs are:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_TOPOLOGY_INFO</span></code> (see <a class="reference internal" href="#c.drm_i915_query_topology_info" title="drm_i915_query_topology_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_topology_info</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_ENGINE_INFO</span></code> (see <a class="reference internal" href="#c.drm_i915_engine_info" title="drm_i915_engine_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_engine_info</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG</span></code> (see <a class="reference internal" href="#c.drm_i915_query_perf_config" title="drm_i915_query_perf_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_perf_config</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_MEMORY_REGIONS</span></code> (see <a class="reference internal" href="#c.drm_i915_query_memory_regions" title="drm_i915_query_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_memory_regions</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_HWCONFIG_BLOB</span></code> (see <cite>GuC HWCONFIG blob uAPI</cite>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_GEOMETRY_SUBSLICES</span></code> (see <a class="reference internal" href="#c.drm_i915_query_topology_info" title="drm_i915_query_topology_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_topology_info</span></code></a>)</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>When set to zero by userspace, this is filled with the size of the
data to be written at the <strong>data_ptr</strong> pointer. The kernel sets this
value to a negative value to signal an error on a particular query
item.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>When <code class="xref c c-type docutils literal notranslate"><span class="pre">query_id</span></code> == <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_TOPOLOGY_INFO</span></code>, must be 0.</p>
<p>When <code class="xref c c-type docutils literal notranslate"><span class="pre">query_id</span></code> == <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG</span></code>, must be one of the
following:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_LIST</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_FOR_UUID</span></code></p></li>
</ul>
</div></blockquote>
<p>When <code class="xref c c-type docutils literal notranslate"><span class="pre">query_id</span></code> == <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_GEOMETRY_SUBSLICES</span></code> must contain
a <a class="reference internal" href="#c.i915_engine_class_instance" title="i915_engine_class_instance"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_engine_class_instance</span></code></a> that references a render engine.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_ptr</span></code></dt><dd><p>Data will be written at the location pointed by <strong>data_ptr</strong> when the
value of <strong>length</strong> matches the length of the data to be written by the
kernel.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The behaviour is determined by the <strong>query_id</strong>. Note that exactly what
<strong>data_ptr</strong> is also depends on the specific <strong>query_id</strong>.</p>
<dl class="type">
<dt id="c.drm_i915_query">
struct <code class="sig-name descname">drm_i915_query</code><a class="headerlink" href="#c.drm_i915_query" title="Permalink to this definition">¶</a></dt>
<dd><p>Supply an array of <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_item</span></code></a> for the kernel to fill out.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query {
    __u32 num_items;
    __u32 flags;
    __u64 items_ptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_items</span></code></dt><dd><p>The number of elements in the <strong>items_ptr</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Unused for now. Must be cleared to zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">items_ptr</span></code></dt><dd><p>Pointer to an array of <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_item</span></code></a>. The number of
array elements is <strong>num_items</strong>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note that this is generally a two step process for each <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_i915_query_item</span></code></a> in the array:</p>
<ol class="arabic simple">
<li><p>Call the DRM_IOCTL_I915_QUERY, giving it our array of <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_i915_query_item</span></code></a>, with <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.length</span></code></a> set to zero. The
kernel will then fill in the size, in bytes, which tells userspace how
memory it needs to allocate for the blob(say for an array of properties).</p></li>
<li><p>Next we call DRM_IOCTL_I915_QUERY again, this time with the
<a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.data_ptr</span></code></a> equal to our newly allocated blob. Note that
the <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.length</span></code></a> should still be the same as what the
kernel previously set. At this point the kernel can fill in the blob.</p></li>
</ol>
<p>Note that for some query items it can make sense for userspace to just pass
in a buffer/blob equal to or larger than the required size. In this case only
a single ioctl call is needed. For some smaller query items this can work
quite well.</p>
<dl class="type">
<dt id="c.drm_i915_query_topology_info">
struct <code class="sig-name descname">drm_i915_query_topology_info</code><a class="headerlink" href="#c.drm_i915_query_topology_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_topology_info {
    __u16 flags;
    __u16 max_slices;
    __u16 max_subslices;
    __u16 max_eus_per_subslice;
    __u16 subslice_offset;
    __u16 subslice_stride;
    __u16 eu_offset;
    __u16 eu_stride;
    __u8 data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Unused for now. Must be cleared to zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_slices</span></code></dt><dd><p>The number of bits used to express the slice mask.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_subslices</span></code></dt><dd><p>The number of bits used to express the subslice mask.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_eus_per_subslice</span></code></dt><dd><p>The number of bits in the EU mask that correspond to a single
subslice’s EUs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subslice_offset</span></code></dt><dd><p>Offset in data[] at which the subslice masks are stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subslice_stride</span></code></dt><dd><p>Stride at which each of the subslice masks for each slice are
stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eu_offset</span></code></dt><dd><p>Offset in data[] at which the EU masks are stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eu_stride</span></code></dt><dd><p>Stride at which each of the EU masks for each subslice are stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Contains 3 pieces of information :</p>
<ul>
<li><p>The slice mask with one bit per slice telling whether a slice is
available. The availability of slice X can be queried with the
following formula :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">X</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
<p>Starting with Xe_HP platforms, Intel hardware no longer has
traditional slices so i915 will always report a single slice
(hardcoded slicemask = 0x1) which contains all of the platform’s
subslices.  I.e., the mask here does not reflect any of the newer
hardware concepts such as “gslices” or “cslices” since userspace
is capable of inferring those from the subslice mask.</p>
</li>
<li><p>The subslice mask for each slice with one bit per subslice telling
whether a subslice is available.  Starting with Gen12 we use the
term “subslice” to refer to what the hardware documentation
describes as a “dual-subslices.”  The availability of subslice Y
in slice X can be queried with the following formula :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">subslice_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">subslice_stride</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">Y</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The EU mask for each subslice in each slice, with one bit per EU
telling whether an EU is available. The availability of EU Z in
subslice Y in slice X can be queried with the following formula :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">eu_offset</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">max_subslices</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">eu_stride</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">      </span><span class="n">Z</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="w"></span>
<span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">Z</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Describes slice/subslice/EU information queried by
<code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_TOPOLOGY_INFO</span></code></p>
<p id="engine-discovery-uapi"><strong>Engine Discovery uAPI</strong></p>
<p>Engine discovery uAPI is a way of enumerating physical engines present in a
GPU associated with an open i915 DRM file descriptor. This supersedes the old
way of using <cite>DRM_IOCTL_I915_GETPARAM</cite> and engine identifiers like
<cite>I915_PARAM_HAS_BLT</cite>.</p>
<p>The need for this interface came starting with Icelake and newer GPUs, which
started to establish a pattern of having multiple engines of a same class,
where not all instances were always completely functionally equivalent.</p>
<p>Entry point for this uapi is <cite>DRM_IOCTL_I915_QUERY</cite> with the
<cite>DRM_I915_QUERY_ENGINE_INFO</cite> as the queried item id.</p>
<p>Example for getting the list of engines:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">drm_i915_query_engine_info</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">drm_i915_query_item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">query_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DRM_I915_QUERY_ENGINE_INFO</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">drm_i915_query</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">num_items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">items_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">item</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="c1">// First query the size of the blob we need, this needs to be large</span>
<span class="c1">// enough to hold our array of engines. The kernel will fill out the</span>
<span class="c1">// item.length for us, which is the number of bytes we need.</span>
<span class="c1">//</span>
<span class="c1">// Alternatively a large buffer can be allocated straight away enabling</span>
<span class="c1">// querying in one pass, in which case item.length should contain the</span>
<span class="c1">// length of the provided buffer.</span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"></span>

<span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Now that we allocated the required number of bytes, we call the ioctl</span>
<span class="c1">// again, this time with the data_ptr pointing to our newly allocated</span>
<span class="c1">// blob, which the kernel can then populate with info on all engines.</span>
<span class="n">item</span><span class="p">.</span><span class="n">data_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"></span>

<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"></span>

<span class="c1">// We can now access each engine in the array</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_engines</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">drm_i915_engine_info</span><span class="w"> </span><span class="n">einfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">engines</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">u16</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">einfo</span><span class="p">.</span><span class="n">engine</span><span class="p">.</span><span class="n">class</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">u16</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">einfo</span><span class="p">.</span><span class="n">engine</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">....</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">free</span><span class="p">(</span><span class="n">info</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Each of the enumerated engines, apart from being defined by its class and
instance (see <cite><a class="reference internal" href="#c.i915_engine_class_instance" title="i915_engine_class_instance"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_engine_class_instance</span></code></a></cite>), also can have flags and
capabilities defined as documented in i915_drm.h.</p>
<p>For instance video engines which support HEVC encoding will have the
<cite>I915_VIDEO_CLASS_CAPABILITY_HEVC</cite> capability bit set.</p>
<p>Engine discovery only fully comes to its own when combined with the new way
of addressing engines when submitting batch buffers using contexts with
engine maps configured.</p>
<dl class="type">
<dt id="c.drm_i915_engine_info">
struct <code class="sig-name descname">drm_i915_engine_info</code><a class="headerlink" href="#c.drm_i915_engine_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_engine_info {
    struct i915_engine_class_instance engine;
    __u32 rsvd0;
    __u64 flags;
#define I915_ENGINE_INFO_HAS_LOGICAL_INSTANCE           (1 &lt;&lt; 0);
    __u64 capabilities;
#define I915_VIDEO_CLASS_CAPABILITY_HEVC                (1 &lt;&lt; 0);
#define I915_VIDEO_AND_ENHANCE_CLASS_CAPABILITY_SFC     (1 &lt;&lt; 1);
    __u16 logical_instance;
    __u16 rsvd1[3];
    __u64 rsvd2[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">engine</span></code></dt><dd><p>Engine class and instance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd0</span></code></dt><dd><p>Reserved field.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Engine flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capabilities</span></code></dt><dd><p>Capabilities of this engine.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">logical_instance</span></code></dt><dd><p>Logical instance of engine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd1</span></code></dt><dd><p>Reserved fields.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd2</span></code></dt><dd><p>Reserved fields.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Describes one engine and it’s capabilities as known to the driver.</p>
<dl class="type">
<dt id="c.drm_i915_query_engine_info">
struct <code class="sig-name descname">drm_i915_query_engine_info</code><a class="headerlink" href="#c.drm_i915_query_engine_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_engine_info {
    __u32 num_engines;
    __u32 rsvd[3];
    struct drm_i915_engine_info engines[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_engines</span></code></dt><dd><p>Number of <a class="reference internal" href="#c.drm_i915_engine_info" title="drm_i915_engine_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_engine_info</span></code></a> structs following.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">engines</span></code></dt><dd><p>Marker for drm_i915_engine_info structures.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Engine info query enumerates all engines known to the driver by filling in
an array of <a class="reference internal" href="#c.drm_i915_engine_info" title="drm_i915_engine_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_engine_info</span></code></a> structures.</p>
<dl class="type">
<dt id="c.drm_i915_query_perf_config">
struct <code class="sig-name descname">drm_i915_query_perf_config</code><a class="headerlink" href="#c.drm_i915_query_perf_config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_perf_config {
    union {
        __u64 n_configs;
        __u64 config;
        char uuid[36];
    };
    __u32 flags;
    __u8 data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_configs</span></code></dt><dd><p>When <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.flags</span></code></a> ==
<code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_LIST</span></code>, i915 sets this fields to
the number of configurations available.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config</span></code></dt><dd><p>When <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.flags</span></code></a> ==
<code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID</span></code>, i915 will use the
value in this field as configuration identifier to decide
what data to write into config_ptr.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uuid</span></code></dt><dd><p>When <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.flags</span></code></a> ==
<code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID</span></code>, i915 will use the
value in this field as configuration identifier to decide
what data to write into config_ptr.</p>
<p>String formatted like “<code class="docutils literal notranslate"><span class="pre">08x-````04x-````04x-````04x-````012x</span></code>”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Unused for now. Must be cleared to zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>When <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.flags</span></code></a> == <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_LIST</span></code>,
i915 will write an array of __u64 of configuration identifiers.</p>
<p>When <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.flags</span></code></a> == <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG_DATA</span></code>,
i915 will write a <a class="reference internal" href="#c.drm_i915_perf_oa_config" title="drm_i915_perf_oa_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_perf_oa_config</span></code></a>. If the following
fields of <a class="reference internal" href="#c.drm_i915_perf_oa_config" title="drm_i915_perf_oa_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_perf_oa_config</span></code></a> are not set to 0, i915 will
write into the associated pointers the values of submitted when the
configuration was created :</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#c.drm_i915_perf_oa_config" title="drm_i915_perf_oa_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_perf_oa_config.n_mux_regs</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.drm_i915_perf_oa_config" title="drm_i915_perf_oa_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_perf_oa_config.n_boolean_regs</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.drm_i915_perf_oa_config" title="drm_i915_perf_oa_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_perf_oa_config.n_flex_regs</span></code></a></p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Data written by the kernel with query <code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_PERF_CONFIG</span></code> and
<code class="docutils literal notranslate"><span class="pre">DRM_I915_QUERY_GEOMETRY_SUBSLICES</span></code>.</p>
<dl class="type">
<dt id="c.drm_i915_gem_memory_class">
enum <code class="sig-name descname">drm_i915_gem_memory_class</code><a class="headerlink" href="#c.drm_i915_gem_memory_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported memory classes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">I915_MEMORY_CLASS_SYSTEM</span></code></dt><dd><p>System memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I915_MEMORY_CLASS_DEVICE</span></code></dt><dd><p>Device local-memory</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_i915_gem_memory_class_instance">
struct <code class="sig-name descname">drm_i915_gem_memory_class_instance</code><a class="headerlink" href="#c.drm_i915_gem_memory_class_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify particular memory region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_memory_class_instance {
    __u16 memory_class;
    __u16 memory_instance;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">memory_class</span></code></dt><dd><p>See <a class="reference internal" href="#c.drm_i915_gem_memory_class" title="drm_i915_gem_memory_class"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">drm_i915_gem_memory_class</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memory_instance</span></code></dt><dd><p>Which instance</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.drm_i915_memory_region_info">
struct <code class="sig-name descname">drm_i915_memory_region_info</code><a class="headerlink" href="#c.drm_i915_memory_region_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes one region as known to the driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_memory_region_info {
    struct drm_i915_gem_memory_class_instance region;
    __u32 rsvd0;
    __u64 probed_size;
    __u64 unallocated_size;
    union {
        __u64 rsvd1[8];
        struct {
            __u64 probed_cpu_visible_size;
            __u64 unallocated_cpu_visible_size;
        };
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">region</span></code></dt><dd><p>The class:instance pair encoding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd0</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probed_size</span></code></dt><dd><p>Memory probed by the driver</p>
<p>Note that it should not be possible to ever encounter a zero value
here, also note that no current region type will ever return -1 here.
Although for future region types, this might be a possibility. The
same applies to the other size fields.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unallocated_size</span></code></dt><dd><p>Estimate of memory remaining</p>
<p>Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable accounting.
Without this (or if this is an older kernel) the value here will
always equal the <strong>probed_size</strong>. Note this is only currently tracked
for I915_MEMORY_CLASS_DEVICE regions (for other types the value here
will always equal the <strong>probed_size</strong>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd1</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probed_cpu_visible_size</span></code></dt><dd><p>Memory probed by the driver
that is CPU accessible.</p>
<p>This will be always be &lt;= <strong>probed_size</strong>, and the
remainder (if there is any) will not be CPU
accessible.</p>
<p>On systems without small BAR, the <strong>probed_size</strong> will
always equal the <strong>probed_cpu_visible_size</strong>, since all
of it will be CPU accessible.</p>
<p>Note this is only tracked for
I915_MEMORY_CLASS_DEVICE regions (for other types the
value here will always equal the <strong>probed_size</strong>).</p>
<p>Note that if the value returned here is zero, then
this must be an old kernel which lacks the relevant
small-bar uAPI support (including
I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS), but on
such systems we should never actually end up with a
small BAR configuration, assuming we are able to load
the kernel module. Hence it should be safe to treat
this the same as when <strong>probed_cpu_visible_size</strong> ==
<strong>probed_size</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unallocated_cpu_visible_size</span></code></dt><dd><p>Estimate of CPU
visible memory remaining.</p>
<p>Note this is only tracked for
I915_MEMORY_CLASS_DEVICE regions (for other types the
value here will always equal the
<strong>probed_cpu_visible_size</strong>).</p>
<p>Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable
accounting.  Without this the value here will always
equal the <strong>probed_cpu_visible_size</strong>. Note this is only
currently tracked for I915_MEMORY_CLASS_DEVICE
regions (for other types the value here will also
always equal the <strong>probed_cpu_visible_size</strong>).</p>
<p>If this is an older kernel the value here will be
zero, see also <strong>probed_cpu_visible_size</strong>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note this is using both <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query_item</span></code></a> and <a class="reference internal" href="#c.drm_i915_query" title="drm_i915_query"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_query</span></code></a>.
For this new query we are adding the new query id DRM_I915_QUERY_MEMORY_REGIONS
at <a class="reference internal" href="#c.drm_i915_query_item" title="drm_i915_query_item"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_query_item.query_id</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_i915_query_memory_regions">
struct <code class="sig-name descname">drm_i915_query_memory_regions</code><a class="headerlink" href="#c.drm_i915_query_memory_regions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_query_memory_regions {
    __u32 num_regions;
    __u32 rsvd[3];
    struct drm_i915_memory_region_info regions[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_regions</span></code></dt><dd><p>Number of supported regions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rsvd</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regions</span></code></dt><dd><p>Info about each supported region</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The region info query enumerates all regions known to the driver by filling
in an array of <a class="reference internal" href="#c.drm_i915_memory_region_info" title="drm_i915_memory_region_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_memory_region_info</span></code></a> structures.</p>
<p>Example for getting the list of supported regions:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">drm_i915_query_memory_regions</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">drm_i915_query_item</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">query_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DRM_I915_QUERY_MEMORY_REGIONS</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">drm_i915_query</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">num_items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">items_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">item</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="c1">// First query the size of the blob we need, this needs to be large</span>
<span class="c1">// enough to hold our array of regions. The kernel will fill out the</span>
<span class="c1">// item.length for us, which is the number of bytes we need.</span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"></span>

<span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Now that we allocated the required number of bytes, we call the ioctl</span>
<span class="c1">// again, this time with the data_ptr pointing to our newly allocated</span>
<span class="c1">// blob, which the kernel can then populate with the all the region info.</span>
<span class="n">item</span><span class="p">.</span><span class="n">data_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"></span>

<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_QUERY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"></span>

<span class="c1">// We can now access each region in the array</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_regions</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">drm_i915_memory_region_info</span><span class="w"> </span><span class="n">mr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">u16</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mr</span><span class="p">.</span><span class="n">region</span><span class="p">.</span><span class="n">class</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">u16</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mr</span><span class="p">.</span><span class="n">region</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="p">....</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">free</span><span class="p">(</span><span class="n">info</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p id="guc-hwconfig-blob-uapi"><strong>GuC HWCONFIG blob uAPI</strong></p>
<p>The GuC produces a blob with information about the current device.
i915 reads this blob from GuC and makes it available via this uAPI.</p>
<p>The format and meaning of the blob content are documented in the
Programmer’s Reference Manual.</p>
<dl class="type">
<dt id="c.drm_i915_gem_create_ext">
struct <code class="sig-name descname">drm_i915_gem_create_ext</code><a class="headerlink" href="#c.drm_i915_gem_create_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>Existing gem_create behaviour, with added extension support using <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_create_ext {
    __u64 size;
    __u32 handle;
#define I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS (1 &lt;&lt; 0);
    __u32 flags;
#define I915_GEM_CREATE_EXT_MEMORY_REGIONS 0;
#define I915_GEM_CREATE_EXT_PROTECTED_CONTENT 1;
    __u64 extensions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Requested size for the object.</p>
<p>The (page-aligned) allocated size for the object will be returned.</p>
<p>On platforms like DG2/ATS the kernel will always use 64K or larger
pages for I915_MEMORY_CLASS_DEVICE. The kernel also requires a
minimum of 64K GTT alignment for such objects.</p>
<p>NOTE: Previously the ABI here required a minimum GTT alignment of 2M
on DG2/ATS, due to how the hardware implemented 64K GTT page support,
where we had the following complications:</p>
<blockquote>
<div><p>1) The entire PDE (which covers a 2MB virtual address range), must
contain only 64K PTEs, i.e mixing 4K and 64K PTEs in the same
PDE is forbidden by the hardware.</p>
<p>2) We still need to support 4K PTEs for I915_MEMORY_CLASS_SYSTEM
objects.</p>
</div></blockquote>
<p>However on actual production HW this was completely changed to now
allow setting a TLB hint at the PTE level (see PS64), which is a lot
more flexible than the above. With this the 2M restriction was
dropped where we now only require 64K.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Returned handle for the object.</p>
<p>Object handles are nonzero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Optional flags.</p>
<p>Supported values:</p>
<p>I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS - Signal to the kernel that
the object will need to be accessed via the CPU.</p>
<p>Only valid when placing objects in I915_MEMORY_CLASS_DEVICE, and only
strictly required on configurations where some subset of the device
memory is directly visible/mappable through the CPU (which we also
call small BAR), like on some DG2+ systems. Note that this is quite
undesirable, but due to various factors like the client CPU, BIOS etc
it’s something we can expect to see in the wild. See
<a class="reference internal" href="#c.drm_i915_memory_region_info" title="drm_i915_memory_region_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_memory_region_info.probed_cpu_visible_size</span></code></a> for how to
determine if this system applies.</p>
<p>Note that one of the placements MUST be I915_MEMORY_CLASS_SYSTEM, to
ensure the kernel can always spill the allocation to system memory,
if the object can’t be allocated in the mappable part of
I915_MEMORY_CLASS_DEVICE.</p>
<p>Also note that since the kernel only supports flat-CCS on objects
that can <em>only</em> be placed in I915_MEMORY_CLASS_DEVICE, we therefore
don’t support I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS together with
flat-CCS.</p>
<p>Without this hint, the kernel will assume that non-mappable
I915_MEMORY_CLASS_DEVICE is preferred for this object. Note that the
kernel can still migrate the object to the mappable part, as a last
resort, if userspace ever CPU faults this object, but this might be
expensive, and so ideally should be avoided.</p>
<p>On older kernels which lack the relevant small-bar uAPI support (see
also <a class="reference internal" href="#c.drm_i915_memory_region_info" title="drm_i915_memory_region_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_memory_region_info.probed_cpu_visible_size</span></code></a>),
usage of the flag will result in an error, but it should NEVER be
possible to end up with a small BAR configuration, assuming we can
also successfully load the i915 kernel module. In such cases the
entire I915_MEMORY_CLASS_DEVICE region will be CPU accessible, and as
such there are zero restrictions on where the object can be placed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>The chain of extensions to apply to this object.</p>
<p>This will be useful in the future when we need to support several
different extensions, and we need to apply more than one when
creating the object. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
<p>If we don’t supply any extensions then we get the same old gem_create
behaviour.</p>
<p>For I915_GEM_CREATE_EXT_MEMORY_REGIONS usage see
<a class="reference internal" href="#c.drm_i915_gem_create_ext_memory_regions" title="drm_i915_gem_create_ext_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_create_ext_memory_regions</span></code></a>.</p>
<p>For I915_GEM_CREATE_EXT_PROTECTED_CONTENT usage see
<a class="reference internal" href="#c.drm_i915_gem_create_ext_protected_content" title="drm_i915_gem_create_ext_protected_content"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_create_ext_protected_content</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note that new buffer flags should be added here, at least for the stuff that
is immutable. Previously we would have two ioctls, one to create the object
with gem_create, and another to apply various parameters, however this
creates some ambiguity for the params which are considered immutable. Also in
general we’re phasing out the various SET/GET ioctls.</p>
<dl class="type">
<dt id="c.drm_i915_gem_create_ext_memory_regions">
struct <code class="sig-name descname">drm_i915_gem_create_ext_memory_regions</code><a class="headerlink" href="#c.drm_i915_gem_create_ext_memory_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>The I915_GEM_CREATE_EXT_MEMORY_REGIONS extension.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_create_ext_memory_regions {
    struct i915_user_extension base;
    __u32 pad;
    __u32 num_regions;
    __u64 regions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Extension link. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>MBZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_regions</span></code></dt><dd><p>Number of elements in the <strong>regions</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regions</span></code></dt><dd><p>The regions/placements array.</p>
<p>An array of <a class="reference internal" href="#c.drm_i915_gem_memory_class_instance" title="drm_i915_gem_memory_class_instance"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_memory_class_instance</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Set the object with the desired set of placements/regions in priority
order. Each entry must be unique and supported by the device.</p>
<p>This is provided as an array of <a class="reference internal" href="#c.drm_i915_gem_memory_class_instance" title="drm_i915_gem_memory_class_instance"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_i915_gem_memory_class_instance</span></code></a>, or
an equivalent layout of class:instance pair encodings. See <a class="reference internal" href="#c.drm_i915_query_memory_regions" title="drm_i915_query_memory_regions"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_i915_query_memory_regions</span></code></a> and DRM_I915_QUERY_MEMORY_REGIONS for how to
query the supported regions for a device.</p>
<p>As an example, on discrete devices, if we wish to set the placement as
device local-memory we can do something like:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">drm_i915_gem_memory_class_instance</span><span class="w"> </span><span class="n">region_lmem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">memory_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_MEMORY_CLASS_DEVICE</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">memory_instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">drm_i915_gem_create_ext_memory_regions</span><span class="w"> </span><span class="n">regions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_GEM_CREATE_EXT_MEMORY_REGIONS</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">regions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">region_lmem</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">num_regions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">drm_i915_gem_create_ext</span><span class="w"> </span><span class="n">create_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">regions</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_GEM_CREATE_EXT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">create_ext</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>At which point we get the object handle in <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext.handle</span></code></a>,
along with the final object size in <a class="reference internal" href="#c.drm_i915_gem_create_ext" title="drm_i915_gem_create_ext"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_i915_gem_create_ext.size</span></code></a>, which
should account for any rounding up, if required.</p>
<p>Note that userspace has no means of knowing the current backing region
for objects where <strong>num_regions</strong> is larger than one. The kernel will only
ensure that the priority order of the <strong>regions</strong> array is honoured, either
when initially placing the object, or when moving memory around due to
memory pressure</p>
<p>On Flat-CCS capable HW, compression is supported for the objects residing
in I915_MEMORY_CLASS_DEVICE. When such objects (compressed) have other
memory class in <strong>regions</strong> and migrated (by i915, due to memory
constraints) to the non I915_MEMORY_CLASS_DEVICE region, then i915 needs to
decompress the content. But i915 doesn’t have the required information to
decompress the userspace compressed objects.</p>
<p>So i915 supports Flat-CCS, on the objects which can reside only on
I915_MEMORY_CLASS_DEVICE regions.</p>
<dl class="type">
<dt id="c.drm_i915_gem_create_ext_protected_content">
struct <code class="sig-name descname">drm_i915_gem_create_ext_protected_content</code><a class="headerlink" href="#c.drm_i915_gem_create_ext_protected_content" title="Permalink to this definition">¶</a></dt>
<dd><p>The I915_OBJECT_PARAM_PROTECTED_CONTENT extension.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct drm_i915_gem_create_ext_protected_content {
    struct i915_user_extension base;
    __u32 flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Extension link. See <a class="reference internal" href="#c.i915_user_extension" title="i915_user_extension"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i915_user_extension</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>reserved for future usage, currently MBZ</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If this extension is provided, buffer contents are expected to be protected
by PXP encryption and require decryption for scan out and processing. This
is only possible on platforms that have PXP enabled, on all other scenarios
using this extension will cause the ioctl to fail and return -ENODEV. The
flags parameter is reserved for future expansion and must currently be set
to zero.</p>
<p>The buffer contents are considered invalid after a PXP session teardown.</p>
<p>The encryption is guaranteed to be processed correctly only if the object
is submitted with a context created using the
I915_CONTEXT_PARAM_PROTECTED_CONTENT flag. This will also enable extra checks
at submission time on the validity of the objects involved.</p>
<p>Below is an example on how to create a protected object:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">drm_i915_gem_create_ext_protected_content</span><span class="w"> </span><span class="n">protected_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I915_GEM_CREATE_EXT_PROTECTED_CONTENT</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">drm_i915_gem_create_ext</span><span class="w"> </span><span class="n">create_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">protected_ext</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">DRM_IOCTL_I915_GEM_CREATE_EXT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">create_ext</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">DRM Driver uAPI</a><ul>
<li><a class="reference internal" href="#drm-i915-uapi">drm/i915 uAPI</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/gpu/driver-uapi.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/gpu/driver-uapi.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>