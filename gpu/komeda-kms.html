
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>drm/komeda Arm display driver &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Backlight support" href="backlight.html" />
    <link rel="prev" title="Arm Framebuffer Compression (AFBC)" href="afbc.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="drm-komeda-arm-display-driver">
<h1>drm/komeda Arm display driver<a class="headerlink" href="#drm-komeda-arm-display-driver" title="Permalink to this headline">¶</a></h1>
<p>The drm/komeda driver supports the Arm display processor D71 and later products,
this document gives a brief overview of driver design: how it works and why
design it like that.</p>
<section id="overview-of-d71-like-display-ips">
<h2>Overview of D71 like display IPs<a class="headerlink" href="#overview-of-d71-like-display-ips" title="Permalink to this headline">¶</a></h2>
<p>From D71, Arm display IP begins to adopt a flexible and modularized
architecture. A display pipeline is made up of multiple individual and
functional pipeline stages called components, and every component has some
specific capabilities that can give the flowed pipeline pixel data a
particular processing.</p>
<p>Typical D71 components:</p>
<section id="layer">
<h3>Layer<a class="headerlink" href="#layer" title="Permalink to this headline">¶</a></h3>
<p>Layer is the first pipeline stage, which prepares the pixel data for the next
stage. It fetches the pixel from memory, decodes it if it’s AFBC, rotates the
source image, unpacks or converts YUV pixels to the device internal RGB pixels,
then adjusts the color_space of pixels if needed.</p>
</section>
<section id="scaler">
<h3>Scaler<a class="headerlink" href="#scaler" title="Permalink to this headline">¶</a></h3>
<p>As its name suggests, scaler takes responsibility for scaling, and D71 also
supports image enhancements by scaler.
The usage of scaler is very flexible and can be connected to layer output
for layer scaling, or connected to compositor and scale the whole display
frame and then feed the output data into wb_layer which will then write it
into memory.</p>
</section>
<section id="compositor-compiz">
<h3>Compositor (compiz)<a class="headerlink" href="#compositor-compiz" title="Permalink to this headline">¶</a></h3>
<p>Compositor blends multiple layers or pixel data flows into one single display
frame. its output frame can be fed into post image processor for showing it on
the monitor or fed into wb_layer and written to memory at the same time.
user can also insert a scaler between compositor and wb_layer to down scale
the display frame first and then write to memory.</p>
</section>
<section id="writeback-layer-wb-layer">
<h3>Writeback Layer (wb_layer)<a class="headerlink" href="#writeback-layer-wb-layer" title="Permalink to this headline">¶</a></h3>
<p>Writeback layer does the opposite things of Layer, which connects to compiz
and writes the composition result to memory.</p>
</section>
<section id="post-image-processor-improc">
<h3>Post image processor (improc)<a class="headerlink" href="#post-image-processor-improc" title="Permalink to this headline">¶</a></h3>
<p>Post image processor adjusts frame data like gamma and color space to fit the
requirements of the monitor.</p>
</section>
<section id="timing-controller-timing-ctrlr">
<h3>Timing controller (timing_ctrlr)<a class="headerlink" href="#timing-controller-timing-ctrlr" title="Permalink to this headline">¶</a></h3>
<p>Final stage of display pipeline, Timing controller is not for the pixel
handling, but only for controlling the display timing.</p>
</section>
<section id="merger">
<h3>Merger<a class="headerlink" href="#merger" title="Permalink to this headline">¶</a></h3>
<p>D71 scaler mostly only has the half horizontal input/output capabilities
compared with Layer, like if Layer supports 4K input size, the scaler only can
support 2K input/output in the same time. To achieve the ful frame scaling, D71
introduces Layer Split, which splits the whole image to two half parts and feeds
them to two Layers A and B, and does the scaling independently. After scaling
the result need to be fed to merger to merge two part images together, and then
output merged result to compiz.</p>
</section>
<section id="splitter">
<h3>Splitter<a class="headerlink" href="#splitter" title="Permalink to this headline">¶</a></h3>
<p>Similar to Layer Split, but Splitter is used for writeback, which splits the
compiz result to two parts and then feed them to two scalers.</p>
</section>
</section>
<section id="possible-d71-pipeline-usage">
<h2>Possible D71 Pipeline usage<a class="headerlink" href="#possible-d71-pipeline-usage" title="Permalink to this headline">¶</a></h2>
<p>Benefitting from the modularized architecture, D71 pipelines can be easily
adjusted to fit different usages. And D71 has two pipelines, which support two
types of working mode:</p>
<ul>
<li><p>Dual display mode
Two pipelines work independently and separately to drive two display outputs.</p></li>
<li><p>Single display mode
Two pipelines work together to drive only one display output.</p>
<p>On this mode, pipeline_B doesn’t work indenpendently, but outputs its
composition result into pipeline_A, and its pixel timing also derived from
pipeline_A.timing_ctrlr. The pipeline_B works just like a “slave” of
pipeline_A(master)</p>
</li>
</ul>
<section id="single-pipeline-data-flow">
<h3>Single pipeline data flow<a class="headerlink" href="#single-pipeline-data-flow" title="Permalink to this headline">¶</a></h3>
<figure class="align-default" id="id1">
<img alt="Single pipeline digraph" src="../_images/DOT-66002ea43d67b166bf5079b6119bec5b363127ba.svg" /><figcaption>
<p><span class="caption-text">Single pipeline data flow</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="dual-pipeline-with-slave-enabled">
<h3>Dual pipeline with Slave enabled<a class="headerlink" href="#dual-pipeline-with-slave-enabled" title="Permalink to this headline">¶</a></h3>
<figure class="align-default" id="id2">
<img alt="Slave pipeline digraph" src="../_images/DOT-d59a989ca63363954b8d9c9e03d8cff5effff7e7.svg" /><figcaption>
<p><span class="caption-text">Slave pipeline enabled data flow</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="sub-pipelines-for-input-and-output">
<h3>Sub-pipelines for input and output<a class="headerlink" href="#sub-pipelines-for-input-and-output" title="Permalink to this headline">¶</a></h3>
<p>A complete display pipeline can be easily divided into three sub-pipelines
according to the in/out usage.</p>
<section id="layer-input-pipeline">
<h4>Layer(input) pipeline<a class="headerlink" href="#layer-input-pipeline" title="Permalink to this headline">¶</a></h4>
<figure class="align-default" id="id3">
<img alt="Layer data digraph" src="../_images/DOT-18a2db30442be8a3a7d319b58bde80b777ddc6d3.svg" /><figcaption>
<p><span class="caption-text">Layer (input) data flow</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id4">
<img alt="Layer Split digraph" src="../_images/DOT-fe8cb898f5142ca0241f8f00c5a38ba8acccf617.svg" /><figcaption>
<p><span class="caption-text">Layer Split pipeline</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="writeback-output-pipeline">
<h4>Writeback(output) pipeline<a class="headerlink" href="#writeback-output-pipeline" title="Permalink to this headline">¶</a></h4>
<figure class="align-default" id="id5">
<img alt="writeback digraph" src="../_images/DOT-1c48a6e05371ecefe4b6c024d2bea979a24bc08a.svg" /><figcaption>
<p><span class="caption-text">Writeback(output) data flow</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<figure class="align-default" id="id6">
<img alt="split writeback digraph" src="../_images/DOT-f14473fbd2d906d47164f55a2529d4ac78b1bc74.svg" /><figcaption>
<p><span class="caption-text">Writeback(output) Split data flow</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="display-output-pipeline">
<h4>Display output pipeline<a class="headerlink" href="#display-output-pipeline" title="Permalink to this headline">¶</a></h4>
<figure class="align-default" id="id7">
<img alt="display digraph" src="../_images/DOT-d0edc63bffe8e7dca5c56d8d28a47b97ffa80d27.svg" /><figcaption>
<p><span class="caption-text">display output data flow</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>In the following section we’ll see these three sub-pipelines will be handled
by KMS-plane/wb_conn/crtc respectively.</p>
</section>
</section>
</section>
<section id="komeda-resource-abstraction">
<h2>Komeda Resource abstraction<a class="headerlink" href="#komeda-resource-abstraction" title="Permalink to this headline">¶</a></h2>
<section id="struct-komeda-pipeline-component">
<h3>struct komeda_pipeline/component<a class="headerlink" href="#struct-komeda-pipeline-component" title="Permalink to this headline">¶</a></h3>
<p>To fully utilize and easily access/configure the HW, the driver side also uses
a similar architecture: Pipeline/Component to describe the HW features and
capabilities, and a specific component includes two parts:</p>
<ul class="simple">
<li><p>Data flow controlling.</p></li>
<li><p>Specific component capabilities and features.</p></li>
</ul>
<p>So the driver defines a common header <a class="reference internal" href="#c.komeda_component" title="komeda_component"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">komeda_component</span></code></a> to describe the
data flow control and all specific components are a subclass of this base
structure.</p>
<dl class="type">
<dt id="c.komeda_component">
struct <code class="sig-name descname">komeda_component</code><a class="headerlink" href="#c.komeda_component" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_component {
    struct drm_private_obj obj;
    struct komeda_pipeline *pipeline;
    char name[32];
    u32 __iomem *reg;
    u32 id;
    u32 hw_id;
    u8 max_active_inputs;
    u8 max_active_outputs;
    u32 supported_inputs;
    u32 supported_outputs;
    const struct komeda_component_funcs *funcs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>treat component as private obj</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pipeline</span></code></dt><dd><p>the komeda pipeline this component belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>component name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg</span></code></dt><dd><p>component register base,
which is initialized by chip and used by chip only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>component id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_id</span></code></dt><dd><p>component hw id,
which is initialized by chip and used by chip only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_active_inputs</span></code></dt><dd><p><strong>max_active_outputs</strong>:</p>
<p>maximum number of inputs/outputs that can be active at the same time
Note:
the number isn’t the bit number of <strong>supported_inputs</strong> or
<strong>supported_outputs</strong>, but may be less than it, since component may not
support enabling all <strong>supported_inputs</strong>/outputs at the same time.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_active_outputs</span></code></dt><dd><p>maximum number of outputs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_inputs</span></code></dt><dd><p><strong>supported_outputs</strong>:</p>
<p>bitmask of BIT(component-&gt;id) for the supported inputs/outputs,
describes the possibilities of how a component is linked into a
pipeline.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_outputs</span></code></dt><dd><p>bitmask of supported output componenet ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>chip functions to access HW</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.komeda_component" title="komeda_component"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">komeda_component</span></code></a> describe the data flow capabilities for how to link a
component into the display pipeline.
all specified components are subclass of this structure.</p>
<dl class="type">
<dt id="c.komeda_component_output">
struct <code class="sig-name descname">komeda_component_output</code><a class="headerlink" href="#c.komeda_component_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_component_output {
    struct komeda_component *component;
    u8 output_port;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">component</span></code></dt><dd><p>indicate which component the data comes from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">output_port</span></code></dt><dd><p>the output port of the <a class="reference internal" href="#c.komeda_component_output" title="komeda_component_output"><code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_component_output.component</span></code></a></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>a component has multiple outputs, if want to know where the data
comes from, only know the component is not enough, we still need to know
its output port</p>
<dl class="type">
<dt id="c.komeda_component_state">
struct <code class="sig-name descname">komeda_component_state</code><a class="headerlink" href="#c.komeda_component_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_component_state {
    struct drm_private_state obj;
    struct komeda_component *component;
    union {
        struct drm_crtc *crtc;
        struct drm_plane *plane;
        struct drm_connector *wb_conn;
        void *binding_user;
    };
    u16 active_inputs;
    u16 changed_active_inputs;
    u16 affected_inputs;
    struct komeda_component_output inputs[KOMEDA_COMPONENT_N_INPUTS];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>tracking component_state by drm_atomic_state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">component</span></code></dt><dd><p>backpointer to the component</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>backpointer for user crtc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">plane</span></code></dt><dd><p>backpointer for user plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wb_conn</span></code></dt><dd><p>backpointer for user wb_connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">binding_user</span></code></dt><dd><p>currently bound user, the user can be <strong>crtc</strong>, <strong>plane</strong> or <strong>wb_conn</strong>,
which is valid decided by <strong>component</strong> and <strong>inputs</strong></p>
<ul class="simple">
<li><p>Layer: its user always is plane.</p></li>
<li><p>compiz/improc/timing_ctrlr: the user is crtc.</p></li>
<li><p>wb_layer: wb_conn;</p></li>
<li><p>scaler: plane when input is layer, wb_conn if input is compiz.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_inputs</span></code></dt><dd><p>active_inputs is bitmask of <strong>inputs</strong> index</p>
<ul class="simple">
<li><p>active_inputs = changed_active_inputs | unchanged_active_inputs</p></li>
<li><p>affected_inputs = old-&gt;active_inputs | new-&gt;active_inputs;</p></li>
<li><p>disabling_inputs = affected_inputs ^ active_inputs;</p></li>
<li><p>changed_inputs = disabling_inputs | changed_active_inputs;</p></li>
</ul>
<p>NOTE:
changed_inputs doesn’t include all active_input but only
<strong>changed_active_inputs</strong>, and this bitmask can be used in chip
level for dirty update.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">changed_active_inputs</span></code></dt><dd><p>bitmask of the changed <strong>active_inputs</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">affected_inputs</span></code></dt><dd><p>bitmask for affected <strong>inputs</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inputs</span></code></dt><dd><p>the specific inputs[i] only valid on BIT(i) has been set in
<strong>active_inputs</strong>, if not the inputs[i] is undefined.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>component_state is the data flow configuration of the component, and it’s
the superclass of all specific component_state like <strong>komeda_layer_state</strong>,
<strong>komeda_scaler_state</strong></p>
<dl class="type">
<dt id="c.komeda_pipeline">
struct <code class="sig-name descname">komeda_pipeline</code><a class="headerlink" href="#c.komeda_pipeline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_pipeline {
    struct drm_private_obj obj;
    struct komeda_dev *mdev;
    struct clk *pxlclk;
    int id;
    u32 avail_comps;
    u32 standalone_disabled_comps;
    int n_layers;
    struct komeda_layer *layers[KOMEDA_PIPELINE_MAX_LAYERS];
    int n_scalers;
    struct komeda_scaler *scalers[KOMEDA_PIPELINE_MAX_SCALERS];
    struct komeda_compiz *compiz;
    struct komeda_splitter *splitter;
    struct komeda_merger *merger;
    struct komeda_layer  *wb_layer;
    struct komeda_improc *improc;
    struct komeda_timing_ctrlr *ctrlr;
    const struct komeda_pipeline_funcs *funcs;
    struct device_node *of_node;
    struct device_node *of_output_port;
    struct device_node *of_output_links[2];
    bool dual_link;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>link pipeline as private obj of drm_atomic_state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mdev</span></code></dt><dd><p>the parent komeda_dev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pxlclk</span></code></dt><dd><p>pixel clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>pipeline id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">avail_comps</span></code></dt><dd><p>available components mask of pipeline</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">standalone_disabled_comps</span></code></dt><dd><p>When disable the pipeline, some components can not be disabled
together with others, but need a sparated and standalone disable.
The standalone_disabled_comps are the components which need to be
disabled standalone, and this concept also introduce concept of
two phase.
phase 1: for disabling the common components.
phase 2: for disabling the standalong_disabled_comps.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_layers</span></code></dt><dd><p>the number of layer on <strong>layers</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">layers</span></code></dt><dd><p>the pipeline layers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_scalers</span></code></dt><dd><p>the number of scaler on <strong>scalers</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scalers</span></code></dt><dd><p>the pipeline scalers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compiz</span></code></dt><dd><p>compositor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">splitter</span></code></dt><dd><p>for split the compiz output to two half data flows</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">merger</span></code></dt><dd><p>merger</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wb_layer</span></code></dt><dd><p>writeback layer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">improc</span></code></dt><dd><p>post image processor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctrlr</span></code></dt><dd><p>timing controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>chip private pipeline functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt><dd><p>pipeline dt node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_output_port</span></code></dt><dd><p>pipeline output port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_output_links</span></code></dt><dd><p>output connector device nodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dual_link</span></code></dt><dd><p>true if of_output_links[0] and [1] are both valid</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Represent a complete display pipeline and hold all functional components.</p>
<dl class="type">
<dt id="c.komeda_pipeline_state">
struct <code class="sig-name descname">komeda_pipeline_state</code><a class="headerlink" href="#c.komeda_pipeline_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_pipeline_state {
    struct drm_private_state obj;
    struct komeda_pipeline *pipe;
    struct drm_crtc *crtc;
    u32 active_comps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>tracking pipeline_state by drm_atomic_state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pipe</span></code></dt><dd><p>backpointer to the pipeline</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crtc</span></code></dt><dd><p>currently bound crtc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_comps</span></code></dt><dd><p>bitmask - BIT(component-&gt;id) of active components</p>
</dd>
</dl>
</div>
<p><strong>NOTE</strong></p>
<p>Unlike the pipeline, pipeline_state doesn’t gather any component_state
into it. It because all component will be managed by drm_atomic_state.</p>
</section>
</section>
<section id="resource-discovery-and-initialization">
<h2>Resource discovery and initialization<a class="headerlink" href="#resource-discovery-and-initialization" title="Permalink to this headline">¶</a></h2>
<p>Pipeline and component are used to describe how to handle the pixel data. We
still need a &#64;<a class="reference internal" href="#c.komeda_dev" title="komeda_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">komeda_dev</span></code></a> to describe the whole view of the device, and
the control-abilites of device.</p>
<p>We have &amp;komeda_dev, &amp;komeda_pipeline, &amp;komeda_component. Now fill devices with
pipelines. Since komeda is not for D71 only but also intended for later products,
of course we’d better share as much as possible between different products. To
achieve this, split the komeda device into two layers: CORE and CHIP.</p>
<ul class="simple">
<li><p>CORE: for common features and capabilities handling.</p></li>
<li><p>CHIP: for register programing and HW specific feature (limitation) handling.</p></li>
</ul>
<p>CORE can access CHIP by three chip function structures:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.komeda_dev_funcs" title="komeda_dev_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">komeda_dev_funcs</span></code></a></p></li>
<li><p>struct komeda_pipeline_funcs</p></li>
<li><p>struct komeda_component_funcs</p></li>
</ul>
<dl class="type">
<dt id="c.komeda_dev_funcs">
struct <code class="sig-name descname">komeda_dev_funcs</code><a class="headerlink" href="#c.komeda_dev_funcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_dev_funcs {
    void (*init_format_table)(struct komeda_dev *mdev);
    int (*enum_resources)(struct komeda_dev *mdev);
    void (*cleanup)(struct komeda_dev *mdev);
    int (*connect_iommu)(struct komeda_dev *mdev);
    int (*disconnect_iommu)(struct komeda_dev *mdev);
    irqreturn_t (*irq_handler)(struct komeda_dev *mdev, struct komeda_events *events);
    int (*enable_irq)(struct komeda_dev *mdev);
    int (*disable_irq)(struct komeda_dev *mdev);
    void (*on_off_vblank)(struct komeda_dev *mdev, int master_pipe, bool on);
    void (*dump_register)(struct komeda_dev *mdev, struct seq_file *seq);
    int (*change_opmode)(struct komeda_dev *mdev, int new_mode);
    void (*flush)(struct komeda_dev *mdev, int master_pipe, u32 active_pipes);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">init_format_table</span></code></dt><dd><p>initialize <a class="reference internal" href="#c.komeda_dev" title="komeda_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_dev-&gt;format_table</span></code></a>, this function should be called
before the <code class="xref c c-type docutils literal notranslate"><span class="pre">enum_resource</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum_resources</span></code></dt><dd><p>for CHIP to report or add pipeline and component resources to CORE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup</span></code></dt><dd><p>call to chip to cleanup komeda_dev-&gt;chip data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connect_iommu</span></code></dt><dd><p>Optional, connect to external iommu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disconnect_iommu</span></code></dt><dd><p>Optional, disconnect to external iommu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler</span></code></dt><dd><p>for CORE to get the HW event from the CHIP when interrupt happened.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_irq</span></code></dt><dd><p>enable irq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_irq</span></code></dt><dd><p>disable irq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">on_off_vblank</span></code></dt><dd><p>notify HW to on/off vblank</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dump_register</span></code></dt><dd><p>Optional, dump registers to seq_file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">change_opmode</span></code></dt><dd><p>Notify HW to switch to a new display operation mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flush</span></code></dt><dd><p>Notify the HW to flush or kickoff the update</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Supplied by chip level and returned by the chip entry function xxx_identify,</p>
<dl class="type">
<dt id="c.komeda_dev">
struct <code class="sig-name descname">komeda_dev</code><a class="headerlink" href="#c.komeda_dev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_dev {
    struct device *dev;
    u32 __iomem   *reg_base;
    struct komeda_chip_info chip;
    struct komeda_format_caps_table fmt_tbl;
    struct clk *aclk;
    int irq;
    struct mutex lock;
    u32 dpmode;
    int n_pipelines;
    struct komeda_pipeline *pipelines[KOMEDA_MAX_PIPELINES];
    const struct komeda_dev_funcs *funcs;
    void *chip_data;
    struct iommu_domain *iommu;
    struct dentry *debugfs_root;
    u16 err_verbosity;
#define KOMEDA_DEV_PRINT_ERR_EVENTS BIT(0);
#define KOMEDA_DEV_PRINT_WARN_EVENTS BIT(1);
#define KOMEDA_DEV_PRINT_INFO_EVENTS BIT(2);
#define KOMEDA_DEV_PRINT_DUMP_STATE_ON_EVENT BIT(8);
#define KOMEDA_DEV_PRINT_DISABLE_RATELIMIT BIT(12);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>the base device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_base</span></code></dt><dd><p>the base address of komeda io space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip</span></code></dt><dd><p>the basic chip information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fmt_tbl</span></code></dt><dd><p>initialized by <a class="reference internal" href="#c.komeda_dev_funcs" title="komeda_dev_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_dev_funcs-&gt;init_format_table</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aclk</span></code></dt><dd><p>HW main engine clk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>irq number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>used to protect dpmode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpmode</span></code></dt><dd><p>current display mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_pipelines</span></code></dt><dd><p>the number of pipe in <strong>pipelines</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pipelines</span></code></dt><dd><p>the komeda pipelines</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt><dd><p>chip funcs to access to HW</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip_data</span></code></dt><dd><p>chip data will be added by <a class="reference internal" href="#c.komeda_dev_funcs" title="komeda_dev_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_dev_funcs.enum_resources()</span></code></a> and
destroyed by <a class="reference internal" href="#c.komeda_dev_funcs" title="komeda_dev_funcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_dev_funcs.cleanup()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iommu</span></code></dt><dd><p>iommu domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debugfs_root</span></code></dt><dd><p>root directory of komeda debugfs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">err_verbosity</span></code></dt><dd><p>bitmask for how much extra info to print on error</p>
<p>See KOMEDA_DEV_* macros for details. Low byte contains the debug
level categories, the high byte contains extra debug options.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Pipeline and component are used to describe how to handle the pixel data.
komeda_device is for describing the whole view of the device, and the
control-abilites of device.</p>
</section>
<section id="format-handling">
<h2>Format handling<a class="headerlink" href="#format-handling" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.komeda_format_caps">
struct <code class="sig-name descname">komeda_format_caps</code><a class="headerlink" href="#c.komeda_format_caps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_format_caps {
    u32 hw_id;
    u32 fourcc;
    u32 supported_layer_types;
    u32 supported_rots;
    u32 supported_afbc_layouts;
    u64 supported_afbc_features;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">hw_id</span></code></dt><dd><p>hw format id, hw specific value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fourcc</span></code></dt><dd><p>drm fourcc format.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_layer_types</span></code></dt><dd><p>indicate which layer supports this format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_rots</span></code></dt><dd><p>allowed rotations for this format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_afbc_layouts</span></code></dt><dd><p>supported afbc layerout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_afbc_features</span></code></dt><dd><p>supported afbc features</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>komeda_format_caps is for describing ARM display specific features and
limitations for a specific format, and format_caps will be linked into
<code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_framebuffer</span></code> like a extension of <a class="reference internal" href="drm-kms.html#c.drm_format_info" title="drm_format_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_format_info</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>one fourcc may has two different format_caps items for fourcc and
fourcc+modifier</p>
<dl class="type">
<dt id="c.komeda_format_caps_table">
struct <code class="sig-name descname">komeda_format_caps_table</code><a class="headerlink" href="#c.komeda_format_caps_table" title="Permalink to this definition">¶</a></dt>
<dd><p>format_caps mananger</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_format_caps_table {
    u32 n_formats;
    const struct komeda_format_caps *format_caps;
    bool (*format_mod_supported)(const struct komeda_format_caps *caps, u32 layer_type, u64 modifier, u32 rot);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n_formats</span></code></dt><dd><p>the size of format_caps list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format_caps</span></code></dt><dd><p>format_caps list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format_mod_supported</span></code></dt><dd><p>Optional. Some HW may have special requirements or
limitations which can not be described by format_caps, this func supply HW
the ability to do the further HW specific check.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.komeda_fb">
struct <code class="sig-name descname">komeda_fb</code><a class="headerlink" href="#c.komeda_fb" title="Permalink to this definition">¶</a></dt>
<dd><p>Entending drm_framebuffer with komeda attribute</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_fb {
    struct drm_framebuffer base;
    const struct komeda_format_caps *format_caps;
    bool is_va;
    u32 aligned_w;
    u32 aligned_h;
    u32 afbc_size;
    u32 offset_payload;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_framebuffer</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">format_caps</span></code></dt><dd><p>extends drm_format_info for komeda specific information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_va</span></code></dt><dd><p>if smmu is enabled, it will be true</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aligned_w</span></code></dt><dd><p>aligned frame buffer width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aligned_h</span></code></dt><dd><p>aligned frame buffer height</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">afbc_size</span></code></dt><dd><p>minimum size of afbc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset_payload</span></code></dt><dd><p>start of afbc body buffer</p>
</dd>
</dl>
</div>
</section>
<section id="attach-komeda-dev-to-drm-kms">
<h2>Attach komeda_dev to DRM-KMS<a class="headerlink" href="#attach-komeda-dev-to-drm-kms" title="Permalink to this headline">¶</a></h2>
<p>Komeda abstracts resources by pipeline/component, but DRM-KMS uses
crtc/plane/connector. One KMS-obj cannot represent only one single component,
since the requirements of a single KMS object cannot simply be achieved by a
single component, usually that needs multiple components to fit the requirement.
Like set mode, gamma, ctm for KMS all target on CRTC-obj, but komeda needs
compiz, improc and timing_ctrlr to work together to fit these requirements.
And a KMS-Plane may require multiple komeda resources: layer/scaler/compiz.</p>
<p>So, one KMS-Obj represents a sub-pipeline of komeda resources.</p>
<ul class="simple">
<li><p>Plane: <a class="reference internal" href="#layer-input-pipeline">Layer(input) pipeline</a></p></li>
<li><p>Wb_connector: <a class="reference internal" href="#writeback-output-pipeline">Writeback(output) pipeline</a></p></li>
<li><p>Crtc: <a class="reference internal" href="#display-output-pipeline">Display output pipeline</a></p></li>
</ul>
<p>So, for komeda, we treat KMS crtc/plane/connector as users of pipeline and
component, and at any one time a pipeline/component only can be used by one
user. And pipeline/component will be treated as private object of DRM-KMS; the
state will be managed by drm_atomic_state as well.</p>
<section id="how-to-map-plane-to-layer-input-pipeline">
<h3>How to map plane to Layer(input) pipeline<a class="headerlink" href="#how-to-map-plane-to-layer-input-pipeline" title="Permalink to this headline">¶</a></h3>
<p>Komeda has multiple Layer input pipelines, see:
-   <a class="reference internal" href="#single-pipeline-data-flow">Single pipeline data flow</a>
-   <a class="reference internal" href="#dual-pipeline-with-slave-enabled">Dual pipeline with Slave enabled</a></p>
<p>The easiest way is binding a plane to a fixed Layer pipeline, but consider the
komeda capabilities:</p>
<ul>
<li><p>Layer Split, See <a class="reference internal" href="#layer-input-pipeline">Layer(input) pipeline</a></p>
<p>Layer_Split is quite complicated feature, which splits a big image into two
parts and handles it by two layers and two scalers individually. But it
imports an edge problem or effect in the middle of the image after the split.
To avoid such a problem, it needs a complicated Split calculation and some
special configurations to the layer and scaler. We’d better hide such HW
related complexity to user mode.</p>
</li>
<li><p>Slave pipeline, See <a class="reference internal" href="#dual-pipeline-with-slave-enabled">Dual pipeline with Slave enabled</a></p>
<p>Since the compiz component doesn’t output alpha value, the slave pipeline
only can be used for bottom layers composition. The komeda driver wants to
hide this limitation to the user. The way to do this is to pick a suitable
Layer according to plane_state-&gt;zpos.</p>
</li>
</ul>
<p>So for komeda, the KMS-plane doesn’t represent a fixed komeda layer pipeline,
but multiple Layers with same capabilities. Komeda will select one or more
Layers to fit the requirement of one KMS-plane.</p>
</section>
<section id="make-component-pipeline-to-be-drm-private-obj">
<h3>Make component/pipeline to be drm_private_obj<a class="headerlink" href="#make-component-pipeline-to-be-drm-private-obj" title="Permalink to this headline">¶</a></h3>
<p>Add <a class="reference internal" href="drm-kms.html#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_obj</span></code></a> to <a class="reference internal" href="#c.komeda_component" title="komeda_component"><code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_component</span></code></a>, <a class="reference internal" href="#c.komeda_pipeline" title="komeda_pipeline"><code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_pipeline</span></code></a></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">komeda_component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">drm_private_obj</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">komeda_pipeline</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">drm_private_obj</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="tracking-component-state-pipeline-state-by-drm-atomic-state">
<h3>Tracking component_state/pipeline_state by drm_atomic_state<a class="headerlink" href="#tracking-component-state-pipeline-state-by-drm-atomic-state" title="Permalink to this headline">¶</a></h3>
<p>Add <a class="reference internal" href="drm-kms.html#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_private_state</span></code></a> and user to <a class="reference internal" href="#c.komeda_component_state" title="komeda_component_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_component_state</span></code></a>,
<a class="reference internal" href="#c.komeda_pipeline_state" title="komeda_pipeline_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_pipeline_state</span></code></a></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">komeda_component_state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">drm_private_state</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">binding_user</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">komeda_pipeline_state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">drm_private_state</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">drm_crtc</span><span class="w"> </span><span class="o">*</span><span class="n">crtc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="komeda-component-validation">
<h3>komeda component validation<a class="headerlink" href="#komeda-component-validation" title="Permalink to this headline">¶</a></h3>
<p>Komeda has multiple types of components, but the process of validation are
similar, usually including the following steps:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">komeda_xxxx_validate</span><span class="p">(</span><span class="k">struct</span> <span class="nc">komeda_component_xxx</span><span class="w"> </span><span class="n">xxx_comp</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">struct</span> <span class="nc">komeda_component_output</span><span class="w"> </span><span class="o">*</span><span class="n">input_dflow</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">struct</span> <span class="nc">drm_plane</span><span class="o">/</span><span class="n">crtc</span><span class="o">/</span><span class="n">connector</span><span class="w"> </span><span class="o">*</span><span class="n">user</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">struct</span> <span class="nc">drm_plane</span><span class="o">/</span><span class="n">crtc</span><span class="o">/</span><span class="n">connector_state</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">user_state</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">setup</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">check</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">needed</span><span class="p">,</span><span class="w"> </span><span class="n">like</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">scaler</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">optional</span><span class="w"> </span><span class="n">depending</span><span class="w"></span>
<span class="w">              </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">user_state</span><span class="p">;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">unneeded</span><span class="p">,</span><span class="w"> </span><span class="n">just</span><span class="w"> </span><span class="k">return</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">caller</span><span class="w"> </span><span class="n">will</span><span class="w"></span>
<span class="w">              </span><span class="n">put</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">flow</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="n">stage</span><span class="p">.</span><span class="w"></span>
<span class="w">     </span><span class="n">Setup</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n">check</span><span class="w"> </span><span class="n">user_state</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="n">features</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">capabilities</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">see</span><span class="w"></span>
<span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="n">requirements</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">met</span><span class="p">;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">not</span><span class="p">,</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">fail</span><span class="p">.</span><span class="w"></span>
<span class="w">     </span><span class="n">Setup</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="n">component_state</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">drm_atomic_state</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">try</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">set</span><span class="w"></span>
<span class="w">              </span><span class="n">user</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">component</span><span class="p">;</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">assigned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">another</span><span class="w"></span>
<span class="w">              </span><span class="n">user</span><span class="w"> </span><span class="n">already</span><span class="p">.</span><span class="w"></span>
<span class="w">     </span><span class="n">Setup</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w"> </span><span class="n">configure</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">component_state</span><span class="p">,</span><span class="w"> </span><span class="n">like</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="n">component</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">convert</span><span class="w"> </span><span class="n">user_state</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="n">specific</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="w"></span>
<span class="w">     </span><span class="n">Setup</span><span class="w"> </span><span class="mi">4</span><span class="o">:</span><span class="w"> </span><span class="n">adjust</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">input_dflow</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">prepare</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="n">stage</span><span class="p">.</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="komeda-kms-abstraction">
<h3>komeda_kms Abstraction<a class="headerlink" href="#komeda-kms-abstraction" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.komeda_plane">
struct <code class="sig-name descname">komeda_plane</code><a class="headerlink" href="#c.komeda_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>komeda instance of drm_plane</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_plane {
    struct drm_plane base;
    struct komeda_layer *layer;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">layer</span></code></dt><dd><p>represents available layer input pipelines for this plane.</p>
<p>NOTE:
the layer is not for a specific Layer, but indicate a group of
Layers with same capabilities.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.komeda_plane_state">
struct <code class="sig-name descname">komeda_plane_state</code><a class="headerlink" href="#c.komeda_plane_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_plane_state {
    struct drm_plane_state base;
    struct list_head zlist_node;
    u8 layer_split : 1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_plane_state</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zlist_node</span></code></dt><dd><p>zorder list node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">layer_split</span></code></dt><dd><p>on/off layer_split</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The plane_state can be split into two data flow (left/right) and handled
by two layers <a class="reference internal" href="#c.komeda_plane" title="komeda_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_plane.layer</span></code></a> and <a class="reference internal" href="#c.komeda_plane" title="komeda_plane"><code class="xref c c-type docutils literal notranslate"><span class="pre">komeda_plane.layer</span></code></a>.right</p>
<dl class="type">
<dt id="c.komeda_wb_connector">
struct <code class="sig-name descname">komeda_wb_connector</code><a class="headerlink" href="#c.komeda_wb_connector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_wb_connector {
    struct drm_writeback_connector base;
    struct komeda_layer *wb_layer;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_writeback_connector" title="drm_writeback_connector"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_writeback_connector</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wb_layer</span></code></dt><dd><p>represents associated writeback pipeline of komeda</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.komeda_crtc">
struct <code class="sig-name descname">komeda_crtc</code><a class="headerlink" href="#c.komeda_crtc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_crtc {
    struct drm_crtc base;
    struct komeda_pipeline *master;
    struct komeda_pipeline *slave;
    u32 slave_planes;
    struct komeda_wb_connector *wb_conn;
    struct completion *disable_done;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master</span></code></dt><dd><p>only master has display output</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slave</span></code></dt><dd><p>optional</p>
<p>Doesn’t have its own display output, the handled data flow will
merge into the master.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slave_planes</span></code></dt><dd><p>komeda slave planes mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wb_conn</span></code></dt><dd><p>komeda write back connector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_done</span></code></dt><dd><p>this flip_done is for tracing the disable</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.komeda_crtc_state">
struct <code class="sig-name descname">komeda_crtc_state</code><a class="headerlink" href="#c.komeda_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct komeda_crtc_state {
    struct drm_crtc_state base;
    u32 affected_pipes;
    u32 active_pipes;
    u64 clock_ratio;
    u32 max_slave_zorder;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p><a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_crtc_state</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">affected_pipes</span></code></dt><dd><p>the affected pipelines in once display instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_pipes</span></code></dt><dd><p>the active pipelines in once display instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clock_ratio</span></code></dt><dd><p>ratio of (aclk &lt;&lt; 32)/pxlclk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_slave_zorder</span></code></dt><dd><p>the maximum of slave zorder</p>
</dd>
</dl>
</div>
</section>
<section id="komde-kms-functions">
<h3>komde_kms Functions<a class="headerlink" href="#komde-kms-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.komeda_crtc_atomic_check">
int <code class="sig-name descname">komeda_crtc_atomic_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a><em> *crtc</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.komeda_crtc_atomic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>build display output data flow</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*crtc</span></code></dt><dd><p>DRM crtc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>the crtc state object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>crtc_atomic_check is the final check stage, so beside build a display data
pipeline according to the crtc_state, but still needs to release or disable
the unclaimed pipeline resources.</p>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
</div>
<dl class="function">
<dt id="c.komeda_plane_atomic_check">
int <code class="sig-name descname">komeda_plane_atomic_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a><em> *plane</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.komeda_plane_atomic_check" title="Permalink to this definition">¶</a></dt>
<dd><p>build input data flow</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*plane</span></code></dt><dd><p>DRM plane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*state</span></code></dt><dd><p>the plane state object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero for success or -errno</p>
</div>
</section>
</section>
<section id="build-komeda-to-be-a-linux-module-driver">
<h2>Build komeda to be a Linux module driver<a class="headerlink" href="#build-komeda-to-be-a-linux-module-driver" title="Permalink to this headline">¶</a></h2>
<p>Now we have two level devices:</p>
<ul class="simple">
<li><p>komeda_dev: describes the real display hardware.</p></li>
<li><p>komeda_kms_dev: attachs or connects komeda_dev to DRM-KMS.</p></li>
</ul>
<p>All komeda operations are supplied or operated by komeda_dev or komeda_kms_dev,
the module driver is only a simple wrapper to pass the Linux command
(probe/remove/pm) into komeda_dev or komeda_kms_dev.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">drm/komeda Arm display driver</a><ul>
<li><a class="reference internal" href="#overview-of-d71-like-display-ips">Overview of D71 like display IPs</a><ul>
<li><a class="reference internal" href="#layer">Layer</a></li>
<li><a class="reference internal" href="#scaler">Scaler</a></li>
<li><a class="reference internal" href="#compositor-compiz">Compositor (compiz)</a></li>
<li><a class="reference internal" href="#writeback-layer-wb-layer">Writeback Layer (wb_layer)</a></li>
<li><a class="reference internal" href="#post-image-processor-improc">Post image processor (improc)</a></li>
<li><a class="reference internal" href="#timing-controller-timing-ctrlr">Timing controller (timing_ctrlr)</a></li>
<li><a class="reference internal" href="#merger">Merger</a></li>
<li><a class="reference internal" href="#splitter">Splitter</a></li>
</ul>
</li>
<li><a class="reference internal" href="#possible-d71-pipeline-usage">Possible D71 Pipeline usage</a><ul>
<li><a class="reference internal" href="#single-pipeline-data-flow">Single pipeline data flow</a></li>
<li><a class="reference internal" href="#dual-pipeline-with-slave-enabled">Dual pipeline with Slave enabled</a></li>
<li><a class="reference internal" href="#sub-pipelines-for-input-and-output">Sub-pipelines for input and output</a><ul>
<li><a class="reference internal" href="#layer-input-pipeline">Layer(input) pipeline</a></li>
<li><a class="reference internal" href="#writeback-output-pipeline">Writeback(output) pipeline</a></li>
<li><a class="reference internal" href="#display-output-pipeline">Display output pipeline</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#komeda-resource-abstraction">Komeda Resource abstraction</a><ul>
<li><a class="reference internal" href="#struct-komeda-pipeline-component">struct komeda_pipeline/component</a></li>
</ul>
</li>
<li><a class="reference internal" href="#resource-discovery-and-initialization">Resource discovery and initialization</a></li>
<li><a class="reference internal" href="#format-handling">Format handling</a></li>
<li><a class="reference internal" href="#attach-komeda-dev-to-drm-kms">Attach komeda_dev to DRM-KMS</a><ul>
<li><a class="reference internal" href="#how-to-map-plane-to-layer-input-pipeline">How to map plane to Layer(input) pipeline</a></li>
<li><a class="reference internal" href="#make-component-pipeline-to-be-drm-private-obj">Make component/pipeline to be drm_private_obj</a></li>
<li><a class="reference internal" href="#tracking-component-state-pipeline-state-by-drm-atomic-state">Tracking component_state/pipeline_state by drm_atomic_state</a></li>
<li><a class="reference internal" href="#komeda-component-validation">komeda component validation</a></li>
<li><a class="reference internal" href="#komeda-kms-abstraction">komeda_kms Abstraction</a></li>
<li><a class="reference internal" href="#komde-kms-functions">komde_kms Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-komeda-to-be-a-linux-module-driver">Build komeda to be a Linux module driver</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/gpu/komeda-kms.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/gpu/komeda-kms.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>