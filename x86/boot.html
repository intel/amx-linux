
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>1. The Linux/x86 Boot Protocol &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2. DeviceTree Booting" href="booting-dt.html" />
    <link rel="prev" title="x86-specific Documentation" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="the-linux-x86-boot-protocol">
<h1><span class="section-number">1. </span>The Linux/x86 Boot Protocol<a class="headerlink" href="#the-linux-x86-boot-protocol" title="Permalink to this headline">¶</a></h1>
<p>On the x86 platform, the Linux kernel uses a rather complicated boot
convention.  This has evolved partially due to historical aspects, as
well as the desire in the early days to have the kernel itself be a
bootable image, the complicated PC memory model and due to changed
expectations in the PC industry caused by the effective demise of
real-mode DOS as a mainstream operating system.</p>
<p>Currently, the following versions of the Linux/x86 boot protocol exist.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Old kernels</p></td>
<td><p>zImage/Image support only.  Some very early kernels
may not even support a command line.</p></td>
</tr>
<tr class="row-even"><td><p>Protocol 2.00</p></td>
<td><p>(Kernel 1.3.73) Added bzImage and initrd support, as
well as a formalized way to communicate between the
boot loader and the kernel.  setup.S made relocatable,
although the traditional setup area still assumed
writable.</p></td>
</tr>
<tr class="row-odd"><td><p>Protocol 2.01</p></td>
<td><p>(Kernel 1.3.76) Added a heap overrun warning.</p></td>
</tr>
<tr class="row-even"><td><p>Protocol 2.02</p></td>
<td><p>(Kernel 2.4.0-test3-pre3) New command line protocol.
Lower the conventional memory ceiling.  No overwrite
of the traditional setup area, thus making booting
safe for systems which use the EBDA from SMM or 32-bit
BIOS entry points.  zImage deprecated but still
supported.</p></td>
</tr>
<tr class="row-odd"><td><p>Protocol 2.03</p></td>
<td><p>(Kernel 2.4.18-pre1) Explicitly makes the highest possible
initrd address available to the bootloader.</p></td>
</tr>
<tr class="row-even"><td><p>Protocol 2.04</p></td>
<td><p>(Kernel 2.6.14) Extend the syssize field to four bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>Protocol 2.05</p></td>
<td><p>(Kernel 2.6.20) Make protected mode kernel relocatable.
Introduce relocatable_kernel and kernel_alignment fields.</p></td>
</tr>
<tr class="row-even"><td><p>Protocol 2.06</p></td>
<td><p>(Kernel 2.6.22) Added a field that contains the size of
the boot command line.</p></td>
</tr>
<tr class="row-odd"><td><p>Protocol 2.07</p></td>
<td><p>(Kernel 2.6.24) Added paravirtualised boot protocol.
Introduced hardware_subarch and hardware_subarch_data
and KEEP_SEGMENTS flag in load_flags.</p></td>
</tr>
<tr class="row-even"><td><p>Protocol 2.08</p></td>
<td><p>(Kernel 2.6.26) Added crc32 checksum and ELF format
payload. Introduced payload_offset and payload_length
fields to aid in locating the payload.</p></td>
</tr>
<tr class="row-odd"><td><p>Protocol 2.09</p></td>
<td><p>(Kernel 2.6.26) Added a field of 64-bit physical
pointer to single linked list of struct setup_data.</p></td>
</tr>
<tr class="row-even"><td><p>Protocol 2.10</p></td>
<td><p>(Kernel 2.6.31) Added a protocol for relaxed alignment
beyond the kernel_alignment added, new init_size and
pref_address fields.  Added extended boot loader IDs.</p></td>
</tr>
<tr class="row-odd"><td><p>Protocol 2.11</p></td>
<td><p>(Kernel 3.6) Added a field for offset of EFI handover
protocol entry point.</p></td>
</tr>
<tr class="row-even"><td><p>Protocol 2.12</p></td>
<td><p>(Kernel 3.8) Added the xloadflags field and extension fields
to struct boot_params for loading bzImage and ramdisk
above 4G in 64bit.</p></td>
</tr>
<tr class="row-odd"><td><p>Protocol 2.13</p></td>
<td><p>(Kernel 3.14) Support 32- and 64-bit flags being set in
xloadflags to support booting a 64-bit kernel from 32-bit
EFI</p></td>
</tr>
<tr class="row-even"><td><p>Protocol 2.14</p></td>
<td><p>BURNT BY INCORRECT COMMIT
ae7e1238e68f2a472a125673ab506d49158c1889
(x86/boot: Add ACPI RSDP address to setup_header)
DO NOT USE!!! ASSUME SAME AS 2.13.</p></td>
</tr>
<tr class="row-odd"><td><p>Protocol 2.15</p></td>
<td><p>(Kernel 5.5) Added the kernel_info and kernel_info.setup_type_max.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The protocol version number should be changed only if the setup header
is changed. There is no need to update the version number if boot_params
or kernel_info are changed. Additionally, it is recommended to use
xloadflags (in this case the protocol version number should not be
updated either) or kernel_info to communicate supported Linux kernel
features to the boot loader. Due to very limited space available in
the original setup header every update to it should be considered
with great care. Starting from the protocol 2.15 the primary way to
communicate things to the boot loader is the kernel_info.</p>
</div>
<section id="memory-layout">
<h2><span class="section-number">1.1. </span>Memory Layout<a class="headerlink" href="#memory-layout" title="Permalink to this headline">¶</a></h2>
<p>The traditional memory map for the kernel loader, used for Image or
zImage kernels, typically looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        |                        |
0A0000  +------------------------+
        |  Reserved for BIOS     |      Do not use.  Reserved for BIOS EBDA.
09A000  +------------------------+
        |  Command line          |
        |  Stack/heap            |      For use by the kernel real-mode code.
098000  +------------------------+
        |  Kernel setup          |      The kernel real-mode code.
090200  +------------------------+
        |  Kernel boot sector    |      The kernel legacy boot sector.
090000  +------------------------+
        |  Protected-mode kernel |      The bulk of the kernel image.
010000  +------------------------+
        |  Boot loader           |      &lt;- Boot sector entry point 0000:7C00
001000  +------------------------+
        |  Reserved for MBR/BIOS |
000800  +------------------------+
        |  Typically used by MBR |
000600  +------------------------+
        |  BIOS use only         |
000000  +------------------------+
</pre></div>
</div>
<p>When using bzImage, the protected-mode kernel was relocated to
0x100000 (“high memory”), and the kernel real-mode block (boot sector,
setup, and stack/heap) was made relocatable to any address between
0x10000 and end of low memory. Unfortunately, in protocols 2.00 and
2.01 the 0x90000+ memory range is still used internally by the kernel;
the 2.02 protocol resolves that problem.</p>
<p>It is desirable to keep the “memory ceiling” – the highest point in
low memory touched by the boot loader – as low as possible, since
some newer BIOSes have begun to allocate some rather large amounts of
memory, called the Extended BIOS Data Area, near the top of low
memory.  The boot loader should use the “INT 12h” BIOS call to verify
how much low memory is available.</p>
<p>Unfortunately, if INT 12h reports that the amount of memory is too
low, there is usually nothing the boot loader can do but to report an
error to the user.  The boot loader should therefore be designed to
take up as little space in low memory as it reasonably can.  For
zImage or old bzImage kernels, which need data written into the
0x90000 segment, the boot loader should make sure not to use memory
above the 0x9A000 point; too many BIOSes will break above that point.</p>
<p>For a modern bzImage kernel with boot protocol version &gt;= 2.02, a
memory layout like the following is suggested:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>              ~                        ~
              |  Protected-mode kernel |
      100000  +------------------------+
              |  I/O memory hole       |
      0A0000  +------------------------+
              |  Reserved for BIOS     |      Leave as much as possible unused
              ~                        ~
              |  Command line          |      (Can also be below the X+10000 mark)
      X+10000 +------------------------+
              |  Stack/heap            |      For use by the kernel real-mode code.
      X+08000 +------------------------+
              |  Kernel setup          |      The kernel real-mode code.
              |  Kernel boot sector    |      The kernel legacy boot sector.
      X       +------------------------+
              |  Boot loader           |      &lt;- Boot sector entry point 0000:7C00
      001000  +------------------------+
              |  Reserved for MBR/BIOS |
      000800  +------------------------+
              |  Typically used by MBR |
      000600  +------------------------+
              |  BIOS use only         |
      000000  +------------------------+

... where the address X is as low as the design of the boot loader permits.
</pre></div>
</div>
</section>
<section id="the-real-mode-kernel-header">
<h2><span class="section-number">1.2. </span>The Real-Mode Kernel Header<a class="headerlink" href="#the-real-mode-kernel-header" title="Permalink to this headline">¶</a></h2>
<p>In the following text, and anywhere in the kernel boot sequence, “a
sector” refers to 512 bytes.  It is independent of the actual sector
size of the underlying medium.</p>
<p>The first step in loading a Linux kernel should be to load the
real-mode code (boot sector and setup code) and then examine the
following header at offset 0x01f1.  The real-mode code can total up to
32K, although the boot loader may choose to load only the first two
sectors (1K) and then examine the bootup sector size.</p>
<p>The header looks like:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 25%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset/Size</p></th>
<th class="head"><p>Proto</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>01F1/1</p></td>
<td><p>ALL(1)</p></td>
<td><p>setup_sects</p></td>
<td><p>The size of the setup in sectors</p></td>
</tr>
<tr class="row-odd"><td><p>01F2/2</p></td>
<td><p>ALL</p></td>
<td><p>root_flags</p></td>
<td><p>If set, the root is mounted readonly</p></td>
</tr>
<tr class="row-even"><td><p>01F4/4</p></td>
<td><p>2.04+(2)</p></td>
<td><p>syssize</p></td>
<td><p>The size of the 32-bit code in 16-byte paras</p></td>
</tr>
<tr class="row-odd"><td><p>01F8/2</p></td>
<td><p>ALL</p></td>
<td><p>ram_size</p></td>
<td><p>DO NOT USE - for bootsect.S use only</p></td>
</tr>
<tr class="row-even"><td><p>01FA/2</p></td>
<td><p>ALL</p></td>
<td><p>vid_mode</p></td>
<td><p>Video mode control</p></td>
</tr>
<tr class="row-odd"><td><p>01FC/2</p></td>
<td><p>ALL</p></td>
<td><p>root_dev</p></td>
<td><p>Default root device number</p></td>
</tr>
<tr class="row-even"><td><p>01FE/2</p></td>
<td><p>ALL</p></td>
<td><p>boot_flag</p></td>
<td><p>0xAA55 magic number</p></td>
</tr>
<tr class="row-odd"><td><p>0200/2</p></td>
<td><p>2.00+</p></td>
<td><p>jump</p></td>
<td><p>Jump instruction</p></td>
</tr>
<tr class="row-even"><td><p>0202/4</p></td>
<td><p>2.00+</p></td>
<td><p>header</p></td>
<td><p>Magic signature “HdrS”</p></td>
</tr>
<tr class="row-odd"><td><p>0206/2</p></td>
<td><p>2.00+</p></td>
<td><p>version</p></td>
<td><p>Boot protocol version supported</p></td>
</tr>
<tr class="row-even"><td><p>0208/4</p></td>
<td><p>2.00+</p></td>
<td><p>realmode_swtch</p></td>
<td><p>Boot loader hook (see below)</p></td>
</tr>
<tr class="row-odd"><td><p>020C/2</p></td>
<td><p>2.00+</p></td>
<td><p>start_sys_seg</p></td>
<td><p>The load-low segment (0x1000) (obsolete)</p></td>
</tr>
<tr class="row-even"><td><p>020E/2</p></td>
<td><p>2.00+</p></td>
<td><p>kernel_version</p></td>
<td><p>Pointer to kernel version string</p></td>
</tr>
<tr class="row-odd"><td><p>0210/1</p></td>
<td><p>2.00+</p></td>
<td><p>type_of_loader</p></td>
<td><p>Boot loader identifier</p></td>
</tr>
<tr class="row-even"><td><p>0211/1</p></td>
<td><p>2.00+</p></td>
<td><p>loadflags</p></td>
<td><p>Boot protocol option flags</p></td>
</tr>
<tr class="row-odd"><td><p>0212/2</p></td>
<td><p>2.00+</p></td>
<td><p>setup_move_size</p></td>
<td><p>Move to high memory size (used with hooks)</p></td>
</tr>
<tr class="row-even"><td><p>0214/4</p></td>
<td><p>2.00+</p></td>
<td><p>code32_start</p></td>
<td><p>Boot loader hook (see below)</p></td>
</tr>
<tr class="row-odd"><td><p>0218/4</p></td>
<td><p>2.00+</p></td>
<td><p>ramdisk_image</p></td>
<td><p>initrd load address (set by boot loader)</p></td>
</tr>
<tr class="row-even"><td><p>021C/4</p></td>
<td><p>2.00+</p></td>
<td><p>ramdisk_size</p></td>
<td><p>initrd size (set by boot loader)</p></td>
</tr>
<tr class="row-odd"><td><p>0220/4</p></td>
<td><p>2.00+</p></td>
<td><p>bootsect_kludge</p></td>
<td><p>DO NOT USE - for bootsect.S use only</p></td>
</tr>
<tr class="row-even"><td><p>0224/2</p></td>
<td><p>2.01+</p></td>
<td><p>heap_end_ptr</p></td>
<td><p>Free memory after setup end</p></td>
</tr>
<tr class="row-odd"><td><p>0226/1</p></td>
<td><p>2.02+(3)</p></td>
<td><p>ext_loader_ver</p></td>
<td><p>Extended boot loader version</p></td>
</tr>
<tr class="row-even"><td><p>0227/1</p></td>
<td><p>2.02+(3)</p></td>
<td><p>ext_loader_type</p></td>
<td><p>Extended boot loader ID</p></td>
</tr>
<tr class="row-odd"><td><p>0228/4</p></td>
<td><p>2.02+</p></td>
<td><p>cmd_line_ptr</p></td>
<td><p>32-bit pointer to the kernel command line</p></td>
</tr>
<tr class="row-even"><td><p>022C/4</p></td>
<td><p>2.03+</p></td>
<td><p>initrd_addr_max</p></td>
<td><p>Highest legal initrd address</p></td>
</tr>
<tr class="row-odd"><td><p>0230/4</p></td>
<td><p>2.05+</p></td>
<td><p>kernel_alignment</p></td>
<td><p>Physical addr alignment required for kernel</p></td>
</tr>
<tr class="row-even"><td><p>0234/1</p></td>
<td><p>2.05+</p></td>
<td><p>relocatable_kernel</p></td>
<td><p>Whether kernel is relocatable or not</p></td>
</tr>
<tr class="row-odd"><td><p>0235/1</p></td>
<td><p>2.10+</p></td>
<td><p>min_alignment</p></td>
<td><p>Minimum alignment, as a power of two</p></td>
</tr>
<tr class="row-even"><td><p>0236/2</p></td>
<td><p>2.12+</p></td>
<td><p>xloadflags</p></td>
<td><p>Boot protocol option flags</p></td>
</tr>
<tr class="row-odd"><td><p>0238/4</p></td>
<td><p>2.06+</p></td>
<td><p>cmdline_size</p></td>
<td><p>Maximum size of the kernel command line</p></td>
</tr>
<tr class="row-even"><td><p>023C/4</p></td>
<td><p>2.07+</p></td>
<td><p>hardware_subarch</p></td>
<td><p>Hardware subarchitecture</p></td>
</tr>
<tr class="row-odd"><td><p>0240/8</p></td>
<td><p>2.07+</p></td>
<td><p>hardware_subarch_data</p></td>
<td><p>Subarchitecture-specific data</p></td>
</tr>
<tr class="row-even"><td><p>0248/4</p></td>
<td><p>2.08+</p></td>
<td><p>payload_offset</p></td>
<td><p>Offset of kernel payload</p></td>
</tr>
<tr class="row-odd"><td><p>024C/4</p></td>
<td><p>2.08+</p></td>
<td><p>payload_length</p></td>
<td><p>Length of kernel payload</p></td>
</tr>
<tr class="row-even"><td><p>0250/8</p></td>
<td><p>2.09+</p></td>
<td><p>setup_data</p></td>
<td><p>64-bit physical pointer to linked list
of struct setup_data</p></td>
</tr>
<tr class="row-odd"><td><p>0258/8</p></td>
<td><p>2.10+</p></td>
<td><p>pref_address</p></td>
<td><p>Preferred loading address</p></td>
</tr>
<tr class="row-even"><td><p>0260/4</p></td>
<td><p>2.10+</p></td>
<td><p>init_size</p></td>
<td><p>Linear memory required during initialization</p></td>
</tr>
<tr class="row-odd"><td><p>0264/4</p></td>
<td><p>2.11+</p></td>
<td><p>handover_offset</p></td>
<td><p>Offset of handover entry point</p></td>
</tr>
<tr class="row-even"><td><p>0268/4</p></td>
<td><p>2.15+</p></td>
<td><p>kernel_info_offset</p></td>
<td><p>Offset of the kernel_info</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>For backwards compatibility, if the setup_sects field contains 0, the
real value is 4.</p></li>
<li><p>For boot protocol prior to 2.04, the upper two bytes of the syssize
field are unusable, which means the size of a bzImage kernel
cannot be determined.</p></li>
<li><p>Ignored, but safe to set, for boot protocols 2.02-2.09.</p></li>
</ol>
</div>
<p>If the “HdrS” (0x53726448) magic number is not found at offset 0x202,
the boot protocol version is “old”.  Loading an old kernel, the
following parameters should be assumed:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Image type = zImage
initrd not supported
Real-mode kernel must be located at 0x90000.
</pre></div>
</div>
<p>Otherwise, the “version” field contains the protocol version,
e.g. protocol version 2.01 will contain 0x0201 in this field.  When
setting fields in the header, you must make sure only to set fields
supported by the protocol version in use.</p>
</section>
<section id="details-of-header-fields">
<h2><span class="section-number">1.3. </span>Details of Header Fields<a class="headerlink" href="#details-of-header-fields" title="Permalink to this headline">¶</a></h2>
<p>For each field, some are information from the kernel to the bootloader
(“read”), some are expected to be filled out by the bootloader
(“write”), and some are expected to be read and modified by the
bootloader (“modify”).</p>
<p>All general purpose boot loaders should write the fields marked
(obligatory).  Boot loaders who want to load the kernel at a
nonstandard address should fill in the fields marked (reloc); other
boot loaders can ignore those fields.</p>
<p>The byte order of all fields is littleendian (this is x86, after all.)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 52%" />
<col style="width: 48%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>setup_sects</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x1f1/1</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>ALL</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>The size of the setup code in 512-byte sectors.  If this field is
0, the real value is 4.  The real-mode code consists of the boot
sector (always one 512-byte sector) plus the setup code.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>root_flags</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>modify (optional)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x1f2/2</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>ALL</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>If this field is nonzero, the root defaults to readonly.  The use of
this field is deprecated; use the “ro” or “rw” options on the
command line instead.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>syssize</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x1f4/4 (protocol 2.04+) 0x1f4/2 (protocol ALL)</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.04+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>The size of the protected-mode code in units of 16-byte paragraphs.
For protocol versions older than 2.04 this field is only two bytes
wide, and therefore cannot be trusted for the size of a kernel if
the LOAD_HIGH flag is set.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>ram_size</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>kernel internal</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x1f8/2</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>ALL</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field is obsolete.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 39%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>vid_mode</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>modify (obligatory)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x1fa/2</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Please see the section on SPECIAL COMMAND LINE OPTIONS.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>root_dev</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>modify (optional)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x1fc/2</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>ALL</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>The default root device device number.  The use of this field is
deprecated, use the “root=” option on the command line instead.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 57%" />
<col style="width: 43%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>boot_flag</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x1fe/2</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>ALL</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Contains 0xAA55.  This is the closest thing old Linux kernels have
to a magic number.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 63%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>jump</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x200/2</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Contains an x86 jump instruction, 0xEB followed by a signed offset
relative to byte 0x202.  This can be used to determine the size of
the header.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 63%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>header</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x202/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Contains the magic number “HdrS” (0x53726448).</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 63%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>version</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x206/2</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Contains the boot protocol version, in (major &lt;&lt; 8)+minor format,
e.g. 0x0204 for version 2.04, and 0x0a11 for a hypothetical version
10.17.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>realmode_swtch</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>modify (optional)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x208/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Boot loader hook (see ADVANCED BOOT LOADER HOOKS below.)</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 52%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>start_sys_seg</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x20c/2</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>The load low segment (0x1000).  Obsolete.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 54%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>kernel_version</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x20e/2</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>If set to a nonzero value, contains a pointer to a NUL-terminated
human-readable kernel version number string, less 0x200.  This can
be used to display the kernel version to the user.  This value
should be less than (0x200*setup_sects).</p>
<p>For example, if this value is set to 0x1c00, the kernel version
number string can be found at offset 0x1e00 in the kernel file.
This is a valid value if and only if the “setup_sects” field
contains the value 15 or higher, as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x1c00  &lt; 15*0x200 (= 0x1e00) but
0x1c00 &gt;= 14*0x200 (= 0x1c00)

0x1c00 &gt;&gt; 9 = 14, So the minimum value for setup_secs is 15.
</pre></div>
</div>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>type_of_loader</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>write (obligatory)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x210/1</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>If your boot loader has an assigned id (see table below), enter
0xTV here, where T is an identifier for the boot loader and V is
a version number.  Otherwise, enter 0xFF here.</p>
<p>For boot loader IDs above T = 0xD, write T = 0xE to this field and
write the extended ID minus 0x10 to the ext_loader_type field.
Similarly, the ext_loader_ver field can be used to provide more than
four bits for the bootloader version.</p>
<p>For example, for T = 0x15, V = 0x234, write:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>type_of_loader  &lt;- 0xE4
ext_loader_type &lt;- 0x05
ext_loader_ver  &lt;- 0x23
</pre></div>
</div>
<p>Assigned boot loader ids (hexadecimal):</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 5%" />
<col style="width: 95%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>LILO
(0x00 reserved for pre-2.00 bootloader)</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>Loadlin</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>bootsect-loader
(0x20, all other values reserved)</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Syslinux</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>Etherboot/gPXE/iPXE</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>ELILO</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>GRUB</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>U-Boot</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>Xen</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>Gujin</p></td>
</tr>
<tr class="row-odd"><td><p>B</p></td>
<td><p>Qemu</p></td>
</tr>
<tr class="row-even"><td><p>C</p></td>
<td><p>Arcturus Networks uCbootloader</p></td>
</tr>
<tr class="row-odd"><td><p>D</p></td>
<td><p>kexec-tools</p></td>
</tr>
<tr class="row-even"><td><p>E</p></td>
<td><p>Extended (see ext_loader_type)</p></td>
</tr>
<tr class="row-odd"><td><p>F</p></td>
<td><p>Special (0xFF = undefined)</p></td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-odd"><td><p>11</p></td>
<td><p>Minimal Linux Bootloader
&lt;<a class="reference external" href="http://sebastian-plotz.blogspot.de">http://sebastian-plotz.blogspot.de</a>&gt;</p></td>
</tr>
<tr class="row-even"><td><p>12</p></td>
<td><p>OVMF UEFI virtualization stack</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>barebox</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Please contact &lt;<a class="reference external" href="mailto:hpa&#37;&#52;&#48;zytor&#46;com">hpa<span>&#64;</span>zytor<span>&#46;</span>com</a>&gt; if you need a bootloader ID value assigned.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 39%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>loadflags</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>modify (obligatory)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x211/1</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field is a bitmask.</p>
<p>Bit 0 (read): LOADED_HIGH</p>
<blockquote>
<div><ul class="simple">
<li><p>If 0, the protected-mode code is loaded at 0x10000.</p></li>
<li><p>If 1, the protected-mode code is loaded at 0x100000.</p></li>
</ul>
</div></blockquote>
<p>Bit 1 (kernel internal): KASLR_FLAG</p>
<blockquote>
<div><ul>
<li><p>Used internally by the compressed kernel to communicate
KASLR status to kernel proper.</p>
<blockquote>
<div><ul class="simple">
<li><p>If 1, KASLR enabled.</p></li>
<li><p>If 0, KASLR disabled.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>Bit 5 (write): QUIET_FLAG</p>
<blockquote>
<div><ul>
<li><p>If 0, print early messages.</p></li>
<li><p>If 1, suppress early messages.</p>
<blockquote>
<div><p>This requests to the kernel (decompressor and early
kernel) to not write early messages that require
accessing the display hardware directly.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>Bit 6 (obsolete): KEEP_SEGMENTS</p>
<blockquote>
<div><p>Protocol: 2.07+</p>
<ul class="simple">
<li><p>This flag is obsolete.</p></li>
</ul>
</div></blockquote>
<p>Bit 7 (write): CAN_USE_HEAP</p>
<blockquote>
<div><p>Set this bit to 1 to indicate that the value entered in the
heap_end_ptr is valid.  If this field is clear, some setup code
functionality will be disabled.</p>
</div></blockquote>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 39%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>setup_move_size</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>modify (obligatory)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x212/2</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00-2.01</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>When using protocol 2.00 or 2.01, if the real mode kernel is not
loaded at 0x90000, it gets moved there later in the loading
sequence.  Fill in this field if you want additional data (such as
the kernel command line) moved in addition to the real-mode kernel
itself.</p>
<p>The unit is bytes starting with the beginning of the boot sector.</p>
<p>This field is can be ignored when the protocol is 2.02 or higher, or
if the real-mode code is loaded at 0x90000.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>code32_start</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>modify (optional, reloc)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x214/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>The address to jump to in protected mode.  This defaults to the load
address of the kernel, and can be used by the boot loader to
determine the proper load address.</p>
<p>This field can be modified for two purposes:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>as a boot loader hook (see Advanced Boot Loader Hooks below.)</p></li>
<li><p>if a bootloader which does not install a hook loads a
relocatable kernel at a nonstandard address it will have to modify
this field to point to the load address.</p></li>
</ol>
</div></blockquote>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>ramdisk_image</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>write (obligatory)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x218/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>The 32-bit linear address of the initial ramdisk or ramfs.  Leave at
zero if there is no initial ramdisk/ramfs.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>ramdisk_size</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>write (obligatory)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x21c/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Size of the initial ramdisk or ramfs.  Leave at zero if there is no
initial ramdisk/ramfs.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>bootsect_kludge</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>kernel internal</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x220/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.00+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field is obsolete.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>heap_end_ptr</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>write (obligatory)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x224/2</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.01+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Set this field to the offset (from the beginning of the real-mode
code) of the end of the setup stack/heap, minus 0x0200.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>ext_loader_ver</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>write (optional)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x226/1</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.02+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field is used as an extension of the version number in the
type_of_loader field.  The total version number is considered to be
(type_of_loader &amp; 0x0f) + (ext_loader_ver &lt;&lt; 4).</p>
<p>The use of this field is boot loader specific.  If not written, it
is zero.</p>
<p>Kernels prior to 2.6.31 did not recognize this field, but it is safe
to write for protocol version 2.02 or higher.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>ext_loader_type</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>write (obligatory if (type_of_loader &amp; 0xf0) == 0xe0)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x227/1</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.02+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field is used as an extension of the type number in
type_of_loader field.  If the type in type_of_loader is 0xE, then
the actual type is (ext_loader_type + 0x10).</p>
<p>This field is ignored if the type in type_of_loader is not 0xE.</p>
<p>Kernels prior to 2.6.31 did not recognize this field, but it is safe
to write for protocol version 2.02 or higher.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>cmd_line_ptr</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>write (obligatory)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x228/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.02+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Set this field to the linear address of the kernel command line.
The kernel command line can be located anywhere between the end of
the setup heap and 0xA0000; it does not have to be located in the
same 64K segment as the real-mode code itself.</p>
<p>Fill in this field even if your boot loader does not support a
command line, in which case you can point this to an empty string
(or better yet, to the string “auto”.)  If this field is left at
zero, the kernel will assume that your boot loader does not support
the 2.02+ protocol.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>initrd_addr_max</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x22c/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.03+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>The maximum address that may be occupied by the initial
ramdisk/ramfs contents.  For boot protocols 2.02 or earlier, this
field is not present, and the maximum address is 0x37FFFFFF.  (This
address is defined as the address of the highest safe byte, so if
your ramdisk is exactly 131072 bytes long and this field is
0x37FFFFFF, you can start your ramdisk at 0x37FE0000.)</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>kernel_alignment</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read/modify (reloc)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x230/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.05+ (read), 2.10+ (modify)</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Alignment unit required by the kernel (if relocatable_kernel is
true.)  A relocatable kernel that is loaded at an alignment
incompatible with the value in this field will be realigned during
kernel initialization.</p>
<p>Starting with protocol version 2.10, this reflects the kernel
alignment preferred for optimal performance; it is possible for the
loader to modify this field to permit a lesser alignment.  See the
min_alignment and pref_address field below.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>relocatable_kernel</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read (reloc)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x234/1</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.05+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>If this field is nonzero, the protected-mode part of the kernel can
be loaded at any address that satisfies the kernel_alignment field.
After loading, the boot loader must set the code32_start field to
point to the loaded code, or to a boot loader hook.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 52%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>min_alignment</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read (reloc)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x235/1</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.10+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field, if nonzero, indicates as a power of two the minimum
alignment required, as opposed to preferred, by the kernel to boot.
If a boot loader makes use of this field, it should update the
kernel_alignment field with the alignment unit desired; typically:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kernel_alignment = 1 &lt;&lt; min_alignment
</pre></div>
</div>
<p>There may be a considerable performance cost with an excessively
misaligned kernel.  Therefore, a loader should typically try each
power-of-two alignment from kernel_alignment down to this alignment.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>xloadflags</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x236/2</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.12+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field is a bitmask.</p>
<p>Bit 0 (read): XLF_KERNEL_64</p>
<blockquote>
<div><ul class="simple">
<li><p>If 1, this kernel has the legacy 64-bit entry point at 0x200.</p></li>
</ul>
</div></blockquote>
<p>Bit 1 (read): XLF_CAN_BE_LOADED_ABOVE_4G</p>
<blockquote>
<div><ul class="simple">
<li><p>If 1, kernel/boot_params/cmdline/ramdisk can be above 4G.</p></li>
</ul>
</div></blockquote>
<p>Bit 2 (read): XLF_EFI_HANDOVER_32</p>
<blockquote>
<div><ul class="simple">
<li><p>If 1, the kernel supports the 32-bit EFI handoff entry point
given at handover_offset.</p></li>
</ul>
</div></blockquote>
<p>Bit 3 (read): XLF_EFI_HANDOVER_64</p>
<blockquote>
<div><ul class="simple">
<li><p>If 1, the kernel supports the 64-bit EFI handoff entry point
given at handover_offset + 0x200.</p></li>
</ul>
</div></blockquote>
<p>Bit 4 (read): XLF_EFI_KEXEC</p>
<blockquote>
<div><ul class="simple">
<li><p>If 1, the kernel supports kexec EFI boot with EFI runtime support.</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>cmdline_size</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x238/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.06+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>The maximum size of the command line without the terminating
zero. This means that the command line can contain at most
cmdline_size characters. With protocol version 2.05 and earlier, the
maximum size was 255.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>hardware_subarch</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>write (optional, defaults to x86/PC)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x23c/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.07+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>In a paravirtualized environment the hardware low level architectural
pieces such as interrupt handling, page table handling, and
accessing process control registers needs to be done differently.</p>
<p>This field allows the bootloader to inform the kernel we are in one
one of those environments.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0x00000000</p></td>
<td><p>The default x86/PC environment</p></td>
</tr>
<tr class="row-even"><td><p>0x00000001</p></td>
<td><p>lguest</p></td>
</tr>
<tr class="row-odd"><td><p>0x00000002</p></td>
<td><p>Xen</p></td>
</tr>
<tr class="row-even"><td><p>0x00000003</p></td>
<td><p>Moorestown MID</p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p>CE4100 TV Platform</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>hardware_subarch_data</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>write (subarch-dependent)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x240/8</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.07+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>A pointer to data that is specific to hardware subarch
This field is currently unused for the default x86/PC environment,
do not modify.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 54%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>payload_offset</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x248/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.08+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>If non-zero then this field contains the offset from the beginning
of the protected-mode code to the payload.</p>
<p>The payload may be compressed. The format of both the compressed and
uncompressed data should be determined using the standard magic
numbers.  The currently supported compression formats are gzip
(magic numbers 1F 8B or 1F 9E), bzip2 (magic number 42 5A), LZMA
(magic number 5D 00), XZ (magic number FD 37), LZ4 (magic number
02 21) and ZSTD (magic number 28 B5). The uncompressed payload is
currently always ELF (magic number 7F 45 4C 46).</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 54%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>payload_length</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x24c/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.08+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>The length of the payload.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>setup_data</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>write (special)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x250/8</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.09+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>The 64-bit physical pointer to NULL terminated single linked list of
struct setup_data. This is used to define a more extensible boot
parameters passing mechanism. The definition of struct setup_data is
as follow:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct setup_data {
        u64 next;
        u32 type;
        u32 len;
        u8  data[0];
};
</pre></div>
</div>
<p>Where, the next is a 64-bit physical pointer to the next node of
linked list, the next field of the last node is 0; the type is used
to identify the contents of data; the len is the length of data
field; the data holds the real payload.</p>
<p>This list may be modified at a number of points during the bootup
process.  Therefore, when modifying this list one should always make
sure to consider the case where the linked list already contains
entries.</p>
<p>The setup_data is a bit awkward to use for extremely large data objects,
both because the setup_data header has to be adjacent to the data object
and because it has a 32-bit length field. However, it is important that
intermediate stages of the boot process have a way to identify which
chunks of memory are occupied by kernel data.</p>
<p>Thus setup_indirect struct and SETUP_INDIRECT type were introduced in
protocol 2.15:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct setup_indirect {
  __u32 type;
  __u32 reserved;  /* Reserved, must be set to zero. */
  __u64 len;
  __u64 addr;
};
</pre></div>
</div>
<p>The type member is a SETUP_INDIRECT | SETUP_* type. However, it cannot be
SETUP_INDIRECT itself since making the setup_indirect a tree structure
could require a lot of stack space in something that needs to parse it
and stack space can be limited in boot contexts.</p>
<p>Let’s give an example how to point to SETUP_E820_EXT data using setup_indirect.
In this case setup_data and setup_indirect will look like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct setup_data {
  __u64 next = 0 or &lt;addr_of_next_setup_data_struct&gt;;
  __u32 type = SETUP_INDIRECT;
  __u32 len = sizeof(setup_indirect);
  __u8 data[sizeof(setup_indirect)] = struct setup_indirect {
    __u32 type = SETUP_INDIRECT | SETUP_E820_EXT;
    __u32 reserved = 0;
    __u64 len = &lt;len_of_SETUP_E820_EXT_data&gt;;
    __u64 addr = &lt;addr_of_SETUP_E820_EXT_data&gt;;
  }
}
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>SETUP_INDIRECT | SETUP_NONE objects cannot be properly distinguished
from SETUP_INDIRECT itself. So, this kind of objects cannot be provided
by the bootloaders.</p>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>pref_address</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read (reloc)</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x258/8</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.10+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field, if nonzero, represents a preferred load address for the
kernel.  A relocating bootloader should attempt to load at this
address if possible.</p>
<p>A non-relocatable kernel will unconditionally move itself and to run
at this address.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 57%" />
<col style="width: 43%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>init_size</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x260/4</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field indicates the amount of linear contiguous memory starting
at the kernel runtime start address that the kernel needs before it
is capable of examining its memory map.  This is not the same thing
as the total amount of memory the kernel needs to boot, but it can
be used by a relocating boot loader to help select a safe load
address for the kernel.</p>
<p>The kernel runtime start address is determined by the following algorithm:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (relocatable_kernel)
runtime_start = align_up(load_address, kernel_alignment)
else
runtime_start = pref_address
</pre></div>
</div>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>handover_offset</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x264/4</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field is the offset from the beginning of the kernel image to
the EFI handover protocol entry point. Boot loaders using the EFI
handover protocol to boot the kernel should jump to this offset.</p>
<p>See EFI HANDOVER PROTOCOL below for more details.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>kernel_info_offset</p></td>
</tr>
<tr class="row-even"><td><p>Type:</p></td>
<td><p>read</p></td>
</tr>
<tr class="row-odd"><td><p>Offset/size:</p></td>
<td><p>0x268/4</p></td>
</tr>
<tr class="row-even"><td><p>Protocol:</p></td>
<td><p>2.15+</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field is the offset from the beginning of the kernel image to the
kernel_info. The kernel_info structure is embedded in the Linux image
in the uncompressed protected mode region.</p>
</div></blockquote>
</section>
<section id="the-kernel-info">
<h2><span class="section-number">1.4. </span>The kernel_info<a class="headerlink" href="#the-kernel-info" title="Permalink to this headline">¶</a></h2>
<p>The relationships between the headers are analogous to the various data
sections:</p>
<blockquote>
<div><p>setup_header = .data
boot_params/setup_data = .bss</p>
</div></blockquote>
<p>What is missing from the above list? That’s right:</p>
<blockquote>
<div><p>kernel_info = .rodata</p>
</div></blockquote>
<p>We have been (ab)using .data for things that could go into .rodata or .bss for
a long time, for lack of alternatives and – especially early on – inertia.
Also, the BIOS stub is responsible for creating boot_params, so it isn’t
available to a BIOS-based loader (setup_data is, though).</p>
<p>setup_header is permanently limited to 144 bytes due to the reach of the
2-byte jump field, which doubles as a length field for the structure, combined
with the size of the “hole” in struct boot_params that a protected-mode loader
or the BIOS stub has to copy it into. It is currently 119 bytes long, which
leaves us with 25 very precious bytes. This isn’t something that can be fixed
without revising the boot protocol entirely, breaking backwards compatibility.</p>
<p>boot_params proper is limited to 4096 bytes, but can be arbitrarily extended
by adding setup_data entries. It cannot be used to communicate properties of
the kernel image, because it is .bss and has no image-provided content.</p>
<p>kernel_info solves this by providing an extensible place for information about
the kernel image. It is readonly, because the kernel cannot rely on a
bootloader copying its contents anywhere, but that is OK; if it becomes
necessary it can still contain data items that an enabled bootloader would be
expected to copy into a setup_data chunk.</p>
<p>All kernel_info data should be part of this structure. Fixed size data have to
be put before kernel_info_var_len_data label. Variable size data have to be put
after kernel_info_var_len_data label. Each chunk of variable size data has to
be prefixed with header/magic and its size, e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kernel_info:
        .ascii  &quot;LToP&quot;          /* Header, Linux top (structure). */
        .long   kernel_info_var_len_data - kernel_info
        .long   kernel_info_end - kernel_info
        .long   0x01234567      /* Some fixed size data for the bootloaders. */
kernel_info_var_len_data:
example_struct:                 /* Some variable size data for the bootloaders. */
        .ascii  &quot;0123&quot;          /* Header/Magic. */
        .long   example_struct_end - example_struct
        .ascii  &quot;Struct&quot;
        .long   0x89012345
example_struct_end:
example_strings:                /* Some variable size data for the bootloaders. */
        .ascii  &quot;ABCD&quot;          /* Header/Magic. */
        .long   example_strings_end - example_strings
        .asciz  &quot;String_0&quot;
        .asciz  &quot;String_1&quot;
example_strings_end:
kernel_info_end:
</pre></div>
</div>
<p>This way the kernel_info is self-contained blob.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each variable size data header/magic can be any 4-character string,
without 0 at the end of the string, which does not collide with
existing variable length data headers/magics.</p>
</div>
</section>
<section id="details-of-the-kernel-info-fields">
<h2><span class="section-number">1.5. </span>Details of the kernel_info Fields<a class="headerlink" href="#details-of-the-kernel-info-fields" title="Permalink to this headline">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 60%" />
<col style="width: 40%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>header</p></td>
</tr>
<tr class="row-even"><td><p>Offset/size:</p></td>
<td><p>0x0000/4</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Contains the magic number “LToP” (0x506f544c).</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 60%" />
<col style="width: 40%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>size</p></td>
</tr>
<tr class="row-even"><td><p>Offset/size:</p></td>
<td><p>0x0004/4</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field contains the size of the kernel_info including kernel_info.header.
It does not count kernel_info.kernel_info_var_len_data size. This field should be
used by the bootloaders to detect supported fixed size fields in the kernel_info
and beginning of kernel_info.kernel_info_var_len_data.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>size_total</p></td>
</tr>
<tr class="row-even"><td><p>Offset/size:</p></td>
<td><p>0x0008/4</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field contains the size of the kernel_info including kernel_info.header
and kernel_info.kernel_info_var_len_data.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 54%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Field name:</p></td>
<td><p>setup_type_max</p></td>
</tr>
<tr class="row-even"><td><p>Offset/size:</p></td>
<td><p>0x000c/4</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>This field contains maximal allowed type for setup_data and setup_indirect structs.</p>
</div></blockquote>
</section>
<section id="the-image-checksum">
<h2><span class="section-number">1.6. </span>The Image Checksum<a class="headerlink" href="#the-image-checksum" title="Permalink to this headline">¶</a></h2>
<p>From boot protocol version 2.08 onwards the CRC-32 is calculated over
the entire file using the characteristic polynomial 0x04C11DB7 and an
initial remainder of 0xffffffff.  The checksum is appended to the
file; therefore the CRC of the file up to the limit specified in the
syssize field of the header is always 0.</p>
</section>
<section id="the-kernel-command-line">
<h2><span class="section-number">1.7. </span>The Kernel Command Line<a class="headerlink" href="#the-kernel-command-line" title="Permalink to this headline">¶</a></h2>
<p>The kernel command line has become an important way for the boot
loader to communicate with the kernel.  Some of its options are also
relevant to the boot loader itself, see “special command line options”
below.</p>
<p>The kernel command line is a null-terminated string. The maximum
length can be retrieved from the field cmdline_size.  Before protocol
version 2.06, the maximum was 255 characters.  A string that is too
long will be automatically truncated by the kernel.</p>
<p>If the boot protocol version is 2.02 or later, the address of the
kernel command line is given by the header field cmd_line_ptr (see
above.)  This address can be anywhere between the end of the setup
heap and 0xA0000.</p>
<p>If the protocol version is <em>not</em> 2.02 or higher, the kernel
command line is entered using the following protocol:</p>
<blockquote>
<div><ul class="simple">
<li><p>At offset 0x0020 (word), “cmd_line_magic”, enter the magic
number 0xA33F.</p></li>
<li><p>At offset 0x0022 (word), “cmd_line_offset”, enter the offset
of the kernel command line (relative to the start of the
real-mode kernel).</p></li>
<li><p>The kernel command line <em>must</em> be within the memory region
covered by setup_move_size, so you may need to adjust this
field.</p></li>
</ul>
</div></blockquote>
</section>
<section id="memory-layout-of-the-real-mode-code">
<h2><span class="section-number">1.8. </span>Memory Layout of The Real-Mode Code<a class="headerlink" href="#memory-layout-of-the-real-mode-code" title="Permalink to this headline">¶</a></h2>
<p>The real-mode code requires a stack/heap to be set up, as well as
memory allocated for the kernel command line.  This needs to be done
in the real-mode accessible memory in bottom megabyte.</p>
<p>It should be noted that modern machines often have a sizable Extended
BIOS Data Area (EBDA).  As a result, it is advisable to use as little
of the low megabyte as possible.</p>
<p>Unfortunately, under the following circumstances the 0x90000 memory
segment has to be used:</p>
<blockquote>
<div><ul class="simple">
<li><p>When loading a zImage kernel ((loadflags &amp; 0x01) == 0).</p></li>
<li><p>When loading a 2.01 or earlier boot protocol kernel.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the 2.00 and 2.01 boot protocols, the real-mode code
can be loaded at another address, but it is internally
relocated to 0x90000.  For the “old” protocol, the
real-mode code must be loaded at 0x90000.</p>
</div>
<p>When loading at 0x90000, avoid using memory above 0x9a000.</p>
<p>For boot protocol 2.02 or higher, the command line does not have to be
located in the same 64K segment as the real-mode setup code; it is
thus permitted to give the stack/heap the full 64K segment and locate
the command line above it.</p>
<p>The kernel command line should not be located below the real-mode
code, nor should it be located in high memory.</p>
</section>
<section id="sample-boot-configuartion">
<h2><span class="section-number">1.9. </span>Sample Boot Configuartion<a class="headerlink" href="#sample-boot-configuartion" title="Permalink to this headline">¶</a></h2>
<p>As a sample configuration, assume the following layout of the real
mode segment.</p>
<blockquote>
<div><p>When loading below 0x90000, use the entire segment:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0x0000-0x7fff</p></td>
<td><p>Real mode kernel</p></td>
</tr>
<tr class="row-even"><td><p>0x8000-0xdfff</p></td>
<td><p>Stack and heap</p></td>
</tr>
<tr class="row-odd"><td><p>0xe000-0xffff</p></td>
<td><p>Kernel command line</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>When loading at 0x90000 OR the protocol version is 2.01 or earlier:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0x0000-0x7fff</p></td>
<td><p>Real mode kernel</p></td>
</tr>
<tr class="row-even"><td><p>0x8000-0x97ff</p></td>
<td><p>Stack and heap</p></td>
</tr>
<tr class="row-odd"><td><p>0x9800-0x9fff</p></td>
<td><p>Kernel command line</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div></blockquote>
<p>Such a boot loader should enter the following fields in the header:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned long base_ptr; /* base address for real-mode segment */

if ( setup_sects == 0 ) {
        setup_sects = 4;
}

if ( protocol &gt;= 0x0200 ) {
        type_of_loader = &lt;type code&gt;;
        if ( loading_initrd ) {
                ramdisk_image = &lt;initrd_address&gt;;
                ramdisk_size = &lt;initrd_size&gt;;
        }

        if ( protocol &gt;= 0x0202 &amp;&amp; loadflags &amp; 0x01 )
                heap_end = 0xe000;
        else
                heap_end = 0x9800;

        if ( protocol &gt;= 0x0201 ) {
                heap_end_ptr = heap_end - 0x200;
                loadflags |= 0x80; /* CAN_USE_HEAP */
        }

        if ( protocol &gt;= 0x0202 ) {
                cmd_line_ptr = base_ptr + heap_end;
                strcpy(cmd_line_ptr, cmdline);
        } else {
                cmd_line_magic  = 0xA33F;
                cmd_line_offset = heap_end;
                setup_move_size = heap_end + strlen(cmdline)+1;
                strcpy(base_ptr+cmd_line_offset, cmdline);
        }
} else {
        /* Very old kernel */

        heap_end = 0x9800;

        cmd_line_magic  = 0xA33F;
        cmd_line_offset = heap_end;

        /* A very old kernel MUST have its real-mode code
           loaded at 0x90000 */

        if ( base_ptr != 0x90000 ) {
                /* Copy the real-mode kernel */
                memcpy(0x90000, base_ptr, (setup_sects+1)*512);
                base_ptr = 0x90000;              /* Relocated */
        }

        strcpy(0x90000+cmd_line_offset, cmdline);

        /* It is recommended to clear memory up to the 32K mark */
        memset(0x90000 + (setup_sects+1)*512, 0,
               (64-(setup_sects+1))*512);
}
</pre></div>
</div>
</section>
<section id="loading-the-rest-of-the-kernel">
<h2><span class="section-number">1.10. </span>Loading The Rest of The Kernel<a class="headerlink" href="#loading-the-rest-of-the-kernel" title="Permalink to this headline">¶</a></h2>
<p>The 32-bit (non-real-mode) kernel starts at offset (setup_sects+1)*512
in the kernel file (again, if setup_sects == 0 the real value is 4.)
It should be loaded at address 0x10000 for Image/zImage kernels and
0x100000 for bzImage kernels.</p>
<p>The kernel is a bzImage kernel if the protocol &gt;= 2.00 and the 0x01
bit (LOAD_HIGH) in the loadflags field is set:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>is_bzImage = (protocol &gt;= 0x0200) &amp;&amp; (loadflags &amp; 0x01);
load_address = is_bzImage ? 0x100000 : 0x10000;
</pre></div>
</div>
<p>Note that Image/zImage kernels can be up to 512K in size, and thus use
the entire 0x10000-0x90000 range of memory.  This means it is pretty
much a requirement for these kernels to load the real-mode part at
0x90000.  bzImage kernels allow much more flexibility.</p>
</section>
<section id="special-command-line-options">
<h2><span class="section-number">1.11. </span>Special Command Line Options<a class="headerlink" href="#special-command-line-options" title="Permalink to this headline">¶</a></h2>
<p>If the command line provided by the boot loader is entered by the
user, the user may expect the following command line options to work.
They should normally not be deleted from the kernel command line even
though not all of them are actually meaningful to the kernel.  Boot
loader authors who need additional command line options for the boot
loader itself should get them registered in
<a class="reference internal" href="../admin-guide/kernel-parameters.html"><span class="doc">The kernel’s command-line parameters</span></a> to make sure they will not
conflict with actual kernel options now or in the future.</p>
<blockquote>
<div><dl class="simple">
<dt>vga=&lt;mode&gt;</dt><dd><p>&lt;mode&gt; here is either an integer (in C notation, either
decimal, octal, or hexadecimal) or one of the strings
“normal” (meaning 0xFFFF), “ext” (meaning 0xFFFE) or “ask”
(meaning 0xFFFD).  This value should be entered into the
vid_mode field, as it is used by the kernel before the command
line is parsed.</p>
</dd>
<dt>mem=&lt;size&gt;</dt><dd><p>&lt;size&gt; is an integer in C notation optionally followed by
(case insensitive) K, M, G, T, P or E (meaning &lt;&lt; 10, &lt;&lt; 20,
&lt;&lt; 30, &lt;&lt; 40, &lt;&lt; 50 or &lt;&lt; 60).  This specifies the end of
memory to the kernel. This affects the possible placement of
an initrd, since an initrd should be placed near end of
memory.  Note that this is an option to <em>both</em> the kernel and
the bootloader!</p>
</dd>
<dt>initrd=&lt;file&gt;</dt><dd><p>An initrd should be loaded.  The meaning of &lt;file&gt; is
obviously bootloader-dependent, and some boot loaders
(e.g. LILO) do not have such a command.</p>
</dd>
</dl>
</div></blockquote>
<p>In addition, some boot loaders add the following options to the
user-specified command line:</p>
<blockquote>
<div><dl class="simple">
<dt>BOOT_IMAGE=&lt;file&gt;</dt><dd><p>The boot image which was loaded.  Again, the meaning of &lt;file&gt;
is obviously bootloader-dependent.</p>
</dd>
<dt>auto</dt><dd><p>The kernel was booted without explicit user intervention.</p>
</dd>
</dl>
</div></blockquote>
<p>If these options are added by the boot loader, it is highly
recommended that they are located <em>first</em>, before the user-specified
or configuration-specified command line.  Otherwise, “init=/bin/sh”
gets confused by the “auto” option.</p>
</section>
<section id="running-the-kernel">
<h2><span class="section-number">1.12. </span>Running the Kernel<a class="headerlink" href="#running-the-kernel" title="Permalink to this headline">¶</a></h2>
<p>The kernel is started by jumping to the kernel entry point, which is
located at <em>segment</em> offset 0x20 from the start of the real mode
kernel.  This means that if you loaded your real-mode kernel code at
0x90000, the kernel entry point is 9020:0000.</p>
<p>At entry, ds = es = ss should point to the start of the real-mode
kernel code (0x9000 if the code is loaded at 0x90000), sp should be
set up properly, normally pointing to the top of the heap, and
interrupts should be disabled.  Furthermore, to guard against bugs in
the kernel, it is recommended that the boot loader sets fs = gs = ds =
es = ss.</p>
<p>In our example from above, we would do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Note: in the case of the &quot;old&quot; kernel protocol, base_ptr must
   be == 0x90000 at this point; see the previous sample code */

seg = base_ptr &gt;&gt; 4;

cli();  /* Enter with interrupts disabled! */

/* Set up the real-mode kernel stack */
_SS = seg;
_SP = heap_end;

_DS = _ES = _FS = _GS = seg;
jmp_far(seg+0x20, 0);   /* Run the kernel */
</pre></div>
</div>
<p>If your boot sector accesses a floppy drive, it is recommended to
switch off the floppy motor before running the kernel, since the
kernel boot leaves interrupts off and thus the motor will not be
switched off, especially if the loaded kernel has the floppy driver as
a demand-loaded module!</p>
</section>
<section id="advanced-boot-loader-hooks">
<h2><span class="section-number">1.13. </span>Advanced Boot Loader Hooks<a class="headerlink" href="#advanced-boot-loader-hooks" title="Permalink to this headline">¶</a></h2>
<p>If the boot loader runs in a particularly hostile environment (such as
LOADLIN, which runs under DOS) it may be impossible to follow the
standard memory location requirements.  Such a boot loader may use the
following hooks that, if set, are invoked by the kernel at the
appropriate time.  The use of these hooks should probably be
considered an absolutely last resort!</p>
<p>IMPORTANT: All the hooks are required to preserve %esp, %ebp, %esi and
%edi across invocation.</p>
<blockquote>
<div><dl>
<dt>realmode_swtch:</dt><dd><p>A 16-bit real mode far subroutine invoked immediately before
entering protected mode.  The default routine disables NMI, so
your routine should probably do so, too.</p>
</dd>
<dt>code32_start:</dt><dd><p>A 32-bit flat-mode routine <em>jumped</em> to immediately after the
transition to protected mode, but before the kernel is
uncompressed.  No segments, except CS, are guaranteed to be
set up (current kernels do, but older ones do not); you should
set them up to BOOT_DS (0x18) yourself.</p>
<p>After completing your hook, you should jump to the address
that was in this field before your boot loader overwrote it
(relocated, if appropriate.)</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="bit-boot-protocol">
<h2><span class="section-number">1.14. </span>32-bit Boot Protocol<a class="headerlink" href="#bit-boot-protocol" title="Permalink to this headline">¶</a></h2>
<p>For machine with some new BIOS other than legacy BIOS, such as EFI,
LinuxBIOS, etc, and kexec, the 16-bit real mode setup code in kernel
based on legacy BIOS can not be used, so a 32-bit boot protocol needs
to be defined.</p>
<p>In 32-bit boot protocol, the first step in loading a Linux kernel
should be to setup the boot parameters (struct boot_params,
traditionally known as “zero page”). The memory for struct boot_params
should be allocated and initialized to all zero. Then the setup header
from offset 0x01f1 of kernel image on should be loaded into struct
boot_params and examined. The end of setup header can be calculated as
follow:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x0202 + byte value at offset 0x0201
</pre></div>
</div>
<p>In addition to read/modify/write the setup header of the struct
boot_params as that of 16-bit boot protocol, the boot loader should
also fill the additional fields of the struct boot_params as
described in chapter <a class="reference internal" href="zero-page.html"><span class="doc">Zero Page</span></a>.</p>
<p>After setting up the struct boot_params, the boot loader can load the
32/64-bit kernel in the same way as that of 16-bit boot protocol.</p>
<p>In 32-bit boot protocol, the kernel is started by jumping to the
32-bit kernel entry point, which is the start address of loaded
32/64-bit kernel.</p>
<p>At entry, the CPU must be in 32-bit protected mode with paging
disabled; a GDT must be loaded with the descriptors for selectors
__BOOT_CS(0x10) and __BOOT_DS(0x18); both descriptors must be 4G flat
segment; __BOOT_CS must have execute/read permission, and __BOOT_DS
must have read/write permission; CS must be __BOOT_CS and DS, ES, SS
must be __BOOT_DS; interrupt must be disabled; %esi must hold the base
address of the struct boot_params; %ebp, %edi and %ebx must be zero.</p>
</section>
<section id="id1">
<h2><span class="section-number">1.15. </span>64-bit Boot Protocol<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>For machine with 64bit cpus and 64bit kernel, we could use 64bit bootloader
and we need a 64-bit boot protocol.</p>
<p>In 64-bit boot protocol, the first step in loading a Linux kernel
should be to setup the boot parameters (struct boot_params,
traditionally known as “zero page”). The memory for struct boot_params
could be allocated anywhere (even above 4G) and initialized to all zero.
Then, the setup header at offset 0x01f1 of kernel image on should be
loaded into struct boot_params and examined. The end of setup header
can be calculated as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x0202 + byte value at offset 0x0201
</pre></div>
</div>
<p>In addition to read/modify/write the setup header of the struct
boot_params as that of 16-bit boot protocol, the boot loader should
also fill the additional fields of the struct boot_params as described
in chapter <a class="reference internal" href="zero-page.html"><span class="doc">Zero Page</span></a>.</p>
<p>After setting up the struct boot_params, the boot loader can load
64-bit kernel in the same way as that of 16-bit boot protocol, but
kernel could be loaded above 4G.</p>
<p>In 64-bit boot protocol, the kernel is started by jumping to the
64-bit kernel entry point, which is the start address of loaded
64-bit kernel plus 0x200.</p>
<p>At entry, the CPU must be in 64-bit mode with paging enabled.
The range with setup_header.init_size from start address of loaded
kernel and zero page and command line buffer get ident mapping;
a GDT must be loaded with the descriptors for selectors
__BOOT_CS(0x10) and __BOOT_DS(0x18); both descriptors must be 4G flat
segment; __BOOT_CS must have execute/read permission, and __BOOT_DS
must have read/write permission; CS must be __BOOT_CS and DS, ES, SS
must be __BOOT_DS; interrupt must be disabled; %rsi must hold the base
address of the struct boot_params.</p>
</section>
<section id="efi-handover-protocol-deprecated">
<h2><span class="section-number">1.16. </span>EFI Handover Protocol (deprecated)<a class="headerlink" href="#efi-handover-protocol-deprecated" title="Permalink to this headline">¶</a></h2>
<p>This protocol allows boot loaders to defer initialisation to the EFI
boot stub. The boot loader is required to load the kernel/initrd(s)
from the boot media and jump to the EFI handover protocol entry point
which is hdr-&gt;handover_offset bytes from the beginning of
startup_{32,64}.</p>
<p>The boot loader MUST respect the kernel’s PE/COFF metadata when it comes
to section alignment, the memory footprint of the executable image beyond
the size of the file itself, and any other aspect of the PE/COFF header
that may affect correct operation of the image as a PE/COFF binary in the
execution context provided by the EFI firmware.</p>
<p>The function prototype for the handover entry point looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>efi_main(void *handle, efi_system_table_t *table, struct boot_params *bp)
</pre></div>
</div>
<p>‘handle’ is the EFI image handle passed to the boot loader by the EFI
firmware, ‘table’ is the EFI system table - these are the first two
arguments of the “handoff state” as described in section 2.3 of the
UEFI specification. ‘bp’ is the boot loader-allocated boot params.</p>
<p>The boot loader <em>must</em> fill out the following fields in bp:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- hdr.cmd_line_ptr
- hdr.ramdisk_image (if applicable)
- hdr.ramdisk_size  (if applicable)
</pre></div>
</div>
<p>All other fields should be zero.</p>
<dl class="simple">
<dt>NOTE: The EFI Handover Protocol is deprecated in favour of the ordinary PE/COFF</dt><dd><p>entry point, combined with the LINUX_EFI_INITRD_MEDIA_GUID based initrd
loading protocol (refer to [0] for an example of the bootloader side of
this), which removes the need for any knowledge on the part of the EFI
bootloader regarding the internal representation of boot_params or any
requirements/limitations regarding the placement of the command line
and ramdisk in memory, or the placement of the kernel image itself.</p>
</dd>
</dl>
<p>[0] <a class="reference external" href="https://github.com/u-boot/u-boot/commit/ec80b4735a593961fe701cc3a5d717d4739b0fd0">https://github.com/u-boot/u-boot/commit/ec80b4735a593961fe701cc3a5d717d4739b0fd0</a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">1. The Linux/x86 Boot Protocol</a><ul>
<li><a class="reference internal" href="#memory-layout">1.1. Memory Layout</a></li>
<li><a class="reference internal" href="#the-real-mode-kernel-header">1.2. The Real-Mode Kernel Header</a></li>
<li><a class="reference internal" href="#details-of-header-fields">1.3. Details of Header Fields</a></li>
<li><a class="reference internal" href="#the-kernel-info">1.4. The kernel_info</a></li>
<li><a class="reference internal" href="#details-of-the-kernel-info-fields">1.5. Details of the kernel_info Fields</a></li>
<li><a class="reference internal" href="#the-image-checksum">1.6. The Image Checksum</a></li>
<li><a class="reference internal" href="#the-kernel-command-line">1.7. The Kernel Command Line</a></li>
<li><a class="reference internal" href="#memory-layout-of-the-real-mode-code">1.8. Memory Layout of The Real-Mode Code</a></li>
<li><a class="reference internal" href="#sample-boot-configuartion">1.9. Sample Boot Configuartion</a></li>
<li><a class="reference internal" href="#loading-the-rest-of-the-kernel">1.10. Loading The Rest of The Kernel</a></li>
<li><a class="reference internal" href="#special-command-line-options">1.11. Special Command Line Options</a></li>
<li><a class="reference internal" href="#running-the-kernel">1.12. Running the Kernel</a></li>
<li><a class="reference internal" href="#advanced-boot-loader-hooks">1.13. Advanced Boot Loader Hooks</a></li>
<li><a class="reference internal" href="#bit-boot-protocol">1.14. 32-bit Boot Protocol</a></li>
<li><a class="reference internal" href="#id1">1.15. 64-bit Boot Protocol</a></li>
<li><a class="reference internal" href="#efi-handover-protocol-deprecated">1.16. EFI Handover Protocol (deprecated)</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/x86/boot.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/x86/boot.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>