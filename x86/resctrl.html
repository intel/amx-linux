
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>23. User Interface for Resource Control feature &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="24. TSX Async Abort (TAA) mitigation" href="tsx_async_abort.html" />
    <link rel="prev" title="22. The Linux Microcode Loader" href="microcode.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="user-interface-for-resource-control-feature">
<h1><span class="section-number">23. </span>User Interface for Resource Control feature<a class="headerlink" href="#user-interface-for-resource-control-feature" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Copyright</dt>
<dd class="field-odd"><p>© 2016 Intel Corporation</p>
</dd>
<dt class="field-even">Authors</dt>
<dd class="field-even"><ul class="simple">
<li><p>Fenghua Yu &lt;<a class="reference external" href="mailto:fenghua&#46;yu&#37;&#52;&#48;intel&#46;com">fenghua<span>&#46;</span>yu<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;</p></li>
<li><p>Tony Luck &lt;<a class="reference external" href="mailto:tony&#46;luck&#37;&#52;&#48;intel&#46;com">tony<span>&#46;</span>luck<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;</p></li>
<li><p>Vikas Shivappa &lt;<a class="reference external" href="mailto:vikas&#46;shivappa&#37;&#52;&#48;intel&#46;com">vikas<span>&#46;</span>shivappa<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;</p></li>
</ul>
</dd>
</dl>
<p>Intel refers to this feature as Intel Resource Director Technology(Intel(R) RDT).
AMD refers to this feature as AMD Platform Quality of Service(AMD QoS).</p>
<p>This feature is enabled by the CONFIG_X86_CPU_RESCTRL and the x86 /proc/cpuinfo
flag bits:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 58%" />
<col style="width: 42%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>RDT (Resource Director Technology) Allocation</p></td>
<td><p>“rdt_a”</p></td>
</tr>
<tr class="row-even"><td><p>CAT (Cache Allocation Technology)</p></td>
<td><p>“cat_l3”, “cat_l2”</p></td>
</tr>
<tr class="row-odd"><td><p>CDP (Code and Data Prioritization)</p></td>
<td><p>“cdp_l3”, “cdp_l2”</p></td>
</tr>
<tr class="row-even"><td><p>CQM (Cache QoS Monitoring)</p></td>
<td><p>“cqm_llc”, “cqm_occup_llc”</p></td>
</tr>
<tr class="row-odd"><td><p>MBM (Memory Bandwidth Monitoring)</p></td>
<td><p>“cqm_mbm_total”, “cqm_mbm_local”</p></td>
</tr>
<tr class="row-even"><td><p>MBA (Memory Bandwidth Allocation)</p></td>
<td><p>“mba”</p></td>
</tr>
</tbody>
</table>
<p>To use the feature mount the file system:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t resctrl resctrl [-o cdp[,cdpl2][,mba_MBps]] /sys/fs/resctrl
</pre></div>
</div>
<p>mount options are:</p>
<dl class="simple">
<dt>“cdp”:</dt><dd><p>Enable code/data prioritization in L3 cache allocations.</p>
</dd>
<dt>“cdpl2”:</dt><dd><p>Enable code/data prioritization in L2 cache allocations.</p>
</dd>
<dt>“mba_MBps”:</dt><dd><p>Enable the MBA Software Controller(mba_sc) to specify MBA
bandwidth in MBps</p>
</dd>
</dl>
<p>L2 and L3 CDP are controlled separately.</p>
<p>RDT features are orthogonal. A particular system may support only
monitoring, only control, or both monitoring and control.  Cache
pseudo-locking is a unique way of using cache control to “pin” or
“lock” data in the cache. Details can be found in
“Cache Pseudo-Locking”.</p>
<p>The mount succeeds if either of allocation or monitoring is present, but
only those files and directories supported by the system will be created.
For more details on the behavior of the interface during monitoring
and allocation, see the “Resource alloc and monitor groups” section.</p>
<section id="info-directory">
<h2><span class="section-number">23.1. </span>Info directory<a class="headerlink" href="#info-directory" title="Permalink to this headline">¶</a></h2>
<p>The ‘info’ directory contains information about the enabled
resources. Each resource has its own subdirectory. The subdirectory
names reflect the resource names.</p>
<p>Each subdirectory contains the following files with respect to
allocation:</p>
<p>Cache resource(L3/L2)  subdirectory contains the following files
related to allocation:</p>
<dl>
<dt>“num_closids”:</dt><dd><p>The number of CLOSIDs which are valid for this
resource. The kernel uses the smallest number of
CLOSIDs of all enabled resources as limit.</p>
</dd>
<dt>“cbm_mask”:</dt><dd><p>The bitmask which is valid for this resource.
This mask is equivalent to 100%.</p>
</dd>
<dt>“min_cbm_bits”:</dt><dd><p>The minimum number of consecutive bits which
must be set when writing a mask.</p>
</dd>
<dt>“shareable_bits”:</dt><dd><p>Bitmask of shareable resource with other executing
entities (e.g. I/O). User can use this when
setting up exclusive cache partitions. Note that
some platforms support devices that have their
own settings for cache use which can over-ride
these bits.</p>
</dd>
<dt>“bit_usage”:</dt><dd><p>Annotated capacity bitmasks showing how all
instances of the resource are used. The legend is:</p>
<blockquote>
<div><dl class="simple">
<dt>“0”:</dt><dd><p>Corresponding region is unused. When the system’s
resources have been allocated and a “0” is found
in “bit_usage” it is a sign that resources are
wasted.</p>
</dd>
<dt>“H”:</dt><dd><p>Corresponding region is used by hardware only
but available for software use. If a resource
has bits set in “shareable_bits” but not all
of these bits appear in the resource groups’
schematas then the bits appearing in
“shareable_bits” but no resource group will
be marked as “H”.</p>
</dd>
<dt>“X”:</dt><dd><p>Corresponding region is available for sharing and
used by hardware and software. These are the
bits that appear in “shareable_bits” as
well as a resource group’s allocation.</p>
</dd>
<dt>“S”:</dt><dd><p>Corresponding region is used by software
and available for sharing.</p>
</dd>
<dt>“E”:</dt><dd><p>Corresponding region is used exclusively by
one resource group. No sharing allowed.</p>
</dd>
<dt>“P”:</dt><dd><p>Corresponding region is pseudo-locked. No
sharing allowed.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>Memory bandwidth(MB) subdirectory contains the following files
with respect to allocation:</p>
<dl>
<dt>“min_bandwidth”:</dt><dd><p>The minimum memory bandwidth percentage which
user can request.</p>
</dd>
<dt>“bandwidth_gran”:</dt><dd><p>The granularity in which the memory bandwidth
percentage is allocated. The allocated
b/w percentage is rounded off to the next
control step available on the hardware. The
available bandwidth control steps are:
min_bandwidth + N * bandwidth_gran.</p>
</dd>
<dt>“delay_linear”:</dt><dd><p>Indicates if the delay scale is linear or
non-linear. This field is purely informational
only.</p>
</dd>
<dt>“thread_throttle_mode”:</dt><dd><p>Indicator on Intel systems of how tasks running on threads
of a physical core are throttled in cases where they
request different memory bandwidth percentages:</p>
<dl class="simple">
<dt>“max”:</dt><dd><p>the smallest percentage is applied
to all threads</p>
</dd>
<dt>“per-thread”:</dt><dd><p>bandwidth percentages are directly applied to
the threads running on the core</p>
</dd>
</dl>
</dd>
</dl>
<p>If RDT monitoring is available there will be an “L3_MON” directory
with the following files:</p>
<dl class="simple">
<dt>“num_rmids”:</dt><dd><p>The number of RMIDs available. This is the
upper bound for how many “CTRL_MON” + “MON”
groups can be created.</p>
</dd>
<dt>“mon_features”:</dt><dd><p>Lists the monitoring events if
monitoring is enabled for the resource.</p>
</dd>
<dt>“max_threshold_occupancy”:</dt><dd><p>Read/write file provides the largest value (in
bytes) at which a previously used LLC_occupancy
counter can be considered for re-use.</p>
</dd>
</dl>
<p>Finally, in the top level of the “info” directory there is a file
named “last_cmd_status”. This is reset with every “command” issued
via the file system (making new directories or writing to any of the
control files). If the command was successful, it will read as “ok”.
If the command failed, it will provide more information that can be
conveyed in the error returns from file operations. E.g.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo L3:0=f7 &gt; schemata
bash: echo: write error: Invalid argument
# cat info/last_cmd_status
mask f7 has non-consecutive 1-bits
</pre></div>
</div>
</section>
<section id="resource-alloc-and-monitor-groups">
<h2><span class="section-number">23.2. </span>Resource alloc and monitor groups<a class="headerlink" href="#resource-alloc-and-monitor-groups" title="Permalink to this headline">¶</a></h2>
<p>Resource groups are represented as directories in the resctrl file
system.  The default group is the root directory which, immediately
after mounting, owns all the tasks and cpus in the system and can make
full use of all resources.</p>
<p>On a system with RDT control features additional directories can be
created in the root directory that specify different amounts of each
resource (see “schemata” below). The root and these additional top level
directories are referred to as “CTRL_MON” groups below.</p>
<p>On a system with RDT monitoring the root directory and other top level
directories contain a directory named “mon_groups” in which additional
directories can be created to monitor subsets of tasks in the CTRL_MON
group that is their ancestor. These are called “MON” groups in the rest
of this document.</p>
<p>Removing a directory will move all tasks and cpus owned by the group it
represents to the parent. Removing one of the created CTRL_MON groups
will automatically remove all MON groups below it.</p>
<p>All groups contain the following files:</p>
<dl class="simple">
<dt>“tasks”:</dt><dd><p>Reading this file shows the list of all tasks that belong to
this group. Writing a task id to the file will add a task to the
group. If the group is a CTRL_MON group the task is removed from
whichever previous CTRL_MON group owned the task and also from
any MON group that owned the task. If the group is a MON group,
then the task must already belong to the CTRL_MON parent of this
group. The task is removed from any previous MON group.</p>
</dd>
<dt>“cpus”:</dt><dd><p>Reading this file shows a bitmask of the logical CPUs owned by
this group. Writing a mask to this file will add and remove
CPUs to/from this group. As with the tasks file a hierarchy is
maintained where MON groups may only include CPUs owned by the
parent CTRL_MON group.
When the resource group is in pseudo-locked mode this file will
only be readable, reflecting the CPUs associated with the
pseudo-locked region.</p>
</dd>
<dt>“cpus_list”:</dt><dd><p>Just like “cpus”, only using ranges of CPUs instead of bitmasks.</p>
</dd>
</dl>
<p>When control is enabled all CTRL_MON groups will also contain:</p>
<dl class="simple">
<dt>“schemata”:</dt><dd><p>A list of all the resources available to this group.
Each resource has its own line and format - see below for details.</p>
</dd>
<dt>“size”:</dt><dd><p>Mirrors the display of the “schemata” file to display the size in
bytes of each allocation instead of the bits representing the
allocation.</p>
</dd>
<dt>“mode”:</dt><dd><p>The “mode” of the resource group dictates the sharing of its
allocations. A “shareable” resource group allows sharing of its
allocations while an “exclusive” resource group does not. A
cache pseudo-locked region is created by first writing
“pseudo-locksetup” to the “mode” file before writing the cache
pseudo-locked region’s schemata to the resource group’s “schemata”
file. On successful pseudo-locked region creation the mode will
automatically change to “pseudo-locked”.</p>
</dd>
</dl>
<p>When monitoring is enabled all MON groups will also contain:</p>
<dl class="simple">
<dt>“mon_data”:</dt><dd><p>This contains a set of files organized by L3 domain and by
RDT event. E.g. on a system with two L3 domains there will
be subdirectories “mon_L3_00” and “mon_L3_01”.  Each of these
directories have one file per event (e.g. “llc_occupancy”,
“mbm_total_bytes”, and “mbm_local_bytes”). In a MON group these
files provide a read out of the current value of the event for
all tasks in the group. In CTRL_MON groups these files provide
the sum for all tasks in the CTRL_MON group and all tasks in
MON groups. Please see example section for more details on usage.</p>
</dd>
</dl>
<section id="resource-allocation-rules">
<h3><span class="section-number">23.2.1. </span>Resource allocation rules<a class="headerlink" href="#resource-allocation-rules" title="Permalink to this headline">¶</a></h3>
<p>When a task is running the following rules define which resources are
available to it:</p>
<ol class="arabic simple">
<li><p>If the task is a member of a non-default group, then the schemata
for that group is used.</p></li>
<li><p>Else if the task belongs to the default group, but is running on a
CPU that is assigned to some specific group, then the schemata for the
CPU’s group is used.</p></li>
<li><p>Otherwise the schemata for the default group is used.</p></li>
</ol>
</section>
<section id="resource-monitoring-rules">
<h3><span class="section-number">23.2.2. </span>Resource monitoring rules<a class="headerlink" href="#resource-monitoring-rules" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>If a task is a member of a MON group, or non-default CTRL_MON group
then RDT events for the task will be reported in that group.</p></li>
<li><p>If a task is a member of the default CTRL_MON group, but is running
on a CPU that is assigned to some specific group, then the RDT events
for the task will be reported in that group.</p></li>
<li><p>Otherwise RDT events for the task will be reported in the root level
“mon_data” group.</p></li>
</ol>
</section>
</section>
<section id="notes-on-cache-occupancy-monitoring-and-control">
<h2><span class="section-number">23.3. </span>Notes on cache occupancy monitoring and control<a class="headerlink" href="#notes-on-cache-occupancy-monitoring-and-control" title="Permalink to this headline">¶</a></h2>
<p>When moving a task from one group to another you should remember that
this only affects <em>new</em> cache allocations by the task. E.g. you may have
a task in a monitor group showing 3 MB of cache occupancy. If you move
to a new group and immediately check the occupancy of the old and new
groups you will likely see that the old group is still showing 3 MB and
the new group zero. When the task accesses locations still in cache from
before the move, the h/w does not update any counters. On a busy system
you will likely see the occupancy in the old group go down as cache lines
are evicted and re-used while the occupancy in the new group rises as
the task accesses memory and loads into the cache are counted based on
membership in the new group.</p>
<p>The same applies to cache allocation control. Moving a task to a group
with a smaller cache partition will not evict any cache lines. The
process may continue to use them from the old partition.</p>
<p>Hardware uses CLOSid(Class of service ID) and an RMID(Resource monitoring ID)
to identify a control group and a monitoring group respectively. Each of
the resource groups are mapped to these IDs based on the kind of group. The
number of CLOSid and RMID are limited by the hardware and hence the creation of
a “CTRL_MON” directory may fail if we run out of either CLOSID or RMID
and creation of “MON” group may fail if we run out of RMIDs.</p>
<section id="max-threshold-occupancy-generic-concepts">
<h3><span class="section-number">23.3.1. </span>max_threshold_occupancy - generic concepts<a class="headerlink" href="#max-threshold-occupancy-generic-concepts" title="Permalink to this headline">¶</a></h3>
<p>Note that an RMID once freed may not be immediately available for use as
the RMID is still tagged the cache lines of the previous user of RMID.
Hence such RMIDs are placed on limbo list and checked back if the cache
occupancy has gone down. If there is a time when system has a lot of
limbo RMIDs but which are not ready to be used, user may see an -EBUSY
during mkdir.</p>
<p>max_threshold_occupancy is a user configurable value to determine the
occupancy at which an RMID can be freed.</p>
</section>
<section id="schemata-files-general-concepts">
<h3><span class="section-number">23.3.2. </span>Schemata files - general concepts<a class="headerlink" href="#schemata-files-general-concepts" title="Permalink to this headline">¶</a></h3>
<p>Each line in the file describes one resource. The line starts with
the name of the resource, followed by specific values to be applied
in each of the instances of that resource on the system.</p>
</section>
<section id="cache-ids">
<h3><span class="section-number">23.3.3. </span>Cache IDs<a class="headerlink" href="#cache-ids" title="Permalink to this headline">¶</a></h3>
<p>On current generation systems there is one L3 cache per socket and L2
caches are generally just shared by the hyperthreads on a core, but this
isn’t an architectural requirement. We could have multiple separate L3
caches on a socket, multiple cores could share an L2 cache. So instead
of using “socket” or “core” to define the set of logical cpus sharing
a resource we use a “Cache ID”. At a given cache level this will be a
unique number across the whole system (but it isn’t guaranteed to be a
contiguous sequence, there may be gaps).  To find the ID for each logical
CPU look in /sys/devices/system/cpu/cpu*/cache/index*/id</p>
</section>
<section id="cache-bit-masks-cbm">
<h3><span class="section-number">23.3.4. </span>Cache Bit Masks (CBM)<a class="headerlink" href="#cache-bit-masks-cbm" title="Permalink to this headline">¶</a></h3>
<p>For cache resources we describe the portion of the cache that is available
for allocation using a bitmask. The maximum value of the mask is defined
by each cpu model (and may be different for different cache levels). It
is found using CPUID, but is also provided in the “info” directory of
the resctrl file system in “info/{resource}/cbm_mask”. Intel hardware
requires that these masks have all the ‘1’ bits in a contiguous block. So
0x3, 0x6 and 0xC are legal 4-bit masks with two bits set, but 0x5, 0x9
and 0xA are not.  On a system with a 20-bit mask each bit represents 5%
of the capacity of the cache. You could partition the cache into four
equal parts with masks: 0x1f, 0x3e0, 0x7c00, 0xf8000.</p>
</section>
</section>
<section id="memory-bandwidth-allocation-and-monitoring">
<h2><span class="section-number">23.4. </span>Memory bandwidth Allocation and monitoring<a class="headerlink" href="#memory-bandwidth-allocation-and-monitoring" title="Permalink to this headline">¶</a></h2>
<p>For Memory bandwidth resource, by default the user controls the resource
by indicating the percentage of total memory bandwidth.</p>
<p>The minimum bandwidth percentage value for each cpu model is predefined
and can be looked up through “info/MB/min_bandwidth”. The bandwidth
granularity that is allocated is also dependent on the cpu model and can
be looked up at “info/MB/bandwidth_gran”. The available bandwidth
control steps are: min_bw + N * bw_gran. Intermediate values are rounded
to the next control step available on the hardware.</p>
<p>The bandwidth throttling is a core specific mechanism on some of Intel
SKUs. Using a high bandwidth and a low bandwidth setting on two threads
sharing a core may result in both threads being throttled to use the
low bandwidth (see “thread_throttle_mode”).</p>
<p>The fact that Memory bandwidth allocation(MBA) may be a core
specific mechanism where as memory bandwidth monitoring(MBM) is done at
the package level may lead to confusion when users try to apply control
via the MBA and then monitor the bandwidth to see if the controls are
effective. Below are such scenarios:</p>
<ol class="arabic simple">
<li><p>User may <em>not</em> see increase in actual bandwidth when percentage
values are increased:</p></li>
</ol>
<p>This can occur when aggregate L2 external bandwidth is more than L3
external bandwidth. Consider an SKL SKU with 24 cores on a package and
where L2 external  is 10GBps (hence aggregate L2 external bandwidth is
240GBps) and L3 external bandwidth is 100GBps. Now a workload with ‘20
threads, having 50% bandwidth, each consuming 5GBps’ consumes the max L3
bandwidth of 100GBps although the percentage value specified is only 50%
&lt;&lt; 100%. Hence increasing the bandwidth percentage will not yield any
more bandwidth. This is because although the L2 external bandwidth still
has capacity, the L3 external bandwidth is fully used. Also note that
this would be dependent on number of cores the benchmark is run on.</p>
<ol class="arabic simple" start="2">
<li><p>Same bandwidth percentage may mean different actual bandwidth
depending on # of threads:</p></li>
</ol>
<p>For the same SKU in #1, a ‘single thread, with 10% bandwidth’ and ‘4
thread, with 10% bandwidth’ can consume upto 10GBps and 40GBps although
they have same percentage bandwidth of 10%. This is simply because as
threads start using more cores in an rdtgroup, the actual bandwidth may
increase or vary although user specified bandwidth percentage is same.</p>
<p>In order to mitigate this and make the interface more user friendly,
resctrl added support for specifying the bandwidth in MBps as well.  The
kernel underneath would use a software feedback mechanism or a “Software
Controller(mba_sc)” which reads the actual bandwidth using MBM counters
and adjust the memory bandwidth percentages to ensure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;actual bandwidth &lt; user specified bandwidth&quot;.
</pre></div>
</div>
<p>By default, the schemata would take the bandwidth percentage values
where as user can switch to the “MBA software controller” mode using
a mount option ‘mba_MBps’. The schemata format is specified in the below
sections.</p>
<section id="l3-schemata-file-details-code-and-data-prioritization-disabled">
<h3><span class="section-number">23.4.1. </span>L3 schemata file details (code and data prioritization disabled)<a class="headerlink" href="#l3-schemata-file-details-code-and-data-prioritization-disabled" title="Permalink to this headline">¶</a></h3>
<p>With CDP disabled the L3 schemata format is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>L3:&lt;cache_id0&gt;=&lt;cbm&gt;;&lt;cache_id1&gt;=&lt;cbm&gt;;...
</pre></div>
</div>
</section>
<section id="l3-schemata-file-details-cdp-enabled-via-mount-option-to-resctrl">
<h3><span class="section-number">23.4.2. </span>L3 schemata file details (CDP enabled via mount option to resctrl)<a class="headerlink" href="#l3-schemata-file-details-cdp-enabled-via-mount-option-to-resctrl" title="Permalink to this headline">¶</a></h3>
<p>When CDP is enabled L3 control is split into two separate resources
so you can specify independent masks for code and data like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>L3DATA:&lt;cache_id0&gt;=&lt;cbm&gt;;&lt;cache_id1&gt;=&lt;cbm&gt;;...
L3CODE:&lt;cache_id0&gt;=&lt;cbm&gt;;&lt;cache_id1&gt;=&lt;cbm&gt;;...
</pre></div>
</div>
</section>
<section id="l2-schemata-file-details">
<h3><span class="section-number">23.4.3. </span>L2 schemata file details<a class="headerlink" href="#l2-schemata-file-details" title="Permalink to this headline">¶</a></h3>
<p>CDP is supported at L2 using the ‘cdpl2’ mount option. The schemata
format is either:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>L2:&lt;cache_id0&gt;=&lt;cbm&gt;;&lt;cache_id1&gt;=&lt;cbm&gt;;...
</pre></div>
</div>
<p>or</p>
<blockquote>
<div><p>L2DATA:&lt;cache_id0&gt;=&lt;cbm&gt;;&lt;cache_id1&gt;=&lt;cbm&gt;;…
L2CODE:&lt;cache_id0&gt;=&lt;cbm&gt;;&lt;cache_id1&gt;=&lt;cbm&gt;;…</p>
</div></blockquote>
</section>
<section id="memory-bandwidth-allocation-default-mode">
<h3><span class="section-number">23.4.4. </span>Memory bandwidth Allocation (default mode)<a class="headerlink" href="#memory-bandwidth-allocation-default-mode" title="Permalink to this headline">¶</a></h3>
<p>Memory b/w domain is L3 cache.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MB:&lt;cache_id0&gt;=bandwidth0;&lt;cache_id1&gt;=bandwidth1;...
</pre></div>
</div>
</section>
<section id="memory-bandwidth-allocation-specified-in-mbps">
<h3><span class="section-number">23.4.5. </span>Memory bandwidth Allocation specified in MBps<a class="headerlink" href="#memory-bandwidth-allocation-specified-in-mbps" title="Permalink to this headline">¶</a></h3>
<p>Memory bandwidth domain is L3 cache.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MB:&lt;cache_id0&gt;=bw_MBps0;&lt;cache_id1&gt;=bw_MBps1;...
</pre></div>
</div>
</section>
<section id="reading-writing-the-schemata-file">
<h3><span class="section-number">23.4.6. </span>Reading/writing the schemata file<a class="headerlink" href="#reading-writing-the-schemata-file" title="Permalink to this headline">¶</a></h3>
<p>Reading the schemata file will show the state of all resources
on all domains. When writing you only need to specify those values
which you wish to change.  E.g.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat schemata
L3DATA:0=fffff;1=fffff;2=fffff;3=fffff
L3CODE:0=fffff;1=fffff;2=fffff;3=fffff
# echo &quot;L3DATA:2=3c0;&quot; &gt; schemata
# cat schemata
L3DATA:0=fffff;1=fffff;2=3c0;3=fffff
L3CODE:0=fffff;1=fffff;2=fffff;3=fffff
</pre></div>
</div>
</section>
</section>
<section id="cache-pseudo-locking">
<h2><span class="section-number">23.5. </span>Cache Pseudo-Locking<a class="headerlink" href="#cache-pseudo-locking" title="Permalink to this headline">¶</a></h2>
<p>CAT enables a user to specify the amount of cache space that an
application can fill. Cache pseudo-locking builds on the fact that a
CPU can still read and write data pre-allocated outside its current
allocated area on a cache hit. With cache pseudo-locking, data can be
preloaded into a reserved portion of cache that no application can
fill, and from that point on will only serve cache hits. The cache
pseudo-locked memory is made accessible to user space where an
application can map it into its virtual address space and thus have
a region of memory with reduced average read latency.</p>
<p>The creation of a cache pseudo-locked region is triggered by a request
from the user to do so that is accompanied by a schemata of the region
to be pseudo-locked. The cache pseudo-locked region is created as follows:</p>
<ul class="simple">
<li><p>Create a CAT allocation CLOSNEW with a CBM matching the schemata
from the user of the cache region that will contain the pseudo-locked
memory. This region must not overlap with any current CAT allocation/CLOS
on the system and no future overlap with this cache region is allowed
while the pseudo-locked region exists.</p></li>
<li><p>Create a contiguous region of memory of the same size as the cache
region.</p></li>
<li><p>Flush the cache, disable hardware prefetchers, disable preemption.</p></li>
<li><p>Make CLOSNEW the active CLOS and touch the allocated memory to load
it into the cache.</p></li>
<li><p>Set the previous CLOS as active.</p></li>
<li><p>At this point the closid CLOSNEW can be released - the cache
pseudo-locked region is protected as long as its CBM does not appear in
any CAT allocation. Even though the cache pseudo-locked region will from
this point on not appear in any CBM of any CLOS an application running with
any CLOS will be able to access the memory in the pseudo-locked region since
the region continues to serve cache hits.</p></li>
<li><p>The contiguous region of memory loaded into the cache is exposed to
user-space as a character device.</p></li>
</ul>
<p>Cache pseudo-locking increases the probability that data will remain
in the cache via carefully configuring the CAT feature and controlling
application behavior. There is no guarantee that data is placed in
cache. Instructions like INVD, WBINVD, CLFLUSH, etc. can still evict
“locked” data from cache. Power management C-states may shrink or
power off cache. Deeper C-states will automatically be restricted on
pseudo-locked region creation.</p>
<p>It is required that an application using a pseudo-locked region runs
with affinity to the cores (or a subset of the cores) associated
with the cache on which the pseudo-locked region resides. A sanity check
within the code will not allow an application to map pseudo-locked memory
unless it runs with affinity to cores associated with the cache on which the
pseudo-locked region resides. The sanity check is only done during the
initial mmap() handling, there is no enforcement afterwards and the
application self needs to ensure it remains affine to the correct cores.</p>
<p>Pseudo-locking is accomplished in two stages:</p>
<ol class="arabic simple">
<li><p>During the first stage the system administrator allocates a portion
of cache that should be dedicated to pseudo-locking. At this time an
equivalent portion of memory is allocated, loaded into allocated
cache portion, and exposed as a character device.</p></li>
<li><p>During the second stage a user-space application maps (mmap()) the
pseudo-locked memory into its address space.</p></li>
</ol>
<section id="cache-pseudo-locking-interface">
<h3><span class="section-number">23.5.1. </span>Cache Pseudo-Locking Interface<a class="headerlink" href="#cache-pseudo-locking-interface" title="Permalink to this headline">¶</a></h3>
<p>A pseudo-locked region is created using the resctrl interface as follows:</p>
<ol class="arabic simple">
<li><p>Create a new resource group by creating a new directory in /sys/fs/resctrl.</p></li>
<li><p>Change the new resource group’s mode to “pseudo-locksetup” by writing
“pseudo-locksetup” to the “mode” file.</p></li>
<li><p>Write the schemata of the pseudo-locked region to the “schemata” file. All
bits within the schemata should be “unused” according to the “bit_usage”
file.</p></li>
</ol>
<p>On successful pseudo-locked region creation the “mode” file will contain
“pseudo-locked” and a new character device with the same name as the resource
group will exist in /dev/pseudo_lock. This character device can be mmap()’ed
by user space in order to obtain access to the pseudo-locked memory region.</p>
<p>An example of cache pseudo-locked region creation and usage can be found below.</p>
</section>
<section id="cache-pseudo-locking-debugging-interface">
<h3><span class="section-number">23.5.2. </span>Cache Pseudo-Locking Debugging Interface<a class="headerlink" href="#cache-pseudo-locking-debugging-interface" title="Permalink to this headline">¶</a></h3>
<p>The pseudo-locking debugging interface is enabled by default (if
CONFIG_DEBUG_FS is enabled) and can be found in /sys/kernel/debug/resctrl.</p>
<p>There is no explicit way for the kernel to test if a provided memory
location is present in the cache. The pseudo-locking debugging interface uses
the tracing infrastructure to provide two ways to measure cache residency of
the pseudo-locked region:</p>
<ol class="arabic simple">
<li><p>Memory access latency using the pseudo_lock_mem_latency tracepoint. Data
from these measurements are best visualized using a hist trigger (see
example below). In this test the pseudo-locked region is traversed at
a stride of 32 bytes while hardware prefetchers and preemption
are disabled. This also provides a substitute visualization of cache
hits and misses.</p></li>
<li><p>Cache hit and miss measurements using model specific precision counters if
available. Depending on the levels of cache on the system the pseudo_lock_l2
and pseudo_lock_l3 tracepoints are available.</p></li>
</ol>
<p>When a pseudo-locked region is created a new debugfs directory is created for
it in debugfs as /sys/kernel/debug/resctrl/&lt;newdir&gt;. A single
write-only file, pseudo_lock_measure, is present in this directory. The
measurement of the pseudo-locked region depends on the number written to this
debugfs file:</p>
<dl class="simple">
<dt>1:</dt><dd><p>writing “1” to the pseudo_lock_measure file will trigger the latency
measurement captured in the pseudo_lock_mem_latency tracepoint. See
example below.</p>
</dd>
<dt>2:</dt><dd><p>writing “2” to the pseudo_lock_measure file will trigger the L2 cache
residency (cache hits and misses) measurement captured in the
pseudo_lock_l2 tracepoint. See example below.</p>
</dd>
<dt>3:</dt><dd><p>writing “3” to the pseudo_lock_measure file will trigger the L3 cache
residency (cache hits and misses) measurement captured in the
pseudo_lock_l3 tracepoint.</p>
</dd>
</dl>
<p>All measurements are recorded with the tracing infrastructure. This requires
the relevant tracepoints to be enabled before the measurement is triggered.</p>
<section id="example-of-latency-debugging-interface">
<h4><span class="section-number">23.5.2.1. </span>Example of latency debugging interface<a class="headerlink" href="#example-of-latency-debugging-interface" title="Permalink to this headline">¶</a></h4>
<p>In this example a pseudo-locked region named “newlock” was created. Here is
how we can measure the latency in cycles of reading from this region and
visualize this data with a histogram that is available if CONFIG_HIST_TRIGGERS
is set:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># :&gt; /sys/kernel/debug/tracing/trace
# echo &#39;hist:keys=latency&#39; &gt; /sys/kernel/debug/tracing/events/resctrl/pseudo_lock_mem_latency/trigger
# echo 1 &gt; /sys/kernel/debug/tracing/events/resctrl/pseudo_lock_mem_latency/enable
# echo 1 &gt; /sys/kernel/debug/resctrl/newlock/pseudo_lock_measure
# echo 0 &gt; /sys/kernel/debug/tracing/events/resctrl/pseudo_lock_mem_latency/enable
# cat /sys/kernel/debug/tracing/events/resctrl/pseudo_lock_mem_latency/hist

# event histogram
#
# trigger info: hist:keys=latency:vals=hitcount:sort=hitcount:size=2048 [active]
#

{ latency:        456 } hitcount:          1
{ latency:         50 } hitcount:         83
{ latency:         36 } hitcount:         96
{ latency:         44 } hitcount:        174
{ latency:         48 } hitcount:        195
{ latency:         46 } hitcount:        262
{ latency:         42 } hitcount:        693
{ latency:         40 } hitcount:       3204
{ latency:         38 } hitcount:       3484

Totals:
    Hits: 8192
    Entries: 9
  Dropped: 0
</pre></div>
</div>
</section>
<section id="example-of-cache-hits-misses-debugging">
<h4><span class="section-number">23.5.2.2. </span>Example of cache hits/misses debugging<a class="headerlink" href="#example-of-cache-hits-misses-debugging" title="Permalink to this headline">¶</a></h4>
<p>In this example a pseudo-locked region named “newlock” was created on the L2
cache of a platform. Here is how we can obtain details of the cache hits
and misses using the platform’s precision counters.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># :&gt; /sys/kernel/debug/tracing/trace
# echo 1 &gt; /sys/kernel/debug/tracing/events/resctrl/pseudo_lock_l2/enable
# echo 2 &gt; /sys/kernel/debug/resctrl/newlock/pseudo_lock_measure
# echo 0 &gt; /sys/kernel/debug/tracing/events/resctrl/pseudo_lock_l2/enable
# cat /sys/kernel/debug/tracing/trace

# tracer: nop
#
#                              _-----=&gt; irqs-off
#                             / _----=&gt; need-resched
#                            | / _---=&gt; hardirq/softirq
#                            || / _--=&gt; preempt-depth
#                            ||| /     delay
#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
#              | |       |   ||||       |         |
pseudo_lock_mea-1672  [002] ....  3132.860500: pseudo_lock_l2: hits=4097 miss=0
</pre></div>
</div>
</section>
<section id="examples-for-rdt-allocation-usage">
<h4><span class="section-number">23.5.2.3. </span>Examples for RDT allocation usage<a class="headerlink" href="#examples-for-rdt-allocation-usage" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><p>Example 1</p></li>
</ol>
<p>On a two socket machine (one L3 cache per socket) with just four bits
for cache bit masks, minimum b/w of 10% with a memory bandwidth
granularity of 10%.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t resctrl resctrl /sys/fs/resctrl
# cd /sys/fs/resctrl
# mkdir p0 p1
# echo &quot;L3:0=3;1=c\nMB:0=50;1=50&quot; &gt; /sys/fs/resctrl/p0/schemata
# echo &quot;L3:0=3;1=3\nMB:0=50;1=50&quot; &gt; /sys/fs/resctrl/p1/schemata
</pre></div>
</div>
<p>The default resource group is unmodified, so we have access to all parts
of all caches (its schemata file reads “L3:0=f;1=f”).</p>
<p>Tasks that are under the control of group “p0” may only allocate from the
“lower” 50% on cache ID 0, and the “upper” 50% of cache ID 1.
Tasks in group “p1” use the “lower” 50% of cache on both sockets.</p>
<p>Similarly, tasks that are under the control of group “p0” may use a
maximum memory b/w of 50% on socket0 and 50% on socket 1.
Tasks in group “p1” may also use 50% memory b/w on both sockets.
Note that unlike cache masks, memory b/w cannot specify whether these
allocations can overlap or not. The allocations specifies the maximum
b/w that the group may be able to use and the system admin can configure
the b/w accordingly.</p>
<p>If resctrl is using the software controller (mba_sc) then user can enter the
max b/w in MB rather than the percentage values.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo &quot;L3:0=3;1=c\nMB:0=1024;1=500&quot; &gt; /sys/fs/resctrl/p0/schemata
# echo &quot;L3:0=3;1=3\nMB:0=1024;1=500&quot; &gt; /sys/fs/resctrl/p1/schemata
</pre></div>
</div>
<p>In the above example the tasks in “p1” and “p0” on socket 0 would use a max b/w
of 1024MB where as on socket 1 they would use 500MB.</p>
<ol class="arabic simple" start="2">
<li><p>Example 2</p></li>
</ol>
<p>Again two sockets, but this time with a more realistic 20-bit mask.</p>
<p>Two real time tasks pid=1234 running on processor 0 and pid=5678 running on
processor 1 on socket 0 on a 2-socket and dual core machine. To avoid noisy
neighbors, each of the two real-time tasks exclusively occupies one quarter
of L3 cache on socket 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t resctrl resctrl /sys/fs/resctrl
# cd /sys/fs/resctrl
</pre></div>
</div>
<p>First we reset the schemata for the default group so that the “upper”
50% of the L3 cache on socket 0 and 50% of memory b/w cannot be used by
ordinary tasks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo &quot;L3:0=3ff;1=fffff\nMB:0=50;1=100&quot; &gt; schemata
</pre></div>
</div>
<p>Next we make a resource group for our first real time task and give
it access to the “top” 25% of the cache on socket 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mkdir p0
# echo &quot;L3:0=f8000;1=fffff&quot; &gt; p0/schemata
</pre></div>
</div>
<p>Finally we move our first real time task into this resource group. We
also use taskset(1) to ensure the task always runs on a dedicated CPU
on socket 0. Most uses of resource groups will also constrain which
processors tasks run on.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo 1234 &gt; p0/tasks
# taskset -cp 1 1234
</pre></div>
</div>
<p>Ditto for the second real time task (with the remaining 25% of cache):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mkdir p1
# echo &quot;L3:0=7c00;1=fffff&quot; &gt; p1/schemata
# echo 5678 &gt; p1/tasks
# taskset -cp 2 5678
</pre></div>
</div>
<p>For the same 2 socket system with memory b/w resource and CAT L3 the
schemata would look like(Assume min_bandwidth 10 and bandwidth_gran is
10):</p>
<p>For our first real time task this would request 20% memory b/w on socket 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo -e &quot;L3:0=f8000;1=fffff\nMB:0=20;1=100&quot; &gt; p0/schemata
</pre></div>
</div>
<p>For our second real time task this would request an other 20% memory b/w
on socket 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo -e &quot;L3:0=f8000;1=fffff\nMB:0=20;1=100&quot; &gt; p0/schemata
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Example 3</p></li>
</ol>
<p>A single socket system which has real-time tasks running on core 4-7 and
non real-time workload assigned to core 0-3. The real-time tasks share text
and data, so a per task association is not required and due to interaction
with the kernel it’s desired that the kernel on these cores shares L3 with
the tasks.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t resctrl resctrl /sys/fs/resctrl
# cd /sys/fs/resctrl
</pre></div>
</div>
<p>First we reset the schemata for the default group so that the “upper”
50% of the L3 cache on socket 0, and 50% of memory bandwidth on socket 0
cannot be used by ordinary tasks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo &quot;L3:0=3ff\nMB:0=50&quot; &gt; schemata
</pre></div>
</div>
<p>Next we make a resource group for our real time cores and give it access
to the “top” 50% of the cache on socket 0 and 50% of memory bandwidth on
socket 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mkdir p0
# echo &quot;L3:0=ffc00\nMB:0=50&quot; &gt; p0/schemata
</pre></div>
</div>
<p>Finally we move core 4-7 over to the new group and make sure that the
kernel and the tasks running there get 50% of the cache. They should
also get 50% of memory bandwidth assuming that the cores 4-7 are SMT
siblings and only the real time threads are scheduled on the cores 4-7.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo F0 &gt; p0/cpus
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>Example 4</p></li>
</ol>
<p>The resource groups in previous examples were all in the default “shareable”
mode allowing sharing of their cache allocations. If one resource group
configures a cache allocation then nothing prevents another resource group
to overlap with that allocation.</p>
<p>In this example a new exclusive resource group will be created on a L2 CAT
system with two L2 cache instances that can be configured with an 8-bit
capacity bitmask. The new exclusive resource group will be configured to use
25% of each cache instance.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t resctrl resctrl /sys/fs/resctrl/
# cd /sys/fs/resctrl
</pre></div>
</div>
<p>First, we observe that the default group is configured to allocate to all L2
cache:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat schemata
L2:0=ff;1=ff
</pre></div>
</div>
<p>We could attempt to create the new resource group at this point, but it will
fail because of the overlap with the schemata of the default group:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mkdir p0
# echo &#39;L2:0=0x3;1=0x3&#39; &gt; p0/schemata
# cat p0/mode
shareable
# echo exclusive &gt; p0/mode
-sh: echo: write error: Invalid argument
# cat info/last_cmd_status
schemata overlaps
</pre></div>
</div>
<p>To ensure that there is no overlap with another resource group the default
resource group’s schemata has to change, making it possible for the new
resource group to become exclusive.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo &#39;L2:0=0xfc;1=0xfc&#39; &gt; schemata
# echo exclusive &gt; p0/mode
# grep . p0/*
p0/cpus:0
p0/mode:exclusive
p0/schemata:L2:0=03;1=03
p0/size:L2:0=262144;1=262144
</pre></div>
</div>
<p>A new resource group will on creation not overlap with an exclusive resource
group:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mkdir p1
# grep . p1/*
p1/cpus:0
p1/mode:shareable
p1/schemata:L2:0=fc;1=fc
p1/size:L2:0=786432;1=786432
</pre></div>
</div>
<p>The bit_usage will reflect how the cache is used:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat info/L2/bit_usage
0=SSSSSSEE;1=SSSSSSEE
</pre></div>
</div>
<p>A resource group cannot be forced to overlap with an exclusive resource group:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo &#39;L2:0=0x1;1=0x1&#39; &gt; p1/schemata
-sh: echo: write error: Invalid argument
# cat info/last_cmd_status
overlaps with exclusive group
</pre></div>
</div>
</section>
<section id="example-of-cache-pseudo-locking">
<h4><span class="section-number">23.5.2.4. </span>Example of Cache Pseudo-Locking<a class="headerlink" href="#example-of-cache-pseudo-locking" title="Permalink to this headline">¶</a></h4>
<p>Lock portion of L2 cache from cache id 1 using CBM 0x3. Pseudo-locked
region is exposed at /dev/pseudo_lock/newlock that can be provided to
application for argument to mmap().</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t resctrl resctrl /sys/fs/resctrl/
# cd /sys/fs/resctrl
</pre></div>
</div>
<p>Ensure that there are bits available that can be pseudo-locked, since only
unused bits can be pseudo-locked the bits to be pseudo-locked needs to be
removed from the default resource group’s schemata:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat info/L2/bit_usage
0=SSSSSSSS;1=SSSSSSSS
# echo &#39;L2:1=0xfc&#39; &gt; schemata
# cat info/L2/bit_usage
0=SSSSSSSS;1=SSSSSS00
</pre></div>
</div>
<p>Create a new resource group that will be associated with the pseudo-locked
region, indicate that it will be used for a pseudo-locked region, and
configure the requested pseudo-locked region capacity bitmask:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mkdir newlock
# echo pseudo-locksetup &gt; newlock/mode
# echo &#39;L2:1=0x3&#39; &gt; newlock/schemata
</pre></div>
</div>
<p>On success the resource group’s mode will change to pseudo-locked, the
bit_usage will reflect the pseudo-locked region, and the character device
exposing the pseudo-locked region will exist:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat newlock/mode
pseudo-locked
# cat info/L2/bit_usage
0=SSSSSSSS;1=SSSSSSPP
# ls -l /dev/pseudo_lock/newlock
crw------- 1 root root 243, 0 Apr  3 05:01 /dev/pseudo_lock/newlock
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
* Example code to access one page of pseudo-locked cache region
* from user space.
*/
#define _GNU_SOURCE
#include &lt;fcntl.h&gt;
#include &lt;sched.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;

/*
* It is required that the application runs with affinity to only
* cores associated with the pseudo-locked region. Here the cpu
* is hardcoded for convenience of example.
*/
static int cpuid = 2;

int main(int argc, char *argv[])
{
  cpu_set_t cpuset;
  long page_size;
  void *mapping;
  int dev_fd;
  int ret;

  page_size = sysconf(_SC_PAGESIZE);

  CPU_ZERO(&amp;cpuset);
  CPU_SET(cpuid, &amp;cpuset);
  ret = sched_setaffinity(0, sizeof(cpuset), &amp;cpuset);
  if (ret &lt; 0) {
    perror(&quot;sched_setaffinity&quot;);
    exit(EXIT_FAILURE);
  }

  dev_fd = open(&quot;/dev/pseudo_lock/newlock&quot;, O_RDWR);
  if (dev_fd &lt; 0) {
    perror(&quot;open&quot;);
    exit(EXIT_FAILURE);
  }

  mapping = mmap(0, page_size, PROT_READ | PROT_WRITE, MAP_SHARED,
          dev_fd, 0);
  if (mapping == MAP_FAILED) {
    perror(&quot;mmap&quot;);
    close(dev_fd);
    exit(EXIT_FAILURE);
  }

  /* Application interacts with pseudo-locked memory @mapping */

  ret = munmap(mapping, page_size);
  if (ret &lt; 0) {
    perror(&quot;munmap&quot;);
    close(dev_fd);
    exit(EXIT_FAILURE);
  }

  close(dev_fd);
  exit(EXIT_SUCCESS);
}
</pre></div>
</div>
</section>
</section>
<section id="locking-between-applications">
<h3><span class="section-number">23.5.3. </span>Locking between applications<a class="headerlink" href="#locking-between-applications" title="Permalink to this headline">¶</a></h3>
<p>Certain operations on the resctrl filesystem, composed of read/writes
to/from multiple files, must be atomic.</p>
<p>As an example, the allocation of an exclusive reservation of L3 cache
involves:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Read the cbmmasks from each directory or the per-resource “bit_usage”</p></li>
<li><p>Find a contiguous set of bits in the global CBM bitmask that is clear
in any of the directory cbmmasks</p></li>
<li><p>Create a new directory</p></li>
<li><p>Set the bits found in step 2 to the new directory “schemata” file</p></li>
</ol>
</div></blockquote>
<p>If two applications attempt to allocate space concurrently then they can
end up allocating the same bits so the reservations are shared instead of
exclusive.</p>
<p>To coordinate atomic operations on the resctrlfs and to avoid the problem
above, the following locking procedure is recommended:</p>
<p>Locking is based on flock, which is available in libc and also as a shell
script command</p>
<p>Write lock:</p>
<blockquote>
<div><ol class="upperalpha simple">
<li><p>Take flock(LOCK_EX) on /sys/fs/resctrl</p></li>
<li><p>Read/write the directory structure.</p></li>
<li><p>funlock</p></li>
</ol>
</div></blockquote>
<p>Read lock:</p>
<blockquote>
<div><ol class="upperalpha simple">
<li><p>Take flock(LOCK_SH) on /sys/fs/resctrl</p></li>
<li><p>If success read the directory structure.</p></li>
<li><p>funlock</p></li>
</ol>
</div></blockquote>
<p>Example with bash:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Atomically read directory structure
$ flock -s /sys/fs/resctrl/ find /sys/fs/resctrl

# Read directory contents and create new subdirectory

$ cat create-dir.sh
find /sys/fs/resctrl/ &gt; output.txt
mask = function-of(output.txt)
mkdir /sys/fs/resctrl/newres/
echo mask &gt; /sys/fs/resctrl/newres/schemata

$ flock /sys/fs/resctrl/ ./create-dir.sh
</pre></div>
</div>
<p>Example with C:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
* Example code do take advisory locks
* before accessing resctrl filesystem
*/
#include &lt;sys/file.h&gt;
#include &lt;stdlib.h&gt;

void resctrl_take_shared_lock(int fd)
{
  int ret;

  /* take shared lock on resctrl filesystem */
  ret = flock(fd, LOCK_SH);
  if (ret) {
    perror(&quot;flock&quot;);
    exit(-1);
  }
}

void resctrl_take_exclusive_lock(int fd)
{
  int ret;

  /* release lock on resctrl filesystem */
  ret = flock(fd, LOCK_EX);
  if (ret) {
    perror(&quot;flock&quot;);
    exit(-1);
  }
}

void resctrl_release_lock(int fd)
{
  int ret;

  /* take shared lock on resctrl filesystem */
  ret = flock(fd, LOCK_UN);
  if (ret) {
    perror(&quot;flock&quot;);
    exit(-1);
  }
}

void main(void)
{
  int fd, ret;

  fd = open(&quot;/sys/fs/resctrl&quot;, O_DIRECTORY);
  if (fd == -1) {
    perror(&quot;open&quot;);
    exit(-1);
  }
  resctrl_take_shared_lock(fd);
  /* code to read directory contents */
  resctrl_release_lock(fd);

  resctrl_take_exclusive_lock(fd);
  /* code to read and write directory contents */
  resctrl_release_lock(fd);
}
</pre></div>
</div>
</section>
</section>
<section id="examples-for-rdt-monitoring-along-with-allocation-usage">
<h2><span class="section-number">23.6. </span>Examples for RDT Monitoring along with allocation usage<a class="headerlink" href="#examples-for-rdt-monitoring-along-with-allocation-usage" title="Permalink to this headline">¶</a></h2>
<section id="reading-monitored-data">
<h3><span class="section-number">23.6.1. </span>Reading monitored data<a class="headerlink" href="#reading-monitored-data" title="Permalink to this headline">¶</a></h3>
<p>Reading an event file (for ex: mon_data/mon_L3_00/llc_occupancy) would
show the current snapshot of LLC occupancy of the corresponding MON
group or CTRL_MON group.</p>
</section>
<section id="example-1-monitor-ctrl-mon-group-and-subset-of-tasks-in-ctrl-mon-group">
<h3><span class="section-number">23.6.2. </span>Example 1 (Monitor CTRL_MON group and subset of tasks in CTRL_MON group)<a class="headerlink" href="#example-1-monitor-ctrl-mon-group-and-subset-of-tasks-in-ctrl-mon-group" title="Permalink to this headline">¶</a></h3>
<p>On a two socket machine (one L3 cache per socket) with just four bits
for cache bit masks:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t resctrl resctrl /sys/fs/resctrl
# cd /sys/fs/resctrl
# mkdir p0 p1
# echo &quot;L3:0=3;1=c&quot; &gt; /sys/fs/resctrl/p0/schemata
# echo &quot;L3:0=3;1=3&quot; &gt; /sys/fs/resctrl/p1/schemata
# echo 5678 &gt; p1/tasks
# echo 5679 &gt; p1/tasks
</pre></div>
</div>
<p>The default resource group is unmodified, so we have access to all parts
of all caches (its schemata file reads “L3:0=f;1=f”).</p>
<p>Tasks that are under the control of group “p0” may only allocate from the
“lower” 50% on cache ID 0, and the “upper” 50% of cache ID 1.
Tasks in group “p1” use the “lower” 50% of cache on both sockets.</p>
<p>Create monitor groups and assign a subset of tasks to each monitor group.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cd /sys/fs/resctrl/p1/mon_groups
# mkdir m11 m12
# echo 5678 &gt; m11/tasks
# echo 5679 &gt; m12/tasks
</pre></div>
</div>
<p>fetch data (data shown in bytes)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat m11/mon_data/mon_L3_00/llc_occupancy
16234000
# cat m11/mon_data/mon_L3_01/llc_occupancy
14789000
# cat m12/mon_data/mon_L3_00/llc_occupancy
16789000
</pre></div>
</div>
<p>The parent ctrl_mon group shows the aggregated data.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /sys/fs/resctrl/p1/mon_data/mon_l3_00/llc_occupancy
31234000
</pre></div>
</div>
</section>
<section id="example-2-monitor-a-task-from-its-creation">
<h3><span class="section-number">23.6.3. </span>Example 2 (Monitor a task from its creation)<a class="headerlink" href="#example-2-monitor-a-task-from-its-creation" title="Permalink to this headline">¶</a></h3>
<p>On a two socket machine (one L3 cache per socket):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t resctrl resctrl /sys/fs/resctrl
# cd /sys/fs/resctrl
# mkdir p0 p1
</pre></div>
</div>
<p>An RMID is allocated to the group once its created and hence the &lt;cmd&gt;
below is monitored from its creation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo $$ &gt; /sys/fs/resctrl/p1/tasks
# &lt;cmd&gt;
</pre></div>
</div>
<p>Fetch the data:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /sys/fs/resctrl/p1/mon_data/mon_l3_00/llc_occupancy
31789000
</pre></div>
</div>
</section>
<section id="example-3-monitor-without-cat-support-or-before-creating-cat-groups">
<h3><span class="section-number">23.6.4. </span>Example 3 (Monitor without CAT support or before creating CAT groups)<a class="headerlink" href="#example-3-monitor-without-cat-support-or-before-creating-cat-groups" title="Permalink to this headline">¶</a></h3>
<p>Assume a system like HSW has only CQM and no CAT support. In this case
the resctrl will still mount but cannot create CTRL_MON directories.
But user can create different MON groups within the root group thereby
able to monitor all tasks including kernel threads.</p>
<p>This can also be used to profile jobs cache size footprint before being
able to allocate them to different allocation groups.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t resctrl resctrl /sys/fs/resctrl
# cd /sys/fs/resctrl
# mkdir mon_groups/m01
# mkdir mon_groups/m02

# echo 3478 &gt; /sys/fs/resctrl/mon_groups/m01/tasks
# echo 2467 &gt; /sys/fs/resctrl/mon_groups/m02/tasks
</pre></div>
</div>
<p>Monitor the groups separately and also get per domain data. From the
below its apparent that the tasks are mostly doing work on
domain(socket) 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /sys/fs/resctrl/mon_groups/m01/mon_L3_00/llc_occupancy
31234000
# cat /sys/fs/resctrl/mon_groups/m01/mon_L3_01/llc_occupancy
34555
# cat /sys/fs/resctrl/mon_groups/m02/mon_L3_00/llc_occupancy
31234000
# cat /sys/fs/resctrl/mon_groups/m02/mon_L3_01/llc_occupancy
32789
</pre></div>
</div>
</section>
<section id="example-4-monitor-real-time-tasks">
<h3><span class="section-number">23.6.5. </span>Example 4 (Monitor real time tasks)<a class="headerlink" href="#example-4-monitor-real-time-tasks" title="Permalink to this headline">¶</a></h3>
<p>A single socket system which has real time tasks running on cores 4-7
and non real time tasks on other cpus. We want to monitor the cache
occupancy of the real time threads on these cores.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t resctrl resctrl /sys/fs/resctrl
# cd /sys/fs/resctrl
# mkdir p1
</pre></div>
</div>
<p>Move the cpus 4-7 over to p1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># echo f0 &gt; p1/cpus
</pre></div>
</div>
<p>View the llc occupancy snapshot:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /sys/fs/resctrl/p1/mon_data/mon_L3_00/llc_occupancy
11234000
</pre></div>
</div>
</section>
</section>
<section id="intel-rdt-errata">
<h2><span class="section-number">23.7. </span>Intel RDT Errata<a class="headerlink" href="#intel-rdt-errata" title="Permalink to this headline">¶</a></h2>
<section id="intel-mbm-counters-may-report-system-memory-bandwidth-incorrectly">
<h3><span class="section-number">23.7.1. </span>Intel MBM Counters May Report System Memory Bandwidth Incorrectly<a class="headerlink" href="#intel-mbm-counters-may-report-system-memory-bandwidth-incorrectly" title="Permalink to this headline">¶</a></h3>
<p>Errata SKX99 for Skylake server and BDF102 for Broadwell server.</p>
<p>Problem: Intel Memory Bandwidth Monitoring (MBM) counters track metrics
according to the assigned Resource Monitor ID (RMID) for that logical
core. The IA32_QM_CTR register (MSR 0xC8E), used to report these
metrics, may report incorrect system bandwidth for certain RMID values.</p>
<p>Implication: Due to the errata, system memory bandwidth may not match
what is reported.</p>
<p>Workaround: MBM total and local readings are corrected according to the
following correction factor table:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 24%" />
<col style="width: 27%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>core count</p></td>
<td><p>rmid count</p></td>
<td><p>rmid threshold</p></td>
<td><p>correction factor</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>8</p></td>
<td><p>0</p></td>
<td><p>1.000000</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>16</p></td>
<td><p>0</p></td>
<td><p>1.000000</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>24</p></td>
<td><p>15</p></td>
<td><p>0.969650</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>32</p></td>
<td><p>0</p></td>
<td><p>1.000000</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>48</p></td>
<td><p>31</p></td>
<td><p>0.969650</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>56</p></td>
<td><p>47</p></td>
<td><p>1.142857</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>64</p></td>
<td><p>0</p></td>
<td><p>1.000000</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>72</p></td>
<td><p>63</p></td>
<td><p>1.185115</p></td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>80</p></td>
<td><p>63</p></td>
<td><p>1.066553</p></td>
</tr>
<tr class="row-odd"><td><p>11</p></td>
<td><p>88</p></td>
<td><p>79</p></td>
<td><p>1.454545</p></td>
</tr>
<tr class="row-even"><td><p>12</p></td>
<td><p>96</p></td>
<td><p>0</p></td>
<td><p>1.000000</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>104</p></td>
<td><p>95</p></td>
<td><p>1.230769</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>112</p></td>
<td><p>95</p></td>
<td><p>1.142857</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>120</p></td>
<td><p>95</p></td>
<td><p>1.066667</p></td>
</tr>
<tr class="row-even"><td><p>16</p></td>
<td><p>128</p></td>
<td><p>0</p></td>
<td><p>1.000000</p></td>
</tr>
<tr class="row-odd"><td><p>17</p></td>
<td><p>136</p></td>
<td><p>127</p></td>
<td><p>1.254863</p></td>
</tr>
<tr class="row-even"><td><p>18</p></td>
<td><p>144</p></td>
<td><p>127</p></td>
<td><p>1.185255</p></td>
</tr>
<tr class="row-odd"><td><p>19</p></td>
<td><p>152</p></td>
<td><p>0</p></td>
<td><p>1.000000</p></td>
</tr>
<tr class="row-even"><td><p>20</p></td>
<td><p>160</p></td>
<td><p>127</p></td>
<td><p>1.066667</p></td>
</tr>
<tr class="row-odd"><td><p>21</p></td>
<td><p>168</p></td>
<td><p>0</p></td>
<td><p>1.000000</p></td>
</tr>
<tr class="row-even"><td><p>22</p></td>
<td><p>176</p></td>
<td><p>159</p></td>
<td><p>1.454334</p></td>
</tr>
<tr class="row-odd"><td><p>23</p></td>
<td><p>184</p></td>
<td><p>0</p></td>
<td><p>1.000000</p></td>
</tr>
<tr class="row-even"><td><p>24</p></td>
<td><p>192</p></td>
<td><p>127</p></td>
<td><p>0.969744</p></td>
</tr>
<tr class="row-odd"><td><p>25</p></td>
<td><p>200</p></td>
<td><p>191</p></td>
<td><p>1.280246</p></td>
</tr>
<tr class="row-even"><td><p>26</p></td>
<td><p>208</p></td>
<td><p>191</p></td>
<td><p>1.230921</p></td>
</tr>
<tr class="row-odd"><td><p>27</p></td>
<td><p>216</p></td>
<td><p>0</p></td>
<td><p>1.000000</p></td>
</tr>
<tr class="row-even"><td><p>28</p></td>
<td><p>224</p></td>
<td><p>191</p></td>
<td><p>1.143118</p></td>
</tr>
</tbody>
</table>
<p>If rmid &gt; rmid threshold, MBM total and local values should be multiplied
by the correction factor.</p>
<p>See:</p>
<p>1. Erratum SKX99 in Intel Xeon Processor Scalable Family Specification Update:
<a class="reference external" href="http://web.archive.org/web/20200716124958/https://www.intel.com/content/www/us/en/processors/xeon/scalable/xeon-scalable-spec-update.html">http://web.archive.org/web/20200716124958/https://www.intel.com/content/www/us/en/processors/xeon/scalable/xeon-scalable-spec-update.html</a></p>
<p>2. Erratum BDF102 in Intel Xeon E5-2600 v4 Processor Product Family Specification Update:
<a class="reference external" href="http://web.archive.org/web/20191125200531/https://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-v4-spec-update.pdf">http://web.archive.org/web/20191125200531/https://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-e5-v4-spec-update.pdf</a></p>
<p>3. The errata in Intel Resource Director Technology (Intel RDT) on 2nd Generation Intel Xeon Scalable Processors Reference Manual:
<a class="reference external" href="https://software.intel.com/content/www/us/en/develop/articles/intel-resource-director-technology-rdt-reference-manual.html">https://software.intel.com/content/www/us/en/develop/articles/intel-resource-director-technology-rdt-reference-manual.html</a></p>
<p>for further information.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">23. User Interface for Resource Control feature</a><ul>
<li><a class="reference internal" href="#info-directory">23.1. Info directory</a></li>
<li><a class="reference internal" href="#resource-alloc-and-monitor-groups">23.2. Resource alloc and monitor groups</a><ul>
<li><a class="reference internal" href="#resource-allocation-rules">23.2.1. Resource allocation rules</a></li>
<li><a class="reference internal" href="#resource-monitoring-rules">23.2.2. Resource monitoring rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notes-on-cache-occupancy-monitoring-and-control">23.3. Notes on cache occupancy monitoring and control</a><ul>
<li><a class="reference internal" href="#max-threshold-occupancy-generic-concepts">23.3.1. max_threshold_occupancy - generic concepts</a></li>
<li><a class="reference internal" href="#schemata-files-general-concepts">23.3.2. Schemata files - general concepts</a></li>
<li><a class="reference internal" href="#cache-ids">23.3.3. Cache IDs</a></li>
<li><a class="reference internal" href="#cache-bit-masks-cbm">23.3.4. Cache Bit Masks (CBM)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memory-bandwidth-allocation-and-monitoring">23.4. Memory bandwidth Allocation and monitoring</a><ul>
<li><a class="reference internal" href="#l3-schemata-file-details-code-and-data-prioritization-disabled">23.4.1. L3 schemata file details (code and data prioritization disabled)</a></li>
<li><a class="reference internal" href="#l3-schemata-file-details-cdp-enabled-via-mount-option-to-resctrl">23.4.2. L3 schemata file details (CDP enabled via mount option to resctrl)</a></li>
<li><a class="reference internal" href="#l2-schemata-file-details">23.4.3. L2 schemata file details</a></li>
<li><a class="reference internal" href="#memory-bandwidth-allocation-default-mode">23.4.4. Memory bandwidth Allocation (default mode)</a></li>
<li><a class="reference internal" href="#memory-bandwidth-allocation-specified-in-mbps">23.4.5. Memory bandwidth Allocation specified in MBps</a></li>
<li><a class="reference internal" href="#reading-writing-the-schemata-file">23.4.6. Reading/writing the schemata file</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cache-pseudo-locking">23.5. Cache Pseudo-Locking</a><ul>
<li><a class="reference internal" href="#cache-pseudo-locking-interface">23.5.1. Cache Pseudo-Locking Interface</a></li>
<li><a class="reference internal" href="#cache-pseudo-locking-debugging-interface">23.5.2. Cache Pseudo-Locking Debugging Interface</a><ul>
<li><a class="reference internal" href="#example-of-latency-debugging-interface">23.5.2.1. Example of latency debugging interface</a></li>
<li><a class="reference internal" href="#example-of-cache-hits-misses-debugging">23.5.2.2. Example of cache hits/misses debugging</a></li>
<li><a class="reference internal" href="#examples-for-rdt-allocation-usage">23.5.2.3. Examples for RDT allocation usage</a></li>
<li><a class="reference internal" href="#example-of-cache-pseudo-locking">23.5.2.4. Example of Cache Pseudo-Locking</a></li>
</ul>
</li>
<li><a class="reference internal" href="#locking-between-applications">23.5.3. Locking between applications</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples-for-rdt-monitoring-along-with-allocation-usage">23.6. Examples for RDT Monitoring along with allocation usage</a><ul>
<li><a class="reference internal" href="#reading-monitored-data">23.6.1. Reading monitored data</a></li>
<li><a class="reference internal" href="#example-1-monitor-ctrl-mon-group-and-subset-of-tasks-in-ctrl-mon-group">23.6.2. Example 1 (Monitor CTRL_MON group and subset of tasks in CTRL_MON group)</a></li>
<li><a class="reference internal" href="#example-2-monitor-a-task-from-its-creation">23.6.3. Example 2 (Monitor a task from its creation)</a></li>
<li><a class="reference internal" href="#example-3-monitor-without-cat-support-or-before-creating-cat-groups">23.6.4. Example 3 (Monitor without CAT support or before creating CAT groups)</a></li>
<li><a class="reference internal" href="#example-4-monitor-real-time-tasks">23.6.5. Example 4 (Monitor real time tasks)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#intel-rdt-errata">23.7. Intel RDT Errata</a><ul>
<li><a class="reference internal" href="#intel-mbm-counters-may-report-system-memory-bandwidth-incorrectly">23.7.1. Intel MBM Counters May Report System Memory Bandwidth Incorrectly</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/x86/resctrl.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/x86/resctrl.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>