
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>31. Software Guard eXtensions (SGX) &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="32. Feature status on x86 architecture" href="features.html" />
    <link rel="prev" title="30. Shared Virtual Addressing (SVA) with ENQCMD" href="sva.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="software-guard-extensions-sgx">
<h1><span class="section-number">31. </span>Software Guard eXtensions (SGX)<a class="headerlink" href="#software-guard-extensions-sgx" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<h2><span class="section-number">31.1. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Software Guard eXtensions (SGX) hardware enables for user space applications
to set aside private memory regions of code and data:</p>
<ul class="simple">
<li><p>Privileged (ring-0) ENCLS functions orchestrate the construction of the
regions.</p></li>
<li><p>Unprivileged (ring-3) ENCLU functions allow an application to enter and
execute inside the regions.</p></li>
</ul>
<p>These memory regions are called enclaves. An enclave can be only entered at a
fixed set of entry points. Each entry point can hold a single hardware thread
at a time.  While the enclave is loaded from a regular binary file by using
ENCLS functions, only the threads inside the enclave can access its memory. The
region is denied from outside access by the CPU, and encrypted before it leaves
from LLC.</p>
<p>The support can be determined by</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">sgx</span> <span class="pre">/proc/cpuinfo</span></code></p>
</div></blockquote>
<p>SGX must both be supported in the processor and enabled by the BIOS.  If SGX
appears to be unsupported on a system which has hardware support, ensure
support is enabled in the BIOS.  If a BIOS presents a choice between “Enabled”
and “Software Enabled” modes for SGX, choose “Enabled”.</p>
</section>
<section id="enclave-page-cache">
<h2><span class="section-number">31.2. </span>Enclave Page Cache<a class="headerlink" href="#enclave-page-cache" title="Permalink to this headline">¶</a></h2>
<p>SGX utilizes an <em>Enclave Page Cache (EPC)</em> to store pages that are associated
with an enclave. It is contained in a BIOS-reserved region of physical memory.
Unlike pages used for regular memory, pages can only be accessed from outside of
the enclave during enclave construction with special, limited SGX instructions.</p>
<p>Only a CPU executing inside an enclave can directly access enclave memory.
However, a CPU executing inside an enclave may access normal memory outside the
enclave.</p>
<p>The kernel manages enclave memory similar to how it treats device memory.</p>
<section id="enclave-page-types">
<h3><span class="section-number">31.2.1. </span>Enclave Page Types<a class="headerlink" href="#enclave-page-types" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt><strong>SGX Enclave Control Structure (SECS)</strong></dt><dd><p>Enclave’s address range, attributes and other global data are defined
by this structure.</p>
</dd>
<dt><strong>Regular (REG)</strong></dt><dd><p>Regular EPC pages contain the code and data of an enclave.</p>
</dd>
<dt><strong>Thread Control Structure (TCS)</strong></dt><dd><p>Thread Control Structure pages define the entry points to an enclave and
track the execution state of an enclave thread.</p>
</dd>
<dt><strong>Version Array (VA)</strong></dt><dd><p>Version Array pages contain 512 slots, each of which can contain a version
number for a page evicted from the EPC.</p>
</dd>
</dl>
</section>
<section id="enclave-page-cache-map">
<h3><span class="section-number">31.2.2. </span>Enclave Page Cache Map<a class="headerlink" href="#enclave-page-cache-map" title="Permalink to this headline">¶</a></h3>
<p>The processor tracks EPC pages in a hardware metadata structure called the
<em>Enclave Page Cache Map (EPCM)</em>.  The EPCM contains an entry for each EPC page
which describes the owning enclave, access rights and page type among the other
things.</p>
<p>EPCM permissions are separate from the normal page tables.  This prevents the
kernel from, for instance, allowing writes to data which an enclave wishes to
remain read-only.  EPCM permissions may only impose additional restrictions on
top of normal x86 page permissions.</p>
<p>For all intents and purposes, the SGX architecture allows the processor to
invalidate all EPCM entries at will.  This requires that software be prepared to
handle an EPCM fault at any time.  In practice, this can happen on events like
power transitions when the ephemeral key that encrypts enclave memory is lost.</p>
</section>
</section>
<section id="application-interface">
<h2><span class="section-number">31.3. </span>Application interface<a class="headerlink" href="#application-interface" title="Permalink to this headline">¶</a></h2>
<section id="enclave-build-functions">
<h3><span class="section-number">31.3.1. </span>Enclave build functions<a class="headerlink" href="#enclave-build-functions" title="Permalink to this headline">¶</a></h3>
<p>In addition to the traditional compiler and linker build process, SGX has a
separate enclave “build” process.  Enclaves must be built before they can be
executed (entered). The first step in building an enclave is opening the
<strong>/dev/sgx_enclave</strong> device.  Since enclave memory is protected from direct
access, special privileged instructions are then used to copy data into enclave
pages and establish enclave page permissions.</p>
<dl class="function">
<dt id="c.sgx_ioc_enclave_create">
long <code class="sig-name descname">sgx_ioc_enclave_create</code><span class="sig-paren">(</span>struct sgx_encl<em> *encl</em>, void __user<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sgx_ioc_enclave_create" title="Permalink to this definition">¶</a></dt>
<dd><p>handler for <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_CREATE</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_encl</span> <span class="pre">*encl</span></code></dt><dd><p>An enclave pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt><dd><p>The ioctl argument.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate kernel data structures for the enclave and invoke ECREATE.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0:         Success.</p></li>
<li><p>-EIO:      ECREATE failed.</p></li>
<li><p>-errno:    POSIX error.</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.sgx_ioc_enclave_add_pages">
long <code class="sig-name descname">sgx_ioc_enclave_add_pages</code><span class="sig-paren">(</span>struct sgx_encl<em> *encl</em>, void __user<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sgx_ioc_enclave_add_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>The handler for <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_ADD_PAGES</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_encl</span> <span class="pre">*encl</span></code></dt><dd><p>an enclave pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt><dd><p>a user pointer to a struct sgx_enclave_add_pages instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add one or more pages to an uninitialized enclave, and optionally extend the
measurement with the contents of the page. The SECINFO and measurement mask
are applied to all pages.</p>
<p>A SECINFO for a TCS is required to always contain zero permissions because
CPU silently zeros them. Allowing anything else would cause a mismatch in
the measurement.</p>
<p>mmap()’s protection bits are capped by the page permissions. For each page
address, the maximum protection bits are computed with the following
heuristics:</p>
<ol class="arabic simple">
<li><p>A regular page: PROT_R, PROT_W and PROT_X match the SECINFO permissions.</p></li>
<li><p>A TCS page: PROT_R | PROT_W.</p></li>
</ol>
<p>mmap() is not allowed to surpass the minimum of the maximum protection bits
within the given address range.</p>
<p>The function deinitializes kernel data structures for enclave and returns
-EIO in any of the following conditions:</p>
<ul class="simple">
<li><p>Enclave Page Cache (EPC), the physical memory holding enclaves, has
been invalidated. This will cause EADD and EEXTEND to fail.</p></li>
<li><p>If the source address is corrupted somehow when executing EADD.</p></li>
</ul>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0:         Success.</p></li>
<li><p>-EACCES:   The source page is located in a noexec partition.</p></li>
<li><p>-ENOMEM:   Out of EPC pages.</p></li>
<li><p>-EINTR:    The call was interrupted before data was processed.</p></li>
<li><dl class="simple">
<dt>-EIO:      Either EADD or EEXTEND failed because invalid source address</dt><dd><p>or power cycle.</p>
</dd>
</dl>
</li>
<li><p>-errno:    POSIX error.</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.sgx_ioc_enclave_init">
long <code class="sig-name descname">sgx_ioc_enclave_init</code><span class="sig-paren">(</span>struct sgx_encl<em> *encl</em>, void __user<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sgx_ioc_enclave_init" title="Permalink to this definition">¶</a></dt>
<dd><p>handler for <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_INIT</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_encl</span> <span class="pre">*encl</span></code></dt><dd><p>an enclave pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt><dd><p>userspace pointer to a struct sgx_enclave_init instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush any outstanding enqueued EADD operations and perform EINIT.  The
Launch Enclave Public Key Hash MSRs are rewritten as necessary to match
the enclave’s MRSIGNER, which is caculated from the provided sigstruct.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0:         Success.</p></li>
<li><p>-EPERM:    Invalid SIGSTRUCT.</p></li>
<li><p>-EIO:      EINIT failed because of a power cycle.</p></li>
<li><p>-errno:    POSIX error.</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.sgx_ioc_enclave_provision">
long <code class="sig-name descname">sgx_ioc_enclave_provision</code><span class="sig-paren">(</span>struct sgx_encl<em> *encl</em>, void __user<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sgx_ioc_enclave_provision" title="Permalink to this definition">¶</a></dt>
<dd><p>handler for <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_PROVISION</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_encl</span> <span class="pre">*encl</span></code></dt><dd><p>an enclave pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt><dd><p>userspace pointer to a struct sgx_enclave_provision instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow ATTRIBUTE.PROVISION_KEY for an enclave by providing a file handle to
/dev/sgx_provision.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0:         Success.</p></li>
<li><p>-errno:    Otherwise.</p></li>
</ul>
</div>
</section>
<section id="enclave-runtime-management">
<h3><span class="section-number">31.3.2. </span>Enclave runtime management<a class="headerlink" href="#enclave-runtime-management" title="Permalink to this headline">¶</a></h3>
<p>Systems supporting SGX2 additionally support changes to initialized
enclaves: modifying enclave page permissions and type, and dynamically
adding and removing of enclave pages. When an enclave accesses an address
within its address range that does not have a backing page then a new
regular page will be dynamically added to the enclave. The enclave is
still required to run EACCEPT on the new page before it can be used.</p>
<dl class="function">
<dt id="c.sgx_ioc_enclave_restrict_permissions">
long <code class="sig-name descname">sgx_ioc_enclave_restrict_permissions</code><span class="sig-paren">(</span>struct sgx_encl<em> *encl</em>, void __user<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sgx_ioc_enclave_restrict_permissions" title="Permalink to this definition">¶</a></dt>
<dd><p>handler for <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_RESTRICT_PERMISSIONS</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_encl</span> <span class="pre">*encl</span></code></dt><dd><p>an enclave pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt><dd><p>userspace pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_enclave_restrict_permissions</span></code>
instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>SGX2 distinguishes between relaxing and restricting the enclave page
permissions maintained by the hardware (EPCM permissions) of pages
belonging to an initialized enclave (after SGX_IOC_ENCLAVE_INIT).</p>
<p>EPCM permissions cannot be restricted from within the enclave, the enclave
requires the kernel to run the privileged level 0 instructions ENCLS[EMODPR]
and ENCLS[ETRACK]. An attempt to relax EPCM permissions with this call
will be ignored by the hardware.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0:         Success</p></li>
<li><p>-errno:    Otherwise</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.sgx_ioc_enclave_modify_types">
long <code class="sig-name descname">sgx_ioc_enclave_modify_types</code><span class="sig-paren">(</span>struct sgx_encl<em> *encl</em>, void __user<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sgx_ioc_enclave_modify_types" title="Permalink to this definition">¶</a></dt>
<dd><p>handler for <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_MODIFY_TYPES</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_encl</span> <span class="pre">*encl</span></code></dt><dd><p>an enclave pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt><dd><p>userspace pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_enclave_modify_types</span></code> instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ability to change the enclave page type supports the following use cases:</p>
<ul class="simple">
<li><p>It is possible to add TCS pages to an enclave by changing the type of
regular pages (<code class="docutils literal notranslate"><span class="pre">SGX_PAGE_TYPE_REG</span></code>) to TCS (<code class="docutils literal notranslate"><span class="pre">SGX_PAGE_TYPE_TCS</span></code>) pages.
With this support the number of threads supported by an initialized
enclave can be increased dynamically.</p></li>
<li><p>Regular or TCS pages can dynamically be removed from an initialized
enclave by changing the page type to <code class="docutils literal notranslate"><span class="pre">SGX_PAGE_TYPE_TRIM</span></code>. Changing the
page type to <code class="docutils literal notranslate"><span class="pre">SGX_PAGE_TYPE_TRIM</span></code> marks the page for removal with actual
removal done by handler of <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_REMOVE_PAGES</span></code> ioctl() called
after ENCLU[EACCEPT] is run on <code class="docutils literal notranslate"><span class="pre">SGX_PAGE_TYPE_TRIM</span></code> page from within the
enclave.</p></li>
</ul>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0:         Success</p></li>
<li><p>-errno:    Otherwise</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.sgx_ioc_enclave_remove_pages">
long <code class="sig-name descname">sgx_ioc_enclave_remove_pages</code><span class="sig-paren">(</span>struct sgx_encl<em> *encl</em>, void __user<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sgx_ioc_enclave_remove_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>handler for <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_REMOVE_PAGES</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_encl</span> <span class="pre">*encl</span></code></dt><dd><p>an enclave pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt><dd><p>userspace pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_enclave_remove_pages</span></code> instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Final step of the flow removing pages from an initialized enclave. The
complete flow is:</p>
<ol class="arabic simple">
<li><p>User changes the type of the pages to be removed to <code class="docutils literal notranslate"><span class="pre">SGX_PAGE_TYPE_TRIM</span></code>
using the <code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_MODIFY_TYPES</span></code> ioctl().</p></li>
<li><p>User approves the page removal by running ENCLU[EACCEPT] from within
the enclave.</p></li>
<li><p>User initiates actual page removal using the
<code class="docutils literal notranslate"><span class="pre">SGX_IOC_ENCLAVE_REMOVE_PAGES</span></code> ioctl() that is handled here.</p></li>
</ol>
<p>First remove any page table entries pointing to the page and then proceed
with the actual removal of the enclave page and data in support of it.</p>
<p>VA pages are not affected by this removal. It is thus possible that the
enclave may end up with more VA pages than needed to support all its
pages.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0:         Success</p></li>
<li><p>-errno:    Otherwise</p></li>
</ul>
</div>
</section>
<section id="enclave-vdso">
<h3><span class="section-number">31.3.3. </span>Enclave vDSO<a class="headerlink" href="#enclave-vdso" title="Permalink to this headline">¶</a></h3>
<p>Entering an enclave can only be done through SGX-specific EENTER and ERESUME
functions, and is a non-trivial process.  Because of the complexity of
transitioning to and from an enclave, enclaves typically utilize a library to
handle the actual transitions.  This is roughly analogous to how glibc
implementations are used by most applications to wrap system calls.</p>
<p>Another crucial characteristic of enclaves is that they can generate exceptions
as part of their normal operation that need to be handled in the enclave or are
unique to SGX.</p>
<p>Instead of the traditional signal mechanism to handle these exceptions, SGX
can leverage special exception fixup provided by the vDSO.  The kernel-provided
vDSO function wraps low-level transitions to/from the enclave like EENTER and
ERESUME.  The vDSO function intercepts exceptions that would otherwise generate
a signal and return the fault information directly to its caller.  This avoids
the need to juggle signal handlers.</p>
<dl class="type">
<dt id="c.vdso_sgx_enter_enclave_t">
<code class="sig-name descname">vdso_sgx_enter_enclave_t</code><a class="headerlink" href="#c.vdso_sgx_enter_enclave_t" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Typedef</strong>: Prototype for __vdso_sgx_enter_enclave(), a vDSO function to enter an SGX enclave.</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vdso_sgx_enter_enclave_t</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">rdi,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rsi,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rdx,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">function,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">r8,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">r9,</span> <span class="pre">struct</span> <span class="pre">sgx_enclave_run</span> <span class="pre">*run)</span></code></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rdi</span></code></dt><dd><p>Pass-through value for RDI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rsi</span></code></dt><dd><p>Pass-through value for RSI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rdx</span></code></dt><dd><p>Pass-through value for RDX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">function</span></code></dt><dd><p>ENCLU function, must be EENTER or ERESUME</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">r8</span></code></dt><dd><p>Pass-through value for R8</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">r9</span></code></dt><dd><p>Pass-through value for R9</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sgx_enclave_run</span> <span class="pre">*run</span></code></dt><dd><p>struct sgx_enclave_run, must be non-NULL</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>__vdso_sgx_enter_enclave() does not ensure full compliance with the
x86-64 ABI, e.g. doesn’t handle XSAVE state.  Except for non-volatile
general purpose registers, EFLAGS.DF, and RSP alignment, preserving/setting
state in accordance with the x86-64 ABI is the responsibility of the enclave
and its runtime, i.e. __vdso_sgx_enter_enclave() cannot be called from C
code without careful consideration by both the enclave and its runtime.</p>
<p><strong>Description</strong></p>
<p>All general purpose registers except RAX, RBX and RCX are passed as-is to the
enclave.  RAX, RBX and RCX are consumed by EENTER and ERESUME and are loaded
with <strong>function</strong>, asynchronous exit pointer, and <strong>run.tcs</strong> respectively.</p>
<p>RBP and the stack are used to anchor __vdso_sgx_enter_enclave() to the
pre-enclave state, e.g. to retrieve <strong>run.exception</strong> and <strong>run.user_handler</strong>
after an enclave exit.  All other registers are available for use by the
enclave and its runtime, e.g. an enclave can push additional data onto the
stack (and modify RSP) to pass information to the optional user handler (see
below).</p>
<p>Most exceptions reported on ENCLU, including those that occur within the
enclave, are fixed up and reported synchronously instead of being delivered
via a standard signal. Debug Exceptions (#DB) and Breakpoints (#BP) are
never fixed up and are always delivered via standard signals. On synchronously
reported exceptions, -EFAULT is returned and details about the exception are
recorded in <strong>run.exception</strong>, the optional sgx_enclave_exception struct.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0:         ENCLU function was successfully executed.</p></li>
<li><p>-EINVAL:   Invalid ENCL number (neither EENTER nor ERESUME).</p></li>
</ul>
</div>
</section>
</section>
<section id="ksgxd">
<h2><span class="section-number">31.4. </span>ksgxd<a class="headerlink" href="#ksgxd" title="Permalink to this headline">¶</a></h2>
<p>SGX support includes a kernel thread called <em>ksgxd</em>.</p>
<section id="epc-sanitization">
<h3><span class="section-number">31.4.1. </span>EPC sanitization<a class="headerlink" href="#epc-sanitization" title="Permalink to this headline">¶</a></h3>
<p>ksgxd is started when SGX initializes.  Enclave memory is typically ready
for use when the processor powers on or resets.  However, if SGX has been in
use since the reset, enclave pages may be in an inconsistent state.  This might
occur after a crash and kexec() cycle, for instance.  At boot, ksgxd
reinitializes all enclave pages so that they can be allocated and re-used.</p>
<p>The sanitization is done by going through EPC address space and applying the
EREMOVE function to each physical page. Some enclave pages like SECS pages have
hardware dependencies on other pages which prevents EREMOVE from functioning.
Executing two EREMOVE passes removes the dependencies.</p>
</section>
<section id="page-reclaimer">
<h3><span class="section-number">31.4.2. </span>Page reclaimer<a class="headerlink" href="#page-reclaimer" title="Permalink to this headline">¶</a></h3>
<p>Similar to the core kswapd, ksgxd, is responsible for managing the
overcommitment of enclave memory.  If the system runs out of enclave memory,
<em>ksgxd</em> “swaps” enclave memory to normal memory.</p>
</section>
</section>
<section id="launch-control">
<h2><span class="section-number">31.5. </span>Launch Control<a class="headerlink" href="#launch-control" title="Permalink to this headline">¶</a></h2>
<p>SGX provides a launch control mechanism. After all enclave pages have been
copied, kernel executes EINIT function, which initializes the enclave. Only after
this the CPU can execute inside the enclave.</p>
<p>EINIT function takes an RSA-3072 signature of the enclave measurement.  The function
checks that the measurement is correct and signature is signed with the key
hashed to the four <strong>IA32_SGXLEPUBKEYHASH{0, 1, 2, 3}</strong> MSRs representing the
SHA256 of a public key.</p>
<p>Those MSRs can be configured by the BIOS to be either readable or writable.
Linux supports only writable configuration in order to give full control to the
kernel on launch control policy. Before calling EINIT function, the driver sets
the MSRs to match the enclave’s signing key.</p>
</section>
<section id="encryption-engines">
<h2><span class="section-number">31.6. </span>Encryption engines<a class="headerlink" href="#encryption-engines" title="Permalink to this headline">¶</a></h2>
<p>In order to conceal the enclave data while it is out of the CPU package, the
memory controller has an encryption engine to transparently encrypt and decrypt
enclave memory.</p>
<p>In CPUs prior to Ice Lake, the Memory Encryption Engine (MEE) is used to
encrypt pages leaving the CPU caches. MEE uses a n-ary Merkle tree with root in
SRAM to maintain integrity of the encrypted data. This provides integrity and
anti-replay protection but does not scale to large memory sizes because the time
required to update the Merkle tree grows logarithmically in relation to the
memory size.</p>
<p>CPUs starting from Icelake use Total Memory Encryption (TME) in the place of
MEE. TME-based SGX implementations do not have an integrity Merkle tree, which
means integrity and replay-attacks are not mitigated.  B, it includes
additional changes to prevent cipher text from being returned and SW memory
aliases from being created.</p>
<p>DMA to enclave memory is blocked by range registers on both MEE and TME systems
(SDM section 41.10).</p>
</section>
<section id="usage-models">
<h2><span class="section-number">31.7. </span>Usage Models<a class="headerlink" href="#usage-models" title="Permalink to this headline">¶</a></h2>
<section id="shared-library">
<h3><span class="section-number">31.7.1. </span>Shared Library<a class="headerlink" href="#shared-library" title="Permalink to this headline">¶</a></h3>
<p>Sensitive data and the code that acts on it is partitioned from the application
into a separate library. The library is then linked as a DSO which can be loaded
into an enclave. The application can then make individual function calls into
the enclave through special SGX instructions. A run-time within the enclave is
configured to marshal function parameters into and out of the enclave and to
call the correct library function.</p>
</section>
<section id="application-container">
<h3><span class="section-number">31.7.2. </span>Application Container<a class="headerlink" href="#application-container" title="Permalink to this headline">¶</a></h3>
<p>An application may be loaded into a container enclave which is specially
configured with a library OS and run-time which permits the application to run.
The enclave run-time and library OS work together to execute the application
when a thread enters the enclave.</p>
</section>
</section>
<section id="impact-of-potential-kernel-sgx-bugs">
<h2><span class="section-number">31.8. </span>Impact of Potential Kernel SGX Bugs<a class="headerlink" href="#impact-of-potential-kernel-sgx-bugs" title="Permalink to this headline">¶</a></h2>
<section id="epc-leaks">
<h3><span class="section-number">31.8.1. </span>EPC leaks<a class="headerlink" href="#epc-leaks" title="Permalink to this headline">¶</a></h3>
<p>When EPC page leaks happen, a WARNING like this is shown in dmesg:</p>
<p>“EREMOVE returned … and an EPC page was leaked.  SGX may become unusable…”</p>
<p>This is effectively a kernel use-after-free of an EPC page, and due
to the way SGX works, the bug is detected at freeing. Rather than
adding the page back to the pool of available EPC pages, the kernel
intentionally leaks the page to avoid additional errors in the future.</p>
<p>When this happens, the kernel will likely soon leak more EPC pages, and
SGX will likely become unusable because the memory available to SGX is
limited. However, while this may be fatal to SGX, the rest of the kernel
is unlikely to be impacted and should continue to work.</p>
<p>As a result, when this happpens, user should stop running any new
SGX workloads, (or just any new workloads), and migrate all valuable
workloads. Although a machine reboot can recover all EPC memory, the bug
should be reported to Linux developers.</p>
</section>
</section>
<section id="virtual-epc">
<h2><span class="section-number">31.9. </span>Virtual EPC<a class="headerlink" href="#virtual-epc" title="Permalink to this headline">¶</a></h2>
<p>The implementation has also a virtual EPC driver to support SGX enclaves
in guests. Unlike the SGX driver, an EPC page allocated by the virtual
EPC driver doesn’t have a specific enclave associated with it. This is
because KVM doesn’t track how a guest uses EPC pages.</p>
<p>As a result, the SGX core page reclaimer doesn’t support reclaiming EPC
pages allocated to KVM guests through the virtual EPC driver. If the
user wants to deploy SGX applications both on the host and in guests
on the same machine, the user should reserve enough EPC (by taking out
total virtual EPC size of all SGX VMs from the physical EPC size) for
host SGX applications so they can run with acceptable performance.</p>
<p>Architectural behavior is to restore all EPC pages to an uninitialized
state also after a guest reboot.  Because this state can be reached only
through the privileged <code class="docutils literal notranslate"><span class="pre">ENCLS[EREMOVE]</span></code> instruction, <code class="docutils literal notranslate"><span class="pre">/dev/sgx_vepc</span></code>
provides the <code class="docutils literal notranslate"><span class="pre">SGX_IOC_VEPC_REMOVE_ALL</span></code> ioctl to execute the instruction
on all pages in the virtual EPC.</p>
<p><code class="docutils literal notranslate"><span class="pre">EREMOVE</span></code> can fail for three reasons.  Userspace must pay attention
to expected failures and handle them as follows:</p>
<ol class="arabic simple">
<li><p>Page removal will always fail when any thread is running in the
enclave to which the page belongs.  In this case the ioctl will
return <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> independent of whether it has successfully removed
some pages; userspace can avoid these failures by preventing execution
of any vcpu which maps the virtual EPC.</p></li>
<li><p>Page removal will cause a general protection fault if two calls to
<code class="docutils literal notranslate"><span class="pre">EREMOVE</span></code> happen concurrently for pages that refer to the same
“SECS” metadata pages.  This can happen if there are concurrent
invocations to <code class="docutils literal notranslate"><span class="pre">SGX_IOC_VEPC_REMOVE_ALL</span></code>, or if a <code class="docutils literal notranslate"><span class="pre">/dev/sgx_vepc</span></code>
file descriptor in the guest is closed at the same time as
<code class="docutils literal notranslate"><span class="pre">SGX_IOC_VEPC_REMOVE_ALL</span></code>; it will also be reported as <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code>.
This can be avoided in userspace by serializing calls to the ioctl()
and to close(), but in general it should not be a problem.</p></li>
<li><p>Finally, page removal will fail for SECS metadata pages which still
have child pages.  Child pages can be removed by executing
<code class="docutils literal notranslate"><span class="pre">SGX_IOC_VEPC_REMOVE_ALL</span></code> on all <code class="docutils literal notranslate"><span class="pre">/dev/sgx_vepc</span></code> file descriptors
mapped into the guest.  This means that the ioctl() must be called
twice: an initial set of calls to remove child pages and a subsequent
set of calls to remove SECS pages.  The second set of calls is only
required for those mappings that returned a nonzero value from the
first call.  It indicates a bug in the kernel or the userspace client
if any of the second round of <code class="docutils literal notranslate"><span class="pre">SGX_IOC_VEPC_REMOVE_ALL</span></code> calls has
a return code other than 0.</p></li>
</ol>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">31. Software Guard eXtensions (SGX)</a><ul>
<li><a class="reference internal" href="#overview">31.1. Overview</a></li>
<li><a class="reference internal" href="#enclave-page-cache">31.2. Enclave Page Cache</a><ul>
<li><a class="reference internal" href="#enclave-page-types">31.2.1. Enclave Page Types</a></li>
<li><a class="reference internal" href="#enclave-page-cache-map">31.2.2. Enclave Page Cache Map</a></li>
</ul>
</li>
<li><a class="reference internal" href="#application-interface">31.3. Application interface</a><ul>
<li><a class="reference internal" href="#enclave-build-functions">31.3.1. Enclave build functions</a></li>
<li><a class="reference internal" href="#enclave-runtime-management">31.3.2. Enclave runtime management</a></li>
<li><a class="reference internal" href="#enclave-vdso">31.3.3. Enclave vDSO</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ksgxd">31.4. ksgxd</a><ul>
<li><a class="reference internal" href="#epc-sanitization">31.4.1. EPC sanitization</a></li>
<li><a class="reference internal" href="#page-reclaimer">31.4.2. Page reclaimer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#launch-control">31.5. Launch Control</a></li>
<li><a class="reference internal" href="#encryption-engines">31.6. Encryption engines</a></li>
<li><a class="reference internal" href="#usage-models">31.7. Usage Models</a><ul>
<li><a class="reference internal" href="#shared-library">31.7.1. Shared Library</a></li>
<li><a class="reference internal" href="#application-container">31.7.2. Application Container</a></li>
</ul>
</li>
<li><a class="reference internal" href="#impact-of-potential-kernel-sgx-bugs">31.8. Impact of Potential Kernel SGX Bugs</a><ul>
<li><a class="reference internal" href="#epc-leaks">31.8.1. EPC leaks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#virtual-epc">31.9. Virtual EPC</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/x86/sgx.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/x86/sgx.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>