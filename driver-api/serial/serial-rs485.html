
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>RS485 Serial Communications &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="SM501 Driver" href="../sm501.html" />
    <link rel="prev" title="ISO7816 Serial Communications" href="serial-iso7816.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="rs485-serial-communications">
<h1>RS485 Serial Communications<a class="headerlink" href="#rs485-serial-communications" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>EIA-485, also known as TIA/EIA-485 or RS-485, is a standard defining the
electrical characteristics of drivers and receivers for use in balanced
digital multipoint systems.
This standard is widely used for communications in industrial automation
because it can be used effectively over long distances and in electrically
noisy environments.</p>
</div></blockquote>
</section>
<section id="hardware-related-considerations">
<h2>2. Hardware-related Considerations<a class="headerlink" href="#hardware-related-considerations" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Some CPUs/UARTs (e.g., Atmel AT91 or 16C950 UART) contain a built-in
half-duplex mode capable of automatically controlling line direction by
toggling RTS or DTR signals. That can be used to control external
half-duplex hardware like an RS485 transceiver or any RS232-connected
half-duplex devices like some modems.</p>
<p>For these microcontrollers, the Linux driver should be made capable of
working in both modes, and proper ioctls (see later) should be made
available at user-level to allow switching from one mode to the other, and
vice versa.</p>
</div></blockquote>
</section>
<section id="data-structures-already-available-in-the-kernel">
<h2>3. Data Structures Already Available in the Kernel<a class="headerlink" href="#data-structures-already-available-in-the-kernel" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The Linux kernel provides the <a class="reference internal" href="#c.serial_rs485" title="serial_rs485"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">serial_rs485</span></code></a> to handle RS485
communications. This data structure is used to set and configure RS485
parameters in the platform data and in ioctls.</p>
<p>The device tree can also provide RS485 boot time parameters
<a class="footnote-reference brackets" href="#dt-bindings" id="id1">1</a>. The serial core fills the <a class="reference internal" href="#c.serial_rs485" title="serial_rs485"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">serial_rs485</span></code></a> from the
values given by the device tree when the driver calls
uart_get_rs485_mode().</p>
<p>Any driver for devices capable of working both as RS232 and RS485 should
implement the <code class="docutils literal notranslate"><span class="pre">rs485_config</span></code> callback and provide <code class="docutils literal notranslate"><span class="pre">rs485_supported</span></code>
in the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span></code>. The serial core calls <code class="docutils literal notranslate"><span class="pre">rs485_config</span></code> to do
the device specific part in response to TIOCSRS485 ioctl (see below). The
<code class="docutils literal notranslate"><span class="pre">rs485_config</span></code> callback receives a pointer to a sanitizated <a class="reference internal" href="#c.serial_rs485" title="serial_rs485"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">serial_rs485</span></code></a>. The <a class="reference internal" href="#c.serial_rs485" title="serial_rs485"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">serial_rs485</span></code></a> userspace provides is sanitized
before calling <code class="docutils literal notranslate"><span class="pre">rs485_config</span></code> using <code class="docutils literal notranslate"><span class="pre">rs485_supported</span></code> that indicates
what RS485 features the driver supports for the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uart_port</span></code>.
TIOCGRS485 ioctl can be used to read back the <a class="reference internal" href="#c.serial_rs485" title="serial_rs485"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">serial_rs485</span></code></a>
matching to the current configuration.</p>
</div></blockquote>
<dl class="type">
<dt id="c.serial_rs485">
struct <code class="sig-name descname">serial_rs485</code><a class="headerlink" href="#c.serial_rs485" title="Permalink to this definition">¶</a></dt>
<dd><p>serial interface for controlling RS485 settings.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct serial_rs485 {
    __u32 flags;
#define SER_RS485_ENABLED               (1 &lt;&lt; 0);
#define SER_RS485_RTS_ON_SEND           (1 &lt;&lt; 1);
#define SER_RS485_RTS_AFTER_SEND        (1 &lt;&lt; 2);
#define SER_RS485_RX_DURING_TX          (1 &lt;&lt; 4);
#define SER_RS485_TERMINATE_BUS         (1 &lt;&lt; 5);
#define SER_RS485_ADDRB                 (1 &lt;&lt; 6);
#define SER_RS485_ADDR_RECV             (1 &lt;&lt; 7);
#define SER_RS485_ADDR_DEST             (1 &lt;&lt; 8);
    __u32 delay_rts_before_send;
    __u32 delay_rts_after_send;
    union {
        __u32 padding[5];
        struct {
            __u8 addr_recv;
            __u8 addr_dest;
            __u8 padding0[2];
            __u32 padding1[4];
        };
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>RS485 feature flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delay_rts_before_send</span></code></dt><dd><p>Delay before send (milliseconds).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delay_rts_after_send</span></code></dt><dd><p>Delay after send (milliseconds).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">padding</span></code></dt><dd><p>Deprecated, use <strong>padding0</strong> and <strong>padding1</strong> instead.
Do not use with <strong>addr_recv</strong> and <strong>addr_dest</strong> (due to
overlap).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_recv</span></code></dt><dd><p>Receive filter for RS485 addressing mode
(used only when <code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDR_RECV</span></code> is set).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_dest</span></code></dt><dd><p>Destination address for RS485 addressing mode
(used only when <code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDR_DEST</span></code> is set).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">padding0</span></code></dt><dd><p>Padding (set to zero).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">padding1</span></code></dt><dd><p>Padding (set to zero).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Serial interface for controlling RS485 settings on chips with suitable
support. Set with TIOCSRS485 and get with TIOCGRS485 if supported by your
platform. The set function returns the new state, with any unsupported bits
reverted appropriately.</p>
<p>The flag bits are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SER_RS485_ENABLED</span></code>         - RS485 enabled.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SER_RS485_RTS_ON_SEND</span></code>     - Logical level for RTS pin when sending.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SER_RS485_RTS_AFTER_SEND</span></code>  - Logical level for RTS pin after sent.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SER_RS485_RX_DURING_TX</span></code>    - Full-duplex RS485 line.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SER_RS485_TERMINATE_BUS</span></code>   - Enable bus termination (if supported).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDRB</span></code>           - Enable RS485 addressing mode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDR_RECV</span></code> - Receive address filter (enables <strong>addr_recv</strong>). Requires <code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDRB</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDR_DEST</span></code> - Destination address (enables <strong>addr_dest</strong>). Requires <code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDRB</span></code>.</p></li>
</ul>
</section>
<section id="usage-from-user-level">
<h2>4. Usage from user-level<a class="headerlink" href="#usage-from-user-level" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>From user-level, RS485 configuration can be get/set using the previous
ioctls. For instance, to set RS485 you can use the following code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/serial.h&gt;

/* Include definition for RS485 ioctls: TIOCGRS485 and TIOCSRS485 */
#include &lt;sys/ioctl.h&gt;

/* Open your specific device (e.g., /dev/mydevice): */
int fd = open (&quot;/dev/mydevice&quot;, O_RDWR);
if (fd &lt; 0) {
        /* Error handling. See errno. */
}

struct serial_rs485 rs485conf;

/* Enable RS485 mode: */
rs485conf.flags |= SER_RS485_ENABLED;

/* Set logical level for RTS pin equal to 1 when sending: */
rs485conf.flags |= SER_RS485_RTS_ON_SEND;
/* or, set logical level for RTS pin equal to 0 when sending: */
rs485conf.flags &amp;= ~(SER_RS485_RTS_ON_SEND);

/* Set logical level for RTS pin equal to 1 after sending: */
rs485conf.flags |= SER_RS485_RTS_AFTER_SEND;
/* or, set logical level for RTS pin equal to 0 after sending: */
rs485conf.flags &amp;= ~(SER_RS485_RTS_AFTER_SEND);

/* Set rts delay before send, if needed: */
rs485conf.delay_rts_before_send = ...;

/* Set rts delay after send, if needed: */
rs485conf.delay_rts_after_send = ...;

/* Set this flag if you want to receive data even while sending data */
rs485conf.flags |= SER_RS485_RX_DURING_TX;

if (ioctl (fd, TIOCSRS485, &amp;rs485conf) &lt; 0) {
        /* Error handling. See errno. */
}

/* Use read() and write() syscalls here... */

/* Close the device when finished: */
if (close (fd) &lt; 0) {
        /* Error handling. See errno. */
}
</pre></div>
</div>
</div></blockquote>
</section>
<section id="multipoint-addressing">
<h2>5. Multipoint Addressing<a class="headerlink" href="#multipoint-addressing" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The Linux kernel provides addressing mode for multipoint RS-485 serial
communications line. The addressing mode is enabled with
<code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDRB</span></code> flag in <a class="reference internal" href="#c.serial_rs485" title="serial_rs485"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">serial_rs485</span></code></a>. The <a class="reference internal" href="#c.serial_rs485" title="serial_rs485"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">serial_rs485</span></code></a>
has two additional flags and fields for enabling receive and destination
addresses.</p>
<dl class="simple">
<dt>Address mode flags:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDRB</span></code>: Enabled addressing mode (sets also ADDRB in termios).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDR_RECV</span></code>: Receive (filter) address enabled.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDR_DEST</span></code>: Set destination address.</p></li>
</ul>
</dd>
<dt>Address fields (enabled with corresponding <code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDR_*</span></code> flag):</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">addr_recv</span></code>: Receive address.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">addr_dest</span></code>: Destination address.</p></li>
</ul>
</dd>
</dl>
<p>Once a receive address is set, the communication can occur only with the
particular device and other peers are filtered out. It is left up to the
receiver side to enforce the filtering. Receive address will be cleared
if <code class="docutils literal notranslate"><span class="pre">SER_RS485_ADDR_RECV</span></code> is not set.</p>
<p>Note: not all devices supporting RS485 support multipoint addressing.</p>
</div></blockquote>
</section>
<section id="references">
<h2>6. References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="dt-bindings"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Documentation/devicetree/bindings/serial/rs485.txt</p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">RS485 Serial Communications</a><ul>
<li><a class="reference internal" href="#introduction">1. Introduction</a></li>
<li><a class="reference internal" href="#hardware-related-considerations">2. Hardware-related Considerations</a></li>
<li><a class="reference internal" href="#data-structures-already-available-in-the-kernel">3. Data Structures Already Available in the Kernel</a></li>
<li><a class="reference internal" href="#usage-from-user-level">4. Usage from user-level</a></li>
<li><a class="reference internal" href="#multipoint-addressing">5. Multipoint Addressing</a></li>
<li><a class="reference internal" href="#references">6. References</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/serial/serial-rs485.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/serial/serial-rs485.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>