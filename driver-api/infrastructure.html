
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Device drivers infrastructure &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ioctl based interfaces" href="ioctl.html" />
    <link rel="prev" title="Driver Basics" href="basics.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="device-drivers-infrastructure">
<h1>Device drivers infrastructure<a class="headerlink" href="#device-drivers-infrastructure" title="Permalink to this headline">¶</a></h1>
<section id="the-basic-device-driver-model-structures">
<h2>The Basic Device Driver-Model Structures<a class="headerlink" href="#the-basic-device-driver-model-structures" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.subsys_interface">
struct <code class="sig-name descname">subsys_interface</code><a class="headerlink" href="#c.subsys_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>interfaces to device functions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct subsys_interface {
    const char *name;
    struct bus_type *subsys;
    struct list_head node;
    int (*add_dev)(struct device *dev, struct subsys_interface *sif);
    void (*remove_dev)(struct device *dev, struct subsys_interface *sif);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the device function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subsys</span></code></dt><dd><p>subsystem of the devices to attach to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>the list of functions registered at the subsystem</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_dev</span></code></dt><dd><p>device hookup to device function handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove_dev</span></code></dt><dd><p>device hookup to device function handler</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Simple interfaces attached to a subsystem. Multiple interfaces can
attach to a subsystem and its devices. Unlike drivers, they do not
exclusively claim or control devices. Interfaces usually represent
a specific functionality of a subsystem/class of devices.</p>
<dl class="function">
<dt id="c.devm_alloc_percpu">
<code class="sig-name descname">devm_alloc_percpu</code><span class="sig-paren">(</span><em>dev</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_alloc_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed alloc_percpu</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Device to allocate per-cpu memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Type to allocate per-cpu memory for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed alloc_percpu. Per-cpu memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
</div>
<dl class="type">
<dt id="c.dl_dev_state">
enum <code class="sig-name descname">dl_dev_state</code><a class="headerlink" href="#c.dl_dev_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Device driver presence tracking information.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_NO_DRIVER</span></code></dt><dd><p>There is no driver attached to the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_PROBING</span></code></dt><dd><p>A driver is probing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_DRIVER_BOUND</span></code></dt><dd><p>The driver has been bound to the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_DEV_UNBINDING</span></code></dt><dd><p>The driver is unbinding from the device.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.device_removable">
enum <code class="sig-name descname">device_removable</code><a class="headerlink" href="#c.device_removable" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the device is removable. The criteria for a device to be classified as removable is determined by its subsystem or bus.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_REMOVABLE_NOT_SUPPORTED</span></code></dt><dd><p>This attribute is not supported for this
device (default).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_REMOVABLE_UNKNOWN</span></code></dt><dd><p>Device location is Unknown.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_FIXED</span></code></dt><dd><p>Device is not removable by the user.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_REMOVABLE</span></code></dt><dd><p>Device is removable by the user.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dev_links_info">
struct <code class="sig-name descname">dev_links_info</code><a class="headerlink" href="#c.dev_links_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Device data related to device links.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dev_links_info {
    struct list_head suppliers;
    struct list_head consumers;
    struct list_head defer_sync;
    enum dl_dev_state status;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">suppliers</span></code></dt><dd><p>List of links to supplier devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">consumers</span></code></dt><dd><p>List of links to consumer devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">defer_sync</span></code></dt><dd><p>Hook to global list of devices that have deferred sync_state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>Driver status information.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dev_msi_info">
struct <code class="sig-name descname">dev_msi_info</code><a class="headerlink" href="#c.dev_msi_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Device data related to MSI</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dev_msi_info {
#ifdef CONFIG_GENERIC_MSI_IRQ;
    struct irq_domain       *domain;
    struct msi_device_data  *data;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">domain</span></code></dt><dd><p>The MSI interrupt domain associated to the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Pointer to MSI device data</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.device_physical_location_panel">
enum <code class="sig-name descname">device_physical_location_panel</code><a class="headerlink" href="#c.device_physical_location_panel" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes which panel surface of the system’s housing the device connection point resides on.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_TOP</span></code></dt><dd><p>Device connection point is on the top panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_BOTTOM</span></code></dt><dd><p>Device connection point is on the bottom panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_LEFT</span></code></dt><dd><p>Device connection point is on the left panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_RIGHT</span></code></dt><dd><p>Device connection point is on the right panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_FRONT</span></code></dt><dd><p>Device connection point is on the front panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_BACK</span></code></dt><dd><p>Device connection point is on the back panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_PANEL_UNKNOWN</span></code></dt><dd><p>The panel with device connection point is unknown.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.device_physical_location_vertical_position">
enum <code class="sig-name descname">device_physical_location_vertical_position</code><a class="headerlink" href="#c.device_physical_location_vertical_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes vertical position of the device connection point on the panel surface.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_VERT_POS_UPPER</span></code></dt><dd><p>Device connection point is at upper part of panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_VERT_POS_CENTER</span></code></dt><dd><p>Device connection point is at center part of panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_VERT_POS_LOWER</span></code></dt><dd><p>Device connection point is at lower part of panel.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.device_physical_location_horizontal_position">
enum <code class="sig-name descname">device_physical_location_horizontal_position</code><a class="headerlink" href="#c.device_physical_location_horizontal_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes horizontal position of the device connection point on the panel surface.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_HORI_POS_LEFT</span></code></dt><dd><p>Device connection point is at left part of panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_HORI_POS_CENTER</span></code></dt><dd><p>Device connection point is at center part of panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEVICE_HORI_POS_RIGHT</span></code></dt><dd><p>Device connection point is at right part of panel.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.device_physical_location">
struct <code class="sig-name descname">device_physical_location</code><a class="headerlink" href="#c.device_physical_location" title="Permalink to this definition">¶</a></dt>
<dd><p>Device data related to physical location of the device connection point.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device_physical_location {
    enum device_physical_location_panel panel;
    enum device_physical_location_vertical_position vertical_position;
    enum device_physical_location_horizontal_position horizontal_position;
    bool dock;
    bool lid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">panel</span></code></dt><dd><p>Panel surface of the system’s housing that the device connection
point resides on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vertical_position</span></code></dt><dd><p>Vertical position of the device connection point within
the panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">horizontal_position</span></code></dt><dd><p>Horizontal position of the device connection point
within the panel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dock</span></code></dt><dd><p>Set if the device connection point resides in a docking station or
port replicator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lid</span></code></dt><dd><p>Set if this device connection point resides on the lid of laptop
system.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.device">
struct <code class="sig-name descname">device</code><a class="headerlink" href="#c.device" title="Permalink to this definition">¶</a></dt>
<dd><p>The basic device structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device {
    struct kobject kobj;
    struct device           *parent;
    struct device_private   *p;
    const char              *init_name;
    const struct device_type *type;
    struct bus_type *bus;
    struct device_driver *driver;
    void *platform_data;
    void *driver_data;
    struct mutex            mutex;
    struct dev_links_info   links;
    struct dev_pm_info      power;
    struct dev_pm_domain    *pm_domain;
#ifdef CONFIG_ENERGY_MODEL;
    struct em_perf_domain   *em_pd;
#endif;
#ifdef CONFIG_PINCTRL;
    struct dev_pin_info     *pins;
#endif;
    struct dev_msi_info     msi;
#ifdef CONFIG_DMA_OPS;
    const struct dma_map_ops *dma_ops;
#endif;
    u64 *dma_mask;
    u64 coherent_dma_mask;
    u64 bus_dma_limit;
    const struct bus_dma_region *dma_range_map;
    struct device_dma_parameters *dma_parms;
    struct list_head        dma_pools;
#ifdef CONFIG_DMA_DECLARE_COHERENT;
    struct dma_coherent_mem *dma_mem;
#endif;
#ifdef CONFIG_DMA_CMA;
    struct cma *cma_area;
#endif;
#ifdef CONFIG_SWIOTLB;
    struct io_tlb_mem *dma_io_tlb_mem;
#endif;
    struct dev_archdata     archdata;
    struct device_node      *of_node;
    struct fwnode_handle    *fwnode;
#ifdef CONFIG_NUMA;
    int numa_node;
#endif;
    dev_t devt;
    u32 id;
    spinlock_t devres_lock;
    struct list_head        devres_head;
    struct class            *class;
    const struct attribute_group **groups;
    void (*release)(struct device *dev);
    struct iommu_group      *iommu_group;
    struct dev_iommu        *iommu;
    struct device_physical_location *physical_location;
    enum device_removable   removable;
    bool offline_disabled:1;
    bool offline:1;
    bool of_node_reused:1;
    bool state_synced:1;
    bool can_match:1;
#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) ||     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) ||     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL);
    bool dma_coherent:1;
#endif;
#ifdef CONFIG_DMA_OPS_BYPASS;
    bool dma_ops_bypass : 1;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">kobj</span></code></dt><dd><p>A top-level, abstract class from which other classes are derived.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>The device’s “parent” device, the device to which it is attached.
In most cases, a parent device is some sort of bus or host
controller. If parent is NULL, the device, is a top-level device,
which is not usually what you want.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>Holds the private data of the driver core portions of the device.
See the comment of the struct device_private for detail.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_name</span></code></dt><dd><p>Initial name of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>The type of device.
This identifies the device type and carries type-specific
information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus</span></code></dt><dd><p>Type of bus device is on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>Which driver has allocated this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">platform_data</span></code></dt><dd><p>Platform data specific to the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>Private pointer for driver specific info.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>Mutex to synchronize calls to its driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">links</span></code></dt><dd><p>Links to suppliers and consumers of this device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">power</span></code></dt><dd><p>For device power management.
See <a class="reference internal" href="pm/devices.html"><span class="doc">Device Power Management Basics</span></a> for details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm_domain</span></code></dt><dd><p>Provide callbacks that are executed during system suspend,
hibernation, system resume and during runtime PM transitions
along with subsystem-level and driver-level callbacks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">em_pd</span></code></dt><dd><p>device’s energy model performance domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pins</span></code></dt><dd><p>For device pin management.
See <a class="reference internal" href="pin-control.html"><span class="doc">PINCTRL (PIN CONTROL) subsystem</span></a> for details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msi</span></code></dt><dd><p>MSI related data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_ops</span></code></dt><dd><p>DMA mapping operations for this device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_mask</span></code></dt><dd><p>Dma mask (if dma’ble device).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">coherent_dma_mask</span></code></dt><dd><p>Like dma_mask, but for alloc_coherent mapping as not all
hardware supports 64-bit addresses for consistent allocations
such descriptors.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_dma_limit</span></code></dt><dd><p>Limit of an upstream bridge or bus which imposes a smaller
DMA limit than the device itself supports.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_range_map</span></code></dt><dd><p>map for DMA memory ranges relative to that of RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_parms</span></code></dt><dd><p>A low level driver may set these to teach IOMMU code about
segment limitations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_pools</span></code></dt><dd><p>Dma pools (if dma’ble device).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_mem</span></code></dt><dd><p>Internal for coherent mem override.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cma_area</span></code></dt><dd><p>Contiguous memory area for dma allocations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_io_tlb_mem</span></code></dt><dd><p>Pointer to the swiotlb pool used.  Not for driver use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">archdata</span></code></dt><dd><p>For arch-specific additions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt><dd><p>Associated device tree node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt><dd><p>Associated device node supplied by platform firmware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">numa_node</span></code></dt><dd><p>NUMA node this device is close to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devt</span></code></dt><dd><p>For creating the sysfs “dev”.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devres_lock</span></code></dt><dd><p>Spinlock to protect the resource of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devres_head</span></code></dt><dd><p>The resources list of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">class</span></code></dt><dd><p>The class of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">groups</span></code></dt><dd><p>Optional attribute groups.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>Callback to free the device after all references have
gone away. This should be set by the allocator of the
device (i.e. the bus driver that discovered the device).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iommu_group</span></code></dt><dd><p>IOMMU group the device belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iommu</span></code></dt><dd><p>Per device generic IOMMU runtime data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">physical_location</span></code></dt><dd><p>Describes physical location of the device connection
point in the system housing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">removable</span></code></dt><dd><p>Whether the device can be removed from the system. This
should be set by the subsystem / bus driver that discovered
the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offline_disabled</span></code></dt><dd><p>If set, the device is permanently online.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offline</span></code></dt><dd><p>Set after successful invocation of bus type’s .offline().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node_reused</span></code></dt><dd><p>Set if the device-tree node is shared with an ancestor
device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_synced</span></code></dt><dd><p>The hardware state of this device has been synced to match
the software state of this device by calling the driver/bus
sync_state() callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">can_match</span></code></dt><dd><p>The device has matched with a driver at least once or it is in
a bus (like AMBA) which can’t check for matching drivers until
other devices probe successfully.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_coherent</span></code></dt><dd><p>this particular device is dma coherent, even if the
architecture supports non-coherent devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_ops_bypass</span></code></dt><dd><p>If set to <code class="docutils literal notranslate"><span class="pre">true</span></code> then the dma_ops are bypassed for the
streaming DMA operations (-&gt;map_* / -&gt;unmap_* / -&gt;sync_*),
and optionall (if the coherent mask is large enough) also
for dma allocations.  This flag is managed by the dma ops
instance from -&gt;dma_supported.</p>
</dd>
</dl>
</div>
<p><strong>Example</strong></p>
<dl class="simple">
<dt>For devices on custom boards, as typical of embedded</dt><dd><p>and SOC based hardware, Linux often uses platform_data to point
to board-specific structures describing devices and how they
are wired.  That can include what ports are available, chip
variants, which GPIO pins act in what additional roles, and so
on.  This shrinks the “Board Support Packages” (BSPs) and
minimizes board-specific #ifdefs in drivers.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>At the lowest level, every device in a Linux system is represented by an
instance of <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>. The device structure contains the information
that the device model core needs to model the system. Most subsystems,
however, track additional information about the devices they host. As a
result, it is rare for devices to be represented by bare device structures;
instead, that structure, like kobject structures, is usually embedded within
a higher-level representation of the device.</p>
<dl class="type">
<dt id="c.device_link">
struct <code class="sig-name descname">device_link</code><a class="headerlink" href="#c.device_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Device link representation.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device_link {
    struct device *supplier;
    struct list_head s_node;
    struct device *consumer;
    struct list_head c_node;
    struct device link_dev;
    enum device_link_state status;
    u32 flags;
    refcount_t rpm_active;
    struct kref kref;
    struct work_struct rm_work;
    bool supplier_preactivated;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">supplier</span></code></dt><dd><p>The device on the supplier end of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_node</span></code></dt><dd><p>Hook to the supplier device’s list of links to consumers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">consumer</span></code></dt><dd><p>The device on the consumer end of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c_node</span></code></dt><dd><p>Hook to the consumer device’s list of links to suppliers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_dev</span></code></dt><dd><p>device used to expose link details in sysfs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>The state of the link (with respect to the presence of drivers).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Link flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rpm_active</span></code></dt><dd><p>Whether or not the consumer device is runtime-PM-active.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt><dd><p>Count repeated addition of the same link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rm_work</span></code></dt><dd><p>Work structure used for removing the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supplier_preactivated</span></code></dt><dd><p>Supplier has been made active before consumer probe.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.device_iommu_mapped">
bool <code class="sig-name descname">device_iommu_mapped</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_iommu_mapped" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true when the device DMA is translated by an IOMMU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to perform the check on</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_bus_name">
const char * <code class="sig-name descname">dev_bus_name</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_bus_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a device’s bus/class name, if at all possible</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p><a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> to get the bus/class name of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will return the name of the bus/class the device is attached to.  If it is
not attached to a bus/class, an empty string will be returned.</p>
</div>
<dl class="function">
<dt id="c.device_lock_set_class">
<code class="sig-name descname">device_lock_set_class</code><span class="sig-paren">(</span><em>dev</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_lock_set_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify a temporary lock class while a device is attached to a driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>lock class key data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called with the device_lock() already held, for example
from driver -&gt;probe(). Take care to only override the default
lockdep_no_validate class.</p>
</div>
<dl class="function">
<dt id="c.device_lock_reset_class">
<code class="sig-name descname">device_lock_reset_class</code><span class="sig-paren">(</span><em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_lock_reset_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a device to the default lockdep novalidate state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device to modify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called with the device_lock() already held, for example
from driver -&gt;remove().</p>
</div>
</section>
<section id="device-drivers-base">
<h2>Device Drivers Base<a class="headerlink" href="#device-drivers-base" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.driver_init">
void <code class="sig-name descname">driver_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.driver_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize driver model.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call the driver model init functions to initialize their
subsystems. Called early from init/main.c.</p>
</div>
<dl class="function">
<dt id="c.driver_set_override">
int <code class="sig-name descname">driver_set_override</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, const char<em> **override</em>, const char<em> *s</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_set_override" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to set or clear driver override.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">**override</span></code></dt><dd><p>Address of string to change (e.g. <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device-&gt;driver_override</span></code></a>);
The contents will be freed and hold newly allocated override.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>NUL-terminated string, new driver name to force a match, pass empty
string to clear it (”” or “n”, where the latter is only for sysfs
interface).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of <strong>s</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to set or clear driver override in a device, intended for the cases
when the driver_override field is allocated by driver/bus code.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.driver_for_each_device">
int <code class="sig-name descname">driver_for_each_device</code><span class="sig-paren">(</span>struct device_driver<em> *drv</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *start</em>, void<em> *data</em>, int (<em>*fn</em>)(struct <a class="reference internal" href="#c.device" title="device">device</a> *, void *)<span class="sig-paren">)</span><a class="headerlink" href="#c.driver_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator for devices bound to a driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>Driver we’re iterating.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>Device to begin with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to pass to the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Function to call for each device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the <strong>drv</strong>’s list of devices calling <strong>fn</strong> for each one.</p>
</div>
<dl class="function">
<dt id="c.driver_find_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">driver_find_device</code><span class="sig-paren">(</span>struct device_driver<em> *drv</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *start</em>, const void<em> *data</em>, int (<em>*match</em>)(struct <a class="reference internal" href="#c.device" title="device">device</a> *dev, const void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find_device" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>The device’s driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>Device to begin with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to pass to match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*match)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>Callback function to check device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.driver_for_each_device" title="driver_for_each_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">driver_for_each_device()</span></code></a> function above, but
it returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
</div>
<dl class="function">
<dt id="c.driver_create_file">
int <code class="sig-name descname">driver_create_file</code><span class="sig-paren">(</span>struct device_driver<em> *drv</em>, const struct driver_attribute<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create sysfs file for driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">driver_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>driver attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.driver_remove_file">
void <code class="sig-name descname">driver_remove_file</code><span class="sig-paren">(</span>struct device_driver<em> *drv</em>, const struct driver_attribute<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_remove_file" title="Permalink to this definition">¶</a></dt>
<dd><p>remove sysfs file for driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">driver_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>driver attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.driver_register">
int <code class="sig-name descname">driver_register</code><span class="sig-paren">(</span>struct device_driver<em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register driver with bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>driver to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We pass off most of the work to the bus_add_driver() call,
since most of the things we have to do deal with the bus
structures.</p>
</div>
<dl class="function">
<dt id="c.driver_unregister">
void <code class="sig-name descname">driver_unregister</code><span class="sig-paren">(</span>struct device_driver<em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>remove driver from system.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Again, we pass off most of the work to the bus-level call.</p>
</div>
<dl class="function">
<dt id="c.driver_find">
struct device_driver * <code class="sig-name descname">driver_find</code><span class="sig-paren">(</span>const char<em> *name</em>, struct bus_type<em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find" title="Permalink to this definition">¶</a></dt>
<dd><p>locate driver on a bus by its name.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus to scan for the driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <a class="reference internal" href="basics.html#c.kset_find_obj" title="kset_find_obj"><code class="xref c c-func docutils literal notranslate"><span class="pre">kset_find_obj()</span></code></a> to iterate over list of drivers on
a bus to find driver by name. Return driver if found.</p>
<p>This routine provides no locking to prevent the driver it returns
from being unregistered or unloaded while the caller is using it.
The caller is responsible for preventing this.</p>
</div>
<dl class="function">
<dt id="c.device_link_add">
struct <a class="reference internal" href="#c.device_link" title="device_link">device_link</a> * <code class="sig-name descname">device_link_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *consumer</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *supplier</em>, u32<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a link between two devices.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*consumer</span></code></dt><dd><p>Consumer end of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*supplier</span></code></dt><dd><p>Supplier end of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>Link flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller is responsible for the proper synchronization of the link creation
with runtime PM.  First, setting the DL_FLAG_PM_RUNTIME flag will cause the
runtime PM framework to take the link into account.  Second, if the
DL_FLAG_RPM_ACTIVE flag is set in addition to it, the supplier devices will
be forced into the active meta state and reference-counted upon the creation
of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
ignored.</p>
<p>If DL_FLAG_STATELESS is set in <strong>flags</strong>, the caller of this function is
expected to release the link returned by it directly with the help of either
<a class="reference internal" href="#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> or <a class="reference internal" href="#c.device_link_remove" title="device_link_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_remove()</span></code></a>.</p>
<p>If that flag is not set, however, the caller of this function is handing the
management of the link over to the driver core entirely and its return value
can only be used to check whether or not the link is present.  In that case,
the DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_AUTOREMOVE_SUPPLIER device link
flags can be used to indicate to the driver core when the link can be safely
deleted.  Namely, setting one of them in <strong>flags</strong> indicates to the driver core
that the link is not going to be used (by the given caller of this function)
after unbinding the consumer or supplier driver, respectively, from its
device, so the link can be deleted at that point.  If none of them is set,
the link will be maintained until one of the devices pointed to by it (either
the consumer or the supplier) is unregistered.</p>
<p>Also, if DL_FLAG_STATELESS, DL_FLAG_AUTOREMOVE_CONSUMER and
DL_FLAG_AUTOREMOVE_SUPPLIER are not set in <strong>flags</strong> (that is, a persistent
managed device link is being added), the DL_FLAG_AUTOPROBE_CONSUMER flag can
be used to request the driver core to automatically probe for a consumer
driver after successfully binding a driver to the supplier device.</p>
<p>The combination of DL_FLAG_STATELESS and one of DL_FLAG_AUTOREMOVE_CONSUMER,
DL_FLAG_AUTOREMOVE_SUPPLIER, or DL_FLAG_AUTOPROBE_CONSUMER set in <strong>flags</strong> at
the same time is invalid and will cause NULL to be returned upfront.
However, if a device link between the given <strong>consumer</strong> and <strong>supplier</strong> pair
exists already when this function is called for them, the existing link will
be returned regardless of its current type and status (the link’s flags may
be modified then).  The caller of this function is then expected to treat
the link as though it has just been created, so (in particular) if
DL_FLAG_STATELESS was passed in <strong>flags</strong>, the link needs to be released
explicitly when not needed any more (as stated above).</p>
<p>A side effect of the link creation is re-ordering of dpm_list and the
devices_kset list by moving the consumer device and all devices depending
on it to the ends of these lists (that does not happen to devices that have
not been registered when this function is called).</p>
<p>The supplier device is required to be registered when this function is called
and NULL will be returned if that is not the case.  The consumer device need
not be registered, however.</p>
</div>
<dl class="function">
<dt id="c.device_link_del">
void <code class="sig-name descname">device_link_del</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_link" title="device_link">device_link</a><em> *link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_del" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a stateless link between two devices.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_link</span> <span class="pre">*link</span></code></dt><dd><p>Device link to delete.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must ensure proper synchronization of this function with runtime
PM.  If the link was added multiple times, it needs to be deleted as often.
Care is required for hotplugged devices:  Their links are purged on removal
and calling <a class="reference internal" href="#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> is then no longer allowed.</p>
</div>
<dl class="function">
<dt id="c.device_link_remove">
void <code class="sig-name descname">device_link_remove</code><span class="sig-paren">(</span>void<em> *consumer</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *supplier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a stateless link between two devices.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*consumer</span></code></dt><dd><p>Consumer end of the link.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*supplier</span></code></dt><dd><p>Supplier end of the link.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must ensure proper synchronization of this function with runtime
PM.</p>
</div>
<dl class="function">
<dt id="c.dev_driver_string">
const char * <code class="sig-name descname">dev_driver_string</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_driver_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a device’s driver name, if at all possible</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p><a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> to get the name of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will return the device’s driver’s name if it is bound to a device.  If
the device is not bound to a driver, it will return the name of the bus
it is attached to.  If it is not attached to a bus either, an empty
string will be returned.</p>
</div>
<dl class="function">
<dt id="c.devm_device_add_group">
int <code class="sig-name descname">devm_device_add_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, const struct attribute_group<em> *grp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_device_add_group" title="Permalink to this definition">¶</a></dt>
<dd><p>given a device, create a managed attribute group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The device to create the group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">*grp</span></code></dt><dd><p>The attribute group to create</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a group for the first time.  It will explicitly
warn and error if any of the attribute files being created already exist.</p>
<p>Returns 0 on success or error code on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_device_add_groups">
int <code class="sig-name descname">devm_device_add_groups</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, const struct attribute_group<em> **groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_device_add_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>create a bunch of managed attribute groups</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The device to create the group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**groups</span></code></dt><dd><p>The attribute groups to create, NULL terminated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a bunch of managed attribute groups.  If an error
occurs when creating a group, all previously created groups will be
removed, unwinding everything back to the original state when this
function was called.  It will explicitly warn and error if any of the
attribute files being created already exist.</p>
<p>Returns 0 on success or error code from sysfs_create_group on failure.</p>
</div>
<dl class="function">
<dt id="c.device_create_file">
int <code class="sig-name descname">device_create_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, const struct device_attribute<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create sysfs attribute file for device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>device attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.device_remove_file">
void <code class="sig-name descname">device_remove_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, const struct device_attribute<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_file" title="Permalink to this definition">¶</a></dt>
<dd><p>remove sysfs attribute file.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>device attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.device_remove_file_self">
bool <code class="sig-name descname">device_remove_file_self</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, const struct device_attribute<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_file_self" title="Permalink to this definition">¶</a></dt>
<dd><p>remove sysfs attribute file from its own method.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>device attribute descriptor.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See kernfs_remove_self() for details.</p>
</div>
<dl class="function">
<dt id="c.device_create_bin_file">
int <code class="sig-name descname">device_create_bin_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, const struct bin_attribute<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_bin_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create sysfs binary attribute file for device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>device binary attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.device_remove_bin_file">
void <code class="sig-name descname">device_remove_bin_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, const struct bin_attribute<em> *attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_bin_file" title="Permalink to this definition">¶</a></dt>
<dd><p>remove sysfs binary attribute file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>device binary attribute descriptor.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.device_initialize">
void <code class="sig-name descname">device_initialize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>init device structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prepares the device for use by other layers by initializing
its fields.
It is the first half of <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>, if called by
that function, though it can also be called separately, so one
may use <strong>dev</strong>’s fields. In particular, <a class="reference internal" href="#c.get_device" title="get_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_device()</span></code></a>/<a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a>
may be used for reference counting of <strong>dev</strong> after calling this
function.</p>
<p>All fields in <strong>dev</strong> must be initialized by the caller to 0, except
for those explicitly set to some other value.  The simplest
approach is to use <a class="reference internal" href="../core-api/mm-api.html#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a> to allocate the structure containing
<strong>dev</strong>.</p>
<p><strong>NOTE</strong></p>
<p>Use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to give up your reference instead of freeing
<strong>dev</strong> directly once you have called this function.</p>
</div>
<dl class="function">
<dt id="c.dev_set_name">
int <code class="sig-name descname">dev_set_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>set a device name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format string for the device’s name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.device_add">
int <code class="sig-name descname">device_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add device to device hierarchy.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is part 2 of <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>, though may be called
separately _iff_ <a class="reference internal" href="#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_initialize()</span></code></a> has been called separately.</p>
<p>This adds <strong>dev</strong> to the kobject hierarchy via <a class="reference internal" href="basics.html#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a>, adds it
to the global and sibling lists for the device, then
adds it to the other relevant subsystems of the driver model.</p>
<p>Do not call this routine or <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a> more than once for
any device structure.  The driver model core is not designed to work
with devices that get unregistered and then spring back to life.
(Among other things, it’s very hard to guarantee that all references
to the previous incarnation of <strong>dev</strong> have been dropped.)  Allocate
and register a fresh new <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> instead.</p>
<p>Rule of thumb is: if <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a> succeeds, you should call
<a class="reference internal" href="#c.device_del" title="device_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_del()</span></code></a> when you want to get rid of it. If <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a> has
<em>not</em> succeeded, use <em>only</em> <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to drop the reference
count.</p>
<p><strong>NOTE</strong></p>
<p>_Never_ directly free <strong>dev</strong> after calling this function, even
if it returned an error! Always use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to give up your
reference instead.</p>
</div>
<dl class="function">
<dt id="c.device_register">
int <code class="sig-name descname">device_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a device with the system.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This happens in two clean steps - initialize the device
and add it to the system. The two steps can be called
separately, but this is the easiest and most common.
I.e. you should only call the two helpers separately if
have a clearly defined need to use and refcount the device
before it is added to the hierarchy.</p>
<p>For more information, see the kerneldoc for <a class="reference internal" href="#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_initialize()</span></code></a>
and <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>_Never_ directly free <strong>dev</strong> after calling this function, even
if it returned an error! Always use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> to give up the
reference initialized in this function instead.</p>
</div>
<dl class="function">
<dt id="c.get_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">get_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>increment reference count for device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This simply forwards the call to <a class="reference internal" href="basics.html#c.kobject_get" title="kobject_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_get()</span></code></a>, though
we do take care to provide for the case that we get a NULL
pointer passed in.</p>
</div>
<dl class="function">
<dt id="c.put_device">
void <code class="sig-name descname">put_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.put_device" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement reference count.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device in question.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.device_del">
void <code class="sig-name descname">device_del</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_del" title="Permalink to this definition">¶</a></dt>
<dd><p>delete device from system.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the first part of the device unregistration
sequence. This removes the device from the lists we control
from here, has it removed from the other driver model
subsystems it was added to in <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a>, and removes it
from the kobject hierarchy.</p>
<p><strong>NOTE</strong></p>
<p>this should be called manually _iff_ <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a> was
also called manually.</p>
</div>
<dl class="function">
<dt id="c.device_unregister">
void <code class="sig-name descname">device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister device from system.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device going away.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We do this in two parts, like we do <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>. First,
we remove it from all the subsystems with <a class="reference internal" href="#c.device_del" title="device_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_del()</span></code></a>, then
we decrement the reference count via <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a>. If that
is the final reference count, the device will be cleaned up
via device_release() above. Otherwise, the structure will
stick around until the final reference to the device is dropped.</p>
</div>
<dl class="function">
<dt id="c.device_for_each_child">
int <code class="sig-name descname">device_for_each_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *parent</em>, void<em> *data</em>, int (<em>*fn</em>)(struct <a class="reference internal" href="#c.device" title="device">device</a> *dev, void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.device_for_each_child" title="Permalink to this definition">¶</a></dt>
<dd><p>device child iterator.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data for the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>function to be called for each device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>parent</strong>’s child devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
</div>
<dl class="function">
<dt id="c.device_for_each_child_reverse">
int <code class="sig-name descname">device_for_each_child_reverse</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *parent</em>, void<em> *data</em>, int (<em>*fn</em>)(struct <a class="reference internal" href="#c.device" title="device">device</a> *dev, void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.device_for_each_child_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>device child iterator in reversed order.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data for the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>function to be called for each device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>parent</strong>’s child devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
</div>
<dl class="function">
<dt id="c.device_find_child">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">device_find_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *parent</em>, void<em> *data</em>, int (<em>*match</em>)(struct <a class="reference internal" href="#c.device" title="device">device</a> *dev, void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.device_find_child" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to pass to match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*match)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>Callback function to check device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.device_for_each_child" title="device_for_each_child"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_for_each_child()</span></code></a> function above, but it
returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero and a reference to the
current device can be obtained, this function will return to the caller
and not iterate over any more devices.</p>
<p><strong>NOTE</strong></p>
<p>you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> after use.</p>
</div>
<dl class="function">
<dt id="c.device_find_child_by_name">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">device_find_child_by_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *parent</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_find_child_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator for locating a child device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the child device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.device_find_child" title="device_find_child"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_find_child()</span></code></a> function above, but it
returns a reference to a device that has the name <strong>name</strong>.</p>
<p><strong>NOTE</strong></p>
<p>you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> after use.</p>
</div>
<dl class="function">
<dt id="c.device_find_any_child">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">device_find_any_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_find_any_child" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator for locating a child device, if any.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.device_find_child" title="device_find_child"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_find_child()</span></code></a> function above, but it
returns a reference to a child device, if any.</p>
<p><strong>NOTE</strong></p>
<p>you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> after use.</p>
</div>
<dl class="function">
<dt id="c.__root_device_register">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">__root_device_register</code><span class="sig-paren">(</span>const char<em> *name</em>, struct module<em> *owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__root_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and register a root device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>root device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owner module of the root device, usually THIS_MODULE</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates a root device and registers it
using <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_register()</span></code></a>. In order to free the returned
device, use <a class="reference internal" href="#c.root_device_unregister" title="root_device_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">root_device_unregister()</span></code></a>.</p>
<p>Root devices are dummy devices which allow other devices
to be grouped under /sys/devices. Use this function to
allocate a root device and then use it as the parent of
any device which should appear under /sys/devices/{name}</p>
<p>The /sys/devices/{name} directory will also contain a
‘module’ symlink which points to the <strong>owner</strong> directory
in sysfs.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or ERR_PTR() on error.</p>
<p><strong>Note</strong></p>
<p>You probably want to use root_device_register().</p>
</div>
<dl class="function">
<dt id="c.root_device_unregister">
void <code class="sig-name descname">root_device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.root_device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister and free a root device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device going away</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters and cleans up a device that was created by
root_device_register().</p>
</div>
<dl class="function">
<dt id="c.device_create">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">device_create</code><span class="sig-paren">(</span>struct class<em> *class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *parent</em>, dev_t<em> devt</em>, void<em> *drvdata</em>, const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.device_create" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a device and registers it with sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>pointer to the struct class that this device should be registered to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>pointer to the parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> of this new device, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt><dd><p>the dev_t for the char device to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*drvdata</span></code></dt><dd><p>the data to be added to the device for callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>string for the device’s name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by char device classes.  A <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>
will be created in sysfs, registered to the specified class.</p>
<p>A “dev” file will be created, showing the dev_t for the device, if
the dev_t is not 0,0.
If a pointer to a parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> is passed in, the newly created
<a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> will be a child of that device in sysfs.
The pointer to the <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or ERR_PTR() on error.</p>
<p><strong>Note</strong></p>
<p>the struct class passed to this function must have previously
been created with a call to class_create().</p>
</div>
<dl class="function">
<dt id="c.device_create_with_groups">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">device_create_with_groups</code><span class="sig-paren">(</span>struct class<em> *class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *parent</em>, dev_t<em> devt</em>, void<em> *drvdata</em>, const struct attribute_group<em> **groups</em>, const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_with_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a device and registers it with sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>pointer to the struct class that this device should be registered to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>pointer to the parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> of this new device, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt><dd><p>the dev_t for the char device to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*drvdata</span></code></dt><dd><p>the data to be added to the device for callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**groups</span></code></dt><dd><p>NULL-terminated list of attribute groups to be created</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>string for the device’s name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by char device classes.  A <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>
will be created in sysfs, registered to the specified class.
Additional attributes specified in the groups parameter will also
be created automatically.</p>
<p>A “dev” file will be created, showing the dev_t for the device, if
the dev_t is not 0,0.
If a pointer to a parent <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> is passed in, the newly created
<a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> will be a child of that device in sysfs.
The pointer to the <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or ERR_PTR() on error.</p>
<p><strong>Note</strong></p>
<p>the struct class passed to this function must have previously
been created with a call to class_create().</p>
</div>
<dl class="function">
<dt id="c.device_destroy">
void <code class="sig-name descname">device_destroy</code><span class="sig-paren">(</span>struct class<em> *class</em>, dev_t<em> devt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>removes a device that was created with <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_create()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>pointer to the struct class that this device was registered with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt><dd><p>the dev_t of the device that was previously registered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call unregisters and cleans up a device that was created with a
call to <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_create()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.device_rename">
int <code class="sig-name descname">device_rename</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, const char<em> *new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>renames a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the pointer to the <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> to be renamed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*new_name</span></code></dt><dd><p>the new name of the device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the responsibility of the caller to provide mutual
exclusion between two different calls of device_rename
on the same device to ensure that new_name is valid and
won’t conflict with other devices.</p>
<p>Renaming devices is racy at many levels, symlinks and other stuff are not
replaced atomically, and you get a “move” uevent, but it’s not easy to
connect the event to the old and new device. Device nodes are not renamed at
all, there isn’t even support for that in the kernel now.</p>
<p>In the meantime, during renaming, your target name might be taken by another
driver, creating conflicts. Or the old name is taken directly after you
renamed it – then you get events for the same DEVPATH, before you even see
the “move” event. It’s just a mess, and nothing new should ever rely on
kernel device renaming. Besides that, it’s not even implemented now for
other things than (driver-core wise very simple) network devices.</p>
<p>We are currently about to change network renaming in udev to completely
disallow renaming of devices in the same namespace as the kernel uses,
because we can’t solve the problems properly, that arise with swapping names
of multiple interfaces without races. Means, renaming of eth[0-9]* will only
be allowed to some other name than eth[0-9]*, for the aforementioned
reasons.</p>
<p>Make up a “real” name in the driver before you register anything, or add
some other attributes for userspace to find the device, or use udev to add
symlinks – but never rename kernel devices later, it’s a complete mess. We
don’t even want to get into that and try to implement the missing pieces in
the core. We really have other pieces to fix in the driver core mess. :)</p>
<p><strong>Note</strong></p>
<p>Don’t call this function.  Currently, the networking layer calls this
function, but that will change.  The following text from Kay Sievers offers
some insight:</p>
</div>
<dl class="function">
<dt id="c.device_move">
int <code class="sig-name descname">device_move</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *new_parent</em>, enum dpm_order<em> dpm_order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_move" title="Permalink to this definition">¶</a></dt>
<dd><p>moves a device to a new parent</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the pointer to the <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> to be moved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*new_parent</span></code></dt><dd><p>the new parent of the device (can be NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dpm_order</span> <span class="pre">dpm_order</span></code></dt><dd><p>how to reorder the dpm_list</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.device_change_owner">
int <code class="sig-name descname">device_change_owner</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, kuid_t<em> kuid</em>, kgid_t<em> kgid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_change_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>change the owner of an existing device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kuid_t</span> <span class="pre">kuid</span></code></dt><dd><p>new owner’s kuid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kgid_t</span> <span class="pre">kgid</span></code></dt><dd><p>new owner’s kgid</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This changes the owner of <strong>dev</strong> and its corresponding sysfs entries to
<strong>kuid</strong>/<strong>kgid</strong>. This function closely mirrors how <strong>dev</strong> was added via driver
core.</p>
<p>Returns 0 on success or error code on failure.</p>
</div>
<dl class="function">
<dt id="c.dev_err_probe">
int <code class="sig-name descname">dev_err_probe</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, int<em> err</em>, const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.dev_err_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>probe error check and log helper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the pointer to the <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">err</span></code></dt><dd><p>error value to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>printf-style format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>arguments as specified in the format string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper implements common pattern present in probe functions for error
checking: print debug or error message depending if the error value is
-EPROBE_DEFER and propagate error upwards.
In case of -EPROBE_DEFER it sets also defer probe reason, which can be
checked later by reading devices_deferred debugfs attribute.
It replaces code sequence:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (err != -EPROBE_DEFER)
        dev_err(dev, ...);
else
        dev_dbg(dev, ...);
return err;
</pre></div>
</div>
<p>with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>return dev_err_probe(dev, err, ...);
</pre></div>
</div>
<p>Note that it is deemed acceptable to use this function for error
prints during probe even if the <strong>err</strong> is known to never be -EPROBE_DEFER.
The benefit compared to a normal dev_err() is the standardized format
of the error code and the fact that the error code is returned.</p>
<p>Returns <strong>err</strong>.</p>
</div>
<dl class="function">
<dt id="c.set_primary_fwnode">
void <code class="sig-name descname">set_primary_fwnode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, struct fwnode_handle<em> *fwnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_primary_fwnode" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the primary firmware node of a given device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>New primary firmware node of the device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the device’s firmware node pointer to <strong>fwnode</strong>, but if a secondary
firmware node of the device is present, preserve it.</p>
<dl class="simple">
<dt>Valid fwnode cases are:</dt><dd><ul class="simple">
<li><p>primary –&gt; secondary –&gt; -ENODEV</p></li>
<li><p>primary –&gt; NULL</p></li>
<li><p>secondary –&gt; -ENODEV</p></li>
<li><p>NULL</p></li>
</ul>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.set_secondary_fwnode">
void <code class="sig-name descname">set_secondary_fwnode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, struct fwnode_handle<em> *fwnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_secondary_fwnode" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the secondary firmware node of a given device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>New secondary firmware node of the device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a primary firmware node of the device is present, set its secondary
pointer to <strong>fwnode</strong>.  Otherwise, set the device’s firmware node pointer to
<strong>fwnode</strong>.</p>
</div>
<dl class="function">
<dt id="c.device_set_of_node_from_dev">
void <code class="sig-name descname">device_set_of_node_from_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, const struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_set_of_node_from_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>reuse device-tree node of another device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device whose device-tree node is being set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev2</span></code></dt><dd><p>device whose device-tree node is being reused</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes another reference to the new device-tree node after first dropping
any reference held to the old node.</p>
</div>
<dl class="function">
<dt id="c.register_syscore_ops">
void <code class="sig-name descname">register_syscore_ops</code><span class="sig-paren">(</span>struct syscore_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_syscore_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a set of system core operations.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">syscore_ops</span> <span class="pre">*ops</span></code></dt><dd><p>System core operations to register.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.unregister_syscore_ops">
void <code class="sig-name descname">unregister_syscore_ops</code><span class="sig-paren">(</span>struct syscore_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_syscore_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a set of system core operations.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">syscore_ops</span> <span class="pre">*ops</span></code></dt><dd><p>System core operations to unregister.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.syscore_suspend">
int <code class="sig-name descname">syscore_suspend</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.syscore_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute all the registered system core suspend callbacks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is executed with one CPU on-line and disabled interrupts.</p>
</div>
<dl class="function">
<dt id="c.syscore_resume">
void <code class="sig-name descname">syscore_resume</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.syscore_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute all the registered system core resume callbacks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is executed with one CPU on-line and disabled interrupts.</p>
</div>
<dl class="function">
<dt id="c.__class_create">
struct class * <code class="sig-name descname">__class_create</code><span class="sig-paren">(</span>struct module<em> *owner</em>, const char<em> *name</em>, struct lock_class_key<em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__class_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a struct class structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>pointer to the module that is to “own” this struct class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>pointer to a string for the name of this class.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*key</span></code></dt><dd><p>the lock_class_key for this class; used by mutex lock debugging</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to create a struct class pointer that can then be used
in calls to <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_create()</span></code></a>.</p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span></code> pointer on success, or ERR_PTR() on error.</p>
<p>Note, the pointer created here is to be destroyed when finished by
making a call to <a class="reference internal" href="#c.class_destroy" title="class_destroy"><code class="xref c c-func docutils literal notranslate"><span class="pre">class_destroy()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.class_destroy">
void <code class="sig-name descname">class_destroy</code><span class="sig-paren">(</span>struct class<em> *cls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroys a struct class structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*cls</span></code></dt><dd><p>pointer to the struct class that is to be destroyed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, the pointer to be destroyed must have been created with a call
to class_create().</p>
</div>
<dl class="function">
<dt id="c.class_dev_iter_init">
void <code class="sig-name descname">class_dev_iter_init</code><span class="sig-paren">(</span>struct class_dev_iter<em> *iter</em>, struct class<em> *class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *start</em>, const struct device_type<em> *type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize class device iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*iter</span></code></dt><dd><p>class iterator to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>the class we wanna iterate over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>the device to start iterating from, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_type</span> <span class="pre">*type</span></code></dt><dd><p>device_type of the devices to iterate over, NULL for all</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize class iterator <strong>iter</strong> such that it iterates over devices
of <strong>class</strong>.  If <strong>start</strong> is set, the list iteration will start there,
otherwise if it is NULL, the iteration starts at the beginning of
the list.</p>
</div>
<dl class="function">
<dt id="c.class_dev_iter_next">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">class_dev_iter_next</code><span class="sig-paren">(</span>struct class_dev_iter<em> *iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate to the next device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*iter</span></code></dt><dd><p>class iterator to proceed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Proceed <strong>iter</strong> to the next device and return it.  Returns NULL if
iteration is complete.</p>
<p>The returned device is referenced and won’t be released till
iterator is proceed to the next device or exited.  The caller is
free to do whatever it wants to do with the device including
calling back into class code.</p>
</div>
<dl class="function">
<dt id="c.class_dev_iter_exit">
void <code class="sig-name descname">class_dev_iter_exit</code><span class="sig-paren">(</span>struct class_dev_iter<em> *iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>finish iteration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*iter</span></code></dt><dd><p>class iterator to finish</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finish an iteration.  Always call this function after iteration is
complete whether the iteration ran till the end or not.</p>
</div>
<dl class="function">
<dt id="c.class_for_each_device">
int <code class="sig-name descname">class_for_each_device</code><span class="sig-paren">(</span>struct class<em> *class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *start</em>, void<em> *data</em>, int (<em>*fn</em>)(struct <a class="reference internal" href="#c.device" title="device">device</a> *, void *)<span class="sig-paren">)</span><a class="headerlink" href="#c.class_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>the class we’re iterating</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>the device to start with in the list, if any.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data for the callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to be called for each device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>class</strong>’s list of devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.  If <strong>start</strong> is set, the list iteration will start
there, otherwise if it is NULL, the iteration starts at the
beginning of the list.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<p><strong>fn</strong> is allowed to do anything including calling back into class
code.  There’s no locking restriction.</p>
</div>
<dl class="function">
<dt id="c.class_find_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">class_find_device</code><span class="sig-paren">(</span>struct class<em> *class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *start</em>, const void<em> *data</em>, int (<em>*match</em>)(struct <a class="reference internal" href="#c.device" title="device">device</a> *, const void *)<span class="sig-paren">)</span><a class="headerlink" href="#c.class_find_device" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator for locating a particular device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*class</span></code></dt><dd><p>the class we’re iterating</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>Device to begin with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data for the match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*match)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to check device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the class_for_each_dev() function above, but it
returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
<p>Note, you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> after use.</p>
<p><strong>match</strong> is allowed to do anything including calling back into class
code.  There’s no locking restriction.</p>
</div>
<dl class="function">
<dt id="c.class_compat_register">
struct class_compat * <code class="sig-name descname">class_compat_register</code><span class="sig-paren">(</span>const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a compatibility class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name of the class</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compatibility class are meant as a temporary user-space compatibility
workaround when converting a family of class devices to a bus devices.</p>
</div>
<dl class="function">
<dt id="c.class_compat_unregister">
void <code class="sig-name descname">class_compat_unregister</code><span class="sig-paren">(</span>struct class_compat<em> *cls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a compatibility class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*cls</span></code></dt><dd><p>the class to unregister</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.class_compat_create_link">
int <code class="sig-name descname">class_compat_create_link</code><span class="sig-paren">(</span>struct class_compat<em> *cls</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *device_link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_create_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create a compatibility class device link to a bus device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*cls</span></code></dt><dd><p>the compatibility class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the target bus device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device_link</span></code></dt><dd><p>an optional device to which a “device” link should be created</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.class_compat_remove_link">
void <code class="sig-name descname">class_compat_remove_link</code><span class="sig-paren">(</span>struct class_compat<em> *cls</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *device_link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_remove_link" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a compatibility class device link to a bus device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*cls</span></code></dt><dd><p>the compatibility class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the target bus device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device_link</span></code></dt><dd><p>an optional device to which a “device” link was previously
created</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.node_access_nodes">
struct <code class="sig-name descname">node_access_nodes</code><a class="headerlink" href="#c.node_access_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Access class device to hold user visible relationships to other nodes.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct node_access_nodes {
    struct device           dev;
    struct list_head        list_node;
    unsigned int            access;
#ifdef CONFIG_HMEM_REPORTING;
    struct node_hmem_attrs  hmem_attrs;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Device for this memory access class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list_node</span></code></dt><dd><p>List element in the node’s access list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">access</span></code></dt><dd><p>The access class rank</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hmem_attrs</span></code></dt><dd><p>Heterogeneous memory performance attributes</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.node_set_perf_attrs">
void <code class="sig-name descname">node_set_perf_attrs</code><span class="sig-paren">(</span>unsigned int<em> nid</em>, struct node_hmem_attrs<em> *hmem_attrs</em>, unsigned int<em> access</em><span class="sig-paren">)</span><a class="headerlink" href="#c.node_set_perf_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the performance values for given access class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>Node identifier to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node_hmem_attrs</span> <span class="pre">*hmem_attrs</span></code></dt><dd><p>Heterogeneous memory performance attributes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">access</span></code></dt><dd><p>The access class the for the given attributes</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.node_cache_info">
struct <code class="sig-name descname">node_cache_info</code><a class="headerlink" href="#c.node_cache_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal tracking for memory node caches</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct node_cache_info {
    struct device dev;
    struct list_head node;
    struct node_cache_attrs cache_attrs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Device represeting the cache level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>List element for tracking in the node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cache_attrs</span></code></dt><dd><p>Attributes for this cache level</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.node_add_cache">
void <code class="sig-name descname">node_add_cache</code><span class="sig-paren">(</span>unsigned int<em> nid</em>, struct node_cache_attrs<em> *cache_attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.node_add_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>add cache attribute to a memory node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>Node identifier that has new cache attributes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node_cache_attrs</span> <span class="pre">*cache_attrs</span></code></dt><dd><p>Attributes for the cache being added</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.unregister_node">
void <code class="sig-name descname">unregister_node</code><span class="sig-paren">(</span>struct node<em> *node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_node" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a node device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node</span> <span class="pre">*node</span></code></dt><dd><p>node going away</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters a node device <strong>node</strong>.  All the devices on the node must be
unregistered before calling this function.</p>
</div>
<dl class="function">
<dt id="c.register_memory_node_under_compute_node">
int <code class="sig-name descname">register_memory_node_under_compute_node</code><span class="sig-paren">(</span>unsigned int<em> mem_nid</em>, unsigned int<em> cpu_nid</em>, unsigned int<em> access</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_memory_node_under_compute_node" title="Permalink to this definition">¶</a></dt>
<dd><p>link memory node to its compute node for a given access class.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mem_nid</span></code></dt><dd><p>Memory node number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu_nid</span></code></dt><dd><p>Cpu  node number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">access</span></code></dt><dd><p>Access class to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>For use with platforms that may have separate memory and compute nodes.
This function will export node relationships linking which memory
initiator nodes can access memory targets at a given ranked access
class.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.transport_class_register">
int <code class="sig-name descname">transport_class_register</code><span class="sig-paren">(</span>struct transport_class<em> *tclass</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_class_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register an initial transport class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">transport_class</span> <span class="pre">*tclass</span></code></dt><dd><p>a pointer to the transport class structure to be initialised</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The transport class contains an embedded class which is used to
identify it.  The caller should initialise this structure with
zeros and then generic class must have been initialised with the
actual transport class unique name.  There’s a macro
DECLARE_TRANSPORT_CLASS() to do this (declared classes still must
be registered).</p>
<p>Returns 0 on success or error on failure.</p>
</div>
<dl class="function">
<dt id="c.transport_class_unregister">
void <code class="sig-name descname">transport_class_unregister</code><span class="sig-paren">(</span>struct transport_class<em> *tclass</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_class_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a previously registered class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">transport_class</span> <span class="pre">*tclass</span></code></dt><dd><p>The transport class to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called prior to deallocating the memory for the transport
class.</p>
</div>
<dl class="function">
<dt id="c.anon_transport_class_register">
int <code class="sig-name descname">anon_transport_class_register</code><span class="sig-paren">(</span>struct anon_transport_class<em> *atc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_transport_class_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register an anonymous class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">anon_transport_class</span> <span class="pre">*atc</span></code></dt><dd><p>The anon transport class to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The anonymous transport class contains both a transport class and a
container.  The idea of an anonymous class is that it never
actually has any device attributes associated with it (and thus
saves on container storage).  So it can only be used for triggering
events.  Use prezero and then use DECLARE_ANON_TRANSPORT_CLASS() to
initialise the anon transport class storage.</p>
</div>
<dl class="function">
<dt id="c.anon_transport_class_unregister">
void <code class="sig-name descname">anon_transport_class_unregister</code><span class="sig-paren">(</span>struct anon_transport_class<em> *atc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_transport_class_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an anon class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">anon_transport_class</span> <span class="pre">*atc</span></code></dt><dd><p>Pointer to the anon transport class to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called prior to deallocating the memory for the anon
transport class.</p>
</div>
<dl class="function">
<dt id="c.transport_setup_device">
void <code class="sig-name descname">transport_setup_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_setup_device" title="Permalink to this definition">¶</a></dt>
<dd><p>declare a new dev for transport class association but don’t make it visible yet.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the generic device representing the entity being added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point to see if any set of transport
classes wishes to associate with the added device.  This allocates
storage for the class device and initialises it, but does not yet
add it to the system or add attributes to it (you do this with
transport_add_device).  If you have no need for a separate setup
and add operations, use transport_register_device (see
transport_class.h).</p>
</div>
<dl class="function">
<dt id="c.transport_add_device">
int <code class="sig-name descname">transport_add_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_add_device" title="Permalink to this definition">¶</a></dt>
<dd><p>declare a new dev for transport class association</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the generic device representing the entity being added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point used to add the device to the
system and register attributes for it.</p>
</div>
<dl class="function">
<dt id="c.transport_configure_device">
void <code class="sig-name descname">transport_configure_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_configure_device" title="Permalink to this definition">¶</a></dt>
<dd><p>configure an already set up device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>generic device representing device to be configured</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The idea of configure is simply to provide a point within the setup
process to allow the transport class to extract information from a
device after it has been setup.  This is used in SCSI because we
have to have a setup device to begin using the HBA, but after we
send the initial inquiry, we use configure to extract the device
parameters.  The device need not have been added to be configured.</p>
</div>
<dl class="function">
<dt id="c.transport_remove_device">
void <code class="sig-name descname">transport_remove_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_remove_device" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the visibility of a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>generic device to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call removes the visibility of the device (to the user from
sysfs), but does not destroy it.  To eliminate a device entirely
you must also call transport_destroy_device.  If you don’t need to
do remove and destroy as separate operations, use
transport_unregister_device() (see transport_class.h) which will
perform both calls for you.</p>
</div>
<dl class="function">
<dt id="c.transport_destroy_device">
void <code class="sig-name descname">transport_destroy_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_destroy_device" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a removed device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to eliminate from the transport class.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call triggers the elimination of storage associated with the
transport classdev.  Note: all it really does is relinquish a
reference to the classdev.  The memory will not be freed until the
last reference goes to zero.  Note also that the classdev retains a
reference count on dev, so dev too will remain for as long as the
transport class device remains around.</p>
</div>
<dl class="function">
<dt id="c.driver_deferred_probe_check_state">
int <code class="sig-name descname">driver_deferred_probe_check_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_deferred_probe_check_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Check deferred probe state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>-ENODEV if initcalls have completed and modules are disabled.</p></li>
<li><p>-ETIMEDOUT if the deferred probe timeout was set and has expired
and modules are enabled.</p></li>
<li><p>-EPROBE_DEFER in other cases.</p></li>
</ul>
<p><strong>Description</strong></p>
<p>Drivers or subsystems can opt-in to calling this function instead of directly
returning -EPROBE_DEFER.</p>
</div>
<dl class="function">
<dt id="c.device_bind_driver">
int <code class="sig-name descname">device_bind_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_bind_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>bind a driver to one device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow manual attachment of a driver to a device.
Caller must have already set <strong>dev-&gt;driver</strong>.</p>
<p>Note that this does not modify the bus reference count.
Please verify that is accounted for before calling this.
(It is ok to call with no other effort from a driver’s probe() method.)</p>
<p>This function must be called with the device lock held.</p>
<p>Callers should prefer to use <a class="reference internal" href="#c.device_driver_attach" title="device_driver_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_driver_attach()</span></code></a> instead.</p>
</div>
<dl class="function">
<dt id="c.wait_for_device_probe">
void <code class="sig-name descname">wait_for_device_probe</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.wait_for_device_probe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for device probing to be completed.</p>
</div>
<dl class="function">
<dt id="c.device_attach">
int <code class="sig-name descname">device_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>try to attach device to a driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of drivers that the bus has and call
driver_probe_device() for each pair. If a compatible
pair is found, break out and return.</p>
<p>Returns 1 if the device was bound to a driver;
0 if no matching driver was found;
-ENODEV if the device is not registered.</p>
<p>When called for a USB interface, <strong>dev-&gt;parent</strong> lock must be held.</p>
</div>
<dl class="function">
<dt id="c.device_driver_attach">
int <code class="sig-name descname">device_driver_attach</code><span class="sig-paren">(</span>struct device_driver<em> *drv</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_driver_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a specific driver to a specific device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>Driver to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to attach it to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Manually attach driver to a device. Will acquire both <strong>dev</strong> lock and
<strong>dev-&gt;parent</strong> lock if needed. Returns 0 on success, -ERR on failure.</p>
</div>
<dl class="function">
<dt id="c.driver_attach">
int <code class="sig-name descname">driver_attach</code><span class="sig-paren">(</span>struct device_driver<em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>try to bind driver to devices.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of devices that the bus has on it and try to
match the driver with each one.  If driver_probe_device()
returns 0 and the <strong>dev-&gt;driver</strong> is set, we’ve found a
compatible pair.</p>
</div>
<dl class="function">
<dt id="c.device_release_driver">
void <code class="sig-name descname">device_release_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_release_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>manually detach device from driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Manually detach device from driver.
When called for a USB interface, <strong>dev-&gt;parent</strong> lock must be held.</p>
<p>If this function is to be called with <strong>dev-&gt;parent</strong> lock held, ensure that
the device’s consumers are unbound in advance or that their locks can be
acquired under the <strong>dev-&gt;parent</strong> lock.</p>
</div>
<dl class="function">
<dt id="c.platform_device_register_resndata">
struct platform_device * <code class="sig-name descname">platform_device_register_resndata</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *parent</em>, const char<em> *name</em>, int<em> id</em>, const struct resource<em> *res</em>, unsigned int<em> num</em>, const void<em> *data</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_resndata" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform-level device with resources and platform-specific data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device for the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>base name of the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>instance id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>set of resources that needs to be allocated for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of resources</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>platform specific data for this platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of platform specific data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or ERR_PTR() on error.</p>
</div>
<dl class="function">
<dt id="c.platform_device_register_simple">
struct platform_device * <code class="sig-name descname">platform_device_register_simple</code><span class="sig-paren">(</span>const char<em> *name</em>, int<em> id</em>, const struct resource<em> *res</em>, unsigned int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform-level device and its resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>base name of the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>instance id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>set of resources that needs to be allocated for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of resources</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a simple platform device that requires minimal
resource and memory management. Canned release function freeing memory
allocated for the device allows drivers using such devices to be
unloaded without waiting for the last reference to the device to be
dropped.</p>
<p>This interface is primarily intended for use with legacy drivers which
probe hardware directly.  Because such drivers create sysfs device nodes
themselves, rather than letting system infrastructure handle such device
enumeration tasks, they don’t fully conform to the Linux driver model.
In particular, when such drivers are built as modules, they can’t be
“hotplugged”.</p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or ERR_PTR() on error.</p>
</div>
<dl class="function">
<dt id="c.platform_device_register_data">
struct platform_device * <code class="sig-name descname">platform_device_register_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *parent</em>, const char<em> *name</em>, int<em> id</em>, const void<em> *data</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_data" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform-level device with platform-specific data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device for the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>base name of the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>instance id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>platform specific data for this platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of platform specific data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a simple platform device that requires minimal
resource and memory management. Canned release function freeing memory
allocated for the device allows drivers using such devices to be
unloaded without waiting for the last reference to the device to be
dropped.</p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or ERR_PTR() on error.</p>
</div>
<dl class="function">
<dt id="c.platform_get_resource">
struct resource * <code class="sig-name descname">platform_get_resource</code><span class="sig-paren">(</span>struct platform_device<em> *dev</em>, unsigned int<em> type</em>, unsigned int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>get a resource for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>resource type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>resource index</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a pointer to the resource or NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_platform_get_and_ioremap_resource">
void __iomem * <code class="sig-name descname">devm_platform_get_and_ioremap_resource</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em>, unsigned int<em> index</em>, struct resource<em> **res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_platform_get_and_ioremap_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>call devm_ioremap_resource() for a platform device and get resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device to use both for memory resource lookup as well as
resource management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>resource index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">**res</span></code></dt><dd><p>optional output parameter to store a pointer to the obtained resource.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a pointer to the remapped memory or an ERR_PTR() encoded error code
on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_platform_ioremap_resource">
void __iomem * <code class="sig-name descname">devm_platform_ioremap_resource</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em>, unsigned int<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_platform_ioremap_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>call devm_ioremap_resource() for a platform device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device to use both for memory resource lookup as well as
resource management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>resource index</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a pointer to the remapped memory or an ERR_PTR() encoded error code
on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_platform_ioremap_resource_byname">
void __iomem * <code class="sig-name descname">devm_platform_ioremap_resource_byname</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_platform_ioremap_resource_byname" title="Permalink to this definition">¶</a></dt>
<dd><p>call devm_ioremap_resource for a platform device, retrieve the resource by name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device to use both for memory resource lookup as well as
resource management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the resource</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a pointer to the remapped memory or an ERR_PTR() encoded error code
on failure.</p>
</div>
<dl class="function">
<dt id="c.platform_get_irq_optional">
int <code class="sig-name descname">platform_get_irq_optional</code><span class="sig-paren">(</span>struct platform_device<em> *dev</em>, unsigned int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>get an optional IRQ for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>IRQ number index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets an IRQ for a platform device. Device drivers should check the return
value for errors so as to not pass a negative integer value to the
<a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> APIs. This is the same as <a class="reference internal" href="#c.platform_get_irq" title="platform_get_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_get_irq()</span></code></a>, except that it
does not print an error message if an IRQ can not be obtained.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int irq = platform_get_irq_optional(pdev, 0);
if (irq &lt; 0)
        return irq;
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>non-zero IRQ number on success, negative error number on failure.</p>
</div>
<dl class="function">
<dt id="c.platform_get_irq">
int <code class="sig-name descname">platform_get_irq</code><span class="sig-paren">(</span>struct platform_device<em> *dev</em>, unsigned int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>get an IRQ for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>IRQ number index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets an IRQ for a platform device and prints an error message if finding the
IRQ fails. Device drivers should check the return value for errors so as to
not pass a negative integer value to the <a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> APIs.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int irq = platform_get_irq(pdev, 0);
if (irq &lt; 0)
        return irq;
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>non-zero IRQ number on success, negative error number on failure.</p>
</div>
<dl class="function">
<dt id="c.platform_irq_count">
int <code class="sig-name descname">platform_irq_count</code><span class="sig-paren">(</span>struct platform_device<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_irq_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of IRQs a platform device uses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Number of IRQs a platform device uses or EPROBE_DEFER</p>
</div>
<dl class="function">
<dt id="c.devm_platform_get_irqs_affinity">
int <code class="sig-name descname">devm_platform_get_irqs_affinity</code><span class="sig-paren">(</span>struct platform_device<em> *dev</em>, struct <a class="reference internal" href="../core-api/genericirq.html#c.irq_affinity" title="irq_affinity">irq_affinity</a><em> *affd</em>, unsigned int<em> minvec</em>, unsigned int<em> maxvec</em>, int<em> **irqs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_platform_get_irqs_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>devm method to get a set of IRQs for a device using an interrupt affinity descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_affinity</span> <span class="pre">*affd</span></code></dt><dd><p>affinity descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">minvec</span></code></dt><dd><p>minimum count of interrupt vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">maxvec</span></code></dt><dd><p>maximum count of interrupt vectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">**irqs</span></code></dt><dd><p>pointer holder for IRQ numbers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets a set of IRQs for a platform device, and updates IRQ afffinty according
to the passed affinity descriptor</p>
<p><strong>Return</strong></p>
<p>Number of vectors on success, negative error number on failure.</p>
</div>
<dl class="function">
<dt id="c.platform_get_resource_byname">
struct resource * <code class="sig-name descname">platform_get_resource_byname</code><span class="sig-paren">(</span>struct platform_device<em> *dev</em>, unsigned int<em> type</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_resource_byname" title="Permalink to this definition">¶</a></dt>
<dd><p>get a resource for a device by name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>resource type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>resource name</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.platform_get_irq_byname">
int <code class="sig-name descname">platform_get_irq_byname</code><span class="sig-paren">(</span>struct platform_device<em> *dev</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq_byname" title="Permalink to this definition">¶</a></dt>
<dd><p>get an IRQ for a device by name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>IRQ name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get an IRQ like <a class="reference internal" href="#c.platform_get_irq" title="platform_get_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_get_irq()</span></code></a>, but then by name rather then by index.</p>
<p><strong>Return</strong></p>
<p>non-zero IRQ number on success, negative error number on failure.</p>
</div>
<dl class="function">
<dt id="c.platform_get_irq_byname_optional">
int <code class="sig-name descname">platform_get_irq_byname_optional</code><span class="sig-paren">(</span>struct platform_device<em> *dev</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq_byname_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>get an optional IRQ for a device by name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*dev</span></code></dt><dd><p>platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>IRQ name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get an optional IRQ by name like <a class="reference internal" href="#c.platform_get_irq_byname" title="platform_get_irq_byname"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_get_irq_byname()</span></code></a>. Except that it
does not print an error message if an IRQ can not be obtained.</p>
<p><strong>Return</strong></p>
<p>non-zero IRQ number on success, negative error number on failure.</p>
</div>
<dl class="function">
<dt id="c.platform_add_devices">
int <code class="sig-name descname">platform_add_devices</code><span class="sig-paren">(</span>struct platform_device<em> **devs</em>, int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_add_devices" title="Permalink to this definition">¶</a></dt>
<dd><p>add a numbers of platform devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">**devs</span></code></dt><dd><p>array of platform devices to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of platform devices in array</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.platform_device_put">
void <code class="sig-name descname">platform_device_put</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_put" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a platform device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all memory associated with a platform device.  This function must
_only_ be externally called in error cases.  All other usage is a bug.</p>
</div>
<dl class="function">
<dt id="c.platform_device_alloc">
struct platform_device * <code class="sig-name descname">platform_device_alloc</code><span class="sig-paren">(</span>const char<em> *name</em>, int<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>create a platform device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>base name of the device we’re adding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>instance id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a platform device object which can have other objects attached
to it, and which will have attached objects freed when it is released.</p>
</div>
<dl class="function">
<dt id="c.platform_device_add_resources">
int <code class="sig-name descname">platform_device_add_resources</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em>, const struct resource<em> *res</em>, unsigned int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add_resources" title="Permalink to this definition">¶</a></dt>
<dd><p>add resources to a platform device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device allocated by platform_device_alloc to add resources to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>set of resources that needs to be allocated for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of resources</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a copy of the resources to the platform device.  The memory
associated with the resources will be freed when the platform device is
released.</p>
</div>
<dl class="function">
<dt id="c.platform_device_add_data">
int <code class="sig-name descname">platform_device_add_data</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em>, const void<em> *data</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>add platform-specific data to a platform device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device allocated by platform_device_alloc to add resources to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>platform specific data for this platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of platform specific data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a copy of platform specific data to the platform device’s
platform_data pointer.  The memory associated with the platform data
will be freed when the platform device is released.</p>
</div>
<dl class="function">
<dt id="c.platform_device_add">
int <code class="sig-name descname">platform_device_add</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform device to device hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device we’re adding</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is part 2 of <a class="reference internal" href="#c.platform_device_register" title="platform_device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_register()</span></code></a>, though may be called
separately _iff_ pdev was allocated by <a class="reference internal" href="#c.platform_device_alloc" title="platform_device_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_alloc()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.platform_device_del">
void <code class="sig-name descname">platform_device_del</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a platform-level device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device we’re removing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function will also release all memory- and port-based
resources owned by the device (<strong>dev-&gt;resource</strong>).  This function must
_only_ be externally called in error cases.  All other usage is a bug.</p>
</div>
<dl class="function">
<dt id="c.platform_device_register">
int <code class="sig-name descname">platform_device_register</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform-level device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device we’re adding</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>_Never_ directly free <strong>pdev</strong> after calling this function, even if it
returned an error! Always use <a class="reference internal" href="#c.platform_device_put" title="platform_device_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_put()</span></code></a> to give up the
reference initialised in this function instead.</p>
</div>
<dl class="function">
<dt id="c.platform_device_unregister">
void <code class="sig-name descname">platform_device_unregister</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a platform-level device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>platform device we’re unregistering</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregistration is done in 2 steps. First we release all resources
and remove it from the subsystem, then we drop reference count by
calling <a class="reference internal" href="#c.platform_device_put" title="platform_device_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_put()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.platform_device_register_full">
struct platform_device * <code class="sig-name descname">platform_device_register_full</code><span class="sig-paren">(</span>const struct platform_device_info<em> *pdevinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_full" title="Permalink to this definition">¶</a></dt>
<dd><p>add a platform-level device with resources and platform-specific data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">platform_device_info</span> <span class="pre">*pdevinfo</span></code></dt><dd><p>data used to create device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or ERR_PTR() on error.</p>
</div>
<dl class="function">
<dt id="c.__platform_driver_register">
int <code class="sig-name descname">__platform_driver_register</code><span class="sig-paren">(</span>struct platform_driver<em> *drv</em>, struct module<em> *owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_driver_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a driver for platform-level devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*drv</span></code></dt><dd><p>platform driver structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owning module/driver</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.platform_driver_unregister">
void <code class="sig-name descname">platform_driver_unregister</code><span class="sig-paren">(</span>struct platform_driver<em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_driver_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a driver for platform-level devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*drv</span></code></dt><dd><p>platform driver structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__platform_driver_probe">
int <code class="sig-name descname">__platform_driver_probe</code><span class="sig-paren">(</span>struct platform_driver<em> *drv</em>, int (<em>*probe</em>)(struct platform_device *), struct module<em> *module</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_driver_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>register driver for non-hotpluggable device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*drv</span></code></dt><dd><p>platform driver structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*probe)(struct</span> <span class="pre">platform_device</span> <span class="pre">*)</span></code></dt><dd><p>the driver probe routine, probably from an __init section</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*module</span></code></dt><dd><p>module which will be the owner of the driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this instead of platform_driver_register() when you know the device
is not hotpluggable and has already been registered, and you want to
remove its run-once probe() infrastructure from memory after the driver
has bound to the device.</p>
<p>One typical use for this would be with drivers for controllers integrated
into system-on-chip processors, where the controller devices have been
configured as part of board setup.</p>
<p>Note that this is incompatible with deferred probing.</p>
<p>Returns zero if the driver registered and bound to a device, else returns
a negative error code and with the driver not registered.</p>
</div>
<dl class="function">
<dt id="c.__platform_create_bundle">
struct platform_device * <code class="sig-name descname">__platform_create_bundle</code><span class="sig-paren">(</span>struct platform_driver<em> *driver</em>, int (<em>*probe</em>)(struct platform_device *), struct resource<em> *res</em>, unsigned int<em> n_res</em>, const void<em> *data</em>, size_t<em> size</em>, struct module<em> *module</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_create_bundle" title="Permalink to this definition">¶</a></dt>
<dd><p>register driver and create corresponding device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*driver</span></code></dt><dd><p>platform driver structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*probe)(struct</span> <span class="pre">platform_device</span> <span class="pre">*)</span></code></dt><dd><p>the driver probe routine, probably from an __init section</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>set of resources that needs to be allocated for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">n_res</span></code></dt><dd><p>number of resources</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>platform specific data for this platform device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of platform specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*module</span></code></dt><dd><p>module which will be the owner of the driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this in legacy-style modules that probe hardware directly and
register a single platform device and corresponding platform driver.</p>
<p>Returns <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or ERR_PTR() on error.</p>
</div>
<dl class="function">
<dt id="c.__platform_register_drivers">
int <code class="sig-name descname">__platform_register_drivers</code><span class="sig-paren">(</span>struct platform_driver * const<em> *drivers</em>, unsigned int<em> count</em>, struct module<em> *owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_register_drivers" title="Permalink to this definition">¶</a></dt>
<dd><p>register an array of platform drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">*drivers</span></code></dt><dd><p>an array of drivers to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of drivers to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module owning the drivers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers platform drivers specified by an array. On failure to register a
driver, all previously registered drivers will be unregistered. Callers of
this API should use <a class="reference internal" href="#c.platform_unregister_drivers" title="platform_unregister_drivers"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_unregister_drivers()</span></code></a> to unregister drivers in
the reverse order.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.platform_unregister_drivers">
void <code class="sig-name descname">platform_unregister_drivers</code><span class="sig-paren">(</span>struct platform_driver * const<em> *drivers</em>, unsigned int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_unregister_drivers" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an array of platform drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">*drivers</span></code></dt><dd><p>an array of drivers to unregister</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of drivers to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters platform drivers specified by an array. This is typically used
to complement an earlier call to platform_register_drivers(). Drivers are
unregistered in the reverse order in which they were registered.</p>
</div>
<dl class="function">
<dt id="c.platform_find_device_by_driver">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">platform_find_device_by_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *start</em>, const struct device_driver<em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_find_device_by_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a platform device with a given driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>The device to start the search from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>The device driver to look for.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.bus_for_each_dev">
int <code class="sig-name descname">bus_for_each_dev</code><span class="sig-paren">(</span>struct bus_type<em> *bus</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *start</em>, void<em> *data</em>, int (<em>*fn</em>)(struct <a class="reference internal" href="#c.device" title="device">device</a> *, void *)<span class="sig-paren">)</span><a class="headerlink" href="#c.bus_for_each_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>device to start iterating from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data for the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to be called for each device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>bus</strong>’s list of devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>. If <strong>start</strong> is not NULL, we use that device to
begin iterating from.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<p><strong>NOTE</strong></p>
<p>The device that returns a non-zero value is not retained
in any way, nor is its refcount incremented. If the caller needs
to retain this data, it should do so, and increment the reference
count in the supplied callback.</p>
</div>
<dl class="function">
<dt id="c.bus_find_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">bus_find_device</code><span class="sig-paren">(</span>struct bus_type<em> *bus</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *start</em>, const void<em> *data</em>, int (<em>*match</em>)(struct <a class="reference internal" href="#c.device" title="device">device</a> *dev, const void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.bus_find_device" title="Permalink to this definition">¶</a></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>Device to begin with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data to pass to match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*match)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>Callback function to check device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.bus_for_each_dev" title="bus_for_each_dev"><code class="xref c c-func docutils literal notranslate"><span class="pre">bus_for_each_dev()</span></code></a> function above, but it
returns a reference to a device that is ‘found’ for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn’t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
</div>
<dl class="function">
<dt id="c.subsys_find_device_by_id">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">subsys_find_device_by_id</code><span class="sig-paren">(</span>struct bus_type<em> *subsys</em>, unsigned int<em> id</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *hint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_find_device_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device with a specific enumeration number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*subsys</span></code></dt><dd><p>subsystem</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>index ‘id’ in <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*hint</span></code></dt><dd><p>device to check first</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the hint’s next object and if it is a match return it directly,
otherwise, fall back to a full list search. Either way a reference for
the returned object is taken.</p>
</div>
<dl class="function">
<dt id="c.bus_for_each_drv">
int <code class="sig-name descname">bus_for_each_drv</code><span class="sig-paren">(</span>struct bus_type<em> *bus</em>, struct device_driver<em> *start</em>, void<em> *data</em>, int (<em>*fn</em>)(struct device_driver *, void *)<span class="sig-paren">)</span><a class="headerlink" href="#c.bus_for_each_drv" title="Permalink to this definition">¶</a></dt>
<dd><p>driver iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus we’re dealing with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*start</span></code></dt><dd><p>driver to start iterating on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data to pass to the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device_driver</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to call for each driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is nearly identical to the device iterator above.
We iterate over each driver that belongs to <strong>bus</strong>, and call
<strong>fn</strong> for each. If <strong>fn</strong> returns anything but 0, we break out
and return it. If <strong>start</strong> is not NULL, we use it as the head
of the list.</p>
<p><strong>NOTE</strong></p>
<p>we don’t return the driver that returns a non-zero
value, nor do we leave the reference count incremented for that
driver. If the caller needs to know that info, it must set it
in the callback. It must also be sure to increment the refcount
so it doesn’t disappear before returning to the caller.</p>
</div>
<dl class="function">
<dt id="c.bus_rescan_devices">
int <code class="sig-name descname">bus_rescan_devices</code><span class="sig-paren">(</span>struct bus_type<em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_rescan_devices" title="Permalink to this definition">¶</a></dt>
<dd><p>rescan devices on the bus for possible drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>the bus to scan.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will look for devices on the bus with no driver
attached and rescan it against existing drivers to see if it matches
any by calling <a class="reference internal" href="#c.device_attach" title="device_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_attach()</span></code></a> for the unbound devices.</p>
</div>
<dl class="function">
<dt id="c.device_reprobe">
int <code class="sig-name descname">device_reprobe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_reprobe" title="Permalink to this definition">¶</a></dt>
<dd><p>remove driver for a device and probe for a new driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device to reprobe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function detaches the attached driver (if any) for the given
device and restarts the driver probing process.  It is intended
to use if probing criteria changed during a devices lifetime and
driver attachment should change accordingly.</p>
</div>
<dl class="function">
<dt id="c.bus_register">
int <code class="sig-name descname">bus_register</code><span class="sig-paren">(</span>struct bus_type<em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a driver-core subsystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Once we have that, we register the bus with the kobject
infrastructure, then register the children subsystems it has:
the devices and drivers that belong to the subsystem.</p>
</div>
<dl class="function">
<dt id="c.bus_unregister">
void <code class="sig-name descname">bus_unregister</code><span class="sig-paren">(</span>struct bus_type<em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a bus from the system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*bus</span></code></dt><dd><p>bus.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister the child subsystems and the bus itself.
Finally, we call bus_put() to release the refcount</p>
</div>
<dl class="function">
<dt id="c.subsys_dev_iter_init">
void <code class="sig-name descname">subsys_dev_iter_init</code><span class="sig-paren">(</span>struct subsys_dev_iter<em> *iter</em>, struct bus_type<em> *subsys</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *start</em>, const struct device_type<em> *type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_dev_iter_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize subsys device iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">subsys_dev_iter</span> <span class="pre">*iter</span></code></dt><dd><p>subsys iterator to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*subsys</span></code></dt><dd><p>the subsys we wanna iterate over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*start</span></code></dt><dd><p>the device to start iterating from, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_type</span> <span class="pre">*type</span></code></dt><dd><p>device_type of the devices to iterate over, NULL for all</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize subsys iterator <strong>iter</strong> such that it iterates over devices
of <strong>subsys</strong>.  If <strong>start</strong> is set, the list iteration will start there,
otherwise if it is NULL, the iteration starts at the beginning of
the list.</p>
</div>
<dl class="function">
<dt id="c.subsys_dev_iter_next">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="sig-name descname">subsys_dev_iter_next</code><span class="sig-paren">(</span>struct subsys_dev_iter<em> *iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_dev_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate to the next device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">subsys_dev_iter</span> <span class="pre">*iter</span></code></dt><dd><p>subsys iterator to proceed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Proceed <strong>iter</strong> to the next device and return it.  Returns NULL if
iteration is complete.</p>
<p>The returned device is referenced and won’t be released till
iterator is proceed to the next device or exited.  The caller is
free to do whatever it wants to do with the device including
calling back into subsys code.</p>
</div>
<dl class="function">
<dt id="c.subsys_dev_iter_exit">
void <code class="sig-name descname">subsys_dev_iter_exit</code><span class="sig-paren">(</span>struct subsys_dev_iter<em> *iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_dev_iter_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>finish iteration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">subsys_dev_iter</span> <span class="pre">*iter</span></code></dt><dd><p>subsys iterator to finish</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finish an iteration.  Always call this function after iteration is
complete whether the iteration ran till the end or not.</p>
</div>
<dl class="function">
<dt id="c.subsys_system_register">
int <code class="sig-name descname">subsys_system_register</code><span class="sig-paren">(</span>struct bus_type<em> *subsys</em>, const struct attribute_group<em> **groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_system_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a subsystem at /sys/devices/system/</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*subsys</span></code></dt><dd><p>system subsystem</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**groups</span></code></dt><dd><p>default attributes for the root device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All ‘system’ subsystems have a /sys/devices/system/&lt;name&gt; root device
with the name of the subsystem. The root device can carry subsystem-
wide attributes. All registered devices are below this single root
device and are named after the subsystem with a simple enumeration
number appended. The registered devices are not explicitly named;
only ‘id’ in the device needs to be set.</p>
<p>Do not use this interface for anything new, it exists for compatibility
with bad ideas only. New subsystems should use plain subsystems; and
add the subsystem-wide attributes should be added to the subsystem
directory itself and not some create fake root-device placed in
/sys/devices/system/&lt;name&gt;.</p>
</div>
<dl class="function">
<dt id="c.subsys_virtual_register">
int <code class="sig-name descname">subsys_virtual_register</code><span class="sig-paren">(</span>struct bus_type<em> *subsys</em>, const struct attribute_group<em> **groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_virtual_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a subsystem at /sys/devices/virtual/</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*subsys</span></code></dt><dd><p>virtual subsystem</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**groups</span></code></dt><dd><p>default attributes for the root device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All ‘virtual’ subsystems have a /sys/devices/system/&lt;name&gt; root device
with the name of the subystem.  The root device can carry subsystem-wide
attributes.  All registered devices are below this single root device.
There’s no restriction on device naming.  This is for kernel software
constructs which need sysfs interface.</p>
</div>
</section>
<section id="device-drivers-dma-management">
<h2>Device Drivers DMA Management<a class="headerlink" href="#device-drivers-dma-management" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.dmam_free_coherent">
void <code class="sig-name descname">dmam_free_coherent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, size_t<em> size</em>, void<em> *vaddr</em>, dma_addr_t<em> dma_handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_free_coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed dma_free_coherent()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to free coherent memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*vaddr</span></code></dt><dd><p>Virtual address of the memory to free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">dma_handle</span></code></dt><dd><p>DMA handle of the memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed dma_free_coherent().</p>
</div>
<dl class="function">
<dt id="c.dmam_alloc_attrs">
void * <code class="sig-name descname">dmam_alloc_attrs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, size_t<em> size</em>, dma_addr_t<em> *dma_handle</em>, gfp_t<em> gfp</em>, unsigned long<em> attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_alloc_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed dma_alloc_attrs()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate non_coherent memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*dma_handle</span></code></dt><dd><p>Out argument for allocated DMA handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt><dd><p>Flags in the DMA_ATTR_* namespace.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed dma_alloc_attrs().  Memory allocated using this function will be
automatically released on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.dma_map_sg_attrs">
unsigned int <code class="sig-name descname">dma_map_sg_attrs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, struct scatterlist<em> *sg</em>, int<em> nents</em>, enum dma_data_direction<em> dir</em>, unsigned long<em> attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_map_sg_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the given buffer for DMA</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The device for which to perform the DMA operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*sg</span></code></dt><dd><p>The sg_table object describing the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nents</span></code></dt><dd><p>Number of entries to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>DMA direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt><dd><p>Optional DMA attributes for the map operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps a buffer described by a scatterlist passed in the sg argument with
nents segments for the <strong>dir</strong> DMA operation by the <strong>dev</strong> device.</p>
<p>Returns the number of mapped entries (which can be less than nents)
on success. Zero is returned for any error.</p>
<p>dma_unmap_sg_attrs() should be used to unmap the buffer with the
original sg and original nents (not the value returned by this funciton).</p>
</div>
<dl class="function">
<dt id="c.dma_map_sgtable">
int <code class="sig-name descname">dma_map_sgtable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, struct sg_table<em> *sgt</em>, enum dma_data_direction<em> dir</em>, unsigned long<em> attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_map_sgtable" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the given buffer for DMA</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The device for which to perform the DMA operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sgt</span></code></dt><dd><p>The sg_table object describing the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>DMA direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt><dd><p>Optional DMA attributes for the map operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps a buffer described by a scatterlist stored in the given sg_table
object for the <strong>dir</strong> DMA operation by the <strong>dev</strong> device. After success, the
ownership for the buffer is transferred to the DMA domain.  One has to
call dma_sync_sgtable_for_cpu() or dma_unmap_sgtable() to move the
ownership of the buffer back to the CPU domain before touching the
buffer by the CPU.</p>
<p>Returns 0 on success or a negative error code on error. The following
error codes are supported with the given meaning:</p>
<blockquote>
<div><dl class="option-list">
<dt><kbd><span class="option">-E<var>INVAL</var></span></kbd></dt>
<dd><p>An invalid argument, unaligned access or other error
in usage. Will not succeed if retried.</p>
</dd>
<dt><kbd><span class="option">-E<var>NOMEM</var></span></kbd></dt>
<dd><p>Insufficient resources (like memory or IOVA space) to
complete the mapping. Should succeed if retried later.</p>
</dd>
<dt><kbd><span class="option">-E<var>IO</var></span></kbd></dt>
<dd><p>Legacy error code with an unknown meaning. eg. this is
returned if a lower level call returned
DMA_MAPPING_ERROR.</p>
</dd>
<dt><kbd><span class="option">-E<var>REMOTEIO</var></span></kbd></dt>
<dd><p>The DMA device cannot access P2PDMA memory specified
in the sg_table. This will not succeed if retried.</p>
</dd>
</dl>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.dma_can_mmap">
bool <code class="sig-name descname">dma_can_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_can_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a given device supports dma_mmap_*</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>dev</strong> supports dma_mmap_coherent() and <a class="reference internal" href="#c.dma_mmap_attrs" title="dma_mmap_attrs"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_mmap_attrs()</span></code></a> to
map DMA allocations to userspace.</p>
</div>
<dl class="function">
<dt id="c.dma_mmap_attrs">
int <code class="sig-name descname">dma_mmap_attrs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a><em> *dev</em>, struct vm_area_struct<em> *vma</em>, void<em> *cpu_addr</em>, dma_addr_t<em> dma_addr</em>, size_t<em> size</em>, unsigned long<em> attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_mmap_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>map a coherent DMA allocation into user space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>valid <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer, or NULL for ISA and EISA-like devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>vm_area_struct describing requested user mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*cpu_addr</span></code></dt><dd><p>kernel CPU-view address returned from dma_alloc_attrs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">dma_addr</span></code></dt><dd><p>device-view address returned from dma_alloc_attrs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of memory originally requested in dma_alloc_attrs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt><dd><p>attributes of mapping properties requested in dma_alloc_attrs</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map a coherent DMA buffer previously allocated by dma_alloc_attrs into user
space.  The coherent DMA buffer must not be freed by the driver until the
user space mapping has been released.</p>
</div>
</section>
<section id="device-drivers-pnp-support">
<h2>Device drivers PnP support<a class="headerlink" href="#device-drivers-pnp-support" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.pnp_register_protocol">
int <code class="sig-name descname">pnp_register_protocol</code><span class="sig-paren">(</span>struct pnp_protocol<em> *protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_register_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a pnp protocol to the pnp layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_protocol</span> <span class="pre">*protocol</span></code></dt><dd><p>pointer to the corresponding pnp_protocol structure</p>
<p>Ex protocols: ISAPNP, PNPBIOS, etc</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pnp_unregister_protocol">
void <code class="sig-name descname">pnp_unregister_protocol</code><span class="sig-paren">(</span>struct pnp_protocol<em> *protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_unregister_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>removes a pnp protocol from the pnp layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_protocol</span> <span class="pre">*protocol</span></code></dt><dd><p>pointer to the corresponding pnp_protocol structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pnp_request_card_device">
struct pnp_dev * <code class="sig-name descname">pnp_request_card_device</code><span class="sig-paren">(</span>struct pnp_card_link<em> *clink</em>, const char<em> *id</em>, struct pnp_dev<em> *from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_request_card_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for a PnP device under the specified card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_card_link</span> <span class="pre">*clink</span></code></dt><dd><p>pointer to the card link, cannot be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>pointer to a PnP ID structure that explains the rules for finding the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*from</span></code></dt><dd><p>Starting place to search from. If NULL it will start from the beginning.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pnp_release_card_device">
void <code class="sig-name descname">pnp_release_card_device</code><span class="sig-paren">(</span>struct pnp_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_release_card_device" title="Permalink to this definition">¶</a></dt>
<dd><p>call this when the driver no longer needs the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the PnP device structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pnp_register_card_driver">
int <code class="sig-name descname">pnp_register_card_driver</code><span class="sig-paren">(</span>struct pnp_card_driver<em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_register_card_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>registers a PnP card driver with the PnP Layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_card_driver</span> <span class="pre">*drv</span></code></dt><dd><p>pointer to the driver to register</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pnp_unregister_card_driver">
void <code class="sig-name descname">pnp_unregister_card_driver</code><span class="sig-paren">(</span>struct pnp_card_driver<em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_unregister_card_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>unregisters a PnP card driver from the PnP Layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_card_driver</span> <span class="pre">*drv</span></code></dt><dd><p>pointer to the driver to unregister</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pnp_add_id">
struct pnp_id * <code class="sig-name descname">pnp_add_id</code><span class="sig-paren">(</span>struct pnp_dev<em> *dev</em>, const char<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_add_id" title="Permalink to this definition">¶</a></dt>
<dd><p>adds an EISA id to the specified device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>pointer to an EISA id string</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pnp_start_dev">
int <code class="sig-name descname">pnp_start_dev</code><span class="sig-paren">(</span>struct pnp_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_start_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>low-level start of the PnP device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>assumes that resources have already been allocated</p>
</div>
<dl class="function">
<dt id="c.pnp_stop_dev">
int <code class="sig-name descname">pnp_stop_dev</code><span class="sig-paren">(</span>struct pnp_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_stop_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>low-level disable of the PnP device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>does not free resources</p>
</div>
<dl class="function">
<dt id="c.pnp_activate_dev">
int <code class="sig-name descname">pnp_activate_dev</code><span class="sig-paren">(</span>struct pnp_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_activate_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>activates a PnP device for use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>does not validate or set resources so be careful.</p>
</div>
<dl class="function">
<dt id="c.pnp_disable_dev">
int <code class="sig-name descname">pnp_disable_dev</code><span class="sig-paren">(</span>struct pnp_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_disable_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>disables device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>inform the correct pnp protocol so that resources can be used by other devices</p>
</div>
<dl class="function">
<dt id="c.pnp_is_active">
int <code class="sig-name descname">pnp_is_active</code><span class="sig-paren">(</span>struct pnp_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_is_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if a device is active based on its current resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the desired PnP device</p>
</dd>
</dl>
</div>
</section>
<section id="userspace-io-devices">
<h2>Userspace IO devices<a class="headerlink" href="#userspace-io-devices" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.uio_event_notify">
void <code class="sig-name descname">uio_event_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.uio_info" title="uio_info">uio_info</a><em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uio_event_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>trigger an interrupt event</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__uio_register_device">
int <code class="sig-name descname">__uio_register_device</code><span class="sig-paren">(</span>struct module<em> *owner</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *parent</em>, struct <a class="reference internal" href="#c.uio_info" title="uio_info">uio_info</a><em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__uio_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new userspace IO device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module that creates the new device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns zero on success or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.__devm_uio_register_device">
int <code class="sig-name descname">__devm_uio_register_device</code><span class="sig-paren">(</span>struct module<em> *owner</em>, struct <a class="reference internal" href="#c.device" title="device">device</a><em> *parent</em>, struct <a class="reference internal" href="#c.uio_info" title="uio_info">uio_info</a><em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__devm_uio_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource managed <a class="reference internal" href="#c.uio_register_device" title="uio_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">uio_register_device()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module that creates the new device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns zero on success or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.uio_unregister_device">
void <code class="sig-name descname">uio_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.uio_info" title="uio_info">uio_info</a><em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uio_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a industrial IO device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.uio_mem">
struct <code class="sig-name descname">uio_mem</code><a class="headerlink" href="#c.uio_mem" title="Permalink to this definition">¶</a></dt>
<dd><p>description of a UIO memory region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct uio_mem {
    const char              *name;
    phys_addr_t addr;
    unsigned long           offs;
    resource_size_t size;
    int memtype;
    void __iomem            *internal_addr;
    struct uio_map          *map;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the memory region for identification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>address of the device’s memory rounded to page
size (phys_addr is used since addr can be
logical, virtual, or physical &amp; phys_addr_t
should always be large enough to handle any of
the address types)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offs</span></code></dt><dd><p>offset of device memory within the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>size of IO (multiple of page size)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memtype</span></code></dt><dd><p>type of memory addr points to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">internal_addr</span></code></dt><dd><p>ioremap-ped version of addr, for driver internal use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map</span></code></dt><dd><p>for use by the UIO core only.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.uio_port">
struct <code class="sig-name descname">uio_port</code><a class="headerlink" href="#c.uio_port" title="Permalink to this definition">¶</a></dt>
<dd><p>description of a UIO port region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct uio_port {
    const char              *name;
    unsigned long           start;
    unsigned long           size;
    int porttype;
    struct uio_portio       *portio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the port region for identification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p>start of port region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>size of port region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">porttype</span></code></dt><dd><p>type of port (see UIO_PORT_* below)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">portio</span></code></dt><dd><p>for use by the UIO core only.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.uio_info">
struct <code class="sig-name descname">uio_info</code><a class="headerlink" href="#c.uio_info" title="Permalink to this definition">¶</a></dt>
<dd><p>UIO device capabilities</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct uio_info {
    struct uio_device       *uio_dev;
    const char              *name;
    const char              *version;
    struct uio_mem          mem[MAX_UIO_MAPS];
    struct uio_port         port[MAX_UIO_PORT_REGIONS];
    long irq;
    unsigned long           irq_flags;
    void *priv;
    irqreturn_t (*handler)(int irq, struct uio_info *dev_info);
    int (*mmap)(struct uio_info *info, struct vm_area_struct *vma);
    int (*open)(struct uio_info *info, struct inode *inode);
    int (*release)(struct uio_info *info, struct inode *inode);
    int (*irqcontrol)(struct uio_info *info, s32 irq_on);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uio_dev</span></code></dt><dd><p>the UIO device this info belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">version</span></code></dt><dd><p>device driver version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem</span></code></dt><dd><p>list of mappable memory regions, size==0 for end of list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt><dd><p>list of port regions, size==0 for end of list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>interrupt number or UIO_IRQ_CUSTOM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_flags</span></code></dt><dd><p>flags for <a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>optional private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt><dd><p>the device’s irq handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap</span></code></dt><dd><p>mmap operation for this uio device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>open operation for this uio device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>release operation for this uio device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irqcontrol</span></code></dt><dd><p>disable/enable irqs when 0/1 is written to /dev/uioX</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.uio_register_device">
<code class="sig-name descname">uio_register_device</code><span class="sig-paren">(</span><em>parent</em>, <em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uio_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new userspace IO device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns zero on success or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.devm_uio_register_device">
<code class="sig-name descname">devm_uio_register_device</code><span class="sig-paren">(</span><em>parent</em>, <em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_uio_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource managed <a class="reference internal" href="#c.uio_register_device" title="uio_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">uio_register_device()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>UIO device capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns zero on success or a negative error code.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Device drivers infrastructure</a><ul>
<li><a class="reference internal" href="#the-basic-device-driver-model-structures">The Basic Device Driver-Model Structures</a></li>
<li><a class="reference internal" href="#device-drivers-base">Device Drivers Base</a></li>
<li><a class="reference internal" href="#device-drivers-dma-management">Device Drivers DMA Management</a></li>
<li><a class="reference internal" href="#device-drivers-pnp-support">Device drivers PnP support</a></li>
<li><a class="reference internal" href="#userspace-io-devices">Userspace IO devices</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/infrastructure.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/infrastructure.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>