
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Device links &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Component Helper for Aggregate Drivers" href="component.html" />
    <link rel="prev" title="Buffer Sharing and Synchronization" href="dma-buf.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="device-links">
<span id="device-link"></span><h1>Device links<a class="headerlink" href="#device-links" title="Permalink to this headline">¶</a></h1>
<p>By default, the driver core only enforces dependencies between devices
that are borne out of a parent/child relationship within the device
hierarchy: When suspending, resuming or shutting down the system, devices
are ordered based on this relationship, i.e. children are always suspended
before their parent, and the parent is always resumed before its children.</p>
<p>Sometimes there is a need to represent device dependencies beyond the
mere parent/child relationship, e.g. between siblings, and have the
driver core automatically take care of them.</p>
<p>Secondly, the driver core by default does not enforce any driver presence
dependencies, i.e. that one device must be bound to a driver before
another one can probe or function correctly.</p>
<p>Often these two dependency types come together, so a device depends on
another one both with regards to driver presence <em>and</em> with regards to
suspend/resume and shutdown ordering.</p>
<p>Device links allow representation of such dependencies in the driver core.</p>
<p>In its standard or <em>managed</em> form, a device link combines <em>both</em> dependency
types:  It guarantees correct suspend/resume and shutdown ordering between a
“supplier” device and its “consumer” devices, and it guarantees driver
presence on the supplier.  The consumer devices are not probed before the
supplier is bound to a driver, and they’re unbound before the supplier
is unbound.</p>
<p>When driver presence on the supplier is irrelevant and only correct
suspend/resume and shutdown ordering is needed, the device link may
simply be set up with the <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> flag.  In other words,
enforcing driver presence on the supplier is optional.</p>
<p>Another optional feature is runtime PM integration:  By setting the
<code class="docutils literal notranslate"><span class="pre">DL_FLAG_PM_RUNTIME</span></code> flag on addition of the device link, the PM core
is instructed to runtime resume the supplier and keep it active
whenever and for as long as the consumer is runtime resumed.</p>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>The earliest point in time when device links can be added is after
<a class="reference internal" href="infrastructure.html#c.device_add" title="device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_add()</span></code></a> has been called for the supplier and
<a class="reference internal" href="infrastructure.html#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_initialize()</span></code></a> has been called for the consumer.</p>
<p>It is legal to add them later, but care must be taken that the system
remains in a consistent state:  E.g. a device link cannot be added in
the midst of a suspend/resume transition, so either commencement of
such a transition needs to be prevented with <code class="xref c c-func docutils literal notranslate"><span class="pre">lock_system_sleep()</span></code>,
or the device link needs to be added from a function which is guaranteed
not to run in parallel to a suspend/resume transition, such as from a
device <code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback or a boot-time PCI quirk.</p>
<p>Another example for an inconsistent state would be a device link that
represents a driver presence dependency, yet is added from the consumer’s
<code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback while the supplier hasn’t started to probe yet:  Had the
driver core known about the device link earlier, it wouldn’t have probed the
consumer in the first place.  The onus is thus on the consumer to check
presence of the supplier after adding the link, and defer probing on
non-presence.  [Note that it is valid to create a link from the consumer’s
<code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback while the supplier is still probing, but the consumer must
know that the supplier is functional already at the link creation time (that is
the case, for instance, if the consumer has just acquired some resources that
would not have been available had the supplier not been functional then).]</p>
<p>If a device link with <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> set (i.e. a stateless device link)
is added in the <code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback of the supplier or consumer driver, it is
typically deleted in its <code class="docutils literal notranslate"><span class="pre">-&gt;remove</span></code> callback for symmetry.  That way, if the
driver is compiled as a module, the device link is added on module load and
orderly deleted on unload.  The same restrictions that apply to device link
addition (e.g. exclusion of a parallel suspend/resume transition) apply equally
to deletion.  Device links managed by the driver core are deleted automatically
by it.</p>
<p>Several flags may be specified on device link addition, two of which
have already been mentioned above:  <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> to express that no
driver presence dependency is needed (but only correct suspend/resume and
shutdown ordering) and <code class="docutils literal notranslate"><span class="pre">DL_FLAG_PM_RUNTIME</span></code> to express that runtime PM
integration is desired.</p>
<p>Two other flags are specifically targeted at use cases where the device
link is added from the consumer’s <code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback:  <code class="docutils literal notranslate"><span class="pre">DL_FLAG_RPM_ACTIVE</span></code>
can be specified to runtime resume the supplier and prevent it from suspending
before the consumer is runtime suspended.  <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_CONSUMER</span></code>
causes the device link to be automatically purged when the consumer fails to
probe or later unbinds.</p>
<p>Similarly, when the device link is added from supplier’s <code class="docutils literal notranslate"><span class="pre">-&gt;probe</span></code> callback,
<code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_SUPPLIER</span></code> causes the device link to be automatically
purged when the supplier fails to probe or later unbinds.</p>
<p>If neither <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_CONSUMER</span></code> nor <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_SUPPLIER</span></code>
is set, <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOPROBE_CONSUMER</span></code> can be used to request the driver core
to probe for a driver for the consumer driver on the link automatically after
a driver has been bound to the supplier device.</p>
<p>Note, however, that any combinations of <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_CONSUMER</span></code>,
<code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_SUPPLIER</span></code> or <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOPROBE_CONSUMER</span></code> with
<code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> are invalid and cannot be used.</p>
</section>
<section id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<p>Driver authors should be aware that a driver presence dependency for managed
device links (i.e. when <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> is not specified on link addition)
may cause probing of the consumer to be deferred indefinitely.  This can become
a problem if the consumer is required to probe before a certain initcall level
is reached.  Worse, if the supplier driver is blacklisted or missing, the
consumer will never be probed.</p>
<p>Moreover, managed device links cannot be deleted directly.  They are deleted
by the driver core when they are not necessary any more in accordance with the
<code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_CONSUMER</span></code> and <code class="docutils literal notranslate"><span class="pre">DL_FLAG_AUTOREMOVE_SUPPLIER</span></code> flags.
However, stateless device links (i.e. device links with <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code>
set) are expected to be removed by whoever called <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a>
to add them with the help of either <a class="reference internal" href="infrastructure.html#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> or
<a class="reference internal" href="infrastructure.html#c.device_link_remove" title="device_link_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_remove()</span></code></a>.</p>
<p>Passing <code class="docutils literal notranslate"><span class="pre">DL_FLAG_RPM_ACTIVE</span></code> along with <code class="docutils literal notranslate"><span class="pre">DL_FLAG_STATELESS</span></code> to
<a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a> may cause the PM-runtime usage counter of the
supplier device to remain nonzero after a subsequent invocation of either
<a class="reference internal" href="infrastructure.html#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> or <a class="reference internal" href="infrastructure.html#c.device_link_remove" title="device_link_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_remove()</span></code></a> to remove the
device link returned by it.  This happens if <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a> is
called twice in a row for the same consumer-supplier pair without removing the
link between these calls, in which case allowing the PM-runtime usage counter
of the supplier to drop on an attempt to remove the link may cause it to be
suspended while the consumer is still PM-runtime-active and that has to be
avoided.  [To work around this limitation it is sufficient to let the consumer
runtime suspend at least once, or call <code class="xref c c-func docutils literal notranslate"><span class="pre">pm_runtime_set_suspended()</span></code> for
it with PM-runtime disabled, between the <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a> and
<a class="reference internal" href="infrastructure.html#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> or <a class="reference internal" href="infrastructure.html#c.device_link_remove" title="device_link_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_remove()</span></code></a> calls.]</p>
<p>Sometimes drivers depend on optional resources.  They are able to operate
in a degraded mode (reduced feature set or performance) when those resources
are not present.  An example is an SPI controller that can use a DMA engine
or work in PIO mode.  The controller can determine presence of the optional
resources at probe time but on non-presence there is no way to know whether
they will become available in the near future (due to a supplier driver
probing) or never.  Consequently it cannot be determined whether to defer
probing or not.  It would be possible to notify drivers when optional
resources become available after probing, but it would come at a high cost
for drivers as switching between modes of operation at runtime based on the
availability of such resources would be much more complex than a mechanism
based on probe deferral.  In any case optional resources are beyond the
scope of device links.</p>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>An MMU device exists alongside a busmaster device, both are in the same
power domain.  The MMU implements DMA address translation for the busmaster
device and shall be runtime resumed and kept active whenever and as long
as the busmaster device is active.  The busmaster device’s driver shall
not bind before the MMU is bound.  To achieve this, a device link with
runtime PM integration is added from the busmaster device (consumer)
to the MMU device (supplier).  The effect with regards to runtime PM
is the same as if the MMU was the parent of the master device.</p>
<p>The fact that both devices share the same power domain would normally
suggest usage of a <a class="reference internal" href="pm/types.html#c.dev_pm_domain" title="dev_pm_domain"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span></code></a> or struct generic_pm_domain,
however these are not independent devices that happen to share a power
switch, but rather the MMU device serves the busmaster device and is
useless without it.  A device link creates a synthetic hierarchical
relationship between the devices and is thus more apt.</p>
</li>
<li><p>A Thunderbolt host controller comprises a number of PCIe hotplug ports
and an NHI device to manage the PCIe switch.  On resume from system sleep,
the NHI device needs to re-establish PCI tunnels to attached devices
before the hotplug ports can resume.  If the hotplug ports were children
of the NHI, this resume order would automatically be enforced by the
PM core, but unfortunately they’re aunts.  The solution is to add
device links from the hotplug ports (consumers) to the NHI device
(supplier).  A driver presence dependency is not necessary for this
use case.</p></li>
<li><p>Discrete GPUs in hybrid graphics laptops often feature an HDA controller
for HDMI/DP audio.  In the device hierarchy the HDA controller is a sibling
of the VGA device, yet both share the same power domain and the HDA
controller is only ever needed when an HDMI/DP display is attached to the
VGA device.  A device link from the HDA controller (consumer) to the
VGA device (supplier) aptly represents this relationship.</p></li>
<li><p>ACPI allows definition of a device start order by way of _DEP objects.
A classical example is when ACPI power management methods on one device
are implemented in terms of I<sup>2</sup>C accesses and require a specific
I<sup>2</sup>C controller to be present and functional for the power
management of the device in question to work.</p></li>
<li><p>In some SoCs a functional dependency exists from display, video codec and
video processing IP cores on transparent memory access IP cores that handle
burst access and compression/decompression.</p></li>
</ul>
</section>
<section id="alternatives">
<h2>Alternatives<a class="headerlink" href="#alternatives" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>A <a class="reference internal" href="pm/types.html#c.dev_pm_domain" title="dev_pm_domain"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span></code></a> can be used to override the bus,
class or device type callbacks.  It is intended for devices sharing
a single on/off switch, however it does not guarantee a specific
suspend/resume ordering, this needs to be implemented separately.
It also does not by itself track the runtime PM status of the involved
devices and turn off the power switch only when all of them are runtime
suspended.  Furthermore it cannot be used to enforce a specific shutdown
ordering or a driver presence dependency.</p></li>
<li><p>A struct generic_pm_domain is a lot more heavyweight than a
device link and does not allow for shutdown ordering or driver presence
dependencies.  It also cannot be used on ACPI systems.</p></li>
</ul>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>The device hierarchy, which – as the name implies – is a tree,
becomes a directed acyclic graph once device links are added.</p>
<p>Ordering of these devices during suspend/resume is determined by the
dpm_list.  During shutdown it is determined by the devices_kset.  With
no device links present, the two lists are a flattened, one-dimensional
representations of the device tree such that a device is placed behind
all its ancestors.  That is achieved by traversing the ACPI namespace
or OpenFirmware device tree top-down and appending devices to the lists
as they are discovered.</p>
<p>Once device links are added, the lists need to satisfy the additional
constraint that a device is placed behind all its suppliers, recursively.
To ensure this, upon addition of the device link the consumer and the
entire sub-graph below it (all children and consumers of the consumer)
are moved to the end of the list.  (Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_reorder_to_tail()</span></code>
from <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a>.)</p>
<p>To prevent introduction of dependency loops into the graph, it is
verified upon device link addition that the supplier is not dependent
on the consumer or any children or consumers of the consumer.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_is_dependent()</span></code> from <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a>.)
If that constraint is violated, <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a> will return
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> and a <code class="docutils literal notranslate"><span class="pre">WARNING</span></code> will be logged.</p>
<p>Notably this also prevents the addition of a device link from a parent
device to a child.  However the converse is allowed, i.e. a device link
from a child to a parent.  Since the driver core already guarantees
correct suspend/resume and shutdown ordering between parent and child,
such a device link only makes sense if a driver presence dependency is
needed on top of that.  In this case driver authors should weigh
carefully if a device link is at all the right tool for the purpose.
A more suitable approach might be to simply use deferred probing or
add a device flag causing the parent driver to be probed before the
child one.</p>
</section>
<section id="state-machine">
<h2>State machine<a class="headerlink" href="#state-machine" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.device_link_state">
enum <code class="sig-name descname">device_link_state</code><a class="headerlink" href="#c.device_link_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Device link states.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_NONE</span></code></dt><dd><p>The presence of the drivers is not being tracked.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_DORMANT</span></code></dt><dd><p>None of the supplier/consumer drivers is present.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_AVAILABLE</span></code></dt><dd><p>The supplier driver is present, but the consumer is not.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_CONSUMER_PROBE</span></code></dt><dd><p>The consumer is probing (supplier driver present).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_ACTIVE</span></code></dt><dd><p>Both the supplier and consumer drivers are present.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DL_STATE_SUPPLIER_UNBIND</span></code></dt><dd><p>The supplier driver is unbinding.</p>
</dd>
</dl>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                .=============================.
                |                             |
                v                             |
DORMANT &lt;=&gt; AVAILABLE &lt;=&gt; CONSUMER_PROBE =&gt; ACTIVE
   ^                                          |
   |                                          |
   &#39;============ SUPPLIER_UNBIND &lt;============&#39;
</pre></div>
</div>
<ul class="simple">
<li><p>The initial state of a device link is automatically determined by
<a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a> based on the driver presence on the supplier
and consumer.  If the link is created before any devices are probed, it
is set to <code class="docutils literal notranslate"><span class="pre">DL_STATE_DORMANT</span></code>.</p></li>
<li><p>When a supplier device is bound to a driver, links to its consumers
progress to <code class="docutils literal notranslate"><span class="pre">DL_STATE_AVAILABLE</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_driver_bound()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">driver_bound()</span></code>.)</p></li>
<li><p>Before a consumer device is probed, presence of supplier drivers is
verified by checking the consumer device is not in the wait_for_suppliers
list and by checking that links to suppliers are in <code class="docutils literal notranslate"><span class="pre">DL_STATE_AVAILABLE</span></code>
state.  The state of the links is updated to <code class="docutils literal notranslate"><span class="pre">DL_STATE_CONSUMER_PROBE</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_check_suppliers()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">really_probe()</span></code>.)
This prevents the supplier from unbinding.
(Call to <a class="reference internal" href="infrastructure.html#c.wait_for_device_probe" title="wait_for_device_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_for_device_probe()</span></code></a> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_unbind_consumers()</span></code>.)</p></li>
<li><p>If the probe fails, links to suppliers revert back to <code class="docutils literal notranslate"><span class="pre">DL_STATE_AVAILABLE</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_no_driver()</span></code> from <code class="xref c c-func docutils literal notranslate"><span class="pre">really_probe()</span></code>.)</p></li>
<li><p>If the probe succeeds, links to suppliers progress to <code class="docutils literal notranslate"><span class="pre">DL_STATE_ACTIVE</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_driver_bound()</span></code> from <code class="xref c c-func docutils literal notranslate"><span class="pre">driver_bound()</span></code>.)</p></li>
<li><p>When the consumer’s driver is later on removed, links to suppliers revert
back to <code class="docutils literal notranslate"><span class="pre">DL_STATE_AVAILABLE</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">__device_links_no_driver()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_driver_cleanup()</span></code>, which in turn is called from
<code class="xref c c-func docutils literal notranslate"><span class="pre">__device_release_driver()</span></code>.)</p></li>
<li><p>Before a supplier’s driver is removed, links to consumers that are not
bound to a driver are updated to <code class="docutils literal notranslate"><span class="pre">DL_STATE_SUPPLIER_UNBIND</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_busy()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">__device_release_driver()</span></code>.)
This prevents the consumers from binding.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_check_suppliers()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">really_probe()</span></code>.)
Consumers that are bound are freed from their driver; consumers that are
probing are waited for until they are done.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_unbind_consumers()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">__device_release_driver()</span></code>.)
Once all links to consumers are in <code class="docutils literal notranslate"><span class="pre">DL_STATE_SUPPLIER_UNBIND</span></code> state,
the supplier driver is released and the links revert to <code class="docutils literal notranslate"><span class="pre">DL_STATE_DORMANT</span></code>.
(Call to <code class="xref c c-func docutils literal notranslate"><span class="pre">device_links_driver_cleanup()</span></code> from
<code class="xref c c-func docutils literal notranslate"><span class="pre">__device_release_driver()</span></code>.)</p></li>
</ul>
</section>
<section id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_add()</span></code></a>, <a class="reference internal" href="infrastructure.html#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_del()</span></code></a> and <a class="reference internal" href="infrastructure.html#c.device_link_remove" title="device_link_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_link_remove()</span></code></a>.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Device links</a><ul>
<li><a class="reference internal" href="#usage">Usage</a></li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#alternatives">Alternatives</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#state-machine">State machine</a></li>
<li><a class="reference internal" href="#api">API</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/device_link.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/device_link.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>