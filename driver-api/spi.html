
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Serial Peripheral Interface (SPI) &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="I2C and SMBus Subsystem" href="i2c.html" />
    <link rel="prev" title="Compute Express Link Memory Devices" href="cxl/memory-devices.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="serial-peripheral-interface-spi">
<h1>Serial Peripheral Interface (SPI)<a class="headerlink" href="#serial-peripheral-interface-spi" title="Permalink to this headline">¶</a></h1>
<p>SPI is the “Serial Peripheral Interface”, widely used with embedded
systems because it is a simple and efficient interface: basically a
multiplexed shift register. Its three signal wires hold a clock (SCK,
often in the range of 1-20 MHz), a “Master Out, Slave In” (MOSI) data
line, and a “Master In, Slave Out” (MISO) data line. SPI is a full
duplex protocol; for each bit shifted out the MOSI line (one per clock)
another is shifted in on the MISO line. Those bits are assembled into
words of various sizes on the way to and from system memory. An
additional chipselect line is usually active-low (nCS); four signals are
normally used for each peripheral, plus sometimes an interrupt.</p>
<p>The SPI bus facilities listed here provide a generalized interface to
declare SPI busses and devices, manage them according to the standard
Linux driver model, and perform input/output operations. At this time,
only “master” side interfaces are supported, where Linux talks to SPI
peripherals and does not implement such a peripheral itself. (Interfaces
to support implementing SPI slaves would necessarily look different.)</p>
<p>The programming interface is structured around two kinds of driver, and
two kinds of device. A “Controller Driver” abstracts the controller
hardware, which may be as simple as a set of GPIO pins or as complex as
a pair of FIFOs connected to dual DMA engines on the other side of the
SPI shift register (maximizing throughput). Such drivers bridge between
whatever bus they sit on (often the platform bus) and SPI, and expose
the SPI side of their device as a <a class="reference internal" href="#c.spi_controller" title="spi_controller"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span></code></a>. SPI devices are children of that master,
represented as a <a class="reference internal" href="#c.spi_device" title="spi_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span></code></a> and
manufactured from <a class="reference internal" href="#c.spi_board_info" title="spi_board_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_board_info</span></code></a> descriptors which are usually provided by
board-specific initialization code. A <a class="reference internal" href="#c.spi_driver" title="spi_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_driver</span></code></a> is called a “Protocol Driver”, and is bound to a
spi_device using normal driver model calls.</p>
<p>The I/O model is a set of queued messages. Protocol drivers submit one
or more <a class="reference internal" href="#c.spi_message" title="spi_message"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span></code></a> objects,
which are processed and completed asynchronously. (There are synchronous
wrappers, however.) Messages are built from one or more
<a class="reference internal" href="#c.spi_transfer" title="spi_transfer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span></code></a> objects, each of
which wraps a full duplex SPI transfer. A variety of protocol tweaking
options are needed, because different chips adopt very different
policies for how they use the bits transferred with SPI.</p>
<dl class="type">
<dt id="c.spi_statistics">
struct <code class="sig-name descname">spi_statistics</code><a class="headerlink" href="#c.spi_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>statistics for spi transfers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_statistics {
    struct u64_stats_sync   syncp;
    u64_stats_t messages;
    u64_stats_t transfers;
    u64_stats_t errors;
    u64_stats_t timedout;
    u64_stats_t spi_sync;
    u64_stats_t spi_sync_immediate;
    u64_stats_t spi_async;
    u64_stats_t bytes;
    u64_stats_t bytes_rx;
    u64_stats_t bytes_tx;
#define SPI_STATISTICS_HISTO_SIZE 17;
    u64_stats_t transfer_bytes_histo[SPI_STATISTICS_HISTO_SIZE];
    u64_stats_t transfers_split_maxsize;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">syncp</span></code></dt><dd><p>seqcount to protect members in this struct for per-cpu udate
on 32-bit systems</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">messages</span></code></dt><dd><p>number of spi-messages handled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfers</span></code></dt><dd><p>number of spi_transfers handled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">errors</span></code></dt><dd><p>number of errors during spi_transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timedout</span></code></dt><dd><p>number of timeouts during spi_transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spi_sync</span></code></dt><dd><p>number of times spi_sync is used</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">spi_sync_immediate</span></code></p>
<blockquote>
<div><p>number of times spi_sync is executed immediately
in calling context without queuing and scheduling</p>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">spi_async</span></code></dt><dd><p>number of times spi_async is used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytes</span></code></dt><dd><p>number of bytes transferred to/from device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytes_rx</span></code></dt><dd><p>number of bytes received from device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytes_tx</span></code></dt><dd><p>number of bytes sent to device</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">transfer_bytes_histo</span></code></p>
<blockquote>
<div><p>transfer bytes histogramm</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">transfers_split_maxsize</span></code></p>
<blockquote>
<div><p>number of transfers that have been split because of
maxsize limit</p>
</div></blockquote>
</div>
<dl class="type">
<dt id="c.spi_delay">
struct <code class="sig-name descname">spi_delay</code><a class="headerlink" href="#c.spi_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI delay information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_delay {
#define SPI_DELAY_UNIT_USECS    0;
#define SPI_DELAY_UNIT_NSECS    1;
#define SPI_DELAY_UNIT_SCK      2;
    u16 value;
    u8 unit;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>Value for the delay</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unit</span></code></dt><dd><p>Unit for the delay</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.spi_device">
struct <code class="sig-name descname">spi_device</code><a class="headerlink" href="#c.spi_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Controller side proxy for an SPI slave device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_device {
    struct device           dev;
    struct spi_controller   *controller;
    struct spi_controller   *master;
    u32 max_speed_hz;
    u8 chip_select;
    u8 bits_per_word;
    bool rt;
#define SPI_NO_TX       BIT(31)         ;
#define SPI_NO_RX       BIT(30)         ;
#define SPI_MODE_KERNEL_MASK    (~(BIT(30) - 1));
    u32 mode;
    int irq;
    void *controller_state;
    void *controller_data;
    char modalias[SPI_NAME_SIZE];
    const char              *driver_override;
    struct gpio_desc        *cs_gpiod;
    struct spi_delay        word_delay;
    struct spi_delay        cs_setup;
    struct spi_delay        cs_hold;
    struct spi_delay        cs_inactive;
    struct spi_statistics __percpu  *pcpu_statistics;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Driver model representation of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">controller</span></code></dt><dd><p>SPI controller used with the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master</span></code></dt><dd><p>Copy of controller, for backwards compatibility.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_speed_hz</span></code></dt><dd><p>Maximum clock rate to be used with this chip
(on this board); may be changed by the device’s driver.
The spi_transfer.speed_hz can override this for each transfer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip_select</span></code></dt><dd><p>Chipselect, distinguishing chips handled by <strong>controller</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_word</span></code></dt><dd><p>Data transfers involve one or more words; word sizes
like eight or 12 bits are common.  In-memory wordsizes are
powers of two bytes (e.g. 20 bit samples use 32 bits).
This may be changed by the device’s driver, or left at the
default (0) indicating protocol words are eight bit bytes.
The spi_transfer.bits_per_word can override this for each transfer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rt</span></code></dt><dd><p>Make the pump thread real time priority.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>The spi mode defines how data is clocked out and in.
This may be changed by the device’s driver.
The “active low” default for chipselect mode can be overridden
(by specifying SPI_CS_HIGH) as can the “MSB first” default for
each word in a transfer (by specifying SPI_LSB_FIRST).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>Negative, or the number passed to <a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> to receive
interrupts from this device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">controller_state</span></code></dt><dd><p>Controller’s runtime state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">controller_data</span></code></dt><dd><p>Board-specific definitions for controller, such as
FIFO initialization parameters; from board_info.controller_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">modalias</span></code></dt><dd><p>Name of the driver to use with this device, or an alias
for that name.  This appears in the sysfs “modalias” attribute
for driver coldplugging, and in uevents used for hotplugging</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_override</span></code></dt><dd><p>If the name of a driver is written to this attribute, then
the device will bind to the named driver and only the named driver.
Do not set directly, because core frees it; use <a class="reference internal" href="infrastructure.html#c.driver_set_override" title="driver_set_override"><code class="xref c c-func docutils literal notranslate"><span class="pre">driver_set_override()</span></code></a> to
set or clear it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_gpiod</span></code></dt><dd><p>gpio descriptor of the chipselect line (optional, NULL when
not using a GPIO line)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">word_delay</span></code></dt><dd><p>delay to be inserted between consecutive
words of a transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_setup</span></code></dt><dd><p>delay to be introduced by the controller after CS is asserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_hold</span></code></dt><dd><p>delay to be introduced by the controller before CS is deasserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_inactive</span></code></dt><dd><p>delay to be introduced by the controller after CS is
deasserted. If <strong>cs_change_delay</strong> is used from <strong>spi_transfer</strong>, then the
two delays will be added up.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcpu_statistics</span></code></dt><dd><p>statistics for the spi_device</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A <strong>spi_device</strong> is used to interchange data between an SPI slave
(usually a discrete chip) and CPU memory.</p>
<p>In <strong>dev</strong>, the platform_data is used to hold information about this
device that’s meaningful to the device’s protocol driver, but not
to its controller.  One example might be an identifier for a chip
variant with slightly different functionality; another might be
information about how this particular board wires the chip’s pins.</p>
<dl class="type">
<dt id="c.spi_driver">
struct <code class="sig-name descname">spi_driver</code><a class="headerlink" href="#c.spi_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Host side “protocol” driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_driver {
    const struct spi_device_id *id_table;
    int (*probe)(struct spi_device *spi);
    void (*remove)(struct spi_device *spi);
    void (*shutdown)(struct spi_device *spi);
    struct device_driver    driver;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id_table</span></code></dt><dd><p>List of SPI devices supported by this driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>Binds this driver to the spi device.  Drivers can verify
that the device is actually present, and may need to configure
characteristics (such as bits_per_word) which weren’t needed for
the initial configuration done during system setup.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p>Unbinds this driver from the spi device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p>Standard shutdown callback used during system state
transitions such as powerdown/halt and kexec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>SPI device drivers should initialize the name and owner
field of this structure.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This represents the kind of device driver that uses SPI messages to
interact with the hardware at the other end of a SPI link.  It’s called
a “protocol” driver because it works through messages rather than talking
directly to SPI hardware (which is what the underlying SPI controller
driver does to pass those messages).  These protocols are defined in the
specification for the device(s) supported by the driver.</p>
<p>As a rule, those device protocols represent the lowest level interface
supported by a driver, and it will support upper level interfaces too.
Examples of such upper levels include frameworks like MTD, networking,
MMC, RTC, filesystem character device nodes, and hardware monitoring.</p>
<dl class="function">
<dt id="c.spi_unregister_driver">
void <code class="sig-name descname">spi_unregister_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_driver" title="spi_driver">spi_driver</a><em> *sdrv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>reverse effect of spi_register_driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_driver</span> <span class="pre">*sdrv</span></code></dt><dd><p>the driver to unregister</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
</div>
<dl class="function">
<dt id="c.module_spi_driver">
<code class="sig-name descname">module_spi_driver</code><span class="sig-paren">(</span><em>__spi_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_spi_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a SPI driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__spi_driver</span></code></dt><dd><p>spi_driver struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for SPI drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a></p>
</div>
<dl class="type">
<dt id="c.spi_controller">
struct <code class="sig-name descname">spi_controller</code><a class="headerlink" href="#c.spi_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>interface to SPI master or slave controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_controller {
    struct device   dev;
    struct list_head list;
    s16 bus_num;
    u16 num_chipselect;
    u16 dma_alignment;
    u32 mode_bits;
    u32 buswidth_override_bits;
    u32 bits_per_word_mask;
#define SPI_BPW_MASK(bits) BIT((bits) - 1);
#define SPI_BPW_RANGE_MASK(min, max) GENMASK((max) - 1, (min) - 1);
    u32 min_speed_hz;
    u32 max_speed_hz;
    u16 flags;
#define SPI_CONTROLLER_HALF_DUPLEX      BIT(0)  ;
#define SPI_CONTROLLER_NO_RX            BIT(1)  ;
#define SPI_CONTROLLER_NO_TX            BIT(2)  ;
#define SPI_CONTROLLER_MUST_RX          BIT(3)  ;
#define SPI_CONTROLLER_MUST_TX          BIT(4)  ;
#define SPI_MASTER_GPIO_SS              BIT(5)  ;
    bool devm_allocated;
    union {
        bool slave;
        bool target;
    };
    size_t (*max_transfer_size)(struct spi_device *spi);
    size_t (*max_message_size)(struct spi_device *spi);
    struct mutex            io_mutex;
    struct mutex            add_lock;
    spinlock_t bus_lock_spinlock;
    struct mutex            bus_lock_mutex;
    bool bus_lock_flag;
    int (*setup)(struct spi_device *spi);
    int (*set_cs_timing)(struct spi_device *spi);
    int (*transfer)(struct spi_device *spi, struct spi_message *mesg);
    void (*cleanup)(struct spi_device *spi);
    bool (*can_dma)(struct spi_controller *ctlr,struct spi_device *spi, struct spi_transfer *xfer);
    struct device *dma_map_dev;
    struct device *cur_rx_dma_dev;
    struct device *cur_tx_dma_dev;
    bool queued;
    struct kthread_worker           *kworker;
    struct kthread_work             pump_messages;
    spinlock_t queue_lock;
    struct list_head                queue;
    struct spi_message              *cur_msg;
    struct completion               cur_msg_completion;
    bool cur_msg_incomplete;
    bool cur_msg_need_completion;
    bool busy;
    bool running;
    bool rt;
    bool auto_runtime_pm;
    bool cur_msg_mapped;
    char last_cs;
    bool last_cs_mode_high;
    bool fallback;
    struct completion               xfer_completion;
    size_t max_dma_len;
    int (*prepare_transfer_hardware)(struct spi_controller *ctlr);
    int (*transfer_one_message)(struct spi_controller *ctlr, struct spi_message *mesg);
    int (*unprepare_transfer_hardware)(struct spi_controller *ctlr);
    int (*prepare_message)(struct spi_controller *ctlr, struct spi_message *message);
    int (*unprepare_message)(struct spi_controller *ctlr, struct spi_message *message);
    union {
        int (*slave_abort)(struct spi_controller *ctlr);
        int (*target_abort)(struct spi_controller *ctlr);
    };
    void (*set_cs)(struct spi_device *spi, bool enable);
    int (*transfer_one)(struct spi_controller *ctlr, struct spi_device *spi, struct spi_transfer *transfer);
    void (*handle_err)(struct spi_controller *ctlr, struct spi_message *message);
    const struct spi_controller_mem_ops *mem_ops;
    const struct spi_controller_mem_caps *mem_caps;
    struct gpio_desc        **cs_gpiods;
    bool use_gpio_descriptors;
    s8 unused_native_cs;
    s8 max_native_cs;
    struct spi_statistics __percpu  *pcpu_statistics;
    struct dma_chan         *dma_tx;
    struct dma_chan         *dma_rx;
    void *dummy_rx;
    void *dummy_tx;
    int (*fw_translate_cs)(struct spi_controller *ctlr, unsigned cs);
    bool ptp_sts_supported;
    unsigned long           irq_flags;
    bool queue_empty;
    bool must_async;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device interface to this driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>link with the global spi_controller list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_num</span></code></dt><dd><p>board-specific (and often SOC-specific) identifier for a
given SPI controller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_chipselect</span></code></dt><dd><p>chipselects are used to distinguish individual
SPI slaves, and are numbered from zero to num_chipselects.
each slave has a chipselect signal, but it’s common that not
every chipselect is connected to a slave.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_alignment</span></code></dt><dd><p>SPI controller constraint on DMA buffers alignment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode_bits</span></code></dt><dd><p>flags understood by this controller driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buswidth_override_bits</span></code></dt><dd><p>flags to override for this controller driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_word_mask</span></code></dt><dd><p>A mask indicating which values of bits_per_word are
supported by the driver. Bit n indicates that a bits_per_word n+1 is
supported. If set, the SPI core will reject any transfer with an
unsupported bits_per_word. If not set, this value is simply ignored,
and it’s up to the individual driver to perform any validation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_speed_hz</span></code></dt><dd><p>Lowest supported transfer speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_speed_hz</span></code></dt><dd><p>Highest supported transfer speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>other constraints relevant to this driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devm_allocated</span></code></dt><dd><p>whether the allocation of this struct is devres-managed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slave</span></code></dt><dd><p>indicates that this is an SPI slave controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">target</span></code></dt><dd><p>indicates that this is an SPI target controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_transfer_size</span></code></dt><dd><p>function that returns the max transfer size for
a <a class="reference internal" href="#c.spi_device" title="spi_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">spi_device</span></code></a>; may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, so the default <code class="docutils literal notranslate"><span class="pre">SIZE_MAX</span></code> will be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_message_size</span></code></dt><dd><p>function that returns the max message size for
a <a class="reference internal" href="#c.spi_device" title="spi_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">spi_device</span></code></a>; may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, so the default <code class="docutils literal notranslate"><span class="pre">SIZE_MAX</span></code> will be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">io_mutex</span></code></dt><dd><p>mutex for physical bus access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_lock</span></code></dt><dd><p>mutex to avoid adding devices to the same chipselect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_lock_spinlock</span></code></dt><dd><p>spinlock for SPI bus locking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_lock_mutex</span></code></dt><dd><p>mutex for exclusion of multiple callers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_lock_flag</span></code></dt><dd><p>indicates that the SPI bus is locked for exclusive use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup</span></code></dt><dd><p>updates the device mode and clocking records used by a
device’s SPI controller; protocol code may call this.  This
must fail if an unrecognized or unsupported mode is requested.
It’s always safe to call this unless transfers are pending on
the device whose settings are being modified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_cs_timing</span></code></dt><dd><p>optional hook for SPI devices to request SPI master
controller for configuring specific CS setup time, hold time and inactive
delay interms of clock counts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer</span></code></dt><dd><p>adds a message to the controller’s transfer queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup</span></code></dt><dd><p>frees controller-specific state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">can_dma</span></code></dt><dd><p>determine whether this controller supports DMA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_map_dev</span></code></dt><dd><p>device which can be used for DMA mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_rx_dma_dev</span></code></dt><dd><p>device which is currently used for RX DMA mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_tx_dma_dev</span></code></dt><dd><p>device which is currently used for TX DMA mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queued</span></code></dt><dd><p>whether this controller is providing an internal message queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kworker</span></code></dt><dd><p>pointer to thread struct for message pump</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pump_messages</span></code></dt><dd><p>work struct for scheduling work to the message pump</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue_lock</span></code></dt><dd><p>spinlock to syncronise access to message queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue</span></code></dt><dd><p>message queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_msg</span></code></dt><dd><p>the currently in-flight message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_msg_completion</span></code></dt><dd><p>a completion for the current in-flight message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_msg_incomplete</span></code></dt><dd><p>Flag used internally to opportunistically skip
the <strong>cur_msg_completion</strong>. This flag is used to check if the driver has
already called <a class="reference internal" href="#c.spi_finalize_current_message" title="spi_finalize_current_message"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_finalize_current_message()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_msg_need_completion</span></code></dt><dd><p>Flag used internally to opportunistically skip
the <strong>cur_msg_completion</strong>. This flag is used to signal the context that
is running <a class="reference internal" href="#c.spi_finalize_current_message" title="spi_finalize_current_message"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_finalize_current_message()</span></code></a> that it needs to complete()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">busy</span></code></dt><dd><p>message pump is busy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">running</span></code></dt><dd><p>message pump is running</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rt</span></code></dt><dd><p>whether this queue is set to run as a realtime task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auto_runtime_pm</span></code></dt><dd><p>the core should ensure a runtime PM reference is held
while the hardware is prepared, using the parent
device for the spidev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_msg_mapped</span></code></dt><dd><p>message has been mapped for DMA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_cs</span></code></dt><dd><p>the last chip_select that is recorded by set_cs, -1 on non chip
selected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_cs_mode_high</span></code></dt><dd><p>was (mode &amp; SPI_CS_HIGH) true on the last call to set_cs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fallback</span></code></dt><dd><p>fallback to pio if dma transfer return failure with
SPI_TRANS_FAIL_NO_START.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfer_completion</span></code></dt><dd><p>used by core transfer_one_message()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_dma_len</span></code></dt><dd><p>Maximum length of a DMA transfer for the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_transfer_hardware</span></code></dt><dd><p>a message will soon arrive from the queue
so the subsystem requests the driver to prepare the transfer hardware
by issuing this call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer_one_message</span></code></dt><dd><p>the subsystem calls the driver to transfer a single
message while queuing transfers that arrive in the meantime. When the
driver is finished with this message, it must call
<a class="reference internal" href="#c.spi_finalize_current_message" title="spi_finalize_current_message"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_finalize_current_message()</span></code></a> so the subsystem can issue the next
message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unprepare_transfer_hardware</span></code></dt><dd><p>there are currently no more messages on the
queue so the subsystem notifies the driver that it may relax the
hardware by issuing this call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_message</span></code></dt><dd><p>set up the controller to transfer a single message,
for example doing DMA mapping.  Called from threaded
context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unprepare_message</span></code></dt><dd><p>undo any work done by prepare_message().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slave_abort</span></code></dt><dd><p>abort the ongoing transfer request on an SPI slave controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">target_abort</span></code></dt><dd><p>abort the ongoing transfer request on an SPI target controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_cs</span></code></dt><dd><p>set the logic level of the chip select line.  May be called
from interrupt context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer_one</span></code></dt><dd><p>transfer a single spi_transfer.</p>
<ul class="simple">
<li><p>return 0 if the transfer is finished,</p></li>
<li><p>return 1 if the transfer is still in progress. When
the driver is finished with this transfer it must
call <a class="reference internal" href="#c.spi_finalize_current_transfer" title="spi_finalize_current_transfer"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_finalize_current_transfer()</span></code></a> so the subsystem
can issue the next transfer. Note: transfer_one and
transfer_one_message are mutually exclusive; when both
are set, the generic subsystem does not call your
transfer_one callback.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle_err</span></code></dt><dd><p>the subsystem calls the driver to handle an error that occurs
in the generic implementation of transfer_one_message().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_ops</span></code></dt><dd><p>optimized/dedicated operations for interactions with SPI memory.
This field is optional and should only be implemented if the
controller has native support for memory like operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_caps</span></code></dt><dd><p>controller capabilities for the handling of memory operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_gpiods</span></code></dt><dd><p>Array of GPIO descs to use as chip select lines; one per CS
number. Any individual value may be NULL for CS lines that
are not GPIOs (driven by the SPI controller itself).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_gpio_descriptors</span></code></dt><dd><p>Turns on the code in the SPI core to parse and grab
GPIO descriptors. This will fill in <strong>cs_gpiods</strong> and SPI devices will have
the cs_gpiod assigned if a GPIO line is found for the chipselect.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unused_native_cs</span></code></dt><dd><p>When cs_gpiods is used, <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_register_controller()</span></code></a> will
fill in this field with the first unused native CS, to be used by SPI
controller drivers that need to drive a native CS when using GPIO CS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_native_cs</span></code></dt><dd><p>When cs_gpiods is used, and this field is filled in,
<a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_register_controller()</span></code></a> will validate all native CS (including the
unused native CS) against this value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcpu_statistics</span></code></dt><dd><p>statistics for the spi_controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_tx</span></code></dt><dd><p>DMA transmit channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_rx</span></code></dt><dd><p>DMA receive channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dummy_rx</span></code></dt><dd><p>dummy receive buffer for full-duplex devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dummy_tx</span></code></dt><dd><p>dummy transmit buffer for full-duplex devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fw_translate_cs</span></code></dt><dd><p>If the boot firmware uses different numbering scheme
what Linux expects, this optional hook can be used to translate
between the two.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptp_sts_supported</span></code></dt><dd><p>If the driver sets this to true, it must provide a
time snapshot in <strong>spi_transfer-&gt;ptp_sts</strong> as close as possible to the
moment in time when <strong>spi_transfer-&gt;ptp_sts_word_pre</strong> and
<strong>spi_transfer-&gt;ptp_sts_word_post</strong> were transmitted.
If the driver does not set this, the SPI core takes the snapshot as
close to the driver hand-over as possible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_flags</span></code></dt><dd><p>Interrupt enable state during PTP system timestamping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue_empty</span></code></dt><dd><p>signal green light for opportunistically skipping the queue
for spi_sync transfers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">must_async</span></code></dt><dd><p>disable all fast paths in the core</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Each SPI controller can communicate with one or more <strong>spi_device</strong>
children.  These make a small bus, sharing MOSI, MISO and SCK signals
but not chip select signals.  Each device may be configured to use a
different clock rate, since those shared signals are ignored unless
the chip is selected.</p>
<p>The driver for an SPI controller manages access to those devices through
a queue of spi_message transactions, copying data between CPU memory and
an SPI slave device.  For each such message it queues, it calls the
message’s completion function when the transaction completes.</p>
<dl class="type">
<dt id="c.spi_res">
struct <code class="sig-name descname">spi_res</code><a class="headerlink" href="#c.spi_res" title="Permalink to this definition">¶</a></dt>
<dd><p>spi resource management structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_res {
    struct list_head        entry;
    spi_res_release_t release;
    unsigned long long      data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>list entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>release code called prior to freeing this resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>extra data allocated for the specific use-case</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>this is based on ideas from devres, but focused on life-cycle
management during spi_message processing</p>
<dl class="type">
<dt id="c.spi_transfer">
struct <code class="sig-name descname">spi_transfer</code><a class="headerlink" href="#c.spi_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>a read/write buffer pair</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_transfer {
    const void      *tx_buf;
    void *rx_buf;
    unsigned len;
    dma_addr_t tx_dma;
    dma_addr_t rx_dma;
    struct sg_table tx_sg;
    struct sg_table rx_sg;
    unsigned dummy_data:1;
    unsigned cs_off:1;
    unsigned cs_change:1;
    unsigned tx_nbits:3;
    unsigned rx_nbits:3;
#define SPI_NBITS_SINGLE        0x01 ;
#define SPI_NBITS_DUAL          0x02 ;
#define SPI_NBITS_QUAD          0x04 ;
    u8 bits_per_word;
    struct spi_delay        delay;
    struct spi_delay        cs_change_delay;
    struct spi_delay        word_delay;
    u32 speed_hz;
    u32 effective_speed_hz;
    unsigned int    ptp_sts_word_pre;
    unsigned int    ptp_sts_word_post;
    struct ptp_system_timestamp *ptp_sts;
    bool timestamped;
    struct list_head transfer_list;
#define SPI_TRANS_FAIL_NO_START BIT(0);
    u16 error;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tx_buf</span></code></dt><dd><p>data to be written (dma-safe memory), or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_buf</span></code></dt><dd><p>data to be read (dma-safe memory), or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>size of rx and tx buffers (in bytes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_dma</span></code></dt><dd><p>DMA address of tx_buf, if <strong>spi_message.is_dma_mapped</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_dma</span></code></dt><dd><p>DMA address of rx_buf, if <strong>spi_message.is_dma_mapped</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_sg</span></code></dt><dd><p>Scatterlist for transmit, currently not for client use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_sg</span></code></dt><dd><p>Scatterlist for receive, currently not for client use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dummy_data</span></code></dt><dd><p>indicates transfer is dummy bytes transfer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_off</span></code></dt><dd><p>performs the transfer with chipselect off.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_change</span></code></dt><dd><p>affects chipselect after this transfer completes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_nbits</span></code></dt><dd><p>number of bits used for writing. If 0 the default
(SPI_NBITS_SINGLE) is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_nbits</span></code></dt><dd><p>number of bits used for reading. If 0 the default
(SPI_NBITS_SINGLE) is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits_per_word</span></code></dt><dd><p>select a bits_per_word other than the device default
for this transfer. If 0 the default (from <strong>spi_device</strong>) is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delay</span></code></dt><dd><p>delay to be introduced after this transfer before
(optionally) changing the chipselect status, then starting
the next transfer or completing this <strong>spi_message</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cs_change_delay</span></code></dt><dd><p>delay between cs deassert and assert when
<strong>cs_change</strong> is set and <strong>spi_transfer</strong> is not the last in <strong>spi_message</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">word_delay</span></code></dt><dd><p>inter word delay to be introduced after each word size
(set by bits_per_word) transmission.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">speed_hz</span></code></dt><dd><p>Select a speed other than the device default for this
transfer. If 0 the default (from <strong>spi_device</strong>) is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">effective_speed_hz</span></code></dt><dd><p>the effective SCK-speed that was used to
transfer this transfer. Set to 0 if the spi bus driver does
not support it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptp_sts_word_pre</span></code></dt><dd><p>The word (subject to bits_per_word semantics) offset
within <strong>tx_buf</strong> for which the SPI device is requesting that the time
snapshot for this transfer begins. Upon completing the SPI transfer,
this value may have changed compared to what was requested, depending
on the available snapshotting resolution (DMA transfer,
<strong>ptp_sts_supported</strong> is false, etc).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptp_sts_word_post</span></code></dt><dd><p>See <strong>ptp_sts_word_post</strong>. The two can be equal (meaning
that a single byte should be snapshotted).
If the core takes care of the timestamp (if <strong>ptp_sts_supported</strong> is false
for this controller), it will set <strong>ptp_sts_word_pre</strong> to 0, and
<strong>ptp_sts_word_post</strong> to the length of the transfer. This is done
purposefully (instead of setting to spi_transfer-&gt;len - 1) to denote
that a transfer-level snapshot taken from within the driver may still
be of higher quality.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptp_sts</span></code></dt><dd><p>Pointer to a memory location held by the SPI slave device where a
PTP system timestamp structure may lie. If drivers use PIO or their
hardware has some sort of assist for retrieving exact transfer timing,
they can (and should) assert <strong>ptp_sts_supported</strong> and populate this
structure using the ptp_read_system_*ts helper functions.
The timestamp must represent the time at which the SPI slave device has
processed the word, i.e. the “pre” timestamp should be taken before
transmitting the “pre” word, and the “post” timestamp after receiving
transmit confirmation from the controller for the “post” word.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timestamped</span></code></dt><dd><p>true if the transfer has been timestamped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transfer_list</span></code></dt><dd><p>transfers are sequenced through <strong>spi_message.transfers</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">error</span></code></dt><dd><p>Error status logged by spi controller driver.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>SPI transfers always write the same number of bytes as they read.
Protocol drivers should always provide <strong>rx_buf</strong> and/or <strong>tx_buf</strong>.
In some cases, they may also want to provide DMA addresses for
the data being transferred; that may reduce overhead, when the
underlying driver uses dma.</p>
<p>If the transmit buffer is null, zeroes will be shifted out
while filling <strong>rx_buf</strong>.  If the receive buffer is null, the data
shifted in will be discarded.  Only “len” bytes shift out (or in).
It’s an error to try to shift out a partial word.  (For example, by
shifting out three bytes with word size of sixteen or twenty bits;
the former uses two bytes per word, the latter uses four bytes.)</p>
<p>In-memory data values are always in native CPU byte order, translated
from the wire byte order (big-endian except with SPI_LSB_FIRST).  So
for example when bits_per_word is sixteen, buffers are 2N bytes long
(<strong>len</strong> = 2N) and hold N sixteen bit words in CPU byte order.</p>
<p>When the word size of the SPI transfer is not a power-of-two multiple
of eight bits, those in-memory words include extra bits.  In-memory
words are always seen by protocol drivers as right-justified, so the
undefined (rx) or unused (tx) bits are always the most significant bits.</p>
<p>All SPI transfers start with the relevant chipselect active.  Normally
it stays selected until after the last transfer in a message.  Drivers
can affect the chipselect signal using cs_change.</p>
<p>(i) If the transfer isn’t the last one in the message, this flag is
used to make the chipselect briefly go inactive in the middle of the
message.  Toggling chipselect in this way may be needed to terminate
a chip command, letting a single spi_message perform all of group of
chip transactions together.</p>
<p>(ii) When the transfer is the last one in the message, the chip may
stay selected until the next transfer.  On multi-device SPI busses
with nothing blocking messages going to other devices, this is just
a performance hint; starting a message to another device deselects
this one.  But in other cases, this can be used to ensure correctness.
Some devices need protocol transactions to be built from a series of
spi_message submissions, where the content of one message is determined
by the results of previous messages and where the whole transaction
ends when the chipselect goes intactive.</p>
<p>When SPI can transfer in 1x,2x or 4x. It can get this transfer information
from device through <strong>tx_nbits</strong> and <strong>rx_nbits</strong>. In Bi-direction, these
two should both be set. User can set transfer mode with SPI_NBITS_SINGLE(1x)
SPI_NBITS_DUAL(2x) and SPI_NBITS_QUAD(4x) to support these three transfer.</p>
<p>The code that submits an spi_message (and its spi_transfers)
to the lower layers is responsible for managing its memory.
Zero-initialize every field you don’t set up explicitly, to
insulate against future API updates.  After you submit a message
and its transfers, ignore them until its completion callback.</p>
<dl class="type">
<dt id="c.spi_message">
struct <code class="sig-name descname">spi_message</code><a class="headerlink" href="#c.spi_message" title="Permalink to this definition">¶</a></dt>
<dd><p>one multi-segment SPI transaction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_message {
    struct list_head        transfers;
    struct spi_device       *spi;
    unsigned is_dma_mapped:1;
    void (*complete)(void *context);
    void *context;
    unsigned frame_length;
    unsigned actual_length;
    int status;
    struct list_head        queue;
    void *state;
    struct list_head        resources;
    bool prepared;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">transfers</span></code></dt><dd><p>list of transfer segments in this transaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spi</span></code></dt><dd><p>SPI device to which the transaction is queued</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_dma_mapped</span></code></dt><dd><p>if true, the caller provided both dma and cpu virtual
addresses for each transfer buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">complete</span></code></dt><dd><p>called to report transaction completions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">context</span></code></dt><dd><p>the argument to complete() when it’s called</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frame_length</span></code></dt><dd><p>the total number of bytes in the message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">actual_length</span></code></dt><dd><p>the total number of bytes that were transferred in all
successful segments</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>zero for success, else negative errno</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue</span></code></dt><dd><p>for use by whichever driver currently owns the message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>for use by whichever driver currently owns the message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resources</span></code></dt><dd><p>for resource management when the spi message is processed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepared</span></code></dt><dd><p>spi_prepare_message was called for the this message</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A <strong>spi_message</strong> is used to execute an atomic sequence of data transfers,
each represented by a <a class="reference internal" href="#c.spi_transfer" title="spi_transfer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span></code></a>.  The sequence is “atomic”
in the sense that no other spi_message may use that SPI bus until that
sequence completes.  On some systems, many such sequences can execute as
a single programmed DMA transfer.  On all systems, these messages are
queued, and might complete after transactions to other devices.  Messages
sent to a given spi_device are always executed in FIFO order.</p>
<p>The code that submits an spi_message (and its spi_transfers)
to the lower layers is responsible for managing its memory.
Zero-initialize every field you don’t set up explicitly, to
insulate against future API updates.  After you submit a message
and its transfers, ignore them until its completion callback.</p>
<dl class="function">
<dt id="c.spi_message_init_with_transfers">
void <code class="sig-name descname">spi_message_init_with_transfers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a><em> *m</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a><em> *xfers</em>, unsigned int<em> num_xfers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_message_init_with_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize spi_message and append transfers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*m</span></code></dt><dd><p>spi_message to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*xfers</span></code></dt><dd><p>An array of spi transfers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_xfers</span></code></dt><dd><p>Number of items in the xfer array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes the given spi_message and adds each spi_transfer in
the given array to the message.</p>
</div>
<dl class="function">
<dt id="c.spi_is_bpw_supported">
bool <code class="sig-name descname">spi_is_bpw_supported</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, u32<em> bpw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_is_bpw_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if bits per word is supported</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>SPI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">bpw</span></code></dt><dd><p>Bits per word</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks to see if the SPI controller supports <strong>bpw</strong>.</p>
<p><strong>Return</strong></p>
<p>True if <strong>bpw</strong> is supported, false otherwise.</p>
</div>
<dl class="type">
<dt id="c.spi_replaced_transfers">
struct <code class="sig-name descname">spi_replaced_transfers</code><a class="headerlink" href="#c.spi_replaced_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>structure describing the spi_transfer replacements that have occurred so that they can get reverted</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_replaced_transfers {
    spi_replaced_release_t release;
    void *extradata;
    struct list_head replaced_transfers;
    struct list_head *replaced_after;
    size_t inserted;
    struct spi_transfer inserted_transfers[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>some extra release code to get executed prior to
relasing this structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extradata</span></code></dt><dd><p>pointer to some extra data if requested or NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">replaced_transfers</span></code></dt><dd><p>transfers that have been replaced and which need
to get restored</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">replaced_after</span></code></dt><dd><p>the transfer after which the <strong>replaced_transfers</strong>
are to get re-inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inserted</span></code></dt><dd><p>number of transfers inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inserted_transfers</span></code></dt><dd><p>array of spi_transfers of array-size <strong>inserted</strong>,
that have been replacing replaced_transfers</p>
</dd>
</dl>
</div>
<p><strong>note</strong></p>
<p>that <strong>extradata</strong> will point to <strong>inserted_transfers**[**inserted</strong>]
if some extra allocation is requested, so alignment will be the same
as for spi_transfers</p>
<dl class="function">
<dt id="c.spi_sync_transfer">
int <code class="sig-name descname">spi_sync_transfer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a><em> *xfers</em>, unsigned int<em> num_xfers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_sync_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronous SPI data transfer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>device with which data will be exchanged</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*xfers</span></code></dt><dd><p>An array of spi_transfers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_xfers</span></code></dt><dd><p>Number of items in the xfer array</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Does a synchronous SPI data transfer of the given spi_transfer array.</p>
<p>For more specific semantics see <a class="reference internal" href="#c.spi_sync" title="spi_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_sync()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.spi_write">
int <code class="sig-name descname">spi_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, const void<em> *buf</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_write" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous write</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>device to which data will be written</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>data buffer size</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This function writes the buffer <strong>buf</strong>.
Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.spi_read">
int <code class="sig-name descname">spi_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, void<em> *buf</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_read" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous read</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>device from which data will be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>data buffer size</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This function reads the buffer <strong>buf</strong>.
Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.spi_w8r8">
ssize_t <code class="sig-name descname">spi_w8r8</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, u8<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_w8r8" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous 8 bit write followed by 8 bit read</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>device with which data will be exchanged</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>command to be written before data is read back</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>the (unsigned) eight bit number returned by the
device, or else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.spi_w8r16">
ssize_t <code class="sig-name descname">spi_w8r16</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, u8<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_w8r16" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous 8 bit write followed by 16 bit read</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>device with which data will be exchanged</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>command to be written before data is read back</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>The number is returned in wire-order, which is at least sometimes
big-endian.</p>
<p>Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>the (unsigned) sixteen bit number returned by the
device, or else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.spi_w8r16be">
ssize_t <code class="sig-name descname">spi_w8r16be</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, u8<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_w8r16be" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous 8 bit write followed by 16 bit big-endian read</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>device with which data will be exchanged</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt><dd><p>command to be written before data is read back</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This function is similar to spi_w8r16, with the exception that it will
convert the read 16 bit data word from big-endian to native endianness.</p>
<p>Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>the (unsigned) sixteen bit number returned by the device in cpu
endianness, or else a negative error code.</p>
</div>
<dl class="type">
<dt id="c.spi_board_info">
struct <code class="sig-name descname">spi_board_info</code><a class="headerlink" href="#c.spi_board_info" title="Permalink to this definition">¶</a></dt>
<dd><p>board-specific template for a SPI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct spi_board_info {
    char modalias[SPI_NAME_SIZE];
    const void      *platform_data;
    const struct software_node *swnode;
    void *controller_data;
    int irq;
    u32 max_speed_hz;
    u16 bus_num;
    u16 chip_select;
    u32 mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">modalias</span></code></dt><dd><p>Initializes spi_device.modalias; identifies the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">platform_data</span></code></dt><dd><p>Initializes spi_device.platform_data; the particular
data stored there is driver-specific.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swnode</span></code></dt><dd><p>Software node for the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">controller_data</span></code></dt><dd><p>Initializes spi_device.controller_data; some
controllers need hints about hardware setup, e.g. for DMA.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>Initializes spi_device.irq; depends on how the board is wired.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_speed_hz</span></code></dt><dd><p>Initializes spi_device.max_speed_hz; based on limits
from the chip datasheet and board-specific signal quality issues.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_num</span></code></dt><dd><p>Identifies which spi_controller parents the spi_device; unused
by <a class="reference internal" href="#c.spi_new_device" title="spi_new_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_new_device()</span></code></a>, and otherwise depends on board wiring.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip_select</span></code></dt><dd><p>Initializes spi_device.chip_select; depends on how
the board is wired.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>Initializes spi_device.mode; based on the chip datasheet, board
wiring (some devices support both 3WIRE and standard modes), and
possibly presence of an inverter in the chipselect path.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>When adding new SPI devices to the device tree, these structures serve
as a partial device template.  They hold information which can’t always
be determined by drivers.  Information that probe() can establish (such
as the default transfer wordsize) is not included here.</p>
<p>These structures are used in two places.  Their primary role is to
be stored in tables of board-specific device descriptors, which are
declared early in board initialization and then used (much later) to
populate a controller’s device tree after the that controller’s driver
initializes.  A secondary (and atypical) role is as a parameter to
<a class="reference internal" href="#c.spi_new_device" title="spi_new_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_new_device()</span></code></a> call, which happens after those controller drivers
are active in some dynamic board configuration models.</p>
<dl class="function">
<dt id="c.spi_register_board_info">
int <code class="sig-name descname">spi_register_board_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_board_info" title="spi_board_info">spi_board_info</a> const<em> *info</em>, unsigned<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_register_board_info" title="Permalink to this definition">¶</a></dt>
<dd><p>register SPI devices for a given board</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_board_info</span> <span class="pre">const</span> <span class="pre">*info</span></code></dt><dd><p>array of chip descriptors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">n</span></code></dt><dd><p>how many descriptors are provided</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Board-specific early init code calls this (probably during arch_initcall)
with segments of the SPI device table.  Any device nodes are created later,
after the relevant parent SPI controller (bus_num) is defined.  We keep
this table of devices forever, so that reloading a controller driver will
not make Linux forget about these hard-wired devices.</p>
<p>Other code can also call this, e.g. a particular add-on board might provide
SPI devices through its expansion connector, so code initializing that board
would naturally declare its SPI devices.</p>
<p>The board info passed can safely be __initdata … but be careful of
any embedded pointers (platform_data, etc), they’re copied as-is.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.__spi_register_driver">
int <code class="sig-name descname">__spi_register_driver</code><span class="sig-paren">(</span>struct module<em> *owner</em>, struct <a class="reference internal" href="#c.spi_driver" title="spi_driver">spi_driver</a><em> *sdrv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__spi_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>register a SPI driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owner module of the driver to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_driver</span> <span class="pre">*sdrv</span></code></dt><dd><p>the driver to register</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.spi_alloc_device">
struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> * <code class="sig-name descname">spi_alloc_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_alloc_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a new SPI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>Controller to which device is connected</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Allows a driver to allocate and initialize a spi_device without
registering it immediately.  This allows a driver to directly
fill the spi_device with device parameters before calling
<a class="reference internal" href="#c.spi_add_device" title="spi_add_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_add_device()</span></code></a> on it.</p>
<p>Caller is responsible to call <a class="reference internal" href="#c.spi_add_device" title="spi_add_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_add_device()</span></code></a> on the returned
spi_device structure to add it to the SPI controller.  If the caller
needs to discard the spi_device without adding it, then it should
call spi_dev_put() on it.</p>
<p><strong>Return</strong></p>
<p>a pointer to the new device, or NULL.</p>
</div>
<dl class="function">
<dt id="c.spi_add_device">
int <code class="sig-name descname">spi_add_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_add_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Add spi_device allocated with spi_alloc_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>spi_device to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Companion function to spi_alloc_device.  Devices allocated with
spi_alloc_device can be added onto the spi bus with this function.</p>
<p><strong>Return</strong></p>
<p>0 on success; negative errno on failure</p>
</div>
<dl class="function">
<dt id="c.spi_new_device">
struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> * <code class="sig-name descname">spi_new_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em>, struct <a class="reference internal" href="#c.spi_board_info" title="spi_board_info">spi_board_info</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_new_device" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiate one new SPI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>Controller to which device is connected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_board_info</span> <span class="pre">*chip</span></code></dt><dd><p>Describes the SPI device</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>On typical mainboards, this is purely internal; and it’s not needed
after board init creates the hard-wired devices.  Some development
platforms may not be able to use spi_register_board_info though, and
this is exported so that for example a USB or parport based adapter
driver could add devices (which it would learn about out-of-band).</p>
<p><strong>Return</strong></p>
<p>the new device, or NULL.</p>
</div>
<dl class="function">
<dt id="c.spi_unregister_device">
void <code class="sig-name descname">spi_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a single SPI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>spi_device to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start making the passed SPI device vanish. Normally this would be handled
by <a class="reference internal" href="#c.spi_unregister_controller" title="spi_unregister_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_unregister_controller()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.spi_finalize_current_transfer">
void <code class="sig-name descname">spi_finalize_current_transfer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_finalize_current_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>report completion of a transfer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>the controller reporting completion</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by SPI drivers using the core transfer_one_message()
implementation to notify it that the current interrupt driven
transfer has finished and the next one may be scheduled.</p>
</div>
<dl class="function">
<dt id="c.spi_take_timestamp_pre">
void <code class="sig-name descname">spi_take_timestamp_pre</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a><em> *xfer</em>, size_t<em> progress</em>, bool<em> irqs_off</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_take_timestamp_pre" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to collect the beginning of the TX timestamp</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>Pointer to the spi_controller structure of the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*xfer</span></code></dt><dd><p>Pointer to the transfer being timestamped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">progress</span></code></dt><dd><p>How many words (not bytes) have been transferred so far</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">irqs_off</span></code></dt><dd><p>If true, will disable IRQs and preemption for the duration of the
transfer, for less jitter in time measurement. Only compatible
with PIO drivers. If true, must follow up with
spi_take_timestamp_post or otherwise system will crash.
WARNING: for fully predictable results, the CPU frequency must
also be under control (governor).</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper for drivers to collect the beginning of the TX timestamp
for the requested byte from the SPI transfer. The frequency with which this
function must be called (once per word, once for the whole transfer, once
per batch of words etc) is arbitrary as long as the <strong>tx</strong> buffer offset is
greater than or equal to the requested byte at the time of the call. The
timestamp is only taken once, at the first such call. It is assumed that
the driver advances its <strong>tx</strong> buffer pointer monotonically.</p>
</div>
<dl class="function">
<dt id="c.spi_take_timestamp_post">
void <code class="sig-name descname">spi_take_timestamp_post</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a><em> *xfer</em>, size_t<em> progress</em>, bool<em> irqs_off</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_take_timestamp_post" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to collect the end of the TX timestamp</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>Pointer to the spi_controller structure of the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*xfer</span></code></dt><dd><p>Pointer to the transfer being timestamped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">progress</span></code></dt><dd><p>How many words (not bytes) have been transferred so far</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">irqs_off</span></code></dt><dd><p>If true, will re-enable IRQs and preemption for the local CPU.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper for drivers to collect the end of the TX timestamp for
the requested byte from the SPI transfer. Can be called with an arbitrary
frequency: only the first call where <strong>tx</strong> exceeds or is equal to the
requested word will be timestamped.</p>
</div>
<dl class="function">
<dt id="c.spi_get_next_queued_message">
struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> * <code class="sig-name descname">spi_get_next_queued_message</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_get_next_queued_message" title="Permalink to this definition">¶</a></dt>
<dd><p>called by driver to check for queued messages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>the controller to check for queued messages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If there are more messages in the queue, the next message is returned from
this call.</p>
<p><strong>Return</strong></p>
<p>the next message in the queue, else NULL if the queue is empty.</p>
</div>
<dl class="function">
<dt id="c.spi_finalize_current_message">
void <code class="sig-name descname">spi_finalize_current_message</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_finalize_current_message" title="Permalink to this definition">¶</a></dt>
<dd><p>the current message is complete</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>the controller to return the message to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by the driver to notify the core that the message in the front of the
queue is complete and can be removed from the queue.</p>
</div>
<dl class="function">
<dt id="c.spi_new_ancillary_device">
struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> * <code class="sig-name descname">spi_new_ancillary_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, u8<em> chip_select</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_new_ancillary_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Register ancillary SPI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>Pointer to the main SPI device registering the ancillary device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">chip_select</span></code></dt><dd><p>Chip Select of the ancillary device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register an ancillary SPI device; for example some chips have a chip-select
for normal device usage and another one for setup/firmware upload.</p>
<p>This may only be called from main SPI device’s probe routine.</p>
<p><strong>Return</strong></p>
<p>0 on success; negative errno on failure</p>
</div>
<dl class="function">
<dt id="c.acpi_spi_count_resources">
int <code class="sig-name descname">acpi_spi_count_resources</code><span class="sig-paren">(</span>struct acpi_device<em> *adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_spi_count_resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of SpiSerialBus resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">acpi_device</span> <span class="pre">*adev</span></code></dt><dd><p>ACPI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of SpiSerialBus resources in the ACPI-device’s
resource-list; or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.acpi_spi_device_alloc">
struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> * <code class="sig-name descname">acpi_spi_device_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em>, struct acpi_device<em> *adev</em>, int<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_spi_device_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a spi device, and fill it in with ACPI information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>controller to which the spi device belongs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">acpi_device</span> <span class="pre">*adev</span></code></dt><dd><p>ACPI Device for the spi device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>Index of the spi resource inside the ACPI Node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be used to allocate a new spi device from and ACPI Node.
The caller is responsible for calling spi_add_device to register the spi device.</p>
<p>If ctlr is set to NULL, the Controller for the spi device will be looked up
using the resource.
If index is set to -1, index is not used.</p>
<p><strong>Note</strong></p>
<p>If index is -1, ctlr must be set.</p>
<p><strong>Return</strong></p>
<p>a pointer to the new device, or ERR_PTR on error.</p>
</div>
<dl class="function">
<dt id="c.spi_slave_abort">
int <code class="sig-name descname">spi_slave_abort</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_slave_abort" title="Permalink to this definition">¶</a></dt>
<dd><p>abort the ongoing transfer request on an SPI slave controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>device used for the current transfer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__spi_alloc_controller">
struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> * <code class="sig-name descname">__spi_alloc_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, unsigned int<em> size</em>, bool<em> slave</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__spi_alloc_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an SPI master or slave controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the controller, possibly using the platform_bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>how much zeroed driver-private data to allocate; the pointer to this
memory is in the driver_data field of the returned device, accessible
with spi_controller_get_devdata(); the memory is cacheline aligned;
drivers granting DMA access to portions of their private data need to
round up <strong>size</strong> using ALIGN(size, dma_get_cache_alignment()).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">slave</span></code></dt><dd><p>flag indicating whether to allocate an SPI master (false) or SPI
slave (true) controller</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call is used only by SPI controller drivers, which are the
only ones directly touching chip registers.  It’s how they allocate
an spi_controller structure, prior to calling <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_register_controller()</span></code></a>.</p>
<p>This must be called from context that can sleep.</p>
<p>The caller is responsible for assigning the bus number and initializing the
controller’s methods before calling <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_register_controller()</span></code></a>; and (after
errors adding the device) calling spi_controller_put() to prevent a memory
leak.</p>
<p><strong>Return</strong></p>
<p>the SPI controller structure on success, else NULL.</p>
</div>
<dl class="function">
<dt id="c.__devm_spi_alloc_controller">
struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> * <code class="sig-name descname">__devm_spi_alloc_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, unsigned int<em> size</em>, bool<em> slave</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__devm_spi_alloc_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>resource-managed <a class="reference internal" href="#c.__spi_alloc_controller" title="__spi_alloc_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">__spi_alloc_controller()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>physical device of SPI controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>how much zeroed driver-private data to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">slave</span></code></dt><dd><p>whether to allocate an SPI master (false) or SPI slave (true)</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Allocate an SPI controller and automatically release a reference on it
when <strong>dev</strong> is unbound from its driver.  Drivers are thus relieved from
having to call spi_controller_put().</p>
<p>The arguments to this function are identical to <a class="reference internal" href="#c.__spi_alloc_controller" title="__spi_alloc_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">__spi_alloc_controller()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>the SPI controller structure on success, else NULL.</p>
</div>
<dl class="function">
<dt id="c.spi_register_controller">
int <code class="sig-name descname">spi_register_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_register_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>register SPI master or slave controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>initialized master, originally from spi_alloc_master() or
spi_alloc_slave()</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>SPI controllers connect to their drivers using some non-SPI bus,
such as the platform bus.  The final stage of probe() in that code
includes calling <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_register_controller()</span></code></a> to hook up to this SPI bus glue.</p>
<p>SPI controllers use board specific (often SOC specific) bus numbers,
and board-specific addressing for SPI devices combines those numbers
with chip select numbers.  Since SPI does not directly support dynamic
device identification, boards need configuration tables telling which
chip is at which address.</p>
<p>This must be called from context that can sleep.  It returns zero on
success, else a negative error code (dropping the controller’s refcount).
After a successful return, the caller is responsible for calling
<a class="reference internal" href="#c.spi_unregister_controller" title="spi_unregister_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_unregister_controller()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.devm_spi_register_controller">
int <code class="sig-name descname">devm_spi_register_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_spi_register_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>register managed SPI master or slave controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device managing SPI controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>initialized controller, originally from spi_alloc_master() or
spi_alloc_slave()</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Register a SPI device as with <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">spi_register_controller()</span></code></a> which will
automatically be unregistered and freed.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.spi_unregister_controller">
void <code class="sig-name descname">spi_unregister_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_unregister_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister SPI master or slave controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>the controller being unregistered</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call is used only by SPI controller drivers, which are the
only ones directly touching chip registers.</p>
<p>This must be called from context that can sleep.</p>
<p>Note that this function also drops a reference to the controller.</p>
</div>
<dl class="function">
<dt id="c.spi_split_transfers_maxsize">
int <code class="sig-name descname">spi_split_transfers_maxsize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a><em> *msg</em>, size_t<em> maxsize</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_split_transfers_maxsize" title="Permalink to this definition">¶</a></dt>
<dd><p>split spi transfers into multiple transfers when an individual transfer exceeds a certain size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>the <strong>spi_controller</strong> for this transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*msg</span></code></dt><dd><p>the <strong>spi_message</strong> to transform</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">maxsize</span></code></dt><dd><p>the maximum when to apply this</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP allocation flags</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>status of transformation</p>
</div>
<dl class="function">
<dt id="c.spi_setup">
int <code class="sig-name descname">spi_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>setup SPI mode and clock rate</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>the device whose settings are being modified</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep, and no requests are queued to the device</p>
<p><strong>Description</strong></p>
<p>SPI protocol drivers may need to update the transfer mode if the
device doesn’t work with its default.  They may likewise need
to update clock rates or word sizes from initial values.  This function
changes those settings, and must be called from a context that can sleep.
Except for SPI_CS_HIGH, which takes effect immediately, the changes take
effect the next time the device is selected and data is transferred to
or from it.  When this function returns, the spi device is deselected.</p>
<p>Note that this call will fail if the protocol driver specifies an option
that the underlying controller or its driver does not support.  For
example, not all hardware supports wire transfers using nine bit words,
LSB-first wire encoding, or active-high chipselects.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.spi_async">
int <code class="sig-name descname">spi_async</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a><em> *message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_async" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronous SPI transfer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>device with which data will be exchanged</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*message</span></code></dt><dd><p>describes the data transfers, including completion callback</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>any (irqs may be blocked, etc)</p>
<p><strong>Description</strong></p>
<p>This call may be used in_irq and other contexts which can’t sleep,
as well as from task contexts which can sleep.</p>
<p>The completion callback is invoked in a context which can’t sleep.
Before that invocation, the value of message-&gt;status is undefined.
When the callback is issued, message-&gt;status holds either zero (to
indicate complete success) or a negative error code.  After that
callback returns, the driver which issued the transfer request may
deallocate the associated memory; it’s no longer in use by any SPI
core or controller driver code.</p>
<p>Note that although all messages to a spi_device are handled in
FIFO order, messages may go to different devices in other orders.
Some device might be higher priority, or have various “hard” access
time requirements, for example.</p>
<p>On detection of any fault during the transfer, processing of
the entire message is aborted, and the device is deselected.
Until returning from the associated message completion callback,
no other spi_message queued to that device will be processed.
(This rule applies equally to all the synchronous transfer calls,
which are wrappers around this core asynchronous primitive.)</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.spi_sync">
int <code class="sig-name descname">spi_sync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a><em> *message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>blocking/synchronous SPI data transfers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>device with which data will be exchanged</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*message</span></code></dt><dd><p>describes the data transfers</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.  Low-overhead controller
drivers may DMA directly into and out of the message buffers.</p>
<p>Note that the SPI device’s chip select is active during the message,
and then is normally disabled between messages.  Drivers for some
frequently-used devices may want to minimize costs of selecting a chip,
by leaving it selected in anticipation that the next message will go
to the same chip.  (That may increase power usage.)</p>
<p>Also, the caller is guaranteeing that the memory associated with the
message will not be freed before this call returns.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.spi_sync_locked">
int <code class="sig-name descname">spi_sync_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a><em> *message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_sync_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>version of spi_sync with exclusive bus usage</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>device with which data will be exchanged</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*message</span></code></dt><dd><p>describes the data transfers</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.  Low-overhead controller
drivers may DMA directly into and out of the message buffers.</p>
<p>This call should be used by drivers that require exclusive access to the
SPI bus. It has to be preceded by a spi_bus_lock call. The SPI bus must
be released by a spi_bus_unlock call when the exclusive access is over.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
<dl class="function">
<dt id="c.spi_bus_lock">
int <code class="sig-name descname">spi_bus_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_bus_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a lock for exclusive SPI bus usage</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>SPI bus master that should be locked for exclusive bus access</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.</p>
<p>This call should be used by drivers that require exclusive access to the
SPI bus. The SPI bus must be released by a spi_bus_unlock call when the
exclusive access is over. Data transfer must be done by spi_sync_locked
and spi_async_locked calls when the SPI bus lock is held.</p>
<p><strong>Return</strong></p>
<p>always zero.</p>
</div>
<dl class="function">
<dt id="c.spi_bus_unlock">
int <code class="sig-name descname">spi_bus_unlock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a><em> *ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_bus_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>release the lock for exclusive SPI bus usage</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*ctlr</span></code></dt><dd><p>SPI bus master that was locked for exclusive bus access</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.</p>
<p>This call releases an SPI bus lock previously obtained by an spi_bus_lock
call.</p>
<p><strong>Return</strong></p>
<p>always zero.</p>
</div>
<dl class="function">
<dt id="c.spi_write_then_read">
int <code class="sig-name descname">spi_write_then_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a><em> *spi</em>, const void<em> *txbuf</em>, unsigned<em> n_tx</em>, void<em> *rxbuf</em>, unsigned<em> n_rx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_write_then_read" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous write followed by read</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*spi</span></code></dt><dd><p>device with which data will be exchanged</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*txbuf</span></code></dt><dd><p>data to be written (need not be dma-safe)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">n_tx</span></code></dt><dd><p>size of txbuf, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*rxbuf</span></code></dt><dd><p>buffer into which data will be read (need not be dma-safe)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">n_rx</span></code></dt><dd><p>size of rxbuf, in bytes</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This performs a half duplex MicroWire style transaction with the
device, sending txbuf and then reading rxbuf.  The return value
is zero for success, else a negative errno status code.
This call may only be used from a context that may sleep.</p>
<p>Parameters to this routine are always copied using a small buffer.
Performance-sensitive or bulk transfer code should instead use
spi_{async,sync}() calls with dma-safe buffers.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/spi.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/spi.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>