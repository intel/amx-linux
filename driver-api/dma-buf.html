
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Buffer Sharing and Synchronization &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Device links" href="device_link.html" />
    <link rel="prev" title="Bus-Independent Device Accesses" href="device-io.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="buffer-sharing-and-synchronization">
<h1>Buffer Sharing and Synchronization<a class="headerlink" href="#buffer-sharing-and-synchronization" title="Permalink to this headline">¶</a></h1>
<p>The dma-buf subsystem provides the framework for sharing buffers for
hardware (DMA) access across multiple device drivers and subsystems, and
for synchronizing asynchronous hardware access.</p>
<p>This is used, for example, by drm “prime” multi-GPU support, but is of
course not limited to GPU use cases.</p>
<p>The three main components of this are: (1) dma-buf, representing a
sg_table and exposed to userspace as a file descriptor to allow passing
between devices, (2) fence, which provides a mechanism to signal when
one device has finished access, and (3) reservation, which manages the
shared or exclusive fence(s) associated with the buffer.</p>
<section id="shared-dma-buffers">
<h2>Shared DMA Buffers<a class="headerlink" href="#shared-dma-buffers" title="Permalink to this headline">¶</a></h2>
<p>This document serves as a guide to device-driver writers on what is the dma-buf
buffer sharing API, how to use it for exporting and using shared buffers.</p>
<p>Any device driver which wishes to be a part of DMA buffer sharing, can do so as
either the ‘exporter’ of buffers, or the ‘user’ or ‘importer’ of buffers.</p>
<p>Say a driver A wants to use buffers created by driver B, then we call B as the
exporter, and A as buffer-user/importer.</p>
<p>The exporter</p>
<blockquote>
<div><ul class="simple">
<li><p>implements and manages operations in <a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_ops</span></code></a> for the buffer,</p></li>
<li><p>allows other users to share the buffer by using dma_buf sharing APIs,</p></li>
<li><p>manages the details of buffer allocation, wrapped in a <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">dma_buf</span></code></a>,</p></li>
<li><p>decides about the actual backing storage where this allocation happens,</p></li>
<li><p>and takes care of any migration of scatterlist - for all (shared) users of
this buffer.</p></li>
</ul>
</div></blockquote>
<p>The buffer-user</p>
<blockquote>
<div><ul class="simple">
<li><p>is one of (many) sharing users of the buffer.</p></li>
<li><p>doesn’t need to worry about how the buffer is allocated, or where.</p></li>
<li><p>and needs a mechanism to get access to the scatterlist that makes up this
buffer in memory, mapped into its own address space, so it can access the
same area of memory. This interface is provided by <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">dma_buf_attachment</span></code></a>.</p></li>
</ul>
</div></blockquote>
<p>Any exporters or users of the dma-buf buffer sharing framework must have a
‘select DMA_SHARED_BUFFER’ in their respective Kconfigs.</p>
<section id="userspace-interface-notes">
<h3>Userspace Interface Notes<a class="headerlink" href="#userspace-interface-notes" title="Permalink to this headline">¶</a></h3>
<p>Mostly a DMA buffer file descriptor is simply an opaque object for userspace,
and hence the generic interface exposed is very minimal. There’s a few things to
consider though:</p>
<ul>
<li><p>Since kernel 3.12 the dma-buf FD supports the llseek system call, but only
with offset=0 and whence=SEEK_END|SEEK_SET. SEEK_SET is supported to allow
the usual size discover pattern size = SEEK_END(0); SEEK_SET(0). Every other
llseek operation will report -EINVAL.</p>
<p>If llseek on dma-buf FDs isn’t support the kernel will report -ESPIPE for all
cases. Userspace can use this to detect support for discovering the dma-buf
size using llseek.</p>
</li>
<li><p>In order to avoid fd leaks on exec, the FD_CLOEXEC flag must be set
on the file descriptor.  This is not just a resource leak, but a
potential security hole.  It could give the newly exec’d application
access to buffers, via the leaked fd, to which it should otherwise
not be permitted access.</p>
<p>The problem with doing this via a separate fcntl() call, versus doing it
atomically when the fd is created, is that this is inherently racy in a
multi-threaded app[3].  The issue is made worse when it is library code
opening/creating the file descriptor, as the application may not even be
aware of the fd’s.</p>
<p>To avoid this problem, userspace must have a way to request O_CLOEXEC
flag be set when the dma-buf fd is created.  So any API provided by
the exporting driver to create a dmabuf fd must provide a way to let
userspace control setting of O_CLOEXEC flag passed in to <a class="reference internal" href="#c.dma_buf_fd" title="dma_buf_fd"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_fd()</span></code></a>.</p>
</li>
<li><p>Memory mapping the contents of the DMA buffer is also supported. See the
discussion below on <a class="reference internal" href="#cpu-access-to-dma-buffer-objects">CPU Access to DMA Buffer Objects</a> for the full details.</p></li>
<li><p>The DMA buffer FD is also pollable, see <a class="reference internal" href="#implicit-fence-poll-support">Implicit Fence Poll Support</a> below for
details.</p></li>
<li><p>The DMA buffer FD also supports a few dma-buf-specific ioctls, see
<a class="reference internal" href="#dma-buffer-ioctls">DMA Buffer ioctls</a> below for details.</p></li>
</ul>
</section>
<section id="basic-operation-and-device-dma-access">
<h3>Basic Operation and Device DMA Access<a class="headerlink" href="#basic-operation-and-device-dma-access" title="Permalink to this headline">¶</a></h3>
<p>For device DMA access to a shared DMA buffer the usual sequence of operations
is fairly simple:</p>
<ol class="arabic">
<li><p>The exporter defines his exporter instance using
<a class="reference internal" href="#c.DEFINE_DMA_BUF_EXPORT_INFO" title="DEFINE_DMA_BUF_EXPORT_INFO"><code class="xref c c-func docutils literal notranslate"><span class="pre">DEFINE_DMA_BUF_EXPORT_INFO()</span></code></a> and calls <a class="reference internal" href="#c.dma_buf_export" title="dma_buf_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_export()</span></code></a> to wrap a private
buffer object into a <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>. It then exports that <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> to userspace
as a file descriptor by calling <a class="reference internal" href="#c.dma_buf_fd" title="dma_buf_fd"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_fd()</span></code></a>.</p></li>
<li><p>Userspace passes this file-descriptors to all drivers it wants this buffer
to share with: First the file descriptor is converted to a <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> using
<a class="reference internal" href="#c.dma_buf_get" title="dma_buf_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_get()</span></code></a>. Then the buffer is attached to the device using
<a class="reference internal" href="#c.dma_buf_attach" title="dma_buf_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_attach()</span></code></a>.</p>
<p>Up to this stage the exporter is still free to migrate or reallocate the
backing storage.</p>
</li>
<li><p>Once the buffer is attached to all devices userspace can initiate DMA
access to the shared buffer. In the kernel this is done by calling
<a class="reference internal" href="#c.dma_buf_map_attachment" title="dma_buf_map_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_attachment()</span></code></a> and <a class="reference internal" href="#c.dma_buf_unmap_attachment" title="dma_buf_unmap_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_unmap_attachment()</span></code></a>.</p></li>
<li><p>Once a driver is done with a shared buffer it needs to call
<a class="reference internal" href="#c.dma_buf_detach" title="dma_buf_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_detach()</span></code></a> (after cleaning up any mappings) and then release the
reference acquired with <a class="reference internal" href="#c.dma_buf_get" title="dma_buf_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_get()</span></code></a> by calling <a class="reference internal" href="#c.dma_buf_put" title="dma_buf_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_put()</span></code></a>.</p></li>
</ol>
<p>For the detailed semantics exporters are expected to implement see
<a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops</span></code></a>.</p>
</section>
<section id="cpu-access-to-dma-buffer-objects">
<h3>CPU Access to DMA Buffer Objects<a class="headerlink" href="#cpu-access-to-dma-buffer-objects" title="Permalink to this headline">¶</a></h3>
<p>There are mutliple reasons for supporting CPU access to a dma buffer object:</p>
<ul>
<li><p>Fallback operations in the kernel, for example when a device is connected
over USB and the kernel needs to shuffle the data around first before
sending it away. Cache coherency is handled by braketing any transactions
with calls to <a class="reference internal" href="#c.dma_buf_begin_cpu_access" title="dma_buf_begin_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_begin_cpu_access()</span></code></a> and <a class="reference internal" href="#c.dma_buf_end_cpu_access" title="dma_buf_end_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_end_cpu_access()</span></code></a>
access.</p>
<p>Since for most kernel internal dma-buf accesses need the entire buffer, a
vmap interface is introduced. Note that on very old 32-bit architectures
vmalloc space might be limited and result in vmap calls failing.</p>
<p>Interfaces:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void \*dma_buf_vmap(struct dma_buf \*dmabuf, struct iosys_map \*map)
void dma_buf_vunmap(struct dma_buf \*dmabuf, struct iosys_map \*map)
</pre></div>
</div>
<p>The vmap call can fail if there is no vmap support in the exporter, or if
it runs out of vmalloc space. Note that the dma-buf layer keeps a reference
count for all vmap access and calls down into the exporter’s vmap function
only when no vmapping exists, and only unmaps it once. Protection against
concurrent vmap/vunmap calls is provided by taking the <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.lock</span></code></a> mutex.</p>
</li>
<li><p>For full compatibility on the importer side with existing userspace
interfaces, which might already support mmap’ing buffers. This is needed in
many processing pipelines (e.g. feeding a software rendered image into a
hardware pipeline, thumbnail creation, snapshots, …). Also, Android’s ION
framework already supported this and for DMA buffer file descriptors to
replace ION buffers mmap support was needed.</p>
<p>There is no special interfaces, userspace simply calls mmap on the dma-buf
fd. But like for CPU access there’s a need to braket the actual access,
which is handled by the ioctl (DMA_BUF_IOCTL_SYNC). Note that
DMA_BUF_IOCTL_SYNC can fail with -EAGAIN or -EINTR, in which case it must
be restarted.</p>
<p>Some systems might need some sort of cache coherency management e.g. when
CPU and GPU domains are being accessed through dma-buf at the same time.
To circumvent this problem there are begin/end coherency markers, that
forward directly to existing dma-buf device drivers vfunc hooks. Userspace
can make use of those markers through the DMA_BUF_IOCTL_SYNC ioctl. The
sequence would be used like following:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li><p>mmap dma-buf fd</p></li>
<li><p>for each drawing/upload cycle in CPU 1. SYNC_START ioctl, 2. read/write
to mmap area 3. SYNC_END ioctl. This can be repeated as often as you
want (with the new data being consumed by say the GPU or the scanout
device)</p></li>
<li><p>munmap once you don’t need the buffer any more</p></li>
</ul>
</div></blockquote>
<p>For correctness and optimal performance, it is always required to use
SYNC_START and SYNC_END before and after, respectively, when accessing the
mapped address. Userspace cannot rely on coherent access, even when there
are systems where it just works without calling these ioctls.</p>
</div></blockquote>
</li>
<li><p>And as a CPU fallback in userspace processing pipelines.</p>
<p>Similar to the motivation for kernel cpu access it is again important that
the userspace code of a given importing subsystem can use the same
interfaces with a imported dma-buf buffer object as with a native buffer
object. This is especially important for drm where the userspace part of
contemporary OpenGL, X, and other drivers is huge, and reworking them to
use a different way to mmap a buffer rather invasive.</p>
<p>The assumption in the current dma-buf interfaces is that redirecting the
initial mmap is all that’s needed. A survey of some of the existing
subsystems shows that no driver seems to do any nefarious thing like
syncing up with outstanding asynchronous processing on the device or
allocating special resources at fault time. So hopefully this is good
enough, since adding interfaces to intercept pagefaults and allow pte
shootdowns would increase the complexity quite a bit.</p>
<p>Interface:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int dma_buf_mmap(struct dma_buf \*, struct vm_area_struct \*,
               unsigned long);
</pre></div>
</div>
<p>If the importing subsystem simply provides a special-purpose mmap call to
set up a mapping in userspace, calling do_mmap with <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.file</span></code></a> will
equally achieve that for a dma-buf object.</p>
</li>
</ul>
</section>
<section id="implicit-fence-poll-support">
<h3>Implicit Fence Poll Support<a class="headerlink" href="#implicit-fence-poll-support" title="Permalink to this headline">¶</a></h3>
<p>To support cross-device and cross-driver synchronization of buffer access
implicit fences (represented internally in the kernel with <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span></code></a>)
can be attached to a <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>. The glue for that and a few related things are
provided in the <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> structure.</p>
<p>Userspace can query the state of these implicitly tracked fences using poll()
and related system calls:</p>
<ul class="simple">
<li><p>Checking for EPOLLIN, i.e. read access, can be use to query the state of the
most recent write or exclusive fence.</p></li>
<li><p>Checking for EPOLLOUT, i.e. write access, can be used to query the state of
all attached fences, shared and exclusive ones.</p></li>
</ul>
<p>Note that this only signals the completion of the respective fences, i.e. the
DMA transfers are complete. Cache flushing and any other necessary
preparations before CPU access can begin still need to happen.</p>
<p>As an alternative to poll(), the set of fences on DMA buffer can be
exported as a <a class="reference internal" href="#c.sync_file" title="sync_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">sync_file</span></code></a> using <code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_sync_file_export</span></code>.</p>
</section>
<section id="dma-buf-statistics">
<h3>DMA-BUF statistics<a class="headerlink" href="#dma-buf-statistics" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">/sys/kernel/debug/dma_buf/bufinfo</span></code> provides an overview of every DMA-BUF
in the system. However, since debugfs is not safe to be mounted in
production, procfs and sysfs can be used to gather DMA-BUF statistics on
production systems.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">/proc/&lt;pid&gt;/fdinfo/&lt;fd&gt;</span></code> files in procfs can be used to gather
information about DMA-BUF fds. Detailed documentation about the interface
is present in <a class="reference internal" href="../filesystems/proc.html"><span class="doc">The /proc Filesystem</span></a>.</p>
<p>Unfortunately, the existing procfs interfaces can only provide information
about the DMA-BUFs for which processes hold fds or have the buffers mmapped
into their address space. This necessitated the creation of the DMA-BUF sysfs
statistics interface to provide per-buffer information on production systems.</p>
<p>The interface at <code class="docutils literal notranslate"><span class="pre">/sys/kernel/dma-buf/buffers</span></code> exposes information about
every DMA-BUF when <code class="docutils literal notranslate"><span class="pre">CONFIG_DMABUF_SYSFS_STATS</span></code> is enabled.</p>
<p>The following stats are exposed by the interface:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/kernel/dmabuf/buffers/&lt;inode_number&gt;/exporter_name</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">/sys/kernel/dmabuf/buffers/&lt;inode_number&gt;/size</span></code></p></li>
</ul>
<p>The information in the interface can also be used to derive per-exporter
statistics. The data from the interface can be gathered on error conditions
or other important events to provide a snapshot of DMA-BUF usage.
It can also be collected periodically by telemetry to monitor various metrics.</p>
<p>Detailed documentation about the interface is present in
Documentation/ABI/testing/sysfs-kernel-dmabuf-buffers.</p>
</section>
<section id="dma-buffer-ioctls">
<h3>DMA Buffer ioctls<a class="headerlink" href="#dma-buffer-ioctls" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.dma_buf_sync">
struct <code class="sig-name descname">dma_buf_sync</code><a class="headerlink" href="#c.dma_buf_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchronize with CPU access.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_sync {
    __u64 flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Set of access flags</p>
<dl class="simple">
<dt>DMA_BUF_SYNC_START:</dt><dd><p>Indicates the start of a map access session.</p>
</dd>
<dt>DMA_BUF_SYNC_END:</dt><dd><p>Indicates the end of a map access session.</p>
</dd>
<dt>DMA_BUF_SYNC_READ:</dt><dd><p>Indicates that the mapped DMA buffer will be read by the
client via the CPU map.</p>
</dd>
<dt>DMA_BUF_SYNC_WRITE:</dt><dd><p>Indicates that the mapped DMA buffer will be written by the
client via the CPU map.</p>
</dd>
<dt>DMA_BUF_SYNC_RW:</dt><dd><p>An alias for DMA_BUF_SYNC_READ | DMA_BUF_SYNC_WRITE.</p>
</dd>
</dl>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>When a DMA buffer is accessed from the CPU via mmap, it is not always
possible to guarantee coherency between the CPU-visible map and underlying
memory.  To manage coherency, DMA_BUF_IOCTL_SYNC must be used to bracket
any CPU access to give the kernel the chance to shuffle memory around if
needed.</p>
<p>Prior to accessing the map, the client must call DMA_BUF_IOCTL_SYNC
with DMA_BUF_SYNC_START and the appropriate read/write flags.  Once the
access is complete, the client should call DMA_BUF_IOCTL_SYNC with
DMA_BUF_SYNC_END and the same read/write flags.</p>
<p>The synchronization provided via DMA_BUF_IOCTL_SYNC only provides cache
coherency.  It does not prevent other processes or devices from
accessing the memory at the same time.  If synchronization with a GPU or
other device driver is required, it is the client’s responsibility to
wait for buffer to be ready for reading or writing before calling this
ioctl with DMA_BUF_SYNC_START.  Likewise, the client must ensure that
follow-up work is not submitted to GPU or other device driver until
after this ioctl has been called with DMA_BUF_SYNC_END?</p>
<p>If the driver or API with which the client is interacting uses implicit
synchronization, waiting for prior work to complete can be done via
poll() on the DMA buffer file descriptor.  If the driver or API requires
explicit synchronization, the client may have to wait on a sync_file or
other synchronization primitive outside the scope of the DMA buffer API.</p>
<dl class="type">
<dt id="c.dma_buf_export_sync_file">
struct <code class="sig-name descname">dma_buf_export_sync_file</code><a class="headerlink" href="#c.dma_buf_export_sync_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a sync_file from a dma-buf</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_export_sync_file {
    __u32 flags;
    __s32 fd;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Read/write flags</p>
<p>Must be DMA_BUF_SYNC_READ, DMA_BUF_SYNC_WRITE, or both.</p>
<p>If DMA_BUF_SYNC_READ is set and DMA_BUF_SYNC_WRITE is not set,
the returned sync file waits on any writers of the dma-buf to
complete.  Waiting on the returned sync file is equivalent to
poll() with POLLIN.</p>
<p>If DMA_BUF_SYNC_WRITE is set, the returned sync file waits on
any users of the dma-buf (read or write) to complete.  Waiting
on the returned sync file is equivalent to poll() with POLLOUT.
If both DMA_BUF_SYNC_WRITE and DMA_BUF_SYNC_READ are set, this
is equivalent to just DMA_BUF_SYNC_WRITE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fd</span></code></dt><dd><p>Returned sync file descriptor</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Userspace can perform a DMA_BUF_IOCTL_EXPORT_SYNC_FILE to retrieve the
current set of fences on a dma-buf file descriptor as a sync_file.  CPU
waits via poll() or other driver-specific mechanisms typically wait on
whatever fences are on the dma-buf at the time the wait begins.  This
is similar except that it takes a snapshot of the current fences on the
dma-buf for waiting later instead of waiting immediately.  This is
useful for modern graphics APIs such as Vulkan which assume an explicit
synchronization model but still need to inter-operate with dma-buf.</p>
<p>The intended usage pattern is the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Export a sync_file with flags corresponding to the expected GPU usage
via DMA_BUF_IOCTL_EXPORT_SYNC_FILE.</p></li>
<li><p>Submit rendering work which uses the dma-buf.  The work should wait on
the exported sync file before rendering and produce another sync_file
when complete.</p></li>
<li><p>Import the rendering-complete sync_file into the dma-buf with flags
corresponding to the GPU usage via DMA_BUF_IOCTL_IMPORT_SYNC_FILE.</p></li>
</ol>
</div></blockquote>
<p>Unlike doing implicit synchronization via a GPU kernel driver’s exec ioctl,
the above is not a single atomic operation.  If userspace wants to ensure
ordering via these fences, it is the respnosibility of userspace to use
locks or other mechanisms to ensure that no other context adds fences or
submits work between steps 1 and 3 above.</p>
<dl class="type">
<dt id="c.dma_buf_import_sync_file">
struct <code class="sig-name descname">dma_buf_import_sync_file</code><a class="headerlink" href="#c.dma_buf_import_sync_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a sync_file into a dma-buf</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_import_sync_file {
    __u32 flags;
    __s32 fd;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Read/write flags</p>
<p>Must be DMA_BUF_SYNC_READ, DMA_BUF_SYNC_WRITE, or both.</p>
<p>If DMA_BUF_SYNC_READ is set and DMA_BUF_SYNC_WRITE is not set,
this inserts the sync_file as a read-only fence.  Any subsequent
implicitly synchronized writes to this dma-buf will wait on this
fence but reads will not.</p>
<p>If DMA_BUF_SYNC_WRITE is set, this inserts the sync_file as a
write fence.  All subsequent implicitly synchronized access to
this dma-buf will wait on this fence.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fd</span></code></dt><dd><p>Sync file descriptor</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Userspace can perform a DMA_BUF_IOCTL_IMPORT_SYNC_FILE to insert a
sync_file into a dma-buf for the purposes of implicit synchronization
with other dma-buf consumers.  This allows clients using explicitly
synchronized APIs such as Vulkan to inter-op with dma-buf consumers
which expect implicit synchronization such as OpenGL or most media
drivers/video.</p>
</section>
<section id="dma-buf-locking-convention">
<h3>DMA-BUF locking convention<a class="headerlink" href="#dma-buf-locking-convention" title="Permalink to this headline">¶</a></h3>
<p>In order to avoid deadlock situations between dma-buf exports and importers,
all dma-buf API users must follow the common dma-buf locking convention.</p>
<p>Convention for importers</p>
<ol class="arabic">
<li><p>Importers must hold the dma-buf reservation lock when calling these
functions:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#c.dma_buf_pin" title="dma_buf_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_pin()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_unpin" title="dma_buf_unpin"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_unpin()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_map_attachment" title="dma_buf_map_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_attachment()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_unmap_attachment" title="dma_buf_unmap_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_unmap_attachment()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_vmap" title="dma_buf_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_vmap()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_vunmap" title="dma_buf_vunmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_vunmap()</span></code></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Importers must not hold the dma-buf reservation lock when calling these
functions:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#c.dma_buf_attach" title="dma_buf_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_attach()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_dynamic_attach" title="dma_buf_dynamic_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_dynamic_attach()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_detach" title="dma_buf_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_detach()</span></code></a></p></li>
<li><p>dma_buf_export(</p></li>
<li><p><a class="reference internal" href="#c.dma_buf_fd" title="dma_buf_fd"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_fd()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_get" title="dma_buf_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_get()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_put" title="dma_buf_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_put()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_mmap" title="dma_buf_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_mmap()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_begin_cpu_access" title="dma_buf_begin_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_begin_cpu_access()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_end_cpu_access" title="dma_buf_end_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_end_cpu_access()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_map_attachment_unlocked" title="dma_buf_map_attachment_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_attachment_unlocked()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_unmap_attachment_unlocked" title="dma_buf_unmap_attachment_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_unmap_attachment_unlocked()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_vmap_unlocked" title="dma_buf_vmap_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_vmap_unlocked()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_vunmap_unlocked" title="dma_buf_vunmap_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_vunmap_unlocked()</span></code></a></p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>Convention for exporters</p>
<ol class="arabic">
<li><p>These <a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops</span></code></a> callbacks are invoked with unlocked dma-buf
reservation and exporter can take the lock:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.attach()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.detach()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.release()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.begin_cpu_access()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.end_cpu_access()</span></code></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>These <a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops</span></code></a> callbacks are invoked with locked dma-buf
reservation and exporter can’t take the lock:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.pin()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.unpin()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.map_dma_buf()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.unmap_dma_buf()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.mmap()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.vmap()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.vunmap()</span></code></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Exporters must hold the dma-buf reservation lock when calling these
functions:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#c.dma_buf_move_notify" title="dma_buf_move_notify"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_move_notify()</span></code></a></p></li>
</ul>
</div></blockquote>
</li>
</ol>
</section>
<section id="kernel-functions-and-structures-reference">
<h3>Kernel Functions and Structures Reference<a class="headerlink" href="#kernel-functions-and-structures-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.dma_buf_export">
struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> * <code class="sig-name descname">dma_buf_export</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.dma_buf_export_info" title="dma_buf_export_info">dma_buf_export_info</a><em> *exp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_export" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new dma_buf, and associates an anon file with this buffer, so it can be exported. Also connect the allocator specific data and ops to the buffer. Additionally, provide a name string for exporter; useful in debugging.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_buf_export_info</span> <span class="pre">*exp_info</span></code></dt><dd><p>[in]    holds all the export related information provided
by the exporter. see <a class="reference internal" href="#c.dma_buf_export_info" title="dma_buf_export_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_export_info</span></code></a>
for further details.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns, on success, a newly created <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a> object, which wraps the
supplied private data and operations for <a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_ops</span></code></a>. On either
missing ops, or error in allocating <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a>, will return negative
error.</p>
<p>For most cases the easiest way to create <strong>exp_info</strong> is through the
<code class="docutils literal notranslate"><span class="pre">DEFINE_DMA_BUF_EXPORT_INFO</span></code> macro.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_fd">
int <code class="sig-name descname">dma_buf_fd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_fd" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a file descriptor for the given <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    pointer to dma_buf for which fd is required.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>[in]    flags to give to fd</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>On success, returns an associated ‘fd’. Else, returns error.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_get">
struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a> * <code class="sig-name descname">dma_buf_get</code><span class="sig-paren">(</span>int<em> fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_get" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a> related to an fd</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>[in]    fd associated with the <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a> to be returned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>On success, returns the <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a> associated with an fd; uses
file’s refcounting done by fget to increase refcount. returns ERR_PTR
otherwise.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_put">
void <code class="sig-name descname">dma_buf_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_put" title="Permalink to this definition">¶</a></dt>
<dd><p>decreases refcount of the buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer to reduce refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses file’s refcounting done implicitly by fput().</p>
<p>If, as a result of this call, the refcount becomes 0, the ‘release’ file
operation related to this fd is called. It calls <a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.release</span></code></a> vfunc
in turn, and frees the memory allocated for dmabuf when exported.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_dynamic_attach">
struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> * <code class="sig-name descname">dma_buf_dynamic_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct <a class="reference internal" href="#c.dma_buf_attach_ops" title="dma_buf_attach_ops">dma_buf_attach_ops</a><em> *importer_ops</em>, void<em> *importer_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_dynamic_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the device to dma_buf’s attachments list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer to attach device to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>[in]    device to be attached.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_buf_attach_ops</span> <span class="pre">*importer_ops</span></code></dt><dd><p>[in]    importer operations for the attachment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*importer_priv</span></code></dt><dd><p>[in]    importer private pointer for the attachment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span></code></a> pointer for this attachment. Attachments
must be cleaned up by calling <a class="reference internal" href="#c.dma_buf_detach" title="dma_buf_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_detach()</span></code></a>.</p>
<p>Optionally this calls <a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.attach</span></code></a> to allow device-specific attach
functionality.</p>
<p>A pointer to newly created <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment</span></code></a> on success, or a negative
error code wrapped into a pointer on failure.</p>
<p>Note that this can fail if the backing storage of <strong>dmabuf</strong> is in a place not
accessible to <strong>dev</strong>, and cannot be moved to a more suitable place. This is
indicated with the error code -EBUSY.</p>
<p><strong>Return</strong></p>
</div>
<dl class="function">
<dt id="c.dma_buf_attach">
struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> * <code class="sig-name descname">dma_buf_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for dma_buf_dynamic_attach</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer to attach device to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>[in]    device to be attached.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper to call <a class="reference internal" href="#c.dma_buf_dynamic_attach" title="dma_buf_dynamic_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_dynamic_attach()</span></code></a> for drivers which still use a static
mapping.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_detach">
void <code class="sig-name descname">dma_buf_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em>, struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em> *attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the given attachment from dmabuf’s attachments list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer to detach from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>[in]    attachment to be detached; is free’d after this call.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clean up a device attachment obtained by calling <a class="reference internal" href="#c.dma_buf_attach" title="dma_buf_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_attach()</span></code></a>.</p>
<p>Optionally this calls <a class="reference internal" href="#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_ops.detach</span></code></a> for device-specific detach.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_pin">
int <code class="sig-name descname">dma_buf_pin</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em> *attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock down the DMA-buf</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>[in]    attachment which should be pinned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only dynamic importers (who set up <strong>attach</strong> with <a class="reference internal" href="#c.dma_buf_dynamic_attach" title="dma_buf_dynamic_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_dynamic_attach()</span></code></a>) may
call this, and only for limited use cases like scanout and not for temporary
pin operations. It is not permitted to allow userspace to pin arbitrary
amounts of buffers through this interface.</p>
<p>Buffers must be unpinned by calling <a class="reference internal" href="#c.dma_buf_unpin" title="dma_buf_unpin"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_unpin()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_unpin">
void <code class="sig-name descname">dma_buf_unpin</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em> *attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_unpin" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpin a DMA-buf</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>[in]    attachment which should be unpinned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This unpins a buffer pinned by <a class="reference internal" href="#c.dma_buf_pin" title="dma_buf_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_pin()</span></code></a> and allows the exporter to move
any mapping of <strong>attach</strong> again and inform the importer through
<a class="reference internal" href="#c.dma_buf_attach_ops" title="dma_buf_attach_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attach_ops.move_notify</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_map_attachment">
struct sg_table * <code class="sig-name descname">dma_buf_map_attachment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em> *attach</em>, enum dma_data_direction<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_map_attachment" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the scatterlist table of the attachment; mapped into _device_ address space. Is a wrapper for map_dma_buf() of the dma_buf_ops.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>[in]    attachment whose scatterlist is to be returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt><dd><p>[in]    direction of DMA transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns sg_table containing the scatterlist to be returned; returns ERR_PTR
on error. May return -EINTR if it is interrupted by a signal.</p>
<p>On success, the DMA addresses and lengths in the returned scatterlist are
PAGE_SIZE aligned.</p>
<p>A mapping must be unmapped by using <a class="reference internal" href="#c.dma_buf_unmap_attachment" title="dma_buf_unmap_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_unmap_attachment()</span></code></a>. Note that
the underlying backing storage is pinned for as long as a mapping exists,
therefore users/importers should not hold onto a mapping for undue amounts of
time.</p>
<p>Important: Dynamic importers must wait for the exclusive fence of the <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">dma_resv</span></code></a> attached to the DMA-BUF first.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_map_attachment_unlocked">
struct sg_table * <code class="sig-name descname">dma_buf_map_attachment_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em> *attach</em>, enum dma_data_direction<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_map_attachment_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the scatterlist table of the attachment; mapped into _device_ address space. Is a wrapper for map_dma_buf() of the dma_buf_ops.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>[in]    attachment whose scatterlist is to be returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt><dd><p>[in]    direction of DMA transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocked variant of <a class="reference internal" href="#c.dma_buf_map_attachment" title="dma_buf_map_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_attachment()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_unmap_attachment">
void <code class="sig-name descname">dma_buf_unmap_attachment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em> *attach</em>, struct sg_table<em> *sg_table</em>, enum dma_data_direction<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_unmap_attachment" title="Permalink to this definition">¶</a></dt>
<dd><p>unmaps and decreases usecount of the buffer;might deallocate the scatterlist associated. Is a wrapper for unmap_dma_buf() of dma_buf_ops.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>[in]    attachment to unmap buffer from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sg_table</span></code></dt><dd><p>[in]    scatterlist info of the buffer to unmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt><dd><p>[in]    direction of DMA transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This unmaps a DMA mapping for <strong>attached</strong> obtained by <a class="reference internal" href="#c.dma_buf_map_attachment" title="dma_buf_map_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_attachment()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_unmap_attachment_unlocked">
void <code class="sig-name descname">dma_buf_unmap_attachment_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em> *attach</em>, struct sg_table<em> *sg_table</em>, enum dma_data_direction<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_unmap_attachment_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>unmaps and decreases usecount of the buffer;might deallocate the scatterlist associated. Is a wrapper for unmap_dma_buf() of dma_buf_ops.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>[in]    attachment to unmap buffer from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*sg_table</span></code></dt><dd><p>[in]    scatterlist info of the buffer to unmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt><dd><p>[in]    direction of DMA transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocked variant of <a class="reference internal" href="#c.dma_buf_unmap_attachment" title="dma_buf_unmap_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_unmap_attachment()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_move_notify">
void <code class="sig-name descname">dma_buf_move_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_move_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notify attachments that DMA-buf is moving</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer which is moving</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Informs all attachmenst that they need to destroy and recreated all their
mappings.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_begin_cpu_access">
int <code class="sig-name descname">dma_buf_begin_cpu_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em>, enum dma_data_direction<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_begin_cpu_access" title="Permalink to this definition">¶</a></dt>
<dd><p>Must be called before accessing a dma_buf from the cpu in the kernel context. Calls begin_cpu_access to allow exporter-specific preparations. Coherency is only guaranteed in the specified range for the specified access direction.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer to prepare cpu access for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt><dd><p>[in]    length of range for cpu access.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After the cpu access is complete the caller should call
<a class="reference internal" href="#c.dma_buf_end_cpu_access" title="dma_buf_end_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_end_cpu_access()</span></code></a>. Only when cpu access is braketed by both calls is
it guaranteed to be coherent with other DMA access.</p>
<p>This function will also wait for any DMA transactions tracked through
implicit synchronization in <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.resv</span></code></a>. For DMA transactions with explicit
synchronization this function will only ensure cache coherency, callers must
ensure synchronization with such DMA transactions on their own.</p>
<p>Can return negative error values, returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_end_cpu_access">
int <code class="sig-name descname">dma_buf_end_cpu_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em>, enum dma_data_direction<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_end_cpu_access" title="Permalink to this definition">¶</a></dt>
<dd><p>Must be called after accessing a dma_buf from the cpu in the kernel context. Calls end_cpu_access to allow exporter-specific actions. Coherency is only guaranteed in the specified range for the specified access direction.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer to complete cpu access for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt><dd><p>[in]    length of range for cpu access.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This terminates CPU access started with <a class="reference internal" href="#c.dma_buf_begin_cpu_access" title="dma_buf_begin_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_begin_cpu_access()</span></code></a>.</p>
<p>Can return negative error values, returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_mmap">
int <code class="sig-name descname">dma_buf_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em>, struct vm_area_struct<em> *vma</em>, unsigned long<em> pgoff</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup up a userspace mmap with the given vma</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer that should back the vma</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>[in]    vma for the mmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt><dd><p>[in]    offset in pages where this mmap should start within the
dma-buf buffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adjusts the passed in vma so that it points at the file of the
dma_buf operation. It also adjusts the starting pgoff and does bounds
checking on the size of the vma. Then it calls the exporters mmap function to
set up the mapping.</p>
<p>Can return negative error values, returns 0 on success.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_vmap">
int <code class="sig-name descname">dma_buf_vmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em>, struct <a class="reference internal" href="device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *map</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_vmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Create virtual mapping for the buffer object into kernel address space. Same restrictions as for vmap and friends apply.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer to vmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>[out]   returns the vmap pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call may fail due to lack of virtual mapping address space.
These calls are optional in drivers. The intended use for them
is for mapping objects linear in kernel space for high use objects.</p>
<p>To ensure coherency users must call <a class="reference internal" href="#c.dma_buf_begin_cpu_access" title="dma_buf_begin_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_begin_cpu_access()</span></code></a> and
<a class="reference internal" href="#c.dma_buf_end_cpu_access" title="dma_buf_end_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_end_cpu_access()</span></code></a> around any cpu access performed through this
mapping.</p>
<p>Returns 0 on success, or a negative errno code otherwise.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_vmap_unlocked">
int <code class="sig-name descname">dma_buf_vmap_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em>, struct <a class="reference internal" href="device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *map</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_vmap_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Create virtual mapping for the buffer object into kernel address space. Same restrictions as for vmap and friends apply.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer to vmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>[out]   returns the vmap pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocked version of <a class="reference internal" href="#c.dma_buf_vmap" title="dma_buf_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_vmap()</span></code></a></p>
<p>Returns 0 on success, or a negative errno code otherwise.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_vunmap">
void <code class="sig-name descname">dma_buf_vunmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em>, struct <a class="reference internal" href="device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *map</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_vunmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap a vmap obtained by dma_buf_vmap.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer to vunmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>[in]    vmap pointer to vunmap</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dma_buf_vunmap_unlocked">
void <code class="sig-name descname">dma_buf_vunmap_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em>, struct <a class="reference internal" href="device-io.html#c.iosys_map" title="iosys_map">iosys_map</a><em> *map</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_vunmap_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap a vmap obtained by dma_buf_vmap.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    buffer to vunmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iosys_map</span> <span class="pre">*map</span></code></dt><dd><p>[in]    vmap pointer to vunmap</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dma_buf_ops">
struct <code class="sig-name descname">dma_buf_ops</code><a class="headerlink" href="#c.dma_buf_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>operations possible on <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_ops {
    bool cache_sgt_mapping;
    int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
    void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
    int (*pin)(struct dma_buf_attachment *attach);
    void (*unpin)(struct dma_buf_attachment *attach);
    struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
    void (*unmap_dma_buf)(struct dma_buf_attachment *,struct sg_table *, enum dma_data_direction);
    void (*release)(struct dma_buf *);
    int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
    int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
    int (*mmap)(struct dma_buf *, struct vm_area_struct *vma);
    int (*vmap)(struct dma_buf *dmabuf, struct iosys_map *map);
    void (*vunmap)(struct dma_buf *dmabuf, struct iosys_map *map);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">cache_sgt_mapping</span></code></dt><dd><p>If true the framework will cache the first mapping made for each
attachment. This avoids creating mappings for attachments multiple
times.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">attach</span></code></dt><dd><p>This is called from <a class="reference internal" href="#c.dma_buf_attach" title="dma_buf_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_attach()</span></code></a> to make sure that a given
<a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment.dev</span></code></a> can access the provided <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>. Exporters
which support buffer objects in special locations like VRAM or
device-specific carveout areas should check whether the buffer could
be move to system memory (or directly accessed by the provided
device), and otherwise need to fail the attach operation.</p>
<p>The exporter should also in general check whether the current
allocation fulfills the DMA constraints of the new device. If this
is not the case, and the allocation cannot be moved, it should also
fail the attach operation.</p>
<p>Any exporter-private housekeeping data can be stored in the
<a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment.priv</span></code></a> pointer.</p>
<p>This callback is optional.</p>
<p>Returns:</p>
<p>0 on success, negative error code on failure. It might return -EBUSY
to signal that backing storage is already allocated and incompatible
with the requirements of requesting device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach</span></code></dt><dd><p>This is called by <a class="reference internal" href="#c.dma_buf_detach" title="dma_buf_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_detach()</span></code></a> to release a <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment</span></code></a>.
Provided so that exporters can clean up any housekeeping for an
<a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment</span></code></a>.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pin</span></code></dt><dd><p>This is called by <a class="reference internal" href="#c.dma_buf_pin" title="dma_buf_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_pin()</span></code></a> and lets the exporter know that the
DMA-buf can’t be moved any more. Ideally, the exporter should
pin the buffer so that it is generally accessible by all
devices.</p>
<p>This is called with the <code class="xref c c-type docutils literal notranslate"><span class="pre">dmabuf.resv</span></code> object locked and is mutual
exclusive with <strong>cache_sgt_mapping</strong>.</p>
<p>This is called automatically for non-dynamic importers from
<a class="reference internal" href="#c.dma_buf_attach" title="dma_buf_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_attach()</span></code></a>.</p>
<p>Note that similar to non-dynamic exporters in their <strong>map_dma_buf</strong>
callback the driver must guarantee that the memory is available for
use and cleared of any old data by the time this function returns.
Drivers which pipeline their buffer moves internally must wait for
all moves and clears to complete.</p>
<p>Returns:</p>
<p>0 on success, negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unpin</span></code></dt><dd><p>This is called by <a class="reference internal" href="#c.dma_buf_unpin" title="dma_buf_unpin"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_unpin()</span></code></a> and lets the exporter know that the
DMA-buf can be moved again.</p>
<p>This is called with the dmabuf-&gt;resv object locked and is mutual
exclusive with <strong>cache_sgt_mapping</strong>.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map_dma_buf</span></code></dt><dd><p>This is called by <a class="reference internal" href="#c.dma_buf_map_attachment" title="dma_buf_map_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_attachment()</span></code></a> and is used to map a
shared <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> into device address space, and it is mandatory. It
can only be called if <strong>attach</strong> has been called successfully.</p>
<p>This call may sleep, e.g. when the backing storage first needs to be
allocated, or moved to a location suitable for all currently attached
devices.</p>
<p>Note that any specific buffer attributes required for this function
should get added to device_dma_parameters accessible via
<a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device.dma_params</span></code></a> from the <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment</span></code></a>. The <strong>attach</strong> callback
should also check these constraints.</p>
<p>If this is being called for the first time, the exporter can now
choose to scan through the list of attachments for this buffer,
collate the requirements of the attached devices, and choose an
appropriate backing storage for the buffer.</p>
<p>Based on enum dma_data_direction, it might be possible to have
multiple users accessing at the same time (for reading, maybe), or
any other kind of sharing that the exporter might wish to make
available to buffer-users.</p>
<p>This is always called with the dmabuf-&gt;resv object locked when
the dynamic_mapping flag is true.</p>
<p>Note that for non-dynamic exporters the driver must guarantee that
that the memory is available for use and cleared of any old data by
the time this function returns.  Drivers which pipeline their buffer
moves internally must wait for all moves and clears to complete.
Dynamic exporters do not need to follow this rule: For non-dynamic
importers the buffer is already pinned through <strong>pin</strong>, which has the
same requirements. Dynamic importers otoh are required to obey the
dma_resv fences.</p>
<p>Returns:</p>
<p>A <code class="xref c c-type docutils literal notranslate"><span class="pre">sg_table</span></code> scatter list of the backing storage of the DMA buffer,
already mapped into the device address space of the <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a> attached
with the provided <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attachment</span></code></a>. The addresses and lengths in
the scatter list are PAGE_SIZE aligned.</p>
<p>On failure, returns a negative error value wrapped into a pointer.
May also return -EINTR when a signal was received while being
blocked.</p>
<p>Note that exporters should not try to cache the scatter list, or
return the same one for multiple calls. Caching is done either by the
DMA-BUF code (for non-dynamic importers) or the importer. Ownership
of the scatter list is transferred to the caller, and returned by
<strong>unmap_dma_buf</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unmap_dma_buf</span></code></dt><dd><p>This is called by <a class="reference internal" href="#c.dma_buf_unmap_attachment" title="dma_buf_unmap_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_unmap_attachment()</span></code></a> and should unmap and
release the <code class="xref c c-type docutils literal notranslate"><span class="pre">sg_table</span></code> allocated in <strong>map_dma_buf</strong>, and it is mandatory.
For static dma_buf handling this might also unpin the backing
storage if this is the last mapping of the DMA buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>Called after the last dma_buf_put to release the <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a>, and
mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">begin_cpu_access</span></code></dt><dd><p>This is called from <a class="reference internal" href="#c.dma_buf_begin_cpu_access" title="dma_buf_begin_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_begin_cpu_access()</span></code></a> and allows the
exporter to ensure that the memory is actually coherent for cpu
access. The exporter also needs to ensure that cpu access is coherent
for the access direction. The direction can be used by the exporter
to optimize the cache flushing, i.e. access with a different
direction (read instead of write) might return stale or even bogus
data (e.g. when the exporter needs to copy the data to temporary
storage).</p>
<p>Note that this is both called through the DMA_BUF_IOCTL_SYNC IOCTL
command for userspace mappings established through <strong>mmap</strong>, and also
for kernel mappings established with <strong>vmap</strong>.</p>
<p>This callback is optional.</p>
<p>Returns:</p>
<p>0 on success or a negative error code on failure. This can for
example fail when the backing storage can’t be allocated. Can also
return -ERESTARTSYS or -EINTR when the call has been interrupted and
needs to be restarted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end_cpu_access</span></code></dt><dd><p>This is called from <a class="reference internal" href="#c.dma_buf_end_cpu_access" title="dma_buf_end_cpu_access"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_end_cpu_access()</span></code></a> when the importer is
done accessing the CPU. The exporter can use this to flush caches and
undo anything else done in <strong>begin_cpu_access</strong>.</p>
<p>This callback is optional.</p>
<p>Returns:</p>
<p>0 on success or a negative error code on failure. Can return
-ERESTARTSYS or -EINTR when the call has been interrupted and needs
to be restarted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap</span></code></dt><dd><p>This callback is used by the <a class="reference internal" href="#c.dma_buf_mmap" title="dma_buf_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_mmap()</span></code></a> function</p>
<p>Note that the mapping needs to be incoherent, userspace is expected
to bracket CPU access using the DMA_BUF_IOCTL_SYNC interface.</p>
<p>Because dma-buf buffers have invariant size over their lifetime, the
dma-buf core checks whether a vma is too large and rejects such
mappings. The exporter hence does not need to duplicate this check.
Drivers do not need to check this themselves.</p>
<p>If an exporter needs to manually flush caches and hence needs to fake
coherency for mmap support, it needs to be able to zap all the ptes
pointing at the backing storage. Now linux mm needs a <a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">address_space</span></code></a> associated with the struct file stored in vma-&gt;vm_file
to do that with the function unmap_mapping_range. But the dma_buf
framework only backs every dma_buf fd with the anon_file struct file,
i.e. all dma_bufs share the same file.</p>
<p>Hence exporters need to setup their own file (and address_space)
association by setting vma-&gt;vm_file and adjusting vma-&gt;vm_pgoff in
the dma_buf mmap callback. In the specific case of a gem driver the
exporter could use the shmem file already provided by gem (and set
vm_pgoff = 0). Exporters can then zap ptes by unmapping the
corresponding range of the <a class="reference internal" href="../filesystems/api-summary.html#c.address_space" title="address_space"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">address_space</span></code></a> associated with their
own file.</p>
<p>This callback is optional.</p>
<p>Returns:</p>
<p>0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vmap</span></code></dt><dd><p>[optional] creates a virtual mapping for the buffer into kernel
address space. Same restrictions as for vmap and friends apply.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vunmap</span></code></dt><dd><p>[optional] unmaps a vmap from the buffer</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dma_buf">
struct <code class="sig-name descname">dma_buf</code><a class="headerlink" href="#c.dma_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>shared buffer object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf {
    size_t size;
    struct file *file;
    struct list_head attachments;
    const struct dma_buf_ops *ops;
    unsigned vmapping_counter;
    struct iosys_map vmap_ptr;
    const char *exp_name;
    const char *name;
    spinlock_t name_lock;
    struct module *owner;
    struct list_head list_node;
    void *priv;
    struct dma_resv *resv;
    wait_queue_head_t poll;
    struct dma_buf_poll_cb_t {
        struct dma_fence_cb cb;
        wait_queue_head_t *poll;
        __poll_t active;
    } cb_in, cb_out;
#ifdef CONFIG_DMABUF_SYSFS_STATS;
    struct dma_buf_sysfs_entry {
        struct kobject kobj;
        struct dma_buf *dmabuf;
    } *sysfs_entry;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the buffer; invariant over the lifetime of the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>File pointer used for sharing buffers across, and for refcounting.
See <a class="reference internal" href="#c.dma_buf_get" title="dma_buf_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_get()</span></code></a> and <a class="reference internal" href="#c.dma_buf_put" title="dma_buf_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_put()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">attachments</span></code></dt><dd><p>List of dma_buf_attachment that denotes all devices attached,
protected by <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> lock <strong>resv</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>dma_buf_ops associated with this buffer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vmapping_counter</span></code></dt><dd><p>Used internally to refcnt the vmaps returned by <a class="reference internal" href="#c.dma_buf_vmap" title="dma_buf_vmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_vmap()</span></code></a>.
Protected by <strong>lock</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vmap_ptr</span></code></dt><dd><p>The current vmap ptr if <strong>vmapping_counter</strong> &gt; 0. Protected by <strong>lock</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exp_name</span></code></dt><dd><p>Name of the exporter; useful for debugging. See the
DMA_BUF_SET_NAME IOCTL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Userspace-provided name; useful for accounting and debugging,
protected by <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> on <strong>resv</strong> and <strong>name_lock</strong> for read access.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name_lock</span></code></dt><dd><p>Spinlock to protect name acces for read access.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>Pointer to exporter module; used for refcounting when exporter is a
kernel module.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list_node</span></code></dt><dd><p>node for dma_buf accounting and debugging.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>exporter specific private data for this buffer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resv</span></code></dt><dd><p>Reservation object linked to this dma-buf.</p>
<p>IMPLICIT SYNCHRONIZATION RULES:</p>
<p>Drivers which support implicit synchronization of buffer access as
e.g. exposed in <a class="reference internal" href="#implicit-fence-poll-support">Implicit Fence Poll Support</a> must follow the
below rules.</p>
<ul class="simple">
<li><p>Drivers must add a read fence through <a class="reference internal" href="#c.dma_resv_add_fence" title="dma_resv_add_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_add_fence()</span></code></a> with the
DMA_RESV_USAGE_READ flag for anything the userspace API considers a
read access. This highly depends upon the API and window system.</p></li>
<li><p>Similarly drivers must add a write fence through
<a class="reference internal" href="#c.dma_resv_add_fence" title="dma_resv_add_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_add_fence()</span></code></a> with the DMA_RESV_USAGE_WRITE flag for
anything the userspace API considers write access.</p></li>
<li><p>Drivers may just always add a write fence, since that only
causes unecessarily synchronization, but no correctness issues.</p></li>
<li><p>Some drivers only expose a synchronous userspace API with no
pipelining across drivers. These do not set any fences for their
access. An example here is v4l.</p></li>
<li><p>Driver should use <a class="reference internal" href="#c.dma_resv_usage_rw" title="dma_resv_usage_rw"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_usage_rw()</span></code></a> when retrieving fences as
dependency for implicit synchronization.</p></li>
</ul>
<p>DYNAMIC IMPORTER RULES:</p>
<p>Dynamic importers, see <a class="reference internal" href="#c.dma_buf_attachment_is_dynamic" title="dma_buf_attachment_is_dynamic"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_attachment_is_dynamic()</span></code></a>, have
additional constraints on how they set up fences:</p>
<ul class="simple">
<li><p>Dynamic importers must obey the write fences and wait for them to
signal before allowing access to the buffer’s underlying storage
through the device.</p></li>
<li><p>Dynamic importers should set fences for any access that they can’t
disable immediately from their <a class="reference internal" href="#c.dma_buf_attach_ops" title="dma_buf_attach_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf_attach_ops.move_notify</span></code></a>
callback.</p></li>
</ul>
<p>IMPORTANT:</p>
<p>All drivers and memory management related functions must obey the
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> rules, specifically the rules for updating and
obeying fences. See <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span></code></a> for further descriptions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll</span></code></dt><dd><p>for userspace poll support</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb_in</span></code></dt><dd><p>for userspace poll support</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb_out</span></code></dt><dd><p>for userspace poll support</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs_entry</span></code></dt><dd><p>For exposing information about this buffer in sysfs. See also
<a class="reference internal" href="#dma-buf-statistics">DMA-BUF statistics</a> for the uapi this enables.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This represents a shared buffer, created by calling <a class="reference internal" href="#c.dma_buf_export" title="dma_buf_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_export()</span></code></a>. The
userspace representation is a normal file descriptor, which can be created by
calling <a class="reference internal" href="#c.dma_buf_fd" title="dma_buf_fd"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_fd()</span></code></a>.</p>
<p>Shared dma buffers are reference counted using <a class="reference internal" href="#c.dma_buf_put" title="dma_buf_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_put()</span></code></a> and
<a class="reference internal" href="#c.get_dma_buf" title="get_dma_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_dma_buf()</span></code></a>.</p>
<p>Device DMA access is handled by the separate <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span></code></a>.</p>
<dl class="type">
<dt id="c.dma_buf_attach_ops">
struct <code class="sig-name descname">dma_buf_attach_ops</code><a class="headerlink" href="#c.dma_buf_attach_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>importer operations for an attachment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_attach_ops {
    bool allow_peer2peer;
    void (*move_notify)(struct dma_buf_attachment *attach);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">allow_peer2peer</span></code></dt><dd><p>If this is set to true the importer must be able to handle peer
resources without struct pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">move_notify</span></code></dt><dd><p>[optional] notification that the DMA-buf is moving</p>
<p>If this callback is provided the framework can avoid pinning the
backing store while mappings exists.</p>
<p>This callback is called with the lock of the reservation object
associated with the dma_buf held and the mapping function must be
called with this lock held as well. This makes sure that no mapping
is created concurrently with an ongoing move operation.</p>
<p>Mappings stay valid and are not directly affected by this callback.
But the DMA-buf can now be in a different physical location, so all
mappings should be destroyed and re-created as soon as possible.</p>
<p>New mappings can be created after this callback returns, and will
point to the new location of the DMA-buf.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Attachment operations implemented by the importer.</p>
<dl class="type">
<dt id="c.dma_buf_attachment">
struct <code class="sig-name descname">dma_buf_attachment</code><a class="headerlink" href="#c.dma_buf_attachment" title="Permalink to this definition">¶</a></dt>
<dd><p>holds device-buffer attachment data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_attachment {
    struct dma_buf *dmabuf;
    struct device *dev;
    struct list_head node;
    struct sg_table *sgt;
    enum dma_data_direction dir;
    bool peer2peer;
    const struct dma_buf_attach_ops *importer_ops;
    void *importer_priv;
    void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dmabuf</span></code></dt><dd><p>buffer for this attachment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device attached to the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>list of dma_buf_attachment, protected by dma_resv lock of the dmabuf.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sgt</span></code></dt><dd><p>cached mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dir</span></code></dt><dd><p>direction of cached mapping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peer2peer</span></code></dt><dd><p>true if the importer can handle peer resources without pages.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">importer_ops</span></code></dt><dd><p>importer operations for this attachment, if provided
dma_buf_map/unmap_attachment() must be called with the dma_resv lock held.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">importer_priv</span></code></dt><dd><p>importer specific attachment data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>exporter specific attachment data.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure holds the attachment information between the dma_buf buffer
and its user device(s). The list contains one attachment struct per device
attached to the buffer.</p>
<p>An attachment is created by calling <a class="reference internal" href="#c.dma_buf_attach" title="dma_buf_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_attach()</span></code></a>, and released again by
calling <a class="reference internal" href="#c.dma_buf_detach" title="dma_buf_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_detach()</span></code></a>. The DMA mapping itself needed to initiate a
transfer is created by <a class="reference internal" href="#c.dma_buf_map_attachment" title="dma_buf_map_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_map_attachment()</span></code></a> and freed again by calling
<a class="reference internal" href="#c.dma_buf_unmap_attachment" title="dma_buf_unmap_attachment"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_unmap_attachment()</span></code></a>.</p>
<dl class="type">
<dt id="c.dma_buf_export_info">
struct <code class="sig-name descname">dma_buf_export_info</code><a class="headerlink" href="#c.dma_buf_export_info" title="Permalink to this definition">¶</a></dt>
<dd><p>holds information needed to export a dma_buf</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_buf_export_info {
    const char *exp_name;
    struct module *owner;
    const struct dma_buf_ops *ops;
    size_t size;
    int flags;
    struct dma_resv *resv;
    void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">exp_name</span></code></dt><dd><p>name of the exporter - useful for debugging.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>pointer to exporter module - used for refcounting kernel module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Attach allocator-defined dma buf ops to the new buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the buffer - invariant over the lifetime of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>mode flags for the file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resv</span></code></dt><dd><p>reservation-object, NULL to allocate default one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>Attach private data of allocator to this buffer</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure holds the information required to export the buffer. Used
with <a class="reference internal" href="#c.dma_buf_export" title="dma_buf_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_export()</span></code></a> only.</p>
<dl class="function">
<dt id="c.DEFINE_DMA_BUF_EXPORT_INFO">
<code class="sig-name descname">DEFINE_DMA_BUF_EXPORT_INFO</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_DMA_BUF_EXPORT_INFO" title="Permalink to this definition">¶</a></dt>
<dd><p>helper macro for exporters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>export-info name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>DEFINE_DMA_BUF_EXPORT_INFO macro defines the <a class="reference internal" href="#c.dma_buf_export_info" title="dma_buf_export_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_export_info</span></code></a>,
zeroes it out and pre-populates exp_name in it.</p>
</div>
<dl class="function">
<dt id="c.get_dma_buf">
void <code class="sig-name descname">get_dma_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_dma_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>convenience wrapper for get_file.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>[in]    pointer to dma_buf</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments the reference count on the dma-buf, needed in case of drivers
that either need to create additional references to the dmabuf on the
kernel side.  For example, an exporter that needs to keep a dmabuf ptr
so that subsequent exports don’t create a new dmabuf.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_is_dynamic">
bool <code class="sig-name descname">dma_buf_is_dynamic</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf" title="dma_buf">dma_buf</a><em> *dmabuf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_is_dynamic" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a DMA-buf uses dynamic mappings.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*dmabuf</span></code></dt><dd><p>the DMA-buf to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if a DMA-buf exporter wants to be called with the dma_resv
locked for the map/unmap callbacks, false if it doesn’t wants to be called
with the lock held.</p>
</div>
<dl class="function">
<dt id="c.dma_buf_attachment_is_dynamic">
bool <code class="sig-name descname">dma_buf_attachment_is_dynamic</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a><em> *attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_buf_attachment_is_dynamic" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a DMA-buf attachment uses dynamic mappings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*attach</span></code></dt><dd><p>the DMA-buf attachment to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if a DMA-buf importer wants to call the map/unmap functions with
the dma_resv lock held.</p>
</div>
</section>
</section>
<section id="reservation-objects">
<h2>Reservation Objects<a class="headerlink" href="#reservation-objects" title="Permalink to this headline">¶</a></h2>
<p>The reservation object provides a mechanism to manage a container of
dma_fence object associated with a resource. A reservation object
can have any number of fences attaches to it. Each fence carries an usage
parameter determining how the operation represented by the fence is using the
resource. The RCU mechanism is used to protect read access to fences from
locked write-side updates.</p>
<p>See <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> for more details.</p>
<dl class="function">
<dt id="c.dma_resv_init">
void <code class="sig-name descname">dma_resv_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a reservation object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dma_resv_fini">
void <code class="sig-name descname">dma_resv_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>destroys a reservation object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dma_resv_reserve_fences">
int <code class="sig-name descname">dma_resv_reserve_fences</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, unsigned int<em> num_fences</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_reserve_fences" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve space to add fences to a dma_resv object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_fences</span></code></dt><dd><p>number of fences we want to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called before <a class="reference internal" href="#c.dma_resv_add_fence" title="dma_resv_add_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_add_fence()</span></code></a>.  Must be called with <strong>obj</strong>
locked through <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a>.</p>
<p>Note that the preallocated slots need to be re-reserved if <strong>obj</strong> is unlocked
at any time before calling <a class="reference internal" href="#c.dma_resv_add_fence" title="dma_resv_add_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_add_fence()</span></code></a>. This is validated when
CONFIG_DEBUG_MUTEXES is enabled.</p>
<p>RETURNS
Zero for success, or -errno</p>
</div>
<dl class="function">
<dt id="c.dma_resv_reset_max_fences">
void <code class="sig-name descname">dma_resv_reset_max_fences</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_reset_max_fences" title="Permalink to this definition">¶</a></dt>
<dd><p>reset fences for debugging</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the dma_resv object to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset the number of pre-reserved fence slots to test that drivers do
correct slot allocation using <a class="reference internal" href="#c.dma_resv_reserve_fences" title="dma_resv_reserve_fences"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_reserve_fences()</span></code></a>. See also
<code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv_list.max_fences</span></code>.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_add_fence">
void <code class="sig-name descname">dma_resv_add_fence</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, enum <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage">dma_resv_usage</a><em> usage</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_add_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a fence to the dma_resv obj</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">usage</span></code></dt><dd><p>how the fence is used, see <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a fence to a slot, <strong>obj</strong> must be locked with <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a>, and
<a class="reference internal" href="#c.dma_resv_reserve_fences" title="dma_resv_reserve_fences"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_reserve_fences()</span></code></a> has been called.</p>
<p>See also <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.fence</span></code></a> for a discussion of the semantics.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_replace_fences">
void <code class="sig-name descname">dma_resv_replace_fences</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, uint64_t<em> context</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *replacement</em>, enum <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage">dma_resv_usage</a><em> usage</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_replace_fences" title="Permalink to this definition">¶</a></dt>
<dd><p>replace fences in the dma_resv obj</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">context</span></code></dt><dd><p>the context of the fences to replace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*replacement</span></code></dt><dd><p>the new fence to use instead</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">usage</span></code></dt><dd><p>how the new fence is used, see <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replace fences with a specified context with a new fence. Only valid if the
operation represented by the original fence has no longer access to the
resources represented by the dma_resv object when the new fence completes.</p>
<p>And example for using this is replacing a preemption fence with a page table
update fence which makes the resource inaccessible.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_iter_first_unlocked">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_resv_iter_first_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter">dma_resv_iter</a><em> *cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_first_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>first fence in an unlocked dma_resv obj.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>the cursor with the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Subsequent fences are iterated with <a class="reference internal" href="#c.dma_resv_iter_next_unlocked" title="dma_resv_iter_next_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_next_unlocked()</span></code></a>.</p>
<p>Beware that the iterator can be restarted.  Code which accumulates statistics
or similar needs to check for this with <a class="reference internal" href="#c.dma_resv_iter_is_restarted" title="dma_resv_iter_is_restarted"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_is_restarted()</span></code></a>. For
this reason prefer the locked <a class="reference internal" href="#c.dma_resv_iter_first" title="dma_resv_iter_first"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_first()</span></code></a> whenver possible.</p>
<p>Returns the first fence from an unlocked dma_resv obj.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_iter_next_unlocked">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_resv_iter_next_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter">dma_resv_iter</a><em> *cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_next_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>next fence in an unlocked dma_resv obj.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>the cursor with the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Beware that the iterator can be restarted.  Code which accumulates statistics
or similar needs to check for this with <a class="reference internal" href="#c.dma_resv_iter_is_restarted" title="dma_resv_iter_is_restarted"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_is_restarted()</span></code></a>. For
this reason prefer the locked <a class="reference internal" href="#c.dma_resv_iter_next" title="dma_resv_iter_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_next()</span></code></a> whenver possible.</p>
<p>Returns the next fence from an unlocked dma_resv obj.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_iter_first">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_resv_iter_first</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter">dma_resv_iter</a><em> *cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_first" title="Permalink to this definition">¶</a></dt>
<dd><p>first fence from a locked dma_resv object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>cursor to record the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Subsequent fences are iterated with <a class="reference internal" href="#c.dma_resv_iter_next_unlocked" title="dma_resv_iter_next_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_next_unlocked()</span></code></a>.</p>
<p>Return the first fence in the dma_resv object while holding the
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.lock</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_iter_next">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_resv_iter_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter">dma_resv_iter</a><em> *cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>next fence from a locked dma_resv object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>cursor to record the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the next fences from the dma_resv object while holding the
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.lock</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_copy_fences">
int <code class="sig-name descname">dma_resv_copy_fences</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *dst</em>, struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_copy_fences" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy all fences from src to dst.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*dst</span></code></dt><dd><p>the destination reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*src</span></code></dt><dd><p>the source reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy all fences from src to dst. dst-lock must be held.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_get_fences">
int <code class="sig-name descname">dma_resv_get_fences</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, enum <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage">dma_resv_usage</a><em> usage</em>, unsigned int<em> *num_fences</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> ***fences</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_get_fences" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an object’s fences fences without update side lock held</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">usage</span></code></dt><dd><p>controls which fences to include, see <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*num_fences</span></code></dt><dd><p>the number of fences returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">***fences</span></code></dt><dd><p>the array of fence ptrs returned (array is krealloc’d to the
required size, and must be freed by caller)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve all fences from the reservation object.
Returns either zero or -ENOMEM.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_get_singleton">
int <code class="sig-name descname">dma_resv_get_singleton</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, enum <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage">dma_resv_usage</a><em> usage</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> **fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_get_singleton" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a single fence for all the fences</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">usage</span></code></dt><dd><p>controls which fences to include, see <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**fence</span></code></dt><dd><p>the resulting fence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a single fence representing all the fences inside the resv object.
Returns either 0 for success or -ENOMEM.</p>
<p>Warning: This can’t be used like this when adding the fence back to the resv
object since that can lead to stack corruption when finalizing the
dma_fence_array.</p>
<p>Returns 0 on success and negative error values on failure.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_wait_timeout">
long <code class="sig-name descname">dma_resv_wait_timeout</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, enum <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage">dma_resv_usage</a><em> usage</em>, bool<em> intr</em>, unsigned long<em> timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_wait_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait on reservation’s objects fences</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">usage</span></code></dt><dd><p>controls which fences to include, see <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt><dd><p>if true, do interruptible wait</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies or zero to return immediately</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callers are not required to hold specific locks, but maybe hold
<a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> already
RETURNS
Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or
greater than zer on success.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_test_signaled">
bool <code class="sig-name descname">dma_resv_test_signaled</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, enum <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage">dma_resv_usage</a><em> usage</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_test_signaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a reservation object’s fences have been signaled.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">usage</span></code></dt><dd><p>controls which fences to include, see <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callers are not required to hold specific locks, but maybe hold
<a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> already.</p>
<p>RETURNS</p>
<p>True if all fences signaled, else false.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_describe">
void <code class="sig-name descname">dma_resv_describe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, struct seq_file<em> *seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump description of the resv object into seq_file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*seq</span></code></dt><dd><p>the seq_file to dump the description into</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dump a textual description of the fences inside an dma_resv object into the
seq_file.</p>
</div>
<dl class="type">
<dt id="c.dma_resv_usage">
enum <code class="sig-name descname">dma_resv_usage</code><a class="headerlink" href="#c.dma_resv_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>how the fences from a dma_resv obj are used</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DMA_RESV_USAGE_KERNEL</span></code></dt><dd><p>For in kernel memory management only.</p>
<p>This should only be used for things like copying or clearing memory
with a DMA hardware engine for the purpose of kernel memory
management.</p>
<p>Drivers <em>always</em> must wait for those fences before accessing the
resource protected by the dma_resv object. The only exception for
that is when the resource is known to be locked down in place by
pinning it previously.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DMA_RESV_USAGE_WRITE</span></code></dt><dd><p>Implicit write synchronization.</p>
<p>This should only be used for userspace command submissions which add
an implicit write dependency.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DMA_RESV_USAGE_READ</span></code></dt><dd><p>Implicit read synchronization.</p>
<p>This should only be used for userspace command submissions which add
an implicit read dependency.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DMA_RESV_USAGE_BOOKKEEP</span></code></dt><dd><p>No implicit sync.</p>
<p>This should be used by submissions which don’t want to participate in
any implicit synchronization.</p>
<p>The most common case are preemption fences, page table updates, TLB
flushes as well as explicit synced user submissions.</p>
<p>Explicit synced user user submissions can be promoted to
DMA_RESV_USAGE_READ or DMA_RESV_USAGE_WRITE as needed using
<a class="reference internal" href="#c.dma_buf_import_sync_file" title="dma_buf_import_sync_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_buf_import_sync_file()</span></code></a> when implicit synchronization should
become necessary after initial adding of the fence.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This enum describes the different use cases for a dma_resv object and
controls which fences are returned when queried.</p>
<p>An important fact is that there is the order KERNEL&lt;WRITE&lt;READ&lt;BOOKKEEP and
when the dma_resv object is asked for fences for one use case the fences
for the lower use case are returned as well.</p>
<p>For example when asking for WRITE fences then the KERNEL fences are returned
as well. Similar when asked for READ fences then both WRITE and KERNEL
fences are returned as well.</p>
<p>Already used fences can be promoted in the sense that a fence with
DMA_RESV_USAGE_BOOKKEEP could become DMA_RESV_USAGE_READ by adding it again
with this usage. But fences can never be degraded in the sense that a fence
with DMA_RESV_USAGE_WRITE could become DMA_RESV_USAGE_READ.</p>
<dl class="function">
<dt id="c.dma_resv_usage_rw">
enum <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage">dma_resv_usage</a> <code class="sig-name descname">dma_resv_usage_rw</code><span class="sig-paren">(</span>bool<em> write</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_usage_rw" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for implicit sync</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">write</span></code></dt><dd><p>true if we create a new implicit sync write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the implicit synchronization usage for write or read accesses,
see <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span></code></a> and <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.resv</span></code></a>.</p>
</div>
<dl class="type">
<dt id="c.dma_resv">
struct <code class="sig-name descname">dma_resv</code><a class="headerlink" href="#c.dma_resv" title="Permalink to this definition">¶</a></dt>
<dd><p>a reservation object manages fences for a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_resv {
    struct ww_mutex lock;
    struct dma_resv_list __rcu *fences;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Update side lock. Don’t use directly, instead use the wrapper
functions like <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> and <a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a>.</p>
<p>Drivers which use the reservation object to manage memory dynamically
also use this lock to protect buffer object state like placement,
allocation policies or throughout command submission.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fences</span></code></dt><dd><p>Array of fences which where added to the dma_resv object</p>
<p>A new fence is added by calling <a class="reference internal" href="#c.dma_resv_add_fence" title="dma_resv_add_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_add_fence()</span></code></a>. Since this
often needs to be done past the point of no return in command
submission it cannot fail, and therefore sufficient slots need to be
reserved by calling <a class="reference internal" href="#c.dma_resv_reserve_fences" title="dma_resv_reserve_fences"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_reserve_fences()</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is a container for dma_fence objects which needs to handle multiple use
cases.</p>
<p>One use is to synchronize cross-driver access to a <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a>, either for
dynamic buffer management or just to handle implicit synchronization between
different users of the buffer in userspace. See <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.resv</span></code></a> for a more
in-depth discussion.</p>
<p>The other major use is to manage access and locking within a driver in a
buffer based memory manager. struct ttm_buffer_object is the canonical
example here, since this is where reservation objects originated from. But
use in drivers is spreading and some drivers also manage <a class="reference internal" href="../gpu/drm-mm.html#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">drm_gem_object</span></code></a> with the same scheme.</p>
<dl class="type">
<dt id="c.dma_resv_iter">
struct <code class="sig-name descname">dma_resv_iter</code><a class="headerlink" href="#c.dma_resv_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>current position into the dma_resv fences</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_resv_iter {
    struct dma_resv *obj;
    enum dma_resv_usage usage;
    struct dma_fence *fence;
    enum dma_resv_usage fence_usage;
    unsigned int index;
    struct dma_resv_list *fences;
    unsigned int num_fences;
    bool is_restarted;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>The dma_resv object we iterate over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usage</span></code></dt><dd><p>Return fences with this usage or lower.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>the currently handled fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_usage</span></code></dt><dd><p>the usage of the current fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>index into the shared fences</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fences</span></code></dt><dd><p>the shared fences; private, <em>MUST</em> not dereference</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_fences</span></code></dt><dd><p>number of fences</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_restarted</span></code></dt><dd><p>true if this is the first returned fence</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Don’t touch this directly in the driver, use the accessor function instead.</p>
<p>IMPORTANT</p>
<p>When using the lockless iterators like <a class="reference internal" href="#c.dma_resv_iter_next_unlocked" title="dma_resv_iter_next_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_next_unlocked()</span></code></a> or
<a class="reference internal" href="#c.dma_resv_for_each_fence_unlocked" title="dma_resv_for_each_fence_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_for_each_fence_unlocked()</span></code></a> beware that the iterator can be restarted.
Code which accumulates statistics or similar needs to check for this with
<a class="reference internal" href="#c.dma_resv_iter_is_restarted" title="dma_resv_iter_is_restarted"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_is_restarted()</span></code></a>.</p>
<dl class="function">
<dt id="c.dma_resv_iter_begin">
void <code class="sig-name descname">dma_resv_iter_begin</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter">dma_resv_iter</a><em> *cursor</em>, struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, enum <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage">dma_resv_usage</a><em> usage</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a dma_resv_iter object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>The dma_resv_iter object to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>The dma_resv object which we want to iterate over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span> <span class="pre">usage</span></code></dt><dd><p>controls which fences to include, see <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_resv_usage</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dma_resv_iter_end">
void <code class="sig-name descname">dma_resv_iter_end</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter">dma_resv_iter</a><em> *cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_end" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup a dma_resv_iter object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>the dma_resv_iter object which should be cleaned up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure that the reference to the fence in the cursor is properly
dropped.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_iter_usage">
enum <a class="reference internal" href="#c.dma_resv_usage" title="dma_resv_usage">dma_resv_usage</a> <code class="sig-name descname">dma_resv_iter_usage</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter">dma_resv_iter</a><em> *cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the usage of the current fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>the cursor of the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the usage of the currently processed fence.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_iter_is_restarted">
bool <code class="sig-name descname">dma_resv_iter_is_restarted</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter">dma_resv_iter</a><em> *cursor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_iter_is_restarted" title="Permalink to this definition">¶</a></dt>
<dd><p>test if this is the first fence after a restart</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span> <span class="pre">*cursor</span></code></dt><dd><p>the cursor with the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if this is the first fence in an iteration after a restart.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_for_each_fence_unlocked">
<code class="sig-name descname">dma_resv_for_each_fence_unlocked</code><span class="sig-paren">(</span><em>cursor</em>, <em>fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_for_each_fence_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>unlocked fence iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cursor</span></code></dt><dd><p>a <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>the current fence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the fences in a <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> object without holding the
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.lock</span></code></a> and using RCU instead. The cursor needs to be initialized
with <a class="reference internal" href="#c.dma_resv_iter_begin" title="dma_resv_iter_begin"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_begin()</span></code></a> and cleaned up with <a class="reference internal" href="#c.dma_resv_iter_end" title="dma_resv_iter_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_end()</span></code></a>. Inside
the iterator a reference to the dma_fence is held and the RCU lock dropped.</p>
<p>Beware that the iterator can be restarted when the <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> for
<strong>cursor</strong> is modified. Code which accumulates statistics or similar needs to
check for this with <a class="reference internal" href="#c.dma_resv_iter_is_restarted" title="dma_resv_iter_is_restarted"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_iter_is_restarted()</span></code></a>. For this reason prefer the
lock iterator <a class="reference internal" href="#c.dma_resv_for_each_fence" title="dma_resv_for_each_fence"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_for_each_fence()</span></code></a> whenever possible.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_for_each_fence">
<code class="sig-name descname">dma_resv_for_each_fence</code><span class="sig-paren">(</span><em>cursor</em>, <em>obj</em>, <em>usage</em>, <em>fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_for_each_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>fence iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cursor</span></code></dt><dd><p>a <a class="reference internal" href="#c.dma_resv_iter" title="dma_resv_iter"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv_iter</span></code></a> pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj</span></code></dt><dd><p>a dma_resv object pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">usage</span></code></dt><dd><p>controls which fences to return</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>the current fence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the fences in a <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> object while holding the
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv.lock</span></code></a>. <strong>all_fences</strong> controls if the shared fences are returned as
well. The cursor initialisation is part of the iterator and the fence stays
valid as long as the lock is held and so no extra reference to the fence is
taken.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_lock">
int <code class="sig-name descname">dma_resv_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, struct ww_acquire_ctx<em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>lock the reservation object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the locking context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Locks the reservation object for exclusive access and modification. Note,
that the lock is only against other writers, readers will run concurrently
with a writer under RCU. The seqlock is used to notify readers if they
overlap with a writer.</p>
<p>As the reservation object may be locked by multiple parties in an
undefined order, a #ww_acquire_ctx is passed to unwind if a cycle
is detected. See ww_mutex_lock() and ww_acquire_init(). A reservation
object may be locked by itself by passing NULL as <strong>ctx</strong>.</p>
<p>When a die situation is indicated by returning -EDEADLK all locks held by
<strong>ctx</strong> must be unlocked and then <a class="reference internal" href="#c.dma_resv_lock_slow" title="dma_resv_lock_slow"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock_slow()</span></code></a> called on <strong>obj</strong>.</p>
<p>Unlocked by calling <a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a>.</p>
<p>See also <a class="reference internal" href="#c.dma_resv_lock_interruptible" title="dma_resv_lock_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock_interruptible()</span></code></a> for the interruptible variant.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_lock_interruptible">
int <code class="sig-name descname">dma_resv_lock_interruptible</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, struct ww_acquire_ctx<em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_lock_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>lock the reservation object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the locking context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Locks the reservation object interruptible for exclusive access and
modification. Note, that the lock is only against other writers, readers
will run concurrently with a writer under RCU. The seqlock is used to
notify readers if they overlap with a writer.</p>
<p>As the reservation object may be locked by multiple parties in an
undefined order, a #ww_acquire_ctx is passed to unwind if a cycle
is detected. See ww_mutex_lock() and ww_acquire_init(). A reservation
object may be locked by itself by passing NULL as <strong>ctx</strong>.</p>
<p>When a die situation is indicated by returning -EDEADLK all locks held by
<strong>ctx</strong> must be unlocked and then <a class="reference internal" href="#c.dma_resv_lock_slow_interruptible" title="dma_resv_lock_slow_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock_slow_interruptible()</span></code></a> called on
<strong>obj</strong>.</p>
<p>Unlocked by calling <a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_lock_slow">
void <code class="sig-name descname">dma_resv_lock_slow</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, struct ww_acquire_ctx<em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_lock_slow" title="Permalink to this definition">¶</a></dt>
<dd><p>slowpath lock the reservation object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the locking context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires the reservation object after a die case. This function
will sleep until the lock becomes available. See <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> as
well.</p>
<p>See also <a class="reference internal" href="#c.dma_resv_lock_slow_interruptible" title="dma_resv_lock_slow_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock_slow_interruptible()</span></code></a> for the interruptible variant.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_lock_slow_interruptible">
int <code class="sig-name descname">dma_resv_lock_slow_interruptible</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em>, struct ww_acquire_ctx<em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_lock_slow_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>slowpath lock the reservation object, interruptible</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the locking context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires the reservation object interruptible after a die case. This function
will sleep until the lock becomes available. See
<a class="reference internal" href="#c.dma_resv_lock_interruptible" title="dma_resv_lock_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock_interruptible()</span></code></a> as well.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_trylock">
bool <code class="sig-name descname">dma_resv_trylock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_trylock" title="Permalink to this definition">¶</a></dt>
<dd><p>trylock the reservation object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tries to lock the reservation object for exclusive access and modification.
Note, that the lock is only against other writers, readers will run
concurrently with a writer under RCU. The seqlock is used to notify readers
if they overlap with a writer.</p>
<p>Also note that since no context is provided, no deadlock protection is
possible, which is also not needed for a trylock.</p>
<p>Returns true if the lock was acquired, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_is_locked">
bool <code class="sig-name descname">dma_resv_is_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_is_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>is the reservation object locked</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the mutex is locked, false if unlocked.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_locking_ctx">
struct ww_acquire_ctx * <code class="sig-name descname">dma_resv_locking_ctx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_locking_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the context used to lock the object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the context used to lock a reservation object or NULL if no context
was used or the object is not locked at all.</p>
<p>WARNING: This interface is pretty horrible, but TTM needs it because it
doesn’t pass the struct ww_acquire_ctx around in some very long callchains.
Everyone else just uses it to check whether they’re holding a reservation or
not.</p>
</div>
<dl class="function">
<dt id="c.dma_resv_unlock">
void <code class="sig-name descname">dma_resv_unlock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_resv" title="dma_resv">dma_resv</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_resv_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock the reservation object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span> <span class="pre">*obj</span></code></dt><dd><p>the reservation object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the reservation object following exclusive access.</p>
</div>
</section>
<section id="dma-fences">
<h2>DMA Fences<a class="headerlink" href="#dma-fences" title="Permalink to this headline">¶</a></h2>
<p>DMA fences, represented by <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span></code></a>, are the kernel internal
synchronization primitive for DMA operations like GPU rendering, video
encoding/decoding, or displaying buffers on a screen.</p>
<p>A fence is initialized using <a class="reference internal" href="#c.dma_fence_init" title="dma_fence_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_init()</span></code></a> and completed using
<a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>. Fences are associated with a context, allocated through
<a class="reference internal" href="#c.dma_fence_context_alloc" title="dma_fence_context_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_context_alloc()</span></code></a>, and all fences on the same context are
fully ordered.</p>
<p>Since the purposes of fences is to facilitate cross-device and
cross-application synchronization, there’s multiple ways to use one:</p>
<ul class="simple">
<li><p>Individual fences can be exposed as a <a class="reference internal" href="#c.sync_file" title="sync_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">sync_file</span></code></a>, accessed as a file
descriptor from userspace, created by calling <a class="reference internal" href="#c.sync_file_create" title="sync_file_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">sync_file_create()</span></code></a>. This is
called explicit fencing, since userspace passes around explicit
synchronization points.</p></li>
<li><p>Some subsystems also have their own explicit fencing primitives, like
<a class="reference internal" href="../gpu/drm-mm.html#c.drm_syncobj" title="drm_syncobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_syncobj</span></code></a>. Compared to <a class="reference internal" href="#c.sync_file" title="sync_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">sync_file</span></code></a>, a <a class="reference internal" href="../gpu/drm-mm.html#c.drm_syncobj" title="drm_syncobj"><code class="xref c c-type docutils literal notranslate"><span class="pre">drm_syncobj</span></code></a> allows the underlying
fence to be updated.</p></li>
<li><p>Then there’s also implicit fencing, where the synchronization points are
implicitly passed around as part of shared <a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf</span></code></a> instances. Such
implicit fences are stored in <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> through the
<a class="reference internal" href="#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_buf.resv</span></code></a> pointer.</p></li>
</ul>
<section id="dma-fence-cross-driver-contract">
<h3>DMA Fence Cross-Driver Contract<a class="headerlink" href="#dma-fence-cross-driver-contract" title="Permalink to this headline">¶</a></h3>
<p>Since <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> provide a cross driver contract, all drivers must follow the
same rules:</p>
<ul class="simple">
<li><p>Fences must complete in a reasonable time. Fences which represent kernels
and shaders submitted by userspace, which could run forever, must be backed
up by timeout and gpu hang recovery code. Minimally that code must prevent
further command submission and force complete all in-flight fences, e.g.
when the driver or hardware do not support gpu reset, or if the gpu reset
failed for some reason. Ideally the driver supports gpu recovery which only
affects the offending userspace context, and no other userspace
submissions.</p></li>
<li><p>Drivers may have different ideas of what completion within a reasonable
time means. Some hang recovery code uses a fixed timeout, others a mix
between observing forward progress and increasingly strict timeouts.
Drivers should not try to second guess timeout handling of fences from
other drivers.</p></li>
<li><p>To ensure there’s no deadlocks of <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> against other locks
drivers should annotate all code required to reach <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>,
which completes the fences, with <a class="reference internal" href="#c.dma_fence_begin_signalling" title="dma_fence_begin_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_begin_signalling()</span></code></a> and
<a class="reference internal" href="#c.dma_fence_end_signalling" title="dma_fence_end_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_end_signalling()</span></code></a>.</p></li>
<li><p>Drivers are allowed to call <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> while holding <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a>.
This means any code required for fence completion cannot acquire a
<a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a> lock. Note that this also pulls in the entire established
locking hierarchy around <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> and <a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a>.</p></li>
<li><p>Drivers are allowed to call <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> from their <code class="xref c c-type docutils literal notranslate"><span class="pre">shrinker</span></code>
callbacks. This means any code required for fence completion cannot
allocate memory with GFP_KERNEL.</p></li>
<li><p>Drivers are allowed to call <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> from their <code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_notifier</span></code>
respectively <code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_interval_notifier</span></code> callbacks. This means any code required
for fence completeion cannot allocate memory with GFP_NOFS or GFP_NOIO.
Only GFP_ATOMIC is permissible, which might fail.</p></li>
</ul>
<p>Note that only GPU drivers have a reasonable excuse for both requiring
<code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_interval_notifier</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">shrinker</span></code> callbacks at the same time as having to
track asynchronous compute work using <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a>. No driver outside of
drivers/gpu should ever call <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> in such contexts.</p>
</section>
<section id="dma-fence-signalling-annotations">
<h3>DMA Fence Signalling Annotations<a class="headerlink" href="#dma-fence-signalling-annotations" title="Permalink to this headline">¶</a></h3>
<p>Proving correctness of all the kernel code around <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> through code
review and testing is tricky for a few reasons:</p>
<ul class="simple">
<li><p>It is a cross-driver contract, and therefore all drivers must follow the
same rules for lock nesting order, calling contexts for various functions
and anything else significant for in-kernel interfaces. But it is also
impossible to test all drivers in a single machine, hence brute-force N vs.
N testing of all combinations is impossible. Even just limiting to the
possible combinations is infeasible.</p></li>
<li><p>There is an enormous amount of driver code involved. For render drivers
there’s the tail of command submission, after fences are published,
scheduler code, interrupt and workers to process job completion,
and timeout, gpu reset and gpu hang recovery code. Plus for integration
with core mm with have <code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_notifier</span></code>, respectively <code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_interval_notifier</span></code>,
and <code class="xref c c-type docutils literal notranslate"><span class="pre">shrinker</span></code>. For modesetting drivers there’s the commit tail functions
between when fences for an atomic modeset are published, and when the
corresponding vblank completes, including any interrupt processing and
related workers. Auditing all that code, across all drivers, is not
feasible.</p></li>
<li><p>Due to how many other subsystems are involved and the locking hierarchies
this pulls in there is extremely thin wiggle-room for driver-specific
differences. <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> interacts with almost all of the core memory
handling through page fault handlers via <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_resv</span></code></a>, <a class="reference internal" href="#c.dma_resv_lock" title="dma_resv_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_lock()</span></code></a> and
<a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a>. On the other side it also interacts through all
allocation sites through <code class="xref c c-type docutils literal notranslate"><span class="pre">mmu_notifier</span></code> and <code class="xref c c-type docutils literal notranslate"><span class="pre">shrinker</span></code>.</p></li>
</ul>
<p>Furthermore lockdep does not handle cross-release dependencies, which means
any deadlocks between <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> and <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> can’t be caught
at runtime with some quick testing. The simplest example is one thread
waiting on a <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> while holding a lock:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lock(A);
dma_fence_wait(B);
unlock(A);
</pre></div>
</div>
<p>while the other thread is stuck trying to acquire the same lock, which
prevents it from signalling the fence the previous thread is stuck waiting
on:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lock(A);
unlock(A);
dma_fence_signal(B);
</pre></div>
</div>
<p>By manually annotating all code relevant to signalling a <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> we can
teach lockdep about these dependencies, which also helps with the validation
headache since now lockdep can check all the rules for us:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cookie = dma_fence_begin_signalling();
lock(A);
unlock(A);
dma_fence_signal(B);
dma_fence_end_signalling(cookie);
</pre></div>
</div>
<p>For using <a class="reference internal" href="#c.dma_fence_begin_signalling" title="dma_fence_begin_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_begin_signalling()</span></code></a> and <a class="reference internal" href="#c.dma_fence_end_signalling" title="dma_fence_end_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_end_signalling()</span></code></a> to
annotate critical sections the following rules need to be observed:</p>
<ul class="simple">
<li><p>All code necessary to complete a <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> must be annotated, from the
point where a fence is accessible to other threads, to the point where
<a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> is called. Un-annotated code can contain deadlock issues,
and due to the very strict rules and many corner cases it is infeasible to
catch these just with review or normal stress testing.</p></li>
<li><p><a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a> deserves a special note, since the readers are only
protected by rcu. This means the signalling critical section starts as soon
as the new fences are installed, even before <a class="reference internal" href="#c.dma_resv_unlock" title="dma_resv_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_resv_unlock()</span></code></a> is called.</p></li>
<li><p>The only exception are fast paths and opportunistic signalling code, which
calls <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> purely as an optimization, but is not required to
guarantee completion of a <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a>. The usual example is a wait IOCTL
which calls <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>, while the mandatory completion path goes
through a hardware interrupt and possible job completion worker.</p></li>
<li><p>To aid composability of code, the annotations can be freely nested, as long
as the overall locking hierarchy is consistent. The annotations also work
both in interrupt and process context. Due to implementation details this
requires that callers pass an opaque cookie from
<a class="reference internal" href="#c.dma_fence_begin_signalling" title="dma_fence_begin_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_begin_signalling()</span></code></a> to <a class="reference internal" href="#c.dma_fence_end_signalling" title="dma_fence_end_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_end_signalling()</span></code></a>.</p></li>
<li><p>Validation against the cross driver contract is implemented by priming
lockdep with the relevant hierarchy at boot-up. This means even just
testing with a single device is enough to validate a driver, at least as
far as deadlocks with <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> against <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> are
concerned.</p></li>
</ul>
</section>
<section id="dma-fences-functions-reference">
<h3>DMA Fences Functions Reference<a class="headerlink" href="#dma-fences-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.dma_fence_get_stub">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_fence_get_stub</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_stub" title="Permalink to this definition">¶</a></dt>
<dd><p>return a signaled fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return a stub fence which is already signaled. The fence’s
timestamp corresponds to the first time after boot this
function is called.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_allocate_private_stub">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_fence_allocate_private_stub</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_allocate_private_stub" title="Permalink to this definition">¶</a></dt>
<dd><p>return a private, signaled fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return a newly allocated and signaled stub fence.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_context_alloc">
u64 <code class="sig-name descname">dma_fence_context_alloc</code><span class="sig-paren">(</span>unsigned<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_context_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an array of fence contexts</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">num</span></code></dt><dd><p>amount of contexts to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will return the first index of the number of fence contexts
allocated.  The fence context is used for setting <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.context</span></code></a> to a
unique number by passing the context to <a class="reference internal" href="#c.dma_fence_init" title="dma_fence_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_init()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_begin_signalling">
bool <code class="sig-name descname">dma_fence_begin_signalling</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_begin_signalling" title="Permalink to this definition">¶</a></dt>
<dd><p>begin a critical DMA fence signalling section</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should use this to annotate the beginning of any code section
required to eventually complete <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a> by calling <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>.</p>
<p>The end of these critical sections are annotated with
<a class="reference internal" href="#c.dma_fence_end_signalling" title="dma_fence_end_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_end_signalling()</span></code></a>.</p>
<p>Opaque cookie needed by the implementation, which needs to be passed to
<a class="reference internal" href="#c.dma_fence_end_signalling" title="dma_fence_end_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_end_signalling()</span></code></a>.</p>
<p><strong>Return</strong></p>
</div>
<dl class="function">
<dt id="c.dma_fence_end_signalling">
void <code class="sig-name descname">dma_fence_end_signalling</code><span class="sig-paren">(</span>bool<em> cookie</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_end_signalling" title="Permalink to this definition">¶</a></dt>
<dd><p>end a critical DMA fence signalling section</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">cookie</span></code></dt><dd><p>opaque cookie from <a class="reference internal" href="#c.dma_fence_begin_signalling" title="dma_fence_begin_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_begin_signalling()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Closes a critical section annotation opened by <a class="reference internal" href="#c.dma_fence_begin_signalling" title="dma_fence_begin_signalling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_begin_signalling()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_signal_timestamp_locked">
int <code class="sig-name descname">dma_fence_signal_timestamp_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, ktime_t<em> timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_signal_timestamp_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>signal completion of a fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">timestamp</span></code></dt><dd><p>fence signal timestamp in kernel’s CLOCK_MONOTONIC time domain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal completion for software callbacks on a fence, this will unblock
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> calls and run all the callbacks added with
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>. Can be called multiple times, but since a fence
can only go from the unsignaled to the signaled state and not back, it will
only be effective the first time. Set the timestamp provided as the fence
signal timestamp.</p>
<p>Unlike <a class="reference internal" href="#c.dma_fence_signal_timestamp" title="dma_fence_signal_timestamp"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal_timestamp()</span></code></a>, this function must be called with
<a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.lock</span></code></a> held.</p>
<p>Returns 0 on success and a negative error value when <strong>fence</strong> has been
signalled already.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_signal_timestamp">
int <code class="sig-name descname">dma_fence_signal_timestamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, ktime_t<em> timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_signal_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>signal completion of a fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">timestamp</span></code></dt><dd><p>fence signal timestamp in kernel’s CLOCK_MONOTONIC time domain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal completion for software callbacks on a fence, this will unblock
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> calls and run all the callbacks added with
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>. Can be called multiple times, but since a fence
can only go from the unsignaled to the signaled state and not back, it will
only be effective the first time. Set the timestamp provided as the fence
signal timestamp.</p>
<p>Returns 0 on success and a negative error value when <strong>fence</strong> has been
signalled already.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_signal_locked">
int <code class="sig-name descname">dma_fence_signal_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_signal_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>signal completion of a fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to signal</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal completion for software callbacks on a fence, this will unblock
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> calls and run all the callbacks added with
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>. Can be called multiple times, but since a fence
can only go from the unsignaled to the signaled state and not back, it will
only be effective the first time.</p>
<p>Unlike <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>, this function must be called with <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.lock</span></code></a>
held.</p>
<p>Returns 0 on success and a negative error value when <strong>fence</strong> has been
signalled already.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_signal">
int <code class="sig-name descname">dma_fence_signal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>signal completion of a fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to signal</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal completion for software callbacks on a fence, this will unblock
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> calls and run all the callbacks added with
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>. Can be called multiple times, but since a fence
can only go from the unsignaled to the signaled state and not back, it will
only be effective the first time.</p>
<p>Returns 0 on success and a negative error value when <strong>fence</strong> has been
signalled already.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_wait_timeout">
signed long <code class="sig-name descname">dma_fence_wait_timeout</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, bool<em> intr</em>, signed long<em> timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_wait_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until the fence gets signaled or until timeout elapses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt><dd><p>if true, do an interruptible wait</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or the
remaining timeout in jiffies on success. Other error values may be
returned on custom implementations.</p>
<p>Performs a synchronous wait on this fence. It is assumed the caller
directly or indirectly (buf-mgr between reservation and committing)
holds a reference to the fence, otherwise the fence might be
freed before return, resulting in undefined behavior.</p>
<p>See also <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> and <a class="reference internal" href="#c.dma_fence_wait_any_timeout" title="dma_fence_wait_any_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait_any_timeout()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_release">
void <code class="sig-name descname">dma_fence_release</code><span class="sig-paren">(</span>struct kref<em> *kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_release" title="Permalink to this definition">¶</a></dt>
<dd><p>default relese function for fences</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*kref</span></code></dt><dd><p><a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.recfount</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default release functions for <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a>. Drivers shouldn’t call
this directly, but instead call <a class="reference internal" href="#c.dma_fence_put" title="dma_fence_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_put()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_free">
void <code class="sig-name descname">dma_fence_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_free" title="Permalink to this definition">¶</a></dt>
<dd><p>default release function for <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default implementation for <a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence_ops.release</span></code></a>. It calls
<a class="reference internal" href="../core-api/kernel-api.html#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> on <strong>fence</strong>.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_enable_sw_signaling">
void <code class="sig-name descname">dma_fence_enable_sw_signaling</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_enable_sw_signaling" title="Permalink to this definition">¶</a></dt>
<dd><p>enable signaling on fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will request for sw signaling to be enabled, to make the fence
complete as soon as possible. This calls <a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence_ops.enable_signaling</span></code></a>
internally.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_add_callback">
int <code class="sig-name descname">dma_fence_add_callback</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, struct <a class="reference internal" href="#c.dma_fence_cb" title="dma_fence_cb">dma_fence_cb</a><em> *cb</em>, dma_fence_func_t<em> func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_add_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>add a callback to be called when the fence is signaled</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_cb</span> <span class="pre">*cb</span></code></dt><dd><p>the callback to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_fence_func_t</span> <span class="pre">func</span></code></dt><dd><p>the function to call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a software callback to the fence. The caller should keep a reference to
the fence.</p>
<p><strong>cb</strong> will be initialized by <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>, no initialization
by the caller is required. Any number of callbacks can be registered
to a fence, but a callback can only be registered to one fence at a time.</p>
<p>If fence is already signaled, this function will return -ENOENT (and
<em>not</em> call the callback).</p>
<p>Note that the callback can be called from an atomic context or irq context.</p>
<p>Returns 0 in case of success, -ENOENT if the fence is already signaled
and -EINVAL in case of error.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_get_status">
int <code class="sig-name descname">dma_fence_get_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_status" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the status upon completion</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the dma_fence to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This wraps <a class="reference internal" href="#c.dma_fence_get_status_locked" title="dma_fence_get_status_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_get_status_locked()</span></code></a> to return the error status
condition on a signaled fence. See <a class="reference internal" href="#c.dma_fence_get_status_locked" title="dma_fence_get_status_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_get_status_locked()</span></code></a> for more
details.</p>
<p>Returns 0 if the fence has not yet been signaled, 1 if the fence has
been signaled without an error condition, or a negative error code
if the fence has been completed in err.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_remove_callback">
bool <code class="sig-name descname">dma_fence_remove_callback</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, struct <a class="reference internal" href="#c.dma_fence_cb" title="dma_fence_cb">dma_fence_cb</a><em> *cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_remove_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a callback from the signaling list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_cb</span> <span class="pre">*cb</span></code></dt><dd><p>the callback to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a previously queued callback from the fence. This function returns
true if the callback is successfully removed, or false if the fence has
already been signaled.</p>
<p><em>WARNING</em>:
Cancelling a callback should only be done if you really know what you’re
doing, since deadlocks and race conditions could occur all too easily. For
this reason, it should only ever be done on hardware lockup recovery,
with a reference held to the fence.</p>
<p>Behaviour is undefined if <strong>cb</strong> has not been added to <strong>fence</strong> using
<a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a> beforehand.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_default_wait">
signed long <code class="sig-name descname">dma_fence_default_wait</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, bool<em> intr</em>, signed long<em> timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_default_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>default sleep until the fence gets signaled or until timeout elapses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt><dd><p>if true, do an interruptible wait</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or the
remaining timeout in jiffies on success. If timeout is zero the value one is
returned if the fence is already signaled for consistency with other
functions taking a jiffies timeout.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_wait_any_timeout">
signed long <code class="sig-name descname">dma_fence_wait_any_timeout</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> **fences</em>, uint32_t<em> count</em>, bool<em> intr</em>, signed long<em> timeout</em>, uint32_t<em> *idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_wait_any_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until any fence gets signaled or until timeout elapses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**fences</span></code></dt><dd><p>array of fences to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">count</span></code></dt><dd><p>number of fences to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt><dd><p>if true, do an interruptible wait</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">*idx</span></code></dt><dd><p>used to store the first signaled fence index, meaningful only on
positive return</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -EINVAL on custom fence wait implementation, -ERESTARTSYS if
interrupted, 0 if the wait timed out, or the remaining timeout in jiffies
on success.</p>
<p>Synchronous waits for the first fence in the array to be signaled. The
caller needs to hold a reference to all fences in the array, otherwise a
fence might be freed before return, resulting in undefined behavior.</p>
<p>See also <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> and <a class="reference internal" href="#c.dma_fence_wait_timeout" title="dma_fence_wait_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait_timeout()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_describe">
void <code class="sig-name descname">dma_fence_describe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, struct seq_file<em> *seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump fence describtion into seq_file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the 6fence to describe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*seq</span></code></dt><dd><p>the seq_file to put the textual description into</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dump a textual description of the fence and it’s state into the seq_file.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_init">
void <code class="sig-name descname">dma_fence_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, const struct <a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops">dma_fence_ops</a><em> *ops</em>, spinlock_t<em> *lock</em>, u64<em> context</em>, u64<em> seqno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a custom fence.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_fence_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the dma_fence_ops for operations on this fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>the irqsafe spinlock to use for locking this fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">context</span></code></dt><dd><p>the execution context this fence is run on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">seqno</span></code></dt><dd><p>a linear increasing sequence number for this context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes an allocated fence, the caller doesn’t have to keep its
refcount after committing with this fence, but it will need to hold a
refcount again if <a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence_ops.enable_signaling</span></code></a> gets called.</p>
<p>context and seqno are used for easy comparison between fences, allowing
to check which fence is later by simply using <a class="reference internal" href="#c.dma_fence_later" title="dma_fence_later"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_later()</span></code></a>.</p>
</div>
<dl class="type">
<dt id="c.dma_fence">
struct <code class="sig-name descname">dma_fence</code><a class="headerlink" href="#c.dma_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>software synchronization primitive</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence {
    spinlock_t *lock;
    const struct dma_fence_ops *ops;
    union {
        struct list_head cb_list;
        ktime_t timestamp;
        struct rcu_head rcu;
    };
    u64 context;
    u64 seqno;
    unsigned long flags;
    struct kref refcount;
    int error;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>spin_lock_irqsave used for locking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>dma_fence_ops associated with this fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb_list</span></code></dt><dd><p>list of all callbacks to call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timestamp</span></code></dt><dd><p>Timestamp when the fence was signaled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt><dd><p>used for releasing fence with kfree_rcu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">context</span></code></dt><dd><p>execution context this fence belongs to, returned by
<a class="reference internal" href="#c.dma_fence_context_alloc" title="dma_fence_context_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_context_alloc()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seqno</span></code></dt><dd><p>the sequence number of this fence inside the execution context,
can be compared to decide which fence would be signaled later.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>A mask of DMA_FENCE_FLAG_* defined below</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt><dd><p>refcount for this fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">error</span></code></dt><dd><p>Optional, only valid if &lt; 0, must be set before calling
dma_fence_signal, indicates that the fence has completed with an error.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>the flags member must be manipulated and read using the appropriate
atomic ops (bit_*), so taking the spinlock will not be needed most
of the time.</p>
<p>DMA_FENCE_FLAG_SIGNALED_BIT - fence is already signaled
DMA_FENCE_FLAG_TIMESTAMP_BIT - timestamp recorded for fence signaling
DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT - enable_signaling might have been called
DMA_FENCE_FLAG_USER_BITS - start of the unused bits, can be used by the
implementer of the fence for its own purposes. Can be used in different
ways by different fence implementers, so do not rely on this.</p>
<p>Since atomic bitops are used, this is not guaranteed to be the case.
Particularly, if the bit was set, but dma_fence_signal was called right
before this bit was set, it would have been able to set the
DMA_FENCE_FLAG_SIGNALED_BIT, before enable_signaling was called.
Adding a check for DMA_FENCE_FLAG_SIGNALED_BIT after setting
DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT closes this race, and makes sure that
after dma_fence_signal was called, any enable_signaling call will have either
been completed, or never called at all.</p>
<dl class="type">
<dt id="c.dma_fence_cb">
struct <code class="sig-name descname">dma_fence_cb</code><a class="headerlink" href="#c.dma_fence_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>callback for <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence_cb {
    struct list_head node;
    dma_fence_func_t func;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>used by <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a> to append this struct to fence::cb_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">func</span></code></dt><dd><p>dma_fence_func_t to call</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct will be initialized by <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>, additional
data can be passed along by embedding dma_fence_cb in another struct.</p>
<dl class="type">
<dt id="c.dma_fence_ops">
struct <code class="sig-name descname">dma_fence_ops</code><a class="headerlink" href="#c.dma_fence_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>operations implemented for fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence_ops {
    bool use_64bit_seqno;
    const char * (*get_driver_name)(struct dma_fence *fence);
    const char * (*get_timeline_name)(struct dma_fence *fence);
    bool (*enable_signaling)(struct dma_fence *fence);
    bool (*signaled)(struct dma_fence *fence);
    signed long (*wait)(struct dma_fence *fence, bool intr, signed long timeout);
    void (*release)(struct dma_fence *fence);
    void (*fence_value_str)(struct dma_fence *fence, char *str, int size);
    void (*timeline_value_str)(struct dma_fence *fence, char *str, int size);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">use_64bit_seqno</span></code></dt><dd><p>True if this dma_fence implementation uses 64bit seqno, false
otherwise.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_driver_name</span></code></dt><dd><p>Returns the driver name. This is a callback to allow drivers to
compute the name at runtime, without having it to store permanently
for each fence, or build a cache of some sort.</p>
<p>This callback is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_timeline_name</span></code></dt><dd><p>Return the name of the context this fence belongs to. This is a
callback to allow drivers to compute the name at runtime, without
having it to store permanently for each fence, or build a cache of
some sort.</p>
<p>This callback is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_signaling</span></code></dt><dd><p>Enable software signaling of fence.</p>
<p>For fence implementations that have the capability for hw-&gt;hw
signaling, they can implement this op to enable the necessary
interrupts, or insert commands into cmdstream, etc, to avoid these
costly operations for the common case where only hw-&gt;hw
synchronization is required.  This is called in the first
<a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> or <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a> path to let the fence
implementation know that there is another driver waiting on the
signal (ie. hw-&gt;sw case).</p>
<p>This function can be called from atomic context, but not
from irq context, so normal spinlocks can be used.</p>
<p>A return value of false indicates the fence already passed,
or some failure occurred that made it impossible to enable
signaling. True indicates successful enabling.</p>
<p><a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.error</span></code></a> may be set in enable_signaling, but only when false
is returned.</p>
<p>Since many implementations can call <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> even when before
<strong>enable_signaling</strong> has been called there’s a race window, where the
<a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a> might result in the final fence reference being
released and its memory freed. To avoid this, implementations of this
callback should grab their own reference using <a class="reference internal" href="#c.dma_fence_get" title="dma_fence_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_get()</span></code></a>, to be
released when the fence is signalled (through e.g. the interrupt
handler).</p>
<p>This callback is optional. If this callback is not present, then the
driver must always have signaling enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signaled</span></code></dt><dd><p>Peek whether the fence is signaled, as a fastpath optimization for
e.g. <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> or <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>. Note that this
callback does not need to make any guarantees beyond that a fence
once indicates as signalled must always return true from this
callback. This callback may return false even if the fence has
completed already, in this case information hasn’t propogated throug
the system yet. See also <a class="reference internal" href="#c.dma_fence_is_signaled" title="dma_fence_is_signaled"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_is_signaled()</span></code></a>.</p>
<p>May set <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.error</span></code></a> if returning true.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait</span></code></dt><dd><p>Custom wait implementation, defaults to <a class="reference internal" href="#c.dma_fence_default_wait" title="dma_fence_default_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_default_wait()</span></code></a> if
not set.</p>
<p>Deprecated and should not be used by new implementations. Only used
by existing implementations which need special handling for their
hardware reset procedure.</p>
<p>Must return -ERESTARTSYS if the wait is intr = true and the wait was
interrupted, and remaining jiffies if fence has signaled, or 0 if wait
timed out. Can also return other error values on custom implementations,
which should be treated as if the fence is signaled. For example a hardware
lockup could be reported like that.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>Called on destruction of fence to release additional resources.
Can be called from irq context.  This callback is optional. If it is
NULL, then <a class="reference internal" href="#c.dma_fence_free" title="dma_fence_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_free()</span></code></a> is instead called as the default
implementation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence_value_str</span></code></dt><dd><p>Callback to fill in free-form debug info specific to this fence, like
the sequence number.</p>
<p>This callback is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeline_value_str</span></code></dt><dd><p>Fills in the current value of the timeline as a string, like the
sequence number. Note that the specific fence passed to this function
should not matter, drivers should only use it to look up the
corresponding timeline structures.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dma_fence_put">
void <code class="sig-name descname">dma_fence_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_put" title="Permalink to this definition">¶</a></dt>
<dd><p>decreases refcount of the fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to reduce refcount of</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dma_fence_get">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_fence_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get" title="Permalink to this definition">¶</a></dt>
<dd><p>increases refcount of the fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to increase refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the same fence, with refcount increased by 1.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_get_rcu">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_fence_get_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get a fence from a dma_resv_list with rcu read lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to increase refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns NULL if no refcount could be obtained, or the fence.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_get_rcu_safe">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_fence_get_rcu_safe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> __rcu<em> **fencep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_rcu_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a reference to an RCU tracked fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">__rcu</span> <span class="pre">**fencep</span></code></dt><dd><p>pointer to fence to increase refcount of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns NULL if no refcount could be obtained, or the fence.
This function handles acquiring a reference to a fence that may be
reallocated within the RCU grace period (such as with SLAB_TYPESAFE_BY_RCU),
so long as the caller is using RCU on the pointer to the fence.</p>
<p>An alternative mechanism is to employ a seqlock to protect a bunch of
fences, such as used by <a class="reference internal" href="#c.dma_resv" title="dma_resv"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_resv</span></code></a>. When using a seqlock,
the seqlock must be taken before and checked after a reference to the
fence is acquired (as shown here).</p>
<p>The caller is required to hold the RCU read lock.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_is_signaled_locked">
bool <code class="sig-name descname">dma_fence_is_signaled_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_signaled_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an indication if the fence is signaled yet.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the fence was already signaled, false if not. Since this
function doesn’t enable signaling, it is not guaranteed to ever return
true if <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>, <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> or
<a class="reference internal" href="#c.dma_fence_enable_sw_signaling" title="dma_fence_enable_sw_signaling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_enable_sw_signaling()</span></code></a> haven’t been called before.</p>
<p>This function requires <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">dma_fence.lock</span></code></a> to be held.</p>
<p>See also <a class="reference internal" href="#c.dma_fence_is_signaled" title="dma_fence_is_signaled"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_is_signaled()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_is_signaled">
bool <code class="sig-name descname">dma_fence_is_signaled</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_signaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an indication if the fence is signaled yet.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the fence was already signaled, false if not. Since this
function doesn’t enable signaling, it is not guaranteed to ever return
true if <a class="reference internal" href="#c.dma_fence_add_callback" title="dma_fence_add_callback"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_add_callback()</span></code></a>, <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a> or
<a class="reference internal" href="#c.dma_fence_enable_sw_signaling" title="dma_fence_enable_sw_signaling"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_enable_sw_signaling()</span></code></a> haven’t been called before.</p>
<p>It’s recommended for seqno fences to call dma_fence_signal when the
operation is complete, it makes it possible to prevent issues from
wraparound between time of issue and time of use by checking the return
value of this function before calling hardware-specific wait instructions.</p>
<p>See also <a class="reference internal" href="#c.dma_fence_is_signaled_locked" title="dma_fence_is_signaled_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_is_signaled_locked()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.__dma_fence_is_later">
bool <code class="sig-name descname">__dma_fence_is_later</code><span class="sig-paren">(</span>u64<em> f1</em>, u64<em> f2</em>, const struct <a class="reference internal" href="#c.dma_fence_ops" title="dma_fence_ops">dma_fence_ops</a><em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dma_fence_is_later" title="Permalink to this definition">¶</a></dt>
<dd><p>return if f1 is chronologically later than f2</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">f1</span></code></dt><dd><p>the first fence’s seqno</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">f2</span></code></dt><dd><p>the second fence’s seqno from the same context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dma_fence_ops</span> <span class="pre">*ops</span></code></dt><dd><p>dma_fence_ops associated with the seqno</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if f1 is chronologically later than f2. Both fences must be
from the same context, since a seqno is not common across contexts.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_is_later">
bool <code class="sig-name descname">dma_fence_is_later</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *f1</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *f2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_later" title="Permalink to this definition">¶</a></dt>
<dd><p>return if f1 is chronologically later than f2</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*f1</span></code></dt><dd><p>the first fence from the same context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*f2</span></code></dt><dd><p>the second fence from the same context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if f1 is chronologically later than f2. Both fences must be
from the same context, since a seqno is not re-used across contexts.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_later">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_fence_later</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *f1</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *f2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_later" title="Permalink to this definition">¶</a></dt>
<dd><p>return the chronologically later fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*f1</span></code></dt><dd><p>the first fence from the same context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*f2</span></code></dt><dd><p>the second fence from the same context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if both fences are signaled, otherwise the fence that would be
signaled last. Both fences must be from the same context, since a seqno is
not re-used across contexts.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_get_status_locked">
int <code class="sig-name descname">dma_fence_get_status_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_get_status_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the status upon completion</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the dma_fence to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can supply an optional error status condition before they signal
the fence (to indicate whether the fence was completed due to an error
rather than success). The value of the status condition is only valid
if the fence has been signaled, <a class="reference internal" href="#c.dma_fence_get_status_locked" title="dma_fence_get_status_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_get_status_locked()</span></code></a> first checks
the signal state before reporting the error status.</p>
<p>Returns 0 if the fence has not yet been signaled, 1 if the fence has
been signaled without an error condition, or a negative error code
if the fence has been completed in err.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_set_error">
void <code class="sig-name descname">dma_fence_set_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, int<em> error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_set_error" title="Permalink to this definition">¶</a></dt>
<dd><p>flag an error condition on the fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the dma_fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">error</span></code></dt><dd><p>the error to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can supply an optional error status condition before they signal
the fence, to indicate that the fence was completed due to an error
rather than success. This must be set before signaling (so that the value
is visible before any waiters on the signal callback are woken). This
helper exists to help catching erroneous setting of #dma_fence.error.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_wait">
signed long <code class="sig-name descname">dma_fence_wait</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, bool<em> intr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until the fence gets signaled</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">intr</span></code></dt><dd><p>if true, do an interruptible wait</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will return -ERESTARTSYS if interrupted by a signal,
or 0 if the fence was signaled. Other error values may be
returned on custom implementations.</p>
<p>Performs a synchronous wait on this fence. It is assumed the caller
directly or indirectly holds a reference to the fence, otherwise the
fence might be freed before return, resulting in undefined behavior.</p>
<p>See also <a class="reference internal" href="#c.dma_fence_wait_timeout" title="dma_fence_wait_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait_timeout()</span></code></a> and <a class="reference internal" href="#c.dma_fence_wait_any_timeout" title="dma_fence_wait_any_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait_any_timeout()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_is_array">
bool <code class="sig-name descname">dma_fence_is_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_array" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a fence is from the array subclass</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if it is a dma_fence_array and false otherwise.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_is_chain">
bool <code class="sig-name descname">dma_fence_is_chain</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a fence is from the chain subclass</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if it is a dma_fence_chain and false otherwise.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_is_container">
bool <code class="sig-name descname">dma_fence_is_container</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_is_container" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a fence is a container for other fences</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if this fence is a container for other fences, false otherwise.
This is important since we can’t build up large fence structure or otherwise
we run into recursion during operation on those fences.</p>
</div>
</section>
<section id="dma-fence-array">
<h3>DMA Fence Array<a class="headerlink" href="#dma-fence-array" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.dma_fence_array_create">
struct <a class="reference internal" href="#c.dma_fence_array" title="dma_fence_array">dma_fence_array</a> * <code class="sig-name descname">dma_fence_array_create</code><span class="sig-paren">(</span>int<em> num_fences</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> **fences</em>, u64<em> context</em>, unsigned<em> seqno</em>, bool<em> signal_on_any</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_array_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a custom fence array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_fences</span></code></dt><dd><p>[in]    number of fences to add in the array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**fences</span></code></dt><dd><p>[in]    array containing the fences</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">context</span></code></dt><dd><p>[in]    fence context to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">seqno</span></code></dt><dd><p>[in]    sequence number to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">signal_on_any</span></code></dt><dd><p>[in]    signal on any fence in the array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a dma_fence_array object and initialize the base fence with
<a class="reference internal" href="#c.dma_fence_init" title="dma_fence_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_init()</span></code></a>.
In case of error it returns NULL.</p>
<p>The caller should allocate the fences array with num_fences size
and fill it with the fences it wants to add to the object. Ownership of this
array is taken and <a class="reference internal" href="#c.dma_fence_put" title="dma_fence_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_put()</span></code></a> is used on each fence on release.</p>
<p>If <strong>signal_on_any</strong> is true the fence array signals if any fence in the array
signals, otherwise it signals when all fences in the array signal.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_match_context">
bool <code class="sig-name descname">dma_fence_match_context</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, u64<em> context</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_match_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if all fences are from the given context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>[in]    fence or fence array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">context</span></code></dt><dd><p>[in]    fence context to check all fences against</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks the provided fence or, for a fence array, all fences in the array
against the given context. Returns false if any fence is from a different
context.</p>
</div>
<dl class="type">
<dt id="c.dma_fence_array_cb">
struct <code class="sig-name descname">dma_fence_array_cb</code><a class="headerlink" href="#c.dma_fence_array_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>callback helper for fence array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence_array_cb {
    struct dma_fence_cb cb;
    struct dma_fence_array *array;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt><dd><p>fence callback structure for signaling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">array</span></code></dt><dd><p>reference to the parent fence array object</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dma_fence_array">
struct <code class="sig-name descname">dma_fence_array</code><a class="headerlink" href="#c.dma_fence_array" title="Permalink to this definition">¶</a></dt>
<dd><p>fence to represent an array of fences</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence_array {
    struct dma_fence base;
    spinlock_t lock;
    unsigned num_fences;
    atomic_t num_pending;
    struct dma_fence **fences;
    struct irq_work work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>fence base class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>spinlock for fence handling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_fences</span></code></dt><dd><p>number of fences in the array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_pending</span></code></dt><dd><p>fences in the array still pending</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fences</span></code></dt><dd><p>array of the fences</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>internal irq_work function</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.to_dma_fence_array">
struct <a class="reference internal" href="#c.dma_fence_array" title="dma_fence_array">dma_fence_array</a> * <code class="sig-name descname">to_dma_fence_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.to_dma_fence_array" title="Permalink to this definition">¶</a></dt>
<dd><p>cast a fence to a dma_fence_array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to cast to a dma_fence_array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the fence is not a dma_fence_array,
or the dma_fence_array otherwise.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_array_for_each">
<code class="sig-name descname">dma_fence_array_for_each</code><span class="sig-paren">(</span><em>fence</em>, <em>index</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_array_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all fences in array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>current fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>index into the array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>potential dma_fence_array object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test if <strong>array</strong> is a dma_fence_array object and if yes iterate over all fences
in the array. If not just iterate over the fence in <strong>array</strong> itself.</p>
<p>For a deep dive iterator see <a class="reference internal" href="#c.dma_fence_unwrap_for_each" title="dma_fence_unwrap_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_unwrap_for_each()</span></code></a>.</p>
</div>
</section>
<section id="dma-fence-chain">
<h3>DMA Fence Chain<a class="headerlink" href="#dma-fence-chain" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.dma_fence_chain_walk">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_fence_chain_walk</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_walk" title="Permalink to this definition">¶</a></dt>
<dd><p>chain walking function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>current chain node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the chain to the next node. Returns the next fence or NULL if we are at
the end of the chain. Garbage collects chain nodes which are already
signaled.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_chain_find_seqno">
int <code class="sig-name descname">dma_fence_chain_find_seqno</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> **pfence</em>, uint64_t<em> seqno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_find_seqno" title="Permalink to this definition">¶</a></dt>
<dd><p>find fence chain node by seqno</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**pfence</span></code></dt><dd><p>pointer to the chain node where to start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">seqno</span></code></dt><dd><p>the sequence number to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Advance the fence pointer to the chain node which will signal this sequence
number. If no sequence number is provided then this is a no-op.</p>
<p>Returns EINVAL if the fence is not a chain node or the sequence number has
not yet advanced far enough.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_chain_init">
void <code class="sig-name descname">dma_fence_chain_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain">dma_fence_chain</a><em> *chain</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *prev</em>, struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em>, uint64_t<em> seqno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a fence chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_chain</span> <span class="pre">*chain</span></code></dt><dd><p>the chain node to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*prev</span></code></dt><dd><p>the previous fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the current fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">seqno</span></code></dt><dd><p>the sequence number to use for the fence chain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a new chain node and either start a new chain or add the node to
the existing chain of the previous fence.</p>
</div>
<dl class="type">
<dt id="c.dma_fence_chain">
struct <code class="sig-name descname">dma_fence_chain</code><a class="headerlink" href="#c.dma_fence_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>fence to represent an node of a fence chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence_chain {
    struct dma_fence base;
    struct dma_fence __rcu *prev;
    u64 prev_seqno;
    struct dma_fence *fence;
    union {
        struct dma_fence_cb cb;
        struct irq_work work;
    };
    spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>fence base class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prev</span></code></dt><dd><p>previous fence of the chain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prev_seqno</span></code></dt><dd><p>original previous seqno before garbage collection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>encapsulated fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt><dd><p>callback for signaling</p>
<p>This is used to add the callback for signaling the
complection of the fence chain. Never used at the same time
as the irq work.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>irq work item for signaling</p>
<p>Irq work structure to allow us to add the callback without
running into lock inversion. Never used at the same time as
the callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>spinlock for fence handling</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.to_dma_fence_chain">
struct <a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain">dma_fence_chain</a> * <code class="sig-name descname">to_dma_fence_chain</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.to_dma_fence_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>cast a fence to a dma_fence_chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to cast to a dma_fence_array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the fence is not a dma_fence_chain,
or the dma_fence_chain otherwise.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_chain_contained">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">dma_fence_chain_contained</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_contained" title="Permalink to this definition">¶</a></dt>
<dd><p>return the contained fence</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>the fence to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the fence is a dma_fence_chain the function returns the fence contained
inside the chain object, otherwise it returns the fence itself.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_chain_alloc">
struct <a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain">dma_fence_chain</a> * <code class="sig-name descname">dma_fence_chain_alloc</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_alloc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a new <a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_chain</span></code></a> object or NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_chain_free">
void <code class="sig-name descname">dma_fence_chain_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain">dma_fence_chain</a><em> *chain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_free" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_chain</span> <span class="pre">*chain</span></code></dt><dd><p>chain node to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees up an allocated but not used <a class="reference internal" href="#c.dma_fence_chain" title="dma_fence_chain"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence_chain</span></code></a> object. This
doesn’t need an RCU grace period since the fence was never initialized nor
published. After <a class="reference internal" href="#c.dma_fence_chain_init" title="dma_fence_chain_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_chain_init()</span></code></a> has been called the fence must be
released by calling <a class="reference internal" href="#c.dma_fence_put" title="dma_fence_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_put()</span></code></a>, and not through this function.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_chain_for_each">
<code class="sig-name descname">dma_fence_chain_for_each</code><span class="sig-paren">(</span><em>iter</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_chain_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all fences in chain</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">iter</span></code></dt><dd><p>current fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>starting point</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all fences in the chain. We keep a reference to the current
fence while inside the loop which must be dropped when breaking out.</p>
<p>For a deep dive iterator see <a class="reference internal" href="#c.dma_fence_unwrap_for_each" title="dma_fence_unwrap_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_unwrap_for_each()</span></code></a>.</p>
</div>
</section>
<section id="dma-fence-unwrap">
<h3>DMA Fence unwrap<a class="headerlink" href="#dma-fence-unwrap" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.dma_fence_unwrap">
struct <code class="sig-name descname">dma_fence_unwrap</code><a class="headerlink" href="#c.dma_fence_unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>cursor into the container structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dma_fence_unwrap {
    struct dma_fence *chain;
    struct dma_fence *array;
    unsigned int index;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">chain</span></code></dt><dd><p>potential dma_fence_chain, but can be other fence as well</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">array</span></code></dt><dd><p>potential dma_fence_array, but can be other fence as well</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>last returned index if <strong>array</strong> is really a dma_fence_array</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Should be used with <a class="reference internal" href="#c.dma_fence_unwrap_for_each" title="dma_fence_unwrap_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_unwrap_for_each()</span></code></a> iterator macro.</p>
<dl class="function">
<dt id="c.dma_fence_unwrap_for_each">
<code class="sig-name descname">dma_fence_unwrap_for_each</code><span class="sig-paren">(</span><em>fence</em>, <em>cursor</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_unwrap_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all fences in containers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>current fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cursor</span></code></dt><dd><p>current position inside the containers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>starting point for the iterator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unwrap dma_fence_chain and dma_fence_array containers and deep dive into all
potential fences in them. If <strong>head</strong> is just a normal fence only that one is
returned.</p>
</div>
<dl class="function">
<dt id="c.dma_fence_unwrap_merge">
<code class="sig-name descname">dma_fence_unwrap_merge</code><span class="sig-paren">(</span><em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_fence_unwrap_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>unwrap and merge fences</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All fences given as parameters are unwrapped and merged back together as flat
dma_fence_array. Useful if multiple containers need to be merged together.</p>
<p>Implemented as a macro to allocate the necessary arrays on the stack and
account the stack frame size to the caller.</p>
<p>Returns NULL on memory allocation failure, a dma_fence object representing
all the given fences otherwise.</p>
</div>
</section>
<section id="dma-fence-uabi-sync-file">
<h3>DMA Fence uABI/Sync File<a class="headerlink" href="#dma-fence-uabi-sync-file" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.sync_file_create">
struct <a class="reference internal" href="#c.sync_file" title="sync_file">sync_file</a> * <code class="sig-name descname">sync_file_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a><em> *fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_file_create" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a sync file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*fence</span></code></dt><dd><p>fence to add to the sync_fence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a sync_file containg <strong>fence</strong>. This function acquires and additional
reference of <strong>fence</strong> for the newly-created <a class="reference internal" href="#c.sync_file" title="sync_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">sync_file</span></code></a>, if it succeeds. The
sync_file can be released with fput(sync_file-&gt;file). Returns the
sync_file or NULL in case of error.</p>
</div>
<dl class="function">
<dt id="c.sync_file_get_fence">
struct <a class="reference internal" href="#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="sig-name descname">sync_file_get_fence</code><span class="sig-paren">(</span>int<em> fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_file_get_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>get the fence related to the sync_file fd</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>sync_file fd to get the fence from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ensures <strong>fd</strong> references a valid sync_file and returns a fence that
represents all fence in the sync_file. On error NULL is returned.</p>
</div>
<dl class="type">
<dt id="c.sync_file">
struct <code class="sig-name descname">sync_file</code><a class="headerlink" href="#c.sync_file" title="Permalink to this definition">¶</a></dt>
<dd><p>sync file to export to the userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sync_file {
    struct file             *file;
    char user_name[32];
#ifdef CONFIG_DEBUG_FS;
    struct list_head        sync_file_list;
#endif;
    wait_queue_head_t wq;
    unsigned long           flags;
    struct dma_fence        *fence;
    struct dma_fence_cb cb;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>file representing this fence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">user_name</span></code></dt><dd><p>Name of the sync file provided by userspace, for merged fences.
Otherwise generated through driver callbacks (in which case the
entire array is 0).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sync_file_list</span></code></dt><dd><p>membership in global file list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>wait queue for fence signaling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags for the sync_file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fence</span></code></dt><dd><p>fence with the fences in the sync_file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt><dd><p>fence callback information</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>flags:
POLL_ENABLED: whether userspace is currently poll()’ing or not</p>
</section>
<section id="indefinite-dma-fences">
<h3>Indefinite DMA Fences<a class="headerlink" href="#indefinite-dma-fences" title="Permalink to this headline">¶</a></h3>
<p>At various times <a class="reference internal" href="#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_fence</span></code></a> with an indefinite time until <a class="reference internal" href="#c.dma_fence_wait" title="dma_fence_wait"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_wait()</span></code></a>
finishes have been proposed. Examples include:</p>
<ul class="simple">
<li><p>Future fences, used in HWC1 to signal when a buffer isn’t used by the display
any longer, and created with the screen update that makes the buffer visible.
The time this fence completes is entirely under userspace’s control.</p></li>
<li><p>Proxy fences, proposed to handle &amp;drm_syncobj for which the fence has not yet
been set. Used to asynchronously delay command submission.</p></li>
<li><p>Userspace fences or gpu futexes, fine-grained locking within a command buffer
that userspace uses for synchronization across engines or with the CPU, which
are then imported as a DMA fence for integration into existing winsys
protocols.</p></li>
<li><p>Long-running compute command buffers, while still using traditional end of
batch DMA fences for memory management instead of context preemption DMA
fences which get reattached when the compute job is rescheduled.</p></li>
</ul>
<p>Common to all these schemes is that userspace controls the dependencies of these
fences and controls when they fire. Mixing indefinite fences with normal
in-kernel DMA fences does not work, even when a fallback timeout is included to
protect against malicious userspace:</p>
<ul class="simple">
<li><p>Only the kernel knows about all DMA fence dependencies, userspace is not aware
of dependencies injected due to memory management or scheduler decisions.</p></li>
<li><p>Only userspace knows about all dependencies in indefinite fences and when
exactly they will complete, the kernel has no visibility.</p></li>
</ul>
<p>Furthermore the kernel has to be able to hold up userspace command submission
for memory management needs, which means we must support indefinite fences being
dependent upon DMA fences. If the kernel also support indefinite fences in the
kernel like a DMA fence, like any of the above proposal would, there is the
potential for deadlocks.</p>
<figure class="align-default" id="id1">
<img alt="Indefinite Fencing Dependency Cycle" src="../_images/DOT-e8ff13d1f6d4fbb7ed4e8bcd73fc8bed4777de4f.svg" /><figcaption>
<p><span class="caption-text">Indefinite Fencing Dependency Cycle</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>This means that the kernel might accidentally create deadlocks
through memory management dependencies which userspace is unaware of, which
randomly hangs workloads until the timeout kicks in. Workloads, which from
userspace’s perspective, do not contain a deadlock.  In such a mixed fencing
architecture there is no single entity with knowledge of all dependencies.
Thefore preventing such deadlocks from within the kernel is not possible.</p>
<p>The only solution to avoid dependencies loops is by not allowing indefinite
fences in the kernel. This means:</p>
<ul class="simple">
<li><p>No future fences, proxy fences or userspace fences imported as DMA fences,
with or without a timeout.</p></li>
<li><p>No DMA fences that signal end of batchbuffer for command submission where
userspace is allowed to use userspace fencing or long running compute
workloads. This also means no implicit fencing for shared buffers in these
cases.</p></li>
</ul>
</section>
<section id="recoverable-hardware-page-faults-implications">
<h3>Recoverable Hardware Page Faults Implications<a class="headerlink" href="#recoverable-hardware-page-faults-implications" title="Permalink to this headline">¶</a></h3>
<p>Modern hardware supports recoverable page faults, which has a lot of
implications for DMA fences.</p>
<p>First, a pending page fault obviously holds up the work that’s running on the
accelerator and a memory allocation is usually required to resolve the fault.
But memory allocations are not allowed to gate completion of DMA fences, which
means any workload using recoverable page faults cannot use DMA fences for
synchronization. Synchronization fences controlled by userspace must be used
instead.</p>
<p>On GPUs this poses a problem, because current desktop compositor protocols on
Linux rely on DMA fences, which means without an entirely new userspace stack
built on top of userspace fences, they cannot benefit from recoverable page
faults. Specifically this means implicit synchronization will not be possible.
The exception is when page faults are only used as migration hints and never to
on-demand fill a memory request. For now this means recoverable page
faults on GPUs are limited to pure compute workloads.</p>
<p>Furthermore GPUs usually have shared resources between the 3D rendering and
compute side, like compute units or command submission engines. If both a 3D
job with a DMA fence and a compute workload using recoverable page faults are
pending they could deadlock:</p>
<ul class="simple">
<li><p>The 3D workload might need to wait for the compute job to finish and release
hardware resources first.</p></li>
<li><p>The compute workload might be stuck in a page fault, because the memory
allocation is waiting for the DMA fence of the 3D workload to complete.</p></li>
</ul>
<p>There are a few options to prevent this problem, one of which drivers need to
ensure:</p>
<ul class="simple">
<li><p>Compute workloads can always be preempted, even when a page fault is pending
and not yet repaired. Not all hardware supports this.</p></li>
<li><p>DMA fence workloads and workloads which need page fault handling have
independent hardware resources to guarantee forward progress. This could be
achieved through e.g. through dedicated engines and minimal compute unit
reservations for DMA fence workloads.</p></li>
<li><p>The reservation approach could be further refined by only reserving the
hardware resources for DMA fence workloads when they are in-flight. This must
cover the time from when the DMA fence is visible to other threads up to
moment when fence is completed through <a class="reference internal" href="#c.dma_fence_signal" title="dma_fence_signal"><code class="xref c c-func docutils literal notranslate"><span class="pre">dma_fence_signal()</span></code></a>.</p></li>
<li><p>As a last resort, if the hardware provides no useful reservation mechanics,
all workloads must be flushed from the GPU when switching between jobs
requiring DMA fences or jobs requiring page fault handling: This means all DMA
fences must complete before a compute job with page fault handling can be
inserted into the scheduler queue. And vice versa, before a DMA fence can be
made visible anywhere in the system, all compute workloads must be preempted
to guarantee all pending GPU page faults are flushed.</p></li>
<li><p>Only a fairly theoretical option would be to untangle these dependencies when
allocating memory to repair hardware page faults, either through separate
memory blocks or runtime tracking of the full dependency graph of all DMA
fences. This results very wide impact on the kernel, since resolving the page
on the CPU side can itself involve a page fault. It is much more feasible and
robust to limit the impact of handling hardware page faults to the specific
driver.</p></li>
</ul>
<p>Note that workloads that run on independent hardware like copy engines or other
GPUs do not have any impact. This allows us to keep using DMA fences internally
in the kernel even for resolving hardware page faults, e.g. by using copy
engines to clear or copy memory needed to resolve the page fault.</p>
<p>In some ways this page fault problem is a special case of the <cite>Infinite DMA
Fences</cite> discussions: Infinite fences from compute workloads are allowed to
depend on DMA fences, but not the other way around. And not even the page fault
problem is new, because some other CPU thread in userspace might
hit a page fault which holds up a userspace fence - supporting page faults on
GPUs doesn’t anything fundamentally new.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Buffer Sharing and Synchronization</a><ul>
<li><a class="reference internal" href="#shared-dma-buffers">Shared DMA Buffers</a><ul>
<li><a class="reference internal" href="#userspace-interface-notes">Userspace Interface Notes</a></li>
<li><a class="reference internal" href="#basic-operation-and-device-dma-access">Basic Operation and Device DMA Access</a></li>
<li><a class="reference internal" href="#cpu-access-to-dma-buffer-objects">CPU Access to DMA Buffer Objects</a></li>
<li><a class="reference internal" href="#implicit-fence-poll-support">Implicit Fence Poll Support</a></li>
<li><a class="reference internal" href="#dma-buf-statistics">DMA-BUF statistics</a></li>
<li><a class="reference internal" href="#dma-buffer-ioctls">DMA Buffer ioctls</a></li>
<li><a class="reference internal" href="#dma-buf-locking-convention">DMA-BUF locking convention</a></li>
<li><a class="reference internal" href="#kernel-functions-and-structures-reference">Kernel Functions and Structures Reference</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reservation-objects">Reservation Objects</a></li>
<li><a class="reference internal" href="#dma-fences">DMA Fences</a><ul>
<li><a class="reference internal" href="#dma-fence-cross-driver-contract">DMA Fence Cross-Driver Contract</a></li>
<li><a class="reference internal" href="#dma-fence-signalling-annotations">DMA Fence Signalling Annotations</a></li>
<li><a class="reference internal" href="#dma-fences-functions-reference">DMA Fences Functions Reference</a></li>
<li><a class="reference internal" href="#dma-fence-array">DMA Fence Array</a></li>
<li><a class="reference internal" href="#dma-fence-chain">DMA Fence Chain</a></li>
<li><a class="reference internal" href="#dma-fence-unwrap">DMA Fence unwrap</a></li>
<li><a class="reference internal" href="#dma-fence-uabi-sync-file">DMA Fence uABI/Sync File</a></li>
<li><a class="reference internal" href="#indefinite-dma-fences">Indefinite DMA Fences</a></li>
<li><a class="reference internal" href="#recoverable-hardware-page-faults-implications">Recoverable Hardware Page Faults Implications</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/dma-buf.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/dma-buf.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>