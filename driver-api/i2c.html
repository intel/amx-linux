
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>I2C and SMBus Subsystem &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="IPMB Driver for a Satellite MC" href="ipmb.html" />
    <link rel="prev" title="Serial Peripheral Interface (SPI)" href="spi.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="i2c-and-smbus-subsystem">
<h1>I<sup>2</sup>C and SMBus Subsystem<a class="headerlink" href="#i2c-and-smbus-subsystem" title="Permalink to this headline">¶</a></h1>
<p>I<sup>2</sup>C (or without fancy typography, “I2C”) is an acronym for
the “Inter-IC” bus, a simple bus protocol which is widely used where low
data rate communications suffice. Since it’s also a licensed trademark,
some vendors use another name (such as “Two-Wire Interface”, TWI) for
the same bus. I2C only needs two signals (SCL for clock, SDA for data),
conserving board real estate and minimizing signal quality issues. Most
I2C devices use seven bit addresses, and bus speeds of up to 400 kHz;
there’s a high speed extension (3.4 MHz) that’s not yet found wide use.
I2C is a multi-master bus; open drain signaling is used to arbitrate
between masters, as well as to handshake and to synchronize clocks from
slower clients.</p>
<p>The Linux I2C programming interfaces support the master side of bus
interactions and the slave side. The programming interface is
structured around two kinds of driver, and two kinds of device. An I2C
“Adapter Driver” abstracts the controller hardware; it binds to a
physical device (perhaps a PCI device or platform_device) and exposes a
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span></code> representing each
I2C bus segment it manages. On each I2C bus segment will be I2C devices
represented by a <a class="reference internal" href="#c.i2c_client" title="i2c_client"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_client</span></code></a>.
Those devices will be bound to a <a class="reference internal" href="#c.i2c_driver" title="i2c_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_driver</span></code></a>, which should follow the standard Linux driver model. There
are functions to perform various I2C protocol operations; at this writing
all such functions are usable only from task context.</p>
<p>The System Management Bus (SMBus) is a sibling protocol. Most SMBus
systems are also I2C conformant. The electrical constraints are tighter
for SMBus, and it standardizes particular protocol messages and idioms.
Controllers that support I2C can also support most SMBus operations, but
SMBus controllers don’t support all the protocol options that an I2C
controller will. There are functions to perform various SMBus protocol
operations, either using I2C primitives or by issuing SMBus commands to
i2c_adapter devices which don’t support those I2C operations.</p>
<dl class="function">
<dt id="c.i2c_master_recv">
int <code class="sig-name descname">i2c_master_recv</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, char<em> *buf</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_master_recv" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a single I2C message in master receive mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Where to store data read from slave</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>How many bytes to read, must be less than 64k since msg.len is u16</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, or else the number of bytes read.</p>
</div>
<dl class="function">
<dt id="c.i2c_master_recv_dmasafe">
int <code class="sig-name descname">i2c_master_recv_dmasafe</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, char<em> *buf</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_master_recv_dmasafe" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a single I2C message in master receive mode using a DMA safe buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Where to store data read from slave, must be safe to use with DMA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>How many bytes to read, must be less than 64k since msg.len is u16</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, or else the number of bytes read.</p>
</div>
<dl class="function">
<dt id="c.i2c_master_send">
int <code class="sig-name descname">i2c_master_send</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, const char<em> *buf</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_master_send" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a single I2C message in master transmit mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Data that will be written to the slave</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>How many bytes to write, must be less than 64k since msg.len is u16</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, or else the number of bytes written.</p>
</div>
<dl class="function">
<dt id="c.i2c_master_send_dmasafe">
int <code class="sig-name descname">i2c_master_send_dmasafe</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, const char<em> *buf</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_master_send_dmasafe" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a single I2C message in master transmit mode using a DMA safe buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Data that will be written to the slave, must be safe to use with DMA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>How many bytes to write, must be less than 64k since msg.len is u16</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, or else the number of bytes written.</p>
</div>
<dl class="type">
<dt id="c.i2c_device_identity">
struct <code class="sig-name descname">i2c_device_identity</code><a class="headerlink" href="#c.i2c_device_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>i2c client device identification</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i2c_device_identity {
    u16 manufacturer_id;
#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS                0;
#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_1              1;
#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_2              2;
#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_3              3;
#define I2C_DEVICE_ID_RAMTRON_INTERNATIONAL             4;
#define I2C_DEVICE_ID_ANALOG_DEVICES                    5;
#define I2C_DEVICE_ID_STMICROELECTRONICS                6;
#define I2C_DEVICE_ID_ON_SEMICONDUCTOR                  7;
#define I2C_DEVICE_ID_SPRINTEK_CORPORATION              8;
#define I2C_DEVICE_ID_ESPROS_PHOTONICS_AG               9;
#define I2C_DEVICE_ID_FUJITSU_SEMICONDUCTOR            10;
#define I2C_DEVICE_ID_FLIR                             11;
#define I2C_DEVICE_ID_O2MICRO                          12;
#define I2C_DEVICE_ID_ATMEL                            13;
#define I2C_DEVICE_ID_NONE                         0xffff;
    u16 part_id;
    u8 die_revision;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">manufacturer_id</span></code></dt><dd><p>0 - 4095, database maintained by NXP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">part_id</span></code></dt><dd><p>0 - 511, according to manufacturer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">die_revision</span></code></dt><dd><p>0 - 7, according to manufacturer</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.i2c_driver_flags">
enum <code class="sig-name descname">i2c_driver_flags</code><a class="headerlink" href="#c.i2c_driver_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags for an I2C device driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">I2C_DRV_ACPI_WAIVE_D0_PROBE</span></code></dt><dd><p>Don’t put the device in D0 state for probe</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.i2c_driver">
struct <code class="sig-name descname">i2c_driver</code><a class="headerlink" href="#c.i2c_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>represent an I2C device driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i2c_driver {
    unsigned int class;
    int (*probe)(struct i2c_client *client, const struct i2c_device_id *id);
    void (*remove)(struct i2c_client *client);
    int (*probe_new)(struct i2c_client *client);
    void (*shutdown)(struct i2c_client *client);
    void (*alert)(struct i2c_client *client, enum i2c_alert_protocol protocol, unsigned int data);
    int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);
    struct device_driver driver;
    const struct i2c_device_id *id_table;
    int (*detect)(struct i2c_client *client, struct i2c_board_info *info);
    const unsigned short *address_list;
    struct list_head clients;
    u32 flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">class</span></code></dt><dd><p>What kind of i2c device we instantiate (for detect)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>Callback for device binding - soon to be deprecated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p>Callback for device unbinding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_new</span></code></dt><dd><p>New callback for device binding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p>Callback for device shutdown</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alert</span></code></dt><dd><p>Alert callback, for example for the SMBus alert protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">command</span></code></dt><dd><p>Callback for bus-wide signaling (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>Device driver model driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id_table</span></code></dt><dd><p>List of I2C devices supported by this driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detect</span></code></dt><dd><p>Callback for device detection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">address_list</span></code></dt><dd><p>The I2C addresses to probe (for detect)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clients</span></code></dt><dd><p>List of detected clients we created (for i2c-core use only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>A bitmask of flags defined in <a class="reference internal" href="#c.i2c_driver_flags" title="i2c_driver_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">i2c_driver_flags</span></code></a></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The driver.owner field should be set to the module owner of this driver.
The driver.name field should be set to the name of this driver.</p>
<p>For automatic device detection, both <strong>detect</strong> and <strong>address_list</strong> must
be defined. <strong>class</strong> should also be set, otherwise only devices forced
with module parameters will be created. The detect function must
fill at least the name field of the i2c_board_info structure it is
handed upon successful detection, and possibly also the flags field.</p>
<p>If <strong>detect</strong> is missing, the driver will still work fine for enumerated
devices. Detected devices simply won’t be supported. This is expected
for the many I2C/SMBus devices which can’t be detected reliably, and
the ones which can always be enumerated in practice.</p>
<p>The i2c_client structure which is handed to the <strong>detect</strong> callback is
not a real i2c_client. It is initialized just enough so that you can
call i2c_smbus_read_byte_data and friends on it. Don’t do anything
else with it. In particular, calling dev_dbg and friends on it is
not allowed.</p>
<dl class="type">
<dt id="c.i2c_client">
struct <code class="sig-name descname">i2c_client</code><a class="headerlink" href="#c.i2c_client" title="Permalink to this definition">¶</a></dt>
<dd><p>represent an I2C slave device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i2c_client {
    unsigned short flags;
#define I2C_CLIENT_PEC          0x04    ;
#define I2C_CLIENT_TEN          0x10    ;
#define I2C_CLIENT_SLAVE        0x20    ;
#define I2C_CLIENT_HOST_NOTIFY  0x40    ;
#define I2C_CLIENT_WAKE         0x80    ;
#define I2C_CLIENT_SCCB         0x9000  ;
    unsigned short addr;
    char name[I2C_NAME_SIZE];
    struct i2c_adapter *adapter;
    struct device dev;
    int init_irq;
    int irq;
    struct list_head detected;
#if IS_ENABLED(CONFIG_I2C_SLAVE);
    i2c_slave_cb_t slave_cb;
#endif;
    void *devres_group_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>see I2C_CLIENT_* for possible flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>Address used on the I2C bus connected to the parent adapter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Indicates the type of the device, usually a chip name that’s
generic enough to hide second-sourcing and compatible revisions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adapter</span></code></dt><dd><p>manages the bus segment hosting this I2C device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Driver model device node for the slave.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_irq</span></code></dt><dd><p>IRQ that was set at initialization</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>indicates the IRQ generated by this device (if any)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detected</span></code></dt><dd><p>member of an i2c_driver.clients list or i2c-core’s
userspace_devices list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slave_cb</span></code></dt><dd><p>Callback when I2C slave mode of an adapter is used. The adapter
calls it to pass on slave events to the slave driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devres_group_id</span></code></dt><dd><p>id of the devres group that will be created for resources
acquired when probing this device.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>An i2c_client identifies a single device (i.e. chip) connected to an
i2c bus. The behaviour exposed to Linux is defined by the driver
managing the device.</p>
<dl class="type">
<dt id="c.i2c_board_info">
struct <code class="sig-name descname">i2c_board_info</code><a class="headerlink" href="#c.i2c_board_info" title="Permalink to this definition">¶</a></dt>
<dd><p>template for device creation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i2c_board_info {
    char type[I2C_NAME_SIZE];
    unsigned short  flags;
    unsigned short  addr;
    const char      *dev_name;
    void *platform_data;
    struct device_node *of_node;
    struct fwnode_handle *fwnode;
    const struct software_node *swnode;
    const struct resource *resources;
    unsigned int    num_resources;
    int irq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>chip type, to initialize i2c_client.name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>to initialize i2c_client.flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>stored in i2c_client.addr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_name</span></code></dt><dd><p>Overrides the default &lt;busnr&gt;-&lt;addr&gt; dev_name if set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">platform_data</span></code></dt><dd><p>stored in i2c_client.dev.platform_data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt><dd><p>pointer to OpenFirmware device node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt><dd><p>device node supplied by the platform firmware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">swnode</span></code></dt><dd><p>software node for the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resources</span></code></dt><dd><p>resources associated with the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_resources</span></code></dt><dd><p>number of resources in the <strong>resources</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>stored in i2c_client.irq</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>I2C doesn’t actually support hardware probing, although controllers and
devices may be able to use I2C_SMBUS_QUICK to tell whether or not there’s
a device at a given address.  Drivers commonly need more information than
that, such as chip type, configuration, associated IRQ, and so on.</p>
<p>i2c_board_info is used to build tables of information listing I2C devices
that are present.  This information is used to grow the driver model tree.
For mainboards this is done statically using <a class="reference internal" href="#c.i2c_register_board_info" title="i2c_register_board_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_register_board_info()</span></code></a>;
bus numbers identify adapters that aren’t yet available.  For add-on boards,
<a class="reference internal" href="#c.i2c_new_client_device" title="i2c_new_client_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_new_client_device()</span></code></a> does this dynamically with the adapter already known.</p>
<dl class="function">
<dt id="c.I2C_BOARD_INFO">
<code class="sig-name descname">I2C_BOARD_INFO</code><span class="sig-paren">(</span><em>dev_type</em>, <em>dev_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.I2C_BOARD_INFO" title="Permalink to this definition">¶</a></dt>
<dd><p>macro used to list an i2c device and its address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_type</span></code></dt><dd><p>identifies the device type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_addr</span></code></dt><dd><p>the device’s address on the bus.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro initializes essential fields of a <a class="reference internal" href="#c.i2c_board_info" title="i2c_board_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_board_info</span></code></a>,
declaring what has been provided on a particular board.  Optional
fields (such as associated irq, or device-specific platform_data)
are provided using conventional syntax.</p>
</div>
<dl class="type">
<dt id="c.i2c_algorithm">
struct <code class="sig-name descname">i2c_algorithm</code><a class="headerlink" href="#c.i2c_algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>represent I2C transfer method</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i2c_algorithm {
    int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);
    int (*master_xfer_atomic)(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);
    int (*smbus_xfer)(struct i2c_adapter *adap, u16 addr,unsigned short flags, char read_write, u8 command, int size, union i2c_smbus_data *data);
    int (*smbus_xfer_atomic)(struct i2c_adapter *adap, u16 addr,unsigned short flags, char read_write, u8 command, int size, union i2c_smbus_data *data);
    u32 (*functionality)(struct i2c_adapter *adap);
#if IS_ENABLED(CONFIG_I2C_SLAVE);
    int (*reg_slave)(struct i2c_client *client);
    int (*unreg_slave)(struct i2c_client *client);
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">master_xfer</span></code></dt><dd><p>Issue a set of i2c transactions to the given I2C adapter
defined by the msgs array, with num messages available to transfer via
the adapter specified by adap.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master_xfer_atomic</span></code></dt><dd><p>same as <strong>master_xfer</strong>. Yet, only using atomic context
so e.g. PMICs can be accessed very late before shutdown. Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">smbus_xfer</span></code></dt><dd><p>Issue smbus transactions to the given I2C adapter. If this
is not present, then the bus layer will try and convert the SMBus calls
into I2C transfers instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">smbus_xfer_atomic</span></code></dt><dd><p>same as <strong>smbus_xfer</strong>. Yet, only using atomic context
so e.g. PMICs can be accessed very late before shutdown. Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">functionality</span></code></dt><dd><p>Return the flags that this algorithm/adapter pair supports
from the <code class="docutils literal notranslate"><span class="pre">I2C_FUNC_*</span></code> flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_slave</span></code></dt><dd><p>Register given client to I2C slave mode of this adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unreg_slave</span></code></dt><dd><p>Unregister given client from I2C slave mode of this adapter</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The following structs are for those who like to implement new bus drivers:
i2c_algorithm is the interface to a class of hardware solutions which can
be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584
to name two of the most common.</p>
<p>The return codes from the <code class="docutils literal notranslate"><span class="pre">master_xfer{_atomic}</span></code> fields should indicate the
type of error code that occurred during the transfer, as documented in the
Kernel Documentation file <a class="reference internal" href="../i2c/fault-codes.html"><span class="doc">I2C/SMBUS Fault Codes</span></a>. Otherwise, the
number of messages executed should be returned.</p>
<dl class="type">
<dt id="c.i2c_lock_operations">
struct <code class="sig-name descname">i2c_lock_operations</code><a class="headerlink" href="#c.i2c_lock_operations" title="Permalink to this definition">¶</a></dt>
<dd><p>represent I2C locking operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i2c_lock_operations {
    void (*lock_bus)(struct i2c_adapter *adapter, unsigned int flags);
    int (*trylock_bus)(struct i2c_adapter *adapter, unsigned int flags);
    void (*unlock_bus)(struct i2c_adapter *adapter, unsigned int flags);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lock_bus</span></code></dt><dd><p>Get exclusive access to an I2C bus segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trylock_bus</span></code></dt><dd><p>Try to get exclusive access to an I2C bus segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unlock_bus</span></code></dt><dd><p>Release exclusive access to an I2C bus segment</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The main operations are wrapped by i2c_lock_bus and i2c_unlock_bus.</p>
<dl class="type">
<dt id="c.i2c_timings">
struct <code class="sig-name descname">i2c_timings</code><a class="headerlink" href="#c.i2c_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C timing information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i2c_timings {
    u32 bus_freq_hz;
    u32 scl_rise_ns;
    u32 scl_fall_ns;
    u32 scl_int_delay_ns;
    u32 sda_fall_ns;
    u32 sda_hold_ns;
    u32 digital_filter_width_ns;
    u32 analog_filter_cutoff_freq_hz;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bus_freq_hz</span></code></dt><dd><p>the bus frequency in Hz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scl_rise_ns</span></code></dt><dd><p>time SCL signal takes to rise in ns; t(r) in the I2C specification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scl_fall_ns</span></code></dt><dd><p>time SCL signal takes to fall in ns; t(f) in the I2C specification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scl_int_delay_ns</span></code></dt><dd><p>time IP core additionally needs to setup SCL in ns</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sda_fall_ns</span></code></dt><dd><p>time SDA signal takes to fall in ns; t(f) in the I2C specification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sda_hold_ns</span></code></dt><dd><p>time IP core additionally needs to hold SDA in ns</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">digital_filter_width_ns</span></code></dt><dd><p>width in ns of spikes on i2c lines that the IP core
digital filter can filter out</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">analog_filter_cutoff_freq_hz</span></code></dt><dd><p>threshold frequency for the low pass IP core
analog filter</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.i2c_bus_recovery_info">
struct <code class="sig-name descname">i2c_bus_recovery_info</code><a class="headerlink" href="#c.i2c_bus_recovery_info" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C bus recovery information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i2c_bus_recovery_info {
    int (*recover_bus)(struct i2c_adapter *adap);
    int (*get_scl)(struct i2c_adapter *adap);
    void (*set_scl)(struct i2c_adapter *adap, int val);
    int (*get_sda)(struct i2c_adapter *adap);
    void (*set_sda)(struct i2c_adapter *adap, int val);
    int (*get_bus_free)(struct i2c_adapter *adap);
    void (*prepare_recovery)(struct i2c_adapter *adap);
    void (*unprepare_recovery)(struct i2c_adapter *adap);
    struct gpio_desc *scl_gpiod;
    struct gpio_desc *sda_gpiod;
    struct pinctrl *pinctrl;
    struct pinctrl_state *pins_default;
    struct pinctrl_state *pins_gpio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">recover_bus</span></code></dt><dd><p>Recover routine. Either pass driver’s recover_bus() routine, or
i2c_generic_scl_recovery().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_scl</span></code></dt><dd><p>This gets current value of SCL line. Mandatory for generic SCL
recovery. Populated internally for generic GPIO recovery.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_scl</span></code></dt><dd><p>This sets/clears the SCL line. Mandatory for generic SCL recovery.
Populated internally for generic GPIO recovery.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_sda</span></code></dt><dd><p>This gets current value of SDA line. This or set_sda() is mandatory
for generic SCL recovery. Populated internally, if sda_gpio is a valid
GPIO, for generic GPIO recovery.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_sda</span></code></dt><dd><p>This sets/clears the SDA line. This or get_sda() is mandatory for
generic SCL recovery. Populated internally, if sda_gpio is a valid GPIO,
for generic GPIO recovery.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_bus_free</span></code></dt><dd><p>Returns the bus free state as seen from the IP core in case it
has a more complex internal logic than just reading SDA. Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_recovery</span></code></dt><dd><p>This will be called before starting recovery. Platform may
configure padmux here for SDA/SCL line or something else they want.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unprepare_recovery</span></code></dt><dd><p>This will be called after completing recovery. Platform
may configure padmux here for SDA/SCL line or something else they want.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scl_gpiod</span></code></dt><dd><p>gpiod of the SCL line. Only required for GPIO recovery.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sda_gpiod</span></code></dt><dd><p>gpiod of the SDA line. Only required for GPIO recovery.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pinctrl</span></code></dt><dd><p>pinctrl used by GPIO recovery to change the state of the I2C pins.
Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pins_default</span></code></dt><dd><p>default pinctrl state of SCL/SDA lines, when they are assigned
to the I2C bus. Optional. Populated internally for GPIO recovery, if
state with the name PINCTRL_STATE_DEFAULT is found and pinctrl is valid.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pins_gpio</span></code></dt><dd><p>recovery pinctrl state of SCL/SDA lines, when they are used as
GPIOs. Optional. Populated internally for GPIO recovery, if this state
is called “gpio” or “recovery” and pinctrl is valid.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.i2c_adapter_quirks">
struct <code class="sig-name descname">i2c_adapter_quirks</code><a class="headerlink" href="#c.i2c_adapter_quirks" title="Permalink to this definition">¶</a></dt>
<dd><p>describe flaws of an i2c adapter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i2c_adapter_quirks {
    u64 flags;
    int max_num_msgs;
    u16 max_write_len;
    u16 max_read_len;
    u16 max_comb_1st_msg_len;
    u16 max_comb_2nd_msg_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>see I2C_AQ_* for possible flags and read below</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_num_msgs</span></code></dt><dd><p>maximum number of messages per transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_write_len</span></code></dt><dd><p>maximum length of a write message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_read_len</span></code></dt><dd><p>maximum length of a read message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_comb_1st_msg_len</span></code></dt><dd><p>maximum length of the first msg in a combined message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_comb_2nd_msg_len</span></code></dt><dd><p>maximum length of the second msg in a combined message</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Note about combined messages: Some I2C controllers can only send one message
per transfer, plus something called combined message or write-then-read.
This is (usually) a small write message followed by a read message and
barely enough to access register based devices like EEPROMs. There is a flag
to support this mode. It implies max_num_msg = 2 and does the length checks
with max_comb_*_len because combined message mode usually has its own
limitations. Because of HW implementations, some controllers can actually do
write-then-anything or other variants. To support that, write-then-read has
been broken out into smaller bits like write-first and read-second which can
be combined as needed.</p>
<dl class="function">
<dt id="c.i2c_lock_bus">
void <code class="sig-name descname">i2c_lock_bus</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_lock_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Get exclusive access to an I2C bus segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>Target I2C bus segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>I2C_LOCK_ROOT_ADAPTER locks the root i2c adapter, I2C_LOCK_SEGMENT
locks only this branch in the adapter tree</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.i2c_trylock_bus">
int <code class="sig-name descname">i2c_trylock_bus</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_trylock_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to get exclusive access to an I2C bus segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>Target I2C bus segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>I2C_LOCK_ROOT_ADAPTER tries to locks the root i2c adapter,
I2C_LOCK_SEGMENT tries to lock only this branch in the adapter tree</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the I2C bus segment is locked, false otherwise</p>
</div>
<dl class="function">
<dt id="c.i2c_unlock_bus">
void <code class="sig-name descname">i2c_unlock_bus</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_unlock_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Release exclusive access to an I2C bus segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>Target I2C bus segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>I2C_LOCK_ROOT_ADAPTER unlocks the root i2c adapter, I2C_LOCK_SEGMENT
unlocks only this branch in the adapter tree</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.i2c_mark_adapter_suspended">
void <code class="sig-name descname">i2c_mark_adapter_suspended</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_mark_adapter_suspended" title="Permalink to this definition">¶</a></dt>
<dd><p>Report suspended state of the adapter to the core</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>Adapter to mark as suspended</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When using this helper to mark an adapter as suspended, the core will reject
further transfers to this adapter. The usage of this helper is optional but
recommended for devices having distinct handlers for system suspend and
runtime suspend. More complex devices are free to implement custom solutions
to reject transfers when suspended.</p>
</div>
<dl class="function">
<dt id="c.i2c_mark_adapter_resumed">
void <code class="sig-name descname">i2c_mark_adapter_resumed</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_mark_adapter_resumed" title="Permalink to this definition">¶</a></dt>
<dd><p>Report resumed state of the adapter to the core</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>Adapter to mark as resumed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When using this helper to mark an adapter as resumed, the core will allow
further transfers to this adapter. See also further notes to
<strong><a class="reference internal" href="#c.i2c_mark_adapter_suspended" title="i2c_mark_adapter_suspended"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_mark_adapter_suspended()</span></code></a></strong>.</p>
</div>
<dl class="function">
<dt id="c.i2c_check_quirks">
bool <code class="sig-name descname">i2c_check_quirks</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adap</em>, u64<em> quirks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_check_quirks" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for checking the quirk flags in an i2c adapter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>i2c adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">quirks</span></code></dt><dd><p>quirk flags</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the adapter has all the specified quirk flags, false if not</p>
</div>
<dl class="function">
<dt id="c.module_i2c_driver">
<code class="sig-name descname">module_i2c_driver</code><span class="sig-paren">(</span><em>__i2c_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_i2c_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a modular I2C driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__i2c_driver</span></code></dt><dd><p>i2c_driver struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for I2C drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.builtin_i2c_driver">
<code class="sig-name descname">builtin_i2c_driver</code><span class="sig-paren">(</span><em>__i2c_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.builtin_i2c_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a builtin I2C driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__i2c_driver</span></code></dt><dd><p>i2c_driver struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for I2C drivers which do not do anything special in their
init. This eliminates a lot of boilerplate. Each driver may only
use this macro once, and calling it replaces device_initcall().</p>
</div>
<dl class="function">
<dt id="c.i2c_register_board_info">
int <code class="sig-name descname">i2c_register_board_info</code><span class="sig-paren">(</span>int<em> busnum</em>, struct <a class="reference internal" href="#c.i2c_board_info" title="i2c_board_info">i2c_board_info</a> const<em> *info</em>, unsigned<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_register_board_info" title="Permalink to this definition">¶</a></dt>
<dd><p>statically declare I2C devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">busnum</span></code></dt><dd><p>identifies the bus to which these devices belong</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_board_info</span> <span class="pre">const</span> <span class="pre">*info</span></code></dt><dd><p>vector of i2c device descriptors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">len</span></code></dt><dd><p>how many descriptors in the vector; may be zero to reserve
the specified bus number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Systems using the Linux I2C driver stack can declare tables of board info
while they initialize.  This should be done in board-specific init code
near arch_initcall() time, or equivalent, before any I2C adapter driver is
registered.  For example, mainboard init code could define several devices,
as could the init code for each daughtercard in a board stack.</p>
<p>The I2C devices will be created later, after the adapter for the relevant
bus has been registered.  After that moment, standard driver model tools
are used to bind “new style” I2C drivers to the devices.  The bus number
for any device declared using this routine is not available for dynamic
allocation.</p>
<p>The board info passed can safely be __initdata, but be careful of embedded
pointers (for platform_data, functions, etc) since that won’t be copied.</p>
</div>
<dl class="function">
<dt id="c.i2c_verify_client">
struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> * <code class="sig-name descname">i2c_verify_client</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_verify_client" title="Permalink to this definition">¶</a></dt>
<dd><p>return parameter as i2c_client, or NULL</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device, probably from some driver model iterator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When traversing the driver model tree, perhaps using driver model
iterators like <strong><a class="reference internal" href="infrastructure.html#c.device_for_each_child" title="device_for_each_child"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_for_each_child()</span></code></a></strong>, you can’t assume very much
about the nodes you find.  Use this function to avoid oopses caused
by wrongly treating some non-I2C device as an i2c_client.</p>
</div>
<dl class="function">
<dt id="c.i2c_new_client_device">
struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> * <code class="sig-name descname">i2c_new_client_device</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adap</em>, struct <a class="reference internal" href="#c.i2c_board_info" title="i2c_board_info">i2c_board_info</a> const<em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_new_client_device" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiate an i2c device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>the adapter managing the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_board_info</span> <span class="pre">const</span> <span class="pre">*info</span></code></dt><dd><p>describes one I2C device; bus_num is ignored</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Create an i2c device. Binding is handled through driver model
probe()/remove() methods.  A driver may be bound to this device when we
return from this function, or any later moment (e.g. maybe hotplugging will
load the driver module).  This call is not appropriate for use by mainboard
initialization logic, which usually runs during an arch_initcall() long
before any i2c_adapter could exist.</p>
<p>This returns the new i2c client, which may be saved for later use with
<a class="reference internal" href="#c.i2c_unregister_device" title="i2c_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_unregister_device()</span></code></a>; or an ERR_PTR to describe the error.</p>
</div>
<dl class="function">
<dt id="c.i2c_unregister_device">
void <code class="sig-name descname">i2c_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>reverse effect of i2c_new_*_device()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>value returned from i2c_new_*_device()</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
</div>
<dl class="function">
<dt id="c.i2c_new_dummy_device">
struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> * <code class="sig-name descname">i2c_new_dummy_device</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, u16<em> address</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_new_dummy_device" title="Permalink to this definition">¶</a></dt>
<dd><p>return a new i2c device bound to a dummy driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>the adapter managing the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">address</span></code></dt><dd><p>seven bit address to be used</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This returns an I2C client bound to the “dummy” driver, intended for use
with devices that consume multiple addresses.  Examples of such chips
include various EEPROMS (like 24c04 and 24c08 models).</p>
<p>These dummy devices have two main uses.  First, most I2C and SMBus calls
except <a class="reference internal" href="#c.i2c_transfer" title="i2c_transfer"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_transfer()</span></code></a> need a client handle; the dummy will be that handle.
And second, this prevents the specified address from being bound to a
different driver.</p>
<p>This returns the new i2c client, which should be saved for later use with
<a class="reference internal" href="#c.i2c_unregister_device" title="i2c_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_unregister_device()</span></code></a>; or an ERR_PTR to describe the error.</p>
</div>
<dl class="function">
<dt id="c.devm_i2c_new_dummy_device">
struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> * <code class="sig-name descname">devm_i2c_new_dummy_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct i2c_adapter<em> *adapter</em>, u16<em> address</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_i2c_new_dummy_device" title="Permalink to this definition">¶</a></dt>
<dd><p>return a new i2c device bound to a dummy driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device the managed resource is bound to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>the adapter managing the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">address</span></code></dt><dd><p>seven bit address to be used</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This is the device-managed version of <strong>i2c_new_dummy_device</strong>. It returns the
new i2c client or an ERR_PTR in case of an error.</p>
</div>
<dl class="function">
<dt id="c.i2c_new_ancillary_device">
struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> * <code class="sig-name descname">i2c_new_ancillary_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, const char<em> *name</em>, u16<em> default_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_new_ancillary_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to get the instantiated secondary address and create the associated device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to the primary client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Handle to specify which secondary address to get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">default_addr</span></code></dt><dd><p>Used as a fallback if no secondary address was specified</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>I2C clients can be composed of multiple I2C slaves bound together in a single
component. The I2C client driver then binds to the master I2C slave and needs
to create I2C dummy clients to communicate with all the other slaves.</p>
<p>This function creates and returns an I2C dummy client whose I2C address is
retrieved from the platform firmware based on the given slave name. If no
address is specified by the firmware default_addr is used.</p>
<p>On DT-based platforms the address is retrieved from the “reg” property entry
cell whose “reg-names” value matches the slave name.</p>
<p>This returns the new i2c client, which should be saved for later use with
<a class="reference internal" href="#c.i2c_unregister_device" title="i2c_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_unregister_device()</span></code></a>; or an ERR_PTR to describe the error.</p>
</div>
<dl class="function">
<dt id="c.i2c_verify_adapter">
struct i2c_adapter * <code class="sig-name descname">i2c_verify_adapter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_verify_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>return parameter as i2c_adapter or NULL</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device, probably from some driver model iterator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When traversing the driver model tree, perhaps using driver model
iterators like <strong><a class="reference internal" href="infrastructure.html#c.device_for_each_child" title="device_for_each_child"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_for_each_child()</span></code></a></strong>, you can’t assume very much
about the nodes you find.  Use this function to avoid oopses caused
by wrongly treating some non-I2C device as an i2c_adapter.</p>
</div>
<dl class="function">
<dt id="c.i2c_handle_smbus_host_notify">
int <code class="sig-name descname">i2c_handle_smbus_host_notify</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adap</em>, unsigned short<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_handle_smbus_host_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward a Host Notify event to the correct I2C client.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>the adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">addr</span></code></dt><dd><p>the I2C address of the notifying device</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can’t sleep</p>
<p><strong>Description</strong></p>
<p>Helper function to be called from an I2C bus driver’s interrupt
handler. It will schedule the Host Notify IRQ.</p>
</div>
<dl class="function">
<dt id="c.i2c_add_adapter">
int <code class="sig-name descname">i2c_add_adapter</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_add_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>declare i2c adapter, use dynamic bus number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>the adapter to add</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This routine is used to declare an I2C adapter when its bus number
doesn’t matter or when its bus number is specified by an dt alias.
Examples of bases when the bus number doesn’t matter: I2C adapters
dynamically added by USB links or PCI plugin cards.</p>
<p>When this returns zero, a new bus number was allocated and stored
in adap-&gt;nr, and the specified adapter became available for clients.
Otherwise, a negative errno value is returned.</p>
</div>
<dl class="function">
<dt id="c.i2c_add_numbered_adapter">
int <code class="sig-name descname">i2c_add_numbered_adapter</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_add_numbered_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>declare i2c adapter, use static bus number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>the adapter to register (with adap-&gt;nr initialized)</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This routine is used to declare an I2C adapter when its bus number
matters.  For example, use it for I2C adapters from system-on-chip CPUs,
or otherwise built in to the system’s mainboard, and where i2c_board_info
is used to properly configure I2C devices.</p>
<p>If the requested bus number is set to -1, then this function will behave
identically to i2c_add_adapter, and will dynamically assign a bus number.</p>
<p>If no devices have pre-been declared for this bus, then be sure to
register the adapter before any dynamically allocated ones.  Otherwise
the required bus ID may not be available.</p>
<p>When this returns zero, the specified adapter became available for
clients using the bus number provided in adap-&gt;nr.  Also, the table
of I2C devices pre-declared using <a class="reference internal" href="#c.i2c_register_board_info" title="i2c_register_board_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_register_board_info()</span></code></a> is scanned,
and the appropriate driver model device nodes are created.  Otherwise, a
negative errno value is returned.</p>
</div>
<dl class="function">
<dt id="c.i2c_del_adapter">
void <code class="sig-name descname">i2c_del_adapter</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_del_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister I2C adapter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>the adapter being unregistered</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This unregisters an I2C adapter which was previously registered
by <strong>i2c_add_adapter</strong> or <strong>i2c_add_numbered_adapter</strong>.</p>
</div>
<dl class="function">
<dt id="c.devm_i2c_add_adapter">
int <code class="sig-name descname">devm_i2c_add_adapter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct i2c_adapter<em> *adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_i2c_add_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>device-managed variant of <a class="reference internal" href="#c.i2c_add_adapter" title="i2c_add_adapter"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_add_adapter()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>managing device for adding this I2C adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>the adapter to add</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Add adapter with dynamic bus number, same with <a class="reference internal" href="#c.i2c_add_adapter" title="i2c_add_adapter"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_add_adapter()</span></code></a>
but the adapter will be auto deleted on driver detach.</p>
</div>
<dl class="function">
<dt id="c.i2c_parse_fw_timings">
void <code class="sig-name descname">i2c_parse_fw_timings</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.i2c_timings" title="i2c_timings">i2c_timings</a><em> *t</em>, bool<em> use_defaults</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_parse_fw_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>get I2C related timing parameters from firmware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The device to scan for I2C timing properties</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_timings</span> <span class="pre">*t</span></code></dt><dd><p>the i2c_timings struct to be filled with values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">use_defaults</span></code></dt><dd><p>bool to use sane defaults derived from the I2C specification
when properties are not found, otherwise don’t update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan the device for the generic I2C properties describing timing parameters
for the signal and fill the given struct with the results. If a property was
not found and use_defaults was true, then maximum timings are assumed which
are derived from the I2C specification. If use_defaults is not used, the
results will be as before, so drivers can apply their own defaults before
calling this helper. The latter is mainly intended for avoiding regressions
of existing drivers which want to switch to this function. New drivers
almost always should use the defaults.</p>
</div>
<dl class="function">
<dt id="c.i2c_del_driver">
void <code class="sig-name descname">i2c_del_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i2c_driver" title="i2c_driver">i2c_driver</a><em> *driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_del_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister I2C driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the driver being unregistered</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
</div>
<dl class="function">
<dt id="c.__i2c_transfer">
int <code class="sig-name descname">__i2c_transfer</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adap</em>, struct i2c_msg<em> *msgs</em>, int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__i2c_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>unlocked flavor of i2c_transfer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>Handle to I2C bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_msg</span> <span class="pre">*msgs</span></code></dt><dd><p>One or more messages to execute before STOP is issued to
terminate the operation; each message begins with a START.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>Number of messages to be executed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, else the number of messages executed.</p>
<p>Adapter lock must be held when calling this function. No debug logging
takes place. adap-&gt;algo-&gt;master_xfer existence isn’t checked.</p>
</div>
<dl class="function">
<dt id="c.i2c_transfer">
int <code class="sig-name descname">i2c_transfer</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adap</em>, struct i2c_msg<em> *msgs</em>, int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>execute a single or combined I2C message</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adap</span></code></dt><dd><p>Handle to I2C bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_msg</span> <span class="pre">*msgs</span></code></dt><dd><p>One or more messages to execute before STOP is issued to
terminate the operation; each message begins with a START.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>Number of messages to be executed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, else the number of messages executed.</p>
<p>Note that there is no requirement that each message be sent to
the same slave address, although that is the most common model.</p>
</div>
<dl class="function">
<dt id="c.i2c_transfer_buffer_flags">
int <code class="sig-name descname">i2c_transfer_buffer_flags</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, char<em> *buf</em>, int<em> count</em>, u16<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_transfer_buffer_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a single I2C message transferring data to/from a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Where the data is stored</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>How many bytes to transfer, must be less than 64k since msg.len is u16</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">flags</span></code></dt><dd><p>The flags to be used for the message, e.g. I2C_M_RD for reads</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, or else the number of bytes transferred.</p>
</div>
<dl class="function">
<dt id="c.i2c_get_device_id">
int <code class="sig-name descname">i2c_get_device_id</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, struct <a class="reference internal" href="#c.i2c_device_identity" title="i2c_device_identity">i2c_device_identity</a><em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_get_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>get manufacturer, part id and die revision of a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>The device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_device_identity</span> <span class="pre">*id</span></code></dt><dd><p>The queried information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno on error, zero on success.</p>
</div>
<dl class="function">
<dt id="c.i2c_client_get_device_id">
const struct i2c_device_id * <code class="sig-name descname">i2c_client_get_device_id</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_client_get_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>get the driver match table entry of a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>the device to query. The device must be bound to a driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the matching entry if found, NULL otherwise.</p>
</div>
<dl class="function">
<dt id="c.i2c_get_dma_safe_msg_buf">
u8 * <code class="sig-name descname">i2c_get_dma_safe_msg_buf</code><span class="sig-paren">(</span>struct i2c_msg<em> *msg</em>, unsigned int<em> threshold</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_get_dma_safe_msg_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>get a DMA safe buffer for the given i2c_msg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_msg</span> <span class="pre">*msg</span></code></dt><dd><p>the message to be checked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">threshold</span></code></dt><dd><p>the minimum number of bytes for which using DMA makes sense.
Should at least be 1.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>NULL if a DMA safe buffer was not obtained. Use msg-&gt;buf with PIO.</dt><dd><p>Or a valid pointer to be used with DMA. After use, release it by
calling <a class="reference internal" href="#c.i2c_put_dma_safe_msg_buf" title="i2c_put_dma_safe_msg_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_put_dma_safe_msg_buf()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must only be called from process context!</p>
</div>
<dl class="function">
<dt id="c.i2c_put_dma_safe_msg_buf">
void <code class="sig-name descname">i2c_put_dma_safe_msg_buf</code><span class="sig-paren">(</span>u8<em> *buf</em>, struct i2c_msg<em> *msg</em>, bool<em> xferred</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_put_dma_safe_msg_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>release DMA safe buffer and sync with i2c_msg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer obtained from <a class="reference internal" href="#c.i2c_get_dma_safe_msg_buf" title="i2c_get_dma_safe_msg_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_get_dma_safe_msg_buf()</span></code></a>. May be NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_msg</span> <span class="pre">*msg</span></code></dt><dd><p>the message which the buffer corresponds to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">xferred</span></code></dt><dd><p>bool saying if the message was transferred</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.i2c_smbus_pec">
u8 <code class="sig-name descname">i2c_smbus_pec</code><span class="sig-paren">(</span>u8<em> crc</em>, u8<em> *p</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_pec" title="Permalink to this definition">¶</a></dt>
<dd><p>Incremental CRC8 over the given input data array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">crc</span></code></dt><dd><p>previous return crc8 value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*p</span></code></dt><dd><p>pointer to data buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes in data buffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Incremental CRC8 over count bytes in the array pointed to by p</p>
</div>
<dl class="function">
<dt id="c.i2c_smbus_read_byte">
s32 <code class="sig-name descname">i2c_smbus_read_byte</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_read_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “receive byte” protocol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “receive byte” protocol, returning negative errno
else the byte received from the device.</p>
</div>
<dl class="function">
<dt id="c.i2c_smbus_write_byte">
s32 <code class="sig-name descname">i2c_smbus_write_byte</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, u8<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_write_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “send byte” protocol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">value</span></code></dt><dd><p>Byte to be sent</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “send byte” protocol, returning negative errno
else zero on success.</p>
</div>
<dl class="function">
<dt id="c.i2c_smbus_read_byte_data">
s32 <code class="sig-name descname">i2c_smbus_read_byte_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, u8<em> command</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_read_byte_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “read byte” protocol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">command</span></code></dt><dd><p>Byte interpreted by slave</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “read byte” protocol, returning negative errno
else a data byte received from the device.</p>
</div>
<dl class="function">
<dt id="c.i2c_smbus_write_byte_data">
s32 <code class="sig-name descname">i2c_smbus_write_byte_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, u8<em> command</em>, u8<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_write_byte_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “write byte” protocol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">command</span></code></dt><dd><p>Byte interpreted by slave</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">value</span></code></dt><dd><p>Byte being written</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “write byte” protocol, returning negative errno
else zero on success.</p>
</div>
<dl class="function">
<dt id="c.i2c_smbus_read_word_data">
s32 <code class="sig-name descname">i2c_smbus_read_word_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, u8<em> command</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_read_word_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “read word” protocol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">command</span></code></dt><dd><p>Byte interpreted by slave</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “read word” protocol, returning negative errno
else a 16-bit unsigned “word” received from the device.</p>
</div>
<dl class="function">
<dt id="c.i2c_smbus_write_word_data">
s32 <code class="sig-name descname">i2c_smbus_write_word_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, u8<em> command</em>, u16<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_write_word_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “write word” protocol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">command</span></code></dt><dd><p>Byte interpreted by slave</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">value</span></code></dt><dd><p>16-bit “word” being written</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “write word” protocol, returning negative errno
else zero on success.</p>
</div>
<dl class="function">
<dt id="c.i2c_smbus_read_block_data">
s32 <code class="sig-name descname">i2c_smbus_read_block_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, u8<em> command</em>, u8<em> *values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_read_block_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “block read” protocol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">command</span></code></dt><dd><p>Byte interpreted by slave</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*values</span></code></dt><dd><p>Byte array into which data will be read; big enough to hold
the data returned by the slave.  SMBus allows at most 32 bytes.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “block read” protocol, returning negative errno
else the number of data bytes in the slave’s response.</p>
<p>Note that using this function requires that the client’s adapter support
the I2C_FUNC_SMBUS_READ_BLOCK_DATA functionality.  Not all adapter drivers
support this; its emulation through I2C messaging relies on a specific
mechanism (I2C_M_RECV_LEN) which may not be implemented.</p>
</div>
<dl class="function">
<dt id="c.i2c_smbus_write_block_data">
s32 <code class="sig-name descname">i2c_smbus_write_block_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, u8<em> command</em>, u8<em> length</em>, const u8<em> *values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_write_block_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “block write” protocol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">command</span></code></dt><dd><p>Byte interpreted by slave</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">length</span></code></dt><dd><p>Size of data block; SMBus allows at most 32 bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*values</span></code></dt><dd><p>Byte array which will be written.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “block write” protocol, returning negative errno
else zero on success.</p>
</div>
<dl class="function">
<dt id="c.i2c_smbus_xfer">
s32 <code class="sig-name descname">i2c_smbus_xfer</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, u16<em> addr</em>, unsigned short<em> flags</em>, char<em> read_write</em>, u8<em> command</em>, int<em> protocol</em>, union i2c_smbus_data<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_xfer" title="Permalink to this definition">¶</a></dt>
<dd><p>execute SMBus protocol operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>Handle to I2C bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">addr</span></code></dt><dd><p>Address of SMBus slave on that bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">flags</span></code></dt><dd><p>I2C_CLIENT_* flags (usually zero or I2C_CLIENT_PEC)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">read_write</span></code></dt><dd><p>I2C_SMBUS_READ or I2C_SMBUS_WRITE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">command</span></code></dt><dd><p>Byte interpreted by slave, for protocols which use such bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt><dd><p>SMBus protocol operation to execute, such as I2C_SMBUS_PROC_CALL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">i2c_smbus_data</span> <span class="pre">*data</span></code></dt><dd><p>Data to be read or written</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes an SMBus protocol operation, and returns a negative
errno code else zero on success.</p>
</div>
<dl class="function">
<dt id="c.i2c_smbus_read_i2c_block_data_or_emulated">
s32 <code class="sig-name descname">i2c_smbus_read_i2c_block_data_or_emulated</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a><em> *client</em>, u8<em> command</em>, u8<em> length</em>, u8<em> *values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_read_i2c_block_data_or_emulated" title="Permalink to this definition">¶</a></dt>
<dd><p>read block or emulate</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*client</span></code></dt><dd><p>Handle to slave device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">command</span></code></dt><dd><p>Byte interpreted by slave</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">length</span></code></dt><dd><p>Size of data block; SMBus allows at most I2C_SMBUS_BLOCK_MAX bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*values</span></code></dt><dd><p>Byte array into which data will be read; big enough to hold
the data returned by the slave.  SMBus allows at most
I2C_SMBUS_BLOCK_MAX bytes.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “block read” protocol if supported by the adapter.
If block read is not supported, it emulates it using either word or byte
read protocols depending on availability.</p>
<p>The addresses of the I2C slave device that are accessed with this function
must be mapped to a linear region, so that a block read will have the same
effect as a byte read. Before using this function you must double-check
if the I2C slave does support exchanging a block transfer with a byte
transfer.</p>
</div>
<dl class="function">
<dt id="c.i2c_new_smbus_alert_device">
struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> * <code class="sig-name descname">i2c_new_smbus_alert_device</code><span class="sig-paren">(</span>struct i2c_adapter<em> *adapter</em>, struct i2c_smbus_alert_setup<em> *setup</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_new_smbus_alert_device" title="Permalink to this definition">¶</a></dt>
<dd><p>get ara client for SMBus alert support</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*adapter</span></code></dt><dd><p>the target adapter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_smbus_alert_setup</span> <span class="pre">*setup</span></code></dt><dd><p>setup data for the SMBus alert handler</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Setup handling of the SMBus alert protocol on a given I2C bus segment.</p>
<p>Handling can be done either through our IRQ handler, or by the
adapter (from its handler, periodic polling, or whatever).</p>
<p>This returns the ara client, which should be saved for later use with
i2c_handle_smbus_alert() and ultimately <a class="reference internal" href="#c.i2c_unregister_device" title="i2c_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_unregister_device()</span></code></a>; or an
ERRPTR to indicate an error.</p>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/i2c.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/i2c.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>