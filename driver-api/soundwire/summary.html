
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>SoundWire Subsystem Summary &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Audio Stream in SoundWire" href="stream.html" />
    <link rel="prev" title="SoundWire Documentation" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="soundwire-subsystem-summary">
<h1>SoundWire Subsystem Summary<a class="headerlink" href="#soundwire-subsystem-summary" title="Permalink to this headline">¶</a></h1>
<p>SoundWire is a new interface ratified in 2015 by the MIPI Alliance.
SoundWire is used for transporting data typically related to audio
functions. SoundWire interface is optimized to integrate audio devices in
mobile or mobile inspired systems.</p>
<p>SoundWire is a 2-pin multi-drop interface with data and clock line. It
facilitates development of low cost, efficient, high performance systems.
Broad level key features of SoundWire interface include:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Transporting all of payload data channels, control information, and setup
commands over a single two-pin interface.</p></li>
<li><p>Lower clock frequency, and hence lower power consumption, by use of DDR
(Dual Data Rate) data transmission.</p></li>
<li><p>Clock scaling and optional multiple data lanes to give wide flexibility
in data rate to match system requirements.</p></li>
<li><p>Device status monitoring, including interrupt-style alerts to the Master.</p></li>
</ol>
</div></blockquote>
<p>The SoundWire protocol supports up to eleven Slave interfaces. All the
interfaces share the common Bus containing data and clock line. Each of the
Slaves can support up to 14 Data Ports. 13 Data Ports are dedicated to audio
transport. Data Port0 is dedicated to transport of Bulk control information,
each of the audio Data Ports (1..14) can support up to 8 Channels in
transmit or receiving mode (typically fixed direction but configurable
direction is enabled by the specification).  Bandwidth restrictions to
~19.2..24.576Mbits/s don’t however allow for 11*13*8 channels to be
transmitted simultaneously.</p>
<p>Below figure shows an example of connectivity between a SoundWire Master and
two Slave devices.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+---------------+                                       +---------------+
|               |                       Clock Signal    |               |
|    Master     |-------+-------------------------------|    Slave      |
|   Interface   |       |               Data Signal     |  Interface 1  |
|               |-------|-------+-----------------------|               |
+---------------+       |       |                       +---------------+
                        |       |
                        |       |
                        |       |
                     +--+-------+--+
                     |             |
                     |   Slave     |
                     | Interface 2 |
                     |             |
                     +-------------+
</pre></div>
</div>
<section id="terminology">
<h2>Terminology<a class="headerlink" href="#terminology" title="Permalink to this headline">¶</a></h2>
<p>The MIPI SoundWire specification uses the term ‘device’ to refer to a Master
or Slave interface, which of course can be confusing. In this summary and
code we use the term interface only to refer to the hardware. We follow the
Linux device model by mapping each Slave interface connected on the bus as a
device managed by a specific driver. The Linux SoundWire subsystem provides
a framework to implement a SoundWire Slave driver with an API allowing
3rd-party vendors to enable implementation-defined functionality while
common setup/configuration tasks are handled by the bus.</p>
<p>Bus:
Implements SoundWire Linux Bus which handles the SoundWire protocol.
Programs all the MIPI-defined Slave registers. Represents a SoundWire
Master. Multiple instances of Bus may be present in a system.</p>
<p>Slave:
Registers as SoundWire Slave device (Linux Device). Multiple Slave devices
can register to a Bus instance.</p>
<p>Slave driver:
Driver controlling the Slave device. MIPI-specified registers are controlled
directly by the Bus (and transmitted through the Master driver/interface).
Any implementation-defined Slave register is controlled by Slave driver. In
practice, it is expected that the Slave driver relies on regmap and does not
request direct register access.</p>
</section>
<section id="programming-interfaces-soundwire-master-interface-driver">
<h2>Programming interfaces (SoundWire Master interface Driver)<a class="headerlink" href="#programming-interfaces-soundwire-master-interface-driver" title="Permalink to this headline">¶</a></h2>
<p>SoundWire Bus supports programming interfaces for the SoundWire Master
implementation and SoundWire Slave devices. All the code uses the “sdw”
prefix commonly used by SoC designers and 3rd party vendors.</p>
<p>Each of the SoundWire Master interfaces needs to be registered to the Bus.
Bus implements API to read standard Master MIPI properties and also provides
callback in Master ops for Master driver to implement its own functions that
provides capabilities information. DT support is not implemented at this
time but should be trivial to add since capabilities are enabled with the
<code class="docutils literal notranslate"><span class="pre">device_property_</span></code> API.</p>
<p>The Master interface along with the Master interface capabilities are
registered based on board file, DT or ACPI.</p>
<p>Following is the Bus API to register the SoundWire Bus:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">sdw_bus_master_add</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sdw_bus</span><span class="w"> </span><span class="o">*</span><span class="n">bus</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">struct</span> <span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">struct</span> <span class="nc">fwnode_handle</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">sdw_master_device_add</span><span class="p">(</span><span class="n">bus</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="n">fwnode</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Check ACPI for Slave devices */</span><span class="w"></span>
<span class="w">        </span><span class="n">sdw_acpi_find_slaves</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Check DT for Slave devices */</span><span class="w"></span>
<span class="w">        </span><span class="n">sdw_of_find_slaves</span><span class="p">(</span><span class="n">bus</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This will initialize sdw_bus object for Master device. “sdw_master_ops” and
“sdw_master_port_ops” callback functions are provided to the Bus.</p>
<p>“sdw_master_ops” is used by Bus to control the Bus in the hardware specific
way. It includes Bus control functions such as sending the SoundWire
read/write messages on Bus, setting up clock frequency &amp; Stream
Synchronization Point (SSP). The “sdw_master_ops” structure abstracts the
hardware details of the Master from the Bus.</p>
<p>“sdw_master_port_ops” is used by Bus to setup the Port parameters of the
Master interface Port. Master interface Port register map is not defined by
MIPI specification, so Bus calls the “sdw_master_port_ops” callback
function to do Port operations like “Port Prepare”, “Port Transport params
set”, “Port enable and disable”. The implementation of the Master driver can
then perform hardware-specific configurations.</p>
</section>
<section id="programming-interfaces-soundwire-slave-driver">
<h2>Programming interfaces (SoundWire Slave Driver)<a class="headerlink" href="#programming-interfaces-soundwire-slave-driver" title="Permalink to this headline">¶</a></h2>
<p>The MIPI specification requires each Slave interface to expose a unique
48-bit identifier, stored in 6 read-only dev_id registers. This dev_id
identifier contains vendor and part information, as well as a field enabling
to differentiate between identical components. An additional class field is
currently unused. Slave driver is written for a specific vendor and part
identifier, Bus enumerates the Slave device based on these two ids.
Slave device and driver match is done based on these two ids . Probe
of the Slave driver is called by Bus on successful match between device and
driver id. A parent/child relationship is enforced between Master and Slave
devices (the logical representation is aligned with the physical
connectivity).</p>
<p>The information on Master/Slave dependencies is stored in platform data,
board-file, ACPI or DT. The MIPI Software specification defines additional
link_id parameters for controllers that have multiple Master interfaces. The
dev_id registers are only unique in the scope of a link, and the link_id
unique in the scope of a controller. Both dev_id and link_id are not
necessarily unique at the system level but the parent/child information is
used to avoid ambiguity.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sdw_device_id</span><span class="w"> </span><span class="n">slave_id</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">SDW_SLAVE_ENTRY</span><span class="p">(</span><span class="mh">0x025d</span><span class="p">,</span><span class="w"> </span><span class="mh">0x700</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">{},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">sdw</span><span class="p">,</span><span class="w"> </span><span class="n">slave_id</span><span class="p">);</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sdw_driver</span><span class="w"> </span><span class="n">slave_sdw_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                   </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;slave_xxx&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="p">.</span><span class="n">pm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slave_runtime_pm</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave_sdw_probe</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave_sdw_remove</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">slave_slave_ops</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">id_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave_id</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>For capabilities, Bus implements API to read standard Slave MIPI properties
and also provides callback in Slave ops for Slave driver to implement own
function that provides capabilities information. Bus needs to know a set of
Slave capabilities to program Slave registers and to control the Bus
reconfigurations.</p>
</section>
<section id="future-enhancements-to-be-done">
<h2>Future enhancements to be done<a class="headerlink" href="#future-enhancements-to-be-done" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ol class="arabic simple">
<li><p>Bulk Register Access (BRA) transfers.</p></li>
<li><p>Multiple data lane support.</p></li>
</ol>
</div></blockquote>
</section>
<section id="links">
<h2>Links<a class="headerlink" href="#links" title="Permalink to this headline">¶</a></h2>
<p>SoundWire MIPI specification 1.1 is available at:
<a class="reference external" href="https://members.mipi.org/wg/All-Members/document/70290">https://members.mipi.org/wg/All-Members/document/70290</a></p>
<p>SoundWire MIPI DisCo (Discovery and Configuration) specification is
available at:
<a class="reference external" href="https://www.mipi.org/specifications/mipi-disco-soundwire">https://www.mipi.org/specifications/mipi-disco-soundwire</a></p>
<p>(publicly accessible with registration or directly accessible to MIPI
members)</p>
<p>MIPI Alliance Manufacturer ID Page: mid.mipi.org</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">SoundWire Subsystem Summary</a><ul>
<li><a class="reference internal" href="#terminology">Terminology</a></li>
<li><a class="reference internal" href="#programming-interfaces-soundwire-master-interface-driver">Programming interfaces (SoundWire Master interface Driver)</a></li>
<li><a class="reference internal" href="#programming-interfaces-soundwire-slave-driver">Programming interfaces (SoundWire Slave Driver)</a></li>
<li><a class="reference internal" href="#future-enhancements-to-be-done">Future enhancements to be done</a></li>
<li><a class="reference internal" href="#links">Links</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/soundwire/summary.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/soundwire/summary.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>