
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>FPGA Manager &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="FPGA Bridge" href="fpga-bridge.html" />
    <link rel="prev" title="Introduction" href="intro.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="fpga-manager">
<h1>FPGA Manager<a class="headerlink" href="#fpga-manager" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The FPGA manager core exports a set of functions for programming an FPGA with
an image.  The API is manufacturer agnostic.  All manufacturer specifics are
hidden away in a low level driver which registers a set of ops with the core.
The FPGA image data itself is very manufacturer specific, but for our purposes
it’s just binary data.  The FPGA manager core won’t parse it.</p>
<p>The FPGA image to be programmed can be in a scatter gather list, a single
contiguous buffer, or a firmware file.  Because allocating contiguous kernel
memory for the buffer should be avoided, users are encouraged to use a scatter
gather list instead if possible.</p>
<p>The particulars for programming the image are presented in a structure (<a class="reference internal" href="fpga-programming.html#c.fpga_image_info" title="fpga_image_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">fpga_image_info</span></code></a>).  This struct contains parameters such as pointers to the
FPGA image as well as image-specific particulars such as whether the image was
built for full or partial reconfiguration.</p>
</section>
<section id="how-to-support-a-new-fpga-device">
<h2>How to support a new FPGA device<a class="headerlink" href="#how-to-support-a-new-fpga-device" title="Permalink to this headline">¶</a></h2>
<p>To add another FPGA manager, write a driver that implements a set of ops.  The
probe function calls <a class="reference internal" href="#c.fpga_mgr_register" title="fpga_mgr_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register()</span></code></a> or <a class="reference internal" href="#c.fpga_mgr_register_full" title="fpga_mgr_register_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register_full()</span></code></a>, such as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct fpga_manager_ops socfpga_fpga_ops = {
        .write_init = socfpga_fpga_ops_configure_init,
        .write = socfpga_fpga_ops_configure_write,
        .write_complete = socfpga_fpga_ops_configure_complete,
        .state = socfpga_fpga_ops_state,
};

static int socfpga_fpga_probe(struct platform_device *pdev)
{
        struct device *dev = &amp;pdev-&gt;dev;
        struct socfpga_fpga_priv *priv;
        struct fpga_manager *mgr;
        int ret;

        priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
        if (!priv)
                return -ENOMEM;

        /*
         * do ioremaps, get interrupts, etc. and save
         * them in priv
         */

        mgr = fpga_mgr_register(dev, &quot;Altera SOCFPGA FPGA Manager&quot;,
                                &amp;socfpga_fpga_ops, priv);
        if (IS_ERR(mgr))
                return PTR_ERR(mgr);

        platform_set_drvdata(pdev, mgr);

        return 0;
}

static int socfpga_fpga_remove(struct platform_device *pdev)
{
        struct fpga_manager *mgr = platform_get_drvdata(pdev);

        fpga_mgr_unregister(mgr);

        return 0;
}
</pre></div>
</div>
<p>Alternatively, the probe function could call one of the resource managed
register functions, <a class="reference internal" href="#c.devm_fpga_mgr_register" title="devm_fpga_mgr_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_fpga_mgr_register()</span></code></a> or <a class="reference internal" href="#c.devm_fpga_mgr_register_full" title="devm_fpga_mgr_register_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_fpga_mgr_register_full()</span></code></a>.
When these functions are used, the parameter syntax is the same, but the call
to <a class="reference internal" href="#c.fpga_mgr_unregister" title="fpga_mgr_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_unregister()</span></code></a> should be removed. In the above example, the
socfpga_fpga_remove() function would not be required.</p>
<p>The ops will implement whatever device specific register writes are needed to
do the programming sequence for this particular FPGA.  These ops return 0 for
success or negative error codes otherwise.</p>
<dl class="simple">
<dt>The programming sequence is::</dt><dd><ol class="arabic simple">
<li><p>.parse_header (optional, may be called once or multiple times)</p></li>
<li><p>.write_init</p></li>
<li><p>.write or .write_sg (may be called once or multiple times)</p></li>
<li><p>.write_complete</p></li>
</ol>
</dd>
</dl>
<p>The .parse_header function will set header_size and data_size to
<a class="reference internal" href="fpga-programming.html#c.fpga_image_info" title="fpga_image_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fpga_image_info</span></code></a>. Before parse_header call, header_size is initialized
with initial_header_size. If flag skip_header of fpga_manager_ops is true,
.write function will get image buffer starting at header_size offset from the
beginning. If data_size is set, .write function will get data_size bytes of
the image buffer, otherwise .write will get data up to the end of image buffer.
This will not affect .write_sg, .write_sg will still get whole image in
sg_table form. If FPGA image is already mapped as a single contiguous buffer,
whole buffer will be passed into .parse_header. If image is in scatter-gather
form, core code will buffer up at least .initial_header_size before the first
call of .parse_header, if it is not enough, .parse_header should set desired
size into info-&gt;header_size and return -EAGAIN, then it will be called again
with greater part of image buffer on the input.</p>
<p>The .write_init function will prepare the FPGA to receive the image data. The
buffer passed into .write_init will be at least info-&gt;header_size bytes long;
if the whole bitstream is not immediately available then the core code will
buffer up at least this much before starting.</p>
<p>The .write function writes a buffer to the FPGA. The buffer may be contain the
whole FPGA image or may be a smaller chunk of an FPGA image.  In the latter
case, this function is called multiple times for successive chunks. This interface
is suitable for drivers which use PIO.</p>
<p>The .write_sg version behaves the same as .write except the input is a sg_table
scatter list. This interface is suitable for drivers which use DMA.</p>
<p>The .write_complete function is called after all the image has been written
to put the FPGA into operating mode.</p>
<p>The ops include a .state function which will determine the state the FPGA is in
and return a code of type <a class="reference internal" href="#c.fpga_mgr_states" title="fpga_mgr_states"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fpga_mgr_states</span></code></a>.  It doesn’t result in a change
in state.</p>
</section>
<section id="api-for-implementing-a-new-fpga-manager-driver">
<h2>API for implementing a new FPGA Manager driver<a class="headerlink" href="#api-for-implementing-a-new-fpga-manager-driver" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fpga_mgr_states</span></code> -  Values for <code class="docutils literal notranslate"><span class="pre">fpga_manager-&gt;state</span></code>.</p></li>
<li><p><a class="reference internal" href="#c.fpga_manager" title="fpga_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fpga_manager</span></code></a> -  the FPGA manager struct</p></li>
<li><p><a class="reference internal" href="#c.fpga_manager_ops" title="fpga_manager_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fpga_manager_ops</span></code></a> -  Low level FPGA manager driver ops</p></li>
<li><p><a class="reference internal" href="#c.fpga_manager_info" title="fpga_manager_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fpga_manager_info</span></code></a> -  Parameter structure for <a class="reference internal" href="#c.fpga_mgr_register_full" title="fpga_mgr_register_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register_full()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.fpga_mgr_register_full" title="fpga_mgr_register_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register_full()</span></code></a> -  Create and register an FPGA manager using the
fpga_mgr_info structure to provide the full flexibility of options</p></li>
<li><p><a class="reference internal" href="#c.fpga_mgr_register" title="fpga_mgr_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register()</span></code></a> -  Create and register an FPGA manager using standard
arguments</p></li>
<li><p><a class="reference internal" href="#c.devm_fpga_mgr_register_full" title="devm_fpga_mgr_register_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_fpga_mgr_register_full()</span></code></a> -  Resource managed version of
<a class="reference internal" href="#c.fpga_mgr_register_full" title="fpga_mgr_register_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register_full()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.devm_fpga_mgr_register" title="devm_fpga_mgr_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_fpga_mgr_register()</span></code></a> -  Resource managed version of <a class="reference internal" href="#c.fpga_mgr_register" title="fpga_mgr_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.fpga_mgr_unregister" title="fpga_mgr_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_unregister()</span></code></a> -  Unregister an FPGA manager</p></li>
</ul>
<dl class="type">
<dt id="c.fpga_mgr_states">
enum <code class="sig-name descname">fpga_mgr_states</code><a class="headerlink" href="#c.fpga_mgr_states" title="Permalink to this definition">¶</a></dt>
<dd><p>fpga framework states</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_UNKNOWN</span></code></dt><dd><p>can’t determine state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_POWER_OFF</span></code></dt><dd><p>FPGA power is off</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_POWER_UP</span></code></dt><dd><p>FPGA reports power is up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_RESET</span></code></dt><dd><p>FPGA in reset state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_FIRMWARE_REQ</span></code></dt><dd><p>firmware request in progress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_FIRMWARE_REQ_ERR</span></code></dt><dd><p>firmware request failed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_PARSE_HEADER</span></code></dt><dd><p>parse FPGA image header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_PARSE_HEADER_ERR</span></code></dt><dd><p>Error during PARSE_HEADER stage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_WRITE_INIT</span></code></dt><dd><p>preparing FPGA for programming</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_WRITE_INIT_ERR</span></code></dt><dd><p>Error during WRITE_INIT stage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_WRITE</span></code></dt><dd><p>writing image to FPGA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_WRITE_ERR</span></code></dt><dd><p>Error while writing FPGA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_WRITE_COMPLETE</span></code></dt><dd><p>Doing post programming steps</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_WRITE_COMPLETE_ERR</span></code></dt><dd><p>Error during WRITE_COMPLETE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FPGA_MGR_STATE_OPERATING</span></code></dt><dd><p>FPGA is programmed and operating</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.fpga_manager">
struct <code class="sig-name descname">fpga_manager</code><a class="headerlink" href="#c.fpga_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>fpga manager structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fpga_manager {
    const char *name;
    struct device dev;
    struct mutex ref_mutex;
    enum fpga_mgr_states state;
    struct fpga_compat_id *compat_id;
    const struct fpga_manager_ops *mops;
    void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of low level fpga manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>fpga manager device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ref_mutex</span></code></dt><dd><p>only allows one reference to fpga manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>state of fpga manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_id</span></code></dt><dd><p>FPGA manager id for compatibility check.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mops</span></code></dt><dd><p>pointer to struct of fpga manager ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>low level driver private date</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.fpga_manager_ops">
struct <code class="sig-name descname">fpga_manager_ops</code><a class="headerlink" href="#c.fpga_manager_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>ops for low level fpga manager drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fpga_manager_ops {
    size_t initial_header_size;
    bool skip_header;
    enum fpga_mgr_states (*state)(struct fpga_manager *mgr);
    u64 (*status)(struct fpga_manager *mgr);
    int (*parse_header)(struct fpga_manager *mgr,struct fpga_image_info *info, const char *buf, size_t count);
    int (*write_init)(struct fpga_manager *mgr,struct fpga_image_info *info, const char *buf, size_t count);
    int (*write)(struct fpga_manager *mgr, const char *buf, size_t count);
    int (*write_sg)(struct fpga_manager *mgr, struct sg_table *sgt);
    int (*write_complete)(struct fpga_manager *mgr, struct fpga_image_info *info);
    void (*fpga_remove)(struct fpga_manager *mgr);
    const struct attribute_group **groups;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">initial_header_size</span></code></dt><dd><p>minimum number of bytes that should be passed into
parse_header and write_init.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skip_header</span></code></dt><dd><p>bool flag to tell fpga-mgr core whether it should skip
info-&gt;header_size part at the beginning of the image when invoking
write callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>returns an enum value of the FPGA’s state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>returns status of the FPGA, including reconfiguration error code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parse_header</span></code></dt><dd><p>parse FPGA image header to set info-&gt;header_size and
info-&gt;data_size. In case the input buffer is not large enough, set
required size to info-&gt;header_size and return -EAGAIN.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_init</span></code></dt><dd><p>prepare the FPGA to receive configuration data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p>write count bytes of configuration data to the FPGA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_sg</span></code></dt><dd><p>write the scatter list of configuration data to the FPGA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_complete</span></code></dt><dd><p>set FPGA to operating state after writing is done</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fpga_remove</span></code></dt><dd><p>optional: Set FPGA into a specific state during driver remove</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">groups</span></code></dt><dd><p>optional attribute groups.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>fpga_manager_ops are the low level functions implemented by a specific
fpga manager driver.  The optional ones are tested for NULL before being
called, so leaving them out is fine.</p>
<dl class="type">
<dt id="c.fpga_manager_info">
struct <code class="sig-name descname">fpga_manager_info</code><a class="headerlink" href="#c.fpga_manager_info" title="Permalink to this definition">¶</a></dt>
<dd><p>collection of parameters for an FPGA Manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fpga_manager_info {
    const char *name;
    struct fpga_compat_id *compat_id;
    const struct fpga_manager_ops *mops;
    void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>fpga manager name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_id</span></code></dt><dd><p>FPGA manager id for compatibility check.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mops</span></code></dt><dd><p>pointer to structure of fpga manager ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>fpga manager private data</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>fpga_manager_info contains parameters for the register_full function.
These are separated into an info structure because they some are optional
others could be added to in the future. The info structure facilitates
maintaining a stable API.</p>
<dl class="function">
<dt id="c.fpga_mgr_register_full">
struct <a class="reference internal" href="#c.fpga_manager" title="fpga_manager">fpga_manager</a> * <code class="sig-name descname">fpga_mgr_register_full</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *parent</em>, const struct <a class="reference internal" href="#c.fpga_manager_info" title="fpga_manager_info">fpga_manager_info</a><em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fpga_mgr_register_full" title="Permalink to this definition">¶</a></dt>
<dd><p>create and register an FPGA Manager device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>fpga manager device from pdev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fpga_manager_info</span> <span class="pre">*info</span></code></dt><dd><p>parameters for fpga manager</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller of this function is responsible for calling <a class="reference internal" href="#c.fpga_mgr_unregister" title="fpga_mgr_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_unregister()</span></code></a>.
Using <a class="reference internal" href="#c.devm_fpga_mgr_register_full" title="devm_fpga_mgr_register_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_fpga_mgr_register_full()</span></code></a> instead is recommended.</p>
<p><strong>Return</strong></p>
<p>pointer to <a class="reference internal" href="#c.fpga_manager" title="fpga_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fpga_manager</span></code></a> pointer or ERR_PTR()</p>
</div>
<dl class="function">
<dt id="c.fpga_mgr_register">
struct <a class="reference internal" href="#c.fpga_manager" title="fpga_manager">fpga_manager</a> * <code class="sig-name descname">fpga_mgr_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *parent</em>, const char<em> *name</em>, const struct <a class="reference internal" href="#c.fpga_manager_ops" title="fpga_manager_ops">fpga_manager_ops</a><em> *mops</em>, void<em> *priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fpga_mgr_register" title="Permalink to this definition">¶</a></dt>
<dd><p>create and register an FPGA Manager device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>fpga manager device from pdev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>fpga manager name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fpga_manager_ops</span> <span class="pre">*mops</span></code></dt><dd><p>pointer to structure of fpga manager ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>fpga manager private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller of this function is responsible for calling <a class="reference internal" href="#c.fpga_mgr_unregister" title="fpga_mgr_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_unregister()</span></code></a>.
Using <a class="reference internal" href="#c.devm_fpga_mgr_register" title="devm_fpga_mgr_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_fpga_mgr_register()</span></code></a> instead is recommended. This simple
version of the register function should be sufficient for most users. The
<a class="reference internal" href="#c.fpga_mgr_register_full" title="fpga_mgr_register_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register_full()</span></code></a> function is available for users that need to pass
additional, optional parameters.</p>
<p><strong>Return</strong></p>
<p>pointer to <a class="reference internal" href="#c.fpga_manager" title="fpga_manager"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fpga_manager</span></code></a> pointer or ERR_PTR()</p>
</div>
<dl class="function">
<dt id="c.devm_fpga_mgr_register_full">
struct <a class="reference internal" href="#c.fpga_manager" title="fpga_manager">fpga_manager</a> * <code class="sig-name descname">devm_fpga_mgr_register_full</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *parent</em>, const struct <a class="reference internal" href="#c.fpga_manager_info" title="fpga_manager_info">fpga_manager_info</a><em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_fpga_mgr_register_full" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed variant of <a class="reference internal" href="#c.fpga_mgr_register" title="fpga_mgr_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>fpga manager device from pdev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fpga_manager_info</span> <span class="pre">*info</span></code></dt><dd><p>parameters for fpga manager</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>fpga manager pointer on success, negative error code otherwise.</p>
<p><strong>Description</strong></p>
<p>This is the devres variant of <a class="reference internal" href="#c.fpga_mgr_register_full" title="fpga_mgr_register_full"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register_full()</span></code></a> for which the unregister
function will be called automatically when the managing device is detached.</p>
</div>
<dl class="function">
<dt id="c.devm_fpga_mgr_register">
struct <a class="reference internal" href="#c.fpga_manager" title="fpga_manager">fpga_manager</a> * <code class="sig-name descname">devm_fpga_mgr_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *parent</em>, const char<em> *name</em>, const struct <a class="reference internal" href="#c.fpga_manager_ops" title="fpga_manager_ops">fpga_manager_ops</a><em> *mops</em>, void<em> *priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_fpga_mgr_register" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed variant of <a class="reference internal" href="#c.fpga_mgr_register" title="fpga_mgr_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>fpga manager device from pdev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>fpga manager name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fpga_manager_ops</span> <span class="pre">*mops</span></code></dt><dd><p>pointer to structure of fpga manager ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>fpga manager private data</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>fpga manager pointer on success, negative error code otherwise.</p>
<p><strong>Description</strong></p>
<p>This is the devres variant of <a class="reference internal" href="#c.fpga_mgr_register" title="fpga_mgr_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">fpga_mgr_register()</span></code></a> for which the
unregister function will be called automatically when the managing
device is detached.</p>
</div>
<dl class="function">
<dt id="c.fpga_mgr_unregister">
void <code class="sig-name descname">fpga_mgr_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.fpga_manager" title="fpga_manager">fpga_manager</a><em> *mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fpga_mgr_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an FPGA manager</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fpga_manager</span> <span class="pre">*mgr</span></code></dt><dd><p>fpga manager struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is intended for use in an FPGA manager driver’s remove function.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">FPGA Manager</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#how-to-support-a-new-fpga-device">How to support a new FPGA device</a></li>
<li><a class="reference internal" href="#api-for-implementing-a-new-fpga-manager-driver">API for implementing a new FPGA Manager driver</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/fpga/fpga-mgr.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/fpga/fpga-mgr.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>