
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Component Helper for Aggregate Drivers &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Message-based devices" href="message-based.html" />
    <link rel="prev" title="Device links" href="device_link.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="component-helper-for-aggregate-drivers">
<span id="component"></span><h1>Component Helper for Aggregate Drivers<a class="headerlink" href="#component-helper-for-aggregate-drivers" title="Permalink to this headline">¶</a></h1>
<p>The component helper allows drivers to collect a pile of sub-devices,
including their bound drivers, into an aggregate driver. Various subsystems
already provide functions to get hold of such components, e.g.
of_clk_get_by_name(). The component helper can be used when such a
subsystem-specific way to find a device is not available: The component
helper fills the niche of aggregate drivers for specific hardware, where
further standardization into a subsystem would not be practical. The common
example is when a logical device (e.g. a DRM display driver) is spread around
the SoC on various components (scanout engines, blending blocks, transcoders
for various outputs and so on).</p>
<p>The component helper also doesn’t solve runtime dependencies, e.g. for system
suspend and resume operations. See also <a class="reference internal" href="device_link.html#device-link"><span class="std std-ref">device links</span></a>.</p>
<p>Components are registered using <a class="reference internal" href="#c.component_add" title="component_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_add()</span></code></a> and unregistered with
<a class="reference internal" href="#c.component_del" title="component_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_del()</span></code></a>, usually from the driver’s probe and disconnect functions.</p>
<p>Aggregate drivers first assemble a component match list of what they need
using <a class="reference internal" href="#c.component_match_add" title="component_match_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add()</span></code></a>. This is then registered as an aggregate driver
using <a class="reference internal" href="#c.component_master_add_with_match" title="component_master_add_with_match"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_master_add_with_match()</span></code></a>, and unregistered using
<a class="reference internal" href="#c.component_master_del" title="component_master_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_master_del()</span></code></a>.</p>
<section id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.component_ops">
struct <code class="sig-name descname">component_ops</code><a class="headerlink" href="#c.component_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>callbacks for component drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct component_ops {
    int (*bind)(struct device *comp, struct device *master, void *master_data);
    void (*unbind)(struct device *comp, struct device *master, void *master_data);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bind</span></code></dt><dd><p>Called through <a class="reference internal" href="#c.component_bind_all" title="component_bind_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_bind_all()</span></code></a> when the aggregate driver is
ready to bind the overall driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unbind</span></code></dt><dd><p>Called through <a class="reference internal" href="#c.component_unbind_all" title="component_unbind_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_unbind_all()</span></code></a> when the aggregate driver is
ready to bind the overall driver, or when <a class="reference internal" href="#c.component_bind_all" title="component_bind_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_bind_all()</span></code></a> fails
part-ways through and needs to unbind some already bound components.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Components are registered with <a class="reference internal" href="#c.component_add" title="component_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_add()</span></code></a> and unregistered with
<a class="reference internal" href="#c.component_del" title="component_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_del()</span></code></a>.</p>
<dl class="type">
<dt id="c.component_master_ops">
struct <code class="sig-name descname">component_master_ops</code><a class="headerlink" href="#c.component_master_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>callback for the aggregate driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct component_master_ops {
    int (*bind)(struct device *master);
    void (*unbind)(struct device *master);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">bind</span></code></dt><dd><p>Called when all components or the aggregate driver, as specified in
the match list passed to <a class="reference internal" href="#c.component_master_add_with_match" title="component_master_add_with_match"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_master_add_with_match()</span></code></a>, are
ready. Usually there are 3 steps to bind an aggregate driver:</p>
<ol class="arabic simple">
<li><p>Allocate a structure for the aggregate driver.</p></li>
<li><p>Bind all components to the aggregate driver by calling
<a class="reference internal" href="#c.component_bind_all" title="component_bind_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_bind_all()</span></code></a> with the aggregate driver structure as opaque
pointer data.</p></li>
<li><p>Register the aggregate driver with the subsystem to publish its
interfaces.</p></li>
</ol>
<p>Note that the lifetime of the aggregate driver does not align with
any of the underlying <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> instances. Therefore devm cannot
be used and all resources acquired or allocated in this callback must
be explicitly released in the <strong>unbind</strong> callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unbind</span></code></dt><dd><p>Called when either the aggregate driver, using
<a class="reference internal" href="#c.component_master_del" title="component_master_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_master_del()</span></code></a>, or one of its components, using
<a class="reference internal" href="#c.component_del" title="component_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_del()</span></code></a>, is unregistered.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Aggregate drivers are registered with <a class="reference internal" href="#c.component_master_add_with_match" title="component_master_add_with_match"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_master_add_with_match()</span></code></a> and
unregistered with <a class="reference internal" href="#c.component_master_del" title="component_master_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_master_del()</span></code></a>.</p>
<dl class="function">
<dt id="c.component_match_add">
void <code class="sig-name descname">component_match_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *parent</em>, struct component_match<em> **matchptr</em>, int (<em>*compare</em>)(struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *, void *), void<em> *compare_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_match_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a component match entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>device with the aggregate driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">component_match</span> <span class="pre">**matchptr</span></code></dt><dd><p>pointer to the list of component matches</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*compare)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>compare function to match against all components</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*compare_data</span></code></dt><dd><p>opaque pointer passed to the <strong>compare</strong> function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a new component match to the list stored in <strong>matchptr</strong>, which the <strong>parent</strong>
aggregate driver needs to function. The list of component matches pointed to
by <strong>matchptr</strong> must be initialized to NULL before adding the first match. This
only matches against components added with <a class="reference internal" href="#c.component_add" title="component_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_add()</span></code></a>.</p>
<p>The allocated match list in <strong>matchptr</strong> is automatically released using devm
actions.</p>
<p>See also <a class="reference internal" href="#c.component_match_add_release" title="component_match_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add_release()</span></code></a> and <a class="reference internal" href="#c.component_match_add_typed" title="component_match_add_typed"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add_typed()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.component_compare_of">
int <code class="sig-name descname">component_compare_of</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_compare_of" title="Permalink to this definition">¶</a></dt>
<dd><p>A common component compare function for of_node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>component device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p><strong>compare_data</strong> from <a class="reference internal" href="#c.component_match_add_release" title="component_match_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add_release()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A common compare function when compare_data is device of_node. e.g.
component_match_add_release(masterdev, <code class="xref c c-type docutils literal notranslate"><span class="pre">match</span></code>, component_release_of,
component_compare_of, component_dev_of_node)</p>
</div>
<dl class="function">
<dt id="c.component_release_of">
void <code class="sig-name descname">component_release_of</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_release_of" title="Permalink to this definition">¶</a></dt>
<dd><p>A common component release function for of_node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>component device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p><strong>compare_data</strong> from <a class="reference internal" href="#c.component_match_add_release" title="component_match_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add_release()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>About the example, Please see <a class="reference internal" href="#c.component_compare_of" title="component_compare_of"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_compare_of()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.component_compare_dev">
int <code class="sig-name descname">component_compare_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_compare_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>A common component compare function for dev</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>component device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p><strong>compare_data</strong> from <a class="reference internal" href="#c.component_match_add_release" title="component_match_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add_release()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A common compare function when compare_data is struce device. e.g.
component_match_add(masterdev, <code class="xref c c-type docutils literal notranslate"><span class="pre">match</span></code>, component_compare_dev, component_dev)</p>
</div>
<dl class="function">
<dt id="c.component_compare_dev_name">
int <code class="sig-name descname">component_compare_dev_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_compare_dev_name" title="Permalink to this definition">¶</a></dt>
<dd><p>A common component compare function for device name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>component device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p><strong>compare_data</strong> from <a class="reference internal" href="#c.component_match_add_release" title="component_match_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add_release()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A common compare function when compare_data is device name string. e.g.
component_match_add(masterdev, <code class="xref c c-type docutils literal notranslate"><span class="pre">match</span></code>, component_compare_dev_name,
“component_dev_name”)</p>
</div>
<dl class="function">
<dt id="c.component_match_add_release">
void <code class="sig-name descname">component_match_add_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *parent</em>, struct component_match<em> **matchptr</em>, void (<em>*release</em>)(struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *, void *), int (*compare)(struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *, void *), void<em> *compare_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_match_add_release" title="Permalink to this definition">¶</a></dt>
<dd><p>add a component match entry with release callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device of the aggregate driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">component_match</span> <span class="pre">**matchptr</span></code></dt><dd><p>pointer to the list of component matches</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*release)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>release function for <strong>compare_data</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*compare)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>compare function to match against all components</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*compare_data</span></code></dt><dd><p>opaque pointer passed to the <strong>compare</strong> function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a new component match to the list stored in <strong>matchptr</strong>, which the
aggregate driver needs to function. The list of component matches pointed to
by <strong>matchptr</strong> must be initialized to NULL before adding the first match. This
only matches against components added with <a class="reference internal" href="#c.component_add" title="component_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_add()</span></code></a>.</p>
<p>The allocated match list in <strong>matchptr</strong> is automatically released using devm
actions, where upon <strong>release</strong> will be called to free any references held by
<strong>compare_data</strong>, e.g. when <strong>compare_data</strong> is a <code class="xref c c-type docutils literal notranslate"><span class="pre">device_node</span></code> that must be
released with <a class="reference internal" href="../devicetree/kernel-api.html#c.of_node_put" title="of_node_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">of_node_put()</span></code></a>.</p>
<p>See also <a class="reference internal" href="#c.component_match_add" title="component_match_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add()</span></code></a> and <a class="reference internal" href="#c.component_match_add_typed" title="component_match_add_typed"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add_typed()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.component_match_add_typed">
void <code class="sig-name descname">component_match_add_typed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *parent</em>, struct component_match<em> **matchptr</em>, int (<em>*compare_typed</em>)(struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *, int, void *), void<em> *compare_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_match_add_typed" title="Permalink to this definition">¶</a></dt>
<dd><p>add a component match entry for a typed component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device of the aggregate driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">component_match</span> <span class="pre">**matchptr</span></code></dt><dd><p>pointer to the list of component matches</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*compare_typed)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">int,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>compare function to match against all typed components</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*compare_data</span></code></dt><dd><p>opaque pointer passed to the <strong>compare</strong> function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a new component match to the list stored in <strong>matchptr</strong>, which the
aggregate driver needs to function. The list of component matches pointed to
by <strong>matchptr</strong> must be initialized to NULL before adding the first match. This
only matches against components added with <a class="reference internal" href="#c.component_add_typed" title="component_add_typed"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_add_typed()</span></code></a>.</p>
<p>The allocated match list in <strong>matchptr</strong> is automatically released using devm
actions.</p>
<p>See also <a class="reference internal" href="#c.component_match_add_release" title="component_match_add_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add_release()</span></code></a> and <a class="reference internal" href="#c.component_match_add_typed" title="component_match_add_typed"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add_typed()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.component_master_add_with_match">
int <code class="sig-name descname">component_master_add_with_match</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *parent</em>, const struct <a class="reference internal" href="#c.component_master_ops" title="component_master_ops">component_master_ops</a><em> *ops</em>, struct component_match<em> *match</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_master_add_with_match" title="Permalink to this definition">¶</a></dt>
<dd><p>register an aggregate driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device of the aggregate driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">component_master_ops</span> <span class="pre">*ops</span></code></dt><dd><p>callbacks for the aggregate driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">component_match</span> <span class="pre">*match</span></code></dt><dd><p>component match list for the aggregate driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a new aggregate driver consisting of the components added to <strong>match</strong>
by calling one of the <a class="reference internal" href="#c.component_match_add" title="component_match_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add()</span></code></a> functions. Once all components in
<strong>match</strong> are available, it will be assembled by calling
<a class="reference internal" href="#c.component_master_ops" title="component_master_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">component_master_ops.bind</span></code></a> from <strong>ops</strong>. Must be unregistered by calling
<a class="reference internal" href="#c.component_master_del" title="component_master_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_master_del()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.component_master_del">
void <code class="sig-name descname">component_master_del</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *parent</em>, const struct <a class="reference internal" href="#c.component_master_ops" title="component_master_ops">component_master_ops</a><em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_master_del" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an aggregate driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device of the aggregate driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">component_master_ops</span> <span class="pre">*ops</span></code></dt><dd><p>callbacks for the aggregate driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters an aggregate driver registered with
<a class="reference internal" href="#c.component_master_add_with_match" title="component_master_add_with_match"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_master_add_with_match()</span></code></a>. If necessary the aggregate driver is first
disassembled by calling <a class="reference internal" href="#c.component_master_ops" title="component_master_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">component_master_ops.unbind</span></code></a> from <strong>ops</strong>.</p>
</div>
<dl class="function">
<dt id="c.component_unbind_all">
void <code class="sig-name descname">component_unbind_all</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *parent</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_unbind_all" title="Permalink to this definition">¶</a></dt>
<dd><p>unbind all components of an aggregate driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device of the aggregate driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>opaque pointer, passed to all components</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unbinds all components of the aggregate device by passing <strong>data</strong> to their
<a class="reference internal" href="#c.component_ops" title="component_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">component_ops.unbind</span></code></a> functions. Should be called from
<a class="reference internal" href="#c.component_master_ops" title="component_master_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">component_master_ops.unbind</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.component_bind_all">
int <code class="sig-name descname">component_bind_all</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *parent</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_bind_all" title="Permalink to this definition">¶</a></dt>
<dd><p>bind all components of an aggregate driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent device of the aggregate driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>opaque pointer, passed to all components</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Binds all components of the aggregate <strong>dev</strong> by passing <strong>data</strong> to their
<a class="reference internal" href="#c.component_ops" title="component_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">component_ops.bind</span></code></a> functions. Should be called from
<a class="reference internal" href="#c.component_master_ops" title="component_master_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">component_master_ops.bind</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.component_add_typed">
int <code class="sig-name descname">component_add_typed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct <a class="reference internal" href="#c.component_ops" title="component_ops">component_ops</a><em> *ops</em>, int<em> subcomponent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_add_typed" title="Permalink to this definition">¶</a></dt>
<dd><p>register a component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>component device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">component_ops</span> <span class="pre">*ops</span></code></dt><dd><p>component callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">subcomponent</span></code></dt><dd><p>nonzero identifier for subcomponents</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a new component for <strong>dev</strong>. Functions in <strong>ops</strong> will be call when the
aggregate driver is ready to bind the overall driver by calling
<a class="reference internal" href="#c.component_bind_all" title="component_bind_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_bind_all()</span></code></a>. See also <a class="reference internal" href="#c.component_ops" title="component_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">component_ops</span></code></a>.</p>
<p><strong>subcomponent</strong> must be nonzero and is used to differentiate between multiple
components registerd on the same device <strong>dev</strong>. These components are match
using <a class="reference internal" href="#c.component_match_add_typed" title="component_match_add_typed"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_match_add_typed()</span></code></a>.</p>
<p>The component needs to be unregistered at driver unload/disconnect by
calling <a class="reference internal" href="#c.component_del" title="component_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_del()</span></code></a>.</p>
<p>See also <a class="reference internal" href="#c.component_add" title="component_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_add()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.component_add">
int <code class="sig-name descname">component_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct <a class="reference internal" href="#c.component_ops" title="component_ops">component_ops</a><em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_add" title="Permalink to this definition">¶</a></dt>
<dd><p>register a component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>component device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">component_ops</span> <span class="pre">*ops</span></code></dt><dd><p>component callbacks</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a new component for <strong>dev</strong>. Functions in <strong>ops</strong> will be called when the
aggregate driver is ready to bind the overall driver by calling
<a class="reference internal" href="#c.component_bind_all" title="component_bind_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_bind_all()</span></code></a>. See also <a class="reference internal" href="#c.component_ops" title="component_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">component_ops</span></code></a>.</p>
<p>The component needs to be unregistered at driver unload/disconnect by
calling <a class="reference internal" href="#c.component_del" title="component_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_del()</span></code></a>.</p>
<p>See also <a class="reference internal" href="#c.component_add_typed" title="component_add_typed"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_add_typed()</span></code></a> for a variant that allows multipled different
components on the same device.</p>
</div>
<dl class="function">
<dt id="c.component_del">
void <code class="sig-name descname">component_del</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct <a class="reference internal" href="#c.component_ops" title="component_ops">component_ops</a><em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.component_del" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>component device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">component_ops</span> <span class="pre">*ops</span></code></dt><dd><p>component callbacks</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister a component added with <a class="reference internal" href="#c.component_add" title="component_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">component_add()</span></code></a>. If the component is bound
into an aggregate driver, this will force the entire aggregate driver, including
all its components, to be unbound.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Component Helper for Aggregate Drivers</a><ul>
<li><a class="reference internal" href="#api">API</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/component.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/component.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>