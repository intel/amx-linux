
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>PPS - Pulse Per Second &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PTP hardware clock infrastructure for Linux" href="ptp.html" />
    <link rel="prev" title="PARPORT interface documentation" href="parport-lowlevel.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pps-pulse-per-second">
<h1>PPS - Pulse Per Second<a class="headerlink" href="#pps-pulse-per-second" title="Permalink to this headline">¶</a></h1>
<p>Copyright (C) 2007 Rodolfo Giometti &lt;<a class="reference external" href="mailto:giometti&#37;&#52;&#48;enneenne&#46;com">giometti<span>&#64;</span>enneenne<span>&#46;</span>com</a>&gt;</p>
<p>This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>LinuxPPS provides a programming interface (API) to define in the
system several PPS sources.</p>
<p>PPS means “pulse per second” and a PPS source is just a device which
provides a high precision signal each second so that an application
can use it to adjust system clock time.</p>
<p>A PPS source can be connected to a serial port (usually to the Data
Carrier Detect pin) or to a parallel port (ACK-pin) or to a special
CPU’s GPIOs (this is the common case in embedded systems) but in each
case when a new pulse arrives the system must apply to it a timestamp
and record it for userland.</p>
<p>Common use is the combination of the NTPD as userland program, with a
GPS receiver as PPS source, to obtain a wallclock-time with
sub-millisecond synchronisation to UTC.</p>
</section>
<section id="rfc-considerations">
<h2>RFC considerations<a class="headerlink" href="#rfc-considerations" title="Permalink to this headline">¶</a></h2>
<p>While implementing a PPS API as RFC 2783 defines and using an embedded
CPU GPIO-Pin as physical link to the signal, I encountered a deeper
problem:</p>
<blockquote>
<div><p>At startup it needs a file descriptor as argument for the function
time_pps_create().</p>
</div></blockquote>
<p>This implies that the source has a /dev/… entry. This assumption is
OK for the serial and parallel port, where you can do something
useful besides(!) the gathering of timestamps as it is the central
task for a PPS API. But this assumption does not work for a single
purpose GPIO line. In this case even basic file-related functionality
(like read() and write()) makes no sense at all and should not be a
precondition for the use of a PPS API.</p>
<p>The problem can be simply solved if you consider that a PPS source is
not always connected with a GPS data source.</p>
<p>So your programs should check if the GPS data source (the serial port
for instance) is a PPS source too, and if not they should provide the
possibility to open another device as PPS source.</p>
<p>In LinuxPPS the PPS sources are simply char devices usually mapped
into files /dev/pps0, /dev/pps1, etc.</p>
</section>
<section id="pps-with-usb-to-serial-devices">
<h2>PPS with USB to serial devices<a class="headerlink" href="#pps-with-usb-to-serial-devices" title="Permalink to this headline">¶</a></h2>
<p>It is possible to grab the PPS from an USB to serial device. However,
you should take into account the latencies and jitter introduced by
the USB stack. Users have reported clock instability around +-1ms when
synchronized with PPS through USB. With USB 2.0, jitter may decrease
down to the order of 125 microseconds.</p>
<p>This may be suitable for time server synchronization with NTP because
of its undersampling and algorithms.</p>
<p>If your device doesn’t report PPS, you can check that the feature is
supported by its driver. Most of the time, you only need to add a call
to usb_serial_handle_dcd_change after checking the DCD status (see
ch341 and pl2303 examples).</p>
</section>
<section id="coding-example">
<h2>Coding example<a class="headerlink" href="#coding-example" title="Permalink to this headline">¶</a></h2>
<p>To register a PPS source into the kernel you should define a struct
pps_source_info as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct pps_source_info pps_ktimer_info = {
        .name         = &quot;ktimer&quot;,
        .path         = &quot;&quot;,
        .mode         = PPS_CAPTUREASSERT | PPS_OFFSETASSERT |
                        PPS_ECHOASSERT |
                        PPS_CANWAIT | PPS_TSFMT_TSPEC,
        .echo         = pps_ktimer_echo,
        .owner        = THIS_MODULE,
};
</pre></div>
</div>
<p>and then calling the function pps_register_source() in your
initialization routine as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>source = pps_register_source(&amp;pps_ktimer_info,
                    PPS_CAPTUREASSERT | PPS_OFFSETASSERT);
</pre></div>
</div>
<p>The pps_register_source() prototype is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pps_register_source(struct pps_source_info *info, int default_params)
</pre></div>
</div>
<p>where “info” is a pointer to a structure that describes a particular
PPS source, “default_params” tells the system what the initial default
parameters for the device should be (it is obvious that these parameters
must be a subset of ones defined in the struct
pps_source_info which describe the capabilities of the driver).</p>
<p>Once you have registered a new PPS source into the system you can
signal an assert event (for example in the interrupt handler routine)
just using:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pps_event(source, &amp;ts, PPS_CAPTUREASSERT, ptr)
</pre></div>
</div>
<p>where “ts” is the event’s timestamp.</p>
<p>The same function may also run the defined echo function
(pps_ktimer_echo(), passing to it the “ptr” pointer) if the user
asked for that… etc..</p>
<p>Please see the file drivers/pps/clients/pps-ktimer.c for example code.</p>
</section>
<section id="sysfs-support">
<h2>SYSFS support<a class="headerlink" href="#sysfs-support" title="Permalink to this headline">¶</a></h2>
<p>If the SYSFS filesystem is enabled in the kernel it provides a new class:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ls /sys/class/pps/
pps0/  pps1/  pps2/
</pre></div>
</div>
<p>Every directory is the ID of a PPS sources defined in the system and
inside you find several files:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ls -F /sys/class/pps/pps0/
assert     dev        mode       path       subsystem@
clear      echo       name       power/     uevent
</pre></div>
</div>
<p>Inside each “assert” and “clear” file you can find the timestamp and a
sequence number:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat /sys/class/pps/pps0/assert
1170026870.983207967#8
</pre></div>
</div>
<p>Where before the “#” is the timestamp in seconds; after it is the
sequence number. Other files are:</p>
<blockquote>
<div><ul class="simple">
<li><p>echo: reports if the PPS source has an echo function or not;</p></li>
<li><p>mode: reports available PPS functioning modes;</p></li>
<li><p>name: reports the PPS source’s name;</p></li>
<li><p>path: reports the PPS source’s device path, that is the device the
PPS source is connected to (if it exists).</p></li>
</ul>
</div></blockquote>
</section>
<section id="testing-the-pps-support">
<h2>Testing the PPS support<a class="headerlink" href="#testing-the-pps-support" title="Permalink to this headline">¶</a></h2>
<p>In order to test the PPS support even without specific hardware you can use
the pps-ktimer driver (see the client subsection in the PPS configuration menu)
and the userland tools available in your distribution’s pps-tools package,
<a class="reference external" href="http://linuxpps.org">http://linuxpps.org</a> , or <a class="reference external" href="https://github.com/redlab-i/pps-tools">https://github.com/redlab-i/pps-tools</a>.</p>
<p>Once you have enabled the compilation of pps-ktimer just modprobe it (if
not statically compiled):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># modprobe pps-ktimer
</pre></div>
</div>
<p>and the run ppstest as follow:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./ppstest /dev/pps1
trying PPS source &quot;/dev/pps1&quot;
found PPS source &quot;/dev/pps1&quot;
ok, found 1 source(s), now start fetching data...
source 0 - assert 1186592699.388832443, sequence: 364 - clear  0.000000000, sequence: 0
source 0 - assert 1186592700.388931295, sequence: 365 - clear  0.000000000, sequence: 0
source 0 - assert 1186592701.389032765, sequence: 366 - clear  0.000000000, sequence: 0
</pre></div>
</div>
<p>Please note that to compile userland programs, you need the file timepps.h.
This is available in the pps-tools repository mentioned above.</p>
</section>
<section id="generators">
<h2>Generators<a class="headerlink" href="#generators" title="Permalink to this headline">¶</a></h2>
<p>Sometimes one needs to be able not only to catch PPS signals but to produce
them also. For example, running a distributed simulation, which requires
computers’ clock to be synchronized very tightly. One way to do this is to
invent some complicated hardware solutions but it may be neither necessary
nor affordable. The cheap way is to load a PPS generator on one of the
computers (master) and PPS clients on others (slaves), and use very simple
cables to deliver signals using parallel ports, for example.</p>
<p>Parallel port cable pinout:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pin     name    master      slave
1       STROBE    *------     *
2       D0        *     |     *
3       D1        *     |     *
4       D2        *     |     *
5       D3        *     |     *
6       D4        *     |     *
7       D5        *     |     *
8       D6        *     |     *
9       D7        *     |     *
10      ACK       *     ------*
11      BUSY      *           *
12      PE        *           *
13      SEL       *           *
14      AUTOFD    *           *
15      ERROR     *           *
16      INIT      *           *
17      SELIN     *           *
18-25   GND       *-----------*
</pre></div>
</div>
<p>Please note that parallel port interrupt occurs only on high-&gt;low transition,
so it is used for PPS assert edge. PPS clear edge can be determined only
using polling in the interrupt handler which actually can be done way more
precisely because interrupt handling delays can be quite big and random. So
current parport PPS generator implementation (pps_gen_parport module) is
geared towards using the clear edge for time synchronization.</p>
<p>Clear edge polling is done with disabled interrupts so it’s better to select
delay between assert and clear edge as small as possible to reduce system
latencies. But if it is too small slave won’t be able to capture clear edge
transition. The default of 30us should be good enough in most situations.
The delay can be selected using ‘delay’ pps_gen_parport module parameter.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">PPS - Pulse Per Second</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#rfc-considerations">RFC considerations</a></li>
<li><a class="reference internal" href="#pps-with-usb-to-serial-devices">PPS with USB to serial devices</a></li>
<li><a class="reference internal" href="#coding-example">Coding example</a></li>
<li><a class="reference internal" href="#sysfs-support">SYSFS support</a></li>
<li><a class="reference internal" href="#testing-the-pps-support">Testing the PPS support</a></li>
<li><a class="reference internal" href="#generators">Generators</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/pps.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/pps.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>