
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Error Detection And Correction (EDAC) Devices &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SCSI Interfaces Guide" href="scsi.html" />
    <link rel="prev" title="High Speed Synchronous Serial Interface (HSI)" href="hsi.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="error-detection-and-correction-edac-devices">
<h1>Error Detection And Correction (EDAC) Devices<a class="headerlink" href="#error-detection-and-correction-edac-devices" title="Permalink to this headline">¶</a></h1>
<section id="main-concepts-used-at-the-edac-subsystem">
<h2>Main Concepts used at the EDAC subsystem<a class="headerlink" href="#main-concepts-used-at-the-edac-subsystem" title="Permalink to this headline">¶</a></h2>
<p>There are several things to be aware of that aren’t at all obvious, like
<em>sockets, *socket sets</em>, <em>banks</em>, <em>rows</em>, <em>chip-select rows</em>, <em>channels</em>,
etc…</p>
<p>These are some of the many terms that are thrown about that don’t always
mean what people think they mean (Inconceivable!).  In the interest of
creating a common ground for discussion, terms and their definitions
will be established.</p>
<ul class="simple">
<li><p>Memory devices</p></li>
</ul>
<p>The individual DRAM chips on a memory stick.  These devices commonly
output 4 and 8 bits each (x4, x8). Grouping several of these in parallel
provides the number of bits that the memory controller expects:
typically 72 bits, in order to provide 64 bits + 8 bits of ECC data.</p>
<ul class="simple">
<li><p>Memory Stick</p></li>
</ul>
<p>A printed circuit board that aggregates multiple memory devices in
parallel.  In general, this is the Field Replaceable Unit (FRU) which
gets replaced, in the case of excessive errors. Most often it is also
called DIMM (Dual Inline Memory Module).</p>
<ul class="simple">
<li><p>Memory Socket</p></li>
</ul>
<p>A physical connector on the motherboard that accepts a single memory
stick. Also called as “slot” on several datasheets.</p>
<ul class="simple">
<li><p>Channel</p></li>
</ul>
<p>A memory controller channel, responsible to communicate with a group of
DIMMs. Each channel has its own independent control (command) and data
bus, and can be used independently or grouped with other channels.</p>
<ul class="simple">
<li><p>Branch</p></li>
</ul>
<p>It is typically the highest hierarchy on a Fully-Buffered DIMM memory
controller. Typically, it contains two channels. Two channels at the
same branch can be used in single mode or in lockstep mode. When
lockstep is enabled, the cacheline is doubled, but it generally brings
some performance penalty. Also, it is generally not possible to point to
just one memory stick when an error occurs, as the error correction code
is calculated using two DIMMs instead of one. Due to that, it is capable
of correcting more errors than on single mode.</p>
<ul class="simple">
<li><p>Single-channel</p></li>
</ul>
<p>The data accessed by the memory controller is contained into one dimm
only. E. g. if the data is 64 bits-wide, the data flows to the CPU using
one 64 bits parallel access. Typically used with SDR, DDR, DDR2 and DDR3
memories. FB-DIMM and RAMBUS use a different concept for channel, so
this concept doesn’t apply there.</p>
<ul class="simple">
<li><p>Double-channel</p></li>
</ul>
<p>The data size accessed by the memory controller is interlaced into two
dimms, accessed at the same time. E. g. if the DIMM is 64 bits-wide (72
bits with ECC), the data flows to the CPU using a 128 bits parallel
access.</p>
<ul class="simple">
<li><p>Chip-select row</p></li>
</ul>
<p>This is the name of the DRAM signal used to select the DRAM ranks to be
accessed. Common chip-select rows for single channel are 64 bits, for
dual channel 128 bits. It may not be visible by the memory controller,
as some DIMM types have a memory buffer that can hide direct access to
it from the Memory Controller.</p>
<ul class="simple">
<li><p>Single-Ranked stick</p></li>
</ul>
<p>A Single-ranked stick has 1 chip-select row of memory. Motherboards
commonly drive two chip-select pins to a memory stick. A single-ranked
stick, will occupy only one of those rows. The other will be unused.</p>
<ul class="simple" id="doubleranked">
<li><p>Double-Ranked stick</p></li>
</ul>
<p>A double-ranked stick has two chip-select rows which access different
sets of memory devices.  The two rows cannot be accessed concurrently.</p>
<ul class="simple">
<li><p>Double-sided stick</p></li>
</ul>
<p><strong>DEPRECATED TERM</strong>, see <a class="reference internal" href="#doubleranked"><span class="std std-ref">Double-Ranked stick</span></a>.</p>
<p>A double-sided stick has two chip-select rows which access different sets
of memory devices. The two rows cannot be accessed concurrently.
“Double-sided” is irrespective of the memory devices being mounted on
both sides of the memory stick.</p>
<ul class="simple">
<li><p>Socket set</p></li>
</ul>
<p>All of the memory sticks that are required for a single memory access or
all of the memory sticks spanned by a chip-select row.  A single socket
set has two chip-select rows and if double-sided sticks are used these
will occupy those chip-select rows.</p>
<ul class="simple">
<li><p>Bank</p></li>
</ul>
<p>This term is avoided because it is unclear when needing to distinguish
between chip-select rows and socket sets.</p>
</section>
<section id="memory-controllers">
<h2>Memory Controllers<a class="headerlink" href="#memory-controllers" title="Permalink to this headline">¶</a></h2>
<p>Most of the EDAC core is focused on doing Memory Controller error detection.
The <a class="reference internal" href="#c.edac_mc_alloc" title="edac_mc_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_mc_alloc()</span></code></a>. It uses internally the struct <code class="docutils literal notranslate"><span class="pre">mem_ctl_info</span></code>
to describe the memory controllers, with is an opaque struct for the EDAC
drivers. Only the EDAC core is allowed to touch it.</p>
<dl class="type">
<dt id="c.dev_type">
enum <code class="sig-name descname">dev_type</code><a class="headerlink" href="#c.dev_type" title="Permalink to this definition">¶</a></dt>
<dd><p>describe the type of memory DRAM chips used at the stick</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DEV_UNKNOWN</span></code></dt><dd><p>Can’t be determined, or MC doesn’t support detect it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X1</span></code></dt><dd><p>1 bit for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X2</span></code></dt><dd><p>2 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X4</span></code></dt><dd><p>4 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X8</span></code></dt><dd><p>8 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X16</span></code></dt><dd><p>16 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X32</span></code></dt><dd><p>32 bits for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEV_X64</span></code></dt><dd><p>64 bits for data</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Typical values are x4 and x8.</p>
<dl class="type">
<dt id="c.hw_event_mc_err_type">
enum <code class="sig-name descname">hw_event_mc_err_type</code><a class="headerlink" href="#c.hw_event_mc_err_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of the detected error</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_CORRECTED</span></code></dt><dd><p>Corrected Error - Indicates that an ECC
corrected error was detected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_UNCORRECTED</span></code></dt><dd><p>Uncorrected Error - Indicates an error that
can’t be corrected by ECC, but it is not
fatal (maybe it is on an unused memory area,
or the memory controller could recover from
it for example, by re-trying the operation).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_DEFERRED</span></code></dt><dd><p>Deferred Error - Indicates an uncorrectable
error whose handling is not urgent. This could
be due to hardware data poisoning where the
system can continue operation until the poisoned
data is consumed. Preemptive measures may also
be taken, e.g. offlining pages, etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_FATAL</span></code></dt><dd><p>Fatal Error - Uncorrected error that could not
be recovered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">HW_EVENT_ERR_INFO</span></code></dt><dd><p>Informational - The CPER spec defines a forth
type of error: informational logs.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.mem_type">
enum <code class="sig-name descname">mem_type</code><a class="headerlink" href="#c.mem_type" title="Permalink to this definition">¶</a></dt>
<dd><p>memory types. For a more detailed reference, please see <a class="reference external" href="http://en.wikipedia.org/wiki/DRAM">http://en.wikipedia.org/wiki/DRAM</a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MEM_EMPTY</span></code></dt><dd><p>Empty csrow</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RESERVED</span></code></dt><dd><p>Reserved csrow type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_UNKNOWN</span></code></dt><dd><p>Unknown csrow type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_FPM</span></code></dt><dd><p>FPM - Fast Page Mode, used on systems up to 1995.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_EDO</span></code></dt><dd><p>EDO - Extended data out, used on systems up to 1998.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_BEDO</span></code></dt><dd><p>BEDO - Burst Extended data out, an EDO variant.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_SDR</span></code></dt><dd><p>SDR - Single data rate SDRAM
<a class="reference external" href="http://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">http://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory</a>
They use 3 pins for chip select: Pins 0 and 2 are
for rank 0; pins 1 and 3 are for rank 1, if the memory
is dual-rank.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDR</span></code></dt><dd><p>Registered SDR SDRAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR</span></code></dt><dd><p>Double data rate SDRAM
<a class="reference external" href="http://en.wikipedia.org/wiki/DDR_SDRAM">http://en.wikipedia.org/wiki/DDR_SDRAM</a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR</span></code></dt><dd><p>Registered Double data rate SDRAM
This is a variant of the DDR memories.
A registered memory has a buffer inside it, hiding
part of the memory details to the memory controller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RMBS</span></code></dt><dd><p>Rambus DRAM, used on a few Pentium III/IV controllers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR2</span></code></dt><dd><p>DDR2 RAM, as described at JEDEC JESD79-2F.
Those memories are labeled as “PC2-” instead of “PC” to
differentiate from DDR.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_FB_DDR2</span></code></dt><dd><p>Fully-Buffered DDR2, as described at JEDEC Std No. 205
and JESD206.
Those memories are accessed per DIMM slot, and not by
a chip select signal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR2</span></code></dt><dd><p>Registered DDR2 RAM
This is a variant of the DDR2 memories.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_XDR</span></code></dt><dd><p>Rambus XDR
It is an evolution of the original RAMBUS memories,
created to compete with DDR2. Weren’t used on any
x86 arch, but cell_edac PPC memory controller uses it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR3</span></code></dt><dd><p>DDR3 RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR3</span></code></dt><dd><p>Registered DDR3 RAM
This is a variant of the DDR3 memories.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LRDDR3</span></code></dt><dd><p>Load-Reduced DDR3 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LPDDR3</span></code></dt><dd><p>Low-Power DDR3 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR4</span></code></dt><dd><p>Unbuffered DDR4 RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR4</span></code></dt><dd><p>Registered DDR4 RAM
This is a variant of the DDR4 memories.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LRDDR4</span></code></dt><dd><p>Load-Reduced DDR4 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LPDDR4</span></code></dt><dd><p>Low-Power DDR4 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_DDR5</span></code></dt><dd><p>Unbuffered DDR5 RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_RDDR5</span></code></dt><dd><p>Registered DDR5 RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_LRDDR5</span></code></dt><dd><p>Load-Reduced DDR5 memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_NVDIMM</span></code></dt><dd><p>Non-volatile RAM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_WIO2</span></code></dt><dd><p>Wide I/O 2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MEM_HBM2</span></code></dt><dd><p>High bandwidth Memory Gen 2.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.edac_type">
enum <code class="sig-name descname">edac_type</code><a class="headerlink" href="#c.edac_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Error Detection and Correction capabilities and mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_UNKNOWN</span></code></dt><dd><p>Unknown if ECC is available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_NONE</span></code></dt><dd><p>Doesn’t support ECC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_RESERVED</span></code></dt><dd><p>Reserved ECC type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_PARITY</span></code></dt><dd><p>Detects parity errors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_EC</span></code></dt><dd><p>Error Checking - no correction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_SECDED</span></code></dt><dd><p>Single bit error correction, Double detection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S2ECD2ED</span></code></dt><dd><p>Chipkill x2 devices - do these exist?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S4ECD4ED</span></code></dt><dd><p>Chipkill x4 devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S8ECD8ED</span></code></dt><dd><p>Chipkill x8 devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_S16ECD16ED</span></code></dt><dd><p>Chipkill x16 devices</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.scrub_type">
enum <code class="sig-name descname">scrub_type</code><a class="headerlink" href="#c.scrub_type" title="Permalink to this definition">¶</a></dt>
<dd><p>scrubbing capabilities</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_UNKNOWN</span></code></dt><dd><p>Unknown if scrubber is available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_NONE</span></code></dt><dd><p>No scrubber</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_PROG</span></code></dt><dd><p>SW progressive (sequential) scrubbing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_SRC</span></code></dt><dd><p>Software scrub only errors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_PROG_SRC</span></code></dt><dd><p>Progressive software scrub from an error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_SW_TUNABLE</span></code></dt><dd><p>Software scrub frequency is tunable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_PROG</span></code></dt><dd><p>HW progressive (sequential) scrubbing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_SRC</span></code></dt><dd><p>Hardware scrub only errors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_PROG_SRC</span></code></dt><dd><p>Progressive hardware scrub from an error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCRUB_HW_TUNABLE</span></code></dt><dd><p>Hardware scrub frequency is tunable</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.edac_mc_layer_type">
enum <code class="sig-name descname">edac_mc_layer_type</code><a class="headerlink" href="#c.edac_mc_layer_type" title="Permalink to this definition">¶</a></dt>
<dd><p>memory controller hierarchy layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_BRANCH</span></code></dt><dd><p>memory layer is named “branch”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_CHANNEL</span></code></dt><dd><p>memory layer is named “channel”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_SLOT</span></code></dt><dd><p>memory layer is named “slot”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_CHIP_SELECT</span></code></dt><dd><p>memory layer is named “chip select”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EDAC_MC_LAYER_ALL_MEM</span></code></dt><dd><p>memory layout is unknown. All memory is mapped
as a single memory area. This is used when
retrieving errors from a firmware driven driver.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This enum is used by the drivers to tell edac_mc_sysfs what name should
be used when describing a memory stick location.</p>
<dl class="type">
<dt id="c.edac_mc_layer">
struct <code class="sig-name descname">edac_mc_layer</code><a class="headerlink" href="#c.edac_mc_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>describes the memory controller hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct edac_mc_layer {
    enum edac_mc_layer_type type;
    unsigned size;
    bool is_virt_csrow;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>layer type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>number of components per layer. For example,
if the channel layer has two channels, size = 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_virt_csrow</span></code></dt><dd><p>This layer is part of the “csrow” when old API
compatibility mode is enabled. Otherwise, it is
a channel</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.rank_info">
struct <code class="sig-name descname">rank_info</code><a class="headerlink" href="#c.rank_info" title="Permalink to this definition">¶</a></dt>
<dd><p>contains the information for one DIMM rank</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rank_info {
    int chan_idx;
    struct csrow_info *csrow;
    struct dimm_info *dimm;
    u32 ce_count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">chan_idx</span></code></dt><dd><p>channel number where the rank is (typically, 0 or 1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csrow</span></code></dt><dd><p>A pointer to the chip select row structure (the parent
structure). The location of the rank is given by
the (csrow-&gt;csrow_idx, chan_idx) vector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dimm</span></code></dt><dd><p>A pointer to the DIMM structure, where the DIMM label
information is stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ce_count</span></code></dt><dd><p>number of correctable errors for this rank</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>FIXME: Currently, the EDAC core model will assume one DIMM per rank.</dt><dd><p>This is a bad assumption, but it makes this patch easier. Later
patches in this series will fix this issue.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.edac_raw_error_desc">
struct <code class="sig-name descname">edac_raw_error_desc</code><a class="headerlink" href="#c.edac_raw_error_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Raw error report structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct edac_raw_error_desc {
    char location[LOCATION_SIZE];
    char label[(EDAC_MC_LABEL_LEN + 1 + sizeof(OTHER_LABEL)) * EDAC_MAX_LABELS];
    long grain;
    u16 error_count;
    enum hw_event_mc_err_type type;
    int top_layer;
    int mid_layer;
    int low_layer;
    unsigned long page_frame_number;
    unsigned long offset_in_page;
    unsigned long syndrome;
    const char *msg;
    const char *other_detail;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">location</span></code></dt><dd><p>location of the error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">label</span></code></dt><dd><p>label of the affected DIMM(s)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">grain</span></code></dt><dd><p>minimum granularity for an error report, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">error_count</span></code></dt><dd><p>number of errors of the same type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>severity of the error (CE/UE/Fatal)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">top_layer</span></code></dt><dd><p>top layer of the error (layer[0])</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mid_layer</span></code></dt><dd><p>middle layer of the error (layer[1])</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">low_layer</span></code></dt><dd><p>low layer of the error (layer[2])</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">page_frame_number</span></code></dt><dd><p>page where the error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset_in_page</span></code></dt><dd><p>page offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">syndrome</span></code></dt><dd><p>syndrome of the error (or 0 if unknown or if
the syndrome is not applicable)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg</span></code></dt><dd><p>error message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">other_detail</span></code></dt><dd><p>other driver-specific detail about the error</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.edac_get_dimm">
struct dimm_info * <code class="sig-name descname">edac_get_dimm</code><span class="sig-paren">(</span>struct mem_ctl_info<em> *mci</em>, int<em> layer0</em>, int<em> layer1</em>, int<em> layer2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_get_dimm" title="Permalink to this definition">¶</a></dt>
<dd><p>Get DIMM info from a memory controller given by [layer0,layer1,layer2] position</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*mci</span></code></dt><dd><p>MC descriptor struct mem_ctl_info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">layer0</span></code></dt><dd><p>layer0 position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">layer1</span></code></dt><dd><p>layer1 position. Unused if n_layers &lt; 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">layer2</span></code></dt><dd><p>layer2 position. Unused if n_layers &lt; 3</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For 1 layer, this function returns “dimms[layer0]”;</p>
<p>For 2 layers, this function is similar to allocating a two-dimensional
array and returning “dimms[layer0][layer1]”;</p>
<p>For 3 layers, this function is similar to allocating a tri-dimensional
array and returning “dimms[layer0][layer1][layer2]”;</p>
</div>
<dl class="function">
<dt id="c.edac_mc_alloc">
struct mem_ctl_info * <code class="sig-name descname">edac_mc_alloc</code><span class="sig-paren">(</span>unsigned int<em> mc_num</em>, unsigned int<em> n_layers</em>, struct <a class="reference internal" href="#c.edac_mc_layer" title="edac_mc_layer">edac_mc_layer</a><em> *layers</em>, unsigned int<em> sz_pvt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and partially fill a struct <code class="xref c c-type docutils literal notranslate"><span class="pre">mem_ctl_info</span></code>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mc_num</span></code></dt><dd><p>Memory controller number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">n_layers</span></code></dt><dd><p>Number of MC hierarchy layers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_mc_layer</span> <span class="pre">*layers</span></code></dt><dd><p>Describes each layer as seen by the Memory Controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz_pvt</span></code></dt><dd><p>size of private storage needed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Everything is kmalloc’ed as one big chunk - more efficient.
Only can be used if all structures have the same lifetime - otherwise
you have to allocate and initialize your own structures.</p>
<p>Use <a class="reference internal" href="#c.edac_mc_free" title="edac_mc_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_mc_free()</span></code></a> to free mc structures allocated by this function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>drivers handle multi-rank memories in different ways: in some
drivers, one multi-rank memory stick is mapped as one entry, while, in
others, a single multi-rank memory stick would be mapped into several
entries. Currently, this function will allocate multiple struct dimm_info
on such scenarios, as grouping the multiple ranks require drivers change.</p>
</div>
<p><strong>Return</strong></p>
<blockquote>
<div><p>On success, return a pointer to struct mem_ctl_info pointer;
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.edac_get_owner">
const char * <code class="sig-name descname">edac_get_owner</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.edac_get_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the owner’s mod_name of EDAC MC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to mod_name string when EDAC MC is owned. NULL otherwise.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.edac_mc_free">
void <code class="sig-name descname">edac_mc_free</code><span class="sig-paren">(</span>struct mem_ctl_info<em> *mci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees a previously allocated <strong>mci</strong> structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*mci</span></code></dt><dd><p>pointer to a struct mem_ctl_info structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.edac_has_mcs">
bool <code class="sig-name descname">edac_has_mcs</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.edac_has_mcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if any MCs have been allocated.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>True if MC instances have been registered successfully.
False otherwise.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.edac_mc_find">
struct mem_ctl_info * <code class="sig-name descname">edac_mc_find</code><span class="sig-paren">(</span>int<em> idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_find" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for a mem_ctl_info structure whose index is <strong>idx</strong>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>index to be seek</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If found, return a pointer to the structure.
Else return NULL.</p>
</div>
<dl class="function">
<dt id="c.find_mci_by_dev">
struct mem_ctl_info * <code class="sig-name descname">find_mci_by_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_mci_by_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan list of controllers looking for the one that manages the <strong>dev</strong> device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to a <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> related with the MCI</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>on success, returns a pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">mem_ctl_info</span></code>;
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.edac_mc_del_mc">
struct mem_ctl_info * <code class="sig-name descname">edac_mc_del_mc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_del_mc" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove sysfs entries for mci structure associated with <strong>dev</strong> and remove mci structure from global list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a> representing mci structure to remove.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>pointer to removed mci structure, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if device not found.</p>
</div>
<dl class="function">
<dt id="c.edac_mc_find_csrow_by_page">
int <code class="sig-name descname">edac_mc_find_csrow_by_page</code><span class="sig-paren">(</span>struct mem_ctl_info<em> *mci</em>, unsigned long<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_find_csrow_by_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Ancillary routine to identify what csrow contains a memory page.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*mci</span></code></dt><dd><p>pointer to a struct mem_ctl_info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page</span></code></dt><dd><p>memory page to find</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>on success, returns the csrow. -1 if not found.</p>
</div>
<dl class="function">
<dt id="c.edac_raw_mc_handle_error">
void <code class="sig-name descname">edac_raw_mc_handle_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.edac_raw_error_desc" title="edac_raw_error_desc">edac_raw_error_desc</a><em> *e</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_raw_mc_handle_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports a memory event to userspace without doing anything to discover the error location.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_raw_error_desc</span> <span class="pre">*e</span></code></dt><dd><p>error description</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This raw function is used internally by <a class="reference internal" href="#c.edac_mc_handle_error" title="edac_mc_handle_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_mc_handle_error()</span></code></a>. It should
only be called directly when the hardware error come directly from BIOS,
like in the case of APEI GHES driver.</p>
</div>
<dl class="function">
<dt id="c.edac_mc_handle_error">
void <code class="sig-name descname">edac_mc_handle_error</code><span class="sig-paren">(</span>const enum <a class="reference internal" href="#c.hw_event_mc_err_type" title="hw_event_mc_err_type">hw_event_mc_err_type</a><em> type</em>, struct mem_ctl_info<em> *mci</em>, const u16<em> error_count</em>, const unsigned long<em> page_frame_number</em>, const unsigned long<em> offset_in_page</em>, const unsigned long<em> syndrome</em>, const int<em> top_layer</em>, const int<em> mid_layer</em>, const int<em> low_layer</em>, const char<em> *msg</em>, const char<em> *other_detail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_handle_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports a memory event to userspace.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hw_event_mc_err_type</span> <span class="pre">type</span></code></dt><dd><p>severity of the error (CE/UE/Fatal)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*mci</span></code></dt><dd><p>a struct mem_ctl_info pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">error_count</span></code></dt><dd><p>Number of errors of the same type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_frame_number</span></code></dt><dd><p>mem page where the error occurred</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">offset_in_page</span></code></dt><dd><p>offset of the error inside the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">syndrome</span></code></dt><dd><p>ECC syndrome</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">top_layer</span></code></dt><dd><p>Memory layer[0] position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">mid_layer</span></code></dt><dd><p>Memory layer[1] position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">low_layer</span></code></dt><dd><p>Memory layer[2] position</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>Message meaningful to the end users that
explains the event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*other_detail</span></code></dt><dd><p>Technical details about the event that
may help hardware manufacturers and
EDAC developers to analyse the event</p>
</dd>
</dl>
</div>
</section>
<section id="pci-controllers">
<h2>PCI Controllers<a class="headerlink" href="#pci-controllers" title="Permalink to this headline">¶</a></h2>
<p>The EDAC subsystem provides a mechanism to handle PCI controllers by calling
the <a class="reference internal" href="#c.edac_pci_alloc_ctl_info" title="edac_pci_alloc_ctl_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_pci_alloc_ctl_info()</span></code></a>. It will use the struct
<code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code> to describe the PCI controllers.</p>
<dl class="function">
<dt id="c.edac_pci_alloc_ctl_info">
struct edac_pci_ctl_info * <code class="sig-name descname">edac_pci_alloc_ctl_info</code><span class="sig-paren">(</span>unsigned int<em> sz_pvt</em>, const char<em> *edac_pci_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_alloc_ctl_info" title="Permalink to this definition">¶</a></dt>
<dd><p>The alloc() function for the ‘edac_pci’ control info structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz_pvt</span></code></dt><dd><p>size of the private info at struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*edac_pci_name</span></code></dt><dd><p>name of the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The chip driver will allocate one of these for each
edac_pci it is going to control/register with the EDAC CORE.</p>
<p><strong>Return</strong></p>
<p>a pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code> on success; <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.edac_pci_free_ctl_info">
void <code class="sig-name descname">edac_pci_free_ctl_info</code><span class="sig-paren">(</span>struct edac_pci_ctl_info<em> *pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_free_ctl_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Last action on the pci control structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the remove sysfs information, which will unregister
this control struct’s kobj. When that kobj’s ref count
goes to zero, its release function will be call and then
<a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a> the memory.</p>
</div>
<dl class="function">
<dt id="c.edac_pci_alloc_index">
int <code class="sig-name descname">edac_pci_alloc_index</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_alloc_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a unique PCI index number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>allocated index number</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.edac_pci_add_device">
int <code class="sig-name descname">edac_pci_add_device</code><span class="sig-paren">(</span>struct edac_pci_ctl_info<em> *pci</em>, int<em> edac_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_add_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert the ‘edac_dev’ structure into the edac_pci global list and create sysfs entries associated with edac_pci structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*pci</span></code></dt><dd><p>pointer to the edac_device structure to be added to the list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">edac_idx</span></code></dt><dd><p>A unique numeric identifier to be assigned to the
‘edac_pci’ structure.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on Success, or an error code on failure</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.edac_pci_del_device">
struct edac_pci_ctl_info * <code class="sig-name descname">edac_pci_del_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_del_device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></p>
<blockquote>
<div><p>Pointer to ‘<a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>’ representing edac_pci structure
to remove</p>
</div></blockquote>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove sysfs entries for specified edac_pci structure and
then remove edac_pci structure from global list</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to removed edac_pci structure,
or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if device not found</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.edac_pci_create_generic_ctl">
struct edac_pci_ctl_info * <code class="sig-name descname">edac_pci_create_generic_ctl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_create_generic_ctl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a>;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>name of the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>A generic constructor for a PCI parity polling device
Some systems have more than one domain of PCI busses.
For systems with one domain, then this API will
provide for a generic poller.</p>
</div></blockquote>
<p>This routine calls the <a class="reference internal" href="#c.edac_pci_alloc_ctl_info" title="edac_pci_alloc_ctl_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">edac_pci_alloc_ctl_info()</span></code></a> for
the generic device, with default values</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code> on success, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on</dt><dd><p>failure.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.edac_pci_release_generic_ctl">
void <code class="sig-name descname">edac_pci_release_generic_ctl</code><span class="sig-paren">(</span>struct edac_pci_ctl_info<em> *pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_release_generic_ctl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The release function of a generic EDAC PCI polling device</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.edac_pci_create_sysfs">
int <code class="sig-name descname">edac_pci_create_sysfs</code><span class="sig-paren">(</span>struct edac_pci_ctl_info<em> *pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_create_sysfs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Create the controls/attributes for the specified EDAC PCI device</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.edac_pci_remove_sysfs">
void <code class="sig-name descname">edac_pci_remove_sysfs</code><span class="sig-paren">(</span>struct edac_pci_ctl_info<em> *pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_remove_sysfs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*pci</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_pci_ctl_info</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>remove the controls and attributes for this EDAC PCI device</p>
</div></blockquote>
</div>
</section>
<section id="edac-blocks">
<h2>EDAC Blocks<a class="headerlink" href="#edac-blocks" title="Permalink to this headline">¶</a></h2>
<p>The EDAC subsystem also provides a generic mechanism to report errors on
other parts of the hardware via <code class="xref c c-func docutils literal notranslate"><span class="pre">edac_device_alloc_ctl_info()</span></code> function.</p>
<p>The structures <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_dev_sysfs_block_attribute</span></code>,
<code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_block</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_instance</span></code> and
<code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code> provide a generic or abstract ‘edac_device’
representation at sysfs.</p>
<p>This set of structures and the code that implements the APIs for the same, provide for registering EDAC type devices which are NOT standard memory or
PCI, like:</p>
<ul class="simple">
<li><p>CPU caches (L1 and L2)</p></li>
<li><p>DMA engines</p></li>
<li><p>Core CPU switches</p></li>
<li><p>Fabric switch units</p></li>
<li><p>PCIe interface controllers</p></li>
<li><p>other EDAC/ECC type devices that can be monitored for
errors, etc.</p></li>
</ul>
<p>It allows for a 2 level set of hierarchy.</p>
<p>For example, a cache could be composed of L1, L2 and L3 levels of cache.
Each CPU core would have its own L1 cache, while sharing L2 and maybe L3
caches. On such case, those can be represented via the following sysfs
nodes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/system/edac/..

pci/            &lt;existing pci directory (if available)&gt;
mc/             &lt;existing memory device directory&gt;
cpu/cpu0/..     &lt;L1 and L2 block directory&gt;
        /L1-cache/ce_count
                 /ue_count
        /L2-cache/ce_count
                 /ue_count
cpu/cpu1/..     &lt;L1 and L2 block directory&gt;
        /L1-cache/ce_count
                 /ue_count
        /L2-cache/ce_count
                 /ue_count
...

the L1 and L2 directories would be &quot;edac_device_block&#39;s&quot;
</pre></div>
</div>
<dl class="function">
<dt id="c.edac_device_add_device">
int <code class="sig-name descname">edac_device_add_device</code><span class="sig-paren">(</span>struct edac_device_ctl_info<em> *edac_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_add_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert the ‘edac_dev’ structure into the edac_device global list and create sysfs entries associated with edac_device structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*edac_dev</span></code></dt><dd><p>pointer to edac_device structure to be added to the list
‘edac_device’ structure.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 on Success, or an error code on failure</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.edac_device_del_device">
struct edac_device_ctl_info * <code class="sig-name descname">edac_device_del_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_del_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove sysfs entries for specified edac_device structure and then remove edac_device structure from global list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></p>
<blockquote>
<div><p>Pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">device</span></code></a> representing the edac device
structure to remove.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>Pointer to removed edac_device structure,
or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if device not found.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.edac_device_handle_ce_count">
void <code class="sig-name descname">edac_device_handle_ce_count</code><span class="sig-paren">(</span>struct edac_device_ctl_info<em> *edac_dev</em>, unsigned int<em> count</em>, int<em> inst_nr</em>, int<em> block_nr</em>, const char<em> *msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ce_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Log correctable errors.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Number of errors to log.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.edac_device_handle_ue_count">
void <code class="sig-name descname">edac_device_handle_ue_count</code><span class="sig-paren">(</span>struct edac_device_ctl_info<em> *edac_dev</em>, unsigned int<em> count</em>, int<em> inst_nr</em>, int<em> block_nr</em>, const char<em> *msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ue_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Log uncorrectable errors.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Number of errors to log.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.edac_device_handle_ce">
void <code class="sig-name descname">edac_device_handle_ce</code><span class="sig-paren">(</span>struct edac_device_ctl_info<em> *edac_dev</em>, int<em> inst_nr</em>, int<em> block_nr</em>, const char<em> *msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ce" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a single correctable error</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the CE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.edac_device_handle_ue">
void <code class="sig-name descname">edac_device_handle_ue</code><span class="sig-paren">(</span>struct edac_device_ctl_info<em> *edac_dev</em>, int<em> inst_nr</em>, int<em> block_nr</em>, const char<em> *msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ue" title="Permalink to this definition">¶</a></dt>
<dd><p>Log a single uncorrectable error</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*edac_dev</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">edac_device_ctl_info</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt><dd><p>number of the instance where the UE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt><dd><p>number of the block where the UE error happened</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>message to be printed</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.edac_device_alloc_index">
int <code class="sig-name descname">edac_device_alloc_index</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_alloc_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a unique device index number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>allocated index number</p>
</div></blockquote>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Error Detection And Correction (EDAC) Devices</a><ul>
<li><a class="reference internal" href="#main-concepts-used-at-the-edac-subsystem">Main Concepts used at the EDAC subsystem</a></li>
<li><a class="reference internal" href="#memory-controllers">Memory Controllers</a></li>
<li><a class="reference internal" href="#pci-controllers">PCI Controllers</a></li>
<li><a class="reference internal" href="#edac-blocks">EDAC Blocks</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/edac.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/edac.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>