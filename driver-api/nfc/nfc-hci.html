
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>HCI backend for NFC Core &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Kernel driver for the NXP Semiconductors PN544 Near Field Communication chip" href="nfc-pn544.html" />
    <link rel="prev" title="Near Field Communication" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="hci-backend-for-nfc-core">
<h1>HCI backend for NFC Core<a class="headerlink" href="#hci-backend-for-nfc-core" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p>Author: Eric Lapuyade, Samuel Ortiz</p></li>
<li><p>Contact: <a class="reference external" href="mailto:eric&#46;lapuyade&#37;&#52;&#48;intel&#46;com">eric<span>&#46;</span>lapuyade<span>&#64;</span>intel<span>&#46;</span>com</a>, <a class="reference external" href="mailto:samuel&#46;ortiz&#37;&#52;&#48;intel&#46;com">samuel<span>&#46;</span>ortiz<span>&#64;</span>intel<span>&#46;</span>com</a></p></li>
</ul>
<section id="general">
<h2>General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h2>
<p>The HCI layer implements much of the ETSI TS 102 622 V10.2.0 specification. It
enables easy writing of HCI-based NFC drivers. The HCI layer runs as an NFC Core
backend, implementing an abstract nfc device and translating NFC Core API
to HCI commands and events.</p>
</section>
<section id="hci">
<h2>HCI<a class="headerlink" href="#hci" title="Permalink to this headline">¶</a></h2>
<p>HCI registers as an nfc device with NFC Core. Requests coming from userspace are
routed through netlink sockets to NFC Core and then to HCI. From this point,
they are translated in a sequence of HCI commands sent to the HCI layer in the
host controller (the chip). Commands can be executed synchronously (the sending
context blocks waiting for response) or asynchronously (the response is returned
from HCI Rx context).
HCI events can also be received from the host controller. They will be handled
and a translation will be forwarded to NFC Core as needed. There are hooks to
let the HCI driver handle proprietary events or override standard behavior.
HCI uses 2 execution contexts:</p>
<ul class="simple">
<li><p>one for executing commands : nfc_hci_msg_tx_work(). Only one command
can be executing at any given moment.</p></li>
<li><p>one for dispatching received events and commands : nfc_hci_msg_rx_work().</p></li>
</ul>
</section>
<section id="hci-session-initialization">
<h2>HCI Session initialization<a class="headerlink" href="#hci-session-initialization" title="Permalink to this headline">¶</a></h2>
<p>The Session initialization is an HCI standard which must unfortunately
support proprietary gates. This is the reason why the driver will pass a list
of proprietary gates that must be part of the session. HCI will ensure all
those gates have pipes connected when the hci device is set up.
In case the chip supports pre-opened gates and pseudo-static pipes, the driver
can pass that information to HCI core.</p>
</section>
<section id="hci-gates-and-pipes">
<h2>HCI Gates and Pipes<a class="headerlink" href="#hci-gates-and-pipes" title="Permalink to this headline">¶</a></h2>
<p>A gate defines the ‘port’ where some service can be found. In order to access
a service, one must create a pipe to that gate and open it. In this
implementation, pipes are totally hidden. The public API only knows gates.
This is consistent with the driver need to send commands to proprietary gates
without knowing the pipe connected to it.</p>
</section>
<section id="driver-interface">
<h2>Driver interface<a class="headerlink" href="#driver-interface" title="Permalink to this headline">¶</a></h2>
<p>A driver is generally written in two parts : the physical link management and
the HCI management. This makes it easier to maintain a driver for a chip that
can be connected using various phy (i2c, spi, …)</p>
</section>
<section id="hci-management">
<h2>HCI Management<a class="headerlink" href="#hci-management" title="Permalink to this headline">¶</a></h2>
<p>A driver would normally register itself with HCI and provide the following
entry points:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nfc_hci_ops {
      int (*open)(struct nfc_hci_dev *hdev);
      void (*close)(struct nfc_hci_dev *hdev);
      int (*hci_ready) (struct nfc_hci_dev *hdev);
      int (*xmit) (struct nfc_hci_dev *hdev, struct sk_buff *skb);
      int (*start_poll) (struct nfc_hci_dev *hdev,
                         u32 im_protocols, u32 tm_protocols);
      int (*dep_link_up)(struct nfc_hci_dev *hdev, struct nfc_target *target,
                         u8 comm_mode, u8 *gb, size_t gb_len);
      int (*dep_link_down)(struct nfc_hci_dev *hdev);
      int (*target_from_gate) (struct nfc_hci_dev *hdev, u8 gate,
                               struct nfc_target *target);
      int (*complete_target_discovered) (struct nfc_hci_dev *hdev, u8 gate,
                                         struct nfc_target *target);
      int (*im_transceive) (struct nfc_hci_dev *hdev,
                            struct nfc_target *target, struct sk_buff *skb,
                            data_exchange_cb_t cb, void *cb_context);
      int (*tm_send)(struct nfc_hci_dev *hdev, struct sk_buff *skb);
      int (*check_presence)(struct nfc_hci_dev *hdev,
                            struct nfc_target *target);
      int (*event_received)(struct nfc_hci_dev *hdev, u8 gate, u8 event,
                            struct sk_buff *skb);
};
</pre></div>
</div>
<ul class="simple">
<li><p>open() and close() shall turn the hardware on and off.</p></li>
<li><p>hci_ready() is an optional entry point that is called right after the hci
session has been set up. The driver can use it to do additional initialization
that must be performed using HCI commands.</p></li>
<li><p>xmit() shall simply write a frame to the physical link.</p></li>
<li><p>start_poll() is an optional entrypoint that shall set the hardware in polling
mode. This must be implemented only if the hardware uses proprietary gates or a
mechanism slightly different from the HCI standard.</p></li>
<li><p>dep_link_up() is called after a p2p target has been detected, to finish
the p2p connection setup with hardware parameters that need to be passed back
to nfc core.</p></li>
<li><p>dep_link_down() is called to bring the p2p link down.</p></li>
<li><p>target_from_gate() is an optional entrypoint to return the nfc protocols
corresponding to a proprietary gate.</p></li>
<li><p>complete_target_discovered() is an optional entry point to let the driver
perform additional proprietary processing necessary to auto activate the
discovered target.</p></li>
<li><p>im_transceive() must be implemented by the driver if proprietary HCI commands
are required to send data to the tag. Some tag types will require custom
commands, others can be written to using the standard HCI commands. The driver
can check the tag type and either do proprietary processing, or return 1 to ask
for standard processing. The data exchange command itself must be sent
asynchronously.</p></li>
<li><p>tm_send() is called to send data in the case of a p2p connection</p></li>
<li><p>check_presence() is an optional entry point that will be called regularly
by the core to check that an activated tag is still in the field. If this is
not implemented, the core will not be able to push tag_lost events to the user
space</p></li>
<li><p>event_received() is called to handle an event coming from the chip. Driver
can handle the event or return 1 to let HCI attempt standard processing.</p></li>
</ul>
<p>On the rx path, the driver is responsible to push incoming HCP frames to HCI
using nfc_hci_recv_frame(). HCI will take care of re-aggregation and handling
This must be done from a context that can sleep.</p>
</section>
<section id="phy-management">
<h2>PHY Management<a class="headerlink" href="#phy-management" title="Permalink to this headline">¶</a></h2>
<p>The physical link (i2c, …) management is defined by the following structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nfc_phy_ops {
      int (*write)(void *dev_id, struct sk_buff *skb);
      int (*enable)(void *dev_id);
      void (*disable)(void *dev_id);
};
</pre></div>
</div>
<dl class="simple">
<dt>enable():</dt><dd><p>turn the phy on (power on), make it ready to transfer data</p>
</dd>
<dt>disable():</dt><dd><p>turn the phy off</p>
</dd>
<dt>write():</dt><dd><p>Send a data frame to the chip. Note that to enable higher
layers such as an llc to store the frame for re-emission, this
function must not alter the skb. It must also not return a positive
result (return 0 for success, negative for failure).</p>
</dd>
</dl>
<p>Data coming from the chip shall be sent directly to nfc_hci_recv_frame().</p>
</section>
<section id="llc">
<h2>LLC<a class="headerlink" href="#llc" title="Permalink to this headline">¶</a></h2>
<p>Communication between the CPU and the chip often requires some link layer
protocol. Those are isolated as modules managed by the HCI layer. There are
currently two modules : nop (raw transfert) and shdlc.
A new llc must implement the following functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nfc_llc_ops {
      void *(*init) (struct nfc_hci_dev *hdev, xmit_to_drv_t xmit_to_drv,
                     rcv_to_hci_t rcv_to_hci, int tx_headroom,
                     int tx_tailroom, int *rx_headroom, int *rx_tailroom,
                     llc_failure_t llc_failure);
      void (*deinit) (struct nfc_llc *llc);
      int (*start) (struct nfc_llc *llc);
      int (*stop) (struct nfc_llc *llc);
      void (*rcv_from_drv) (struct nfc_llc *llc, struct sk_buff *skb);
      int (*xmit_from_hci) (struct nfc_llc *llc, struct sk_buff *skb);
};
</pre></div>
</div>
<dl class="simple">
<dt>init():</dt><dd><p>allocate and init your private storage</p>
</dd>
<dt>deinit():</dt><dd><p>cleanup</p>
</dd>
<dt>start():</dt><dd><p>establish the logical connection</p>
</dd>
<dt>stop ():</dt><dd><p>terminate the logical connection</p>
</dd>
<dt>rcv_from_drv():</dt><dd><p>handle data coming from the chip, going to HCI</p>
</dd>
<dt>xmit_from_hci():</dt><dd><p>handle data sent by HCI, going to the chip</p>
</dd>
</dl>
<p>The llc must be registered with nfc before it can be used. Do that by
calling:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nfc_llc_register(const char *name, const struct nfc_llc_ops *ops);
</pre></div>
</div>
<p>Again, note that the llc does not handle the physical link. It is thus very
easy to mix any physical link with any llc for a given chip driver.</p>
</section>
<section id="included-drivers">
<h2>Included Drivers<a class="headerlink" href="#included-drivers" title="Permalink to this headline">¶</a></h2>
<p>An HCI based driver for an NXP PN544, connected through I2C bus, and using
shdlc is included.</p>
</section>
<section id="execution-contexts">
<h2>Execution Contexts<a class="headerlink" href="#execution-contexts" title="Permalink to this headline">¶</a></h2>
<p>The execution contexts are the following:
- IRQ handler (IRQH):
fast, cannot sleep. sends incoming frames to HCI where they are passed to
the current llc. In case of shdlc, the frame is queued in shdlc rx queue.</p>
<ul>
<li><p>SHDLC State Machine worker (SMW)</p>
<p>Only when llc_shdlc is used: handles shdlc rx &amp; tx queues.</p>
<p>Dispatches HCI cmd responses.</p>
</li>
<li><p>HCI Tx Cmd worker (MSGTXWQ)</p>
<p>Serializes execution of HCI commands.</p>
<p>Completes execution in case of response timeout.</p>
</li>
<li><p>HCI Rx worker (MSGRXWQ)</p>
<p>Dispatches incoming HCI commands or events.</p>
</li>
<li><p>Syscall context from a userspace call (SYSCALL)</p>
<p>Any entrypoint in HCI called from NFC Core</p>
</li>
</ul>
</section>
<section id="workflow-executing-an-hci-command-using-shdlc">
<h2>Workflow executing an HCI command (using shdlc)<a class="headerlink" href="#workflow-executing-an-hci-command-using-shdlc" title="Permalink to this headline">¶</a></h2>
<p>Executing an HCI command can easily be performed synchronously using the
following API:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int nfc_hci_send_cmd (struct nfc_hci_dev *hdev, u8 gate, u8 cmd,
                      const u8 *param, size_t param_len, struct sk_buff **skb)
</pre></div>
</div>
<p>The API must be invoked from a context that can sleep. Most of the time, this
will be the syscall context. skb will return the result that was received in
the response.</p>
<p>Internally, execution is asynchronous. So all this API does is to enqueue the
HCI command, setup a local wait queue on stack, and <a class="reference internal" href="../basics.html#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_event()</span></code></a> for completion.
The wait is not interruptible because it is guaranteed that the command will
complete after some short timeout anyway.</p>
<p>MSGTXWQ context will then be scheduled and invoke nfc_hci_msg_tx_work().
This function will dequeue the next pending command and send its HCP fragments
to the lower layer which happens to be shdlc. It will then start a timer to be
able to complete the command with a timeout error if no response arrive.</p>
<p>SMW context gets scheduled and invokes nfc_shdlc_sm_work(). This function
handles shdlc framing in and out. It uses the driver xmit to send frames and
receives incoming frames in an skb queue filled from the driver IRQ handler.
SHDLC I(nformation) frames payload are HCP fragments. They are aggregated to
form complete HCI frames, which can be a response, command, or event.</p>
<p>HCI Responses are dispatched immediately from this context to unblock
waiting command execution. Response processing involves invoking the completion
callback that was provided by nfc_hci_msg_tx_work() when it sent the command.
The completion callback will then wake the syscall context.</p>
<p>It is also possible to execute the command asynchronously using this API:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int nfc_hci_execute_cmd_async(struct nfc_hci_dev *hdev, u8 pipe, u8 cmd,
                                     const u8 *param, size_t param_len,
                                     data_exchange_cb_t cb, void *cb_context)
</pre></div>
</div>
<p>The workflow is the same, except that the API call returns immediately, and
the callback will be called with the result from the SMW context.</p>
</section>
<section id="workflow-receiving-an-hci-event-or-command">
<h2>Workflow receiving an HCI event or command<a class="headerlink" href="#workflow-receiving-an-hci-event-or-command" title="Permalink to this headline">¶</a></h2>
<p>HCI commands or events are not dispatched from SMW context. Instead, they are
queued to HCI rx_queue and will be dispatched from HCI rx worker
context (MSGRXWQ). This is done this way to allow a cmd or event handler
to also execute other commands (for example, handling the
NFC_HCI_EVT_TARGET_DISCOVERED event from PN544 requires to issue an
ANY_GET_PARAMETER to the reader A gate to get information on the target
that was discovered).</p>
<p>Typically, such an event will be propagated to NFC Core from MSGRXWQ context.</p>
</section>
<section id="error-management">
<h2>Error management<a class="headerlink" href="#error-management" title="Permalink to this headline">¶</a></h2>
<p>Errors that occur synchronously with the execution of an NFC Core request are
simply returned as the execution result of the request. These are easy.</p>
<p>Errors that occur asynchronously (e.g. in a background protocol handling thread)
must be reported such that upper layers don’t stay ignorant that something
went wrong below and know that expected events will probably never happen.
Handling of these errors is done as follows:</p>
<ul class="simple">
<li><p>driver (pn544) fails to deliver an incoming frame: it stores the error such
that any subsequent call to the driver will result in this error. Then it
calls the standard nfc_shdlc_recv_frame() with a NULL argument to report the
problem above. shdlc stores a EREMOTEIO sticky status, which will trigger
SMW to report above in turn.</p></li>
<li><p>SMW is basically a background thread to handle incoming and outgoing shdlc
frames. This thread will also check the shdlc sticky status and report to HCI
when it discovers it is not able to run anymore because of an unrecoverable
error that happened within shdlc or below. If the problem occurs during shdlc
connection, the error is reported through the connect completion.</p></li>
<li><p>HCI: if an internal HCI error happens (frame is lost), or HCI is reported an
error from a lower layer, HCI will either complete the currently executing
command with that error, or notify NFC Core directly if no command is
executing.</p></li>
<li><p>NFC Core: when NFC Core is notified of an error from below and polling is
active, it will send a tag discovered event with an empty tag list to the user
space to let it know that the poll operation will never be able to detect a
tag. If polling is not active and the error was sticky, lower levels will
return it at next invocation.</p></li>
</ul>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">HCI backend for NFC Core</a><ul>
<li><a class="reference internal" href="#general">General</a></li>
<li><a class="reference internal" href="#hci">HCI</a></li>
<li><a class="reference internal" href="#hci-session-initialization">HCI Session initialization</a></li>
<li><a class="reference internal" href="#hci-gates-and-pipes">HCI Gates and Pipes</a></li>
<li><a class="reference internal" href="#driver-interface">Driver interface</a></li>
<li><a class="reference internal" href="#hci-management">HCI Management</a></li>
<li><a class="reference internal" href="#phy-management">PHY Management</a></li>
<li><a class="reference internal" href="#llc">LLC</a></li>
<li><a class="reference internal" href="#included-drivers">Included Drivers</a></li>
<li><a class="reference internal" href="#execution-contexts">Execution Contexts</a></li>
<li><a class="reference internal" href="#workflow-executing-an-hci-command-using-shdlc">Workflow executing an HCI command (using shdlc)</a></li>
<li><a class="reference internal" href="#workflow-receiving-an-hci-event-or-command">Workflow receiving an HCI event or command</a></li>
<li><a class="reference internal" href="#error-management">Error management</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/nfc/nfc-hci.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/nfc/nfc-hci.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>