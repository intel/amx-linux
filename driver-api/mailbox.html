
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>The Common Mailbox Framework &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="MTD NAND Driver Programming Interface" href="mtdnand.html" />
    <link rel="prev" title="target and iSCSI Interfaces Guide" href="target.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="the-common-mailbox-framework">
<h1>The Common Mailbox Framework<a class="headerlink" href="#the-common-mailbox-framework" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Jassi Brar &lt;<a class="reference external" href="mailto:jaswinder&#46;singh&#37;&#52;&#48;linaro&#46;org">jaswinder<span>&#46;</span>singh<span>&#64;</span>linaro<span>&#46;</span>org</a>&gt;</p>
</dd>
</dl>
<p>This document aims to help developers write client and controller
drivers for the API. But before we start, let us note that the
client (especially) and controller drivers are likely going to be
very platform specific because the remote firmware is likely to be
proprietary and implement non-standard protocol. So even if two
platforms employ, say, PL320 controller, the client drivers can’t
be shared across them. Even the PL320 driver might need to accommodate
some platform specific quirks. So the API is meant mainly to avoid
similar copies of code written for each platform. Having said that,
nothing prevents the remote f/w to also be Linux based and use the
same api there. However none of that helps us locally because we only
ever deal at client’s protocol level.</p>
<p>Some of the choices made during implementation are the result of this
peculiarity of this “common” framework.</p>
<section id="controller-driver-see-include-linux-mailbox-controller-h">
<h2>Controller Driver (See include/linux/mailbox_controller.h)<a class="headerlink" href="#controller-driver-see-include-linux-mailbox-controller-h" title="Permalink to this headline">¶</a></h2>
<p>Allocate mbox_controller and the array of mbox_chan.
Populate mbox_chan_ops, except peek_data() all are mandatory.
The controller driver might know a message has been consumed
by the remote by getting an IRQ or polling some hardware flag
or it can never know (the client knows by way of the protocol).
The method in order of preference is IRQ -&gt; Poll -&gt; None, which
the controller driver should set via ‘txdone_irq’ or ‘txdone_poll’
or neither.</p>
</section>
<section id="client-driver-see-include-linux-mailbox-client-h">
<h2>Client Driver (See include/linux/mailbox_client.h)<a class="headerlink" href="#client-driver-see-include-linux-mailbox-client-h" title="Permalink to this headline">¶</a></h2>
<p>The client might want to operate in blocking mode (synchronously
send a message through before returning) or non-blocking/async mode (submit
a message and a callback function to the API and return immediately).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct demo_client {
        struct mbox_client cl;
        struct mbox_chan *mbox;
        struct completion c;
        bool async;
        /* ... */
};

/*
* This is the handler for data received from remote. The behaviour is purely
* dependent upon the protocol. This is just an example.
*/
static void message_from_remote(struct mbox_client *cl, void *mssg)
{
        struct demo_client *dc = container_of(cl, struct demo_client, cl);
        if (dc-&gt;async) {
                if (is_an_ack(mssg)) {
                        /* An ACK to our last sample sent */
                        return; /* Or do something else here */
                } else { /* A new message from remote */
                        queue_req(mssg);
                }
        } else {
                /* Remote f/w sends only ACK packets on this channel */
                return;
        }
}

static void sample_sent(struct mbox_client *cl, void *mssg, int r)
{
        struct demo_client *dc = container_of(cl, struct demo_client, cl);
        complete(&amp;dc-&gt;c);
}

static void client_demo(struct platform_device *pdev)
{
        struct demo_client *dc_sync, *dc_async;
        /* The controller already knows async_pkt and sync_pkt */
        struct async_pkt ap;
        struct sync_pkt sp;

        dc_sync = kzalloc(sizeof(*dc_sync), GFP_KERNEL);
        dc_async = kzalloc(sizeof(*dc_async), GFP_KERNEL);

        /* Populate non-blocking mode client */
        dc_async-&gt;cl.dev = &amp;pdev-&gt;dev;
        dc_async-&gt;cl.rx_callback = message_from_remote;
        dc_async-&gt;cl.tx_done = sample_sent;
        dc_async-&gt;cl.tx_block = false;
        dc_async-&gt;cl.tx_tout = 0; /* doesn&#39;t matter here */
        dc_async-&gt;cl.knows_txdone = false; /* depending upon protocol */
        dc_async-&gt;async = true;
        init_completion(&amp;dc_async-&gt;c);

        /* Populate blocking mode client */
        dc_sync-&gt;cl.dev = &amp;pdev-&gt;dev;
        dc_sync-&gt;cl.rx_callback = message_from_remote;
        dc_sync-&gt;cl.tx_done = NULL; /* operate in blocking mode */
        dc_sync-&gt;cl.tx_block = true;
        dc_sync-&gt;cl.tx_tout = 500; /* by half a second */
        dc_sync-&gt;cl.knows_txdone = false; /* depending upon protocol */
        dc_sync-&gt;async = false;

        /* ASync mailbox is listed second in &#39;mboxes&#39; property */
        dc_async-&gt;mbox = mbox_request_channel(&amp;dc_async-&gt;cl, 1);
        /* Populate data packet */
        /* ap.xxx = 123; etc */
        /* Send async message to remote */
        mbox_send_message(dc_async-&gt;mbox, &amp;ap);

        /* Sync mailbox is listed first in &#39;mboxes&#39; property */
        dc_sync-&gt;mbox = mbox_request_channel(&amp;dc_sync-&gt;cl, 0);
        /* Populate data packet */
        /* sp.abc = 123; etc */
        /* Send message to remote in blocking mode */
        mbox_send_message(dc_sync-&gt;mbox, &amp;sp);
        /* At this point &#39;sp&#39; has been sent */

        /* Now wait for async chan to be done */
        wait_for_completion(&amp;dc_async-&gt;c);
}
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The Common Mailbox Framework</a><ul>
<li><a class="reference internal" href="#controller-driver-see-include-linux-mailbox-controller-h">Controller Driver (See include/linux/mailbox_controller.h)</a></li>
<li><a class="reference internal" href="#client-driver-see-include-linux-mailbox-client-h">Client Driver (See include/linux/mailbox_client.h)</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/mailbox.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/mailbox.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>