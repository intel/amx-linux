
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>target and iSCSI Interfaces Guide &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Common Mailbox Framework" href="mailbox.html" />
    <link rel="prev" title="libATA Developer’s Guide" href="libata.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="target-and-iscsi-interfaces-guide">
<h1>target and iSCSI Interfaces Guide<a class="headerlink" href="#target-and-iscsi-interfaces-guide" title="Permalink to this headline">¶</a></h1>
<section id="introduction-and-overview">
<h2>Introduction and Overview<a class="headerlink" href="#introduction-and-overview" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
</section>
<section id="target-core-device-interfaces">
<h2>Target core device interfaces<a class="headerlink" href="#target-core-device-interfaces" title="Permalink to this headline">¶</a></h2>
<p>This section is blank because no kerneldoc comments have been added to
drivers/target/target_core_device.c.</p>
</section>
<section id="target-core-transport-interfaces">
<h2>Target core transport interfaces<a class="headerlink" href="#target-core-transport-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.transport_init_session">
int <code class="sig-name descname">transport_init_session</code><span class="sig-paren">(</span>struct se_session<em> *se_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_init_session" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a session object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*se_sess</span></code></dt><dd><p>Session object pointer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must have zero-initialized <strong>se_sess</strong> before calling this function.</p>
</div>
<dl class="function">
<dt id="c.transport_alloc_session">
struct se_session * <code class="sig-name descname">transport_alloc_session</code><span class="sig-paren">(</span>enum target_prot_op<em> sup_prot_ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_alloc_session" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a session object and initialize it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">target_prot_op</span> <span class="pre">sup_prot_ops</span></code></dt><dd><p>bitmask that defines which T10-PI modes are supported.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.transport_alloc_session_tags">
int <code class="sig-name descname">transport_alloc_session_tags</code><span class="sig-paren">(</span>struct se_session<em> *se_sess</em>, unsigned int<em> tag_num</em>, unsigned int<em> tag_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_alloc_session_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate target driver private data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*se_sess</span></code></dt><dd><p>Session pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tag_num</span></code></dt><dd><p>Maximum number of in-flight commands between initiator and target.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tag_size</span></code></dt><dd><p>Size in bytes of the private data a target driver associates with
each command.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.target_init_cmd">
int <code class="sig-name descname">target_init_cmd</code><span class="sig-paren">(</span>struct se_cmd<em> *se_cmd</em>, struct se_session<em> *se_sess</em>, unsigned char<em> *sense</em>, u64<em> unpacked_lun</em>, u32<em> data_length</em>, int<em> task_attr</em>, int<em> data_dir</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_init_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize se_cmd</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*se_cmd</span></code></dt><dd><p>command descriptor to init</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*se_sess</span></code></dt><dd><p>associated se_sess for endpoint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*sense</span></code></dt><dd><p>pointer to SCSI sense buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">unpacked_lun</span></code></dt><dd><p>unpacked LUN to reference for struct se_lun</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">data_length</span></code></dt><dd><p>fabric expected data transfer length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">task_attr</span></code></dt><dd><p>SAM task attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">data_dir</span></code></dt><dd><p>DMA data direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags for command submission from target_sc_flags_tables</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Task tags are supported if the caller has set <strong>se_cmd-&gt;tag</strong>.</p>
<p>If the fabric driver calls target_stop_session, then it must check the
return code and handle failures. This will never fail for other drivers,
and the return code can be ignored.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>less than zero to signal active I/O shutdown failure.</p></li>
<li><p>zero on success.</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.target_submit_prep">
int <code class="sig-name descname">target_submit_prep</code><span class="sig-paren">(</span>struct se_cmd<em> *se_cmd</em>, unsigned char<em> *cdb</em>, struct scatterlist<em> *sgl</em>, u32<em> sgl_count</em>, struct scatterlist<em> *sgl_bidi</em>, u32<em> sgl_bidi_count</em>, struct scatterlist<em> *sgl_prot</em>, u32<em> sgl_prot_count</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_submit_prep" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare cmd for submission</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*se_cmd</span></code></dt><dd><p>command descriptor to prep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*cdb</span></code></dt><dd><p>pointer to SCSI CDB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*sgl</span></code></dt><dd><p>struct scatterlist memory for unidirectional mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">sgl_count</span></code></dt><dd><p>scatterlist count for unidirectional mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*sgl_bidi</span></code></dt><dd><p>struct scatterlist memory for bidirectional READ mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">sgl_bidi_count</span></code></dt><dd><p>scatterlist count for bidirectional READ mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*sgl_prot</span></code></dt><dd><p>struct scatterlist memory protection information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">sgl_prot_count</span></code></dt><dd><p>scatterlist count for protection information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>gfp allocation type</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>less than zero to signal failure.</p></li>
<li><p>zero on success.</p></li>
</ul>
</div></blockquote>
<p><strong>Description</strong></p>
<p>If failure is returned, lio will the callers queue_status to complete
the cmd.</p>
</div>
<dl class="function">
<dt id="c.target_submit">
void <code class="sig-name descname">target_submit</code><span class="sig-paren">(</span>struct se_cmd<em> *se_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_submit" title="Permalink to this definition">¶</a></dt>
<dd><p>perform final initialization and submit cmd to LIO core</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*se_cmd</span></code></dt><dd><p>command descriptor to submit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>target_submit_prep must have been called on the cmd, and this must be
called from process context.</p>
</div>
<dl class="function">
<dt id="c.target_submit_cmd">
void <code class="sig-name descname">target_submit_cmd</code><span class="sig-paren">(</span>struct se_cmd<em> *se_cmd</em>, struct se_session<em> *se_sess</em>, unsigned char<em> *cdb</em>, unsigned char<em> *sense</em>, u64<em> unpacked_lun</em>, u32<em> data_length</em>, int<em> task_attr</em>, int<em> data_dir</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_submit_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup unpacked lun and submit uninitialized se_cmd</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*se_cmd</span></code></dt><dd><p>command descriptor to submit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*se_sess</span></code></dt><dd><p>associated se_sess for endpoint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*cdb</span></code></dt><dd><p>pointer to SCSI CDB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*sense</span></code></dt><dd><p>pointer to SCSI sense buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">unpacked_lun</span></code></dt><dd><p>unpacked LUN to reference for struct se_lun</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">data_length</span></code></dt><dd><p>fabric expected data transfer length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">task_attr</span></code></dt><dd><p>SAM task attribute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">data_dir</span></code></dt><dd><p>DMA data direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags for command submission from target_sc_flags_tables</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Task tags are supported if the caller has set <strong>se_cmd-&gt;tag</strong>.</p>
<p>This may only be called from process context, and also currently
assumes internal allocation of fabric payload buffer by target-core.</p>
<p>It also assumes interal target core SGL memory allocation.</p>
<p>This function must only be used by drivers that do their own
sync during shutdown and does not use target_stop_session. If there
is a failure this function will call into the fabric driver’s
queue_status with a CHECK_CONDITION.</p>
</div>
<dl class="function">
<dt id="c.target_queue_submission">
void <code class="sig-name descname">target_queue_submission</code><span class="sig-paren">(</span>struct se_cmd<em> *se_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_queue_submission" title="Permalink to this definition">¶</a></dt>
<dd><p>queue the cmd to run on the LIO workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*se_cmd</span></code></dt><dd><p>command descriptor to submit</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.target_submit_tmr">
int <code class="sig-name descname">target_submit_tmr</code><span class="sig-paren">(</span>struct se_cmd<em> *se_cmd</em>, struct se_session<em> *se_sess</em>, unsigned char<em> *sense</em>, u64<em> unpacked_lun</em>, void<em> *fabric_tmr_ptr</em>, unsigned char<em> tm_type</em>, gfp_t<em> gfp</em>, u64<em> tag</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_submit_tmr" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup unpacked lun and submit uninitialized se_cmd for TMR CDBs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*se_cmd</span></code></dt><dd><p>command descriptor to submit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*se_sess</span></code></dt><dd><p>associated se_sess for endpoint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*sense</span></code></dt><dd><p>pointer to SCSI sense buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">unpacked_lun</span></code></dt><dd><p>unpacked LUN to reference for struct se_lun</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*fabric_tmr_ptr</span></code></dt><dd><p>fabric context for TMR req</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">tm_type</span></code></dt><dd><p>Type of TM request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>gfp type for caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">tag</span></code></dt><dd><p>referenced task tag for TMR_ABORT_TASK</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>submit cmd flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callable from all contexts.</p>
</div>
<dl class="function">
<dt id="c.target_get_sess_cmd">
int <code class="sig-name descname">target_get_sess_cmd</code><span class="sig-paren">(</span>struct se_cmd<em> *se_cmd</em>, bool<em> ack_kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_get_sess_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify the session is accepting cmds and take ref</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*se_cmd</span></code></dt><dd><p>command descriptor to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">ack_kref</span></code></dt><dd><p>Signal that fabric will perform an ack <a class="reference internal" href="#c.target_put_sess_cmd" title="target_put_sess_cmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">target_put_sess_cmd()</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.target_put_sess_cmd">
int <code class="sig-name descname">target_put_sess_cmd</code><span class="sig-paren">(</span>struct se_cmd<em> *se_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_put_sess_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>decrease the command reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*se_cmd</span></code></dt><dd><p>command to drop a reference from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 1 if and only if this <a class="reference internal" href="#c.target_put_sess_cmd" title="target_put_sess_cmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">target_put_sess_cmd()</span></code></a> call caused the
refcount to drop to zero. Returns zero otherwise.</p>
</div>
<dl class="function">
<dt id="c.target_stop_session">
void <code class="sig-name descname">target_stop_session</code><span class="sig-paren">(</span>struct se_session<em> *se_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_stop_session" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop new IO from being queued on the session.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*se_sess</span></code></dt><dd><p>session to stop</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.target_wait_for_sess_cmds">
void <code class="sig-name descname">target_wait_for_sess_cmds</code><span class="sig-paren">(</span>struct se_session<em> *se_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_wait_for_sess_cmds" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for outstanding commands</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*se_sess</span></code></dt><dd><p>session to wait for active I/O</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.transport_wait_for_tasks">
bool <code class="sig-name descname">transport_wait_for_tasks</code><span class="sig-paren">(</span>struct se_cmd<em> *cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_wait_for_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>set CMD_T_STOP and wait for t_transport_stop_comp</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*cmd</span></code></dt><dd><p>command to wait on</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.target_send_busy">
int <code class="sig-name descname">target_send_busy</code><span class="sig-paren">(</span>struct se_cmd<em> *cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_send_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>Send SCSI BUSY status back to the initiator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*cmd</span></code></dt><dd><p>SCSI command for which to send a BUSY reply.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>Only call this function if target_submit_cmd*() failed.</p>
</div>
</section>
<section id="target-supported-userspace-i-o">
<h2>Target-supported userspace I/O<a class="headerlink" href="#target-supported-userspace-i-o" title="Permalink to this headline">¶</a></h2>
<section id="userspace-i-o">
<h3>Userspace I/O<a class="headerlink" href="#userspace-i-o" title="Permalink to this headline">¶</a></h3>
<p>Define a shared-memory interface for LIO to pass SCSI commands and
data to userspace for processing. This is to allow backends that
are too complex for in-kernel support to be possible.</p>
<p>It uses the UIO framework to do a lot of the device-creation and
introspection work for us.</p>
<p>See the .h file for how the ring is laid out. Note that while the
command ring is defined, the particulars of the data area are
not. Offset values in the command entry point to other locations
internal to the mmap-ed area. There is separate space outside the
command ring for data buffers. This leaves maximum flexibility for
moving buffer allocations, or even page flipping or other
allocation techniques, without altering the command ring layout.</p>
<p>SECURITY:
The user process must be assumed to be malicious. There’s no way to
prevent it breaking the command ring protocol if it wants, but in
order to prevent other issues we must only ever read <em>data</em> from
the shared memory area, not offsets or sizes. This applies to
command ring entries as well as the mailbox. Extra code needed for
this may have a ‘UAM’ comment.</p>
</section>
<section id="ring-design">
<h3>Ring Design<a class="headerlink" href="#ring-design" title="Permalink to this headline">¶</a></h3>
<p>The mmaped area is divided into three parts:
1) The mailbox (struct tcmu_mailbox, below);
2) The command ring;
3) Everything beyond the command ring (data).</p>
<p>The mailbox tells userspace the offset of the command ring from the
start of the shared memory region, and how big the command ring is.</p>
<p>The kernel passes SCSI commands to userspace by putting a struct
tcmu_cmd_entry in the ring, updating mailbox-&gt;cmd_head, and poking
userspace via UIO’s interrupt mechanism.</p>
<p>tcmu_cmd_entry contains a header. If the header type is PAD,
userspace should skip hdr-&gt;length bytes (mod cmdr_size) to find the
next cmd_entry.</p>
<p>Otherwise, the entry will contain offsets into the mmaped area that
contain the cdb and data buffers – the latter accessible via the
iov array. iov addresses are also offsets into the shared area.</p>
<p>When userspace is completed handling the command, set
entry-&gt;rsp.scsi_status, fill in rsp.sense_buffer if appropriate,
and also set mailbox-&gt;cmd_tail equal to the old cmd_tail plus
hdr-&gt;length, mod cmdr_size. If cmd_tail doesn’t equal cmd_head, it
should process the next packet the same way, and so on.</p>
</section>
</section>
<section id="iscsi-helper-functions">
<h2>iSCSI helper functions<a class="headerlink" href="#iscsi-helper-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.iscsi_prep_data_out_pdu">
void <code class="sig-name descname">iscsi_prep_data_out_pdu</code><span class="sig-paren">(</span>struct iscsi_task<em> *task</em>, struct iscsi_r2t_info<em> *r2t</em>, struct iscsi_data<em> *hdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_prep_data_out_pdu" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize Data-Out</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*task</span></code></dt><dd><p>scsi command task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_r2t_info</span> <span class="pre">*r2t</span></code></dt><dd><p>R2T info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_data</span> <span class="pre">*hdr</span></code></dt><dd><p>iscsi data in pdu</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>Initialize Data-Out within this R2T sequence and finds
proper data_offset within this SCSI command.</p>
<p>This function is called with connection lock taken.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.__iscsi_put_task">
void <code class="sig-name descname">__iscsi_put_task</code><span class="sig-paren">(</span>struct iscsi_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__iscsi_put_task" title="Permalink to this definition">¶</a></dt>
<dd><p>drop the refcount on a task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*task</span></code></dt><dd><p>iscsi_task to drop the refcount on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The back_lock must be held when calling in case it frees the task.</p>
</div>
<dl class="function">
<dt id="c.iscsi_complete_scsi_task">
void <code class="sig-name descname">iscsi_complete_scsi_task</code><span class="sig-paren">(</span>struct iscsi_task<em> *task</em>, uint32_t<em> exp_cmdsn</em>, uint32_t<em> max_cmdsn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_complete_scsi_task" title="Permalink to this definition">¶</a></dt>
<dd><p>finish scsi task normally</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*task</span></code></dt><dd><p>iscsi task for scsi cmd</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">exp_cmdsn</span></code></dt><dd><p>expected cmd sn in cpu format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">max_cmdsn</span></code></dt><dd><p>max cmd sn in cpu format</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used when drivers do not need or cannot perform
lower level pdu processing.</p>
<p>Called with session back_lock</p>
</div>
<dl class="function">
<dt id="c.iscsi_itt_to_task">
struct iscsi_task * <code class="sig-name descname">iscsi_itt_to_task</code><span class="sig-paren">(</span>struct iscsi_conn<em> *conn</em>, itt_t<em> itt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_itt_to_task" title="Permalink to this definition">¶</a></dt>
<dd><p>look up task by itt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi connection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">itt_t</span> <span class="pre">itt</span></code></dt><dd><p>itt</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be used for mgmt tasks like login and nops, or if
the LDD’s itt space does not include the session age.</p>
<p>The session back_lock must be held.</p>
</div>
<dl class="function">
<dt id="c.__iscsi_complete_pdu">
int <code class="sig-name descname">__iscsi_complete_pdu</code><span class="sig-paren">(</span>struct iscsi_conn<em> *conn</em>, struct iscsi_hdr<em> *hdr</em>, char<em> *data</em>, int<em> datalen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__iscsi_complete_pdu" title="Permalink to this definition">¶</a></dt>
<dd><p>complete pdu</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi conn</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_hdr</span> <span class="pre">*hdr</span></code></dt><dd><p>iscsi header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*data</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">datalen</span></code></dt><dd><p>len of data buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Completes pdu processing by freeing any resources allocated at
queuecommand or send generic. session back_lock must be held and verify
itt must have been called.</p>
</div>
<dl class="function">
<dt id="c.iscsi_itt_to_ctask">
struct iscsi_task * <code class="sig-name descname">iscsi_itt_to_ctask</code><span class="sig-paren">(</span>struct iscsi_conn<em> *conn</em>, itt_t<em> itt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_itt_to_ctask" title="Permalink to this definition">¶</a></dt>
<dd><p>look up ctask by itt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi connection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">itt_t</span> <span class="pre">itt</span></code></dt><dd><p>itt</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be used for cmd tasks.</p>
<p>The session back_lock must be held.</p>
</div>
<dl class="function">
<dt id="c.iscsi_requeue_task">
void <code class="sig-name descname">iscsi_requeue_task</code><span class="sig-paren">(</span>struct iscsi_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_requeue_task" title="Permalink to this definition">¶</a></dt>
<dd><p>requeue task to run from session workqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*task</span></code></dt><dd><p>task to requeue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callers must have taken a ref to the task that is going to be requeued.</p>
</div>
<dl class="function">
<dt id="c.iscsi_suspend_queue">
void <code class="sig-name descname">iscsi_suspend_queue</code><span class="sig-paren">(</span>struct iscsi_conn<em> *conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_suspend_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>suspend iscsi_queuecommand</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi conn to stop queueing IO on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This grabs the session frwd_lock to make sure no one is in
xmit_task/queuecommand, and then sets suspend to prevent
new commands from being queued. This only needs to be called
by offload drivers that need to sync a path like ep disconnect
with the iscsi_queuecommand/xmit_task. To start IO again libiscsi
will call iscsi_start_tx and iscsi_unblock_session when in FFP.</p>
</div>
<dl class="function">
<dt id="c.iscsi_suspend_tx">
void <code class="sig-name descname">iscsi_suspend_tx</code><span class="sig-paren">(</span>struct iscsi_conn<em> *conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_suspend_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>suspend iscsi_data_xmit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi conn to stop processing IO on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets the suspend bit to prevent iscsi_data_xmit
from sending new IO, and if work is queued on the xmit thread
it will wait for it to be completed.</p>
</div>
<dl class="function">
<dt id="c.iscsi_suspend_rx">
void <code class="sig-name descname">iscsi_suspend_rx</code><span class="sig-paren">(</span>struct iscsi_conn<em> *conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_suspend_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Prevent recvwork from running again.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi conn to stop.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iscsi_conn_unbind">
void <code class="sig-name descname">iscsi_conn_unbind</code><span class="sig-paren">(</span>struct iscsi_cls_conn<em> *cls_conn</em>, bool<em> is_active</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_conn_unbind" title="Permalink to this definition">¶</a></dt>
<dd><p>prevent queueing to conn.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*cls_conn</span></code></dt><dd><p>iscsi conn ep is bound to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_active</span></code></dt><dd><p>is the conn in use for boot or is this for EH/termination</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called by drivers implementing the ep_disconnect callout.
It disables queueing to the connection from libiscsi in preparation for
an ep_disconnect call.</p>
</div>
<dl class="function">
<dt id="c.iscsi_eh_session_reset">
int <code class="sig-name descname">iscsi_eh_session_reset</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *sc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_eh_session_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>drop session and attempt relogin</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*sc</span></code></dt><dd><p>scsi command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will wait for a relogin, session termination from
userspace, or a recovery/replacement timeout.</p>
</div>
<dl class="function">
<dt id="c.iscsi_eh_recover_target">
int <code class="sig-name descname">iscsi_eh_recover_target</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *sc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_eh_recover_target" title="Permalink to this definition">¶</a></dt>
<dd><p>reset target and possibly the session</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*sc</span></code></dt><dd><p>scsi command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will attempt to send a warm target reset. If that fails,
we will escalate to ERL0 session recovery.</p>
</div>
<dl class="function">
<dt id="c.iscsi_host_add">
int <code class="sig-name descname">iscsi_host_add</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_host_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add host to system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*pdev</span></code></dt><dd><p>parent device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called by partial offload and software iscsi drivers
to add a host to the system.</p>
</div>
<dl class="function">
<dt id="c.iscsi_host_alloc">
struct Scsi_Host * <code class="sig-name descname">iscsi_host_alloc</code><span class="sig-paren">(</span>struct scsi_host_template<em> *sht</em>, int<em> dd_data_size</em>, bool<em> xmit_can_sleep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_host_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a host and driver data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*sht</span></code></dt><dd><p>scsi host template</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_data_size</span></code></dt><dd><p>driver host data size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">xmit_can_sleep</span></code></dt><dd><p>bool indicating if LLD will queue IO from a work queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called by partial offload and software iscsi drivers.
To access the driver specific memory use the iscsi_host_priv() macro.</p>
</div>
<dl class="function">
<dt id="c.iscsi_host_remove">
void <code class="sig-name descname">iscsi_host_remove</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, bool<em> is_shutdown</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_host_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove host and sessions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_shutdown</span></code></dt><dd><p>true if called from a driver shutdown callout</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If there are any sessions left, this will initiate the removal and wait
for the completion.</p>
</div>
<dl class="function">
<dt id="c.iscsi_session_setup">
struct iscsi_cls_session * <code class="sig-name descname">iscsi_session_setup</code><span class="sig-paren">(</span>struct iscsi_transport<em> *iscsit</em>, struct Scsi_Host<em> *shost</em>, uint16_t<em> cmds_max</em>, int<em> dd_size</em>, int<em> cmd_task_size</em>, uint32_t<em> initial_cmdsn</em>, unsigned int<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_session_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>create iscsi cls session and host and session</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*iscsit</span></code></dt><dd><p>iscsi transport template</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">cmds_max</span></code></dt><dd><p>session can queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>private driver data size, added to session allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd_task_size</span></code></dt><dd><p>LLD task private data size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">initial_cmdsn</span></code></dt><dd><p>initial CmdSN</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>target ID to add to this session</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used by software iscsi_transports that allocate
a session per scsi host.</p>
<p>Callers should set cmds_max to the largest total numer (mgmt + scsi) of
tasks they support. The iscsi layer reserves ISCSI_MGMT_CMDS_MAX tasks
for nop handling and login/logout requests.</p>
</div>
<dl class="function">
<dt id="c.iscsi_session_teardown">
void <code class="sig-name descname">iscsi_session_teardown</code><span class="sig-paren">(</span>struct iscsi_cls_session<em> *cls_session</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_session_teardown" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy session, host, and cls_session</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*cls_session</span></code></dt><dd><p>iscsi session</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iscsi_conn_setup">
struct iscsi_cls_conn * <code class="sig-name descname">iscsi_conn_setup</code><span class="sig-paren">(</span>struct iscsi_cls_session<em> *cls_session</em>, int<em> dd_size</em>, uint32_t<em> conn_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_conn_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>create iscsi_cls_conn and iscsi_conn</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*cls_session</span></code></dt><dd><p>iscsi_cls_session</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>private driver data size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">conn_idx</span></code></dt><dd><p>cid</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iscsi_conn_teardown">
void <code class="sig-name descname">iscsi_conn_teardown</code><span class="sig-paren">(</span>struct iscsi_cls_conn<em> *cls_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_conn_teardown" title="Permalink to this definition">¶</a></dt>
<dd><p>teardown iscsi connection</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*cls_conn</span></code></dt><dd><p>iscsi class connection</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>TODO: we may need to make this into a two step process
like scsi-mls remove + put host</p>
</div>
</section>
<section id="iscsi-boot-information">
<h2>iSCSI boot information<a class="headerlink" href="#iscsi-boot-information" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.iscsi_boot_create_target">
struct iscsi_boot_kobj * <code class="sig-name descname">iscsi_boot_create_target</code><span class="sig-paren">(</span>struct iscsi_boot_kset<em> *boot_kset</em>, int<em> index</em>, void<em> *data</em>, ssize_t (<em>*show</em>)(void *data, int type, char *buf), umode_t (*is_visible) (void *data, int type), void (*release) (void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_target" title="Permalink to this definition">¶</a></dt>
<dd><p>create boot target sysfs dir</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_boot_kset</span> <span class="pre">*boot_kset</span></code></dt><dd><p>boot kset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>the target id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>driver specific data for target</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">(*show)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">char</span> <span class="pre">*buf)</span></code></dt><dd><p>attr show function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">(*is_visible)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type)</span></code></dt><dd><p>attr visibility function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*release)</span> <span class="pre">(void</span> <span class="pre">*data)</span></code></dt><dd><p>release function</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>The boot sysfs lib will free the data passed in for the caller
when all refs to the target kobject have been released.</p>
</div>
<dl class="function">
<dt id="c.iscsi_boot_create_initiator">
struct iscsi_boot_kobj * <code class="sig-name descname">iscsi_boot_create_initiator</code><span class="sig-paren">(</span>struct iscsi_boot_kset<em> *boot_kset</em>, int<em> index</em>, void<em> *data</em>, ssize_t (<em>*show</em>)(void *data, int type, char *buf), umode_t (*is_visible) (void *data, int type), void (*release) (void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_initiator" title="Permalink to this definition">¶</a></dt>
<dd><p>create boot initiator sysfs dir</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_boot_kset</span> <span class="pre">*boot_kset</span></code></dt><dd><p>boot kset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>the initiator id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>driver specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">(*show)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">char</span> <span class="pre">*buf)</span></code></dt><dd><p>attr show function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">(*is_visible)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type)</span></code></dt><dd><p>attr visibility function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*release)</span> <span class="pre">(void</span> <span class="pre">*data)</span></code></dt><dd><p>release function</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>The boot sysfs lib will free the data passed in for the caller
when all refs to the initiator kobject have been released.</p>
</div>
<dl class="function">
<dt id="c.iscsi_boot_create_ethernet">
struct iscsi_boot_kobj * <code class="sig-name descname">iscsi_boot_create_ethernet</code><span class="sig-paren">(</span>struct iscsi_boot_kset<em> *boot_kset</em>, int<em> index</em>, void<em> *data</em>, ssize_t (<em>*show</em>)(void *data, int type, char *buf), umode_t (*is_visible) (void *data, int type), void (*release) (void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_ethernet" title="Permalink to this definition">¶</a></dt>
<dd><p>create boot ethernet sysfs dir</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_boot_kset</span> <span class="pre">*boot_kset</span></code></dt><dd><p>boot kset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>the ethernet device id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>driver specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">(*show)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">char</span> <span class="pre">*buf)</span></code></dt><dd><p>attr show function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">(*is_visible)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type)</span></code></dt><dd><p>attr visibility function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*release)</span> <span class="pre">(void</span> <span class="pre">*data)</span></code></dt><dd><p>release function</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>The boot sysfs lib will free the data passed in for the caller
when all refs to the ethernet kobject have been released.</p>
</div>
<dl class="function">
<dt id="c.iscsi_boot_create_acpitbl">
struct iscsi_boot_kobj * <code class="sig-name descname">iscsi_boot_create_acpitbl</code><span class="sig-paren">(</span>struct iscsi_boot_kset<em> *boot_kset</em>, int<em> index</em>, void<em> *data</em>, ssize_t (<em>*show</em>)(void *data, int type, char *buf), umode_t (*is_visible)(void *data, int type), void (*release)(void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_acpitbl" title="Permalink to this definition">¶</a></dt>
<dd><p>create boot acpi table sysfs dir</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_boot_kset</span> <span class="pre">*boot_kset</span></code></dt><dd><p>boot kset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>not used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>driver specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">(*show)(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">char</span> <span class="pre">*buf)</span></code></dt><dd><p>attr show function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">umode_t</span> <span class="pre">(*is_visible)(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type)</span></code></dt><dd><p>attr visibility function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*release)(void</span> <span class="pre">*data)</span></code></dt><dd><p>release function</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>The boot sysfs lib will free the data passed in for the caller
when all refs to the acpitbl kobject have been released.</p>
</div>
<dl class="function">
<dt id="c.iscsi_boot_create_kset">
struct iscsi_boot_kset * <code class="sig-name descname">iscsi_boot_create_kset</code><span class="sig-paren">(</span>const char<em> *set_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_kset" title="Permalink to this definition">¶</a></dt>
<dd><p>creates root sysfs tree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*set_name</span></code></dt><dd><p>name of root dir</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iscsi_boot_create_host_kset">
struct iscsi_boot_kset * <code class="sig-name descname">iscsi_boot_create_host_kset</code><span class="sig-paren">(</span>unsigned int<em> hostno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_host_kset" title="Permalink to this definition">¶</a></dt>
<dd><p>creates root sysfs tree for a scsi host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hostno</span></code></dt><dd><p>host number of scsi host</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iscsi_boot_destroy_kset">
void <code class="sig-name descname">iscsi_boot_destroy_kset</code><span class="sig-paren">(</span>struct iscsi_boot_kset<em> *boot_kset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_destroy_kset" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy kset and kobjects under it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_boot_kset</span> <span class="pre">*boot_kset</span></code></dt><dd><p>boot kset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will remove the kset and kobjects and attrs under it.</p>
</div>
</section>
<section id="iscsi-tcp-interfaces">
<h2>iSCSI TCP interfaces<a class="headerlink" href="#iscsi-tcp-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.iscsi_sw_tcp_recv">
int <code class="sig-name descname">iscsi_sw_tcp_recv</code><span class="sig-paren">(</span>read_descriptor_t<em> *rd_desc</em>, struct <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> offset</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_tcp_recv" title="Permalink to this definition">¶</a></dt>
<dd><p>TCP receive in sendfile fashion</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">read_descriptor_t</span> <span class="pre">*rd_desc</span></code></dt><dd><p>read descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>socket buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>skb-&gt;len - offset</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iscsi_sw_sk_state_check">
int <code class="sig-name descname">iscsi_sw_sk_state_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../networking/kapi.html#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_sk_state_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check socket state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the socket is in CLOSE or CLOSE_WAIT we should
not close the connection if there is still some
data pending.</p>
<p>Must be called with sk_callback_lock.</p>
</div>
<dl class="function">
<dt id="c.iscsi_sw_tcp_write_space">
void <code class="sig-name descname">iscsi_sw_tcp_write_space</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../networking/kapi.html#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_tcp_write_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when more output buffer space is available</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket space is available for</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iscsi_sw_tcp_xmit_segment">
int <code class="sig-name descname">iscsi_sw_tcp_xmit_segment</code><span class="sig-paren">(</span>struct iscsi_tcp_conn<em> *tcp_conn</em>, struct iscsi_segment<em> *segment</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_tcp_xmit_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit segment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_tcp_conn</span> <span class="pre">*tcp_conn</span></code></dt><dd><p>the iSCSI TCP connection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_segment</span> <span class="pre">*segment</span></code></dt><dd><p>the buffer to transmnit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function transmits as much of the buffer as
the network layer will accept, and returns the number of
bytes transmitted.</p>
<p>If CRC hashing is enabled, the function will compute the
hash as it goes. When the entire segment has been transmitted,
it will retrieve the hash value and send it as well.</p>
</div>
<dl class="function">
<dt id="c.iscsi_sw_tcp_xmit">
int <code class="sig-name descname">iscsi_sw_tcp_xmit</code><span class="sig-paren">(</span>struct iscsi_conn<em> *conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_tcp_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>TCP transmit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi connection</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iscsi_sw_tcp_xmit_qlen">
int <code class="sig-name descname">iscsi_sw_tcp_xmit_qlen</code><span class="sig-paren">(</span>struct iscsi_conn<em> *conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_tcp_xmit_qlen" title="Permalink to this definition">¶</a></dt>
<dd><p>return the number of bytes queued for xmit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi connection</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iscsi_tcp_segment_done">
int <code class="sig-name descname">iscsi_tcp_segment_done</code><span class="sig-paren">(</span>struct iscsi_tcp_conn<em> *tcp_conn</em>, struct iscsi_segment<em> *segment</em>, int<em> recv</em>, unsigned<em> copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_segment_done" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the segment is complete</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_tcp_conn</span> <span class="pre">*tcp_conn</span></code></dt><dd><p>iscsi tcp connection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_segment</span> <span class="pre">*segment</span></code></dt><dd><p>iscsi segment to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">recv</span></code></dt><dd><p>set to one of this is called from the recv path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">copied</span></code></dt><dd><p>number of bytes copied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if we’re done receiving this segment. If the receive
buffer is full but we expect more data, move on to the
next entry in the scatterlist.</p>
<p>If the amount of data we received isn’t a multiple of 4,
we will transparently receive the pad bytes, too.</p>
<p>This function must be re-entrant.</p>
</div>
<dl class="function">
<dt id="c.iscsi_tcp_hdr_recv_prep">
void <code class="sig-name descname">iscsi_tcp_hdr_recv_prep</code><span class="sig-paren">(</span>struct iscsi_tcp_conn<em> *tcp_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_hdr_recv_prep" title="Permalink to this definition">¶</a></dt>
<dd><p>prep segment for hdr reception</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_tcp_conn</span> <span class="pre">*tcp_conn</span></code></dt><dd><p>iscsi connection to prep for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function always passes NULL for the hash argument, because when this
function is called we do not yet know the final size of the header and want
to delay the digest processing until we know that.</p>
</div>
<dl class="function">
<dt id="c.iscsi_tcp_cleanup_task">
void <code class="sig-name descname">iscsi_tcp_cleanup_task</code><span class="sig-paren">(</span>struct iscsi_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_cleanup_task" title="Permalink to this definition">¶</a></dt>
<dd><p>free tcp_task resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*task</span></code></dt><dd><p>iscsi task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>must be called with session back_lock</p>
</div>
<dl class="function">
<dt id="c.iscsi_tcp_recv_segment_is_hdr">
int <code class="sig-name descname">iscsi_tcp_recv_segment_is_hdr</code><span class="sig-paren">(</span>struct iscsi_tcp_conn<em> *tcp_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_recv_segment_is_hdr" title="Permalink to this definition">¶</a></dt>
<dd><p>tests if we are reading in a header</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_tcp_conn</span> <span class="pre">*tcp_conn</span></code></dt><dd><p>iscsi tcp conn</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns non zero if we are currently processing or setup to process
a header.</p>
</div>
<dl class="function">
<dt id="c.iscsi_tcp_recv_skb">
int <code class="sig-name descname">iscsi_tcp_recv_skb</code><span class="sig-paren">(</span>struct iscsi_conn<em> *conn</em>, struct <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> offset</em>, bool<em> offloaded</em>, int<em> *status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_recv_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>Process skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi connection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>network buffer with header and/or data segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">offloaded</span></code></dt><dd><p>bool indicating if transfer was offloaded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*status</span></code></dt><dd><p>iscsi TCP status result</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will return status of transfer in <strong>status</strong>. And will return
number of bytes copied.</p>
</div>
<dl class="function">
<dt id="c.iscsi_tcp_task_init">
int <code class="sig-name descname">iscsi_tcp_task_init</code><span class="sig-paren">(</span>struct iscsi_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_task_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize iSCSI SCSI_READ or SCSI_WRITE commands</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*task</span></code></dt><dd><p>scsi command task</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iscsi_tcp_task_xmit">
int <code class="sig-name descname">iscsi_tcp_task_xmit</code><span class="sig-paren">(</span>struct iscsi_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_task_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>xmit normal PDU task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*task</span></code></dt><dd><p>iscsi command task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We’re expected to return 0 when everything was transmitted successfully,
-EAGAIN if there’s still data in the queue, or != 0 for any other kind
of error.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">target and iSCSI Interfaces Guide</a><ul>
<li><a class="reference internal" href="#introduction-and-overview">Introduction and Overview</a></li>
<li><a class="reference internal" href="#target-core-device-interfaces">Target core device interfaces</a></li>
<li><a class="reference internal" href="#target-core-transport-interfaces">Target core transport interfaces</a></li>
<li><a class="reference internal" href="#target-supported-userspace-i-o">Target-supported userspace I/O</a><ul>
<li><a class="reference internal" href="#userspace-i-o">Userspace I/O</a></li>
<li><a class="reference internal" href="#ring-design">Ring Design</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iscsi-helper-functions">iSCSI helper functions</a></li>
<li><a class="reference internal" href="#iscsi-boot-information">iSCSI boot information</a></li>
<li><a class="reference internal" href="#iscsi-tcp-interfaces">iSCSI TCP interfaces</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/target.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/target.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>