
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>USB Gadget API for Linux &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="USB Anchors" href="anchors.html" />
    <link rel="prev" title="The Linux-USB Host Side API" href="usb.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="usb-gadget-api-for-linux">
<h1>USB Gadget API for Linux<a class="headerlink" href="#usb-gadget-api-for-linux" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>David Brownell</p>
</dd>
<dt class="field-even">Date</dt>
<dd class="field-even"><p>20 August 2004</p>
</dd>
</dl>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document presents a Linux-USB “Gadget” kernel mode API, for use
within peripherals and other USB devices that embed Linux. It provides
an overview of the API structure, and shows how that fits into a system
development project. This is the first such API released on Linux to
address a number of important problems, including:</p>
<ul class="simple">
<li><p>Supports USB 2.0, for high speed devices which can stream data at
several dozen megabytes per second.</p></li>
<li><p>Handles devices with dozens of endpoints just as well as ones with
just two fixed-function ones. Gadget drivers can be written so
they’re easy to port to new hardware.</p></li>
<li><p>Flexible enough to expose more complex USB device capabilities such
as multiple configurations, multiple interfaces, composite devices,
and alternate interface settings.</p></li>
<li><p>USB “On-The-Go” (OTG) support, in conjunction with updates to the
Linux-USB host side.</p></li>
<li><p>Sharing data structures and API models with the Linux-USB host side
API. This helps the OTG support, and looks forward to more-symmetric
frameworks (where the same I/O model is used by both host and device
side drivers).</p></li>
<li><p>Minimalist, so it’s easier to support new device controller hardware.
I/O processing doesn’t imply large demands for memory or CPU
resources.</p></li>
</ul>
<p>Most Linux developers will not be able to use this API, since they have
USB <code class="docutils literal notranslate"><span class="pre">host</span></code> hardware in a PC, workstation, or server. Linux users with
embedded systems are more likely to have USB peripheral hardware. To
distinguish drivers running inside such hardware from the more familiar
Linux “USB device drivers”, which are host side proxies for the real USB
devices, a different term is used: the drivers inside the peripherals
are “USB gadget drivers”. In USB protocol interactions, the device
driver is the master (or “client driver”) and the gadget driver is the
slave (or “function driver”).</p>
<p>The gadget API resembles the host side Linux-USB API in that both use
queues of request objects to package I/O buffers, and those requests may
be submitted or canceled. They share common definitions for the standard
USB <em>Chapter 9</em> messages, structures, and constants. Also, both APIs
bind and unbind drivers to devices. The APIs differ in detail, since the
host side’s current URB framework exposes a number of implementation
details and assumptions that are inappropriate for a gadget API. While
the model for control transfers and configuration management is
necessarily different (one side is a hardware-neutral master, the other
is a hardware-aware slave), the endpoint I/0 API used here should also
be usable for an overhead-reduced host side API.</p>
</section>
<section id="structure-of-gadget-drivers">
<h2>Structure of Gadget Drivers<a class="headerlink" href="#structure-of-gadget-drivers" title="Permalink to this headline">¶</a></h2>
<p>A system running inside a USB peripheral normally has at least three
layers inside the kernel to handle USB protocol processing, and may have
additional layers in user space code. The <code class="docutils literal notranslate"><span class="pre">gadget</span></code> API is used by the
middle layer to interact with the lowest level (which directly handles
hardware).</p>
<p>In Linux, from the bottom up, these layers are:</p>
<dl>
<dt><em>USB Controller Driver</em></dt><dd><p>This is the lowest software level. It is the only layer that talks
to hardware, through registers, fifos, dma, irqs, and the like. The
<code class="docutils literal notranslate"><span class="pre">&lt;linux/usb/gadget.h&gt;</span></code> API abstracts the peripheral controller
endpoint hardware. That hardware is exposed through endpoint
objects, which accept streams of IN/OUT buffers, and through
callbacks that interact with gadget drivers. Since normal USB
devices only have one upstream port, they only have one of these
drivers. The controller driver can support any number of different
gadget drivers, but only one of them can be used at a time.</p>
<p>Examples of such controller hardware include the PCI-based NetChip
2280 USB 2.0 high speed controller, the SA-11x0 or PXA-25x UDC
(found within many PDAs), and a variety of other products.</p>
</dd>
<dt><em>Gadget Driver</em></dt><dd><p>The lower boundary of this driver implements hardware-neutral USB
functions, using calls to the controller driver. Because such
hardware varies widely in capabilities and restrictions, and is used
in embedded environments where space is at a premium, the gadget
driver is often configured at compile time to work with endpoints
supported by one particular controller. Gadget drivers may be
portable to several different controllers, using conditional
compilation. (Recent kernels substantially simplify the work
involved in supporting new hardware, by <em>autoconfiguring</em> endpoints
automatically for many bulk-oriented drivers.) Gadget driver
responsibilities include:</p>
<ul class="simple">
<li><p>handling setup requests (ep0 protocol responses) possibly
including class-specific functionality</p></li>
<li><p>returning configuration and string descriptors</p></li>
<li><p>(re)setting configurations and interface altsettings, including
enabling and configuring endpoints</p></li>
<li><p>handling life cycle events, such as managing bindings to
hardware, USB suspend/resume, remote wakeup, and disconnection
from the USB host.</p></li>
<li><p>managing IN and OUT transfers on all currently enabled endpoints</p></li>
</ul>
<p>Such drivers may be modules of proprietary code, although that
approach is discouraged in the Linux community.</p>
</dd>
<dt><em>Upper Level</em></dt><dd><p>Most gadget drivers have an upper boundary that connects to some
Linux driver or framework in Linux. Through that boundary flows the
data which the gadget driver produces and/or consumes through
protocol transfers over USB. Examples include:</p>
<ul class="simple">
<li><p>user mode code, using generic (gadgetfs) or application specific
files in <code class="docutils literal notranslate"><span class="pre">/dev</span></code></p></li>
<li><p>networking subsystem (for network gadgets, like the CDC Ethernet
Model gadget driver)</p></li>
<li><p>data capture drivers, perhaps video4Linux or a scanner driver; or
test and measurement hardware.</p></li>
<li><p>input subsystem (for HID gadgets)</p></li>
<li><p>sound subsystem (for audio gadgets)</p></li>
<li><p>file system (for PTP gadgets)</p></li>
<li><p>block i/o subsystem (for usb-storage gadgets)</p></li>
<li><p>… and more</p></li>
</ul>
</dd>
<dt><em>Additional Layers</em></dt><dd><p>Other layers may exist. These could include kernel layers, such as
network protocol stacks, as well as user mode applications building
on standard POSIX system call APIs such as <code class="docutils literal notranslate"><span class="pre">open()</span></code>, <code class="docutils literal notranslate"><span class="pre">close()</span></code>,
<code class="docutils literal notranslate"><span class="pre">read()</span></code> and <code class="docutils literal notranslate"><span class="pre">write()</span></code>. On newer systems, POSIX Async I/O calls may
be an option. Such user mode code will not necessarily be subject to
the GNU General Public License (GPL).</p>
</dd>
</dl>
<p>OTG-capable systems will also need to include a standard Linux-USB host
side stack, with <code class="docutils literal notranslate"><span class="pre">usbcore</span></code>, one or more <em>Host Controller Drivers</em>
(HCDs), <em>USB Device Drivers</em> to support the OTG “Targeted Peripheral
List”, and so forth. There will also be an <em>OTG Controller Driver</em>,
which is visible to gadget and device driver developers only indirectly.
That helps the host and device side USB controllers implement the two
new OTG protocols (HNP and SRP). Roles switch (host to peripheral, or
vice versa) using HNP during USB suspend processing, and SRP can be
viewed as a more battery-friendly kind of device wakeup protocol.</p>
<p>Over time, reusable utilities are evolving to help make some gadget
driver tasks simpler. For example, building configuration descriptors
from vectors of descriptors for the configurations interfaces and
endpoints is now automated, and many drivers now use autoconfiguration
to choose hardware endpoints and initialize their descriptors. A
potential example of particular interest is code implementing standard
USB-IF protocols for HID, networking, storage, or audio classes. Some
developers are interested in KDB or KGDB hooks, to let target hardware
be remotely debugged. Most such USB protocol code doesn’t need to be
hardware-specific, any more than network protocols like X11, HTTP, or
NFS are. Such gadget-side interface drivers should eventually be
combined, to implement composite devices.</p>
</section>
<section id="kernel-mode-gadget-api">
<h2>Kernel Mode Gadget API<a class="headerlink" href="#kernel-mode-gadget-api" title="Permalink to this headline">¶</a></h2>
<p>Gadget drivers declare themselves through a struct
<a class="reference internal" href="#c.usb_gadget_driver" title="usb_gadget_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">usb_gadget_driver</span></code></a>, which is responsible for most parts of enumeration
for a <a class="reference internal" href="#c.usb_gadget" title="usb_gadget"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span></code></a>. The response to a set_configuration usually
involves enabling one or more of the <a class="reference internal" href="#c.usb_ep" title="usb_ep"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_ep</span></code></a> objects exposed by
the gadget, and submitting one or more <a class="reference internal" href="#c.usb_request" title="usb_request"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_request</span></code></a> buffers to
transfer data. Understand those four data types, and their operations,
and you will understand how this API works.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Other than the “Chapter 9” data types, most of the significant data
types and functions are described here.</p>
<p>However, some relevant information is likely omitted from what you
are reading. One example of such information is endpoint
autoconfiguration. You’ll have to read the header file, and use
example source code (such as that for “Gadget Zero”), to fully
understand the API.</p>
<p>The part of the API implementing some basic driver capabilities is
specific to the version of the Linux kernel that’s in use. The 2.6
and upper kernel versions include a <em>driver model</em> framework that has
no analogue on earlier kernels; so those parts of the gadget API are
not fully portable. (They are implemented on 2.4 kernels, but in a
different way.) The driver model state is another part of this API that is
ignored by the kerneldoc tools.</p>
</div>
<p>The core API does not expose every possible hardware feature, only the
most widely available ones. There are significant hardware features,
such as device-to-device DMA (without temporary storage in a memory
buffer) that would be added using hardware-specific APIs.</p>
<p>This API allows drivers to use conditional compilation to handle
endpoint capabilities of different hardware, but doesn’t require that.
Hardware tends to have arbitrary restrictions, relating to transfer
types, addressing, packet sizes, buffering, and availability. As a rule,
such differences only matter for “endpoint zero” logic that handles
device configuration and management. The API supports limited run-time
detection of capabilities, through naming conventions for endpoints.
Many drivers will be able to at least partially autoconfigure
themselves. In particular, driver init sections will often have endpoint
autoconfiguration logic that scans the hardware’s list of endpoints to
find ones matching the driver requirements (relying on those
conventions), to eliminate some of the most common reasons for
conditional compilation.</p>
<p>Like the Linux-USB host side API, this API exposes the “chunky” nature
of USB messages: I/O requests are in terms of one or more “packets”, and
packet boundaries are visible to drivers. Compared to RS-232 serial
protocols, USB resembles synchronous protocols like HDLC (N bytes per
frame, multipoint addressing, host as the primary station and devices as
secondary stations) more than asynchronous ones (tty style: 8 data bits
per frame, no parity, one stop bit). So for example the controller
drivers won’t buffer two single byte writes into a single two-byte USB
IN packet, although gadget drivers may do so when they implement
protocols where packet boundaries (and “short packets”) are not
significant.</p>
<section id="driver-life-cycle">
<h3>Driver Life Cycle<a class="headerlink" href="#driver-life-cycle" title="Permalink to this headline">¶</a></h3>
<p>Gadget drivers make endpoint I/O requests to hardware without needing to
know many details of the hardware, but driver setup/configuration code
needs to handle some differences. Use the API like this:</p>
<ol class="arabic simple">
<li><p>Register a driver for the particular device side usb controller
hardware, such as the net2280 on PCI (USB 2.0), sa11x0 or pxa25x as
found in Linux PDAs, and so on. At this point the device is logically
in the USB ch9 initial state (<code class="docutils literal notranslate"><span class="pre">attached</span></code>), drawing no power and not
usable (since it does not yet support enumeration). Any host should
not see the device, since it’s not activated the data line pullup
used by the host to detect a device, even if VBUS power is available.</p></li>
<li><p>Register a gadget driver that implements some higher level device
function. That will then bind() to a <a class="reference internal" href="#c.usb_gadget" title="usb_gadget"><code class="xref c c-type docutils literal notranslate"><span class="pre">usb_gadget</span></code></a>, which activates
the data line pullup sometime after detecting VBUS.</p></li>
<li><p>The hardware driver can now start enumerating. The steps it handles
are to accept USB <code class="docutils literal notranslate"><span class="pre">power</span></code> and <code class="docutils literal notranslate"><span class="pre">set_address</span></code> requests. Other steps are
handled by the gadget driver. If the gadget driver module is unloaded
before the host starts to enumerate, steps before step 7 are skipped.</p></li>
<li><p>The gadget driver’s <code class="docutils literal notranslate"><span class="pre">setup()</span></code> call returns usb descriptors, based both
on what the bus interface hardware provides and on the functionality
being implemented. That can involve alternate settings or
configurations, unless the hardware prevents such operation. For OTG
devices, each configuration descriptor includes an OTG descriptor.</p></li>
<li><p>The gadget driver handles the last step of enumeration, when the USB
host issues a <code class="docutils literal notranslate"><span class="pre">set_configuration</span></code> call. It enables all endpoints used
in that configuration, with all interfaces in their default settings.
That involves using a list of the hardware’s endpoints, enabling each
endpoint according to its descriptor. It may also involve using
<code class="docutils literal notranslate"><span class="pre">usb_gadget_vbus_draw</span></code> to let more power be drawn from VBUS, as
allowed by that configuration. For OTG devices, setting a
configuration may also involve reporting HNP capabilities through a
user interface.</p></li>
<li><p>Do real work and perform data transfers, possibly involving changes
to interface settings or switching to new configurations, until the
device is disconnect()ed from the host. Queue any number of transfer
requests to each endpoint. It may be suspended and resumed several
times before being disconnected. On disconnect, the drivers go back
to step 3 (above).</p></li>
<li><p>When the gadget driver module is being unloaded, the driver unbind()
callback is issued. That lets the controller driver be unloaded.</p></li>
</ol>
<p>Drivers will normally be arranged so that just loading the gadget driver
module (or statically linking it into a Linux kernel) allows the
peripheral device to be enumerated, but some drivers will defer
enumeration until some higher level component (like a user mode daemon)
enables it. Note that at this lowest level there are no policies about
how ep0 configuration logic is implemented, except that it should obey
USB specifications. Such issues are in the domain of gadget drivers,
including knowing about implementation constraints imposed by some USB
controllers or understanding that composite devices might happen to be
built by integrating reusable components.</p>
<p>Note that the lifecycle above can be slightly different for OTG devices.
Other than providing an additional OTG descriptor in each configuration,
only the HNP-related differences are particularly visible to driver
code. They involve reporting requirements during the <code class="docutils literal notranslate"><span class="pre">SET_CONFIGURATION</span></code>
request, and the option to invoke HNP during some suspend callbacks.
Also, SRP changes the semantics of <code class="docutils literal notranslate"><span class="pre">usb_gadget_wakeup</span></code> slightly.</p>
</section>
<section id="usb-2-0-chapter-9-types-and-constants">
<h3>USB 2.0 Chapter 9 Types and Constants<a class="headerlink" href="#usb-2-0-chapter-9-types-and-constants" title="Permalink to this headline">¶</a></h3>
<p>Gadget drivers rely on common USB structures and constants defined in
the <a class="reference internal" href="usb.html#usb-chapter9"><span class="std std-ref">linux/usb/ch9.h</span></a> header file, which is standard in
Linux 2.6+ kernels. These are the same types and constants used by host side
drivers (and usbcore).</p>
</section>
<section id="core-objects-and-methods">
<h3>Core Objects and Methods<a class="headerlink" href="#core-objects-and-methods" title="Permalink to this headline">¶</a></h3>
<p>These are declared in <code class="docutils literal notranslate"><span class="pre">&lt;linux/usb/gadget.h&gt;</span></code>, and are used by gadget
drivers to interact with USB peripheral controller drivers.</p>
<dl class="type">
<dt id="c.usb_request">
struct <code class="sig-name descname">usb_request</code><a class="headerlink" href="#c.usb_request" title="Permalink to this definition">¶</a></dt>
<dd><p>describes one i/o request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_request {
    void *buf;
    unsigned length;
    dma_addr_t dma;
    struct scatterlist      *sg;
    unsigned num_sgs;
    unsigned num_mapped_sgs;
    unsigned stream_id:16;
    unsigned is_last:1;
    unsigned no_interrupt:1;
    unsigned zero:1;
    unsigned short_not_ok:1;
    unsigned dma_mapped:1;
    void (*complete)(struct usb_ep *ep, struct usb_request *req);
    void *context;
    struct list_head        list;
    unsigned frame_number;
    int status;
    unsigned actual;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>Buffer used for data.  Always provide this; some controllers
only use PIO, or don’t use DMA for some endpoints.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Length of that data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma</span></code></dt><dd><p>DMA address corresponding to ‘buf’.  If you don’t set this
field, and the usb controller needs one, it is responsible
for mapping and unmapping the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sg</span></code></dt><dd><p>a scatterlist for SG-capable controllers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_sgs</span></code></dt><dd><p>number of SG entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_mapped_sgs</span></code></dt><dd><p>number of SG entries mapped to DMA (internal)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream_id</span></code></dt><dd><p>The stream id, when USB3.0 bulk streams are being used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_last</span></code></dt><dd><p>Indicates if this is the last request of a stream_id before
switching to a different stream (required for DWC3 controllers).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">no_interrupt</span></code></dt><dd><p>If true, hints that no completion irq is needed.
Helpful sometimes with deep request queues that are handled
directly by DMA controllers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zero</span></code></dt><dd><p>If true, when writing data, makes the last packet be “short”
by adding a zero length packet as needed;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">short_not_ok</span></code></dt><dd><p>When reading data, makes short packets be
treated as errors (queue stops advancing till cleanup).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_mapped</span></code></dt><dd><p>Indicates if request has been mapped to DMA (internal)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">complete</span></code></dt><dd><p>Function called when request completes, so this request and
its buffer may be re-used.  The function will always be called with
interrupts disabled, and it must not sleep.
Reads terminate with a short packet, or when the buffer fills,
whichever comes first.  When writes terminate, some data bytes
will usually still be in flight (often in a hardware fifo).
Errors (for reads or writes) stop the queue from advancing
until the completion function returns, so that any transfers
invalidated by the error may first be dequeued.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">context</span></code></dt><dd><p>For use by the completion callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>For use by the gadget driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frame_number</span></code></dt><dd><p>Reports the interval number in (micro)frame in which the
isochronous transfer was transmitted or received.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>Reports completion code, zero or a negative errno.
Normally, faults block the transfer queue from advancing until
the completion callback returns.
Code “-ESHUTDOWN” indicates completion caused by device disconnect,
or when the driver disabled the endpoint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">actual</span></code></dt><dd><p>Reports bytes transferred to/from the buffer.  For reads (OUT
transfers) this may be less than the requested length.  If the
short_not_ok flag is set, short reads are treated as errors
even when status otherwise indicates successful completion.
Note that for writes (IN transfers) some data bytes may still
reside in a device-side FIFO when the request is reported as
complete.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These are allocated/freed through the endpoint they’re used with.  The
hardware’s driver can add extra per-request data to the memory it returns,
which often avoids separate memory allocations (potential failures),
later when the request is queued.</p>
<p>Request flags affect request handling, such as whether a zero length
packet is written (the “zero” flag), whether a short read should be
treated as an error (blocking request queue advance, the “short_not_ok”
flag), or hinting that an interrupt is not required (the “no_interrupt”
flag, for use with deep request queues).</p>
<p>Bulk endpoints can use any size buffers, and can also be used for interrupt
transfers. interrupt-only endpoints can be much less functional.</p>
<p><strong>NOTE</strong></p>
<p>this is analogous to ‘<a class="reference internal" href="usb.html#c.urb" title="urb"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">urb</span></code></a>’ on the host side, except that
it’s thinner and promotes more pre-allocation.</p>
<dl class="type">
<dt id="c.usb_ep_caps">
struct <code class="sig-name descname">usb_ep_caps</code><a class="headerlink" href="#c.usb_ep_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>endpoint capabilities description</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_ep_caps {
    unsigned type_control:1;
    unsigned type_iso:1;
    unsigned type_bulk:1;
    unsigned type_int:1;
    unsigned dir_in:1;
    unsigned dir_out:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type_control</span></code></dt><dd><p>Endpoint supports control type (reserved for ep0).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type_iso</span></code></dt><dd><p>Endpoint supports isochronous transfers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type_bulk</span></code></dt><dd><p>Endpoint supports bulk transfers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type_int</span></code></dt><dd><p>Endpoint supports interrupt transfers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dir_in</span></code></dt><dd><p>Endpoint supports IN direction.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dir_out</span></code></dt><dd><p>Endpoint supports OUT direction.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.usb_ep">
struct <code class="sig-name descname">usb_ep</code><a class="headerlink" href="#c.usb_ep" title="Permalink to this definition">¶</a></dt>
<dd><p>device side representation of USB endpoint</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_ep {
    void *driver_data;
    const char              *name;
    const struct usb_ep_ops *ops;
    struct list_head        ep_list;
    struct usb_ep_caps      caps;
    bool claimed;
    bool enabled;
    unsigned maxpacket:16;
    unsigned maxpacket_limit:16;
    unsigned max_streams:16;
    unsigned mult:2;
    unsigned maxburst:5;
    u8 address;
    const struct usb_endpoint_descriptor    *desc;
    const struct usb_ss_ep_comp_descriptor  *comp_desc;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>for use by the gadget driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>identifier for the endpoint, such as “ep-a” or “ep9in-bulk”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Function pointers used to access hardware-specific operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ep_list</span></code></dt><dd><p>the gadget’s ep_list holds all of its endpoints</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">caps</span></code></dt><dd><p>The structure describing types and directions supported by endpoint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">claimed</span></code></dt><dd><p>True if this endpoint is claimed by a function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled</span></code></dt><dd><p>The current endpoint enabled/disabled state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">maxpacket</span></code></dt><dd><p>The maximum packet size used on this endpoint.  The initial
value can sometimes be reduced (hardware allowing), according to
the endpoint descriptor used to configure the endpoint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">maxpacket_limit</span></code></dt><dd><p>The maximum packet size value which can be handled by this
endpoint. It’s set once by UDC driver when endpoint is initialized, and
should not be changed. Should not be confused with maxpacket.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_streams</span></code></dt><dd><p>The maximum number of streams supported
by this EP (0 - 16, actual number is 2^n)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mult</span></code></dt><dd><p>multiplier, ‘mult’ value for SS Isoc EPs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">maxburst</span></code></dt><dd><p>the maximum number of bursts supported by this EP (for usb3)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">address</span></code></dt><dd><p>used to identify the endpoint when finding descriptor that
matches connection speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">desc</span></code></dt><dd><p>endpoint descriptor.  This pointer is set before the endpoint is
enabled and remains valid until the endpoint is disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">comp_desc</span></code></dt><dd><p>In case of SuperSpeed support, this is the endpoint companion
descriptor that is used to configure the endpoint</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>the bus controller driver lists all the general purpose endpoints in
gadget-&gt;ep_list.  the control endpoint (gadget-&gt;ep0) is not in that list,
and is accessed only in response to a driver setup() callback.</p>
<dl class="type">
<dt id="c.usb_gadget">
struct <code class="sig-name descname">usb_gadget</code><a class="headerlink" href="#c.usb_gadget" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a usb device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_gadget {
    struct work_struct              work;
    struct usb_udc                  *udc;
    const struct usb_gadget_ops     *ops;
    struct usb_ep                   *ep0;
    struct list_head                ep_list;
    enum usb_device_speed           speed;
    enum usb_device_speed           max_speed;
    enum usb_ssp_rate               ssp_rate;
    enum usb_ssp_rate               max_ssp_rate;
    enum usb_device_state           state;
    const char                      *name;
    struct device                   dev;
    unsigned isoch_delay;
    unsigned out_epnum;
    unsigned in_epnum;
    unsigned mA;
    struct usb_otg_caps             *otg_caps;
    unsigned sg_supported:1;
    unsigned is_otg:1;
    unsigned is_a_peripheral:1;
    unsigned b_hnp_enable:1;
    unsigned a_hnp_support:1;
    unsigned a_alt_hnp_support:1;
    unsigned hnp_polling_support:1;
    unsigned host_request_flag:1;
    unsigned quirk_ep_out_aligned_size:1;
    unsigned quirk_altset_not_supp:1;
    unsigned quirk_stall_not_supp:1;
    unsigned quirk_zlp_not_supp:1;
    unsigned quirk_avoids_skb_reserve:1;
    unsigned is_selfpowered:1;
    unsigned deactivated:1;
    unsigned connected:1;
    unsigned lpm_capable:1;
    int irq;
    int id_number;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>(internal use) Workqueue to be used for sysfs_notify()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">udc</span></code></dt><dd><p>struct usb_udc pointer for this gadget</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Function pointers used to access hardware-specific operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ep0</span></code></dt><dd><p>Endpoint zero, used when reading or writing responses to
driver setup() requests</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ep_list</span></code></dt><dd><p>List of other endpoints supported by the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">speed</span></code></dt><dd><p>Speed of current connection to USB host.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_speed</span></code></dt><dd><p>Maximal speed the UDC can handle.  UDC must support this
and all slower speeds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssp_rate</span></code></dt><dd><p>Current connected SuperSpeed Plus signaling rate and lane count.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_ssp_rate</span></code></dt><dd><p>Maximum SuperSpeed Plus signaling rate and lane count the UDC
can handle. The UDC must support this and all slower speeds and lower
number of lanes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>the state we are now (attached, suspended, configured, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Identifies the controller hardware type.  Used in diagnostics
and sometimes configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Driver model state for this abstract device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isoch_delay</span></code></dt><dd><p>value from Set Isoch Delay request. Only valid on SS/SSP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_epnum</span></code></dt><dd><p>last used out ep number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in_epnum</span></code></dt><dd><p>last used in ep number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mA</span></code></dt><dd><p>last set mA value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">otg_caps</span></code></dt><dd><p>OTG capabilities of this gadget.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sg_supported</span></code></dt><dd><p>true if we can handle scatter-gather</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_otg</span></code></dt><dd><p>True if the USB device port uses a Mini-AB jack, so that the
gadget driver must provide a USB OTG descriptor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_a_peripheral</span></code></dt><dd><p>False unless is_otg, the “A” end of a USB cable
is in the Mini-AB jack, and HNP has been used to switch roles
so that the “A” device currently acts as A-Peripheral, not A-Host.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b_hnp_enable</span></code></dt><dd><p>OTG device feature flag, indicating that the A-Host
enabled HNP support.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">a_hnp_support</span></code></dt><dd><p>OTG device feature flag, indicating that the A-Host
supports HNP at this port.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">a_alt_hnp_support</span></code></dt><dd><p>OTG device feature flag, indicating that the A-Host
only supports HNP on a different root port.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hnp_polling_support</span></code></dt><dd><p>OTG device feature flag, indicating if the OTG device
in peripheral mode can support HNP polling.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">host_request_flag</span></code></dt><dd><p>OTG device feature flag, indicating if A-Peripheral
or B-Peripheral wants to take host role.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quirk_ep_out_aligned_size</span></code></dt><dd><p>epout requires buffer size to be aligned to
MaxPacketSize.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quirk_altset_not_supp</span></code></dt><dd><p>UDC controller doesn’t support alt settings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quirk_stall_not_supp</span></code></dt><dd><p>UDC controller doesn’t support stalling.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quirk_zlp_not_supp</span></code></dt><dd><p>UDC controller doesn’t support ZLP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quirk_avoids_skb_reserve</span></code></dt><dd><p>udc/platform wants to avoid <a class="reference internal" href="../../networking/kapi.html#c.skb_reserve" title="skb_reserve"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_reserve()</span></code></a> in
u_ether.c to improve performance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_selfpowered</span></code></dt><dd><p>if the gadget is self-powered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deactivated</span></code></dt><dd><p>True if gadget is deactivated - in deactivated state it cannot
be connected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connected</span></code></dt><dd><p>True if gadget is connected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lpm_capable</span></code></dt><dd><p>If the gadget max_speed is FULL or HIGH, this flag
indicates that it supports LPM as per the LPM ECN &amp; errata.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>the interrupt number for device controller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id_number</span></code></dt><dd><p>a unique ID number for ensuring that gadget names are distinct</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Gadgets have a mostly-portable “gadget driver” implementing device
functions, handling all usb configurations and interfaces.  Gadget
drivers talk to hardware-specific code indirectly, through ops vectors.
That insulates the gadget driver from hardware details, and packages
the hardware endpoints through generic i/o queues.  The “usb_gadget”
and “usb_ep” interfaces provide that insulation from the hardware.</p>
<p>Except for the driver data, all fields in this structure are
read-only to the gadget driver.  That driver data is part of the
“driver model” infrastructure in 2.6 (and later) kernels, and for
earlier systems is grouped in a similar structure that’s not known
to the rest of the kernel.</p>
<p>Values of the three OTG device feature flags are updated before the
setup() call corresponding to USB_REQ_SET_CONFIGURATION, and before
driver suspend() calls.  They are valid only when is_otg, and when the
device is acting as a B-Peripheral (so is_a_peripheral is false).</p>
<dl class="function">
<dt id="c.usb_ep_align">
size_t <code class="sig-name descname">usb_ep_align</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_ep" title="usb_ep">usb_ep</a><em> *ep</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_ep_align" title="Permalink to this definition">¶</a></dt>
<dd><p>returns <strong>len</strong> aligned to ep’s maxpacketsize.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_ep</span> <span class="pre">*ep</span></code></dt><dd><p>the endpoint whose maxpacketsize is used to align <strong>len</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>buffer size’s length to align to <strong>ep</strong>’s maxpacketsize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper is used to align buffer’s size to an ep’s maxpacketsize.</p>
</div>
<dl class="function">
<dt id="c.usb_ep_align_maybe">
size_t <code class="sig-name descname">usb_ep_align_maybe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a><em> *g</em>, struct <a class="reference internal" href="#c.usb_ep" title="usb_ep">usb_ep</a><em> *ep</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_ep_align_maybe" title="Permalink to this definition">¶</a></dt>
<dd><p>returns <strong>len</strong> aligned to ep’s maxpacketsize if gadget requires quirk_ep_out_aligned_size, otherwise returns len.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*g</span></code></dt><dd><p>controller to check for quirk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_ep</span> <span class="pre">*ep</span></code></dt><dd><p>the endpoint whose maxpacketsize is used to align <strong>len</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>buffer size’s length to align to <strong>ep</strong>’s maxpacketsize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper is used in case it’s required for any reason to check and maybe
align buffer’s size to an ep’s maxpacketsize.</p>
</div>
<dl class="function">
<dt id="c.gadget_is_altset_supported">
int <code class="sig-name descname">gadget_is_altset_supported</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a><em> *g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_altset_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware supports altsettings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*g</span></code></dt><dd><p>controller to check for quirk</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gadget_is_stall_supported">
int <code class="sig-name descname">gadget_is_stall_supported</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a><em> *g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_stall_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware supports stalling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*g</span></code></dt><dd><p>controller to check for quirk</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gadget_is_zlp_supported">
int <code class="sig-name descname">gadget_is_zlp_supported</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a><em> *g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_zlp_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware supports zlp</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*g</span></code></dt><dd><p>controller to check for quirk</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gadget_avoids_skb_reserve">
int <code class="sig-name descname">gadget_avoids_skb_reserve</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a><em> *g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_avoids_skb_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware would like to avoid skb_reserve to improve performance.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*g</span></code></dt><dd><p>controller to check for quirk</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gadget_is_dualspeed">
int <code class="sig-name descname">gadget_is_dualspeed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a><em> *g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_dualspeed" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware handles high speed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*g</span></code></dt><dd><p>controller that might support both high and full speeds</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gadget_is_superspeed">
int <code class="sig-name descname">gadget_is_superspeed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a><em> *g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_superspeed" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if the hardware handles superspeed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*g</span></code></dt><dd><p>controller that might support superspeed</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gadget_is_superspeed_plus">
int <code class="sig-name descname">gadget_is_superspeed_plus</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a><em> *g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_superspeed_plus" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if the hardware handles superspeed plus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*g</span></code></dt><dd><p>controller that might support superspeed plus</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gadget_is_otg">
int <code class="sig-name descname">gadget_is_otg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a><em> *g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_otg" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware is OTG-ready</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*g</span></code></dt><dd><p>controller that might have a Mini-AB connector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a runtime test, since kernels with a USB-OTG stack sometimes
run on boards which only have a Mini-B (or Mini-A) connector.</p>
</div>
<dl class="type">
<dt id="c.usb_gadget_driver">
struct <code class="sig-name descname">usb_gadget_driver</code><a class="headerlink" href="#c.usb_gadget_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>driver for usb gadget devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_gadget_driver {
    char *function;
    enum usb_device_speed   max_speed;
    int (*bind)(struct usb_gadget *gadget, struct usb_gadget_driver *driver);
    void (*unbind)(struct usb_gadget *);
    int (*setup)(struct usb_gadget *, const struct usb_ctrlrequest *);
    void (*disconnect)(struct usb_gadget *);
    void (*suspend)(struct usb_gadget *);
    void (*resume)(struct usb_gadget *);
    void (*reset)(struct usb_gadget *);
    struct device_driver    driver;
    char *udc_name;
    unsigned match_existing_only:1;
    bool is_bound:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">function</span></code></dt><dd><p>String describing the gadget’s function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_speed</span></code></dt><dd><p>Highest speed the driver handles.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bind</span></code></dt><dd><p>the driver’s bind callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unbind</span></code></dt><dd><p>Invoked when the driver is unbound from a gadget,
usually from rmmod (after a disconnect is reported).
Called in a context that permits sleeping.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup</span></code></dt><dd><p>Invoked for ep0 control requests that aren’t handled by
the hardware level driver. Most calls must be handled by
the gadget driver, including descriptor and configuration
management.  The 16 bit members of the setup data are in
USB byte order. Called in_interrupt; this may not sleep.  Driver
queues a response to ep0, or returns negative to stall.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disconnect</span></code></dt><dd><p>Invoked after all transfers have been stopped,
when the host is disconnected.  May be called in_interrupt; this
may not sleep.  Some devices can’t detect disconnect, so this might
not be called except as part of controller shutdown.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Invoked on USB suspend.  May be called in_interrupt.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Invoked on USB resume.  May be called in_interrupt.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset</span></code></dt><dd><p>Invoked on USB bus reset. It is mandatory for all gadget drivers
and should be called in_interrupt.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>Driver model state for this driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">udc_name</span></code></dt><dd><p>A name of UDC this driver should be bound to. If udc_name is NULL,
this driver will be bound to any available UDC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">match_existing_only</span></code></dt><dd><p>If udc is not found, return an error and fail
the driver registration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_bound</span></code></dt><dd><p>Allow a driver to be bound to only one gadget</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Devices are disabled till a gadget driver successfully bind()s, which
means the driver will handle setup() requests needed to enumerate (and
meet “chapter 9” requirements) then do some useful work.</p>
<p>If gadget-&gt;is_otg is true, the gadget driver must provide an OTG
descriptor during enumeration, or else fail the bind() call.  In such
cases, no USB traffic may flow until both bind() returns without
having called usb_gadget_disconnect(), and the USB host stack has
initialized.</p>
<p>Drivers use hardware-specific knowledge to configure the usb hardware.
endpoint addressing is only one of several hardware characteristics that
are in descriptors the ep0 implementation returns from setup() calls.</p>
<p>Except for ep0 implementation, most driver code shouldn’t need change to
run on top of different usb controllers.  It’ll use endpoints set up by
that ep0 implementation.</p>
<p>The usb controller driver handles a few standard usb requests.  Those
include set_address, and feature flags for devices, interfaces, and
endpoints (the get_status, set_feature, and clear_feature requests).</p>
<p>Accordingly, the driver’s setup() callback must always implement all
get_descriptor requests, returning at least a device descriptor and
a configuration descriptor.  Drivers must make sure the endpoint
descriptors match any hardware constraints. Some hardware also constrains
other descriptors. (The pxa250 allows only configurations 1, 2, or 3).</p>
<p>The driver’s setup() callback must also implement set_configuration,
and should also implement set_interface, get_configuration, and
get_interface.  Setting a configuration (or interface) is where
endpoints should be activated or (config 0) shut down.</p>
<p>(Note that only the default control endpoint is supported.  Neither
hosts nor devices generally support control traffic except to ep0.)</p>
<p>Most devices will ignore USB suspend/resume operations, and so will
not provide those callbacks.  However, some may need to change modes
when the host is not longer directing those activities.  For example,
local controls (buttons, dials, etc) may need to be re-enabled since
the (remote) host can’t do that any longer; or an error state might
be cleared, to make the device behave identically whether or not
power is maintained.</p>
<dl class="function">
<dt id="c.usb_gadget_register_driver_owner">
int <code class="sig-name descname">usb_gadget_register_driver_owner</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget_driver" title="usb_gadget_driver">usb_gadget_driver</a><em> *driver</em>, struct module<em> *owner</em>, const char<em> *mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_gadget_register_driver_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>register a gadget driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the driver being registered</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>the driver module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>the driver module’s build name</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Call this in your gadget driver’s module initialization function,
to tell the underlying UDC controller driver about your driver.
The <strong>bind()</strong> function will be called to bind it to a gadget before this
registration call returns.  It’s expected that the <strong>bind()</strong> function will
be in init sections.</p>
<p>Use the macro defined below instead of calling this directly.</p>
</div>
<dl class="function">
<dt id="c.usb_gadget_unregister_driver">
int <code class="sig-name descname">usb_gadget_unregister_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget_driver" title="usb_gadget_driver">usb_gadget_driver</a><em> *driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_gadget_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a gadget driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the driver being unregistered</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Call this in your gadget driver’s module cleanup function,
to tell the underlying usb controller that your driver is
going away.  If the controller is connected to a USB host,
it will first disconnect().  The driver is also requested
to unbind() and clean up any device state, before this procedure
finally returns.  It’s expected that the unbind() functions
will be in exit sections, so may not be linked in some kernels.</p>
</div>
<dl class="type">
<dt id="c.usb_string">
struct <code class="sig-name descname">usb_string</code><a class="headerlink" href="#c.usb_string" title="Permalink to this definition">¶</a></dt>
<dd><p>wraps a C string and its USB id</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_string {
    u8 id;
    const char              *s;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>the (nonzero) ID for this string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code></dt><dd><p>the string, in UTF-8 encoding</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If you’re using <a class="reference internal" href="#c.usb_gadget_get_string" title="usb_gadget_get_string"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_gadget_get_string()</span></code></a>, use this to wrap a string
together with its ID.</p>
<dl class="type">
<dt id="c.usb_gadget_strings">
struct <code class="sig-name descname">usb_gadget_strings</code><a class="headerlink" href="#c.usb_gadget_strings" title="Permalink to this definition">¶</a></dt>
<dd><p>a set of USB strings in a given language</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_gadget_strings {
    u16 language;
    struct usb_string       *strings;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">language</span></code></dt><dd><p>identifies the strings’ language (0x0409 for en-us)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">strings</span></code></dt><dd><p>array of strings with their ids</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If you’re using <a class="reference internal" href="#c.usb_gadget_get_string" title="usb_gadget_get_string"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_gadget_get_string()</span></code></a>, use this to wrap all the
strings for a given language.</p>
<dl class="function">
<dt id="c.usb_free_descriptors">
void <code class="sig-name descname">usb_free_descriptors</code><span class="sig-paren">(</span>struct usb_descriptor_header<em> **v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_free_descriptors" title="Permalink to this definition">¶</a></dt>
<dd><p>free descriptors returned by <a class="reference internal" href="#c.usb_copy_descriptors" title="usb_copy_descriptors"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_copy_descriptors()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_descriptor_header</span> <span class="pre">**v</span></code></dt><dd><p>vector of descriptors</p>
</dd>
</dl>
</div>
</section>
<section id="optional-utilities">
<h3>Optional Utilities<a class="headerlink" href="#optional-utilities" title="Permalink to this headline">¶</a></h3>
<p>The core API is sufficient for writing a USB Gadget Driver, but some
optional utilities are provided to simplify common tasks. These
utilities include endpoint autoconfiguration.</p>
<dl class="function">
<dt id="c.usb_gadget_get_string">
int <code class="sig-name descname">usb_gadget_get_string</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.usb_gadget_strings" title="usb_gadget_strings">usb_gadget_strings</a><em> *table</em>, int<em> id</em>, u8<em> *buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_gadget_get_string" title="Permalink to this definition">¶</a></dt>
<dd><p>fill out a string descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">usb_gadget_strings</span> <span class="pre">*table</span></code></dt><dd><p>of c strings encoded using UTF-8</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>string id, from low byte of wValue in get string descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>at least 256 bytes, must be 16-bit aligned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the UTF-8 string matching the ID, and converts it into a
string descriptor in utf16-le.
Returns length of descriptor (always even) or negative errno</p>
<p>If your driver needs stings in multiple languages, you’ll probably
“switch (wIndex) { … }”  in your ep0 string descriptor logic,
using this routine after choosing which set of UTF-8 strings to use.
Note that US-ASCII is a strict subset of UTF-8; any string bytes with
the eighth bit set will be multibyte UTF-8 characters, not ISO-8859/1
characters (which are also widely used in C strings).</p>
</div>
<dl class="function">
<dt id="c.usb_validate_langid">
bool <code class="sig-name descname">usb_validate_langid</code><span class="sig-paren">(</span>u16<em> langid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_validate_langid" title="Permalink to this definition">¶</a></dt>
<dd><p>validate usb language identifiers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">langid</span></code></dt><dd><p>usb language identifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true for valid language identifier, otherwise false.</p>
</div>
<dl class="function">
<dt id="c.usb_descriptor_fillbuf">
int <code class="sig-name descname">usb_descriptor_fillbuf</code><span class="sig-paren">(</span>void<em> *buf</em>, unsigned<em> buflen</em>, const struct usb_descriptor_header<em> **src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_descriptor_fillbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>fill buffer with descriptors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer to be filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">buflen</span></code></dt><dd><p>Size of buf</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">usb_descriptor_header</span> <span class="pre">**src</span></code></dt><dd><p>Array of descriptor pointers, terminated by null pointer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies descriptors into the buffer, returning the length or a
negative error code if they can’t all be copied.  Useful when
assembling descriptors for an associated set of interfaces used
as part of configuring a composite device; or in other cases where
sets of descriptors need to be marshaled.</p>
</div>
<dl class="function">
<dt id="c.usb_gadget_config_buf">
int <code class="sig-name descname">usb_gadget_config_buf</code><span class="sig-paren">(</span>const struct usb_config_descriptor<em> *config</em>, void<em> *buf</em>, unsigned<em> length</em>, const struct usb_descriptor_header<em> **desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_gadget_config_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>builts a complete configuration descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">usb_config_descriptor</span> <span class="pre">*config</span></code></dt><dd><p>Header for the descriptor, including characteristics such
as power requirements and number of interfaces.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer for the resulting configuration descriptor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">length</span></code></dt><dd><p>Length of buffer.  If this is not big enough to hold the
entire configuration descriptor, an error code will be returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">usb_descriptor_header</span> <span class="pre">**desc</span></code></dt><dd><p>Null-terminated vector of pointers to the descriptors (interface,
endpoint, etc) defining all functions in this device configuration.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This copies descriptors into the response buffer, building a descriptor
for that configuration.  It returns the buffer length or a negative
status code.  The config.wTotalLength field is set to match the length
of the result, but other descriptor fields (including power usage and
interface count) must be set by the caller.</p>
<p>Gadget drivers could use this when constructing a config descriptor
in response to USB_REQ_GET_DESCRIPTOR.  They will need to patch the
resulting bDescriptorType value if USB_DT_OTHER_SPEED_CONFIG is needed.</p>
</div>
<dl class="function">
<dt id="c.usb_copy_descriptors">
struct usb_descriptor_header ** <code class="sig-name descname">usb_copy_descriptors</code><span class="sig-paren">(</span>struct usb_descriptor_header<em> **src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_copy_descriptors" title="Permalink to this definition">¶</a></dt>
<dd><p>copy a vector of USB descriptors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_descriptor_header</span> <span class="pre">**src</span></code></dt><dd><p>null-terminated vector to copy</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>initialization code, which may sleep</p>
<p><strong>Description</strong></p>
<p>This makes a copy of a vector of USB descriptors.  Its primary use
is to support usb_function objects which can have multiple copies,
each needing different descriptors.  Functions may have static
tables of descriptors, which are used as templates and customized
with identifiers (for interfaces, strings, endpoints, and more)
as needed by a given function instance.</p>
</div>
</section>
<section id="composite-device-framework">
<h3>Composite Device Framework<a class="headerlink" href="#composite-device-framework" title="Permalink to this headline">¶</a></h3>
<p>The core API is sufficient for writing drivers for composite USB devices
(with more than one function in a given configuration), and also
multi-configuration devices (also more than one function, but not
necessarily sharing a given configuration). There is however an optional
framework which makes it easier to reuse and combine functions.</p>
<p>Devices using this framework provide a <a class="reference internal" href="#c.usb_composite_driver" title="usb_composite_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_composite_driver</span></code></a>,
which in turn provides one or more <a class="reference internal" href="#c.usb_configuration" title="usb_configuration"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_configuration</span></code></a>
instances. Each such configuration includes at least one struct
<a class="reference internal" href="#c.usb_function" title="usb_function"><code class="xref c c-type docutils literal notranslate"><span class="pre">usb_function</span></code></a>, which packages a user visible role such as “network
link” or “mass storage device”. Management functions may also exist,
such as “Device Firmware Upgrade”.</p>
<dl class="type">
<dt id="c.usb_os_desc_ext_prop">
struct <code class="sig-name descname">usb_os_desc_ext_prop</code><a class="headerlink" href="#c.usb_os_desc_ext_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>describes one “Extended Property”</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_os_desc_ext_prop {
    struct list_head        entry;
    u8 type;
    int name_len;
    char *name;
    int data_len;
    char *data;
    struct config_item      item;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>used to keep a list of extended properties</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Extended Property type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name_len</span></code></dt><dd><p>Extended Property unicode name length, including terminating ‘0’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Extended Property name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_len</span></code></dt><dd><p>Length of Extended Property blob (for unicode store double len)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Extended Property blob</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">item</span></code></dt><dd><p>Represents this Extended Property in configfs</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.usb_os_desc">
struct <code class="sig-name descname">usb_os_desc</code><a class="headerlink" href="#c.usb_os_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>describes OS descriptors associated with one interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_os_desc {
    char *ext_compat_id;
    struct list_head        ext_prop;
    int ext_prop_len;
    int ext_prop_count;
    struct mutex            *opts_mutex;
    struct config_group     group;
    struct module           *owner;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ext_compat_id</span></code></dt><dd><p>16 bytes of “Compatible ID” and “Subcompatible ID”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext_prop</span></code></dt><dd><p>Extended Properties list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext_prop_len</span></code></dt><dd><p>Total length of Extended Properties blobs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext_prop_count</span></code></dt><dd><p>Number of Extended Properties</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">opts_mutex</span></code></dt><dd><p>Optional mutex protecting config data of a usb_function_instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">group</span></code></dt><dd><p>Represents OS descriptors associated with an interface in configfs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>Module associated with this OS descriptor</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.usb_os_desc_table">
struct <code class="sig-name descname">usb_os_desc_table</code><a class="headerlink" href="#c.usb_os_desc_table" title="Permalink to this definition">¶</a></dt>
<dd><p>describes OS descriptors associated with one interface of a usb_function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_os_desc_table {
    int if_id;
    struct usb_os_desc      *os_desc;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">if_id</span></code></dt><dd><p>Interface id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">os_desc</span></code></dt><dd><p>“Extended Compatibility ID” and “Extended Properties” of the
interface</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Each interface can have at most one “Extended Compatibility ID” and a
number of “Extended Properties”.</p>
<dl class="type">
<dt id="c.usb_function">
struct <code class="sig-name descname">usb_function</code><a class="headerlink" href="#c.usb_function" title="Permalink to this definition">¶</a></dt>
<dd><p>describes one function of a configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_function {
    const char                      *name;
    struct usb_gadget_strings       **strings;
    struct usb_descriptor_header    **fs_descriptors;
    struct usb_descriptor_header    **hs_descriptors;
    struct usb_descriptor_header    **ss_descriptors;
    struct usb_descriptor_header    **ssp_descriptors;
    struct usb_configuration        *config;
    struct usb_os_desc_table        *os_desc_table;
    unsigned os_desc_n;
    int (*bind)(struct usb_configuration *, struct usb_function *);
    void (*unbind)(struct usb_configuration *, struct usb_function *);
    void (*free_func)(struct usb_function *f);
    struct module           *mod;
    int (*set_alt)(struct usb_function *, unsigned interface, unsigned alt);
    int (*get_alt)(struct usb_function *, unsigned interface);
    void (*disable)(struct usb_function *);
    int (*setup)(struct usb_function *, const struct usb_ctrlrequest *);
    bool (*req_match)(struct usb_function *,const struct usb_ctrlrequest *, bool config0);
    void (*suspend)(struct usb_function *);
    void (*resume)(struct usb_function *);
    int (*get_status)(struct usb_function *);
    int (*func_suspend)(struct usb_function *, u8 suspend_opt);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>For diagnostics, identifies the function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">strings</span></code></dt><dd><p>tables of strings, keyed by identifiers assigned during bind()
and by language IDs provided in control requests</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fs_descriptors</span></code></dt><dd><p>Table of full (or low) speed descriptors, using interface and
string identifiers assigned during <strong>bind()</strong>.  If this pointer is null,
the function will not be available at full speed (or at low speed).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hs_descriptors</span></code></dt><dd><p>Table of high speed descriptors, using interface and
string identifiers assigned during <strong>bind()</strong>.  If this pointer is null,
the function will not be available at high speed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ss_descriptors</span></code></dt><dd><p>Table of super speed descriptors, using interface and
string identifiers assigned during <strong>bind()</strong>. If this
pointer is null after initiation, the function will not
be available at super speed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssp_descriptors</span></code></dt><dd><p>Table of super speed plus descriptors, using
interface and string identifiers assigned during <strong>bind()</strong>. If
this pointer is null after initiation, the function will not
be available at super speed plus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config</span></code></dt><dd><p>assigned when <strong><a class="reference internal" href="#c.usb_add_function" title="usb_add_function"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_add_function()</span></code></a></strong> is called; this is the
configuration with which this function is associated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">os_desc_table</span></code></dt><dd><p>Table of (interface id, os descriptors) pairs. The function
can expose more than one interface. If an interface is a member of
an IAD, only the first interface of IAD has its entry in the table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">os_desc_n</span></code></dt><dd><p>Number of entries in os_desc_table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bind</span></code></dt><dd><p>Before the gadget can register, all of its functions bind() to the
available resources including string and interface identifiers used
in interface or class descriptors; endpoints; I/O buffers; and so on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unbind</span></code></dt><dd><p>Reverses <strong>bind</strong>; called as a side effect of unregistering the
driver which added this function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_func</span></code></dt><dd><p>free the <a class="reference internal" href="#c.usb_function" title="usb_function"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_function</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mod</span></code></dt><dd><p>(internal) points to the module that created this structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_alt</span></code></dt><dd><p>(REQUIRED) Reconfigures altsettings; function drivers may
initialize usb_ep.driver data at this time (when it is used).
Note that setting an interface to its current altsetting resets
interface state, and that all interfaces have a disabled state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_alt</span></code></dt><dd><p>Returns the active altsetting.  If this is not provided,
then only altsetting zero is supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>(REQUIRED) Indicates the function should be disabled.  Reasons
include host resetting or reconfiguring the gadget, and disconnection.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup</span></code></dt><dd><p>Used for interface-specific control requests.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_match</span></code></dt><dd><p>Tests if a given class request can be handled by this function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Notifies functions when the host stops sending USB traffic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Notifies functions when the host restarts USB traffic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_status</span></code></dt><dd><p>Returns function status as a reply to
GetStatus() request when the recipient is Interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">func_suspend</span></code></dt><dd><p>callback to be called when
SetFeature(FUNCTION_SUSPEND) is reseived</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A single USB function uses one or more interfaces, and should in most
cases support operation at both full and high speeds.  Each function is
associated by <strong><a class="reference internal" href="#c.usb_add_function" title="usb_add_function"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_add_function()</span></code></a></strong> with a one configuration; that function
causes <strong>bind()</strong> to be called so resources can be allocated as part of
setting up a gadget driver.  Those resources include endpoints, which
should be allocated using <strong>usb_ep_autoconfig()</strong>.</p>
<p>To support dual speed operation, a function driver provides descriptors
for both high and full speed operation.  Except in rare cases that don’t
involve bulk endpoints, each speed needs different endpoint descriptors.</p>
<p>Function drivers choose their own strategies for managing instance data.
The simplest strategy just declares it “static’, which means the function
can only be activated once.  If the function needs to be exposed in more
than one configuration at a given speed, it needs to support multiple
usb_function structures (one for each configuration).</p>
<p>A more complex strategy might encapsulate a <strong>usb_function</strong> structure inside
a driver-specific instance structure to allows multiple activations.  An
example of multiple activations might be a CDC ACM function that supports
two or more distinct instances within the same configuration, providing
several independent logical data links to a USB host.</p>
<dl class="type">
<dt id="c.usb_configuration">
struct <code class="sig-name descname">usb_configuration</code><a class="headerlink" href="#c.usb_configuration" title="Permalink to this definition">¶</a></dt>
<dd><p>represents one gadget configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_configuration {
    const char                      *label;
    struct usb_gadget_strings       **strings;
    const struct usb_descriptor_header **descriptors;
    void (*unbind)(struct usb_configuration *);
    int (*setup)(struct usb_configuration *, const struct usb_ctrlrequest *);
    u8 bConfigurationValue;
    u8 iConfiguration;
    u8 bmAttributes;
    u16 MaxPower;
    struct usb_composite_dev        *cdev;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">label</span></code></dt><dd><p>For diagnostics, describes the configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">strings</span></code></dt><dd><p>Tables of strings, keyed by identifiers assigned during <strong>bind()</strong>
and by language IDs provided in control requests.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">descriptors</span></code></dt><dd><p>Table of descriptors preceding all function descriptors.
Examples include OTG and vendor-specific descriptors.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unbind</span></code></dt><dd><p>Reverses <strong>bind</strong>; called as a side effect of unregistering the
driver which added this configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup</span></code></dt><dd><p>Used to delegate control requests that aren’t handled by standard
device infrastructure or directed at a specific interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bConfigurationValue</span></code></dt><dd><p>Copied into configuration descriptor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iConfiguration</span></code></dt><dd><p>Copied into configuration descriptor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bmAttributes</span></code></dt><dd><p>Copied into configuration descriptor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MaxPower</span></code></dt><dd><p>Power consumption in mA. Used to compute bMaxPower in the
configuration descriptor after considering the bus speed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cdev</span></code></dt><dd><p>assigned by <strong><a class="reference internal" href="#c.usb_add_config" title="usb_add_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_add_config()</span></code></a></strong> before calling <strong>bind()</strong>; this is
the device associated with this configuration.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Configurations are building blocks for gadget drivers structured around
function drivers.  Simple USB gadgets require only one function and one
configuration, and handle dual-speed hardware by always providing the same
functionality.  Slightly more complex gadgets may have more than one
single-function configuration at a given speed; or have configurations
that only work at one speed.</p>
<p>Composite devices are, by definition, ones with configurations which
include more than one function.</p>
<p>The lifecycle of a usb_configuration includes allocation, initialization
of the fields described above, and calling <strong><a class="reference internal" href="#c.usb_add_config" title="usb_add_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_add_config()</span></code></a></strong> to set up
internal data and bind it to a specific device.  The configuration’s
<strong>bind()</strong> method is then used to initialize all the functions and then
call <strong><a class="reference internal" href="#c.usb_add_function" title="usb_add_function"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_add_function()</span></code></a></strong> for them.</p>
<p>Those functions would normally be independent of each other, but that’s
not mandatory.  CDC WMC devices are an example where functions often
depend on other functions, with some functions subsidiary to others.
Such interdependency may be managed in any way, so long as all of the
descriptors complete by the time the composite driver returns from
its bind() routine.</p>
<dl class="type">
<dt id="c.usb_composite_driver">
struct <code class="sig-name descname">usb_composite_driver</code><a class="headerlink" href="#c.usb_composite_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>groups configurations into a gadget</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_composite_driver {
    const char                              *name;
    const struct usb_device_descriptor      *dev;
    struct usb_gadget_strings               **strings;
    enum usb_device_speed                   max_speed;
    unsigned needs_serial:1;
    int (*bind)(struct usb_composite_dev *cdev);
    int (*unbind)(struct usb_composite_dev *);
    void (*disconnect)(struct usb_composite_dev *);
    void (*suspend)(struct usb_composite_dev *);
    void (*resume)(struct usb_composite_dev *);
    struct usb_gadget_driver                gadget_driver;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>For diagnostics, identifies the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Template descriptor for the device, including default device
identifiers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">strings</span></code></dt><dd><p>tables of strings, keyed by identifiers assigned during <strong>bind</strong>
and language IDs provided in control requests. Note: The first entries
are predefined. The first entry that may be used is
USB_GADGET_FIRST_AVAIL_IDX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_speed</span></code></dt><dd><p>Highest speed the driver supports.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needs_serial</span></code></dt><dd><p>set to 1 if the gadget needs userspace to provide
a serial number.  If one is not provided, warning will be printed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bind</span></code></dt><dd><p>(REQUIRED) Used to allocate resources that are shared across the
whole device, such as string IDs, and add its configurations using
<strong><a class="reference internal" href="#c.usb_add_config" title="usb_add_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_add_config()</span></code></a></strong>. This may fail by returning a negative errno
value; it should return zero on successful initialization.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unbind</span></code></dt><dd><p>Reverses <strong>bind</strong>; called as a side effect of unregistering
this driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disconnect</span></code></dt><dd><p>optional driver disconnect method</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Notifies when the host stops sending USB traffic,
after function notifications</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Notifies configuration when the host restarts USB traffic,
before function notifications</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gadget_driver</span></code></dt><dd><p>Gadget driver controlling this driver</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Devices default to reporting self powered operation.  Devices which rely
on bus powered operation should report this in their <strong>bind</strong> method.</p>
<p>Before returning from <strong>bind</strong>, various fields in the template descriptor
may be overridden.  These include the idVendor/idProduct/bcdDevice values
normally to bind the appropriate host side driver, and the three strings
(iManufacturer, iProduct, iSerialNumber) normally used to provide user
meaningful device identifiers.  (The strings will not be defined unless
they are defined in <strong>dev</strong> and <strong>strings</strong>.)  The correct ep0 maxpacket size
is also reported, as defined by the underlying controller driver.</p>
<dl class="function">
<dt id="c.module_usb_composite_driver">
<code class="sig-name descname">module_usb_composite_driver</code><span class="sig-paren">(</span><em>__usb_composite_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_usb_composite_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a USB gadget composite driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__usb_composite_driver</span></code></dt><dd><p>usb_composite_driver struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for USB gadget composite drivers which do not do anything
special in module init/exit. This eliminates a lot of boilerplate. Each
module may only use this macro once, and calling it replaces <a class="reference internal" href="../basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a>
and <a class="reference internal" href="../basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a></p>
</div>
<dl class="type">
<dt id="c.usb_composite_dev">
struct <code class="sig-name descname">usb_composite_dev</code><a class="headerlink" href="#c.usb_composite_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>represents one composite usb gadget</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_composite_dev {
    struct usb_gadget               *gadget;
    struct usb_request              *req;
    struct usb_request              *os_desc_req;
    struct usb_configuration        *config;
    u8 qw_sign[OS_STRING_QW_SIGN_LEN];
    u8 b_vendor_code;
    struct usb_configuration        *os_desc_config;
    unsigned int                    use_os_string:1;
    unsigned int                    setup_pending:1;
    unsigned int                    os_desc_pending:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gadget</span></code></dt><dd><p>read-only, abstracts the gadget’s usb peripheral controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req</span></code></dt><dd><p>used for control responses; buffer is pre-allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">os_desc_req</span></code></dt><dd><p>used for OS descriptors responses; buffer is pre-allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config</span></code></dt><dd><p>the currently active configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qw_sign</span></code></dt><dd><p>qwSignature part of the OS string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b_vendor_code</span></code></dt><dd><p>bMS_VendorCode part of the OS string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">os_desc_config</span></code></dt><dd><p>the configuration to be used with OS descriptors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_os_string</span></code></dt><dd><p>false by default, interested gadgets set it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup_pending</span></code></dt><dd><p>true when setup request is queued but not completed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">os_desc_pending</span></code></dt><dd><p>true when os_desc request is queued but not completed</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>One of these devices is allocated and initialized before the
associated device driver’s bind() is called.</p>
<p>OPEN ISSUE:  it appears that some WUSB devices will need to be
built by combining a normal (wired) gadget with a wireless one.
This revision of the gadget framework should probably try to make
sure doing that won’t hurt too much.</p>
<p>One notion for how to handle Wireless USB devices involves:</p>
<ol class="loweralpha simple">
<li><p>a second gadget here, discovery mechanism TBD, but likely
needing separate “register/unregister WUSB gadget” calls;</p></li>
<li><p>updates to usb_gadget to include flags “is it wireless”,
“is it wired”, plus (presumably in a wrapper structure)
bandgroup and PHY info;</p></li>
<li><p>presumably a wireless_ep wrapping a usb_ep, and reporting
wireless-specific parameters like maxburst and maxsequence;</p></li>
<li><p>configurations that are specific to wireless links;</p></li>
<li><p>function drivers that understand wireless configs and will
support wireless for (additional) function instances;</p></li>
<li><p>a function to support association setup (like CBAF), not
necessarily requiring a wireless adapter;</p></li>
<li><p>composite device setup that can create one or more wireless
configs, including appropriate association setup support;</p></li>
<li><p>more, TBD.</p></li>
</ol>
<dl class="function">
<dt id="c.config_ep_by_speed_and_alt">
int <code class="sig-name descname">config_ep_by_speed_and_alt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a><em> *g</em>, struct <a class="reference internal" href="#c.usb_function" title="usb_function">usb_function</a><em> *f</em>, struct <a class="reference internal" href="#c.usb_ep" title="usb_ep">usb_ep</a><em> *_ep</em>, u8<em> alt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.config_ep_by_speed_and_alt" title="Permalink to this definition">¶</a></dt>
<dd><p>configures the given endpoint according to gadget speed.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*g</span></code></dt><dd><p>pointer to the gadget</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_function</span> <span class="pre">*f</span></code></dt><dd><p>usb function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_ep</span> <span class="pre">*_ep</span></code></dt><dd><p>the endpoint to configure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">alt</span></code></dt><dd><p>alternate setting number</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>error code, 0 on success</p>
<p><strong>Description</strong></p>
<p>This function chooses the right descriptors for a given
endpoint according to gadget speed and saves it in the
endpoint desc field. If the endpoint already has a descriptor
assigned to it - overwrites it with currently corresponding
descriptor. The endpoint maxpacket field is updated according
to the chosen descriptor.</p>
<p><strong>Note</strong></p>
<p>the supplied function should hold all the descriptors
for supported speeds</p>
</div>
<dl class="function">
<dt id="c.config_ep_by_speed">
int <code class="sig-name descname">config_ep_by_speed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a><em> *g</em>, struct <a class="reference internal" href="#c.usb_function" title="usb_function">usb_function</a><em> *f</em>, struct <a class="reference internal" href="#c.usb_ep" title="usb_ep">usb_ep</a><em> *_ep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.config_ep_by_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>configures the given endpoint according to gadget speed.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*g</span></code></dt><dd><p>pointer to the gadget</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_function</span> <span class="pre">*f</span></code></dt><dd><p>usb function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_ep</span> <span class="pre">*_ep</span></code></dt><dd><p>the endpoint to configure</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>error code, 0 on success</p>
<p><strong>Description</strong></p>
<p>This function chooses the right descriptors for a given
endpoint according to gadget speed and saves it in the
endpoint desc field. If the endpoint already has a descriptor
assigned to it - overwrites it with currently corresponding
descriptor. The endpoint maxpacket field is updated according
to the chosen descriptor.</p>
<p><strong>Note</strong></p>
<p>the supplied function should hold all the descriptors
for supported speeds</p>
</div>
<dl class="function">
<dt id="c.usb_add_function">
int <code class="sig-name descname">usb_add_function</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_configuration" title="usb_configuration">usb_configuration</a><em> *config</em>, struct <a class="reference internal" href="#c.usb_function" title="usb_function">usb_function</a><em> *function</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_add_function" title="Permalink to this definition">¶</a></dt>
<dd><p>add a function to a configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_configuration</span> <span class="pre">*config</span></code></dt><dd><p>the configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_function</span> <span class="pre">*function</span></code></dt><dd><p>the function being added</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p>After initialization, each configuration must have one or more
functions added to it.  Adding a function involves calling its <strong>bind()</strong>
method to allocate resources such as interface and string identifiers
and endpoints.</p>
<p>This function returns the value of the function’s bind(), which is
zero for success else a negative errno value.</p>
</div>
<dl class="function">
<dt id="c.usb_function_deactivate">
int <code class="sig-name descname">usb_function_deactivate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_function" title="usb_function">usb_function</a><em> *function</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_function_deactivate" title="Permalink to this definition">¶</a></dt>
<dd><p>prevent function and gadget enumeration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_function</span> <span class="pre">*function</span></code></dt><dd><p>the function that isn’t yet ready to respond</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Blocks response of the gadget driver to host enumeration by
preventing the data line pullup from being activated.  This is
normally called during <strong>bind()</strong> processing to change from the
initial “ready to respond” state, or when a required resource
becomes available.</p>
<p>For example, drivers that serve as a passthrough to a userspace
daemon can block enumeration unless that daemon (such as an OBEX,
MTP, or print server) is ready to handle host requests.</p>
<p>Not all systems support software control of their USB peripheral
data pullups.</p>
<p>Returns zero on success, else negative errno.</p>
</div>
<dl class="function">
<dt id="c.usb_function_activate">
int <code class="sig-name descname">usb_function_activate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_function" title="usb_function">usb_function</a><em> *function</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_function_activate" title="Permalink to this definition">¶</a></dt>
<dd><p>allow function and gadget enumeration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_function</span> <span class="pre">*function</span></code></dt><dd><p>function on which <a class="reference internal" href="#c.usb_function_activate" title="usb_function_activate"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_function_activate()</span></code></a> was called</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reverses effect of <a class="reference internal" href="#c.usb_function_deactivate" title="usb_function_deactivate"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_function_deactivate()</span></code></a>.  If no more functions
are delaying their activation, the gadget driver will respond to
host enumeration procedures.</p>
<p>Returns zero on success, else negative errno.</p>
</div>
<dl class="function">
<dt id="c.usb_interface_id">
int <code class="sig-name descname">usb_interface_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_configuration" title="usb_configuration">usb_configuration</a><em> *config</em>, struct <a class="reference internal" href="#c.usb_function" title="usb_function">usb_function</a><em> *function</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_interface_id" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an unused interface ID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_configuration</span> <span class="pre">*config</span></code></dt><dd><p>configuration associated with the interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_function</span> <span class="pre">*function</span></code></dt><dd><p>function handling the interface</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.usb_interface_id" title="usb_interface_id"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_interface_id()</span></code></a> is called from usb_function.bind() callbacks to
allocate new interface IDs.  The function driver will then store that
ID in interface, association, CDC union, and other descriptors.  It
will also handle any control requests targeted at that interface,
particularly changing its altsetting via set_alt().  There may
also be class-specific or vendor-specific requests to handle.</p>
<p>All interface identifier should be allocated using this routine, to
ensure that for example different functions don’t wrongly assign
different meanings to the same identifier.  Note that since interface
identifiers are configuration-specific, functions used in more than
one configuration (or more than once in a given configuration) need
multiple versions of the relevant descriptors.</p>
<p>Returns the interface ID which was allocated; or -ENODEV if no
more interface IDs can be allocated.</p>
</div>
<dl class="function">
<dt id="c.usb_add_config">
int <code class="sig-name descname">usb_add_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a><em> *cdev</em>, struct <a class="reference internal" href="#c.usb_configuration" title="usb_configuration">usb_configuration</a><em> *config</em>, int (<em>*bind</em>)(struct <a class="reference internal" href="#c.usb_configuration" title="usb_configuration">usb_configuration</a> *)<span class="sig-paren">)</span><a class="headerlink" href="#c.usb_add_config" title="Permalink to this definition">¶</a></dt>
<dd><p>add a configuration to a device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*cdev</span></code></dt><dd><p>wraps the USB gadget</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_configuration</span> <span class="pre">*config</span></code></dt><dd><p>the configuration, with bConfigurationValue assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*bind)(struct</span> <span class="pre">usb_configuration</span> <span class="pre">*)</span></code></dt><dd><p>the configuration’s bind function</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p>One of the main tasks of a composite <strong>bind()</strong> routine is to
add each of the configurations it supports, using this routine.</p>
<p>This function returns the value of the configuration’s <strong>bind()</strong>, which
is zero for success else a negative errno value.  Binding configurations
assigns global resources including string IDs, and per-configuration
resources such as interface IDs and endpoints.</p>
</div>
<dl class="function">
<dt id="c.usb_string_id">
int <code class="sig-name descname">usb_string_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a><em> *cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_string_id" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an unused string ID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*cdev</span></code></dt><dd><p>the device whose string descriptor IDs are being allocated</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p><strong><a class="reference internal" href="#c.usb_string_id" title="usb_string_id"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_string_id()</span></code></a></strong> is called from bind() callbacks to allocate
string IDs.  Drivers for functions, configurations, or gadgets will
then store that ID in the appropriate descriptors and string table.</p>
<p>All string identifier should be allocated using this,
<strong><a class="reference internal" href="#c.usb_string_ids_tab" title="usb_string_ids_tab"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_string_ids_tab()</span></code></a></strong> or <strong><a class="reference internal" href="#c.usb_string_ids_n" title="usb_string_ids_n"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_string_ids_n()</span></code></a></strong> routine, to ensure
that for example different functions don’t wrongly assign different
meanings to the same identifier.</p>
</div>
<dl class="function">
<dt id="c.usb_string_ids_tab">
int <code class="sig-name descname">usb_string_ids_tab</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a><em> *cdev</em>, struct <a class="reference internal" href="#c.usb_string" title="usb_string">usb_string</a><em> *str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_string_ids_tab" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate unused string IDs in batch</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*cdev</span></code></dt><dd><p>the device whose string descriptor IDs are being allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_string</span> <span class="pre">*str</span></code></dt><dd><p>an array of usb_string objects to assign numbers to</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p><strong>usb_string_ids()</strong> is called from bind() callbacks to allocate
string IDs.  Drivers for functions, configurations, or gadgets will
then copy IDs from the string table to the appropriate descriptors
and string table for other languages.</p>
<p>All string identifier should be allocated using this,
<strong><a class="reference internal" href="#c.usb_string_id" title="usb_string_id"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_string_id()</span></code></a></strong> or <strong><a class="reference internal" href="#c.usb_string_ids_n" title="usb_string_ids_n"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_string_ids_n()</span></code></a></strong> routine, to ensure that for
example different functions don’t wrongly assign different meanings
to the same identifier.</p>
</div>
<dl class="function">
<dt id="c.usb_gstrings_attach">
struct <a class="reference internal" href="#c.usb_string" title="usb_string">usb_string</a> * <code class="sig-name descname">usb_gstrings_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a><em> *cdev</em>, struct <a class="reference internal" href="#c.usb_gadget_strings" title="usb_gadget_strings">usb_gadget_strings</a><em> **sp</em>, unsigned<em> n_strings</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_gstrings_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach gadget strings to a cdev and assign ids</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*cdev</span></code></dt><dd><p>the device whose string descriptor IDs are being allocated
and attached.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget_strings</span> <span class="pre">**sp</span></code></dt><dd><p>an array of usb_gadget_strings to attach.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">n_strings</span></code></dt><dd><p>number of entries in each usb_strings array (sp[]-&gt;strings)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will create a deep copy of usb_gadget_strings and usb_string
and attach it to the cdev. The actual string (usb_string.s) will not be
copied but only a referenced will be made. The <a class="reference internal" href="#c.usb_gadget_strings" title="usb_gadget_strings"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget_strings</span></code></a>
array may contain multiple languages and should be NULL terminated.
The -&gt;language pointer of each <a class="reference internal" href="#c.usb_gadget_strings" title="usb_gadget_strings"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_gadget_strings</span></code></a> has to contain the
same amount of entries.
For instance: sp[0] is en-US, sp[1] is es-ES. It is expected that the first
usb_string entry of es-ES contains the translation of the first usb_string
entry of en-US. Therefore both entries become the same id assign.</p>
</div>
<dl class="function">
<dt id="c.usb_string_ids_n">
int <code class="sig-name descname">usb_string_ids_n</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a><em> *c</em>, unsigned<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_string_ids_n" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate unused string IDs in batch</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*c</span></code></dt><dd><p>the device whose string descriptor IDs are being allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">n</span></code></dt><dd><p>number of string IDs to allocate</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p>Returns the first requested ID.  This ID and next <strong>n</strong>-1 IDs are now
valid IDs.  At least provided that <strong>n</strong> is non-zero because if it
is, returns last requested ID which is now very useful information.</p>
<p><strong><a class="reference internal" href="#c.usb_string_ids_n" title="usb_string_ids_n"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_string_ids_n()</span></code></a></strong> is called from bind() callbacks to allocate
string IDs.  Drivers for functions, configurations, or gadgets will
then store that ID in the appropriate descriptors and string table.</p>
<p>All string identifier should be allocated using this,
<strong><a class="reference internal" href="#c.usb_string_id" title="usb_string_id"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_string_id()</span></code></a></strong> or <strong><a class="reference internal" href="#c.usb_string_ids_n" title="usb_string_ids_n"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_string_ids_n()</span></code></a></strong> routine, to ensure that for
example different functions don’t wrongly assign different meanings
to the same identifier.</p>
</div>
<dl class="function">
<dt id="c.usb_composite_probe">
int <code class="sig-name descname">usb_composite_probe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_driver" title="usb_composite_driver">usb_composite_driver</a><em> *driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_composite_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>register a composite driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_composite_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the driver to register</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p>This function is used to register drivers using the composite driver
framework.  The return value is zero, or a negative errno value.
Those values normally come from the driver’s <strong>bind</strong> method, which does
all the work of setting up the driver to match the hardware.</p>
<p>On successful return, the gadget is ready to respond to requests from
the host, unless one of its components invokes usb_gadget_disconnect()
while it was binding.  That would usually be done in order to wait for
some userspace participation.</p>
</div>
<dl class="function">
<dt id="c.usb_composite_unregister">
void <code class="sig-name descname">usb_composite_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_driver" title="usb_composite_driver">usb_composite_driver</a><em> *driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_composite_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a composite driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_composite_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the driver to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to unregister drivers using the composite
driver framework.</p>
</div>
<dl class="function">
<dt id="c.usb_composite_setup_continue">
void <code class="sig-name descname">usb_composite_setup_continue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a><em> *cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_composite_setup_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>Continue with the control transfer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*cdev</span></code></dt><dd><p>the composite device who’s control transfer was kept waiting</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called by the USB function driver to continue
with the control transfer’s data/status stage in case it had requested to
delay the data/status stages. A USB function’s setup handler (e.g. set_alt())
can request the composite framework to delay the setup request’s data/status
stages by returning USB_GADGET_DELAYED_STATUS.</p>
</div>
</section>
<section id="composite-device-functions">
<h3>Composite Device Functions<a class="headerlink" href="#composite-device-functions" title="Permalink to this headline">¶</a></h3>
<p>At this writing, a few of the current gadget drivers have been converted
to this framework. Near-term plans include converting all of them,
except for <code class="docutils literal notranslate"><span class="pre">gadgetfs</span></code>.</p>
</section>
</section>
<section id="peripheral-controller-drivers">
<h2>Peripheral Controller Drivers<a class="headerlink" href="#peripheral-controller-drivers" title="Permalink to this headline">¶</a></h2>
<p>The first hardware supporting this API was the NetChip 2280 controller,
which supports USB 2.0 high speed and is based on PCI. This is the
<code class="docutils literal notranslate"><span class="pre">net2280</span></code> driver module. The driver supports Linux kernel versions 2.4
and 2.6; contact NetChip Technologies for development boards and product
information.</p>
<p>Other hardware working in the <code class="docutils literal notranslate"><span class="pre">gadget</span></code> framework includes: Intel’s PXA
25x and IXP42x series processors (<code class="docutils literal notranslate"><span class="pre">pxa2xx_udc</span></code>), Toshiba TC86c001
“Goku-S” (<code class="docutils literal notranslate"><span class="pre">goku_udc</span></code>), Renesas SH7705/7727 (<code class="docutils literal notranslate"><span class="pre">sh_udc</span></code>), MediaQ 11xx
(<code class="docutils literal notranslate"><span class="pre">mq11xx_udc</span></code>), Hynix HMS30C7202 (<code class="docutils literal notranslate"><span class="pre">h7202_udc</span></code>), National 9303/4
(<code class="docutils literal notranslate"><span class="pre">n9604_udc</span></code>), Texas Instruments OMAP (<code class="docutils literal notranslate"><span class="pre">omap_udc</span></code>), Sharp LH7A40x
(<code class="docutils literal notranslate"><span class="pre">lh7a40x_udc</span></code>), and more. Most of those are full speed controllers.</p>
<p>At this writing, there are people at work on drivers in this framework
for several other USB device controllers, with plans to make many of
them be widely available.</p>
<p>A partial USB simulator, the <code class="docutils literal notranslate"><span class="pre">dummy_hcd</span></code> driver, is available. It can
act like a net2280, a pxa25x, or an sa11x0 in terms of available
endpoints and device speeds; and it simulates control, bulk, and to some
extent interrupt transfers. That lets you develop some parts of a gadget
driver on a normal PC, without any special hardware, and perhaps with
the assistance of tools such as GDB running with User Mode Linux. At
least one person has expressed interest in adapting that approach,
hooking it up to a simulator for a microcontroller. Such simulators can
help debug subsystems where the runtime hardware is unfriendly to
software development, or is not yet available.</p>
<p>Support for other controllers is expected to be developed and
contributed over time, as this driver framework evolves.</p>
</section>
<section id="gadget-drivers">
<h2>Gadget Drivers<a class="headerlink" href="#gadget-drivers" title="Permalink to this headline">¶</a></h2>
<p>In addition to <em>Gadget Zero</em> (used primarily for testing and development
with drivers for usb controller hardware), other gadget drivers exist.</p>
<p>There’s an <code class="docutils literal notranslate"><span class="pre">ethernet</span></code> gadget driver, which implements one of the most
useful <em>Communications Device Class</em> (CDC) models. One of the standards
for cable modem interoperability even specifies the use of this ethernet
model as one of two mandatory options. Gadgets using this code look to a
USB host as if they’re an Ethernet adapter. It provides access to a
network where the gadget’s CPU is one host, which could easily be
bridging, routing, or firewalling access to other networks. Since some
hardware can’t fully implement the CDC Ethernet requirements, this
driver also implements a “good parts only” subset of CDC Ethernet. (That
subset doesn’t advertise itself as CDC Ethernet, to avoid creating
problems.)</p>
<p>Support for Microsoft’s <code class="docutils literal notranslate"><span class="pre">RNDIS</span></code> protocol has been contributed by
Pengutronix and Auerswald GmbH. This is like CDC Ethernet, but it runs
on more slightly USB hardware (but less than the CDC subset). However,
its main claim to fame is being able to connect directly to recent
versions of Windows, using drivers that Microsoft bundles and supports,
making it much simpler to network with Windows.</p>
<p>There is also support for user mode gadget drivers, using <code class="docutils literal notranslate"><span class="pre">gadgetfs</span></code>.
This provides a <em>User Mode API</em> that presents each endpoint as a single
file descriptor. I/O is done using normal <code class="docutils literal notranslate"><span class="pre">read()</span></code> and <code class="docutils literal notranslate"><span class="pre">read()</span></code> calls.
Familiar tools like GDB and pthreads can be used to develop and debug
user mode drivers, so that once a robust controller driver is available
many applications for it won’t require new kernel mode software. Linux
2.6 <em>Async I/O (AIO)</em> support is available, so that user mode software
can stream data with only slightly more overhead than a kernel driver.</p>
<p>There’s a USB Mass Storage class driver, which provides a different
solution for interoperability with systems such as MS-Windows and MacOS.
That <em>Mass Storage</em> driver uses a file or block device as backing store
for a drive, like the <code class="docutils literal notranslate"><span class="pre">loop</span></code> driver. The USB host uses the BBB, CB, or
CBI versions of the mass storage class specification, using transparent
SCSI commands to access the data from the backing store.</p>
<p>There’s a “serial line” driver, useful for TTY style operation over USB.
The latest version of that driver supports CDC ACM style operation, like
a USB modem, and so on most hardware it can interoperate easily with
MS-Windows. One interesting use of that driver is in boot firmware (like
a BIOS), which can sometimes use that model with very small systems
without real serial lines.</p>
<p>Support for other kinds of gadget is expected to be developed and
contributed over time, as this driver framework evolves.</p>
</section>
<section id="usb-on-the-go-otg">
<h2>USB On-The-GO (OTG)<a class="headerlink" href="#usb-on-the-go-otg" title="Permalink to this headline">¶</a></h2>
<p>USB OTG support on Linux 2.6 was initially developed by Texas
Instruments for <a class="reference external" href="http://www.omap.com">OMAP</a> 16xx and 17xx series
processors. Other OTG systems should work in similar ways, but the
hardware level details could be very different.</p>
<p>Systems need specialized hardware support to implement OTG, notably
including a special <em>Mini-AB</em> jack and associated transceiver to support
<em>Dual-Role</em> operation: they can act either as a host, using the standard
Linux-USB host side driver stack, or as a peripheral, using this
<code class="docutils literal notranslate"><span class="pre">gadget</span></code> framework. To do that, the system software relies on small
additions to those programming interfaces, and on a new internal
component (here called an “OTG Controller”) affecting which driver stack
connects to the OTG port. In each role, the system can re-use the
existing pool of hardware-neutral drivers, layered on top of the
controller driver interfaces (<code class="xref c c-type docutils literal notranslate"><span class="pre">usb_bus</span></code> or <a class="reference internal" href="#c.usb_gadget" title="usb_gadget"><code class="xref c c-type docutils literal notranslate"><span class="pre">usb_gadget</span></code></a>).
Such drivers need at most minor changes, and most of the calls added to
support OTG can also benefit non-OTG products.</p>
<ul>
<li><p>Gadget drivers test the <code class="docutils literal notranslate"><span class="pre">is_otg</span></code> flag, and use it to determine
whether or not to include an OTG descriptor in each of their
configurations.</p></li>
<li><p>Gadget drivers may need changes to support the two new OTG protocols,
exposed in new gadget attributes such as <code class="docutils literal notranslate"><span class="pre">b_hnp_enable</span></code> flag. HNP
support should be reported through a user interface (two LEDs could
suffice), and is triggered in some cases when the host suspends the
peripheral. SRP support can be user-initiated just like remote
wakeup, probably by pressing the same button.</p></li>
<li><p>On the host side, USB device drivers need to be taught to trigger HNP
at appropriate moments, using <code class="docutils literal notranslate"><span class="pre">usb_suspend_device()</span></code>. That also
conserves battery power, which is useful even for non-OTG
configurations.</p></li>
<li><p>Also on the host side, a driver must support the OTG “Targeted
Peripheral List”. That’s just a whitelist, used to reject peripherals
not supported with a given Linux OTG host. <em>This whitelist is
product-specific; each product must modify</em> <code class="docutils literal notranslate"><span class="pre">otg_whitelist.h</span></code> <em>to
match its interoperability specification.</em></p>
<p>Non-OTG Linux hosts, like PCs and workstations, normally have some
solution for adding drivers, so that peripherals that aren’t
recognized can eventually be supported. That approach is unreasonable
for consumer products that may never have their firmware upgraded,
and where it’s usually unrealistic to expect traditional
PC/workstation/server kinds of support model to work. For example,
it’s often impractical to change device firmware once the product has
been distributed, so driver bugs can’t normally be fixed if they’re
found after shipment.</p>
</li>
</ul>
<p>Additional changes are needed below those hardware-neutral <code class="xref c c-type docutils literal notranslate"><span class="pre">usb_bus</span></code>
and <a class="reference internal" href="#c.usb_gadget" title="usb_gadget"><code class="xref c c-type docutils literal notranslate"><span class="pre">usb_gadget</span></code></a> driver interfaces; those aren’t discussed here in any
detail. Those affect the hardware-specific code for each USB Host or
Peripheral controller, and how the HCD initializes (since OTG can be
active only on a single port). They also involve what may be called an
<em>OTG Controller Driver</em>, managing the OTG transceiver and the OTG state
machine logic as well as much of the root hub behavior for the OTG port.
The OTG controller driver needs to activate and deactivate USB
controllers depending on the relevant device role. Some related changes
were needed inside usbcore, so that it can identify OTG-capable devices
and respond appropriately to HNP or SRP protocols.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">USB Gadget API for Linux</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#structure-of-gadget-drivers">Structure of Gadget Drivers</a></li>
<li><a class="reference internal" href="#kernel-mode-gadget-api">Kernel Mode Gadget API</a><ul>
<li><a class="reference internal" href="#driver-life-cycle">Driver Life Cycle</a></li>
<li><a class="reference internal" href="#usb-2-0-chapter-9-types-and-constants">USB 2.0 Chapter 9 Types and Constants</a></li>
<li><a class="reference internal" href="#core-objects-and-methods">Core Objects and Methods</a></li>
<li><a class="reference internal" href="#optional-utilities">Optional Utilities</a></li>
<li><a class="reference internal" href="#composite-device-framework">Composite Device Framework</a></li>
<li><a class="reference internal" href="#composite-device-functions">Composite Device Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#peripheral-controller-drivers">Peripheral Controller Drivers</a></li>
<li><a class="reference internal" href="#gadget-drivers">Gadget Drivers</a></li>
<li><a class="reference internal" href="#usb-on-the-go-otg">USB On-The-GO (OTG)</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/usb/gadget.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/usb/gadget.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>