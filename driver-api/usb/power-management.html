
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Power Management for USB &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="USB hotplugging" href="hotplug.html" />
    <link rel="prev" title="USB Request Block (URB)" href="URB.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="power-management-for-usb">
<span id="usb-power-management"></span><h1>Power Management for USB<a class="headerlink" href="#power-management-for-usb" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Alan Stern &lt;<a class="reference external" href="mailto:stern&#37;&#52;&#48;rowland&#46;harvard&#46;edu">stern<span>&#64;</span>rowland<span>&#46;</span>harvard<span>&#46;</span>edu</a>&gt;</p>
</dd>
<dt class="field-even">Date</dt>
<dd class="field-even"><p>Last-updated: February 2014</p>
</dd>
</dl>
<section id="what-is-power-management">
<h2>What is Power Management?<a class="headerlink" href="#what-is-power-management" title="Permalink to this headline">¶</a></h2>
<p>Power Management (PM) is the practice of saving energy by suspending
parts of a computer system when they aren’t being used.  While a
component is <code class="docutils literal notranslate"><span class="pre">suspended</span></code> it is in a nonfunctional low-power state; it
might even be turned off completely.  A suspended component can be
<code class="docutils literal notranslate"><span class="pre">resumed</span></code> (returned to a functional full-power state) when the kernel
needs to use it.  (There also are forms of PM in which components are
placed in a less functional but still usable state instead of being
suspended; an example would be reducing the CPU’s clock rate.  This
document will not discuss those other forms.)</p>
<p>When the parts being suspended include the CPU and most of the rest of
the system, we speak of it as a “system suspend”.  When a particular
device is turned off while the system as a whole remains running, we
call it a “dynamic suspend” (also known as a “runtime suspend” or
“selective suspend”).  This document concentrates mostly on how
dynamic PM is implemented in the USB subsystem, although system PM is
covered to some extent (see <code class="docutils literal notranslate"><span class="pre">Documentation/power/*.rst</span></code> for more
information about system PM).</p>
<p>System PM support is present only if the kernel was built with
<code class="docutils literal notranslate"><span class="pre">CONFIG_SUSPEND</span></code> or <code class="docutils literal notranslate"><span class="pre">CONFIG_HIBERNATION</span></code> enabled.  Dynamic PM support</p>
<p>for USB is present whenever
the kernel was built with <code class="docutils literal notranslate"><span class="pre">CONFIG_PM</span></code> enabled.</p>
<p>[Historically, dynamic PM support for USB was present only if the
kernel had been built with <code class="docutils literal notranslate"><span class="pre">CONFIG_USB_SUSPEND</span></code> enabled (which depended on
<code class="docutils literal notranslate"><span class="pre">CONFIG_PM_RUNTIME</span></code>).  Starting with the 3.10 kernel release, dynamic PM
support for USB was present whenever the kernel was built with
<code class="docutils literal notranslate"><span class="pre">CONFIG_PM_RUNTIME</span></code> enabled.  The <code class="docutils literal notranslate"><span class="pre">CONFIG_USB_SUSPEND</span></code> option had been
eliminated.]</p>
</section>
<section id="what-is-remote-wakeup">
<h2>What is Remote Wakeup?<a class="headerlink" href="#what-is-remote-wakeup" title="Permalink to this headline">¶</a></h2>
<p>When a device has been suspended, it generally doesn’t resume until
the computer tells it to.  Likewise, if the entire computer has been
suspended, it generally doesn’t resume until the user tells it to, say
by pressing a power button or opening the cover.</p>
<p>However some devices have the capability of resuming by themselves, or
asking the kernel to resume them, or even telling the entire computer
to resume.  This capability goes by several names such as “Wake On
LAN”; we will refer to it generically as “remote wakeup”.  When a
device is enabled for remote wakeup and it is suspended, it may resume
itself (or send a request to be resumed) in response to some external
event.  Examples include a suspended keyboard resuming when a key is
pressed, or a suspended USB hub resuming when a device is plugged in.</p>
</section>
<section id="when-is-a-usb-device-idle">
<h2>When is a USB device idle?<a class="headerlink" href="#when-is-a-usb-device-idle" title="Permalink to this headline">¶</a></h2>
<p>A device is idle whenever the kernel thinks it’s not busy doing
anything important and thus is a candidate for being suspended.  The
exact definition depends on the device’s driver; drivers are allowed
to declare that a device isn’t idle even when there’s no actual
communication taking place.  (For example, a hub isn’t considered idle
unless all the devices plugged into that hub are already suspended.)
In addition, a device isn’t considered idle so long as a program keeps
its usbfs file open, whether or not any I/O is going on.</p>
<p>If a USB device has no driver, its usbfs file isn’t open, and it isn’t
being accessed through sysfs, then it definitely is idle.</p>
</section>
<section id="forms-of-dynamic-pm">
<h2>Forms of dynamic PM<a class="headerlink" href="#forms-of-dynamic-pm" title="Permalink to this headline">¶</a></h2>
<p>Dynamic suspends occur when the kernel decides to suspend an idle
device.  This is called <code class="docutils literal notranslate"><span class="pre">autosuspend</span></code> for short.  In general, a device
won’t be autosuspended unless it has been idle for some minimum period
of time, the so-called idle-delay time.</p>
<p>Of course, nothing the kernel does on its own initiative should
prevent the computer or its devices from working properly.  If a
device has been autosuspended and a program tries to use it, the
kernel will automatically resume the device (autoresume).  For the
same reason, an autosuspended device will usually have remote wakeup
enabled, if the device supports remote wakeup.</p>
<p>It is worth mentioning that many USB drivers don’t support
autosuspend.  In fact, at the time of this writing (Linux 2.6.23) the
only drivers which do support it are the hub driver, kaweth, asix,
usblp, usblcd, and usb-skeleton (which doesn’t count).  If a
non-supporting driver is bound to a device, the device won’t be
autosuspended.  In effect, the kernel pretends the device is never
idle.</p>
<p>We can categorize power management events in two broad classes:
external and internal.  External events are those triggered by some
agent outside the USB stack: system suspend/resume (triggered by
userspace), manual dynamic resume (also triggered by userspace), and
remote wakeup (triggered by the device).  Internal events are those
triggered within the USB stack: autosuspend and autoresume.  Note that
all dynamic suspend events are internal; external agents are not
allowed to issue dynamic suspends.</p>
</section>
<section id="the-user-interface-for-dynamic-pm">
<h2>The user interface for dynamic PM<a class="headerlink" href="#the-user-interface-for-dynamic-pm" title="Permalink to this headline">¶</a></h2>
<p>The user interface for controlling dynamic PM is located in the <code class="docutils literal notranslate"><span class="pre">power/</span></code>
subdirectory of each USB device’s sysfs directory, that is, in
<code class="docutils literal notranslate"><span class="pre">/sys/bus/usb/devices/.../power/</span></code> where “…” is the device’s ID.  The
relevant attribute files are: wakeup, control, and
<code class="docutils literal notranslate"><span class="pre">autosuspend_delay_ms</span></code>.  (There may also be a file named <code class="docutils literal notranslate"><span class="pre">level</span></code>; this
file was deprecated as of the 2.6.35 kernel and replaced by the
<code class="docutils literal notranslate"><span class="pre">control</span></code> file.  In 2.6.38 the <code class="docutils literal notranslate"><span class="pre">autosuspend</span></code> file will be deprecated
and replaced by the <code class="docutils literal notranslate"><span class="pre">autosuspend_delay_ms</span></code> file.  The only difference
is that the newer file expresses the delay in milliseconds whereas the
older file uses seconds.  Confusingly, both files are present in 2.6.37
but only <code class="docutils literal notranslate"><span class="pre">autosuspend</span></code> works.)</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">power/wakeup</span></code></p>
<blockquote>
<div><p>This file is empty if the device does not support
remote wakeup.  Otherwise the file contains either the
word <code class="docutils literal notranslate"><span class="pre">enabled</span></code> or the word <code class="docutils literal notranslate"><span class="pre">disabled</span></code>, and you can
write those words to the file.  The setting determines
whether or not remote wakeup will be enabled when the
device is next suspended.  (If the setting is changed
while the device is suspended, the change won’t take
effect until the following suspend.)</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">power/control</span></code></p>
<blockquote>
<div><p>This file contains one of two words: <code class="docutils literal notranslate"><span class="pre">on</span></code> or <code class="docutils literal notranslate"><span class="pre">auto</span></code>.
You can write those words to the file to change the
device’s setting.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">on</span></code> means that the device should be resumed and
autosuspend is not allowed.  (Of course, system
suspends are still allowed.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">auto</span></code> is the normal state in which the kernel is
allowed to autosuspend and autoresume the device.</p></li>
</ul>
<p>(In kernels up to 2.6.32, you could also specify
<code class="docutils literal notranslate"><span class="pre">suspend</span></code>, meaning that the device should remain
suspended and autoresume was not allowed.  This
setting is no longer supported.)</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">power/autosuspend_delay_ms</span></code></p>
<blockquote>
<div><p>This file contains an integer value, which is the
number of milliseconds the device should remain idle
before the kernel will autosuspend it (the idle-delay
time).  The default is 2000.  0 means to autosuspend
as soon as the device becomes idle, and negative
values mean never to autosuspend.  You can write a
number to the file to change the autosuspend
idle-delay time.</p>
</div></blockquote>
</div></blockquote>
<p>Writing <code class="docutils literal notranslate"><span class="pre">-1</span></code> to <code class="docutils literal notranslate"><span class="pre">power/autosuspend_delay_ms</span></code> and writing <code class="docutils literal notranslate"><span class="pre">on</span></code> to
<code class="docutils literal notranslate"><span class="pre">power/control</span></code> do essentially the same thing – they both prevent the
device from being autosuspended.  Yes, this is a redundancy in the
API.</p>
<p>(In 2.6.21 writing <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">power/autosuspend</span></code> would prevent the device
from being autosuspended; the behavior was changed in 2.6.22.  The
<code class="docutils literal notranslate"><span class="pre">power/autosuspend</span></code> attribute did not exist prior to 2.6.21, and the
<code class="docutils literal notranslate"><span class="pre">power/level</span></code> attribute did not exist prior to 2.6.22.  <code class="docutils literal notranslate"><span class="pre">power/control</span></code>
was added in 2.6.34, and <code class="docutils literal notranslate"><span class="pre">power/autosuspend_delay_ms</span></code> was added in
2.6.37 but did not become functional until 2.6.38.)</p>
</section>
<section id="changing-the-default-idle-delay-time">
<h2>Changing the default idle-delay time<a class="headerlink" href="#changing-the-default-idle-delay-time" title="Permalink to this headline">¶</a></h2>
<p>The default autosuspend idle-delay time (in seconds) is controlled by
a module parameter in usbcore.  You can specify the value when usbcore
is loaded.  For example, to set it to 5 seconds instead of 2 you would
do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>modprobe usbcore autosuspend=5
</pre></div>
</div>
<p>Equivalently, you could add to a configuration file in /etc/modprobe.d
a line saying:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>options usbcore autosuspend=5
</pre></div>
</div>
<p>Some distributions load the usbcore module very early during the boot
process, by means of a program or script running from an initramfs
image.  To alter the parameter value you would have to rebuild that
image.</p>
<p>If usbcore is compiled into the kernel rather than built as a loadable
module, you can add:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>usbcore.autosuspend=5
</pre></div>
</div>
<p>to the kernel’s boot command line.</p>
<p>Finally, the parameter value can be changed while the system is
running.  If you do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 5 &gt;/sys/module/usbcore/parameters/autosuspend
</pre></div>
</div>
<p>then each new USB device will have its autosuspend idle-delay
initialized to 5.  (The idle-delay values for already existing devices
will not be affected.)</p>
<p>Setting the initial default idle-delay to -1 will prevent any
autosuspend of any USB device.  This has the benefit of allowing you
then to enable autosuspend for selected devices.</p>
</section>
<section id="warnings">
<h2>Warnings<a class="headerlink" href="#warnings" title="Permalink to this headline">¶</a></h2>
<p>The USB specification states that all USB devices must support power
management.  Nevertheless, the sad fact is that many devices do not
support it very well.  You can suspend them all right, but when you
try to resume them they disconnect themselves from the USB bus or
they stop working entirely.  This seems to be especially prevalent
among printers and scanners, but plenty of other types of device have
the same deficiency.</p>
<p>For this reason, by default the kernel disables autosuspend (the
<code class="docutils literal notranslate"><span class="pre">power/control</span></code> attribute is initialized to <code class="docutils literal notranslate"><span class="pre">on</span></code>) for all devices other
than hubs.  Hubs, at least, appear to be reasonably well-behaved in
this regard.</p>
<p>(In 2.6.21 and 2.6.22 this wasn’t the case.  Autosuspend was enabled
by default for almost all USB devices.  A number of people experienced
problems as a result.)</p>
<p>This means that non-hub devices won’t be autosuspended unless the user
or a program explicitly enables it.  As of this writing there aren’t
any widespread programs which will do this; we hope that in the near
future device managers such as HAL will take on this added
responsibility.  In the meantime you can always carry out the
necessary operations by hand or add them to a udev script.  You can
also change the idle-delay time; 2 seconds is not the best choice for
every device.</p>
<p>If a driver knows that its device has proper suspend/resume support,
it can enable autosuspend all by itself.  For example, the video
driver for a laptop’s webcam might do this (in recent kernels they
do), since these devices are rarely used and so should normally be
autosuspended.</p>
<p>Sometimes it turns out that even when a device does work okay with
autosuspend there are still problems.  For example, the usbhid driver,
which manages keyboards and mice, has autosuspend support.  Tests with
a number of keyboards show that typing on a suspended keyboard, while
causing the keyboard to do a remote wakeup all right, will nonetheless
frequently result in lost keystrokes.  Tests with mice show that some
of them will issue a remote-wakeup request in response to button
presses but not to motion, and some in response to neither.</p>
<p>The kernel will not prevent you from enabling autosuspend on devices
that can’t handle it.  It is even possible in theory to damage a
device by suspending it at the wrong time.  (Highly unlikely, but
possible.)  Take care.</p>
</section>
<section id="the-driver-interface-for-power-management">
<h2>The driver interface for Power Management<a class="headerlink" href="#the-driver-interface-for-power-management" title="Permalink to this headline">¶</a></h2>
<p>The requirements for a USB driver to support external power management
are pretty modest; the driver need only define:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.suspend
.resume
.reset_resume
</pre></div>
</div>
<p>methods in its <a class="reference internal" href="usb.html#c.usb_driver" title="usb_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">usb_driver</span></code></a> structure, and the <code class="docutils literal notranslate"><span class="pre">reset_resume</span></code> method
is optional.  The methods’ jobs are quite simple:</p>
<blockquote>
<div><ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">suspend</span></code> method is called to warn the driver that the
device is going to be suspended.  If the driver returns a
negative error code, the suspend will be aborted.  Normally
the driver will return 0, in which case it must cancel all
outstanding URBs (<a class="reference internal" href="usb.html#c.usb_kill_urb" title="usb_kill_urb"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_kill_urb()</span></code></a>) and not submit any more.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">resume</span></code> method is called to tell the driver that the
device has been resumed and the driver can return to normal
operation.  URBs may once more be submitted.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">reset_resume</span></code> method is called to tell the driver that
the device has been resumed and it also has been reset.
The driver should redo any necessary device initialization,
since the device has probably lost most or all of its state
(although the interfaces will be in the same altsettings as
before the suspend).</p></li>
</ul>
</div></blockquote>
<p>If the device is disconnected or powered down while it is suspended,
the <code class="docutils literal notranslate"><span class="pre">disconnect</span></code> method will be called instead of the <code class="docutils literal notranslate"><span class="pre">resume</span></code> or
<code class="docutils literal notranslate"><span class="pre">reset_resume</span></code> method.  This is also quite likely to happen when
waking up from hibernation, as many systems do not maintain suspend
current to the USB host controllers during hibernation.  (It’s
possible to work around the hibernation-forces-disconnect problem by
using the USB Persist facility.)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">reset_resume</span></code> method is used by the USB Persist facility (see
<a class="reference internal" href="persist.html#usb-persist"><span class="std std-ref">USB device persistence during system suspend</span></a>) and it can also be used under certain
circumstances when <code class="docutils literal notranslate"><span class="pre">CONFIG_USB_PERSIST</span></code> is not enabled.  Currently, if a
device is reset during a resume and the driver does not have a
<code class="docutils literal notranslate"><span class="pre">reset_resume</span></code> method, the driver won’t receive any notification about
the resume.  Later kernels will call the driver’s <code class="docutils literal notranslate"><span class="pre">disconnect</span></code> method;
2.6.23 doesn’t do this.</p>
<p>USB drivers are bound to interfaces, so their <code class="docutils literal notranslate"><span class="pre">suspend</span></code> and <code class="docutils literal notranslate"><span class="pre">resume</span></code>
methods get called when the interfaces are suspended or resumed.  In
principle one might want to suspend some interfaces on a device (i.e.,
force the drivers for those interface to stop all activity) without
suspending the other interfaces.  The USB core doesn’t allow this; all
interfaces are suspended when the device itself is suspended and all
interfaces are resumed when the device is resumed.  It isn’t possible
to suspend or resume some but not all of a device’s interfaces.  The
closest you can come is to unbind the interfaces’ drivers.</p>
</section>
<section id="the-driver-interface-for-autosuspend-and-autoresume">
<h2>The driver interface for autosuspend and autoresume<a class="headerlink" href="#the-driver-interface-for-autosuspend-and-autoresume" title="Permalink to this headline">¶</a></h2>
<p>To support autosuspend and autoresume, a driver should implement all
three of the methods listed above.  In addition, a driver indicates
that it supports autosuspend by setting the <code class="docutils literal notranslate"><span class="pre">.supports_autosuspend</span></code> flag
in its usb_driver structure.  It is then responsible for informing the
USB core whenever one of its interfaces becomes busy or idle.  The
driver does so by calling these six functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int  usb_autopm_get_interface(struct usb_interface *intf);
void usb_autopm_put_interface(struct usb_interface *intf);
int  usb_autopm_get_interface_async(struct usb_interface *intf);
void usb_autopm_put_interface_async(struct usb_interface *intf);
void usb_autopm_get_interface_no_resume(struct usb_interface *intf);
void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);
</pre></div>
</div>
<p>The functions work by maintaining a usage counter in the
usb_interface’s embedded device structure.  When the counter is &gt; 0
then the interface is deemed to be busy, and the kernel will not
autosuspend the interface’s device.  When the usage counter is = 0
then the interface is considered to be idle, and the kernel may
autosuspend the device.</p>
<p>Drivers must be careful to balance their overall changes to the usage
counter.  Unbalanced “get”s will remain in effect when a driver is
unbound from its interface, preventing the device from going into
runtime suspend should the interface be bound to a driver again.  On
the other hand, drivers are allowed to achieve this balance by calling
the <code class="docutils literal notranslate"><span class="pre">usb_autopm_*</span></code> functions even after their <code class="docutils literal notranslate"><span class="pre">disconnect</span></code> routine
has returned – say from within a work-queue routine – provided they
retain an active reference to the interface (via <code class="docutils literal notranslate"><span class="pre">usb_get_intf</span></code> and
<code class="docutils literal notranslate"><span class="pre">usb_put_intf</span></code>).</p>
<p>Drivers using the async routines are responsible for their own
synchronization and mutual exclusion.</p>
<blockquote>
<div><p><a class="reference internal" href="usb.html#c.usb_autopm_get_interface" title="usb_autopm_get_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_get_interface()</span></code></a> increments the usage counter and
does an autoresume if the device is suspended.  If the
autoresume fails, the counter is decremented back.</p>
<p><a class="reference internal" href="usb.html#c.usb_autopm_put_interface" title="usb_autopm_put_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_put_interface()</span></code></a> decrements the usage counter and
attempts an autosuspend if the new value is = 0.</p>
<p><a class="reference internal" href="usb.html#c.usb_autopm_get_interface_async" title="usb_autopm_get_interface_async"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_get_interface_async()</span></code></a> and
<a class="reference internal" href="usb.html#c.usb_autopm_put_interface_async" title="usb_autopm_put_interface_async"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_put_interface_async()</span></code></a> do almost the same things as
their non-async counterparts.  The big difference is that they
use a workqueue to do the resume or suspend part of their
jobs.  As a result they can be called in an atomic context,
such as an URB’s completion handler, but when they return the
device will generally not yet be in the desired state.</p>
<p><a class="reference internal" href="usb.html#c.usb_autopm_get_interface_no_resume" title="usb_autopm_get_interface_no_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_get_interface_no_resume()</span></code></a> and
<a class="reference internal" href="usb.html#c.usb_autopm_put_interface_no_suspend" title="usb_autopm_put_interface_no_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_put_interface_no_suspend()</span></code></a> merely increment or
decrement the usage counter; they do not attempt to carry out
an autoresume or an autosuspend.  Hence they can be called in
an atomic context.</p>
</div></blockquote>
<p>The simplest usage pattern is that a driver calls
<a class="reference internal" href="usb.html#c.usb_autopm_get_interface" title="usb_autopm_get_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_get_interface()</span></code></a> in its open routine and
<a class="reference internal" href="usb.html#c.usb_autopm_put_interface" title="usb_autopm_put_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_put_interface()</span></code></a> in its close or release routine.  But other
patterns are possible.</p>
<p>The autosuspend attempts mentioned above will often fail for one
reason or another.  For example, the <code class="docutils literal notranslate"><span class="pre">power/control</span></code> attribute might be
set to <code class="docutils literal notranslate"><span class="pre">on</span></code>, or another interface in the same device might not be
idle.  This is perfectly normal.  If the reason for failure was that
the device hasn’t been idle for long enough, a timer is scheduled to
carry out the operation automatically when the autosuspend idle-delay
has expired.</p>
<p>Autoresume attempts also can fail, although failure would mean that
the device is no longer present or operating properly.  Unlike
autosuspend, there’s no idle-delay for an autoresume.</p>
</section>
<section id="other-parts-of-the-driver-interface">
<h2>Other parts of the driver interface<a class="headerlink" href="#other-parts-of-the-driver-interface" title="Permalink to this headline">¶</a></h2>
<p>Drivers can enable autosuspend for their devices by calling:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>usb_enable_autosuspend(struct usb_device *udev);
</pre></div>
</div>
<p>in their <code class="xref c c-func docutils literal notranslate"><span class="pre">probe()</span></code> routine, if they know that the device is capable of
suspending and resuming correctly.  This is exactly equivalent to
writing <code class="docutils literal notranslate"><span class="pre">auto</span></code> to the device’s <code class="docutils literal notranslate"><span class="pre">power/control</span></code> attribute.  Likewise,
drivers can disable autosuspend by calling:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>usb_disable_autosuspend(struct usb_device *udev);
</pre></div>
</div>
<p>This is exactly the same as writing <code class="docutils literal notranslate"><span class="pre">on</span></code> to the <code class="docutils literal notranslate"><span class="pre">power/control</span></code> attribute.</p>
<p>Sometimes a driver needs to make sure that remote wakeup is enabled
during autosuspend.  For example, there’s not much point
autosuspending a keyboard if the user can’t cause the keyboard to do a
remote wakeup by typing on it.  If the driver sets
<code class="docutils literal notranslate"><span class="pre">intf-&gt;needs_remote_wakeup</span></code> to 1, the kernel won’t autosuspend the
device if remote wakeup isn’t available.  (If the device is already
autosuspended, though, setting this flag won’t cause the kernel to
autoresume it.  Normally a driver would set this flag in its <code class="docutils literal notranslate"><span class="pre">probe</span></code>
method, at which time the device is guaranteed not to be
autosuspended.)</p>
<p>If a driver does its I/O asynchronously in interrupt context, it
should call <a class="reference internal" href="usb.html#c.usb_autopm_get_interface_async" title="usb_autopm_get_interface_async"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_get_interface_async()</span></code></a> before starting output and
<a class="reference internal" href="usb.html#c.usb_autopm_put_interface_async" title="usb_autopm_put_interface_async"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_put_interface_async()</span></code></a> when the output queue drains.  When
it receives an input event, it should call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>usb_mark_last_busy(struct usb_device *udev);
</pre></div>
</div>
<p>in the event handler.  This tells the PM core that the device was just
busy and therefore the next autosuspend idle-delay expiration should
be pushed back.  Many of the usb_autopm_* routines also make this call,
so drivers need to worry only when interrupt-driven input arrives.</p>
<p>Asynchronous operation is always subject to races.  For example, a
driver may call the <a class="reference internal" href="usb.html#c.usb_autopm_get_interface_async" title="usb_autopm_get_interface_async"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_get_interface_async()</span></code></a> routine at a time
when the core has just finished deciding the device has been idle for
long enough but not yet gotten around to calling the driver’s <code class="docutils literal notranslate"><span class="pre">suspend</span></code>
method.  The <code class="docutils literal notranslate"><span class="pre">suspend</span></code> method must be responsible for synchronizing with
the I/O request routine and the URB completion handler; it should
cause autosuspends to fail with -EBUSY if the driver needs to use the
device.</p>
<p>External suspend calls should never be allowed to fail in this way,
only autosuspend calls.  The driver can tell them apart by applying
the <code class="xref c c-func docutils literal notranslate"><span class="pre">PMSG_IS_AUTO()</span></code> macro to the message argument to the <code class="docutils literal notranslate"><span class="pre">suspend</span></code>
method; it will return True for internal PM events (autosuspend) and
False for external PM events.</p>
</section>
<section id="mutual-exclusion">
<h2>Mutual exclusion<a class="headerlink" href="#mutual-exclusion" title="Permalink to this headline">¶</a></h2>
<p>For external events – but not necessarily for autosuspend or
autoresume – the device semaphore (udev-&gt;dev.sem) will be held when a
<code class="docutils literal notranslate"><span class="pre">suspend</span></code> or <code class="docutils literal notranslate"><span class="pre">resume</span></code> method is called.  This implies that external
suspend/resume events are mutually exclusive with calls to <code class="docutils literal notranslate"><span class="pre">probe</span></code>,
<code class="docutils literal notranslate"><span class="pre">disconnect</span></code>, <code class="docutils literal notranslate"><span class="pre">pre_reset</span></code>, and <code class="docutils literal notranslate"><span class="pre">post_reset</span></code>; the USB core guarantees that
this is true of autosuspend/autoresume events as well.</p>
<p>If a driver wants to block all suspend/resume calls during some
critical section, the best way is to lock the device and call
<a class="reference internal" href="usb.html#c.usb_autopm_get_interface" title="usb_autopm_get_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_get_interface()</span></code></a> (and do the reverse at the end of the
critical section).  Holding the device semaphore will block all
external PM calls, and the <a class="reference internal" href="usb.html#c.usb_autopm_get_interface" title="usb_autopm_get_interface"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_autopm_get_interface()</span></code></a> will prevent any
internal PM calls, even if it fails.  (Exercise: Why?)</p>
</section>
<section id="interaction-between-dynamic-pm-and-system-pm">
<h2>Interaction between dynamic PM and system PM<a class="headerlink" href="#interaction-between-dynamic-pm-and-system-pm" title="Permalink to this headline">¶</a></h2>
<p>Dynamic power management and system power management can interact in
a couple of ways.</p>
<p>Firstly, a device may already be autosuspended when a system suspend
occurs.  Since system suspends are supposed to be as transparent as
possible, the device should remain suspended following the system
resume.  But this theory may not work out well in practice; over time
the kernel’s behavior in this regard has changed.  As of 2.6.37 the
policy is to resume all devices during a system resume and let them
handle their own runtime suspends afterward.</p>
<p>Secondly, a dynamic power-management event may occur as a system
suspend is underway.  The window for this is short, since system
suspends don’t take long (a few seconds usually), but it can happen.
For example, a suspended device may send a remote-wakeup signal while
the system is suspending.  The remote wakeup may succeed, which would
cause the system suspend to abort.  If the remote wakeup doesn’t
succeed, it may still remain active and thus cause the system to
resume as soon as the system suspend is complete.  Or the remote
wakeup may fail and get lost.  Which outcome occurs depends on timing
and on the hardware and firmware design.</p>
</section>
<section id="xhci-hardware-link-pm">
<h2>xHCI hardware link PM<a class="headerlink" href="#xhci-hardware-link-pm" title="Permalink to this headline">¶</a></h2>
<p>xHCI host controller provides hardware link power management to usb2.0
(xHCI 1.0 feature) and usb3.0 devices which support link PM. By
enabling hardware LPM, the host can automatically put the device into
lower power state(L1 for usb2.0 devices, or U1/U2 for usb3.0 devices),
which state device can enter and resume very quickly.</p>
<p>The user interface for controlling hardware LPM is located in the
<code class="docutils literal notranslate"><span class="pre">power/</span></code> subdirectory of each USB device’s sysfs directory, that is, in
<code class="docutils literal notranslate"><span class="pre">/sys/bus/usb/devices/.../power/</span></code> where “…” is the device’s ID. The
relevant attribute files are <code class="docutils literal notranslate"><span class="pre">usb2_hardware_lpm</span></code> and <code class="docutils literal notranslate"><span class="pre">usb3_hardware_lpm</span></code>.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">power/usb2_hardware_lpm</span></code></p>
<blockquote>
<div><p>When a USB2 device which support LPM is plugged to a
xHCI host root hub which support software LPM, the
host will run a software LPM test for it; if the device
enters L1 state and resume successfully and the host
supports USB2 hardware LPM, this file will show up and
driver will enable hardware LPM for the device. You
can write y/Y/1 or n/N/0 to the file to enable/disable
USB2 hardware LPM manually. This is for test purpose mainly.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">power/usb3_hardware_lpm_u1</span></code>
<code class="docutils literal notranslate"><span class="pre">power/usb3_hardware_lpm_u2</span></code></p>
<blockquote>
<div><p>When a USB 3.0 lpm-capable device is plugged in to a
xHCI host which supports link PM, it will check if U1
and U2 exit latencies have been set in the BOS
descriptor; if the check is passed and the host
supports USB3 hardware LPM, USB3 hardware LPM will be
enabled for the device and these files will be created.
The files hold a string value (enable or disable)
indicating whether or not USB3 hardware LPM U1 or U2
is enabled for the device.</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="usb-port-power-control">
<h2>USB Port Power Control<a class="headerlink" href="#usb-port-power-control" title="Permalink to this headline">¶</a></h2>
<p>In addition to suspending endpoint devices and enabling hardware
controlled link power management, the USB subsystem also has the
capability to disable power to ports under some conditions.  Power is
controlled through <code class="docutils literal notranslate"><span class="pre">Set/ClearPortFeature(PORT_POWER)</span></code> requests to a hub.
In the case of a root or platform-internal hub the host controller
driver translates <code class="docutils literal notranslate"><span class="pre">PORT_POWER</span></code> requests into platform firmware (ACPI)
method calls to set the port power state. For more background see the
Linux Plumbers Conference 2012 slides <a class="footnote-reference brackets" href="#f1" id="id1">1</a> and video <a class="footnote-reference brackets" href="#f2" id="id2">2</a>:</p>
<p>Upon receiving a <code class="docutils literal notranslate"><span class="pre">ClearPortFeature(PORT_POWER)</span></code> request a USB port is
logically off, and may trigger the actual loss of VBUS to the port <a class="footnote-reference brackets" href="#f3" id="id3">3</a>.
VBUS may be maintained in the case where a hub gangs multiple ports into
a shared power well causing power to remain until all ports in the gang
are turned off.  VBUS may also be maintained by hub ports configured for
a charging application.  In any event a logically off port will lose
connection with its device, not respond to hotplug events, and not
respond to remote wakeup events.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>turning off a port may result in the inability to hot add a device.
Please see “User Interface for Port Power Control” for details.</p>
</div>
<p>As far as the effect on the device itself it is similar to what a device
goes through during system suspend, i.e. the power session is lost.  Any
USB device or driver that misbehaves with system suspend will be
similarly affected by a port power cycle event.  For this reason the
implementation shares the same device recovery path (and honors the same
quirks) as the system resume path for the hub.</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><a class="reference external" href="http://dl.dropbox.com/u/96820575/sarah-sharp-lpt-port-power-off2-mini.pdf">http://dl.dropbox.com/u/96820575/sarah-sharp-lpt-port-power-off2-mini.pdf</a></p>
</dd>
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p><a class="reference external" href="http://linuxplumbers.ubicast.tv/videos/usb-port-power-off-kerneluserspace-api/">http://linuxplumbers.ubicast.tv/videos/usb-port-power-off-kerneluserspace-api/</a></p>
</dd>
<dt class="label" id="f3"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>USB 3.1 Section 10.12</p>
<p>wakeup note: if a device is configured to send wakeup events the port
power control implementation will block poweroff attempts on that
port.</p>
</dd>
</dl>
</section>
<section id="user-interface-for-port-power-control">
<h2>User Interface for Port Power Control<a class="headerlink" href="#user-interface-for-port-power-control" title="Permalink to this headline">¶</a></h2>
<p>The port power control mechanism uses the PM runtime system.  Poweroff is
requested by clearing the <code class="docutils literal notranslate"><span class="pre">power/pm_qos_no_power_off</span></code> flag of the port device
(defaults to 1).  If the port is disconnected it will immediately receive a
<code class="docutils literal notranslate"><span class="pre">ClearPortFeature(PORT_POWER)</span></code> request.  Otherwise, it will honor the pm
runtime rules and require the attached child device and all descendants to be
suspended. This mechanism is dependent on the hub advertising port power
switching in its hub descriptor (wHubCharacteristics logical power switching
mode field).</p>
<p>Note, some interface devices/drivers do not support autosuspend.  Userspace may
need to unbind the interface drivers before the <a class="reference internal" href="usb.html#c.usb_device" title="usb_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">usb_device</span></code></a> will
suspend.  An unbound interface device is suspended by default.  When unbinding,
be careful to unbind interface drivers, not the driver of the parent usb
device.  Also, leave hub interface drivers bound.  If the driver for the usb
device (not interface) is unbound the kernel is no longer able to resume the
device.  If a hub interface driver is unbound, control of its child ports is
lost and all attached child-devices will disconnect.  A good rule of thumb is
that if the ‘driver/module’ link for a device points to
<code class="docutils literal notranslate"><span class="pre">/sys/module/usbcore</span></code> then unbinding it will interfere with port power
control.</p>
<p>Example of the relevant files for port power control.  Note, in this example
these files are relative to a usb hub device (prefix):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>prefix=/sys/devices/pci0000:00/0000:00:14.0/usb3/3-1

                 attached child device +
             hub port device +         |
hub interface device +       |         |
                     v       v         v
             $prefix/3-1:1.0/3-1-port1/device

$prefix/3-1:1.0/3-1-port1/power/pm_qos_no_power_off
$prefix/3-1:1.0/3-1-port1/device/power/control
$prefix/3-1:1.0/3-1-port1/device/3-1.1:&lt;intf0&gt;/driver/unbind
$prefix/3-1:1.0/3-1-port1/device/3-1.1:&lt;intf1&gt;/driver/unbind
...
$prefix/3-1:1.0/3-1-port1/device/3-1.1:&lt;intfN&gt;/driver/unbind
</pre></div>
</div>
<p>In addition to these files some ports may have a ‘peer’ link to a port on
another hub.  The expectation is that all superspeed ports have a
hi-speed peer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$prefix/3-1:1.0/3-1-port1/peer -&gt; ../../../../usb2/2-1/2-1:1.0/2-1-port1
../../../../usb2/2-1/2-1:1.0/2-1-port1/peer -&gt; ../../../../usb3/3-1/3-1:1.0/3-1-port1
</pre></div>
</div>
<p>Distinct from ‘companion ports’, or ‘ehci/xhci shared switchover ports’
peer ports are simply the hi-speed and superspeed interface pins that
are combined into a single usb3 connector.  Peer ports share the same
ancestor XHCI device.</p>
<p>While a superspeed port is powered off a device may downgrade its
connection and attempt to connect to the hi-speed pins.  The
implementation takes steps to prevent this:</p>
<ol class="arabic simple">
<li><p>Port suspend is sequenced to guarantee that hi-speed ports are powered-off
before their superspeed peer is permitted to power-off.  The implication is
that the setting <code class="docutils literal notranslate"><span class="pre">pm_qos_no_power_off</span></code> to zero on a superspeed port may
not cause the port to power-off until its highspeed peer has gone to its
runtime suspend state.  Userspace must take care to order the suspensions
if it wants to guarantee that a superspeed port will power-off.</p></li>
<li><p>Port resume is sequenced to force a superspeed port to power-on prior to its
highspeed peer.</p></li>
<li><p>Port resume always triggers an attached child device to resume.  After a
power session is lost the device may have been removed, or need reset.
Resuming the child device when the parent port regains power resolves those
states and clamps the maximum port power cycle frequency at the rate the
child device can suspend (autosuspend-delay) and resume (reset-resume
latency).</p></li>
</ol>
<p>Sysfs files relevant for port power control:</p>
<blockquote>
<div><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;hubdev-portX&gt;/power/pm_qos_no_power_off</span></code>:</dt><dd><p>This writable flag controls the state of an idle port.
Once all children and descendants have suspended the
port may suspend/poweroff provided that
pm_qos_no_power_off is ‘0’.  If pm_qos_no_power_off is
‘1’ the port will remain active/powered regardless of
the stats of descendants.  Defaults to 1.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;hubdev-portX&gt;/power/runtime_status</span></code>:</dt><dd><p>This file reflects whether the port is ‘active’ (power is on)
or ‘suspended’ (logically off).  There is no indication to
userspace whether VBUS is still supplied.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;hubdev-portX&gt;/connect_type</span></code>:</dt><dd><p>An advisory read-only flag to userspace indicating the
location and connection type of the port.  It returns
one of four values ‘hotplug’, ‘hardwired’, ‘not used’,
and ‘unknown’.  All values, besides unknown, are set by
platform firmware.</p>
<p><code class="docutils literal notranslate"><span class="pre">hotplug</span></code> indicates an externally connectable/visible
port on the platform.  Typically userspace would choose
to keep such a port powered to handle new device
connection events.</p>
<p><code class="docutils literal notranslate"><span class="pre">hardwired</span></code> refers to a port that is not visible but
connectable. Examples are internal ports for USB
bluetooth that can be disconnected via an external
switch or a port with a hardwired USB camera.  It is
expected to be safe to allow these ports to suspend
provided pm_qos_no_power_off is coordinated with any
switch that gates connections.  Userspace must arrange
for the device to be connected prior to the port
powering off, or to activate the port prior to enabling
connection via a switch.</p>
<p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">used</span></code> refers to an internal port that is expected
to never have a device connected to it.  These may be
empty internal ports, or ports that are not physically
exposed on a platform.  Considered safe to be
powered-off at all times.</p>
<p><code class="docutils literal notranslate"><span class="pre">unknown</span></code> means platform firmware does not provide
information for this port.  Most commonly refers to
external hub ports which should be considered ‘hotplug’
for policy decisions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>since we are relying on the BIOS to get this ACPI
information correct, the USB port descriptions may
be missing or wrong.</p></li>
<li><p>Take care in clearing <code class="docutils literal notranslate"><span class="pre">pm_qos_no_power_off</span></code>. Once
power is off this port will
not respond to new connect events.</p></li>
</ul>
</div>
</dd>
</dl>
<p>Once a child device is attached additional constraints are
applied before the port is allowed to poweroff.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;child&gt;/power/control</span></code>:</dt><dd><p>Must be <code class="docutils literal notranslate"><span class="pre">auto</span></code>, and the port will not
power down until <code class="docutils literal notranslate"><span class="pre">&lt;child&gt;/power/runtime_status</span></code>
reflects the ‘suspended’ state.  Default
value is controlled by child device driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;child&gt;/power/persist</span></code>:</dt><dd><p>This defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code> for most devices and indicates if
kernel can persist the device’s configuration across a
power session loss (suspend / port-power event).  When
this value is <code class="docutils literal notranslate"><span class="pre">0</span></code> (quirky devices), port poweroff is
disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;child&gt;/driver/unbind</span></code>:</dt><dd><p>Wakeup capable devices will block port poweroff.  At
this time the only mechanism to clear the usb-internal
wakeup-capability for an interface device is to unbind
its driver.</p>
</dd>
</dl>
</div></blockquote>
<p>Summary of poweroff pre-requisite settings relative to a port device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 0 &gt; power/pm_qos_no_power_off
echo 0 &gt; peer/power/pm_qos_no_power_off # if it exists
echo auto &gt; power/control # this is the default value
echo auto &gt; &lt;child&gt;/power/control
echo 1 &gt; &lt;child&gt;/power/persist # this is the default value
</pre></div>
</div>
</section>
<section id="suggested-userspace-port-power-policy">
<h2>Suggested Userspace Port Power Policy<a class="headerlink" href="#suggested-userspace-port-power-policy" title="Permalink to this headline">¶</a></h2>
<p>As noted above userspace needs to be careful and deliberate about what
ports are enabled for poweroff.</p>
<p>The default configuration is that all ports start with
<code class="docutils literal notranslate"><span class="pre">power/pm_qos_no_power_off</span></code> set to <code class="docutils literal notranslate"><span class="pre">1</span></code> causing ports to always remain
active.</p>
<p>Given confidence in the platform firmware’s description of the ports
(ACPI _PLD record for a port populates ‘connect_type’) userspace can
clear pm_qos_no_power_off for all ‘not used’ ports.  The same can be
done for ‘hardwired’ ports provided poweroff is coordinated with any
connection switch for the port.</p>
<p>A more aggressive userspace policy is to enable USB port power off for
all ports (set <code class="docutils literal notranslate"><span class="pre">&lt;hubdev-portX&gt;/power/pm_qos_no_power_off</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code>) when
some external factor indicates the user has stopped interacting with the
system.  For example, a distro may want to enable power off all USB
ports when the screen blanks, and re-power them when the screen becomes
active.  Smart phones and tablets may want to power off USB ports when
the user pushes the power button.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Power Management for USB</a><ul>
<li><a class="reference internal" href="#what-is-power-management">What is Power Management?</a></li>
<li><a class="reference internal" href="#what-is-remote-wakeup">What is Remote Wakeup?</a></li>
<li><a class="reference internal" href="#when-is-a-usb-device-idle">When is a USB device idle?</a></li>
<li><a class="reference internal" href="#forms-of-dynamic-pm">Forms of dynamic PM</a></li>
<li><a class="reference internal" href="#the-user-interface-for-dynamic-pm">The user interface for dynamic PM</a></li>
<li><a class="reference internal" href="#changing-the-default-idle-delay-time">Changing the default idle-delay time</a></li>
<li><a class="reference internal" href="#warnings">Warnings</a></li>
<li><a class="reference internal" href="#the-driver-interface-for-power-management">The driver interface for Power Management</a></li>
<li><a class="reference internal" href="#the-driver-interface-for-autosuspend-and-autoresume">The driver interface for autosuspend and autoresume</a></li>
<li><a class="reference internal" href="#other-parts-of-the-driver-interface">Other parts of the driver interface</a></li>
<li><a class="reference internal" href="#mutual-exclusion">Mutual exclusion</a></li>
<li><a class="reference internal" href="#interaction-between-dynamic-pm-and-system-pm">Interaction between dynamic PM and system PM</a></li>
<li><a class="reference internal" href="#xhci-hardware-link-pm">xHCI hardware link PM</a></li>
<li><a class="reference internal" href="#usb-port-power-control">USB Port Power Control</a></li>
<li><a class="reference internal" href="#user-interface-for-port-power-control">User Interface for Port Power Control</a></li>
<li><a class="reference internal" href="#suggested-userspace-port-power-policy">Suggested Userspace Port Power Policy</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/usb/power-management.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/usb/power-management.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>