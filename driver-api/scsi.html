
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>SCSI Interfaces Guide &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="libATA Developer’s Guide" href="libata.html" />
    <link rel="prev" title="Error Detection And Correction (EDAC) Devices" href="edac.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="scsi-interfaces-guide">
<h1>SCSI Interfaces Guide<a class="headerlink" href="#scsi-interfaces-guide" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>James Bottomley</p>
</dd>
<dt class="field-even">Author</dt>
<dd class="field-even"><p>Rob Landley</p>
</dd>
</dl>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<section id="protocol-vs-bus">
<h3>Protocol vs bus<a class="headerlink" href="#protocol-vs-bus" title="Permalink to this headline">¶</a></h3>
<p>Once upon a time, the Small Computer Systems Interface defined both a
parallel I/O bus and a data protocol to connect a wide variety of
peripherals (disk drives, tape drives, modems, printers, scanners,
optical drives, test equipment, and medical devices) to a host computer.</p>
<p>Although the old parallel (fast/wide/ultra) SCSI bus has largely fallen
out of use, the SCSI command set is more widely used than ever to
communicate with devices over a number of different busses.</p>
<p>The <a class="reference external" href="http://www.t10.org/scsi-3.htm">SCSI protocol</a> is a big-endian
peer-to-peer packet based protocol. SCSI commands are 6, 10, 12, or 16
bytes long, often followed by an associated data payload.</p>
<p>SCSI commands can be transported over just about any kind of bus, and
are the default protocol for storage devices attached to USB, SATA, SAS,
Fibre Channel, FireWire, and ATAPI devices. SCSI packets are also
commonly exchanged over Infiniband,
<a class="reference external" href="http://i2o.shadowconnect.com/faq.php">I2O</a>, TCP/IP
(<a class="reference external" href="https://en.wikipedia.org/wiki/ISCSI">iSCSI</a>), even <a class="reference external" href="http://cyberelk.net/tim/parport/parscsi.html">Parallel
ports</a>.</p>
</section>
<section id="design-of-the-linux-scsi-subsystem">
<h3>Design of the Linux SCSI subsystem<a class="headerlink" href="#design-of-the-linux-scsi-subsystem" title="Permalink to this headline">¶</a></h3>
<p>The SCSI subsystem uses a three layer design, with upper, mid, and low
layers. Every operation involving the SCSI subsystem (such as reading a
sector from a disk) uses one driver at each of the 3 levels: one upper
layer driver, one lower layer driver, and the SCSI midlayer.</p>
<p>The SCSI upper layer provides the interface between userspace and the
kernel, in the form of block and char device nodes for I/O and ioctl().
The SCSI lower layer contains drivers for specific hardware devices.</p>
<p>In between is the SCSI mid-layer, analogous to a network routing layer
such as the IPv4 stack. The SCSI mid-layer routes a packet based data
protocol between the upper layer’s /dev nodes and the corresponding
devices in the lower layer. It manages command queues, provides error
handling and power management functions, and responds to ioctl()
requests.</p>
</section>
</section>
<section id="scsi-upper-layer">
<h2>SCSI upper layer<a class="headerlink" href="#scsi-upper-layer" title="Permalink to this headline">¶</a></h2>
<p>The upper layer supports the user-kernel interface by providing device
nodes.</p>
<section id="sd-scsi-disk">
<h3>sd (SCSI Disk)<a class="headerlink" href="#sd-scsi-disk" title="Permalink to this headline">¶</a></h3>
<p>sd (sd_mod.o)</p>
</section>
<section id="sr-scsi-cd-rom">
<h3>sr (SCSI CD-ROM)<a class="headerlink" href="#sr-scsi-cd-rom" title="Permalink to this headline">¶</a></h3>
<p>sr (sr_mod.o)</p>
</section>
<section id="st-scsi-tape">
<h3>st (SCSI Tape)<a class="headerlink" href="#st-scsi-tape" title="Permalink to this headline">¶</a></h3>
<p>st (st.o)</p>
</section>
<section id="sg-scsi-generic">
<h3>sg (SCSI Generic)<a class="headerlink" href="#sg-scsi-generic" title="Permalink to this headline">¶</a></h3>
<p>sg (sg.o)</p>
</section>
<section id="ch-scsi-media-changer">
<h3>ch (SCSI Media Changer)<a class="headerlink" href="#ch-scsi-media-changer" title="Permalink to this headline">¶</a></h3>
<p>ch (ch.c)</p>
</section>
</section>
<section id="scsi-mid-layer">
<h2>SCSI mid layer<a class="headerlink" href="#scsi-mid-layer" title="Permalink to this headline">¶</a></h2>
<section id="scsi-midlayer-implementation">
<h3>SCSI midlayer implementation<a class="headerlink" href="#scsi-midlayer-implementation" title="Permalink to this headline">¶</a></h3>
<section id="include-scsi-scsi-device-h">
<h4>include/scsi/scsi_device.h<a class="headerlink" href="#include-scsi-scsi-device-h" title="Permalink to this headline">¶</a></h4>
<dl class="type">
<dt id="c.scsi_vpd">
struct <code class="sig-name descname">scsi_vpd</code><a class="headerlink" href="#c.scsi_vpd" title="Permalink to this definition">¶</a></dt>
<dd><p>SCSI Vital Product Data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct scsi_vpd {
    struct rcu_head rcu;
    int len;
    unsigned char   data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcu</span></code></dt><dd><p>For <a class="reference internal" href="../core-api/kernel-api.html#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>Length in bytes of <strong>data</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>VPD data as defined in various T10 SCSI standard documents.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.shost_for_each_device">
<code class="sig-name descname">shost_for_each_device</code><span class="sig-paren">(</span><em>sdev</em>, <em>shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.shost_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all devices of a host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sdev</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code> to use as a cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shost</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host</span></code> to iterate over</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterator that returns each device attached to <strong>shost</strong>.  This loop
takes a reference on each device and releases it at the end.  If
you break out of the loop, you must call scsi_device_put(sdev).</p>
</div>
<dl class="function">
<dt id="c.__shost_for_each_device">
<code class="sig-name descname">__shost_for_each_device</code><span class="sig-paren">(</span><em>sdev</em>, <em>shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__shost_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all devices of a host (UNLOCKED)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sdev</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code> to use as a cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shost</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host</span></code> to iterate over</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterator that returns each device attached to <strong>shost</strong>.  It does _not_
take a reference on the scsi_device, so the whole loop must be
protected by shost-&gt;host_lock.</p>
<p><strong>Note</strong></p>
<p>The only reason to use this is because you need to access the
device list in interrupt context.  Otherwise you really want to use
shost_for_each_device instead.</p>
</div>
<dl class="function">
<dt id="c.scsi_device_supports_vpd">
int <code class="sig-name descname">scsi_device_supports_vpd</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_supports_vpd" title="Permalink to this definition">¶</a></dt>
<dd><p>test if a device supports VPD pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code> to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the ‘try_vpd_pages’ flag is set it takes precedence.
Otherwise we will assume VPD pages are supported if the
SCSI level is at least SPC-3 and ‘skip_vpd_pages’ is not set.</p>
</div>
</section>
<section id="drivers-scsi-scsi-c">
<h4>drivers/scsi/scsi.c<a class="headerlink" href="#drivers-scsi-scsi-c" title="Permalink to this headline">¶</a></h4>
<p>Main file for the SCSI midlayer.</p>
<dl class="function">
<dt id="c.scsi_change_queue_depth">
int <code class="sig-name descname">scsi_change_queue_depth</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, int<em> depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_change_queue_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>change a device’s queue depth</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI Device in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">depth</span></code></dt><dd><p>number of commands allowed to be queued to the driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the device queue depth and returns the new value.</p>
</div>
<dl class="function">
<dt id="c.scsi_track_queue_full">
int <code class="sig-name descname">scsi_track_queue_full</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, int<em> depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_track_queue_full" title="Permalink to this definition">¶</a></dt>
<dd><p>track QUEUE_FULL events to adjust queue depth</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI Device in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">depth</span></code></dt><dd><p>Current number of outstanding SCSI commands on this device,
not counting the one returned as QUEUE_FULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>This function will track successive QUEUE_FULL events on a</dt><dd><p>specific SCSI device to determine if and when there is a
need to adjust the queue depth on the device.</p>
</dd>
</dl>
<p>Lock Status: None held on entry</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 - No change needed, &gt;0 - Adjust queue depth to this new depth,</dt><dd><dl class="simple">
<dt>-1 - Drop back to untagged operation using host-&gt;cmd_per_lun</dt><dd><p>as the untagged command depth</p>
</dd>
</dl>
</dd>
</dl>
<p><strong>Notes</strong></p>
<dl class="simple">
<dt>Low level drivers may call this at any time and we will do</dt><dd><p>“The Right Thing.”  We are interrupt context safe.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_get_vpd_page">
int <code class="sig-name descname">scsi_get_vpd_page</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, u8<em> page</em>, unsigned char<em> *buf</em>, int<em> buf_len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_get_vpd_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Vital Product Data from a SCSI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>The device to ask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">page</span></code></dt><dd><p>Which Vital Product Data to return</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>where to store the VPD</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buf_len</span></code></dt><dd><p>number of bytes in the VPD buffer area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>SCSI devices may optionally supply Vital Product Data.  Each ‘page’
of VPD is defined in the appropriate SCSI document (eg SPC, SBC).
If the device supports this VPD page, this routine fills <strong>buf</strong>
with the data from that page and return 0. If the VPD page is not
supported or its content cannot be retrieved, -EINVAL is returned.</p>
</div>
<dl class="function">
<dt id="c.scsi_report_opcode">
int <code class="sig-name descname">scsi_report_opcode</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, unsigned char<em> *buffer</em>, unsigned int<em> len</em>, unsigned char<em> opcode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_report_opcode" title="Permalink to this definition">¶</a></dt>
<dd><p>Find out if a given command opcode is supported</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buffer</span></code></dt><dd><p>scratch buffer (must be at least 20 bytes long)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">opcode</span></code></dt><dd><p>opcode for command to look up</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses the REPORT SUPPORTED OPERATION CODES to look up the given
opcode. Returns -EINVAL if RSOC fails, 0 if the command opcode is
unsupported and 1 if the device claims to support the command.</p>
</div>
<dl class="function">
<dt id="c.scsi_device_get">
int <code class="sig-name descname">scsi_device_get</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get an additional reference to a scsi_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>device to get a reference to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets a reference to the scsi_device and increments the use count
of the underlying LLDD module.  You must hold host_lock of the
parent Scsi_Host or already have a reference when calling this.</p>
<p>This will fail if a device is deleted or cancelled, or when the LLD module
is in the process of being unloaded.</p>
</div>
<dl class="function">
<dt id="c.scsi_device_put">
void <code class="sig-name descname">scsi_device_put</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to a scsi_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>device to release a reference on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release a reference to the scsi_device and decrements the use
count of the underlying LLDD module.  The device is freed once the last
user vanishes.</p>
</div>
<dl class="function">
<dt id="c.starget_for_each_device">
void <code class="sig-name descname">starget_for_each_device</code><span class="sig-paren">(</span>struct scsi_target<em> *starget</em>, void<em> *data</em>, void (<em>*fn</em>)(struct scsi_device *, void *)<span class="sig-paren">)</span><a class="headerlink" href="#c.starget_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to walk all devices of a target</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>target whose devices we want to iterate over.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Opaque passed to each function call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*fn)(struct</span> <span class="pre">scsi_device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Function to call on each device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This traverses over each device of <strong>starget</strong>.  The devices have
a reference that must be released by scsi_host_put when breaking
out of the loop.</p>
</div>
<dl class="function">
<dt id="c.__starget_for_each_device">
void <code class="sig-name descname">__starget_for_each_device</code><span class="sig-paren">(</span>struct scsi_target<em> *starget</em>, void<em> *data</em>, void (<em>*fn</em>)(struct scsi_device *, void *)<span class="sig-paren">)</span><a class="headerlink" href="#c.__starget_for_each_device" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to walk all devices of a target (UNLOCKED)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>target whose devices we want to iterate over.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>parameter for callback <strong>fn()</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*fn)(struct</span> <span class="pre">scsi_device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback function that is invoked for each device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This traverses over each device of <strong>starget</strong>.  It does _not_
take a reference on the scsi_device, so the whole loop must be
protected by shost-&gt;host_lock.</p>
<p><strong>Note</strong></p>
<p>The only reason why drivers would want to use this is because
they need to access the device list in irq context.  Otherwise you
really want to use starget_for_each_device instead.</p>
</div>
<dl class="function">
<dt id="c.__scsi_device_lookup_by_target">
struct scsi_device * <code class="sig-name descname">__scsi_device_lookup_by_target</code><span class="sig-paren">(</span>struct scsi_target<em> *starget</em>, u64<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__scsi_device_lookup_by_target" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device given the target (UNLOCKED)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>SCSI target pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>lun</strong> for a given
<strong>starget</strong>.  The returned scsi_device does not have an additional
reference.  You must hold the host’s host_lock over this call and
any access to the returned scsi_device. A scsi_device in state
SDEV_DEL is skipped.</p>
<p><strong>Note</strong></p>
<p>The only reason why drivers should use this is because
they need to access the device list in irq context.  Otherwise you
really want to use scsi_device_lookup_by_target instead.</p>
</div>
<dl class="function">
<dt id="c.scsi_device_lookup_by_target">
struct scsi_device * <code class="sig-name descname">scsi_device_lookup_by_target</code><span class="sig-paren">(</span>struct scsi_target<em> *starget</em>, u64<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_lookup_by_target" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device given the target</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>SCSI target pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>lun</strong> for a given
<strong>starget</strong>.  The returned scsi_device has an additional reference that
needs to be released with scsi_device_put once you’re done with it.</p>
</div>
<dl class="function">
<dt id="c.__scsi_device_lookup">
struct scsi_device * <code class="sig-name descname">__scsi_device_lookup</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, uint<em> channel</em>, uint<em> id</em>, u64<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__scsi_device_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device given the host (UNLOCKED)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>SCSI host pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>SCSI channel (zero if only one channel)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>SCSI target number (physical unit number)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>channel</strong>, <strong>id</strong>, <strong>lun</strong>
for a given host. The returned scsi_device does not have an additional
reference.  You must hold the host’s host_lock over this call and any access
to the returned scsi_device.</p>
<p><strong>Note</strong></p>
<p>The only reason why drivers would want to use this is because
they need to access the device list in irq context.  Otherwise you
really want to use scsi_device_lookup instead.</p>
</div>
<dl class="function">
<dt id="c.scsi_device_lookup">
struct scsi_device * <code class="sig-name descname">scsi_device_lookup</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, uint<em> channel</em>, uint<em> id</em>, u64<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device given the host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>SCSI host pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>SCSI channel (zero if only one channel)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>SCSI target number (physical unit number)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>SCSI Logical Unit Number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the scsi_device with the specified <strong>channel</strong>, <strong>id</strong>, <strong>lun</strong>
for a given host.  The returned scsi_device has an additional reference that
needs to be released with scsi_device_put once you’re done with it.</p>
</div>
</section>
<section id="drivers-scsi-scsicam-c">
<h4>drivers/scsi/scsicam.c<a class="headerlink" href="#drivers-scsi-scsicam-c" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="http://www.t10.org/ftp/t10/drafts/cam/cam-r12b.pdf">SCSI Common Access
Method</a> support
functions, for use with HDIO_GETGEO, etc.</p>
<dl class="function">
<dt id="c.scsi_bios_ptable">
unsigned char * <code class="sig-name descname">scsi_bios_ptable</code><span class="sig-paren">(</span>struct block_device<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_bios_ptable" title="Permalink to this definition">¶</a></dt>
<dd><p>Read PC partition table out of first sector of device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*dev</span></code></dt><dd><p>from this device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Reads the first sector from the device and returns <code class="docutils literal notranslate"><span class="pre">0x42</span></code> bytes</dt><dd><p>starting at offset <code class="docutils literal notranslate"><span class="pre">0x1be</span></code>.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>partition table in kmalloc(GFP_KERNEL) memory, or NULL on error.</p>
</div>
<dl class="function">
<dt id="c.scsi_partsize">
bool <code class="sig-name descname">scsi_partsize</code><span class="sig-paren">(</span>struct block_device<em> *bdev</em>, sector_t<em> capacity</em>, int<em> geom[3]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_partsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse cylinders/heads/sectors from PC partition table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>block device to parse</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">capacity</span></code></dt><dd><p>size of the disk in sectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">geom[3]</span></code></dt><dd><p>output in form of [hds, cylinders, sectors]</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the BIOS mapping/geometry used to create the partition
table, storing the results in <strong>geom</strong>.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> on failure, <code class="docutils literal notranslate"><span class="pre">true</span></code> on success.</p>
</div>
<dl class="function">
<dt id="c.scsicam_bios_param">
int <code class="sig-name descname">scsicam_bios_param</code><span class="sig-paren">(</span>struct block_device<em> *bdev</em>, sector_t<em> capacity</em>, int<em> *ip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsicam_bios_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine geometry of a disk in cylinders/heads/sectors.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*bdev</span></code></dt><dd><p>which device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sector_t</span> <span class="pre">capacity</span></code></dt><dd><p>size of the disk in sectors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*ip</span></code></dt><dd><p>return value: ip[0]=heads, ip[1]=sectors, ip[2]=cylinders</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>determine the BIOS mapping/geometry used for a drive in a</dt><dd><p>SCSI-CAM system, storing the results in ip as required
by the HDIO_GETGEO ioctl().</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>-1 on failure, 0 on success.</p>
</div>
</section>
<section id="drivers-scsi-scsi-error-c">
<h4>drivers/scsi/scsi_error.c<a class="headerlink" href="#drivers-scsi-scsi-error-c" title="Permalink to this headline">¶</a></h4>
<p>Common SCSI error/timeout handling routines.</p>
<dl class="function">
<dt id="c.scsi_schedule_eh">
void <code class="sig-name descname">scsi_schedule_eh</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_schedule_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule EH for SCSI host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>SCSI host to invoke error handling on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule SCSI EH without scmd.</p>
</div>
<dl class="function">
<dt id="c.scsi_block_when_processing_errors">
int <code class="sig-name descname">scsi_block_when_processing_errors</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_block_when_processing_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>Prevent cmds from being queued.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>Device on which we are performing recovery.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>We block until the host is out of error recovery, and then check to
see whether the host or the device is offline.</p>
</div></blockquote>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 when dev was taken offline by error recovery. 1 OK to proceed.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_check_sense">
enum scsi_disposition <code class="sig-name descname">scsi_check_sense</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *scmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_check_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>Examine scsi cmd sense</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>Cmd to have sense checked.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>SUCCESS or FAILED or NEEDS_RETRY or ADD_TO_MLQUEUE</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>When a deferred error is detected the current command has
not been executed and needs retrying.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.scsi_eh_prep_cmnd">
void <code class="sig-name descname">scsi_eh_prep_cmnd</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *scmd</em>, struct scsi_eh_save<em> *ses</em>, unsigned char<em> *cmnd</em>, int<em> cmnd_size</em>, unsigned<em> sense_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_prep_cmnd" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a scsi command info as part of error recovery</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>SCSI command structure to hijack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_eh_save</span> <span class="pre">*ses</span></code></dt><dd><p>structure to save restore information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*cmnd</span></code></dt><dd><p>CDB to send. Can be NULL if no new cmnd is needed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmnd_size</span></code></dt><dd><p>size in bytes of <strong>cmnd</strong> (must be &lt;= MAX_COMMAND_SIZE)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">sense_bytes</span></code></dt><dd><p>size of sense data to copy. or 0 (if != 0 <strong>cmnd</strong> is ignored)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to save a scsi command information before re-execution
as part of the error recovery process.  If <strong>sense_bytes</strong> is 0 the command
sent must be one that does not transfer any data.  If <strong>sense_bytes</strong> != 0
<strong>cmnd</strong> is ignored and this functions sets up a REQUEST_SENSE command
and cmnd buffers to read <strong>sense_bytes</strong> into <strong>scmd-&gt;sense_buffer</strong>.</p>
</div>
<dl class="function">
<dt id="c.scsi_eh_restore_cmnd">
void <code class="sig-name descname">scsi_eh_restore_cmnd</code><span class="sig-paren">(</span>struct scsi_cmnd*<em> scmd</em>, struct scsi_eh_save<em> *ses</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_restore_cmnd" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore a scsi command info as part of error recovery</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd*</span> <span class="pre">scmd</span></code></dt><dd><p>SCSI command structure to restore</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_eh_save</span> <span class="pre">*ses</span></code></dt><dd><p>saved information from a coresponding call to scsi_eh_prep_cmnd</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo any damage done by above <a class="reference internal" href="#c.scsi_eh_prep_cmnd" title="scsi_eh_prep_cmnd"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_eh_prep_cmnd()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.scsi_eh_finish_cmd">
void <code class="sig-name descname">scsi_eh_finish_cmd</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *scmd</em>, struct list_head<em> *done_q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_finish_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a cmd that eh is finished with.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>Original SCSI cmd that eh has finished.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*done_q</span></code></dt><dd><p>Queue for processed commands.</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>We don’t want to use the normal command completion while we are are
still handling errors - it may cause other commands to be queued,
and that would disturb what we are doing.  Thus we really want to
keep a list of pending commands for final completion, and once we
are ready to leave error handling we handle completion for real.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.scsi_eh_get_sense">
int <code class="sig-name descname">scsi_eh_get_sense</code><span class="sig-paren">(</span>struct list_head<em> *work_q</em>, struct list_head<em> *done_q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_get_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>Get device sense data.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*work_q</span></code></dt><dd><p>Queue of commands to process.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*done_q</span></code></dt><dd><p>Queue of processed commands.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>See if we need to request sense information.  if so, then get it
now, so we have a better idea of what to do.</p>
</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This has the unfortunate side effect that if a shost adapter does
not automatically request sense information, we end up shutting
it down before we request it.</p>
<p>All drivers should request sense information internally these days,
so for now all I have to say is tough noogies if you end up in here.</p>
<dl class="simple">
<dt>XXX: Long term this code should go away, but that needs an audit of</dt><dd><p>all LLDDs first.</p>
</dd>
</dl>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.scsi_eh_ready_devs">
void <code class="sig-name descname">scsi_eh_ready_devs</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, struct list_head<em> *work_q</em>, struct list_head<em> *done_q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_ready_devs" title="Permalink to this definition">¶</a></dt>
<dd><p>check device ready state and recover if not.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host to be recovered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*work_q</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> for pending commands.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*done_q</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code> for processed commands.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_eh_flush_done_q">
void <code class="sig-name descname">scsi_eh_flush_done_q</code><span class="sig-paren">(</span>struct list_head<em> *done_q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_eh_flush_done_q" title="Permalink to this definition">¶</a></dt>
<dd><p>finish processed commands or retry them.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*done_q</span></code></dt><dd><p>list_head of processed commands.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_get_sense_info_fld">
bool <code class="sig-name descname">scsi_get_sense_info_fld</code><span class="sig-paren">(</span>const u8<em> *sense_buffer</em>, int<em> sb_len</em>, u64<em> *info_out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_get_sense_info_fld" title="Permalink to this definition">¶</a></dt>
<dd><p>get information field from sense data (either fixed or descriptor format)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*sense_buffer</span></code></dt><dd><p>byte array of sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sb_len</span></code></dt><dd><p>number of valid bytes in sense_buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*info_out</span></code></dt><dd><p>pointer to 64 integer where 8 or 4 byte information
field will be placed if found.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>true if information field found, false if not found.</p>
</dd>
</dl>
</div>
</section>
<section id="drivers-scsi-scsi-devinfo-c">
<h4>drivers/scsi/scsi_devinfo.c<a class="headerlink" href="#drivers-scsi-scsi-devinfo-c" title="Permalink to this headline">¶</a></h4>
<p>Manage scsi_dev_info_list, which tracks blacklisted and whitelisted
devices.</p>
<dl class="function">
<dt id="c.scsi_dev_info_list_add">
int <code class="sig-name descname">scsi_dev_info_list_add</code><span class="sig-paren">(</span>int<em> compatible</em>, char<em> *vendor</em>, char<em> *model</em>, char<em> *strflags</em>, blist_flags_t<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dev_info_list_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add one dev_info list entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">compatible</span></code></dt><dd><p>if true, null terminate short strings.  Otherwise space pad.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*vendor</span></code></dt><dd><p>vendor string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*model</span></code></dt><dd><p>model (product) string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*strflags</span></code></dt><dd><p>integer string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">flags</span></code></dt><dd><p>if strflags NULL, use this flag value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Create and add one dev_info entry for <strong>vendor</strong>, <strong>model</strong>, <strong>strflags</strong> or
<strong>flag</strong>. If <strong>compatible</strong>, add to the tail of the list, do not space
pad, and set devinfo-&gt;compatible. The scsi_static_device_list entries
are added with <strong>compatible</strong> 1 and <strong>clfags</strong> NULL.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>0 OK, -error on failure.</p>
</div>
<dl class="function">
<dt id="c.scsi_dev_info_list_find">
struct scsi_dev_info_list * <code class="sig-name descname">scsi_dev_info_list_find</code><span class="sig-paren">(</span>const char<em> *vendor</em>, const char<em> *model</em>, enum scsi_devinfo_key<em> key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dev_info_list_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find a matching dev_info list entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*vendor</span></code></dt><dd><p>full vendor string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*model</span></code></dt><dd><p>full model (product) string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_devinfo_key</span> <span class="pre">key</span></code></dt><dd><p>specify list to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Finds the first dev_info entry matching <strong>vendor</strong>, <strong>model</strong>
in list specified by <strong>key</strong>.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>pointer to matching entry, or ERR_PTR on failure.</p>
</div>
<dl class="function">
<dt id="c.scsi_dev_info_list_add_str">
int <code class="sig-name descname">scsi_dev_info_list_add_str</code><span class="sig-paren">(</span>char<em> *dev_list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dev_info_list_add_str" title="Permalink to this definition">¶</a></dt>
<dd><p>parse dev_list and add to the scsi_dev_info_list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*dev_list</span></code></dt><dd><p>string of device flags to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Parse dev_list, and add entries to the scsi_dev_info_list.
dev_list is of the form “vendor:product:flag,vendor:product:flag”.
dev_list is modified via strsep. Can be called for command line
addition, for proc or mabye a sysfs interface.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>0 if OK, -error on failure.</p>
</div>
<dl class="function">
<dt id="c.scsi_get_device_flags">
blist_flags_t <code class="sig-name descname">scsi_get_device_flags</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, const unsigned char<em> *vendor</em>, const unsigned char<em> *model</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_get_device_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>get device specific flags from the dynamic device list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">scsi_device</span></code> to get flags for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*vendor</span></code></dt><dd><p>vendor name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*model</span></code></dt><dd><p>model name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Search the global scsi_dev_info_list (specified by list zero)
for an entry matching <strong>vendor</strong> and <strong>model</strong>, if found, return the
matching flags value, else return the host or global default
settings.  Called during scan time.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.scsi_exit_devinfo">
void <code class="sig-name descname">scsi_exit_devinfo</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_exit_devinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>remove /proc/scsi/device_info &amp; the scsi_dev_info_list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_init_devinfo">
int <code class="sig-name descname">scsi_init_devinfo</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_init_devinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>set up the dynamic device list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Add command line entries from scsi_dev_flags, then add
scsi_static_device_list entries to the scsi device info list.</p>
</div></blockquote>
</div>
</section>
<section id="drivers-scsi-scsi-ioctl-c">
<h4>drivers/scsi/scsi_ioctl.c<a class="headerlink" href="#drivers-scsi-scsi-ioctl-c" title="Permalink to this headline">¶</a></h4>
<p>Handle ioctl() calls for SCSI devices.</p>
<dl class="function">
<dt id="c.scsi_ioctl">
int <code class="sig-name descname">scsi_ioctl</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, fmode_t<em> mode</em>, int<em> cmd</em>, void __user<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Dispatch ioctl to scsi device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device receiving ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fmode_t</span> <span class="pre">mode</span></code></dt><dd><p>mode the block/char device is opened with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>which ioctl is it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*arg</span></code></dt><dd><p>data associated with ioctl</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.scsi_ioctl" title="scsi_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_ioctl()</span></code></a> function differs from most ioctls in that it
does not take a major/minor number as the dev field.  Rather, it takes
a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span></code>.</p>
</div>
</section>
<section id="drivers-scsi-scsi-lib-c">
<h4>drivers/scsi/scsi_lib.c<a class="headerlink" href="#drivers-scsi-scsi-lib-c" title="Permalink to this headline">¶</a></h4>
<p>SCSI queuing library.</p>
<dl class="function">
<dt id="c.__scsi_execute">
int <code class="sig-name descname">__scsi_execute</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, const unsigned char<em> *cmd</em>, int<em> data_direction</em>, void<em> *buffer</em>, unsigned<em> bufflen</em>, unsigned char<em> *sense</em>, struct scsi_sense_hdr<em> *sshdr</em>, int<em> timeout</em>, int<em> retries</em>, blk_opf_t<em> flags</em>, req_flags_t<em> rq_flags</em>, int<em> *resid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__scsi_execute" title="Permalink to this definition">¶</a></dt>
<dd><p>insert request and wait for the result</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*cmd</span></code></dt><dd><p>scsi command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">data_direction</span></code></dt><dd><p>data direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">bufflen</span></code></dt><dd><p>len of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*sense</span></code></dt><dd><p>optional sense buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*sshdr</span></code></dt><dd><p>optional decoded sense header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>request timeout in HZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retries</span></code></dt><dd><p>number of times to retry request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blk_opf_t</span> <span class="pre">flags</span></code></dt><dd><p>flags for -&gt;cmd_flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_flags_t</span> <span class="pre">rq_flags</span></code></dt><dd><p>flags for -&gt;rq_flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*resid</span></code></dt><dd><p>optional residual length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the scsi_cmnd result field if a command was executed, or a negative
Linux error code if we didn’t get that far.</p>
</div>
<dl class="function">
<dt id="c.scsi_alloc_sgtables">
blk_status_t <code class="sig-name descname">scsi_alloc_sgtables</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_alloc_sgtables" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and initialize data and integrity scatterlists</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmd</span></code></dt><dd><p>SCSI command data structure to initialize.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes <strong>cmd-&gt;sdb</strong> and also <strong>cmd-&gt;prot_sdb</strong> if data integrity is enabled
for <strong>cmd</strong>.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>BLK_STS_OK       - on success</p></li>
<li><p>BLK_STS_RESOURCE - if the failure is retryable</p></li>
<li><p>BLK_STS_IOERR    - if the failure is fatal</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.scsi_device_from_queue">
struct scsi_device * <code class="sig-name descname">scsi_device_from_queue</code><span class="sig-paren">(</span>struct request_queue<em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_from_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>return sdev associated with a request_queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*q</span></code></dt><dd><p>The request queue to return the sdev from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the sdev associated with a request queue or NULL if the
request_queue does not reference a SCSI device.</p>
</div>
<dl class="function">
<dt id="c.scsi_block_requests">
void <code class="sig-name descname">scsi_block_requests</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_block_requests" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function used by low-level drivers to prevent further commands from being queued to the device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>There is no timer nor any other means by which the requests get unblocked
other than the low-level driver calling <a class="reference internal" href="#c.scsi_unblock_requests" title="scsi_unblock_requests"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_unblock_requests()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.scsi_unblock_requests">
void <code class="sig-name descname">scsi_unblock_requests</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_unblock_requests" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function used by low-level drivers to allow further commands to be queued to the device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>There is no timer nor any other means by which the requests get unblocked
other than the low-level driver calling <a class="reference internal" href="#c.scsi_unblock_requests" title="scsi_unblock_requests"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_unblock_requests()</span></code></a>. This is done
as an API function so that changes to the internals of the scsi mid-layer
won’t require wholesale changes to drivers that use this feature.</p>
</div>
<dl class="function">
<dt id="c.scsi_mode_select">
int <code class="sig-name descname">scsi_mode_select</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, int<em> pf</em>, int<em> sp</em>, unsigned char<em> *buffer</em>, int<em> len</em>, int<em> timeout</em>, int<em> retries</em>, struct scsi_mode_data<em> *data</em>, struct scsi_sense_hdr<em> *sshdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_mode_select" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a mode select</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI device to be queried</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pf</span></code></dt><dd><p>Page format bit (1 == standard, 0 == vendor specific)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sp</span></code></dt><dd><p>Save page bit (0 == don’t save, 1 == save)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buffer</span></code></dt><dd><p>request buffer (may not be smaller than eight bytes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of request buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>command timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retries</span></code></dt><dd><p>number of retries before failing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_mode_data</span> <span class="pre">*data</span></code></dt><dd><p>returns a structure abstracting the mode header data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*sshdr</span></code></dt><dd><p>place to put sense data (or NULL if no sense to be collected).
must be SCSI_SENSE_BUFFERSIZE big.</p>
<blockquote>
<div><p>Returns zero if successful; negative error number or scsi
status on error</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_mode_sense">
int <code class="sig-name descname">scsi_mode_sense</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, int<em> dbd</em>, int<em> modepage</em>, unsigned char<em> *buffer</em>, int<em> len</em>, int<em> timeout</em>, int<em> retries</em>, struct scsi_mode_data<em> *data</em>, struct scsi_sense_hdr<em> *sshdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_mode_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a mode sense, falling back from 10 to six bytes if necessary.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI device to be queried</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dbd</span></code></dt><dd><p>set to prevent mode sense from returning block descriptors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">modepage</span></code></dt><dd><p>mode page being requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buffer</span></code></dt><dd><p>request buffer (may not be smaller than eight bytes)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of request buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>command timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retries</span></code></dt><dd><p>number of retries before failing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_mode_data</span> <span class="pre">*data</span></code></dt><dd><p>returns a structure abstracting the mode header data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*sshdr</span></code></dt><dd><p>place to put sense data (or NULL if no sense to be collected).
must be SCSI_SENSE_BUFFERSIZE big.</p>
<blockquote>
<div><p>Returns zero if successful, or a negative error number on failure</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_test_unit_ready">
int <code class="sig-name descname">scsi_test_unit_ready</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, int<em> timeout</em>, int<em> retries</em>, struct scsi_sense_hdr<em> *sshdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_test_unit_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>test if unit is ready</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to change the state of.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeout</span></code></dt><dd><p>command timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retries</span></code></dt><dd><p>number of retries before failing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*sshdr</span></code></dt><dd><p>outpout pointer for decoded sense information.</p>
<p>Returns zero if unsuccessful or an error if TUR failed.  For
removable media, UNIT_ATTENTION sets -&gt;changed flag.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_device_set_state">
int <code class="sig-name descname">scsi_device_set_state</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, enum scsi_device_state<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_set_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the given device through the device state model.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to change the state of.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_state</span> <span class="pre">state</span></code></dt><dd><p>state to change to.</p>
<p>Returns zero if successful or an error if the requested
transition is illegal.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sdev_evt_send">
void <code class="sig-name descname">sdev_evt_send</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, struct scsi_event<em> *evt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sdev_evt_send" title="Permalink to this definition">¶</a></dt>
<dd><p>send asserted event to uevent thread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi_device event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_event</span> <span class="pre">*evt</span></code></dt><dd><p>event to send</p>
<p>Assert scsi device event asynchronously.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sdev_evt_alloc">
struct scsi_event * <code class="sig-name descname">sdev_evt_alloc</code><span class="sig-paren">(</span>enum scsi_device_event<em> evt_type</em>, gfp_t<em> gfpflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sdev_evt_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a new scsi event</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_event</span> <span class="pre">evt_type</span></code></dt><dd><p>type of event to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfpflags</span></code></dt><dd><p>GFP flags for allocation</p>
<p>Allocates and returns a new scsi_event.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sdev_evt_send_simple">
void <code class="sig-name descname">sdev_evt_send_simple</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, enum scsi_device_event<em> evt_type</em>, gfp_t<em> gfpflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sdev_evt_send_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>send asserted event to uevent thread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi_device event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_event</span> <span class="pre">evt_type</span></code></dt><dd><p>type of event to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfpflags</span></code></dt><dd><p>GFP flags for allocation</p>
<p>Assert scsi device event asynchronously, given an event type.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_device_quiesce">
int <code class="sig-name descname">scsi_device_quiesce</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_quiesce" title="Permalink to this definition">¶</a></dt>
<dd><p>Block all commands except power management.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to quiesce.</p>
<p>This works by trying to transition to the SDEV_QUIESCE state
(which must be a legal transition).  When the device is in this
state, only power management requests will be accepted, all others will
be deferred.</p>
<p>Must be called with user context, may sleep.</p>
<p>Returns zero if unsuccessful or an error if not.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_device_resume">
void <code class="sig-name descname">scsi_device_resume</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Restart user issued commands to a quiesced device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to resume.</p>
<p>Moves the device from quiesced back to running and restarts the
queues.</p>
<p>Must be called with user context, may sleep.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_internal_device_block_nowait">
int <code class="sig-name descname">scsi_internal_device_block_nowait</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_internal_device_block_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>try to transition to the SDEV_BLOCK state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>device to block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pause SCSI command processing on the specified device. Does not sleep.</p>
<p>Returns zero if successful or a negative error code upon failure.</p>
<p><strong>Notes</strong></p>
<p>This routine transitions the device to the SDEV_BLOCK state (which must be
a legal transition). When the device is in this state, command processing
is paused until the device leaves the SDEV_BLOCK state. See also
<a class="reference internal" href="#c.scsi_internal_device_unblock_nowait" title="scsi_internal_device_unblock_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_internal_device_unblock_nowait()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.scsi_internal_device_unblock_nowait">
int <code class="sig-name descname">scsi_internal_device_unblock_nowait</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, enum scsi_device_state<em> new_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_internal_device_unblock_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>resume a device after a block request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>device to resume</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_device_state</span> <span class="pre">new_state</span></code></dt><dd><p>state to set the device to after unblocking</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Restart the device queue for a previously suspended SCSI device. Does not
sleep.</p>
<p>Returns zero if successful or a negative error code upon failure.</p>
<p><strong>Notes</strong></p>
<p>This routine transitions the device to the SDEV_RUNNING state or to one of
the offline states (which must be a legal transition) allowing the midlayer
to goose the queue for this device.</p>
</div>
<dl class="function">
<dt id="c.scsi_kmap_atomic_sg">
void * <code class="sig-name descname">scsi_kmap_atomic_sg</code><span class="sig-paren">(</span>struct scatterlist<em> *sgl</em>, int<em> sg_count</em>, size_t<em> *offset</em>, size_t<em> *len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_kmap_atomic_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>find and atomically map an sg-elemnt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*sgl</span></code></dt><dd><p>scatter-gather list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sg_count</span></code></dt><dd><p>number of segments in sg</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*offset</span></code></dt><dd><p>offset in bytes into sg, on return offset into the mapped area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*len</span></code></dt><dd><p>bytes to map, on return number of bytes mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns virtual address of the start of the mapped page</p>
</div>
<dl class="function">
<dt id="c.scsi_kunmap_atomic_sg">
void <code class="sig-name descname">scsi_kunmap_atomic_sg</code><span class="sig-paren">(</span>void<em> *virt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_kunmap_atomic_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>atomically unmap a virtual address, previously mapped with scsi_kmap_atomic_sg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*virt</span></code></dt><dd><p>virtual address to be unmapped</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_vpd_lun_id">
int <code class="sig-name descname">scsi_vpd_lun_id</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, char<em> *id</em>, size_t<em> id_len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_vpd_lun_id" title="Permalink to this definition">¶</a></dt>
<dd><p>return a unique device identification</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>SCSI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>buffer for the identification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">id_len</span></code></dt><dd><p>length of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies a unique device identification into <strong>id</strong> based
on the information in the VPD page 0x83 of the device.
The string will be formatted as a SCSI name string.</p>
<p>Returns the length of the identification or error on failure.
If the identifier is longer than the supplied buffer the actual
identifier length is returned and the buffer is not zero-padded.</p>
</div>
<dl class="function">
<dt id="c.scsi_build_sense">
void <code class="sig-name descname">scsi_build_sense</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *scmd</em>, int<em> desc</em>, u8<em> key</em>, u8<em> asc</em>, u8<em> ascq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_build_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>build sense data for a command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>scsi command for which the sense should be formatted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">desc</span></code></dt><dd><p>Sense format (non-zero == descriptor format,
0 == fixed format)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">key</span></code></dt><dd><p>Sense key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">asc</span></code></dt><dd><p>Additional sense code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">ascq</span></code></dt><dd><p>Additional sense code qualifier</p>
</dd>
</dl>
</div>
</section>
<section id="drivers-scsi-scsi-lib-dma-c">
<h4>drivers/scsi/scsi_lib_dma.c<a class="headerlink" href="#drivers-scsi-scsi-lib-dma-c" title="Permalink to this headline">¶</a></h4>
<p>SCSI library functions depending on DMA (map and unmap scatter-gather
lists).</p>
<dl class="function">
<dt id="c.scsi_dma_map">
int <code class="sig-name descname">scsi_dma_map</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dma_map" title="Permalink to this definition">¶</a></dt>
<dd><p>perform DMA mapping against command’s sg lists</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmd</span></code></dt><dd><p>scsi command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of sg lists actually used, zero if the sg lists
is NULL, or -ENOMEM if the mapping failed.</p>
</div>
<dl class="function">
<dt id="c.scsi_dma_unmap">
void <code class="sig-name descname">scsi_dma_unmap</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_dma_unmap" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap command’s sg lists mapped by scsi_dma_map</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmd</span></code></dt><dd><p>scsi command</p>
</dd>
</dl>
</div>
</section>
<section id="drivers-scsi-scsi-proc-c">
<h4>drivers/scsi/scsi_proc.c<a class="headerlink" href="#drivers-scsi-scsi-proc-c" title="Permalink to this headline">¶</a></h4>
<p>The functions in this file provide an interface between the PROC file
system and the SCSI device drivers It is mainly used for debugging,
statistics and to pass information directly to the lowlevel driver. I.E.
plumbing to manage /proc/scsi/*</p>
<dl class="type">
<dt id="c.scsi_proc_entry">
struct <code class="sig-name descname">scsi_proc_entry</code><a class="headerlink" href="#c.scsi_proc_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>(host template, SCSI proc dir) association</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct scsi_proc_entry {
    struct list_head        entry;
    const struct scsi_host_template *sht;
    struct proc_dir_entry   *proc_dir;
    unsigned int            present;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>entry in scsi_proc_list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sht</span></code></dt><dd><p>SCSI host template associated with the procfs directory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proc_dir</span></code></dt><dd><p>procfs directory associated with the SCSI host template.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">present</span></code></dt><dd><p>Number of SCSI hosts instantiated for <strong>sht</strong>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_proc_hostdir_add">
int <code class="sig-name descname">scsi_proc_hostdir_add</code><span class="sig-paren">(</span>const struct scsi_host_template<em> *sht</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_hostdir_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create directory in /proc for a scsi host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*sht</span></code></dt><dd><p>owner of this directory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets sht-&gt;proc_dir to the new directory.</p>
</div>
<dl class="function">
<dt id="c.scsi_proc_hostdir_rm">
void <code class="sig-name descname">scsi_proc_hostdir_rm</code><span class="sig-paren">(</span>const struct scsi_host_template<em> *sht</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_hostdir_rm" title="Permalink to this definition">¶</a></dt>
<dd><p>remove directory in /proc for a scsi host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*sht</span></code></dt><dd><p>owner of directory</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_proc_host_add">
void <code class="sig-name descname">scsi_proc_host_add</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_host_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add entry for this host to appropriate /proc dir</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host to add</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_proc_host_rm">
void <code class="sig-name descname">scsi_proc_host_rm</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_proc_host_rm" title="Permalink to this definition">¶</a></dt>
<dd><p>remove this host’s entry from /proc</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>which host</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.proc_print_scsidevice">
int <code class="sig-name descname">proc_print_scsidevice</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_print_scsidevice" title="Permalink to this definition">¶</a></dt>
<dd><p>return data about this host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>A scsi device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">seq_file</span></code> to output to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>prints Host, Channel, Id, Lun, Vendor, Model, Rev, Type,
and revision.</p>
</div>
<dl class="function">
<dt id="c.scsi_add_single_device">
int <code class="sig-name descname">scsi_add_single_device</code><span class="sig-paren">(</span>uint<em> host</em>, uint<em> channel</em>, uint<em> id</em>, uint<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_add_single_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Respond to user request to probe for/add device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">host</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">lun</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called by writing “scsi add-single-device” to /proc/scsi/scsi.</p>
<p>does <a class="reference internal" href="#c.scsi_host_lookup" title="scsi_host_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_host_lookup()</span></code></a> and either user_scan() if that transport
type supports it, or else scsi_scan_host_selected()</p>
<p><strong>Note</strong></p>
<p>this seems to be aimed exclusively at SCSI parallel busses.</p>
</div>
<dl class="function">
<dt id="c.scsi_remove_single_device">
int <code class="sig-name descname">scsi_remove_single_device</code><span class="sig-paren">(</span>uint<em> host</em>, uint<em> channel</em>, uint<em> id</em>, uint<em> lun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_single_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Respond to user request to remove a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">host</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">channel</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">lun</span></code></dt><dd><p>user-supplied decimal integer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called by writing “scsi remove-single-device” to
/proc/scsi/scsi.  Does a <a class="reference internal" href="#c.scsi_device_lookup" title="scsi_device_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_device_lookup()</span></code></a> and <a class="reference internal" href="#c.scsi_remove_device" title="scsi_remove_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_device()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.proc_scsi_write">
ssize_t <code class="sig-name descname">proc_scsi_write</code><span class="sig-paren">(</span>struct file<em> *file</em>, const char __user<em> *buf</em>, size_t<em> length</em>, loff_t<em> *ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_scsi_write" title="Permalink to this definition">¶</a></dt>
<dd><p>handle writes to /proc/scsi/scsi</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>not used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>length of buf, at most PAGE_SIZE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>not used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>this provides a legacy mechanism to add or remove devices by
Host, Channel, ID, and Lun.  To use,
“echo ‘scsi add-single-device 0 1 2 3’ &gt; /proc/scsi/scsi” or
“echo ‘scsi remove-single-device 0 1 2 3’ &gt; /proc/scsi/scsi” with
“0 1 2 3” replaced by the Host, Channel, Id, and Lun.</p>
<p><strong>Note</strong></p>
<p>this seems to be aimed at parallel SCSI. Most modern busses (USB,
SATA, Firewire, Fibre Channel, etc) dynamically assign these values to
provide a unique identifier and nothing more.</p>
</div>
<dl class="function">
<dt id="c.proc_scsi_open">
int <code class="sig-name descname">proc_scsi_open</code><span class="sig-paren">(</span>struct inode<em> *inode</em>, struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_scsi_open" title="Permalink to this definition">¶</a></dt>
<dd><p>glue function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*inode</span></code></dt><dd><p>not used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>passed to single_open()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Associates proc_scsi_show with this file</p>
</div>
<dl class="function">
<dt id="c.scsi_init_procfs">
int <code class="sig-name descname">scsi_init_procfs</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_init_procfs" title="Permalink to this definition">¶</a></dt>
<dd><p>create scsi and scsi/scsi in procfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_exit_procfs">
void <code class="sig-name descname">scsi_exit_procfs</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_exit_procfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove scsi/scsi and scsi from procfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
</section>
<section id="drivers-scsi-scsi-netlink-c">
<h4>drivers/scsi/scsi_netlink.c<a class="headerlink" href="#drivers-scsi-scsi-netlink-c" title="Permalink to this headline">¶</a></h4>
<p>Infrastructure to provide async events from transports to userspace via
netlink, using a single NETLINK_SCSITRANSPORT protocol for all
transports. See <a class="reference external" href="http://marc.info/?l=linux-scsi&amp;m=115507374832500&amp;w=2">the original patch
submission</a> for
more details.</p>
<dl class="function">
<dt id="c.scsi_nl_rcv_msg">
void <code class="sig-name descname">scsi_nl_rcv_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_nl_rcv_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive message handler.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>socket receive buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Extracts message from a receive buffer.</dt><dd><p>Validates message header and calls appropriate transport message handler</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_netlink_init">
void <code class="sig-name descname">scsi_netlink_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_netlink_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by SCSI subsystem to initialize the SCSI transport netlink interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_netlink_exit">
void <code class="sig-name descname">scsi_netlink_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_netlink_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by SCSI subsystem to disable the SCSI transport netlink interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
</section>
<section id="drivers-scsi-scsi-scan-c">
<h4>drivers/scsi/scsi_scan.c<a class="headerlink" href="#drivers-scsi-scsi-scan-c" title="Permalink to this headline">¶</a></h4>
<p>Scan a host to determine which (if any) devices are attached. The
general scanning/probing algorithm is as follows, exceptions are made to
it depending on device specific flags, compilation options, and global
variable (boot or module load time) settings. A specific LUN is scanned
via an INQUIRY command; if the LUN has a device attached, a scsi_device
is allocated and setup for it. For every id of every channel on the
given host, start by scanning LUN 0. Skip hosts that don’t respond at
all to a scan of LUN 0. Otherwise, if LUN 0 has a device attached,
allocate and setup a scsi_device for it. If target is SCSI-3 or up,
issue a REPORT LUN, and scan all of the LUNs returned by the REPORT LUN;
else, sequentially scan LUNs up until some maximum is reached, or a LUN
is seen that cannot have a device attached to it.</p>
<dl class="function">
<dt id="c.scsi_complete_async_scans">
int <code class="sig-name descname">scsi_complete_async_scans</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_complete_async_scans" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for asynchronous scans to complete</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When this function returns, any host which started scanning before
this function was called will have finished its scan.  Hosts which
started scanning after this function was called may or may not have
finished.</p>
</div>
<dl class="function">
<dt id="c.scsi_unlock_floptical">
void <code class="sig-name descname">scsi_unlock_floptical</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, unsigned char<em> *result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_unlock_floptical" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock device via a special MODE SENSE command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device to send command to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*result</span></code></dt><dd><p>area to store the result of the MODE SENSE</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Send a vendor specific MODE SENSE (not a MODE SELECT) command.
Called for BLIST_KEY devices.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.scsi_alloc_sdev">
struct scsi_device * <code class="sig-name descname">scsi_alloc_sdev</code><span class="sig-paren">(</span>struct scsi_target<em> *starget</em>, u64<em> lun</em>, void<em> *hostdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_alloc_sdev" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and setup a scsi_Device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>which target to allocate a <code class="xref c c-type docutils literal notranslate"><span class="pre">scsi_device</span></code> for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>which lun</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*hostdata</span></code></dt><dd><p>usually NULL and set by -&gt;slave_alloc instead</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate, initialize for io, and return a pointer to a scsi_Device.
Stores the <strong>shost</strong>, <strong>channel</strong>, <strong>id</strong>, and <strong>lun</strong> in the scsi_Device, and
adds scsi_Device to the appropriate list.</p>
</div></blockquote>
<dl class="simple">
<dt>Return value:</dt><dd><p>scsi_Device pointer, or NULL on failure.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_target_reap_ref_release">
void <code class="sig-name descname">scsi_target_reap_ref_release</code><span class="sig-paren">(</span>struct kref<em> *kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_target_reap_ref_release" title="Permalink to this definition">¶</a></dt>
<dd><p>remove target from visibility</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*kref</span></code></dt><dd><p>the reap_ref in the target being released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called on last put of reap_ref, which is the indication that no device
under this target is visible anymore, so render the target invisible in
sysfs.  Note: we have to be in user context here because the target reaps
should be done in places where the scsi device visibility is being removed.</p>
</div>
<dl class="function">
<dt id="c.scsi_alloc_target">
struct scsi_target * <code class="sig-name descname">scsi_alloc_target</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *parent</em>, int<em> channel</em>, uint<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_alloc_target" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a new or find an existing target</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>parent of the target (need not be a scsi host)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>target channel number (zero if no channels)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">id</span></code></dt><dd><p>target id number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return an existing target if one exists, provided it hasn’t already
gone into STARGET_DEL state, otherwise allocate a new target.</p>
<p>The target is returned with an incremented reference, so the caller
is responsible for both reaping and doing a last put</p>
</div>
<dl class="function">
<dt id="c.scsi_target_reap">
void <code class="sig-name descname">scsi_target_reap</code><span class="sig-paren">(</span>struct scsi_target<em> *starget</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_target_reap" title="Permalink to this definition">¶</a></dt>
<dd><p>check to see if target is in use and destroy if not</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>target to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used after removing a LUN or doing a last put of the target
it checks atomically that nothing is using the target and removes
it if so.</p>
</div>
<dl class="function">
<dt id="c.scsi_probe_lun">
int <code class="sig-name descname">scsi_probe_lun</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, unsigned char<em> *inq_result</em>, int<em> result_len</em>, blist_flags_t<em> *bflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_probe_lun" title="Permalink to this definition">¶</a></dt>
<dd><p>probe a single LUN using a SCSI INQUIRY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi_device to probe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*inq_result</span></code></dt><dd><p>area to store the INQUIRY result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">result_len</span></code></dt><dd><p>len of inq_result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">*bflags</span></code></dt><dd><p>store any bflags found here</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Probe the lun associated with <strong>req</strong> using a standard SCSI INQUIRY;</p>
<p>If the INQUIRY is successful, zero is returned and the
INQUIRY data is in <strong>inq_result</strong>; the scsi_level and INQUIRY length
are copied to the scsi_device any flags value is stored in <strong>*bflags</strong>.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.scsi_add_lun">
int <code class="sig-name descname">scsi_add_lun</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em>, unsigned char<em> *inq_result</em>, blist_flags_t<em> *bflags</em>, int<em> async</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_add_lun" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and fully initialze a scsi_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>holds information to be stored in the new scsi_device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*inq_result</span></code></dt><dd><p>holds the result of a previous INQUIRY to the LUN</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">*bflags</span></code></dt><dd><p>black/white list flag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">async</span></code></dt><dd><p>1 if this device is being scanned asynchronously</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Initialize the scsi_device <strong>sdev</strong>.  Optionally set fields based
on values in <strong>*bflags</strong>.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>SCSI_SCAN_NO_RESPONSE: could not allocate or setup a scsi_device
SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.scsi_inq_str">
unsigned char * <code class="sig-name descname">scsi_inq_str</code><span class="sig-paren">(</span>unsigned char<em> *buf</em>, unsigned char<em> *inq</em>, unsigned<em> first</em>, unsigned<em> end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_inq_str" title="Permalink to this definition">¶</a></dt>
<dd><p>print INQUIRY data from min to max index, strip trailing whitespace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Output buffer with at least end-first+1 bytes of space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*inq</span></code></dt><dd><p>Inquiry buffer (input)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">first</span></code></dt><dd><p>Offset of string into inq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">end</span></code></dt><dd><p>Index after last character in inq</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_probe_and_add_lun">
int <code class="sig-name descname">scsi_probe_and_add_lun</code><span class="sig-paren">(</span>struct scsi_target<em> *starget</em>, u64<em> lun</em>, blist_flags_t<em> *bflagsp</em>, struct scsi_device<em> **sdevp</em>, enum scsi_scan_mode<em> rescan</em>, void<em> *hostdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_probe_and_add_lun" title="Permalink to this definition">¶</a></dt>
<dd><p>probe a LUN, if a LUN is found add it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>pointer to target device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>LUN of target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">*bflagsp</span></code></dt><dd><p>store bflags here if not NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">**sdevp</span></code></dt><dd><p>probe the LUN corresponding to this scsi_device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_scan_mode</span> <span class="pre">rescan</span></code></dt><dd><p>if not equal to SCSI_SCAN_INITIAL skip some code only
needed on first scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*hostdata</span></code></dt><dd><p>passed to <a class="reference internal" href="#c.scsi_alloc_sdev" title="scsi_alloc_sdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_alloc_sdev()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Call scsi_probe_lun, if a LUN with an attached device is found,
allocate and set it up by calling scsi_add_lun.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>SCSI_SCAN_NO_RESPONSE: could not allocate or setup a scsi_device</p></li>
<li><dl class="simple">
<dt>SCSI_SCAN_TARGET_PRESENT: target responded, but no device is</dt><dd><p>attached at the LUN</p>
</dd>
</dl>
</li>
<li><p>SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.scsi_sequential_lun_scan">
void <code class="sig-name descname">scsi_sequential_lun_scan</code><span class="sig-paren">(</span>struct scsi_target<em> *starget</em>, blist_flags_t<em> bflags</em>, int<em> scsi_level</em>, enum scsi_scan_mode<em> rescan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_sequential_lun_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>sequentially scan a SCSI target</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>pointer to target structure to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">bflags</span></code></dt><dd><p>black/white list flag for LUN 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">scsi_level</span></code></dt><dd><p>Which version of the standard does this device adhere to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_scan_mode</span> <span class="pre">rescan</span></code></dt><dd><p>passed to scsi_probe_add_lun()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Generally, scan from LUN 1 (LUN 0 is assumed to already have been
scanned) to some maximum lun until a LUN is found with no device
attached. Use the bflags to figure out any oddities.</p>
<p>Modifies sdevscan-&gt;lun.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.scsi_report_lun_scan">
int <code class="sig-name descname">scsi_report_lun_scan</code><span class="sig-paren">(</span>struct scsi_target<em> *starget</em>, blist_flags_t<em> bflags</em>, enum scsi_scan_mode<em> rescan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_report_lun_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan using SCSI REPORT LUN results</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>which target</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blist_flags_t</span> <span class="pre">bflags</span></code></dt><dd><p>Zero or a mix of BLIST_NOLUN, BLIST_REPORTLUN2, or BLIST_NOREPORTLUN</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_scan_mode</span> <span class="pre">rescan</span></code></dt><dd><p>nonzero if we can skip code only needed on first scan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Fast scanning for modern (SCSI-3) devices by sending a REPORT LUN command.
Scan the resulting list of LUNs by calling scsi_probe_and_add_lun.</p>
<p>If BLINK_REPORTLUN2 is set, scan a target that supports more than 8
LUNs even if it’s older than SCSI-3.
If BLIST_NOREPORTLUN is set, return 1 always.
If BLIST_NOLUN is set, return 0 always.
If starget-&gt;no_report_luns is set, return 1 always.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0: scan completed (or no memory, so further scanning is futile)
1: could not scan with REPORT LUN</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.scsi_prep_async_scan">
struct async_scan_data * <code class="sig-name descname">scsi_prep_async_scan</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_prep_async_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare for an async scan</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>the host which will be scanned</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a cookie to be passed to <a class="reference internal" href="#c.scsi_finish_async_scan" title="scsi_finish_async_scan"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_finish_async_scan()</span></code></a></p>
<p><strong>Description</strong></p>
<p>Tells the midlayer this host is going to do an asynchronous scan.
It reserves the host’s position in the scanning list and ensures
that other asynchronous scans started after this one won’t affect the
ordering of the discovered devices.</p>
</div>
<dl class="function">
<dt id="c.scsi_finish_async_scan">
void <code class="sig-name descname">scsi_finish_async_scan</code><span class="sig-paren">(</span>struct async_scan_data<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_finish_async_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronous scan has finished</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">async_scan_data</span> <span class="pre">*data</span></code></dt><dd><p>cookie returned from earlier call to <a class="reference internal" href="#c.scsi_prep_async_scan" title="scsi_prep_async_scan"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_prep_async_scan()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All the devices currently attached to this host have been found.
This function announces all the devices it has found to the rest
of the system.</p>
</div>
</section>
<section id="drivers-scsi-scsi-sysctl-c">
<h4>drivers/scsi/scsi_sysctl.c<a class="headerlink" href="#drivers-scsi-scsi-sysctl-c" title="Permalink to this headline">¶</a></h4>
<p>Set up the sysctl entry: “/dev/scsi/logging_level”
(DEV_SCSI_LOGGING_LEVEL) which sets/returns scsi_logging_level.</p>
</section>
<section id="drivers-scsi-scsi-sysfs-c">
<h4>drivers/scsi/scsi_sysfs.c<a class="headerlink" href="#drivers-scsi-scsi-sysfs-c" title="Permalink to this headline">¶</a></h4>
<p>SCSI sysfs interface routines.</p>
<dl class="function">
<dt id="c.scsi_remove_device">
void <code class="sig-name descname">scsi_remove_device</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a device from the scsi bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi_device to unregister</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_remove_target">
void <code class="sig-name descname">scsi_remove_target</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_target" title="Permalink to this definition">¶</a></dt>
<dd><p>try to remove a target and all its devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>generic starget or parent of generic stargets to be removed</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This is slightly racy.  It is possible that if the user
requests the addition of another device then the target won’t be
removed.</p>
</div>
</section>
<section id="drivers-scsi-hosts-c">
<h4>drivers/scsi/hosts.c<a class="headerlink" href="#drivers-scsi-hosts-c" title="Permalink to this headline">¶</a></h4>
<p>mid to lowlevel SCSI driver interface</p>
<dl class="function">
<dt id="c.scsi_remove_host">
void <code class="sig-name descname">scsi_remove_host</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_remove_host" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a scsi host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>a pointer to a scsi host to remove</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_add_host_with_dma">
int <code class="sig-name descname">scsi_add_host_with_dma</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dma_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_add_host_with_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>add a scsi host with dma device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host pointer to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>a <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> of type scsi class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dma_dev</span></code></dt><dd><p>dma device for the host</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>You rarely need to worry about this unless you’re in a
virtualised host environments, so use the simpler scsi_add_host()
function instead.</p>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 on success / != 0 for error</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_host_alloc">
struct Scsi_Host * <code class="sig-name descname">scsi_host_alloc</code><span class="sig-paren">(</span>struct scsi_host_template<em> *sht</em>, int<em> privsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>register a scsi host adapter instance.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*sht</span></code></dt><dd><p>pointer to scsi host template</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">privsize</span></code></dt><dd><p>extra bytes to allocate for driver</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<blockquote>
<div><p>Allocate a new Scsi_Host and perform basic initialization.
The host is not published to the scsi midlayer until scsi_add_host
is called.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>Pointer to a new Scsi_Host</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_host_lookup">
struct Scsi_Host * <code class="sig-name descname">scsi_host_lookup</code><span class="sig-paren">(</span>unsigned short<em> hostnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a Scsi_Host by host no</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">hostnum</span></code></dt><dd><p>host number to locate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl>
<dt>Return value:</dt><dd><p>A pointer to located Scsi_Host or NULL.</p>
<p>The caller must do a <a class="reference internal" href="#c.scsi_host_put" title="scsi_host_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_host_put()</span></code></a> to drop the reference
that <a class="reference internal" href="#c.scsi_host_get" title="scsi_host_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_host_get()</span></code></a> took. The <a class="reference internal" href="infrastructure.html#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> below dropped
the reference from <a class="reference internal" href="infrastructure.html#c.class_find_device" title="class_find_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">class_find_device()</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_host_get">
struct Scsi_Host * <code class="sig-name descname">scsi_host_get</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_get" title="Permalink to this definition">¶</a></dt>
<dd><p>inc a Scsi_Host ref count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host to inc.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_host_busy">
int <code class="sig-name descname">scsi_host_busy</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the host busy counter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host to inc.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_host_put">
void <code class="sig-name descname">scsi_host_put</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_put" title="Permalink to this definition">¶</a></dt>
<dd><p>dec a Scsi_Host ref count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host to dec.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_queue_work">
int <code class="sig-name descname">scsi_queue_work</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, struct work_struct<em> *work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_queue_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue work to the Scsi_Host workqueue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>Work to queue for execution.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>1 - work queued for execution
0 - work is already queued
-EINVAL - work queue doesn’t exist</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_flush_work">
void <code class="sig-name descname">scsi_flush_work</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_flush_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush a Scsi_Host’s workqueue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_host_complete_all_commands">
void <code class="sig-name descname">scsi_host_complete_all_commands</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, enum scsi_host_status<em> status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_complete_all_commands" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminate all running commands</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Scsi Host on which commands should be terminated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">scsi_host_status</span> <span class="pre">status</span></code></dt><dd><p>Status to be set for the terminated commands</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>There is no protection against modification of the number
of outstanding commands. It is the responsibility of the
caller to ensure that concurrent I/O submission and/or
completion is stopped when calling this function.</p>
</div>
<dl class="function">
<dt id="c.scsi_host_busy_iter">
void <code class="sig-name descname">scsi_host_busy_iter</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, bool (<em>*fn</em>)(struct scsi_cmnd *, void *), void<em> *priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_host_busy_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all busy commands</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Pointer to Scsi_Host.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">(*fn)(struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Function to call on each busy command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>Data pointer passed to <strong>fn</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If locking against concurrent command completions is required
ithas to be provided by the caller</p>
</div>
</section>
<section id="drivers-scsi-scsi-common-c">
<h4>drivers/scsi/scsi_common.c<a class="headerlink" href="#drivers-scsi-scsi-common-c" title="Permalink to this headline">¶</a></h4>
<p>general support functions</p>
<dl class="function">
<dt id="c.scsi_device_type">
const char * <code class="sig-name descname">scsi_device_type</code><span class="sig-paren">(</span>unsigned<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_device_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 17-char string indicating device type.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt><dd><p>type number to look up</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsilun_to_int">
u64 <code class="sig-name descname">scsilun_to_int</code><span class="sig-paren">(</span>struct scsi_lun<em> *scsilun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsilun_to_int" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a scsi_lun to an int</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_lun</span> <span class="pre">*scsilun</span></code></dt><dd><p>struct scsi_lun to be converted.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Convert <strong>scsilun</strong> from a struct scsi_lun to a four-byte host byte-ordered
integer, and return the result. The caller must check for
truncation before using this function.</p>
</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>For a description of the LUN format, post SCSI-3 see the SCSI
Architecture Model, for SCSI-3 see the SCSI Controller Commands.</p>
<p>Given a struct scsi_lun of: d2 04 0b 03 00 00 00 00, this function
returns the integer: 0x0b03d204</p>
<p>This encoding will return a standard integer LUN for LUNs smaller
than 256, which typically use a single level LUN structure with
addressing method 0.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.int_to_scsilun">
void <code class="sig-name descname">int_to_scsilun</code><span class="sig-paren">(</span>u64<em> lun</em>, struct scsi_lun<em> *scsilun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.int_to_scsilun" title="Permalink to this definition">¶</a></dt>
<dd><p>reverts an int into a scsi_lun</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">lun</span></code></dt><dd><p>integer to be reverted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_lun</span> <span class="pre">*scsilun</span></code></dt><dd><p>struct scsi_lun to be set.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Reverts the functionality of the scsilun_to_int, which packed
an 8-byte lun value into an int. This routine unpacks the int
back into the lun value.</p>
</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>Given an integer : 0x0b03d204, this function returns a
struct scsi_lun of: d2 04 0b 03 00 00 00 00</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.scsi_normalize_sense">
bool <code class="sig-name descname">scsi_normalize_sense</code><span class="sig-paren">(</span>const u8<em> *sense_buffer</em>, int<em> sb_len</em>, struct scsi_sense_hdr<em> *sshdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_normalize_sense" title="Permalink to this definition">¶</a></dt>
<dd><p>normalize main elements from either fixed or descriptor sense data format into a common format.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*sense_buffer</span></code></dt><dd><p>byte array containing sense data returned by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sb_len</span></code></dt><dd><p>number of valid bytes in sense_buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_sense_hdr</span> <span class="pre">*sshdr</span></code></dt><dd><p>pointer to instance of structure that common
elements are written to.</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>The “main elements” from sense data are: response_code, sense_key,
asc, ascq and additional_length (only for descriptor format).</p>
<p>Typically this function can be called after a device has
responded to a SCSI command with the CHECK_CONDITION status.</p>
</div></blockquote>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>true if valid sense data information found, else false;</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_sense_desc_find">
const u8 * <code class="sig-name descname">scsi_sense_desc_find</code><span class="sig-paren">(</span>const u8 *<em> sense_buffer</em>, int<em> sb_len</em>, int<em> desc_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_sense_desc_find" title="Permalink to this definition">¶</a></dt>
<dd><p>search for a given descriptor type in descriptor sense data format.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">sense_buffer</span></code></dt><dd><p>byte array of descriptor format sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sb_len</span></code></dt><dd><p>number of valid bytes in sense_buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">desc_type</span></code></dt><dd><p>value of descriptor type to find
(e.g. 0 -&gt; information)</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>only valid when sense data is in descriptor format</p>
</div></blockquote>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>pointer to start of (first) descriptor if found else NULL</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_build_sense_buffer">
void <code class="sig-name descname">scsi_build_sense_buffer</code><span class="sig-paren">(</span>int<em> desc</em>, u8<em> *buf</em>, u8<em> key</em>, u8<em> asc</em>, u8<em> ascq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_build_sense_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>build sense data in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">desc</span></code></dt><dd><p>Sense format (non-zero == descriptor format,
0 == fixed format)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>Where to build sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">key</span></code></dt><dd><p>Sense key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">asc</span></code></dt><dd><p>Additional sense code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">ascq</span></code></dt><dd><p>Additional sense code qualifier</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_set_sense_information">
int <code class="sig-name descname">scsi_set_sense_information</code><span class="sig-paren">(</span>u8<em> *buf</em>, int<em> buf_len</em>, u64<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_set_sense_information" title="Permalink to this definition">¶</a></dt>
<dd><p>set the information field in a formatted sense data buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>Where to build sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buf_len</span></code></dt><dd><p>buffer length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">info</span></code></dt><dd><p>64-bit information value to be set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 on success or -EINVAL for invalid sense buffer length</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.scsi_set_sense_field_pointer">
int <code class="sig-name descname">scsi_set_sense_field_pointer</code><span class="sig-paren">(</span>u8<em> *buf</em>, int<em> buf_len</em>, u16<em> fp</em>, u8<em> bp</em>, bool<em> cd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_set_sense_field_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>set the field pointer sense key specific information in a formatted sense data buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>Where to build sense data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">buf_len</span></code></dt><dd><p>buffer length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">fp</span></code></dt><dd><p>field pointer to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">bp</span></code></dt><dd><p>bit pointer to be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">cd</span></code></dt><dd><p>command/data bit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return value:</dt><dd><p>0 on success or -EINVAL for invalid sense buffer length</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="transport-classes">
<h3>Transport classes<a class="headerlink" href="#transport-classes" title="Permalink to this headline">¶</a></h3>
<p>Transport classes are service libraries for drivers in the SCSI lower
layer, which expose transport attributes in sysfs.</p>
<section id="fibre-channel-transport">
<h4>Fibre Channel transport<a class="headerlink" href="#fibre-channel-transport" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_fc.c defines transport attributes
for Fibre Channel.</p>
<dl class="function">
<dt id="c.fc_get_event_number">
u32 <code class="sig-name descname">fc_get_event_number</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.fc_get_event_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the next sequential FC event number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>We could have inlined this, but it would have required fc_event_seq to
be exposed. For now, live with the subroutine call.
Atomic used to avoid lock/unlock…</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_host_post_fc_event">
void <code class="sig-name descname">fc_host_post_fc_event</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, u32<em> event_number</em>, enum fc_host_event_code<em> event_code</em>, u32<em> data_len</em>, char<em> *data_buf</em>, u64<em> vendor_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_post_fc_event" title="Permalink to this definition">¶</a></dt>
<dd><p>routine to do the work of posting an event on an fc_host.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host the event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_number</span></code></dt><dd><p>fc event number obtained from get_fc_event_number()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fc_host_event_code</span> <span class="pre">event_code</span></code></dt><dd><p>fc_host event being posted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">data_len</span></code></dt><dd><p>amount, in bytes, of event data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*data_buf</span></code></dt><dd><p>pointer to event data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">vendor_id</span></code></dt><dd><p>value for Vendor id</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_host_post_event">
void <code class="sig-name descname">fc_host_post_event</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, u32<em> event_number</em>, enum fc_host_event_code<em> event_code</em>, u32<em> event_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_post_event" title="Permalink to this definition">¶</a></dt>
<dd><p>called to post an even on an fc_host.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host the event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_number</span></code></dt><dd><p>fc event number obtained from get_fc_event_number()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fc_host_event_code</span> <span class="pre">event_code</span></code></dt><dd><p>fc_host event being posted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_data</span></code></dt><dd><p>32bits of data for the event being posted</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_host_post_vendor_event">
void <code class="sig-name descname">fc_host_post_vendor_event</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, u32<em> event_number</em>, u32<em> data_len</em>, char *<em> data_buf</em>, u64<em> vendor_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_post_vendor_event" title="Permalink to this definition">¶</a></dt>
<dd><p>called to post a vendor unique event on an fc_host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host the event occurred on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">event_number</span></code></dt><dd><p>fc event number obtained from get_fc_event_number()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">data_len</span></code></dt><dd><p>amount, in bytes, of vendor unique data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">data_buf</span></code></dt><dd><p>pointer to vendor unique data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">vendor_id</span></code></dt><dd><p>Vendor id</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_find_rport_by_wwpn">
struct fc_rport * <code class="sig-name descname">fc_find_rport_by_wwpn</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, u64<em> wwpn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_find_rport_by_wwpn" title="Permalink to this definition">¶</a></dt>
<dd><p>find the fc_rport pointer for a given wwpn</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host the fc_rport is associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">wwpn</span></code></dt><dd><p>wwpn of the fc_rport device</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_host_fpin_rcv">
void <code class="sig-name descname">fc_host_fpin_rcv</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, u32<em> fpin_len</em>, char<em> *fpin_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_host_fpin_rcv" title="Permalink to this definition">¶</a></dt>
<dd><p>routine to process a received FPIN.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>host the FPIN was received on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">fpin_len</span></code></dt><dd><p>length of FPIN payload, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*fpin_buf</span></code></dt><dd><p>pointer to FPIN payload</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_eh_timed_out">
enum scsi_timeout_action <code class="sig-name descname">fc_eh_timed_out</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *scmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_eh_timed_out" title="Permalink to this definition">¶</a></dt>
<dd><p>FC Transport I/O timeout intercept handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>The SCSI command which timed out</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine protects against error handlers getting invoked while a
rport is in a blocked state, typically due to a temporarily loss of
connectivity. If the error handlers are allowed to proceed, requests
to abort i/o, reset the target, etc will likely fail as there is no way
to communicate with the device to perform the requested function. These
failures may result in the midlayer taking the device offline, requiring
manual intervention to restore operation.</p>
<p>This routine, called whenever an i/o times out, validates the state of
the underlying rport. If the rport is blocked, it returns
EH_RESET_TIMER, which will continue to reschedule the timeout.
Eventually, either the device will return, or devloss_tmo will fire,
and when the timeout then fires, it will be handled normally.
If the rport is not blocked, normal error handling continues.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_remove_host">
void <code class="sig-name descname">fc_remove_host</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remove_host" title="Permalink to this definition">¶</a></dt>
<dd><p>called to terminate any fc_transport-related elements for a scsi host.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Which <code class="xref c c-type docutils literal notranslate"><span class="pre">Scsi_Host</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is expected to be called immediately preceding the
a driver’s call to <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a>.</p>
<dl class="simple">
<dt>WARNING: A driver utilizing the fc_transport, which fails to call</dt><dd><p>this routine prior to <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a>, will leave dangling
objects in /sys/class/fc_remote_ports. Access to any of these
objects can result in a system crash !!!</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_remote_port_add">
struct fc_rport * <code class="sig-name descname">fc_remote_port_add</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, int<em> channel</em>, struct fc_rport_identifiers<em> *ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remote_port_add" title="Permalink to this definition">¶</a></dt>
<dd><p>notify fc transport of the existence of a remote FC port.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host the remote port is connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>Channel on shost port connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport_identifiers</span> <span class="pre">*ids</span></code></dt><dd><p>The world wide names, fc address, and FC4 port
roles for the remote port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The LLDD calls this routine to notify the transport of the existence
of a remote port. The LLDD provides the unique identifiers (wwpn,wwn)
of the port, it’s FC address (port_id), and the FC4 roles that are
active for the port.</p>
<p>For ports that are FCP targets (aka scsi targets), the FC transport
maintains consistent target id bindings on behalf of the LLDD.
A consistent target id binding is an assignment of a target id to
a remote port identifier, which persists while the scsi host is
attached. The remote port can disappear, then later reappear, and
it’s target id assignment remains the same. This allows for shifts
in FC addressing (if binding by wwpn or wwnn) with no apparent
changes to the scsi subsystem which is based on scsi host number and
target id values.  Bindings are only valid during the attachment of
the scsi host. If the host detaches, then later re-attaches, target
id bindings may change.</p>
<p>This routine is responsible for returning a remote port structure.
The routine will search the list of remote ports it maintains
internally on behalf of consistent target id mappings. If found, the
remote port structure will be reused. Otherwise, a new remote port
structure will be allocated.</p>
<p>Whenever a remote port is allocated, a new fc_remote_port class
device is created.</p>
<p>Should not be called from interrupt context.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_remote_port_delete">
void <code class="sig-name descname">fc_remote_port_delete</code><span class="sig-paren">(</span>struct fc_rport<em> *rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remote_port_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the fc transport that a remote port is no longer in existence.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport</span> <span class="pre">*rport</span></code></dt><dd><p>The remote port that no longer exists</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The LLDD calls this routine to notify the transport that a remote
port is no longer part of the topology. Note: Although a port
may no longer be part of the topology, it may persist in the remote
ports displayed by the fc_host. We do this under 2 conditions:</p>
<ol class="arabic simple">
<li><p>If the port was a scsi target, we delay its deletion by “blocking” it.
This allows the port to temporarily disappear, then reappear without
disrupting the SCSI device tree attached to it. During the “blocked”
period the port will still exist.</p></li>
<li><p>If the port was a scsi target and disappears for longer than we
expect, we’ll delete the port and the tear down the SCSI device tree
attached to it. However, we want to semi-persist the target id assigned
to that port if it eventually does exist. The port structure will
remain (although with minimal information) so that the target id
bindings also remain.</p></li>
</ol>
<p>If the remote port is not an FCP Target, it will be fully torn down
and deallocated, including the fc_remote_port class device.</p>
<p>If the remote port is an FCP Target, the port will be placed in a
temporary blocked state. From the LLDD’s perspective, the rport no
longer exists. From the SCSI midlayer’s perspective, the SCSI target
exists, but all sdevs on it are blocked from further I/O. The following
is then expected.</p>
<blockquote>
<div><p>If the remote port does not return (signaled by a LLDD call to
<a class="reference internal" href="#c.fc_remote_port_add" title="fc_remote_port_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">fc_remote_port_add()</span></code></a>) within the dev_loss_tmo timeout, then the
scsi target is removed - killing all outstanding i/o and removing the
scsi devices attached to it. The port structure will be marked Not
Present and be partially cleared, leaving only enough information to
recognize the remote port relative to the scsi target id binding if
it later appears.  The port will remain as long as there is a valid
binding (e.g. until the user changes the binding type or unloads the
scsi host with the binding).</p>
<p>If the remote port returns within the dev_loss_tmo value (and matches
according to the target id binding type), the port structure will be
reused. If it is no longer a SCSI target, the target will be torn
down. If it continues to be a SCSI target, then the target will be
unblocked (allowing i/o to be resumed), and a scan will be activated
to ensure that all luns are detected.</p>
</div></blockquote>
<p>Called from normal process context only - cannot be called from interrupt.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_remote_port_rolechg">
void <code class="sig-name descname">fc_remote_port_rolechg</code><span class="sig-paren">(</span>struct fc_rport<em> *rport</em>, u32<em> roles</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_remote_port_rolechg" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the fc transport that the roles on a remote may have changed.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport</span> <span class="pre">*rport</span></code></dt><dd><p>The remote port that changed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">roles</span></code></dt><dd><p>New roles for this port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The LLDD calls this routine to notify the transport that the
roles on a remote port may have changed. The largest effect of this is
if a port now becomes a FCP Target, it must be allocated a
scsi target id.  If the port is no longer a FCP target, any
scsi target id value assigned to it will persist in case the
role changes back to include FCP Target. No changes in the scsi
midlayer will be invoked if the role changes (in the expectation
that the role will be resumed. If it doesn’t normal error processing
will take place).</p>
<p>Should not be called from interrupt context.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_block_rport">
int <code class="sig-name descname">fc_block_rport</code><span class="sig-paren">(</span>struct fc_rport<em> *rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_block_rport" title="Permalink to this definition">¶</a></dt>
<dd><p>Block SCSI eh thread for blocked fc_rport.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_rport</span> <span class="pre">*rport</span></code></dt><dd><p>Remote port that scsi_eh is trying to recover.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine can be called from a FC LLD scsi_eh callback. It
blocks the scsi_eh thread until the fc_rport leaves the
FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is
necessary to avoid the scsi_eh failing recovery actions for blocked
rports which would lead to offlined SCSI devices.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.</dt><dd><p>FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be
passed back to scsi_eh.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.fc_block_scsi_eh">
int <code class="sig-name descname">fc_block_scsi_eh</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *cmnd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_block_scsi_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>Block SCSI eh thread for blocked fc_rport</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmnd</span></code></dt><dd><p>SCSI command that scsi_eh is trying to recover</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine can be called from a FC LLD scsi_eh callback. It
blocks the scsi_eh thread until the fc_rport leaves the
FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is
necessary to avoid the scsi_eh failing recovery actions for blocked
rports which would lead to offlined SCSI devices.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.</dt><dd><p>FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be
passed back to scsi_eh.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.fc_vport_create">
struct fc_vport * <code class="sig-name descname">fc_vport_create</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, int<em> channel</em>, struct fc_vport_identifiers<em> *ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_vport_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Admin App or LLDD requests creation of a vport</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host the virtual port is connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">channel</span></code></dt><dd><p>channel on shost port connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_vport_identifiers</span> <span class="pre">*ids</span></code></dt><dd><p>The world wide names, FC4 port roles, etc for
the virtual port.</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.fc_vport_terminate">
int <code class="sig-name descname">fc_vport_terminate</code><span class="sig-paren">(</span>struct fc_vport<em> *vport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fc_vport_terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Admin App or LLDD requests termination of a vport</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fc_vport</span> <span class="pre">*vport</span></code></dt><dd><p>fc_vport to be terminated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the LLDD vport_delete() function, then deallocates and removes
the vport from the shost and object tree.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This routine assumes no locks are held on entry.</p>
</div></blockquote>
</div>
</section>
<section id="iscsi-transport-class">
<h4>iSCSI transport class<a class="headerlink" href="#iscsi-transport-class" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_iscsi.c defines transport
attributes for the iSCSI class, which sends SCSI packets over TCP/IP
connections.</p>
<dl class="function">
<dt id="c.iscsi_lookup_endpoint">
struct iscsi_endpoint * <code class="sig-name descname">iscsi_lookup_endpoint</code><span class="sig-paren">(</span>u64<em> handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_lookup_endpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>get ep from handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">handle</span></code></dt><dd><p>endpoint handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must do a iscsi_put_endpoint.</p>
</div>
<dl class="function">
<dt id="c.iscsi_create_flashnode_sess">
struct iscsi_bus_flash_session * <code class="sig-name descname">iscsi_create_flashnode_sess</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, int<em> index</em>, struct iscsi_transport<em> *transport</em>, int<em> dd_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_flashnode_sess" title="Permalink to this definition">¶</a></dt>
<dd><p>Add flashnode session entry in sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of flashnode to add in sysfs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*transport</span></code></dt><dd><p>pointer to transport data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>total size to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a sysfs entry for the flashnode session attributes</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to allocated flashnode sess on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.iscsi_create_flashnode_conn">
struct iscsi_bus_flash_conn * <code class="sig-name descname">iscsi_create_flashnode_conn</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, struct iscsi_bus_flash_session<em> *fnode_sess</em>, struct iscsi_transport<em> *transport</em>, int<em> dd_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_flashnode_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>Add flashnode conn entry in sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*fnode_sess</span></code></dt><dd><p>pointer to the parent flashnode session entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*transport</span></code></dt><dd><p>pointer to transport data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>total size to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a sysfs entry for the flashnode connection attributes</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to allocated flashnode conn on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.iscsi_find_flashnode_sess">
struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> * <code class="sig-name descname">iscsi_find_flashnode_sess</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, void<em> *data</em>, int (<em>*fn</em>)(struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *dev, void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_find_flashnode_sess" title="Permalink to this definition">¶</a></dt>
<dd><p>finds flashnode session entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>pointer to data containing value to use for comparison</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>function pointer that does actual comparison</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the flashnode session object comparing the data passed using logic
defined in passed function pointer</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to found flashnode session device object on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.iscsi_find_flashnode_conn">
struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> * <code class="sig-name descname">iscsi_find_flashnode_conn</code><span class="sig-paren">(</span>struct iscsi_bus_flash_session<em> *fnode_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_find_flashnode_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>finds flashnode connection entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*fnode_sess</span></code></dt><dd><p>pointer to parent flashnode session entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the flashnode connection object comparing the data passed using logic
defined in passed function pointer</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>pointer to found flashnode connection device object on success
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.iscsi_destroy_flashnode_sess">
void <code class="sig-name descname">iscsi_destroy_flashnode_sess</code><span class="sig-paren">(</span>struct iscsi_bus_flash_session<em> *fnode_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_destroy_flashnode_sess" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy flashnode session entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*fnode_sess</span></code></dt><dd><p>pointer to flashnode session entry to be destroyed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deletes the flashnode session entry and all children flashnode connection
entries from sysfs</p>
</div>
<dl class="function">
<dt id="c.iscsi_destroy_all_flashnode">
void <code class="sig-name descname">iscsi_destroy_all_flashnode</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_destroy_all_flashnode" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy all flashnode session entries</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>pointer to host data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroys all the flashnode session entries and all corresponding children
flashnode connection entries from sysfs</p>
</div>
<dl class="function">
<dt id="c.iscsi_block_scsi_eh">
int <code class="sig-name descname">iscsi_block_scsi_eh</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_block_scsi_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>block scsi eh until session state has transistioned</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmd</span></code></dt><dd><p>scsi cmd passed to scsi eh handler</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the session is down this function will wait for the recovery
timer to fire or for the session to be logged back in. If the
recovery timer fires then FAST_IO_FAIL is returned. The caller
should pass this error value to the scsi eh.</p>
</div>
<dl class="function">
<dt id="c.iscsi_unblock_session">
void <code class="sig-name descname">iscsi_unblock_session</code><span class="sig-paren">(</span>struct iscsi_cls_session<em> *session</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_unblock_session" title="Permalink to this definition">¶</a></dt>
<dd><p>set a session as logged in and start IO.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*session</span></code></dt><dd><p>iscsi session</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark a session as ready to accept IO.</p>
</div>
<dl class="function">
<dt id="c.iscsi_create_session">
struct iscsi_cls_session * <code class="sig-name descname">iscsi_create_session</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, struct iscsi_transport<em> *transport</em>, int<em> dd_size</em>, unsigned int<em> target_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_session" title="Permalink to this definition">¶</a></dt>
<dd><p>create iscsi class session</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*transport</span></code></dt><dd><p>iscsi transport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>private driver data size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">target_id</span></code></dt><dd><p>which target</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be called from a LLD or iscsi_transport.</p>
</div>
<dl class="function">
<dt id="c.iscsi_force_destroy_session">
void <code class="sig-name descname">iscsi_force_destroy_session</code><span class="sig-paren">(</span>struct iscsi_cls_session<em> *session</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_force_destroy_session" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a session from the kernel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*session</span></code></dt><dd><p>session to destroy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Force the destruction of a session from the kernel. This should only be
used when userspace is no longer running during system shutdown.</p>
</div>
<dl class="function">
<dt id="c.iscsi_alloc_conn">
struct iscsi_cls_conn * <code class="sig-name descname">iscsi_alloc_conn</code><span class="sig-paren">(</span>struct iscsi_cls_session<em> *session</em>, int<em> dd_size</em>, uint32_t<em> cid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_alloc_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>alloc iscsi class connection</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*session</span></code></dt><dd><p>iscsi cls session</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt><dd><p>private driver data size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">cid</span></code></dt><dd><p>connection id</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.iscsi_add_conn">
int <code class="sig-name descname">iscsi_add_conn</code><span class="sig-paren">(</span>struct iscsi_cls_conn<em> *conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_add_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>add iscsi class connection</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi cls connection</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will expose iscsi_cls_conn to sysfs so make sure the related
resources for sysfs attributes are initialized before calling this.</p>
</div>
<dl class="function">
<dt id="c.iscsi_remove_conn">
void <code class="sig-name descname">iscsi_remove_conn</code><span class="sig-paren">(</span>struct iscsi_cls_conn<em> *conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_remove_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>remove iscsi class connection from sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*conn</span></code></dt><dd><p>iscsi cls connection</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove iscsi_cls_conn from sysfs, and wait for previous
read/write of iscsi_cls_conn’s attributes in sysfs to finish.</p>
</div>
<dl class="function">
<dt id="c.iscsi_session_event">
int <code class="sig-name descname">iscsi_session_event</code><span class="sig-paren">(</span>struct iscsi_cls_session<em> *session</em>, enum iscsi_uevent_e<em> event</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_session_event" title="Permalink to this definition">¶</a></dt>
<dd><p>send session destr. completion event</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*session</span></code></dt><dd><p>iscsi class session</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">iscsi_uevent_e</span> <span class="pre">event</span></code></dt><dd><p>type of event</p>
</dd>
</dl>
</div>
</section>
<section id="serial-attached-scsi-sas-transport-class">
<h4>Serial Attached SCSI (SAS) transport class<a class="headerlink" href="#serial-attached-scsi-sas-transport-class" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_sas.c defines transport
attributes for Serial Attached SCSI, a variant of SATA aimed at large
high-end systems.</p>
<p>The SAS transport class contains common code to deal with SAS HBAs, an
aproximated representation of SAS topologies in the driver model, and
various sysfs attributes to expose these topologies and management
interfaces to userspace.</p>
<p>In addition to the basic SCSI core objects this transport class
introduces two additional intermediate objects: The SAS PHY as
represented by struct sas_phy defines an “outgoing” PHY on a SAS HBA or
Expander, and the SAS remote PHY represented by struct sas_rphy defines
an “incoming” PHY on a SAS Expander or end device. Note that this is
purely a software concept, the underlying hardware for a PHY and a
remote PHY is the exactly the same.</p>
<p>There is no concept of a SAS port in this code, users can see what PHYs
form a wide port based on the port_identifier attribute, which is the
same for all PHYs in a port.</p>
<dl class="function">
<dt id="c.sas_remove_children">
void <code class="sig-name descname">sas_remove_children</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_remove_children" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down a devices SAS data structures</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device belonging to the sas object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes all SAS PHYs and remote PHYs for a given object</p>
</div>
<dl class="function">
<dt id="c.sas_remove_host">
void <code class="sig-name descname">sas_remove_host</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_remove_host" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down a Scsi_Host’s SAS data structures</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Scsi Host that is torn down</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes all SAS PHYs and remote PHYs for a given Scsi_Host and remove the
Scsi_Host as well.</p>
<p><strong>Note</strong></p>
<p>Do not call <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a> on the Scsi_Host any more, as it is
already removed.</p>
</div>
<dl class="function">
<dt id="c.sas_get_address">
u64 <code class="sig-name descname">sas_get_address</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_get_address" title="Permalink to this definition">¶</a></dt>
<dd><p>return the SAS address of the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the SAS address of the scsi device</p>
</div>
<dl class="function">
<dt id="c.sas_tlr_supported">
unsigned int <code class="sig-name descname">sas_tlr_supported</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_tlr_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>checking TLR bit in vpd 0x90</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check Transport Layer Retries are supported or not.
If vpd page 0x90 is present, TRL is supported.</p>
</div>
<dl class="function">
<dt id="c.sas_disable_tlr">
void <code class="sig-name descname">sas_disable_tlr</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_disable_tlr" title="Permalink to this definition">¶</a></dt>
<dd><p>setting TLR flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Seting tlr_enabled flag to 0.</p>
</div>
<dl class="function">
<dt id="c.sas_enable_tlr">
void <code class="sig-name descname">sas_enable_tlr</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_enable_tlr" title="Permalink to this definition">¶</a></dt>
<dd><p>setting TLR flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>scsi device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Seting tlr_enabled flag 1.</p>
</div>
<dl class="function">
<dt id="c.sas_phy_alloc">
struct sas_phy * <code class="sig-name descname">sas_phy_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *parent</em>, int<em> number</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocates and initialize a SAS PHY structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>Parent device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">number</span></code></dt><dd><p>Phy index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an SAS PHY structure.  It will be added in the device tree
below the device specified by <strong>parent</strong>, which has to be either a Scsi_Host
or sas_rphy.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>SAS PHY allocated or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the allocation failed.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sas_phy_add">
int <code class="sig-name descname">sas_phy_add</code><span class="sig-paren">(</span>struct sas_phy<em> *phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a SAS PHY to the device hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*phy</span></code></dt><dd><p>The PHY to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Publishes a SAS PHY to the rest of the system.</p>
</div>
<dl class="function">
<dt id="c.sas_phy_free">
void <code class="sig-name descname">sas_phy_free</code><span class="sig-paren">(</span>struct sas_phy<em> *phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a SAS PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*phy</span></code></dt><dd><p>SAS PHY to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees the specified SAS PHY.</p>
<p><strong>Note</strong></p>
<blockquote>
<div><p>This function must only be called on a PHY that has not
successfully been added using <a class="reference internal" href="#c.sas_phy_add" title="sas_phy_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_phy_add()</span></code></a>.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sas_phy_delete">
void <code class="sig-name descname">sas_phy_delete</code><span class="sig-paren">(</span>struct sas_phy<em> *phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_phy_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>remove SAS PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*phy</span></code></dt><dd><p>SAS PHY to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS PHY.  If the SAS PHY has an
associated remote PHY it is removed before.</p>
</div>
<dl class="function">
<dt id="c.scsi_is_sas_phy">
int <code class="sig-name descname">scsi_is_sas_phy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_is_sas_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> represents a SAS PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">1</span></code> if the device represents a SAS PHY, <code class="docutils literal notranslate"><span class="pre">0</span></code> else</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sas_port_add">
int <code class="sig-name descname">sas_port_add</code><span class="sig-paren">(</span>struct sas_port<em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a SAS port to the device hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>port to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>publishes a port to the rest of the system</p>
</div>
<dl class="function">
<dt id="c.sas_port_free">
void <code class="sig-name descname">sas_port_free</code><span class="sig-paren">(</span>struct sas_port<em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a SAS PORT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>SAS PORT to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees the specified SAS PORT.</p>
<p><strong>Note</strong></p>
<blockquote>
<div><p>This function must only be called on a PORT that has not
successfully been added using <a class="reference internal" href="#c.sas_port_add" title="sas_port_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_port_add()</span></code></a>.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sas_port_delete">
void <code class="sig-name descname">sas_port_delete</code><span class="sig-paren">(</span>struct sas_port<em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>remove SAS PORT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>SAS PORT to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS PORT.  If the SAS PORT has an
associated phys, unlink them from the port as well.</p>
</div>
<dl class="function">
<dt id="c.scsi_is_sas_port">
int <code class="sig-name descname">scsi_is_sas_port</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_is_sas_port" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> represents a SAS port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">1</span></code> if the device represents a SAS Port, <code class="docutils literal notranslate"><span class="pre">0</span></code> else</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sas_port_get_phy">
struct sas_phy * <code class="sig-name descname">sas_port_get_phy</code><span class="sig-paren">(</span>struct sas_port<em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_get_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>try to take a reference on a port member</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>port to check</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sas_port_add_phy">
void <code class="sig-name descname">sas_port_add_phy</code><span class="sig-paren">(</span>struct sas_port<em> *port</em>, struct sas_phy<em> *phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_add_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>add another phy to a port to form a wide port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>port to add the phy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*phy</span></code></dt><dd><p>phy to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a port is initially created, it is empty (has no phys).  All
ports must have at least one phy to operated, and all wide ports
must have at least two.  The current code makes no difference
between ports and wide ports, but the only object that can be
connected to a remote device is a port, so ports must be formed on
all devices with phys if they’re connected to anything.</p>
</div>
<dl class="function">
<dt id="c.sas_port_delete_phy">
void <code class="sig-name descname">sas_port_delete_phy</code><span class="sig-paren">(</span>struct sas_port<em> *port</em>, struct sas_phy<em> *phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_port_delete_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a phy from a port or wide port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*port</span></code></dt><dd><p>port to remove the phy from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_phy</span> <span class="pre">*phy</span></code></dt><dd><p>phy to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is used for tearing down ports again.  It must be
done to every port or wide port before calling sas_port_delete.</p>
</div>
<dl class="function">
<dt id="c.sas_end_device_alloc">
struct sas_rphy * <code class="sig-name descname">sas_end_device_alloc</code><span class="sig-paren">(</span>struct sas_port<em> *parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_end_device_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an rphy for an end device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*parent</span></code></dt><dd><p>which port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an SAS remote PHY structure, connected to <strong>parent</strong>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>SAS PHY allocated or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the allocation failed.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sas_expander_alloc">
struct sas_rphy * <code class="sig-name descname">sas_expander_alloc</code><span class="sig-paren">(</span>struct sas_port<em> *parent</em>, enum sas_device_type<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_expander_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an rphy for an end device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_port</span> <span class="pre">*parent</span></code></dt><dd><p>which port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">sas_device_type</span> <span class="pre">type</span></code></dt><dd><p>SAS_EDGE_EXPANDER_DEVICE or SAS_FANOUT_EXPANDER_DEVICE</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an SAS remote PHY structure, connected to <strong>parent</strong>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>SAS PHY allocated or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the allocation failed.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sas_rphy_add">
int <code class="sig-name descname">sas_rphy_add</code><span class="sig-paren">(</span>struct sas_rphy<em> *rphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a SAS remote PHY to the device hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*rphy</span></code></dt><dd><p>The remote PHY to be added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Publishes a SAS remote PHY to the rest of the system.</p>
</div>
<dl class="function">
<dt id="c.sas_rphy_free">
void <code class="sig-name descname">sas_rphy_free</code><span class="sig-paren">(</span>struct sas_rphy<em> *rphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a SAS remote PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*rphy</span></code></dt><dd><p>SAS remote PHY to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Frees the specified SAS remote PHY.</p>
<p><strong>Note</strong></p>
<blockquote>
<div><p>This function must only be called on a remote
PHY that has not successfully been added using
<a class="reference internal" href="#c.sas_rphy_add" title="sas_rphy_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_rphy_add()</span></code></a> (or has been <a class="reference internal" href="#c.sas_rphy_remove" title="sas_rphy_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">sas_rphy_remove()</span></code></a>’d)</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sas_rphy_delete">
void <code class="sig-name descname">sas_rphy_delete</code><span class="sig-paren">(</span>struct sas_rphy<em> *rphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>remove and free SAS remote PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*rphy</span></code></dt><dd><p>SAS remote PHY to remove and free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS remote PHY and frees it.</p>
</div>
<dl class="function">
<dt id="c.sas_rphy_unlink">
void <code class="sig-name descname">sas_rphy_unlink</code><span class="sig-paren">(</span>struct sas_rphy<em> *rphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>unlink SAS remote PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*rphy</span></code></dt><dd><p>SAS remote phy to unlink from its parent port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes port reference to an rphy</p>
</div>
<dl class="function">
<dt id="c.sas_rphy_remove">
void <code class="sig-name descname">sas_rphy_remove</code><span class="sig-paren">(</span>struct sas_rphy<em> *rphy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_rphy_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove SAS remote PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_rphy</span> <span class="pre">*rphy</span></code></dt><dd><p>SAS remote phy to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SAS remote PHY.</p>
</div>
<dl class="function">
<dt id="c.scsi_is_sas_rphy">
int <code class="sig-name descname">scsi_is_sas_rphy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scsi_is_sas_rphy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> represents a SAS remote PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">1</span></code> if the device represents a SAS remote PHY, <code class="docutils literal notranslate"><span class="pre">0</span></code> else</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sas_attach_transport">
struct scsi_transport_template * <code class="sig-name descname">sas_attach_transport</code><span class="sig-paren">(</span>struct sas_function_template<em> *ft</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_attach_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiate SAS transport template</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sas_function_template</span> <span class="pre">*ft</span></code></dt><dd><p>SAS transport class function template</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sas_release_transport">
void <code class="sig-name descname">sas_release_transport</code><span class="sig-paren">(</span>struct scsi_transport_template<em> *t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sas_release_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>release SAS transport template instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_transport_template</span> <span class="pre">*t</span></code></dt><dd><p>transport template instance</p>
</dd>
</dl>
</div>
</section>
<section id="sata-transport-class">
<h4>SATA transport class<a class="headerlink" href="#sata-transport-class" title="Permalink to this headline">¶</a></h4>
<p>The SATA transport is handled by libata, which has its own book of
documentation in this directory.</p>
</section>
<section id="parallel-scsi-spi-transport-class">
<h4>Parallel SCSI (SPI) transport class<a class="headerlink" href="#parallel-scsi-spi-transport-class" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_spi.c defines transport
attributes for traditional (fast/wide/ultra) SCSI busses.</p>
<dl class="function">
<dt id="c.spi_schedule_dv_device">
void <code class="sig-name descname">spi_schedule_dv_device</code><span class="sig-paren">(</span>struct scsi_device<em> *sdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_schedule_dv_device" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule domain validation to occur on the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_device</span> <span class="pre">*sdev</span></code></dt><dd><p>The device to validate</p>
<p>Identical to spi_dv_device() above, except that the DV will be
scheduled to occur in a workqueue later.  All memory allocations
are atomic, so may be called from any context including those holding
SCSI locks.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.spi_display_xfer_agreement">
void <code class="sig-name descname">spi_display_xfer_agreement</code><span class="sig-paren">(</span>struct scsi_target<em> *starget</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_display_xfer_agreement" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the current target transfer agreement</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_target</span> <span class="pre">*starget</span></code></dt><dd><p>The target for which to display the agreement</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each SPI port is required to maintain a transfer agreement for each
other port on the bus.  This function prints a one-line summary of
the current agreement; more detailed information is available in sysfs.</p>
</div>
<dl class="function">
<dt id="c.spi_populate_tag_msg">
int <code class="sig-name descname">spi_populate_tag_msg</code><span class="sig-paren">(</span>unsigned char<em> *msg</em>, struct scsi_cmnd<em> *cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_populate_tag_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>place a tag message in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*msg</span></code></dt><dd><p>pointer to the area to place the tag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*cmd</span></code></dt><dd><p>pointer to the scsi command for the tag</p>
</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>designed to create the correct type of tag message for the
particular request.  Returns the size of the tag message.
May return 0 if TCQ is disabled for this device.</p>
</div></blockquote>
</div>
</section>
<section id="scsi-rdma-srp-transport-class">
<h4>SCSI RDMA (SRP) transport class<a class="headerlink" href="#scsi-rdma-srp-transport-class" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_transport_srp.c defines transport
attributes for SCSI over Remote Direct Memory Access.</p>
<dl class="function">
<dt id="c.srp_tmo_valid">
int <code class="sig-name descname">srp_tmo_valid</code><span class="sig-paren">(</span>int<em> reconnect_delay</em>, int<em> fast_io_fail_tmo</em>, long<em> dev_loss_tmo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_tmo_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>check timeout combination validity</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">reconnect_delay</span></code></dt><dd><p>Reconnect delay in seconds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fast_io_fail_tmo</span></code></dt><dd><p>Fast I/O fail timeout in seconds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">dev_loss_tmo</span></code></dt><dd><p>Device loss timeout in seconds.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The combination of the timeout parameters must be such that SCSI commands
are finished in a reasonable time. Hence do not allow the fast I/O fail
timeout to exceed SCSI_DEVICE_BLOCK_MAX_TIMEOUT nor allow dev_loss_tmo to
exceed that limit if failing I/O fast has been disabled. Furthermore, these
parameters must be such that multipath can detect failed paths timely.
Hence do not allow all three parameters to be disabled simultaneously.</p>
</div>
<dl class="function">
<dt id="c.srp_start_tl_fail_timers">
void <code class="sig-name descname">srp_start_tl_fail_timers</code><span class="sig-paren">(</span>struct srp_rport<em> *rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_start_tl_fail_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>start the transport layer failure timers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start the transport layer fast I/O failure and device loss timers. Do not
modify a timer that was already started.</p>
</div>
<dl class="function">
<dt id="c.srp_reconnect_rport">
int <code class="sig-name descname">srp_reconnect_rport</code><span class="sig-paren">(</span>struct srp_rport<em> *rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_reconnect_rport" title="Permalink to this definition">¶</a></dt>
<dd><p>reconnect to an SRP target port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Blocks SCSI command queueing before invoking reconnect() such that
queuecommand() won’t be invoked concurrently with reconnect() from outside
the SCSI EH. This is important since a reconnect() implementation may
reallocate resources needed by queuecommand().</p>
<p><strong>Notes</strong></p>
<ul class="simple">
<li><p>This function neither waits until outstanding requests have finished nor
tries to abort these. It is the responsibility of the reconnect()
function to finish outstanding commands before reconnecting to the target
port.</p></li>
<li><p>It is the responsibility of the caller to ensure that the resources
reallocated by the reconnect() function won’t be used while this function
is in progress. One possible strategy is to invoke this function from
the context of the SCSI EH thread only. Another possible strategy is to
lock the rport mutex inside each SCSI LLD callback that can be invoked by
the SCSI EH (the scsi_host_template.eh_*() functions and also the
scsi_host_template.queuecommand() function).</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.srp_timed_out">
enum scsi_timeout_action <code class="sig-name descname">srp_timed_out</code><span class="sig-paren">(</span>struct scsi_cmnd<em> *scmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_timed_out" title="Permalink to this definition">¶</a></dt>
<dd><p>SRP transport intercept of the SCSI timeout EH</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*scmd</span></code></dt><dd><p>SCSI command.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a timeout occurs while an rport is in the blocked state, ask the SCSI
EH to continue waiting (SCSI_EH_RESET_TIMER). Otherwise let the SCSI core
handle the timeout (SCSI_EH_NOT_HANDLED).</p>
<p><strong>Note</strong></p>
<p>This function is called from soft-IRQ context and with the request
queue lock held.</p>
</div>
<dl class="function">
<dt id="c.srp_rport_get">
void <code class="sig-name descname">srp_rport_get</code><span class="sig-paren">(</span>struct srp_rport<em> *rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_get" title="Permalink to this definition">¶</a></dt>
<dd><p>increment rport reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.srp_rport_put">
void <code class="sig-name descname">srp_rport_put</code><span class="sig-paren">(</span>struct srp_rport<em> *rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_put" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement rport reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP target port.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.srp_rport_add">
struct srp_rport * <code class="sig-name descname">srp_rport_add</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em>, struct srp_rport_identifiers<em> *ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a SRP remote port to the device hierarchy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>scsi host the remote port is connected to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport_identifiers</span> <span class="pre">*ids</span></code></dt><dd><p>The port id for the remote port.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Publishes a port to the rest of the system.</p>
</div>
<dl class="function">
<dt id="c.srp_rport_del">
void <code class="sig-name descname">srp_rport_del</code><span class="sig-paren">(</span>struct srp_rport<em> *rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_rport_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a SRP remote port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP remote port to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the specified SRP remote port.</p>
</div>
<dl class="function">
<dt id="c.srp_remove_host">
void <code class="sig-name descname">srp_remove_host</code><span class="sig-paren">(</span>struct Scsi_Host<em> *shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_remove_host" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down a Scsi_Host’s SRP data structures</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*shost</span></code></dt><dd><p>Scsi Host that is torn down</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes all SRP remote ports for a given Scsi_Host.
Must be called just before scsi_remove_host for SRP HBAs.</p>
</div>
<dl class="function">
<dt id="c.srp_stop_rport_timers">
void <code class="sig-name descname">srp_stop_rport_timers</code><span class="sig-paren">(</span>struct srp_rport<em> *rport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_stop_rport_timers" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the transport layer recovery timers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_rport</span> <span class="pre">*rport</span></code></dt><dd><p>SRP remote port for which to stop the timers.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called after <a class="reference internal" href="#c.srp_remove_host" title="srp_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">srp_remove_host()</span></code></a> and <a class="reference internal" href="#c.scsi_remove_host" title="scsi_remove_host"><code class="xref c c-func docutils literal notranslate"><span class="pre">scsi_remove_host()</span></code></a>. The caller
must hold a reference on the rport (rport-&gt;dev) and on the SCSI host
(rport-&gt;dev.parent).</p>
</div>
<dl class="function">
<dt id="c.srp_attach_transport">
struct scsi_transport_template * <code class="sig-name descname">srp_attach_transport</code><span class="sig-paren">(</span>struct srp_function_template<em> *ft</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_attach_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiate SRP transport template</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">srp_function_template</span> <span class="pre">*ft</span></code></dt><dd><p>SRP transport class function template</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.srp_release_transport">
void <code class="sig-name descname">srp_release_transport</code><span class="sig-paren">(</span>struct scsi_transport_template<em> *t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srp_release_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>release SRP transport template instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scsi_transport_template</span> <span class="pre">*t</span></code></dt><dd><p>transport template instance</p>
</dd>
</dl>
</div>
</section>
</section>
</section>
<section id="scsi-lower-layer">
<h2>SCSI lower layer<a class="headerlink" href="#scsi-lower-layer" title="Permalink to this headline">¶</a></h2>
<section id="host-bus-adapter-transport-types">
<h3>Host Bus Adapter transport types<a class="headerlink" href="#host-bus-adapter-transport-types" title="Permalink to this headline">¶</a></h3>
<p>Many modern device controllers use the SCSI command set as a protocol to
communicate with their devices through many different types of physical
connections.</p>
<p>In SCSI language a bus capable of carrying SCSI commands is called a
“transport”, and a controller connecting to such a bus is called a “host
bus adapter” (HBA).</p>
<section id="debug-transport">
<h4>Debug transport<a class="headerlink" href="#debug-transport" title="Permalink to this headline">¶</a></h4>
<p>The file drivers/scsi/scsi_debug.c simulates a host adapter with a
variable number of disks (or disk like devices) attached, sharing a
common amount of RAM. Does a lot of checking to make sure that we are
not getting blocks mixed up, and panics the kernel if anything out of
the ordinary is seen.</p>
<p>To be more realistic, the simulated devices have the transport
attributes of SAS disks.</p>
<p>For documentation see <a class="reference external" href="http://sg.danny.cz/sg/sdebug26.html">http://sg.danny.cz/sg/sdebug26.html</a></p>
</section>
<section id="todo">
<h4>todo<a class="headerlink" href="#todo" title="Permalink to this headline">¶</a></h4>
<p>Parallel (fast/wide/ultra) SCSI, USB, SATA, SAS, Fibre Channel,
FireWire, ATAPI devices, Infiniband, I2O, Parallel ports,
netlink…</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">SCSI Interfaces Guide</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#protocol-vs-bus">Protocol vs bus</a></li>
<li><a class="reference internal" href="#design-of-the-linux-scsi-subsystem">Design of the Linux SCSI subsystem</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scsi-upper-layer">SCSI upper layer</a><ul>
<li><a class="reference internal" href="#sd-scsi-disk">sd (SCSI Disk)</a></li>
<li><a class="reference internal" href="#sr-scsi-cd-rom">sr (SCSI CD-ROM)</a></li>
<li><a class="reference internal" href="#st-scsi-tape">st (SCSI Tape)</a></li>
<li><a class="reference internal" href="#sg-scsi-generic">sg (SCSI Generic)</a></li>
<li><a class="reference internal" href="#ch-scsi-media-changer">ch (SCSI Media Changer)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scsi-mid-layer">SCSI mid layer</a><ul>
<li><a class="reference internal" href="#scsi-midlayer-implementation">SCSI midlayer implementation</a><ul>
<li><a class="reference internal" href="#include-scsi-scsi-device-h">include/scsi/scsi_device.h</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-c">drivers/scsi/scsi.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsicam-c">drivers/scsi/scsicam.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-error-c">drivers/scsi/scsi_error.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-devinfo-c">drivers/scsi/scsi_devinfo.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-ioctl-c">drivers/scsi/scsi_ioctl.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-lib-c">drivers/scsi/scsi_lib.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-lib-dma-c">drivers/scsi/scsi_lib_dma.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-proc-c">drivers/scsi/scsi_proc.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-netlink-c">drivers/scsi/scsi_netlink.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-scan-c">drivers/scsi/scsi_scan.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-sysctl-c">drivers/scsi/scsi_sysctl.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-sysfs-c">drivers/scsi/scsi_sysfs.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-hosts-c">drivers/scsi/hosts.c</a></li>
<li><a class="reference internal" href="#drivers-scsi-scsi-common-c">drivers/scsi/scsi_common.c</a></li>
</ul>
</li>
<li><a class="reference internal" href="#transport-classes">Transport classes</a><ul>
<li><a class="reference internal" href="#fibre-channel-transport">Fibre Channel transport</a></li>
<li><a class="reference internal" href="#iscsi-transport-class">iSCSI transport class</a></li>
<li><a class="reference internal" href="#serial-attached-scsi-sas-transport-class">Serial Attached SCSI (SAS) transport class</a></li>
<li><a class="reference internal" href="#sata-transport-class">SATA transport class</a></li>
<li><a class="reference internal" href="#parallel-scsi-spi-transport-class">Parallel SCSI (SPI) transport class</a></li>
<li><a class="reference internal" href="#scsi-rdma-srp-transport-class">SCSI RDMA (SRP) transport class</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#scsi-lower-layer">SCSI lower layer</a><ul>
<li><a class="reference internal" href="#host-bus-adapter-transport-types">Host Bus Adapter transport types</a><ul>
<li><a class="reference internal" href="#debug-transport">Debug transport</a></li>
<li><a class="reference internal" href="#todo">todo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/scsi.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/scsi.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>