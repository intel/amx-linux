
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>General Purpose Input/Output (GPIO) &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Introduction" href="intro.html" />
    <link rel="prev" title="PINCTRL (PIN CONTROL) subsystem" href="../pin-control.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="general-purpose-input-output-gpio">
<h1>General Purpose Input/Output (GPIO)<a class="headerlink" href="#general-purpose-input-output-gpio" title="Permalink to this headline">¶</a></h1>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="intro.html#gpio-interfaces">GPIO Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html#what-is-a-gpio">What is a GPIO?</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html#common-gpio-properties">Common GPIO Properties</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="using-gpio.html">Using GPIO Lines in Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="driver.html">GPIO Driver Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="driver.html#internal-representation-of-gpios">Internal Representation of GPIOs</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver.html#controller-drivers-gpio-chip">Controller Drivers: gpio_chip</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver.html#gpio-drivers-providing-irqs">GPIO drivers providing IRQs</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver.html#requesting-self-owned-gpio-pins">Requesting self-owned GPIO pins</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="consumer.html">GPIO Descriptor Consumer Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#guidelines-for-gpios-consumers">Guidelines for GPIOs consumers</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#obtaining-and-disposing-gpios">Obtaining and Disposing GPIOs</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#using-gpios">Using GPIOs</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#gpios-and-acpi">GPIOs and ACPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#interacting-with-the-legacy-gpio-subsystem">Interacting With the Legacy GPIO Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="board.html">GPIO Mappings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="board.html#device-tree">Device Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="board.html#acpi">ACPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="board.html#platform-data">Platform Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="board.html#arrays-of-pins">Arrays of pins</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="drivers-on-gpio.html">Subsystem drivers using GPIO</a></li>
<li class="toctree-l1"><a class="reference internal" href="legacy.html">Legacy GPIO Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#what-is-a-gpio">What is a GPIO?</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#gpio-conventions">GPIO conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#what-do-these-conventions-omit">What do these conventions omit?</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#gpio-implementor-s-framework-optional">GPIO implementor’s framework (OPTIONAL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#sysfs-interface-for-userspace-optional">Sysfs Interface for Userspace (OPTIONAL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bt8xxgpio.html">A driver for a selfmade cheap BT8xx based PCI GPIO-card (bt8xxgpio)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="bt8xxgpio.html#how-to-physically-access-the-gpio-pins">How to physically access the GPIO pins</a></li>
</ul>
</li>
</ul>
</div>
<section id="core">
<h2>Core<a class="headerlink" href="#core" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.gpio_irq_chip">
struct <code class="sig-name descname">gpio_irq_chip</code><a class="headerlink" href="#c.gpio_irq_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>GPIO interrupt controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_irq_chip {
    struct irq_chip *chip;
    struct irq_domain *domain;
    const struct irq_domain_ops *domain_ops;
#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY;
    struct fwnode_handle *fwnode;
    struct irq_domain *parent_domain;
    int (*child_to_parent_hwirq)(struct gpio_chip *gc,unsigned int child_hwirq,unsigned int child_type,unsigned int *parent_hwirq, unsigned int *parent_type);
    int (*populate_parent_alloc_arg)(struct gpio_chip *gc,union gpio_irq_fwspec *fwspec,unsigned int parent_hwirq, unsigned int parent_type);
    unsigned int (*child_offset_to_irq)(struct gpio_chip *gc, unsigned int pin);
    struct irq_domain_ops child_irq_domain_ops;
#endif;
    irq_flow_handler_t handler;
    unsigned int default_type;
    struct lock_class_key *lock_key;
    struct lock_class_key *request_key;
    irq_flow_handler_t parent_handler;
    union {
        void *parent_handler_data;
        void **parent_handler_data_array;
    };
    unsigned int num_parents;
    unsigned int *parents;
    unsigned int *map;
    bool threaded;
    bool per_parent_data;
    bool initialized;
    int (*init_hw)(struct gpio_chip *gc);
    void (*init_valid_mask)(struct gpio_chip *gc,unsigned long *valid_mask, unsigned int ngpios);
    unsigned long *valid_mask;
    unsigned int first;
    void (*irq_enable)(struct irq_data *data);
    void (*irq_disable)(struct irq_data *data);
    void (*irq_unmask)(struct irq_data *data);
    void (*irq_mask)(struct irq_data *data);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">chip</span></code></dt><dd><p>GPIO IRQ chip implementation, provided by GPIO driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">domain</span></code></dt><dd><p>Interrupt translation domain; responsible for mapping between GPIO
hwirq number and Linux IRQ number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">domain_ops</span></code></dt><dd><p>Table of interrupt domain operations for this IRQ chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt><dd><p>Firmware node corresponding to this gpiochip/irqchip, necessary
for hierarchical irqdomain support.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent_domain</span></code></dt><dd><p>If non-NULL, will be set as the parent of this GPIO interrupt
controller’s IRQ domain to establish a hierarchical interrupt
domain. The presence of this will activate the hierarchical
interrupt support.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">child_to_parent_hwirq</span></code></dt><dd><p>This callback translates a child hardware IRQ offset to a parent
hardware IRQ offset on a hierarchical interrupt chip. The child
hardware IRQs correspond to the GPIO index 0..ngpio-1 (see the
ngpio field of <a class="reference internal" href="#c.gpio_chip" title="gpio_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span></code></a>) and the corresponding parent
hardware IRQ and type (such as IRQ_TYPE_*) shall be returned by
the driver. The driver can calculate this from an offset or using
a lookup table or whatever method is best for this chip. Return
0 on successful translation in the driver.</p>
<p>If some ranges of hardware IRQs do not have a corresponding parent
HWIRQ, return -EINVAL, but also make sure to fill in <strong>valid_mask</strong> and
<strong>need_valid_mask</strong> to make these GPIO lines unavailable for
translation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">populate_parent_alloc_arg</span></code></dt><dd><p>This optional callback allocates and populates the specific struct
for the parent’s IRQ domain. If this is not specified, then
<code class="xref c c-type docutils literal notranslate"><span class="pre">gpiochip_populate_parent_fwspec_twocell</span></code> will be used. A four-cell
variant named <code class="xref c c-type docutils literal notranslate"><span class="pre">gpiochip_populate_parent_fwspec_fourcell</span></code> is also
available.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">child_offset_to_irq</span></code></dt><dd><p>This optional callback is used to translate the child’s GPIO line
offset on the GPIO chip to an IRQ number for the GPIO to_irq()
callback. If this is not specified, then a default callback will be
provided that returns the line offset.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">child_irq_domain_ops</span></code></dt><dd><p>The IRQ domain operations that will be used for this GPIO IRQ
chip. If no operations are provided, then default callbacks will
be populated to setup the IRQ hierarchy. Some drivers need to
supply their own translate function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt><dd><p>The IRQ handler to use (often a predefined IRQ core function) for
GPIO IRQs, provided by GPIO driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">default_type</span></code></dt><dd><p>Default IRQ triggering type applied during GPIO driver
initialization, provided by GPIO driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock_key</span></code></dt><dd><p>Per GPIO IRQ chip lockdep class for IRQ lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request_key</span></code></dt><dd><p>Per GPIO IRQ chip lockdep class for IRQ request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent_handler</span></code></dt><dd><p>The interrupt handler for the GPIO chip’s parent interrupts, may be
NULL if the parent interrupts are nested rather than cascaded.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent_handler_data</span></code></dt><dd><p>If <strong>per_parent_data</strong> is false, <strong>parent_handler_data</strong> is a
single pointer used as the data associated with every
parent interrupt.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent_handler_data_array</span></code></dt><dd><p>If <strong>per_parent_data</strong> is true, <strong>parent_handler_data_array</strong> is
an array of <strong>num_parents</strong> pointers, and is used to associate
different data for each parent. This cannot be NULL if
<strong>per_parent_data</strong> is true.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_parents</span></code></dt><dd><p>The number of interrupt parents of a GPIO chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parents</span></code></dt><dd><p>A list of interrupt parents of a GPIO chip. This is owned by the
driver, so the core will only reference this list, not modify it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map</span></code></dt><dd><p>A list of interrupt parents for each line of a GPIO chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">threaded</span></code></dt><dd><p>True if set the interrupt handling uses nested threads.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">per_parent_data</span></code></dt><dd><p>True if parent_handler_data_array describes a <strong>num_parents</strong>
sized array to be used as parent data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initialized</span></code></dt><dd><p>Flag to track GPIO chip irq member’s initialization.
This flag will make sure GPIO chip irq members are not used
before they are initialized.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_hw</span></code></dt><dd><p>optional routine to initialize hardware before
an IRQ chip will be added. This is quite useful when
a particular driver wants to clear IRQ related registers
in order to avoid undesired events.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_valid_mask</span></code></dt><dd><p>optional routine to initialize <strong>valid_mask</strong>, to be
used if not all GPIO lines are valid interrupts. Sometimes some
lines just cannot fire interrupts, and this routine, when defined,
is passed a bitmap in “valid_mask” and it will have ngpios
bits from 0..(ngpios-1) set to “1” as in valid. The callback can
then directly set some bits to “0” if they cannot be used for
interrupts.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid_mask</span></code></dt><dd><p>If not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, holds bitmask of GPIOs which are valid to be included
in IRQ domain of the chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">first</span></code></dt><dd><p>Required for static IRQ allocation. If set, irq_domain_add_simple()
will allocate and map all IRQs during initialization.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_enable</span></code></dt><dd><p>Store old irq_chip irq_enable callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_disable</span></code></dt><dd><p>Store old irq_chip irq_disable callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_unmask</span></code></dt><dd><p>Store old irq_chip irq_unmask callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_mask</span></code></dt><dd><p>Store old irq_chip irq_mask callback</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.gpio_chip">
struct <code class="sig-name descname">gpio_chip</code><a class="headerlink" href="#c.gpio_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>abstract a GPIO controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_chip {
    const char              *label;
    struct gpio_device      *gpiodev;
    struct device           *parent;
    struct fwnode_handle    *fwnode;
    struct module           *owner;
    int (*request)(struct gpio_chip *gc, unsigned int offset);
    void (*free)(struct gpio_chip *gc, unsigned int offset);
    int (*get_direction)(struct gpio_chip *gc, unsigned int offset);
    int (*direction_input)(struct gpio_chip *gc, unsigned int offset);
    int (*direction_output)(struct gpio_chip *gc, unsigned int offset, int value);
    int (*get)(struct gpio_chip *gc, unsigned int offset);
    int (*get_multiple)(struct gpio_chip *gc,unsigned long *mask, unsigned long *bits);
    void (*set)(struct gpio_chip *gc, unsigned int offset, int value);
    void (*set_multiple)(struct gpio_chip *gc,unsigned long *mask, unsigned long *bits);
    int (*set_config)(struct gpio_chip *gc,unsigned int offset, unsigned long config);
    int (*to_irq)(struct gpio_chip *gc, unsigned int offset);
    void (*dbg_show)(struct seq_file *s, struct gpio_chip *gc);
    int (*init_valid_mask)(struct gpio_chip *gc,unsigned long *valid_mask, unsigned int ngpios);
    int (*add_pin_ranges)(struct gpio_chip *gc);
    int (*en_hw_timestamp)(struct gpio_chip *gc,u32 offset, unsigned long flags);
    int (*dis_hw_timestamp)(struct gpio_chip *gc,u32 offset, unsigned long flags);
    int base;
    u16 ngpio;
    u16 offset;
    const char              *const *names;
    bool can_sleep;
#if IS_ENABLED(CONFIG_GPIO_GENERIC);
    unsigned long (*read_reg)(void __iomem *reg);
    void (*write_reg)(void __iomem *reg, unsigned long data);
    bool be_bits;
    void __iomem *reg_dat;
    void __iomem *reg_set;
    void __iomem *reg_clr;
    void __iomem *reg_dir_out;
    void __iomem *reg_dir_in;
    bool bgpio_dir_unreadable;
    int bgpio_bits;
    raw_spinlock_t bgpio_lock;
    unsigned long bgpio_data;
    unsigned long bgpio_dir;
#endif ;
#ifdef CONFIG_GPIOLIB_IRQCHIP;
    struct gpio_irq_chip irq;
#endif ;
    unsigned long *valid_mask;
#if defined(CONFIG_OF_GPIO);
    struct device_node *of_node;
    unsigned int of_gpio_n_cells;
    int (*of_xlate)(struct gpio_chip *gc, const struct of_phandle_args *gpiospec, u32 *flags);
    int (*of_gpio_ranges_fallback)(struct gpio_chip *gc, struct device_node *np);
#endif ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">label</span></code></dt><dd><p>a functional name for the GPIO device, such as a part
number or the name of the SoC IP-block implementing it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gpiodev</span></code></dt><dd><p>the internal state holder, opaque struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>optional parent device providing the GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt><dd><p>optional fwnode providing this controller’s properties</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>helps prevent removal of modules exporting active GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request</span></code></dt><dd><p>optional hook for chip-specific activation, such as
enabling module power and clock; may sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free</span></code></dt><dd><p>optional hook for chip-specific deactivation, such as
disabling module power and clock; may sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_direction</span></code></dt><dd><p>returns direction for signal “offset”, 0=out, 1=in,
(same as GPIO_LINE_DIRECTION_OUT / GPIO_LINE_DIRECTION_IN),
or negative error. It is recommended to always implement this
function, even on input-only or output-only gpio chips.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction_input</span></code></dt><dd><p>configures signal “offset” as input, or returns error
This can be omitted on input-only or output-only gpio chips.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction_output</span></code></dt><dd><p>configures signal “offset” as output, or returns error
This can be omitted on input-only or output-only gpio chips.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get</span></code></dt><dd><p>returns value for signal “offset”, 0=low, 1=high, or negative error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_multiple</span></code></dt><dd><p>reads values for multiple signals defined by “mask” and
stores them in “bits”, returns 0 on success or negative error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set</span></code></dt><dd><p>assigns output value for signal “offset”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_multiple</span></code></dt><dd><p>assigns output values for multiple signals defined by “mask”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_config</span></code></dt><dd><p>optional hook for all kinds of settings. Uses the same
packed config format as generic pinconf.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">to_irq</span></code></dt><dd><p>optional hook supporting non-static gpio_to_irq() mappings;
implementation may not sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dbg_show</span></code></dt><dd><p>optional routine to show contents in debugfs; default code
will be used when this is omitted, but custom code can show extra
state (such as pullup/pulldown configuration).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_valid_mask</span></code></dt><dd><p>optional routine to initialize <strong>valid_mask</strong>, to be used if
not all GPIOs are valid.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">add_pin_ranges</span></code></dt><dd><p>optional routine to initialize pin ranges, to be used when
requires special mapping of the pins that provides GPIO functionality.
It is called after adding GPIO chip and before adding IRQ chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">en_hw_timestamp</span></code></dt><dd><p>Dependent on GPIO chip, an optional routine to
enable hardware timestamp.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dis_hw_timestamp</span></code></dt><dd><p>Dependent on GPIO chip, an optional routine to
disable hardware timestamp.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>identifies the first GPIO number handled by this chip;
or, if negative during registration, requests dynamic ID allocation.
DEPRECATION: providing anything non-negative and nailing the base
offset of GPIO chips is deprecated. Please pass -1 as base to
let gpiolib select the chip base in all possible cases. We want to
get rid of the static GPIO number space in the long run.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ngpio</span></code></dt><dd><p>the number of GPIOs handled by this controller; the last GPIO
handled is (base + ngpio - 1).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>when multiple gpio chips belong to the same device this
can be used as offset within the device so friendly names can
be properly assigned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">names</span></code></dt><dd><p>if set, must be an array of strings to use as alternative
names for the GPIOs in this chip. Any entry in the array
may be NULL if there is no alias for the GPIO, however the
array must be <strong>ngpio</strong> entries long.  A name can include a single printk
format specifier for an unsigned int.  It is substituted by the actual
number of the gpio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">can_sleep</span></code></dt><dd><p>flag must be set iff get()/set() methods sleep, as they
must while accessing GPIO expander chips over I2C or SPI. This
implies that if the chip supports IRQs, these IRQs need to be threaded
as the chip access may sleep when e.g. reading out the IRQ status
registers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_reg</span></code></dt><dd><p>reader function for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_reg</span></code></dt><dd><p>writer function for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">be_bits</span></code></dt><dd><p>if the generic GPIO has big endian bit order (bit 31 is representing
line 0, bit 30 is line 1 … bit 0 is line 31) this is set to true by the
generic GPIO core. It is for internal housekeeping only.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_dat</span></code></dt><dd><p>data (in) register for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_set</span></code></dt><dd><p>output set register (out=high) for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_clr</span></code></dt><dd><p>output clear register (out=low) for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_dir_out</span></code></dt><dd><p>direction out setting register for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_dir_in</span></code></dt><dd><p>direction in setting register for generic GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bgpio_dir_unreadable</span></code></dt><dd><p>indicates that the direction register(s) cannot
be read and we need to rely on out internal state tracking.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bgpio_bits</span></code></dt><dd><p>number of register bits used for a generic GPIO i.e.
&lt;register width&gt; * 8</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bgpio_lock</span></code></dt><dd><p>used to lock chip-&gt;bgpio_data. Also, this is needed to keep
shadowed and real data registers writes together.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bgpio_data</span></code></dt><dd><p>shadowed data register for generic GPIO to clear/set bits
safely.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bgpio_dir</span></code></dt><dd><p>shadowed direction register for generic GPIO to clear/set
direction safely. A “1” in this word means the line is set as
output.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>Integrates interrupt chip functionality with the GPIO chip. Can be
used to handle IRQs for most practical cases.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid_mask</span></code></dt><dd><p>If not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, holds bitmask of GPIOs which are valid to be used
from the chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt><dd><p>Pointer to a device tree node representing this GPIO controller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_gpio_n_cells</span></code></dt><dd><p>Number of cells used to form the GPIO specifier.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_xlate</span></code></dt><dd><p>Callback to translate a device tree GPIO specifier into a chip-
relative GPIO number and flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_gpio_ranges_fallback</span></code></dt><dd><p>Optional hook for the case that no gpio-ranges property is defined
within the device tree node “np” (usually DT before introduction
of gpio-ranges). So this callback is helpful to provide the
necessary backward compatibility for the pin ranges.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A gpio_chip can help platforms abstract various sources of GPIOs so
they can all be accessed through a common programming interface.
Example sources would be SOC controllers, FPGAs, multifunction
chips, dedicated GPIO expanders, and so on.</p>
<p>Each chip controls a number of signals, identified in method calls
by “offset” values in the range 0..(<strong>ngpio</strong> - 1).  When those signals
are referenced through calls like gpio_get_value(gpio), the offset
is calculated by subtracting <strong>base</strong> from the gpio number.</p>
<dl class="function">
<dt id="c.for_each_requested_gpio_in_range">
<code class="sig-name descname">for_each_requested_gpio_in_range</code><span class="sig-paren">(</span><em>chip</em>, <em>i</em>, <em>base</em>, <em>size</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_requested_gpio_in_range" title="Permalink to this definition">¶</a></dt>
<dd><p>iterates over requested GPIOs in a given range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">chip</span></code></dt><dd><p>the chip to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i</span></code></dt><dd><p>loop variable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>first GPIO in the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>amount of GPIOs to check starting from <strong>base</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">label</span></code></dt><dd><p>label of current GPIO</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiochip_add_data">
<code class="sig-name descname">gpiochip_add_data</code><span class="sig-paren">(</span><em>gc</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>register a gpio_chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gc</span></code></dt><dd><p>the chip to register, with gc-&gt;base initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>driver-private data associated with this chip</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>potentially before irqs will work</p>
<p><strong>Description</strong></p>
<p>When <a class="reference internal" href="#c.gpiochip_add_data" title="gpiochip_add_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_add_data()</span></code></a> is called very early during boot, so that GPIOs
can be freely used, the gc-&gt;parent device must be registered before
the gpio framework’s arch_initcall().  Otherwise sysfs initialization
for GPIOs will fail rudely.</p>
<p><a class="reference internal" href="#c.gpiochip_add_data" title="gpiochip_add_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_add_data()</span></code></a> must only be called after gpiolib initialization,
i.e. after core_initcall().</p>
<p>If gc-&gt;base is negative, this requests dynamic assignment of
a range of valid GPIOs.</p>
<p><strong>Return</strong></p>
<p>A negative errno if the chip can’t be registered, such as because the
gc-&gt;base is invalid or already associated with a different chip.
Otherwise it returns zero as a success code.</p>
</div>
<dl class="type">
<dt id="c.gpio_pin_range">
struct <code class="sig-name descname">gpio_pin_range</code><a class="headerlink" href="#c.gpio_pin_range" title="Permalink to this definition">¶</a></dt>
<dd><p>pin range controlled by a gpio chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_pin_range {
    struct list_head node;
    struct pinctrl_dev *pctldev;
    struct pinctrl_gpio_range range;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>list for maintaining set of pin ranges, used internally</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pctldev</span></code></dt><dd><p>pinctrl device which handles corresponding pins</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">range</span></code></dt><dd><p>actual range of pins controlled by a gpio controller</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpio_to_desc">
struct gpio_desc * <code class="sig-name descname">gpio_to_desc</code><span class="sig-paren">(</span>unsigned<em> gpio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpio_to_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a GPIO number to its descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">gpio</span></code></dt><dd><p>global GPIO number</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The GPIO descriptor associated with the given GPIO, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no GPIO
with the given number exists in the system.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_get_desc">
struct gpio_desc * <code class="sig-name descname">gpiochip_get_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, unsigned int<em> hwnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_get_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>get the GPIO descriptor corresponding to the given hardware number for this chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>GPIO chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hwnum</span></code></dt><dd><p>hardware number of the GPIO for this chip</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the GPIO descriptor or <code class="docutils literal notranslate"><span class="pre">ERR_PTR(-EINVAL)</span></code> if no GPIO exists
in the given chip for the specified hardware number.</p>
</div>
<dl class="function">
<dt id="c.desc_to_gpio">
int <code class="sig-name descname">desc_to_gpio</code><span class="sig-paren">(</span>const struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.desc_to_gpio" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a GPIO descriptor to the integer namespace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should disappear in the future but is needed since we still
use GPIO numbers for error messages and sysfs nodes.</p>
<p><strong>Return</strong></p>
<p>The global GPIO number for the GPIO specified by its descriptor.</p>
</div>
<dl class="function">
<dt id="c.gpiod_to_chip">
struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> * <code class="sig-name descname">gpiod_to_chip</code><span class="sig-paren">(</span>const struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_to_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the GPIO chip to which a GPIO descriptor belongs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>descriptor to return the chip of</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiod_get_direction">
int <code class="sig-name descname">gpiod_get_direction</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>return the current direction of a GPIO</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO to get the direction of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for output, 1 for input, or an error code in case of error.</p>
<p>This function may sleep if <a class="reference internal" href="#c.gpiod_cansleep" title="gpiod_cansleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_cansleep()</span></code></a> is true.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_get_data">
void * <code class="sig-name descname">gpiochip_get_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>get per-subdriver data for the chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>GPIO chip</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The per-subdriver data for the chip.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_remove">
void <code class="sig-name descname">gpiochip_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a gpio_chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>the chip to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A gpio_chip with any GPIOs still requested may not be removed.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_find">
struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> * <code class="sig-name descname">gpiochip_find</code><span class="sig-paren">(</span>void<em> *data</em>, int (<em>*match</em>)(struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *gc, void *data)<span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_find" title="Permalink to this definition">¶</a></dt>
<dd><p>iterator for locating a specific gpio_chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data to pass to match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*match)(struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc,</span> <span class="pre">void</span> <span class="pre">*data)</span></code></dt><dd><p>Callback function to check gpio_chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to bus_find_device.  It returns a reference to a gpio_chip as
determined by a user supplied <strong>match</strong> callback.  The callback should return
0 if the device doesn’t match and non-zero if it does.  If the callback is
non-zero, this function will return to the caller and not iterate over any
more gpio_chips.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_irq_map">
int <code class="sig-name descname">gpiochip_irq_map</code><span class="sig-paren">(</span>struct irq_domain<em> *d</em>, unsigned int<em> irq</em>, irq_hw_number_t<em> hwirq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_irq_map" title="Permalink to this definition">¶</a></dt>
<dd><p>maps an IRQ into a GPIO irqchip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*d</span></code></dt><dd><p>the irqdomain used by this irqchip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>the global irq number used by this GPIO irqchip irq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt><dd><p>the local IRQ/GPIO line offset on this gpiochip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will set up the mapping for a certain IRQ line on a
gpiochip by assigning the gpiochip as chip data, and using the irqchip
stored inside the gpiochip.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_irq_domain_activate">
int <code class="sig-name descname">gpiochip_irq_domain_activate</code><span class="sig-paren">(</span>struct irq_domain<em> *domain</em>, struct <a class="reference internal" href="../../core-api/genericirq.html#c.irq_data" title="irq_data">irq_data</a><em> *data</em>, bool<em> reserve</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_irq_domain_activate" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock a GPIO to be used as an IRQ</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>The IRQ domain used by this IRQ chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Outermost irq_data associated with the IRQ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">reserve</span></code></dt><dd><p>If set, only reserve an interrupt vector instead of assigning one</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a wrapper that calls <a class="reference internal" href="#c.gpiochip_lock_as_irq" title="gpiochip_lock_as_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_lock_as_irq()</span></code></a> and is to be
used as the activate function for the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain_ops</span></code>. The host_data
for the IRQ domain must be the <a class="reference internal" href="#c.gpio_chip" title="gpio_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_irq_domain_deactivate">
void <code class="sig-name descname">gpiochip_irq_domain_deactivate</code><span class="sig-paren">(</span>struct irq_domain<em> *domain</em>, struct <a class="reference internal" href="../../core-api/genericirq.html#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_irq_domain_deactivate" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock a GPIO used as an IRQ</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>The IRQ domain used by this IRQ chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>Outermost irq_data associated with the IRQ</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a wrapper that will call <a class="reference internal" href="#c.gpiochip_unlock_as_irq" title="gpiochip_unlock_as_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_unlock_as_irq()</span></code></a> and is to
be used as the deactivate function for the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain_ops</span></code>. The
host_data for the IRQ domain must be the <a class="reference internal" href="#c.gpio_chip" title="gpio_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_irqchip_add_domain">
int <code class="sig-name descname">gpiochip_irqchip_add_domain</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, struct irq_domain<em> *domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_irqchip_add_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>adds an irqdomain to a gpiochip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>the gpiochip to add the irqchip to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*domain</span></code></dt><dd><p>the irqdomain to add to the gpiochip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adds an IRQ domain to the gpiochip.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_generic_request">
int <code class="sig-name descname">gpiochip_generic_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_generic_request" title="Permalink to this definition">¶</a></dt>
<dd><p>request the gpio function for a pin</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>the gpiochip owning the GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>the offset of the GPIO to request for GPIO function</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiochip_generic_free">
void <code class="sig-name descname">gpiochip_generic_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_generic_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free the gpio function from a pin</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>the gpiochip to request the gpio function for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>the offset of the GPIO to free from GPIO function</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiochip_generic_config">
int <code class="sig-name descname">gpiochip_generic_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, unsigned int<em> offset</em>, unsigned long<em> config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_generic_config" title="Permalink to this definition">¶</a></dt>
<dd><p>apply configuration for a pin</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>the gpiochip owning the GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>the offset of the GPIO to apply the configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">config</span></code></dt><dd><p>the configuration to be applied</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiochip_add_pingroup_range">
int <code class="sig-name descname">gpiochip_add_pingroup_range</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, struct pinctrl_dev<em> *pctldev</em>, unsigned int<em> gpio_offset</em>, const char<em> *pin_group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_add_pingroup_range" title="Permalink to this definition">¶</a></dt>
<dd><p>add a range for GPIO &lt;-&gt; pin mapping</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>the gpiochip to add the range for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pinctrl_dev</span> <span class="pre">*pctldev</span></code></dt><dd><p>the pin controller to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">gpio_offset</span></code></dt><dd><p>the start offset in the current gpio_chip number space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pin_group</span></code></dt><dd><p>name of the pin group inside the pin controller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function directly from a DeviceTree-supported
pinctrl driver is DEPRECATED. Please see Section 2.1 of
Documentation/devicetree/bindings/gpio/gpio.txt on how to
bind pinctrl and gpio drivers via the “gpio-ranges” property.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_add_pin_range">
int <code class="sig-name descname">gpiochip_add_pin_range</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, const char<em> *pinctl_name</em>, unsigned int<em> gpio_offset</em>, unsigned int<em> pin_offset</em>, unsigned int<em> npins</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_add_pin_range" title="Permalink to this definition">¶</a></dt>
<dd><p>add a range for GPIO &lt;-&gt; pin mapping</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>the gpiochip to add the range for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pinctl_name</span></code></dt><dd><p>the dev_name() of the pin controller to map to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">gpio_offset</span></code></dt><dd><p>the start offset in the current gpio_chip number space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pin_offset</span></code></dt><dd><p>the start offset in the pin controller number space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">npins</span></code></dt><dd><p>the number of pins from the offset of each pin space (GPIO and
pin controller) to accumulate in this range</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, or a negative error-code on failure.</p>
<p><strong>Description</strong></p>
<p>Calling this function directly from a DeviceTree-supported
pinctrl driver is DEPRECATED. Please see Section 2.1 of
Documentation/devicetree/bindings/gpio/gpio.txt on how to
bind pinctrl and gpio drivers via the “gpio-ranges” property.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_remove_pin_ranges">
void <code class="sig-name descname">gpiochip_remove_pin_ranges</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_remove_pin_ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all the GPIO &lt;-&gt; pin mappings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>the chip to remove all the mappings for</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiochip_is_requested">
const char * <code class="sig-name descname">gpiochip_is_requested</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_is_requested" title="Permalink to this definition">¶</a></dt>
<dd><p>return string iff signal was requested</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>controller managing the signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>of signal within controller’s 0..(ngpio - 1) range</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the GPIO is not currently requested, else a string.
The string returned is the label passed to gpio_request(); if none has been
passed it is a meaningless, non-NULL constant.</p>
<p>This function is for use by GPIO controller drivers.  The label can
help with diagnostics, and knowing that the signal is used as a GPIO
can help avoid accidentally multiplexing it to another controller.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_request_own_desc">
struct gpio_desc * <code class="sig-name descname">gpiochip_request_own_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, unsigned int<em> hwnum</em>, const char<em> *label</em>, enum gpio_lookup_flags<em> lflags</em>, enum gpiod_flags<em> dflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_request_own_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow GPIO chip to request its own descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>GPIO chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hwnum</span></code></dt><dd><p>hardware number of the GPIO for which to request the descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*label</span></code></dt><dd><p>label for the GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpio_lookup_flags</span> <span class="pre">lflags</span></code></dt><dd><p>lookup flags for this GPIO or 0 if default, this can be used to
specify things like line inversion semantics with the machine flags
such as GPIO_OUT_LOW</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">dflags</span></code></dt><dd><p>descriptor request flags for this GPIO or 0 if default, this
can be used to specify consumer semantics such as open drain</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function allows GPIO chip drivers to request and use their own GPIO
descriptors via gpiolib API. Difference to gpiod_request() is that this
function will not increase reference count of the GPIO chip module. This
allows the GPIO chip module to be unloaded as needed (we assume that the
GPIO chip driver handles freeing the GPIOs it has requested).</p>
<p><strong>Return</strong></p>
<p>A pointer to the GPIO descriptor, or an ERR_PTR()-encoded negative error
code on failure.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_free_own_desc">
void <code class="sig-name descname">gpiochip_free_own_desc</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_free_own_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Free GPIO requested by the chip driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO descriptor to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function frees the given GPIO requested previously with
<a class="reference internal" href="#c.gpiochip_request_own_desc" title="gpiochip_request_own_desc"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_request_own_desc()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.gpiod_direction_input">
int <code class="sig-name descname">gpiod_direction_input</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_direction_input" title="Permalink to this definition">¶</a></dt>
<dd><p>set the GPIO direction to input</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO to set to input</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the direction of the passed GPIO to input, such as <a class="reference internal" href="#c.gpiod_get_value" title="gpiod_get_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_value()</span></code></a> can
be called safely on it.</p>
<p>Return 0 in case of success, else an error code.</p>
</div>
<dl class="function">
<dt id="c.gpiod_direction_output_raw">
int <code class="sig-name descname">gpiod_direction_output_raw</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_direction_output_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>set the GPIO direction to output</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO to set to output</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>initial output value of the GPIO</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the direction of the passed GPIO to output, such as <a class="reference internal" href="#c.gpiod_set_value" title="gpiod_set_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_set_value()</span></code></a> can
be called safely on it. The initial value of the output must be specified
as raw value on the physical line without regard for the ACTIVE_LOW status.</p>
<p>Return 0 in case of success, else an error code.</p>
</div>
<dl class="function">
<dt id="c.gpiod_direction_output">
int <code class="sig-name descname">gpiod_direction_output</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_direction_output" title="Permalink to this definition">¶</a></dt>
<dd><p>set the GPIO direction to output</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO to set to output</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>initial output value of the GPIO</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the direction of the passed GPIO to output, such as <a class="reference internal" href="#c.gpiod_set_value" title="gpiod_set_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_set_value()</span></code></a> can
be called safely on it. The initial value of the output must be specified
as the logical value of the GPIO, i.e. taking its ACTIVE_LOW status into
account.</p>
<p>Return 0 in case of success, else an error code.</p>
</div>
<dl class="function">
<dt id="c.gpiod_enable_hw_timestamp_ns">
int <code class="sig-name descname">gpiod_enable_hw_timestamp_ns</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, unsigned long<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_enable_hw_timestamp_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable hardware timestamp in nanoseconds.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO to enable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>Flags related to GPIO edge.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 in case of success, else negative error code.</p>
</div>
<dl class="function">
<dt id="c.gpiod_disable_hw_timestamp_ns">
int <code class="sig-name descname">gpiod_disable_hw_timestamp_ns</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, unsigned long<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_disable_hw_timestamp_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable hardware timestamp.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO to disable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>Flags related to GPIO edge, same value as used during enable call.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 in case of success, else negative error code.</p>
</div>
<dl class="function">
<dt id="c.gpiod_set_config">
int <code class="sig-name descname">gpiod_set_config</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, unsigned long<em> config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_config" title="Permalink to this definition">¶</a></dt>
<dd><p>sets <strong>config</strong> for a GPIO</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>descriptor of the GPIO for which to set the configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">config</span></code></dt><dd><p>Same packed config format as generic pinconf</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, <code class="docutils literal notranslate"><span class="pre">-ENOTSUPP</span></code> if the controller doesn’t support setting the
configuration.</p>
</div>
<dl class="function">
<dt id="c.gpiod_set_debounce">
int <code class="sig-name descname">gpiod_set_debounce</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, unsigned int<em> debounce</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_debounce" title="Permalink to this definition">¶</a></dt>
<dd><p>sets <strong>debounce</strong> time for a GPIO</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>descriptor of the GPIO for which to set debounce time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">debounce</span></code></dt><dd><p>debounce time in microseconds</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, <code class="docutils literal notranslate"><span class="pre">-ENOTSUPP</span></code> if the controller doesn’t support setting the
debounce time.</p>
</div>
<dl class="function">
<dt id="c.gpiod_set_transitory">
int <code class="sig-name descname">gpiod_set_transitory</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, bool<em> transitory</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_transitory" title="Permalink to this definition">¶</a></dt>
<dd><p>Lose or retain GPIO state on suspend or reset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>descriptor of the GPIO for which to configure persistence</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">transitory</span></code></dt><dd><p>True to lose state on suspend or reset, false for persistence</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, otherwise a negative error code.</p>
</div>
<dl class="function">
<dt id="c.gpiod_is_active_low">
int <code class="sig-name descname">gpiod_is_active_low</code><span class="sig-paren">(</span>const struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_is_active_low" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether a GPIO is active-low or not</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the gpio descriptor to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 1 if the GPIO is active-low, 0 otherwise.</p>
</div>
<dl class="function">
<dt id="c.gpiod_toggle_active_low">
void <code class="sig-name descname">gpiod_toggle_active_low</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_toggle_active_low" title="Permalink to this definition">¶</a></dt>
<dd><p>toggle whether a GPIO is active-low or not</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>the gpio descriptor to change</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiod_get_raw_value">
int <code class="sig-name descname">gpiod_get_raw_value</code><span class="sig-paren">(</span>const struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_value" title="Permalink to this definition">¶</a></dt>
<dd><p>return a gpio’s raw value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>gpio whose value will be returned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO’s raw value, i.e. the value of the physical line disregarding
its ACTIVE_LOW status, or negative errno on failure.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_value">
int <code class="sig-name descname">gpiod_get_value</code><span class="sig-paren">(</span>const struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>return a gpio’s value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>gpio whose value will be returned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO’s logical value, i.e. taking the ACTIVE_LOW status into
account, or negative errno on failure.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_raw_array_value">
int <code class="sig-name descname">gpiod_get_raw_array_value</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc<em> **desc_array</em>, struct gpio_array<em> *array_info</em>, unsigned long<em> *value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_array_value" title="Permalink to this definition">¶</a></dt>
<dd><p>read raw values from an array of GPIOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*value_bitmap</span></code></dt><dd><p>bitmap to store the read values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.  Return 0 in case of success,
else an error code.</p>
<p>This function can be called from contexts where we cannot sleep,
and it will complain if the GPIO chip functions potentially sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_array_value">
int <code class="sig-name descname">gpiod_get_array_value</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc<em> **desc_array</em>, struct gpio_array<em> *array_info</em>, unsigned long<em> *value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array_value" title="Permalink to this definition">¶</a></dt>
<dd><p>read values from an array of GPIOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*value_bitmap</span></code></dt><dd><p>bitmap to store the read values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.  Return 0 in case of success, else an error code.</p>
<p>This function can be called from contexts where we cannot sleep,
and it will complain if the GPIO chip functions potentially sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_set_raw_value">
void <code class="sig-name descname">gpiod_set_raw_value</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_value" title="Permalink to this definition">¶</a></dt>
<dd><p>assign a gpio’s raw value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>gpio whose value will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw value of the GPIO, i.e. the value of its physical line without
regard for its ACTIVE_LOW status.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_set_value">
void <code class="sig-name descname">gpiod_set_value</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_value" title="Permalink to this definition">¶</a></dt>
<dd><p>assign a gpio’s value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>gpio whose value will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical value of the GPIO, i.e. taking its ACTIVE_LOW,
OPEN_DRAIN and OPEN_SOURCE flags into account.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_set_raw_array_value">
int <code class="sig-name descname">gpiod_set_raw_array_value</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc<em> **desc_array</em>, struct gpio_array<em> *array_info</em>, unsigned long<em> *value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_array_value" title="Permalink to this definition">¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*value_bitmap</span></code></dt><dd><p>bitmap of values to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_set_array_value">
int <code class="sig-name descname">gpiod_set_array_value</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc<em> **desc_array</em>, struct gpio_array<em> *array_info</em>, unsigned long<em> *value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_array_value" title="Permalink to this definition">¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*value_bitmap</span></code></dt><dd><p>bitmap of values to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.</p>
<p>This function can be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_cansleep">
int <code class="sig-name descname">gpiod_cansleep</code><span class="sig-paren">(</span>const struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>report whether gpio value access may sleep</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>gpio to check</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiod_set_consumer_name">
int <code class="sig-name descname">gpiod_set_consumer_name</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_consumer_name" title="Permalink to this definition">¶</a></dt>
<dd><p>set the consumer name for the descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>gpio to set the consumer name on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the new consumer name</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiod_to_irq">
int <code class="sig-name descname">gpiod_to_irq</code><span class="sig-paren">(</span>const struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_to_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>return the IRQ corresponding to a GPIO</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>gpio whose IRQ will be returned (already requested)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the IRQ corresponding to the passed GPIO, or an error code in case of
error.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_lock_as_irq">
int <code class="sig-name descname">gpiochip_lock_as_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_lock_as_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>lock a GPIO to be used as IRQ</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>the chip the GPIO to lock belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>the offset of the GPIO to lock as IRQ</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used directly by GPIO drivers that want to lock down
a certain GPIO line to be used for IRQs.</p>
</div>
<dl class="function">
<dt id="c.gpiochip_unlock_as_irq">
void <code class="sig-name descname">gpiochip_unlock_as_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_unlock_as_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock a GPIO used as IRQ</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>the chip the GPIO to lock belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>the offset of the GPIO to lock as IRQ</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used directly by GPIO drivers that want to indicate
that a certain GPIO is no longer used exclusively for IRQ.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_raw_value_cansleep">
int <code class="sig-name descname">gpiod_get_raw_value_cansleep</code><span class="sig-paren">(</span>const struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>return a gpio’s raw value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>gpio whose value will be returned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO’s raw value, i.e. the value of the physical line disregarding
its ACTIVE_LOW status, or negative errno on failure.</p>
<p>This function is to be called from contexts that can sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_value_cansleep">
int <code class="sig-name descname">gpiod_get_value_cansleep</code><span class="sig-paren">(</span>const struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>return a gpio’s value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>gpio whose value will be returned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO’s logical value, i.e. taking the ACTIVE_LOW status into
account, or negative errno on failure.</p>
<p>This function is to be called from contexts that can sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_raw_array_value_cansleep">
int <code class="sig-name descname">gpiod_get_raw_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc<em> **desc_array</em>, struct gpio_array<em> *array_info</em>, unsigned long<em> *value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_array_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>read raw values from an array of GPIOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*value_bitmap</span></code></dt><dd><p>bitmap to store the read values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.  Return 0 in case of success,
else an error code.</p>
<p>This function is to be called from contexts that can sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_array_value_cansleep">
int <code class="sig-name descname">gpiod_get_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc<em> **desc_array</em>, struct gpio_array<em> *array_info</em>, unsigned long<em> *value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>read values from an array of GPIOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*value_bitmap</span></code></dt><dd><p>bitmap to store the read values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.  Return 0 in case of success, else an error code.</p>
<p>This function is to be called from contexts that can sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_set_raw_value_cansleep">
void <code class="sig-name descname">gpiod_set_raw_value_cansleep</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>assign a gpio’s raw value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>gpio whose value will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw value of the GPIO, i.e. the value of its physical line without
regard for its ACTIVE_LOW status.</p>
<p>This function is to be called from contexts that can sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_set_value_cansleep">
void <code class="sig-name descname">gpiod_set_value_cansleep</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>assign a gpio’s value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>gpio whose value will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>value to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical value of the GPIO, i.e. taking its ACTIVE_LOW status into
account</p>
<p>This function is to be called from contexts that can sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_set_raw_array_value_cansleep">
int <code class="sig-name descname">gpiod_set_raw_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc<em> **desc_array</em>, struct gpio_array<em> *array_info</em>, unsigned long<em> *value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_array_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*value_bitmap</span></code></dt><dd><p>bitmap of values to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.</p>
<p>This function is to be called from contexts that can sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_set_array_value_cansleep">
int <code class="sig-name descname">gpiod_set_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em> array_size</em>, struct gpio_desc<em> **desc_array</em>, struct gpio_array<em> *array_info</em>, unsigned long<em> *value_bitmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_array_value_cansleep" title="Permalink to this definition">¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt><dd><p>number of elements in the descriptor array / value bitmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**desc_array</span></code></dt><dd><p>array of GPIO descriptors whose values will be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_array</span> <span class="pre">*array_info</span></code></dt><dd><p>information on applicability of fast bitmap processing path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*value_bitmap</span></code></dt><dd><p>bitmap of values to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.</p>
<p>This function is to be called from contexts that can sleep.</p>
</div>
<dl class="function">
<dt id="c.gpiod_add_lookup_table">
void <code class="sig-name descname">gpiod_add_lookup_table</code><span class="sig-paren">(</span>struct gpiod_lookup_table<em> *table</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_add_lookup_table" title="Permalink to this definition">¶</a></dt>
<dd><p>register GPIO device consumers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpiod_lookup_table</span> <span class="pre">*table</span></code></dt><dd><p>table of consumers to register</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiod_remove_lookup_table">
void <code class="sig-name descname">gpiod_remove_lookup_table</code><span class="sig-paren">(</span>struct gpiod_lookup_table<em> *table</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_remove_lookup_table" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister GPIO device consumers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpiod_lookup_table</span> <span class="pre">*table</span></code></dt><dd><p>table of consumers to unregister</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiod_add_hogs">
void <code class="sig-name descname">gpiod_add_hogs</code><span class="sig-paren">(</span>struct gpiod_hog<em> *hogs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_add_hogs" title="Permalink to this definition">¶</a></dt>
<dd><p>register a set of GPIO hogs from machine code</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpiod_hog</span> <span class="pre">*hogs</span></code></dt><dd><p>table of gpio hog entries with a zeroed sentinel at the end</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.fwnode_gpiod_get_index">
struct gpio_desc * <code class="sig-name descname">fwnode_gpiod_get_index</code><span class="sig-paren">(</span>struct fwnode_handle<em> *fwnode</em>, const char<em> *con_id</em>, int<em> index</em>, enum gpiod_flags<em> flags</em>, const char<em> *label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fwnode_gpiod_get_index" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a GPIO from firmware node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>handle of the firmware node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain for the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>GPIO initialization flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*label</span></code></dt><dd><p>label to attach to the requested GPIO</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used for drivers that get their configuration
from opaque firmware.</p>
<p>The function properly finds the corresponding GPIO using whatever is the
underlying firmware interface and then makes sure that the GPIO
descriptor is requested before it is returned to the caller.</p>
<p>In case of error an ERR_PTR() is returned.</p>
<p><strong>Return</strong></p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>flags</strong>.</p>
</div>
<dl class="function">
<dt id="c.gpiod_count">
int <code class="sig-name descname">gpiod_count</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_count" title="Permalink to this definition">¶</a></dt>
<dd><p>return the number of GPIOs associated with a device / function or -ENOENT if no GPIO has been assigned to the requested function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gpiod_get">
struct gpio_desc * <code class="sig-name descname">gpiod_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a GPIO for a given GPIO function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO descriptor corresponding to the function con_id of device
dev, -ENOENT if no GPIO has been assigned to the requested function, or
another IS_ERR() code if an error occurred while trying to acquire the GPIO.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_optional">
struct gpio_desc * <code class="sig-name descname">gpiod_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an optional GPIO for a given GPIO function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent to <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a>, except that when no GPIO was assigned to
the requested function it will return NULL. This is convenient for drivers
that need to handle optional GPIOs.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_index">
struct gpio_desc * <code class="sig-name descname">gpiod_get_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, unsigned int<em> idx</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_index" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a GPIO from a multi-index GPIO function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>index of the GPIO to obtain in the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant of <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a> allows to access GPIOs other than the first
defined one for functions that define several GPIOs.</p>
<p>Return a valid GPIO descriptor, -ENOENT if no GPIO has been assigned to the
requested function and/or index, or another IS_ERR() code if an error
occurred while trying to acquire the GPIO.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_index_optional">
struct gpio_desc * <code class="sig-name descname">gpiod_get_index_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, unsigned int<em> index</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_index_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an optional GPIO from a multi-index GPIO function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain in the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent to <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index()</span></code></a>, except that when no GPIO with the
specified index was assigned to the requested function it will return NULL.
This is convenient for drivers that need to handle optional GPIOs.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_array">
struct gpio_descs * <code class="sig-name descname">gpiod_get_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain multiple GPIOs from a multi-index GPIO function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function acquires all the GPIOs defined under a given function.</p>
<p>Return a struct gpio_descs containing an array of descriptors, -ENOENT if
no GPIO has been assigned to the requested function, or another IS_ERR()
code if an error occurred while trying to acquire the GPIOs.</p>
</div>
<dl class="function">
<dt id="c.gpiod_get_array_optional">
struct gpio_descs * <code class="sig-name descname">gpiod_get_array_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain multiple GPIOs from a multi-index GPIO function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer, can be NULL for system-global GPIOs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent to <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a>, except that when no GPIO was
assigned to the requested function it will return NULL.</p>
</div>
<dl class="function">
<dt id="c.gpiod_put">
void <code class="sig-name descname">gpiod_put</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_put" title="Permalink to this definition">¶</a></dt>
<dd><p>dispose of a GPIO descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO descriptor to dispose of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>No descriptor can be used after <a class="reference internal" href="#c.gpiod_put" title="gpiod_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_put()</span></code></a> has been called on it.</p>
</div>
<dl class="function">
<dt id="c.gpiod_put_array">
void <code class="sig-name descname">gpiod_put_array</code><span class="sig-paren">(</span>struct gpio_descs<em> *descs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_put_array" title="Permalink to this definition">¶</a></dt>
<dd><p>dispose of multiple GPIO descriptors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_descs</span> <span class="pre">*descs</span></code></dt><dd><p>struct gpio_descs containing an array of descriptors</p>
</dd>
</dl>
</div>
</section>
<section id="acpi-support">
<h2>ACPI support<a class="headerlink" href="#acpi-support" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.acpi_get_and_request_gpiod">
struct gpio_desc * <code class="sig-name descname">acpi_get_and_request_gpiod</code><span class="sig-paren">(</span>char<em> *path</em>, unsigned int<em> pin</em>, char<em> *label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_get_and_request_gpiod" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate ACPI GPIO pin to GPIO descriptor and hold a refcount to the GPIO device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*path</span></code></dt><dd><p>ACPI GPIO controller full path name, (e.g. “\_SB.GPO1”)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pin</span></code></dt><dd><p>ACPI GPIO pin number (0-based, controller-relative)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*label</span></code></dt><dd><p>Label to pass to gpiod_request()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a simple pass-through to acpi_get_gpiod(), except that
as it is intended for use outside of the GPIO layer (in a similar fashion to
<a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index()</span></code></a> for example) it also holds a reference to the GPIO device.</p>
</div>
<dl class="function">
<dt id="c.acpi_gpio_get_io_resource">
bool <code class="sig-name descname">acpi_gpio_get_io_resource</code><span class="sig-paren">(</span>struct acpi_resource<em> *ares</em>, struct acpi_resource_gpio<em> **agpio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_gpio_get_io_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch details of an ACPI resource if it is a GPIO I/O resource or return False if not.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">acpi_resource</span> <span class="pre">*ares</span></code></dt><dd><p>Pointer to the ACPI resource to fetch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">acpi_resource_gpio</span> <span class="pre">**agpio</span></code></dt><dd><p>Pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">acpi_resource_gpio</span></code> to store the output pointer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.acpi_gpiochip_request_interrupts">
void <code class="sig-name descname">acpi_gpiochip_request_interrupts</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_gpiochip_request_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>Register isr for gpio chip ACPI events</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*chip</span></code></dt><dd><p>GPIO chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
handled by ACPI event methods which need to be called from the GPIO
chip’s interrupt handler. <a class="reference internal" href="#c.acpi_gpiochip_request_interrupts" title="acpi_gpiochip_request_interrupts"><code class="xref c c-func docutils literal notranslate"><span class="pre">acpi_gpiochip_request_interrupts()</span></code></a> finds out which
GPIO pins have ACPI event methods and assigns interrupt handlers that calls
the ACPI event methods for those pins.</p>
</div>
<dl class="function">
<dt id="c.acpi_gpiochip_free_interrupts">
void <code class="sig-name descname">acpi_gpiochip_free_interrupts</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_gpiochip_free_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>Free GPIO ACPI event interrupts.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*chip</span></code></dt><dd><p>GPIO chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free interrupts associated with GPIO ACPI event method for the given
GPIO chip.</p>
</div>
<dl class="function">
<dt id="c.acpi_dev_gpio_irq_wake_get_by">
int <code class="sig-name descname">acpi_dev_gpio_irq_wake_get_by</code><span class="sig-paren">(</span>struct acpi_device<em> *adev</em>, const char<em> *name</em>, int<em> index</em>, bool<em> *wake_capable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_dev_gpio_irq_wake_get_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Find GpioInt and translate it to Linux IRQ number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">acpi_device</span> <span class="pre">*adev</span></code></dt><dd><p>pointer to a ACPI device to get IRQ from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>optional name of GpioInt resource</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of GpioInt resource (starting from <code class="docutils literal notranslate"><span class="pre">0</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*wake_capable</span></code></dt><dd><p>Set to true if the IRQ is wake capable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the device has one or more GpioInt resources, this function can be
used to translate from the GPIO offset in the resource to the Linux IRQ
number.</p>
<p>The function is idempotent, though each time it runs it will configure GPIO
pin direction according to the flags in GpioInt resource.</p>
<p>The function takes optional <strong>name</strong> parameter. If the resource has a property
name, then only those will be taken into account.</p>
<p>The GPIO is considered wake capable if the GpioInt resource specifies
SharedAndWake or ExclusiveAndWake.</p>
<p><strong>Return</strong></p>
<p>Linux IRQ number (&gt; <code class="docutils literal notranslate"><span class="pre">0</span></code>) on success, negative errno on failure.</p>
</div>
</section>
<section id="device-tree-support">
<h2>Device tree support<a class="headerlink" href="#device-tree-support" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.gpiod_get_from_of_node">
struct gpio_desc * <code class="sig-name descname">gpiod_get_from_of_node</code><span class="sig-paren">(</span>const struct device_node<em> *node</em>, const char<em> *propname</em>, int<em> index</em>, enum gpiod_flags<em> dflags</em>, const char<em> *label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_from_of_node" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a GPIO from an OF node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt><dd><p>handle of the OF node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt><dd><p>name of the DT property representing the GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain for the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">dflags</span></code></dt><dd><p>GPIO initialization flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*label</span></code></dt><dd><p>label to attach to the requested GPIO</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>dflags</strong>.</p>
<p><strong>Description</strong></p>
<p>In case of error an ERR_PTR() is returned.</p>
</div>
<dl class="function">
<dt id="c.of_mm_gpiochip_add_data">
int <code class="sig-name descname">of_mm_gpiochip_add_data</code><span class="sig-paren">(</span>struct device_node<em> *np</em>, struct of_mm_gpio_chip<em> *mm_gc</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_mm_gpiochip_add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Add memory mapped GPIO chip (bank)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>device node of the GPIO chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_mm_gpio_chip</span> <span class="pre">*mm_gc</span></code></dt><dd><p>pointer to the of_mm_gpio_chip allocated structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>driver data to store in the <a class="reference internal" href="#c.gpio_chip" title="gpio_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>To use this function you should allocate and fill mm_gc with:</p>
<ol class="arabic simple">
<li><p>In the gpio_chip structure:
- all the callbacks
- of_gpio_n_cells
- of_xlate callback (optional)</p></li>
</ol>
<ol class="arabic simple" start="3">
<li><p>In the of_mm_gpio_chip structure:
- save_regs callback (optional)</p></li>
</ol>
<p>If succeeded, this function will map bank’s memory and will
do all necessary work for you. Then you’ll able to use .regs
to manage GPIOs from the callbacks.</p>
</div>
<dl class="function">
<dt id="c.of_mm_gpiochip_remove">
void <code class="sig-name descname">of_mm_gpiochip_remove</code><span class="sig-paren">(</span>struct of_mm_gpio_chip<em> *mm_gc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_mm_gpiochip_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove memory mapped GPIO chip (bank)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">of_mm_gpio_chip</span> <span class="pre">*mm_gc</span></code></dt><dd><p>pointer to the of_mm_gpio_chip allocated structure</p>
</dd>
</dl>
</div>
</section>
<section id="device-managed-api">
<h2>Device-managed API<a class="headerlink" href="#device-managed-api" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.devm_gpiod_get">
struct gpio_desc * <code class="sig-name descname">devm_gpiod_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a>. GPIO descriptors returned from this function are
automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get()</span></code></a> for detailed
information about behavior and return values.</p>
</div>
<dl class="function">
<dt id="c.devm_gpiod_get_optional">
struct gpio_desc * <code class="sig-name descname">devm_gpiod_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_optional" title="gpiod_get_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_optional()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_optional" title="gpiod_get_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_optional()</span></code></a>. GPIO descriptors returned from this function
are automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get_optional" title="gpiod_get_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_optional()</span></code></a> for
detailed information about behavior and return values.</p>
</div>
<dl class="function">
<dt id="c.devm_gpiod_get_index">
struct gpio_desc * <code class="sig-name descname">devm_gpiod_get_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, unsigned int<em> idx</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>index of the GPIO to obtain in the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index()</span></code></a>. GPIO descriptors returned from this function are
automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index()</span></code></a> for detailed
information about behavior and return values.</p>
</div>
<dl class="function">
<dt id="c.devm_gpiod_get_from_of_node">
struct gpio_desc * <code class="sig-name descname">devm_gpiod_get_from_of_node</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct device_node<em> *node</em>, const char<em> *propname</em>, int<em> index</em>, enum gpiod_flags<em> dflags</em>, const char<em> *label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_from_of_node" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a GPIO from an OF node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for lifecycle management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*node</span></code></dt><dd><p>handle of the OF node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*propname</span></code></dt><dd><p>name of the DT property representing the GPIO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain for the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">dflags</span></code></dt><dd><p>GPIO initialization flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*label</span></code></dt><dd><p>label to attach to the requested GPIO</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>dflags</strong>.</p>
<p><strong>Description</strong></p>
<p>In case of error an ERR_PTR() is returned.</p>
</div>
<dl class="function">
<dt id="c.devm_fwnode_gpiod_get_index">
struct gpio_desc * <code class="sig-name descname">devm_fwnode_gpiod_get_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct fwnode_handle<em> *fwnode</em>, const char<em> *con_id</em>, int<em> index</em>, enum gpiod_flags<em> flags</em>, const char<em> *label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_fwnode_gpiod_get_index" title="Permalink to this definition">¶</a></dt>
<dd><p>get a GPIO descriptor from a given node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>firmware node containing GPIO reference</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain in the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>GPIO initialization flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*label</span></code></dt><dd><p>label to attach to the requested GPIO</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>GPIO descriptors returned from this function are automatically disposed on
driver detach.</p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>flags</strong>.</p>
</div>
<dl class="function">
<dt id="c.devm_gpiod_get_index_optional">
struct gpio_desc * <code class="sig-name descname">devm_gpiod_get_index_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, unsigned int<em> index</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_index_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_index_optional" title="gpiod_get_index_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index_optional()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>index of the GPIO to obtain in the consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_index_optional" title="gpiod_get_index_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index_optional()</span></code></a>. GPIO descriptors returned from this
function are automatically disposed on driver detach. See
<a class="reference internal" href="#c.gpiod_get_index_optional" title="gpiod_get_index_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_index_optional()</span></code></a> for detailed information about behavior and
return values.</p>
</div>
<dl class="function">
<dt id="c.devm_gpiod_get_array">
struct gpio_descs * <code class="sig-name descname">devm_gpiod_get_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a>. GPIO descriptors returned from this function are
automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array()</span></code></a> for detailed
information about behavior and return values.</p>
</div>
<dl class="function">
<dt id="c.devm_gpiod_get_array_optional">
struct gpio_descs * <code class="sig-name descname">devm_gpiod_get_array_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em>, enum gpiod_flags<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_array_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_array_optional" title="gpiod_get_array_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array_optional()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>function within the GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt><dd><p>optional GPIO initialization flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_array_optional" title="gpiod_get_array_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array_optional()</span></code></a>. GPIO descriptors returned from this
function are automatically disposed on driver detach.
See <a class="reference internal" href="#c.gpiod_get_array_optional" title="gpiod_get_array_optional"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_get_array_optional()</span></code></a> for detailed information about behavior and
return values.</p>
</div>
<dl class="function">
<dt id="c.devm_gpiod_put">
void <code class="sig-name descname">devm_gpiod_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_put" title="gpiod_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_put()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO descriptor to dispose of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dispose of a GPIO descriptor obtained with <a class="reference internal" href="#c.devm_gpiod_get" title="devm_gpiod_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_gpiod_get()</span></code></a> or
<a class="reference internal" href="#c.devm_gpiod_get_index" title="devm_gpiod_get_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_gpiod_get_index()</span></code></a>. Normally this function will not be called as the GPIO
will be disposed of by the resource management code.</p>
</div>
<dl class="function">
<dt id="c.devm_gpiod_unhinge">
void <code class="sig-name descname">devm_gpiod_unhinge</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_unhinge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove resource management from a gpio descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO descriptor to remove resource management from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove resource management from a GPIO descriptor. This is needed when
you want to hand over lifecycle management of a descriptor to another
mechanism.</p>
</div>
<dl class="function">
<dt id="c.devm_gpiod_put_array">
void <code class="sig-name descname">devm_gpiod_put_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct gpio_descs<em> *descs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_put_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_put_array" title="gpiod_put_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_put_array()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>GPIO consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_descs</span> <span class="pre">*descs</span></code></dt><dd><p>GPIO descriptor array to dispose of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dispose of an array of GPIO descriptors obtained with <a class="reference internal" href="#c.devm_gpiod_get_array" title="devm_gpiod_get_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_gpiod_get_array()</span></code></a>.
Normally this function will not be called as the GPIOs will be disposed of
by the resource management code.</p>
</div>
<dl class="function">
<dt id="c.devm_gpio_request">
int <code class="sig-name descname">devm_gpio_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, unsigned<em> gpio</em>, const char<em> *label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpio_request" title="Permalink to this definition">¶</a></dt>
<dd><p>request a GPIO for a managed device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to request the GPIO for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">gpio</span></code></dt><dd><p>GPIO to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*label</span></code></dt><dd><p>the name of the requested GPIO</p>
<p>Except for the extra <strong>dev</strong> argument, this function takes the
same arguments and performs the same function as
gpio_request().  GPIOs requested with this function will be
automatically freed on driver detach.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.devm_gpio_request_one">
int <code class="sig-name descname">devm_gpio_request_one</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, unsigned<em> gpio</em>, unsigned long<em> flags</em>, const char<em> *label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpio_request_one" title="Permalink to this definition">¶</a></dt>
<dd><p>request a single GPIO with initial setup</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to request for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">gpio</span></code></dt><dd><p>the GPIO number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>GPIO configuration as specified by GPIOF_*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*label</span></code></dt><dd><p>a literal description string of this GPIO</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.devm_gpiochip_add_data_with_key">
int <code class="sig-name descname">devm_gpiochip_add_data_with_key</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em> *gc</em>, void<em> *data</em>, struct lock_class_key<em> *lock_key</em>, struct lock_class_key<em> *request_key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiochip_add_data_with_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource managed gpiochip_add_data_with_key()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the device that gpio_chip belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*gc</span></code></dt><dd><p>the GPIO chip to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>driver-private data associated with this chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*lock_key</span></code></dt><dd><p>lockdep class for IRQ lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*request_key</span></code></dt><dd><p>lockdep class for IRQ request</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>potentially before irqs will work</p>
<p><strong>Description</strong></p>
<p>The gpio chip automatically be released when the device is unbound.</p>
<p><strong>Return</strong></p>
<p>A negative errno if the chip can’t be registered, such as because the
gc-&gt;base is invalid or already associated with a different chip.
Otherwise it returns zero as a success code.</p>
</div>
</section>
<section id="sysfs-helpers">
<h2>sysfs helpers<a class="headerlink" href="#sysfs-helpers" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.gpiod_export">
int <code class="sig-name descname">gpiod_export</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em>, bool<em> direction_may_change</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_export" title="Permalink to this definition">¶</a></dt>
<dd><p>export a GPIO through sysfs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO to make available, already requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">direction_may_change</span></code></dt><dd><p>true if userspace may change GPIO direction</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>arch_initcall or later</p>
<p><strong>Description</strong></p>
<p>When drivers want to make a GPIO accessible to userspace after they
have requested it – perhaps while debugging, or as part of their
public interface – they may use this routine.  If the GPIO can
change direction (some can’t) and the caller allows it, userspace
will see “direction” sysfs attribute which may be used to change
the gpio’s direction.  A “value” attribute will always be provided.</p>
<p>Returns zero on success, else an error.</p>
</div>
<dl class="function">
<dt id="c.gpiod_export_link">
int <code class="sig-name descname">gpiod_export_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *name</em>, struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_export_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create a sysfs link to an exported GPIO node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device under which to create symlink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the symlink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO to create symlink to, already exported</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up a symlink from /sys/…/dev/name to /sys/class/gpio/gpioN
node. Caller is responsible for unlinking.</p>
<p>Returns zero on success, else an error.</p>
</div>
<dl class="function">
<dt id="c.gpiod_unexport">
void <code class="sig-name descname">gpiod_unexport</code><span class="sig-paren">(</span>struct gpio_desc<em> *desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_unexport" title="Permalink to this definition">¶</a></dt>
<dd><p>reverse effect of <a class="reference internal" href="#c.gpiod_export" title="gpiod_export"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_export()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*desc</span></code></dt><dd><p>GPIO to make unavailable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is implicit on gpiod_free().</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">General Purpose Input/Output (GPIO)</a><ul>
<li><a class="reference internal" href="#core">Core</a></li>
<li><a class="reference internal" href="#acpi-support">ACPI support</a></li>
<li><a class="reference internal" href="#device-tree-support">Device tree support</a></li>
<li><a class="reference internal" href="#device-managed-api">Device-managed API</a></li>
<li><a class="reference internal" href="#sysfs-helpers">sysfs helpers</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/gpio/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/gpio/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>