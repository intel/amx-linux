
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>GPIO Driver Interface &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="GPIO Descriptor Consumer Interface" href="consumer.html" />
    <link rel="prev" title="Using GPIO Lines in Linux" href="using-gpio.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="gpio-driver-interface">
<h1>GPIO Driver Interface<a class="headerlink" href="#gpio-driver-interface" title="Permalink to this headline">¶</a></h1>
<p>This document serves as a guide for writers of GPIO chip drivers.</p>
<p>Each GPIO controller driver needs to include the following header, which defines
the structures used to define a GPIO driver:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/gpio/driver.h&gt;
</pre></div>
</div>
<section id="internal-representation-of-gpios">
<h2>Internal Representation of GPIOs<a class="headerlink" href="#internal-representation-of-gpios" title="Permalink to this headline">¶</a></h2>
<p>A GPIO chip handles one or more GPIO lines. To be considered a GPIO chip, the
lines must conform to the definition: General Purpose Input/Output. If the
line is not general purpose, it is not GPIO and should not be handled by a
GPIO chip. The use case is the indicative: certain lines in a system may be
called GPIO but serve a very particular purpose thus not meeting the criteria
of a general purpose I/O. On the other hand a LED driver line may be used as a
GPIO and should therefore still be handled by a GPIO chip driver.</p>
<p>Inside a GPIO driver, individual GPIO lines are identified by their hardware
number, sometime also referred to as <code class="docutils literal notranslate"><span class="pre">offset</span></code>, which is a unique number
between 0 and n-1, n being the number of GPIOs managed by the chip.</p>
<p>The hardware GPIO number should be something intuitive to the hardware, for
example if a system uses a memory-mapped set of I/O-registers where 32 GPIO
lines are handled by one bit per line in a 32-bit register, it makes sense to
use hardware offsets 0..31 for these, corresponding to bits 0..31 in the
register.</p>
<p>This number is purely internal: the hardware number of a particular GPIO
line is never made visible outside of the driver.</p>
<p>On top of this internal number, each GPIO line also needs to have a global
number in the integer GPIO namespace so that it can be used with the legacy GPIO
interface. Each chip must thus have a “base” number (which can be automatically
assigned), and for each GPIO line the global number will be (base + hardware
number). Although the integer representation is considered deprecated, it still
has many users and thus needs to be maintained.</p>
<p>So for example one platform could use global numbers 32-159 for GPIOs, with a
controller defining 128 GPIOs at a “base” of 32 ; while another platform uses
global numbers 0..63 with one set of GPIO controllers, 64-79 with another type
of GPIO controller, and on one particular board 80-95 with an FPGA. The legacy
numbers need not be contiguous; either of those platforms could also use numbers
2000-2063 to identify GPIO lines in a bank of I2C GPIO expanders.</p>
</section>
<section id="controller-drivers-gpio-chip">
<h2>Controller Drivers: gpio_chip<a class="headerlink" href="#controller-drivers-gpio-chip" title="Permalink to this headline">¶</a></h2>
<p>In the gpiolib framework each GPIO controller is packaged as a “<a class="reference internal" href="index.html#c.gpio_chip" title="gpio_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">gpio_chip</span></code></a>” (see &lt;linux/gpio/driver.h&gt; for its complete definition) with members
common to each controller of that type, these should be assigned by the
driver code:</p>
<blockquote>
<div><ul class="simple">
<li><p>methods to establish GPIO line direction</p></li>
<li><p>methods used to access GPIO line values</p></li>
<li><p>method to set electrical configuration for a given GPIO line</p></li>
<li><p>method to return the IRQ number associated to a given GPIO line</p></li>
<li><p>flag saying whether calls to its methods may sleep</p></li>
<li><p>optional line names array to identify lines</p></li>
<li><p>optional debugfs dump method (showing extra state information)</p></li>
<li><p>optional base number (will be automatically assigned if omitted)</p></li>
<li><p>optional label for diagnostics and GPIO chip mapping using platform data</p></li>
</ul>
</div></blockquote>
<p>The code implementing a gpio_chip should support multiple instances of the
controller, preferably using the driver model. That code will configure each
gpio_chip and issue gpiochip_add(), <a class="reference internal" href="index.html#c.gpiochip_add_data" title="gpiochip_add_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_add_data()</span></code></a>, or
devm_gpiochip_add_data().  Removing a GPIO controller should be rare; use
<a class="reference internal" href="index.html#c.gpiochip_remove" title="gpiochip_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_remove()</span></code></a> when it is unavoidable.</p>
<p>Often a gpio_chip is part of an instance-specific structure with states not
exposed by the GPIO interfaces, such as addressing, power management, and more.
Chips such as audio codecs will have complex non-GPIO states.</p>
<p>Any debugfs dump method should normally ignore lines which haven’t been
requested. They can use <a class="reference internal" href="index.html#c.gpiochip_is_requested" title="gpiochip_is_requested"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_is_requested()</span></code></a>, which returns either
NULL or the label associated with that GPIO line when it was requested.</p>
<p>Realtime considerations: the GPIO driver should not use spinlock_t or any
sleepable APIs (like PM runtime) in its gpio_chip implementation (.get/.set
and direction control callbacks) if it is expected to call GPIO APIs from
atomic context on realtime kernels (inside hard IRQ handlers and similar
contexts). Normally this should not be required.</p>
<section id="gpio-electrical-configuration">
<h3>GPIO electrical configuration<a class="headerlink" href="#gpio-electrical-configuration" title="Permalink to this headline">¶</a></h3>
<p>GPIO lines can be configured for several electrical modes of operation by using
the .set_config() callback. Currently this API supports setting:</p>
<ul class="simple">
<li><p>Debouncing</p></li>
<li><p>Single-ended modes (open drain/open source)</p></li>
<li><p>Pull up and pull down resistor enablement</p></li>
</ul>
<p>These settings are described below.</p>
<p>The .set_config() callback uses the same enumerators and configuration
semantics as the generic pin control drivers. This is not a coincidence: it is
possible to assign the .set_config() to the function <a class="reference internal" href="index.html#c.gpiochip_generic_config" title="gpiochip_generic_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_generic_config()</span></code></a>
which will result in pinctrl_gpio_set_config() being called and eventually
ending up in the pin control back-end “behind” the GPIO controller, usually
closer to the actual pins. This way the pin controller can manage the below
listed GPIO configurations.</p>
<p>If a pin controller back-end is used, the GPIO controller or hardware
description needs to provide “GPIO ranges” mapping the GPIO line offsets to pin
numbers on the pin controller so they can properly cross-reference each other.</p>
</section>
<section id="gpio-lines-with-debounce-support">
<h3>GPIO lines with debounce support<a class="headerlink" href="#gpio-lines-with-debounce-support" title="Permalink to this headline">¶</a></h3>
<p>Debouncing is a configuration set to a pin indicating that it is connected to
a mechanical switch or button, or similar that may bounce. Bouncing means the
line is pulled high/low quickly at very short intervals for mechanical
reasons. This can result in the value being unstable or irqs firing repeatedly
unless the line is debounced.</p>
<p>Debouncing in practice involves setting up a timer when something happens on
the line, wait a little while and then sample the line again, so see if it
still has the same value (low or high). This could also be repeated by a clever
state machine, waiting for a line to become stable. In either case, it sets
a certain number of milliseconds for debouncing, or just “on/off” if that time
is not configurable.</p>
</section>
<section id="gpio-lines-with-open-drain-source-support">
<h3>GPIO lines with open drain/source support<a class="headerlink" href="#gpio-lines-with-open-drain-source-support" title="Permalink to this headline">¶</a></h3>
<p>Open drain (CMOS) or open collector (TTL) means the line is not actively driven
high: instead you provide the drain/collector as output, so when the transistor
is not open, it will present a high-impedance (tristate) to the external rail:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CMOS CONFIGURATION      TTL CONFIGURATION

         ||--- out              +--- out
  in ----||                   |/
         ||--+         in ----|
             |                |\
            GND                 GND
</pre></div>
</div>
<p>This configuration is normally used as a way to achieve one of two things:</p>
<ul class="simple">
<li><p>Level-shifting: to reach a logical level higher than that of the silicon
where the output resides.</p></li>
<li><p>Inverse wire-OR on an I/O line, for example a GPIO line, making it possible
for any driving stage on the line to drive it low even if any other output
to the same line is simultaneously driving it high. A special case of this
is driving the SCL and SDA lines of an I2C bus, which is by definition a
wire-OR bus.</p></li>
</ul>
<p>Both use cases require that the line be equipped with a pull-up resistor. This
resistor will make the line tend to high level unless one of the transistors on
the rail actively pulls it down.</p>
<p>The level on the line will go as high as the VDD on the pull-up resistor, which
may be higher than the level supported by the transistor, achieving a
level-shift to the higher VDD.</p>
<p>Integrated electronics often have an output driver stage in the form of a CMOS
“totem-pole” with one N-MOS and one P-MOS transistor where one of them drives
the line high and one of them drives the line low. This is called a push-pull
output. The “totem-pole” looks like so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                 VDD
                  |
        OD    ||--+
     +--/ ---o||     P-MOS-FET
     |        ||--+
IN --+            +----- out
     |        ||--+
     +--/ ----||     N-MOS-FET
        OS    ||--+
                  |
                 GND
</pre></div>
</div>
<p>The desired output signal (e.g. coming directly from some GPIO output register)
arrives at IN. The switches named “OD” and “OS” are normally closed, creating
a push-pull circuit.</p>
<p>Consider the little “switches” named “OD” and “OS” that enable/disable the
P-MOS or N-MOS transistor right after the split of the input. As you can see,
either transistor will go totally numb if this switch is open. The totem-pole
is then halved and give high impedance instead of actively driving the line
high or low respectively. That is usually how software-controlled open
drain/source works.</p>
<p>Some GPIO hardware come in open drain / open source configuration. Some are
hard-wired lines that will only support open drain or open source no matter
what: there is only one transistor there. Some are software-configurable:
by flipping a bit in a register the output can be configured as open drain
or open source, in practice by flicking open the switches labeled “OD” and “OS”
in the drawing above.</p>
<p>By disabling the P-MOS transistor, the output can be driven between GND and
high impedance (open drain), and by disabling the N-MOS transistor, the output
can be driven between VDD and high impedance (open source). In the first case,
a pull-up resistor is needed on the outgoing rail to complete the circuit, and
in the second case, a pull-down resistor is needed on the rail.</p>
<p>Hardware that supports open drain or open source or both, can implement a
special callback in the gpio_chip: .set_config() that takes a generic
pinconf packed value telling whether to configure the line as open drain,
open source or push-pull. This will happen in response to the
GPIO_OPEN_DRAIN or GPIO_OPEN_SOURCE flag set in the machine file, or coming
from other hardware descriptions.</p>
<p>If this state can not be configured in hardware, i.e. if the GPIO hardware does
not support open drain/open source in hardware, the GPIO library will instead
use a trick: when a line is set as output, if the line is flagged as open
drain, and the IN output value is low, it will be driven low as usual. But
if the IN output value is set to high, it will instead <em>NOT</em> be driven high,
instead it will be switched to input, as input mode is high impedance, thus
achieving an “open drain emulation” of sorts: electrically the behaviour will
be identical, with the exception of possible hardware glitches when switching
the mode of the line.</p>
<p>For open source configuration the same principle is used, just that instead
of actively driving the line low, it is set to input.</p>
</section>
<section id="gpio-lines-with-pull-up-down-resistor-support">
<h3>GPIO lines with pull up/down resistor support<a class="headerlink" href="#gpio-lines-with-pull-up-down-resistor-support" title="Permalink to this headline">¶</a></h3>
<p>A GPIO line can support pull-up/down using the .set_config() callback. This
means that a pull up or pull-down resistor is available on the output of the
GPIO line, and this resistor is software controlled.</p>
<p>In discrete designs, a pull-up or pull-down resistor is simply soldered on
the circuit board. This is not something we deal with or model in software. The
most you will think about these lines is that they will very likely be
configured as open drain or open source (see the section above).</p>
<p>The .set_config() callback can only turn pull up or down on and off, and will
no have any semantic knowledge about the resistance used. It will only say
switch a bit in a register enabling or disabling pull-up or pull-down.</p>
<p>If the GPIO line supports shunting in different resistance values for the
pull-up or pull-down resistor, the GPIO chip callback .set_config() will not
suffice. For these complex use cases, a combined GPIO chip and pin controller
need to be implemented, as the pin config interface of a pin controller
supports more versatile control over electrical properties and can handle
different pull-up or pull-down resistance values.</p>
</section>
</section>
<section id="gpio-drivers-providing-irqs">
<h2>GPIO drivers providing IRQs<a class="headerlink" href="#gpio-drivers-providing-irqs" title="Permalink to this headline">¶</a></h2>
<p>It is custom that GPIO drivers (GPIO chips) are also providing interrupts,
most often cascaded off a parent interrupt controller, and in some special
cases the GPIO logic is melded with a SoC’s primary interrupt controller.</p>
<p>The IRQ portions of the GPIO block are implemented using an irq_chip, using
the header &lt;linux/irq.h&gt;. So this combined driver is utilizing two sub-
systems simultaneously: gpio and irq.</p>
<p>It is legal for any IRQ consumer to request an IRQ from any irqchip even if it
is a combined GPIO+IRQ driver. The basic premise is that gpio_chip and
irq_chip are orthogonal, and offering their services independent of each
other.</p>
<p><a class="reference internal" href="index.html#c.gpiod_to_irq" title="gpiod_to_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_to_irq()</span></code></a> is just a convenience function to figure out the IRQ for a
certain GPIO line and should not be relied upon to have been called before
the IRQ is used.</p>
<p>Always prepare the hardware and make it ready for action in respective
callbacks from the GPIO and irq_chip APIs. Do not rely on <a class="reference internal" href="index.html#c.gpiod_to_irq" title="gpiod_to_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiod_to_irq()</span></code></a> having
been called first.</p>
<p>We can divide GPIO irqchips in two broad categories:</p>
<ul class="simple">
<li><p>CASCADED INTERRUPT CHIPS: this means that the GPIO chip has one common
interrupt output line, which is triggered by any enabled GPIO line on that
chip. The interrupt output line will then be routed to an parent interrupt
controller one level up, in the most simple case the systems primary
interrupt controller. This is modeled by an irqchip that will inspect bits
inside the GPIO controller to figure out which line fired it. The irqchip
part of the driver needs to inspect registers to figure this out and it
will likely also need to acknowledge that it is handling the interrupt
by clearing some bit (sometime implicitly, by just reading a status
register) and it will often need to set up the configuration such as
edge sensitivity (rising or falling edge, or high/low level interrupt for
example).</p></li>
<li><p>HIERARCHICAL INTERRUPT CHIPS: this means that each GPIO line has a dedicated
irq line to a parent interrupt controller one level up. There is no need
to inquire the GPIO hardware to figure out which line has fired, but it
may still be necessary to acknowledge the interrupt and set up configuration
such as edge sensitivity.</p></li>
</ul>
<p>Realtime considerations: a realtime compliant GPIO driver should not use
spinlock_t or any sleepable APIs (like PM runtime) as part of its irqchip
implementation.</p>
<ul class="simple">
<li><p>spinlock_t should be replaced with raw_spinlock_t.[1]</p></li>
<li><p>If sleepable APIs have to be used, these can be done from the .irq_bus_lock()
and .irq_bus_unlock() callbacks, as these are the only slowpath callbacks
on an irqchip. Create the callbacks if needed.[2]</p></li>
</ul>
<section id="cascaded-gpio-irqchips">
<h3>Cascaded GPIO irqchips<a class="headerlink" href="#cascaded-gpio-irqchips" title="Permalink to this headline">¶</a></h3>
<p>Cascaded GPIO irqchips usually fall in one of three categories:</p>
<ul>
<li><p>CHAINED CASCADED GPIO IRQCHIPS: these are usually the type that is embedded on
an SoC. This means that there is a fast IRQ flow handler for the GPIOs that
gets called in a chain from the parent IRQ handler, most typically the
system interrupt controller. This means that the GPIO irqchip handler will
be called immediately from the parent irqchip, while holding the IRQs
disabled. The GPIO irqchip will then end up calling something like this
sequence in its interrupt handler:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static irqreturn_t foo_gpio_irq(int irq, void *data)
    chained_irq_enter(...);
    generic_handle_irq(...);
    chained_irq_exit(...);
</pre></div>
</div>
<p>Chained GPIO irqchips typically can NOT set the .can_sleep flag on
<a class="reference internal" href="index.html#c.gpio_chip" title="gpio_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span></code></a>, as everything happens directly in the callbacks: no
slow bus traffic like I2C can be used.</p>
<p>Realtime considerations: Note that chained IRQ handlers will not be forced
threaded on -RT. As a result, spinlock_t or any sleepable APIs (like PM
runtime) can’t be used in a chained IRQ handler.</p>
<p>If required (and if it can’t be converted to the nested threaded GPIO irqchip,
see below) a chained IRQ handler can be converted to generic irq handler and
this way it will become a threaded IRQ handler on -RT and a hard IRQ handler
on non-RT (for example, see [3]).</p>
<p>The <a class="reference internal" href="../../core-api/genericirq.html#c.generic_handle_irq" title="generic_handle_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_handle_irq()</span></code></a> is expected to be called with IRQ disabled,
so the IRQ core will complain if it is called from an IRQ handler which is
forced to a thread. The “fake?” raw lock can be used to work around this
problem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>raw_spinlock_t wa_lock;
static irqreturn_t omap_gpio_irq_handler(int irq, void *gpiobank)
    unsigned long wa_lock_flags;
    raw_spin_lock_irqsave(&amp;bank-&gt;wa_lock, wa_lock_flags);
    generic_handle_irq(irq_find_mapping(bank-&gt;chip.irq.domain, bit));
    raw_spin_unlock_irqrestore(&amp;bank-&gt;wa_lock, wa_lock_flags);
</pre></div>
</div>
</li>
<li><p>GENERIC CHAINED GPIO IRQCHIPS: these are the same as “CHAINED GPIO irqchips”,
but chained IRQ handlers are not used. Instead GPIO IRQs dispatching is
performed by generic IRQ handler which is configured using <a class="reference internal" href="../../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a>.
The GPIO irqchip will then end up calling something like this sequence in
its interrupt handler:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static irqreturn_t gpio_rcar_irq_handler(int irq, void *dev_id)
    for each detected GPIO IRQ
        generic_handle_irq(...);
</pre></div>
</div>
<p>Realtime considerations: this kind of handlers will be forced threaded on -RT,
and as result the IRQ core will complain that <a class="reference internal" href="../../core-api/genericirq.html#c.generic_handle_irq" title="generic_handle_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_handle_irq()</span></code></a> is called
with IRQ enabled and the same work-around as for “CHAINED GPIO irqchips” can
be applied.</p>
</li>
<li><p>NESTED THREADED GPIO IRQCHIPS: these are off-chip GPIO expanders and any
other GPIO irqchip residing on the other side of a sleeping bus such as I2C
or SPI.</p>
<p>Of course such drivers that need slow bus traffic to read out IRQ status and
similar, traffic which may in turn incur other IRQs to happen, cannot be
handled in a quick IRQ handler with IRQs disabled. Instead they need to spawn
a thread and then mask the parent IRQ line until the interrupt is handled
by the driver. The hallmark of this driver is to call something like
this in its interrupt handler:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static irqreturn_t foo_gpio_irq(int irq, void *data)
    ...
    handle_nested_irq(irq);
</pre></div>
</div>
<p>The hallmark of threaded GPIO irqchips is that they set the .can_sleep
flag on <a class="reference internal" href="index.html#c.gpio_chip" title="gpio_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span></code></a> to true, indicating that this chip may sleep
when accessing the GPIOs.</p>
<p>These kinds of irqchips are inherently realtime tolerant as they are
already set up to handle sleeping contexts.</p>
</li>
</ul>
</section>
<section id="infrastructure-helpers-for-gpio-irqchips">
<h3>Infrastructure helpers for GPIO irqchips<a class="headerlink" href="#infrastructure-helpers-for-gpio-irqchips" title="Permalink to this headline">¶</a></h3>
<p>To help out in handling the set-up and management of GPIO irqchips and the
associated irqdomain and resource allocation callbacks. These are activated
by selecting the Kconfig symbol GPIOLIB_IRQCHIP. If the symbol
IRQ_DOMAIN_HIERARCHY is also selected, hierarchical helpers will also be
provided. A big portion of overhead code will be managed by gpiolib,
under the assumption that your interrupts are 1-to-1-mapped to the
GPIO line index:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>GPIO line offset</p></th>
<th class="head"><p>Hardware IRQ</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>ngpio-1</p></td>
<td><p>ngpio-1</p></td>
</tr>
</tbody>
</table>
<p>If some GPIO lines do not have corresponding IRQs, the bitmask valid_mask
and the flag need_valid_mask in gpio_irq_chip can be used to mask off some
lines as invalid for associating with IRQs.</p>
<p>The preferred way to set up the helpers is to fill in the
<a class="reference internal" href="index.html#c.gpio_irq_chip" title="gpio_irq_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_irq_chip</span></code></a> inside <a class="reference internal" href="index.html#c.gpio_chip" title="gpio_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span></code></a> before adding the gpio_chip.
If you do this, the additional irq_chip will be set up by gpiolib at the
same time as setting up the rest of the GPIO functionality. The following
is a typical example of a chained cascaded interrupt handler using
the gpio_irq_chip. Note how the mask/unmask (or disable/enable) functions
call into the core gpiolib code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Typical state container */</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">my_gpio</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">gpio_chip</span><span class="w"> </span><span class="n">gc</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_gpio_mask_irq</span><span class="p">(</span><span class="k">struct</span> <span class="nc">irq_data</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">gpio_chip</span><span class="w"> </span><span class="o">*</span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">irq_hw_number_t</span><span class="w"> </span><span class="n">hwirq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irqd_to_hwirq</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Perform any necessary action to mask the interrupt,</span>
<span class="cm">     * and then call into the core code to synchronise the</span>
<span class="cm">     * state.</span>
<span class="cm">     */</span><span class="w"></span>

<span class="w">    </span><span class="n">gpiochip_disable_irq</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">hwirq</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_gpio_unmask_irq</span><span class="p">(</span><span class="k">struct</span> <span class="nc">irq_data</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">gpio_chip</span><span class="w"> </span><span class="o">*</span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">irq_hw_number_t</span><span class="w"> </span><span class="n">hwirq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irqd_to_hwirq</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">gpiochip_enable_irq</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">hwirq</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Perform any necessary action to unmask the interrupt,</span>
<span class="cm">     * after having called into the core code to synchronise</span>
<span class="cm">     * the state.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Statically populate the irqchip. Note that it is made const</span>
<span class="cm"> * (further indicated by the IRQCHIP_IMMUTABLE flag), and that</span>
<span class="cm"> * the GPIOCHIP_IRQ_RESOURCE_HELPER macro adds some extra</span>
<span class="cm"> * callbacks to the structure.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">irq_chip</span><span class="w"> </span><span class="n">my_gpio_irq_chip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_gpio_irq&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_ack</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_ack_irq</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_mask</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_mask_irq</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_unmask</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_unmask_irq</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_set_type</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_set_irq_type</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">IRQCHIP_IMMUTABLE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* Provide the gpio resource callbacks */</span><span class="w"></span>
<span class="w">    </span><span class="n">GPIOCHIP_IRQ_RESOURCE_HELPERS</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">;</span><span class="w"> </span><span class="cm">/* from platform etc */</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">my_gpio</span><span class="w"> </span><span class="o">*</span><span class="n">g</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">gpio_irq_chip</span><span class="w"> </span><span class="o">*</span><span class="n">girq</span><span class="p">;</span><span class="w"></span>

<span class="cm">/* Get a pointer to the gpio_irq_chip */</span><span class="w"></span>
<span class="n">girq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">irq</span><span class="p">;</span><span class="w"></span>
<span class="n">gpio_irq_chip_set_chip</span><span class="p">(</span><span class="n">girq</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_gpio_irq_chip</span><span class="p">);</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">parent_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ftgpio_gpio_irq_handler</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">parents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_kcalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">girq</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">),</span><span class="w"></span>
<span class="w">                             </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">girq</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">default_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRQ_TYPE_NONE</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle_bad_irq</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irq</span><span class="p">;</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="n">devm_gpiochip_add_data</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The helper supports using threaded interrupts as well. Then you just request
the interrupt separately and go with it:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Typical state container */</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">my_gpio</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">gpio_chip</span><span class="w"> </span><span class="n">gc</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_gpio_mask_irq</span><span class="p">(</span><span class="k">struct</span> <span class="nc">irq_data</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">gpio_chip</span><span class="w"> </span><span class="o">*</span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">irq_hw_number_t</span><span class="w"> </span><span class="n">hwirq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irqd_to_hwirq</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Perform any necessary action to mask the interrupt,</span>
<span class="cm">     * and then call into the core code to synchronise the</span>
<span class="cm">     * state.</span>
<span class="cm">     */</span><span class="w"></span>

<span class="w">    </span><span class="n">gpiochip_disable_irq</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">hwirq</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_gpio_unmask_irq</span><span class="p">(</span><span class="k">struct</span> <span class="nc">irq_data</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">gpio_chip</span><span class="w"> </span><span class="o">*</span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">irq_hw_number_t</span><span class="w"> </span><span class="n">hwirq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irqd_to_hwirq</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">gpiochip_enable_irq</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">hwirq</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Perform any necessary action to unmask the interrupt,</span>
<span class="cm">     * after having called into the core code to synchronise</span>
<span class="cm">     * the state.</span>
<span class="cm">     */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Statically populate the irqchip. Note that it is made const</span>
<span class="cm"> * (further indicated by the IRQCHIP_IMMUTABLE flag), and that</span>
<span class="cm"> * the GPIOCHIP_IRQ_RESOURCE_HELPER macro adds some extra</span>
<span class="cm"> * callbacks to the structure.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">irq_chip</span><span class="w"> </span><span class="n">my_gpio_irq_chip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_gpio_irq&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_ack</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_ack_irq</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_mask</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_mask_irq</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_unmask</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_unmask_irq</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_set_type</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_set_irq_type</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">IRQCHIP_IMMUTABLE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* Provide the gpio resource callbacks */</span><span class="w"></span>
<span class="w">    </span><span class="n">GPIOCHIP_IRQ_RESOURCE_HELPERS</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">;</span><span class="w"> </span><span class="cm">/* from platform etc */</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">my_gpio</span><span class="w"> </span><span class="o">*</span><span class="n">g</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">gpio_irq_chip</span><span class="w"> </span><span class="o">*</span><span class="n">girq</span><span class="p">;</span><span class="w"></span>

<span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_request_threaded_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">irq_thread_fn</span><span class="p">,</span><span class="w"> </span><span class="n">IRQF_ONESHOT</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;my-chip&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="cm">/* Get a pointer to the gpio_irq_chip */</span><span class="w"></span>
<span class="n">girq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">irq</span><span class="p">;</span><span class="w"></span>
<span class="n">gpio_irq_chip_set_chip</span><span class="p">(</span><span class="n">girq</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_gpio_irq_chip</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* This will let us handle the parent IRQ in the driver */</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">parent_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">num_parents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">parents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">default_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRQ_TYPE_NONE</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle_bad_irq</span><span class="p">;</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="n">devm_gpiochip_add_data</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The helper supports using hierarchical interrupt controllers as well.
In this case the typical set-up will look like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Typical state container with dynamic irqchip */</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">my_gpio</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">gpio_chip</span><span class="w"> </span><span class="n">gc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">fwnode_handle</span><span class="w"> </span><span class="o">*</span><span class="n">fwnode</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_gpio_mask_irq</span><span class="p">(</span><span class="k">struct</span> <span class="nc">irq_data</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">gpio_chip</span><span class="w"> </span><span class="o">*</span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">irq_hw_number_t</span><span class="w"> </span><span class="n">hwirq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irqd_to_hwirq</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Perform any necessary action to mask the interrupt,</span>
<span class="cm">     * and then call into the core code to synchronise the</span>
<span class="cm">     * state.</span>
<span class="cm">     */</span><span class="w"></span>

<span class="w">    </span><span class="n">gpiochip_disable_irq</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">hwirq</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">irq_mask_mask_parent</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_gpio_unmask_irq</span><span class="p">(</span><span class="k">struct</span> <span class="nc">irq_data</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">gpio_chip</span><span class="w"> </span><span class="o">*</span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irq_data_get_irq_chip_data</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">irq_hw_number_t</span><span class="w"> </span><span class="n">hwirq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irqd_to_hwirq</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">gpiochip_enable_irq</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">hwirq</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Perform any necessary action to unmask the interrupt,</span>
<span class="cm">     * after having called into the core code to synchronise</span>
<span class="cm">     * the state.</span>
<span class="cm">     */</span><span class="w"></span>

<span class="w">    </span><span class="n">irq_mask_unmask_parent</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Statically populate the irqchip. Note that it is made const</span>
<span class="cm"> * (further indicated by the IRQCHIP_IMMUTABLE flag), and that</span>
<span class="cm"> * the GPIOCHIP_IRQ_RESOURCE_HELPER macro adds some extra</span>
<span class="cm"> * callbacks to the structure.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">irq_chip</span><span class="w"> </span><span class="n">my_gpio_irq_chip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_gpio_irq&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_ack</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_ack_irq</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_mask</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_mask_irq</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_unmask</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_unmask_irq</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">irq_set_type</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_set_irq_type</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">flags</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">IRQCHIP_IMMUTABLE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* Provide the gpio resource callbacks */</span><span class="w"></span>
<span class="w">    </span><span class="n">GPIOCHIP_IRQ_RESOURCE_HELPERS</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">my_gpio</span><span class="w"> </span><span class="o">*</span><span class="n">g</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">gpio_irq_chip</span><span class="w"> </span><span class="o">*</span><span class="n">girq</span><span class="p">;</span><span class="w"></span>

<span class="cm">/* Get a pointer to the gpio_irq_chip */</span><span class="w"></span>
<span class="n">girq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">irq</span><span class="p">;</span><span class="w"></span>
<span class="n">gpio_irq_chip_set_chip</span><span class="p">(</span><span class="n">girq</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_gpio_irq_chip</span><span class="p">);</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">default_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IRQ_TYPE_NONE</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle_bad_irq</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">fwnode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="o">-&gt;</span><span class="n">fwnode</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">parent_domain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span><span class="w"></span>
<span class="n">girq</span><span class="o">-&gt;</span><span class="n">child_to_parent_hwirq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_gpio_child_to_parent_hwirq</span><span class="p">;</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="n">devm_gpiochip_add_data</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>As you can see pretty similar, but you do not supply a parent handler for
the IRQ, instead a parent irqdomain, an fwnode for the hardware and
a function .child_to_parent_hwirq() that has the purpose of looking up
the parent hardware irq from a child (i.e. this gpio chip) hardware irq.
As always it is good to look at examples in the kernel tree for advice
on how to find the required pieces.</p>
<p>If there is a need to exclude certain GPIO lines from the IRQ domain handled by
these helpers, we can set .irq.need_valid_mask of the gpiochip before
devm_gpiochip_add_data() or <a class="reference internal" href="index.html#c.gpiochip_add_data" title="gpiochip_add_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_add_data()</span></code></a> is called. This allocates an
.irq.valid_mask with as many bits set as there are GPIO lines in the chip, each
bit representing line 0..n-1. Drivers can exclude GPIO lines by clearing bits
from this mask. The mask can be filled in the init_valid_mask() callback
that is part of the <a class="reference internal" href="index.html#c.gpio_irq_chip" title="gpio_irq_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_irq_chip</span></code></a>.</p>
<p>To use the helpers please keep the following in mind:</p>
<ul class="simple">
<li><p>Make sure to assign all relevant members of the <a class="reference internal" href="index.html#c.gpio_chip" title="gpio_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_chip</span></code></a> so that
the irqchip can initialize. E.g. .dev and .can_sleep shall be set up
properly.</p></li>
<li><p>Nominally set gpio_irq_chip.handler to handle_bad_irq. Then, if your irqchip
is cascaded, set the handler to <a class="reference internal" href="../../core-api/genericirq.html#c.handle_level_irq" title="handle_level_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_level_irq()</span></code></a> and/or <a class="reference internal" href="../../core-api/genericirq.html#c.handle_edge_irq" title="handle_edge_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">handle_edge_irq()</span></code></a>
in the irqchip .set_type() callback depending on what your controller
supports and what is requested by the consumer.</p></li>
</ul>
</section>
<section id="locking-irq-usage">
<h3>Locking IRQ usage<a class="headerlink" href="#locking-irq-usage" title="Permalink to this headline">¶</a></h3>
<p>Since GPIO and irq_chip are orthogonal, we can get conflicts between different
use cases. For example a GPIO line used for IRQs should be an input line,
it does not make sense to fire interrupts on an output GPIO.</p>
<p>If there is competition inside the subsystem which side is using the
resource (a certain GPIO line and register for example) it needs to deny
certain operations and keep track of usage inside of the gpiolib subsystem.</p>
<p>Input GPIOs can be used as IRQ signals. When this happens, a driver is requested
to mark the GPIO as being used as an IRQ:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset)
</pre></div>
</div>
<p>This will prevent the use of non-irq related GPIO APIs until the GPIO IRQ lock
is released:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset)
</pre></div>
</div>
<p>When implementing an irqchip inside a GPIO driver, these two functions should
typically be called in the .startup() and .shutdown() callbacks from the
irqchip.</p>
<p>When using the gpiolib irqchip helpers, these callbacks are automatically
assigned.</p>
</section>
<section id="disabling-and-enabling-irqs">
<h3>Disabling and enabling IRQs<a class="headerlink" href="#disabling-and-enabling-irqs" title="Permalink to this headline">¶</a></h3>
<p>In some (fringe) use cases, a driver may be using a GPIO line as input for IRQs,
but occasionally switch that line over to drive output and then back to being
an input with interrupts again. This happens on things like CEC (Consumer
Electronics Control).</p>
<p>When a GPIO is used as an IRQ signal, then gpiolib also needs to know if
the IRQ is enabled or disabled. In order to inform gpiolib about this,
the irqchip driver should call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void gpiochip_disable_irq(struct gpio_chip *chip, unsigned int offset)
</pre></div>
</div>
<p>This allows drivers to drive the GPIO as an output while the IRQ is
disabled. When the IRQ is enabled again, a driver should call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void gpiochip_enable_irq(struct gpio_chip *chip, unsigned int offset)
</pre></div>
</div>
<p>When implementing an irqchip inside a GPIO driver, these two functions should
typically be called in the .<a class="reference internal" href="../../core-api/genericirq.html#c.irq_disable" title="irq_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">irq_disable()</span></code></a> and .irq_enable() callbacks from the
irqchip.</p>
<p>When IRQCHIP_IMMUTABLE is not advertised by the irqchip, these callbacks
are automatically assigned. This behaviour is deprecated and on its way
to be removed from the kernel.</p>
</section>
<section id="real-time-compliance-for-gpio-irq-chips">
<h3>Real-Time compliance for GPIO IRQ chips<a class="headerlink" href="#real-time-compliance-for-gpio-irq-chips" title="Permalink to this headline">¶</a></h3>
<p>Any provider of irqchips needs to be carefully tailored to support Real-Time
preemption. It is desirable that all irqchips in the GPIO subsystem keep this
in mind and do the proper testing to assure they are real time-enabled.</p>
<p>So, pay attention on above realtime considerations in the documentation.</p>
<p>The following is a checklist to follow when preparing a driver for real-time
compliance:</p>
<ul class="simple">
<li><p>ensure spinlock_t is not used as part irq_chip implementation</p></li>
<li><p>ensure that sleepable APIs are not used as part irq_chip implementation
If sleepable APIs have to be used, these can be done from the .irq_bus_lock()
and .irq_bus_unlock() callbacks</p></li>
<li><p>Chained GPIO irqchips: ensure spinlock_t or any sleepable APIs are not used
from the chained IRQ handler</p></li>
<li><p>Generic chained GPIO irqchips: take care about <a class="reference internal" href="../../core-api/genericirq.html#c.generic_handle_irq" title="generic_handle_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_handle_irq()</span></code></a> calls and
apply corresponding work-around</p></li>
<li><p>Chained GPIO irqchips: get rid of the chained IRQ handler and use generic irq
handler if possible</p></li>
<li><p>regmap_mmio: it is possible to disable internal locking in regmap by setting
.disable_locking and handling the locking in the GPIO driver</p></li>
<li><p>Test your driver with the appropriate in-kernel real-time test cases for both
level and edge IRQs</p></li>
</ul>
<ul class="simple">
<li><p>[1] <a class="reference external" href="http://www.spinics.net/lists/linux-omap/msg120425.html">http://www.spinics.net/lists/linux-omap/msg120425.html</a></p></li>
<li><p>[2] <a class="reference external" href="https://lore.kernel.org/r/1443209283-20781-2-git-send-email-grygorii.strashko&#64;ti.com">https://lore.kernel.org/r/1443209283-20781-2-git-send-email-grygorii.strashko&#64;ti.com</a></p></li>
<li><p>[3] <a class="reference external" href="https://lore.kernel.org/r/1443209283-20781-3-git-send-email-grygorii.strashko&#64;ti.com">https://lore.kernel.org/r/1443209283-20781-3-git-send-email-grygorii.strashko&#64;ti.com</a></p></li>
</ul>
</section>
</section>
<section id="requesting-self-owned-gpio-pins">
<h2>Requesting self-owned GPIO pins<a class="headerlink" href="#requesting-self-owned-gpio-pins" title="Permalink to this headline">¶</a></h2>
<p>Sometimes it is useful to allow a GPIO chip driver to request its own GPIO
descriptors through the gpiolib API. A GPIO driver can use the following
functions to request and free descriptors:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gpio_desc *gpiochip_request_own_desc(struct gpio_desc *desc,
                                            u16 hwnum,
                                            const char *label,
                                            enum gpiod_flags flags)

void gpiochip_free_own_desc(struct gpio_desc *desc)
</pre></div>
</div>
<p>Descriptors requested with <a class="reference internal" href="index.html#c.gpiochip_request_own_desc" title="gpiochip_request_own_desc"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_request_own_desc()</span></code></a> must be released with
<a class="reference internal" href="index.html#c.gpiochip_free_own_desc" title="gpiochip_free_own_desc"><code class="xref c c-func docutils literal notranslate"><span class="pre">gpiochip_free_own_desc()</span></code></a>.</p>
<p>These functions must be used with care since they do not affect module use
count. Do not use the functions to request gpio descriptors not owned by the
calling driver.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">GPIO Driver Interface</a><ul>
<li><a class="reference internal" href="#internal-representation-of-gpios">Internal Representation of GPIOs</a></li>
<li><a class="reference internal" href="#controller-drivers-gpio-chip">Controller Drivers: gpio_chip</a><ul>
<li><a class="reference internal" href="#gpio-electrical-configuration">GPIO electrical configuration</a></li>
<li><a class="reference internal" href="#gpio-lines-with-debounce-support">GPIO lines with debounce support</a></li>
<li><a class="reference internal" href="#gpio-lines-with-open-drain-source-support">GPIO lines with open drain/source support</a></li>
<li><a class="reference internal" href="#gpio-lines-with-pull-up-down-resistor-support">GPIO lines with pull up/down resistor support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gpio-drivers-providing-irqs">GPIO drivers providing IRQs</a><ul>
<li><a class="reference internal" href="#cascaded-gpio-irqchips">Cascaded GPIO irqchips</a></li>
<li><a class="reference internal" href="#infrastructure-helpers-for-gpio-irqchips">Infrastructure helpers for GPIO irqchips</a></li>
<li><a class="reference internal" href="#locking-irq-usage">Locking IRQ usage</a></li>
<li><a class="reference internal" href="#disabling-and-enabling-irqs">Disabling and enabling IRQs</a></li>
<li><a class="reference internal" href="#real-time-compliance-for-gpio-irq-chips">Real-Time compliance for GPIO IRQ chips</a></li>
</ul>
</li>
<li><a class="reference internal" href="#requesting-self-owned-gpio-pins">Requesting self-owned GPIO pins</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/gpio/driver.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/gpio/driver.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>