
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>PCI Support Library &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="PCI Peer-to-Peer DMA Support" href="p2pdma.html" />
    <link rel="prev" title="The Linux PCI driver implementer’s API guide" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pci-support-library">
<h1>PCI Support Library<a class="headerlink" href="#pci-support-library" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="c.pci_bus_max_busnr">
unsigned char <code class="sig-name descname">pci_bus_max_busnr</code><span class="sig-paren">(</span>struct pci_bus<em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_max_busnr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns maximum PCI bus number of given bus’ children</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>pointer to PCI bus structure to search</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI bus, returns the highest PCI bus number present in the set
including the given PCI bus and its list of child PCI buses.</p>
</div>
<dl class="function">
<dt id="c.pci_status_get_and_clear_errors">
int <code class="sig-name descname">pci_status_get_and_clear_errors</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_status_get_and_clear_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>return and clear error bits in PCI_STATUS</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns error bits set in PCI_STATUS and clears them.</p>
</div>
<dl class="function">
<dt id="c.pci_find_capability">
u8 <code class="sig-name descname">pci_find_capability</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>query for devices’ capabilities</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell if a device supports a given PCI capability.
Returns the address of the requested capability structure within the
device’s PCI configuration space or 0 in case the device does not
support it.  Possible values for <strong>cap</strong> include:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_PM</span></code>           Power Management
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_AGP</span></code>          Accelerated Graphics Port
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_VPD</span></code>          Vital Product Data
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_SLOTID</span></code>       Slot Identification
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_MSI</span></code>          Message Signalled Interrupts
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_CHSWP</span></code>        CompactPCI HotSwap
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_PCIX</span></code>         PCI-X
<code class="docutils literal notranslate"><span class="pre">PCI_CAP_ID_EXP</span></code>          PCI Express</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.pci_bus_find_capability">
u8 <code class="sig-name descname">pci_bus_find_capability</code><span class="sig-paren">(</span>struct pci_bus<em> *bus</em>, unsigned int<em> devfn</em>, int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_find_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>query for devices’ capabilities</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the PCI bus to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">devfn</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.pci_find_capability" title="pci_find_capability"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_find_capability()</span></code></a> but works for PCI devices that do not have a
pci_dev structure set up yet.</p>
<p>Returns the address of the requested capability structure within the
device’s PCI configuration space or 0 in case the device does not
support it.</p>
</div>
<dl class="function">
<dt id="c.pci_find_next_ext_capability">
u16 <code class="sig-name descname">pci_find_next_ext_capability</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, u16<em> start</em>, int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_next_ext_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an extended capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">start</span></code></dt><dd><p>address at which to start looking (0 to start at beginning of list)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the next matching extended capability structure
within the device’s PCI configuration space or 0 if the device does
not support it.  Some capabilities can occur several times, e.g., the
vendor-specific capability, and this provides a way to find them all.</p>
</div>
<dl class="function">
<dt id="c.pci_find_ext_capability">
u16 <code class="sig-name descname">pci_find_ext_capability</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_ext_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an extended capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the requested extended capability structure
within the device’s PCI configuration space or 0 if the device does
not support it.  Possible values for <strong>cap</strong> include:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">PCI_EXT_CAP_ID_ERR</span></code>         Advanced Error Reporting
<code class="docutils literal notranslate"><span class="pre">PCI_EXT_CAP_ID_VC</span></code>          Virtual Channel
<code class="docutils literal notranslate"><span class="pre">PCI_EXT_CAP_ID_DSN</span></code>         Device Serial Number
<code class="docutils literal notranslate"><span class="pre">PCI_EXT_CAP_ID_PWR</span></code>         Power Budgeting</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.pci_get_dsn">
u64 <code class="sig-name descname">pci_get_dsn</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_dsn" title="Permalink to this definition">¶</a></dt>
<dd><p>Read and return the 8-byte Device Serial Number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the PCI_EXT_CAP_ID_DSN and reads the 8 bytes of the Device Serial
Number.</p>
<p>Returns the DSN, or zero if the capability does not exist.</p>
</div>
<dl class="function">
<dt id="c.pci_find_next_ht_capability">
u8 <code class="sig-name descname">pci_find_next_ht_capability</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, u8<em> pos</em>, int<em> ht_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_next_ht_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>query a device’s HyperTransport capabilities</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">pos</span></code></dt><dd><p>Position from which to continue searching</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ht_cap</span></code></dt><dd><p>HyperTransport capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>To be used in conjunction with <a class="reference internal" href="#c.pci_find_ht_capability" title="pci_find_ht_capability"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_find_ht_capability()</span></code></a> to search for
all capabilities matching <strong>ht_cap</strong>. <strong>pos</strong> should always be a value returned
from <a class="reference internal" href="#c.pci_find_ht_capability" title="pci_find_ht_capability"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_find_ht_capability()</span></code></a>.</p>
<p>NB. To be 100% safe against broken PCI devices, the caller should take
steps to avoid an infinite loop.</p>
</div>
<dl class="function">
<dt id="c.pci_find_ht_capability">
u8 <code class="sig-name descname">pci_find_ht_capability</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, int<em> ht_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_ht_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>query a device’s HyperTransport capabilities</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ht_cap</span></code></dt><dd><p>HyperTransport capability code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell if a device supports a given HyperTransport capability.
Returns an address within the device’s PCI configuration space
or 0 in case the device does not support the request capability.
The address points to the PCI capability, of type PCI_CAP_ID_HT,
which has a HyperTransport capability matching <strong>ht_cap</strong>.</p>
</div>
<dl class="function">
<dt id="c.pci_find_vsec_capability">
u16 <code class="sig-name descname">pci_find_vsec_capability</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, u16<em> vendor</em>, int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_vsec_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a vendor-specific extended capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">vendor</span></code></dt><dd><p>Vendor ID for which capability is defined</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>Vendor-specific capability ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>dev</strong> has Vendor ID <strong>vendor</strong>, search for a VSEC capability with
VSEC ID <strong>cap</strong>. If found, return the capability offset in
config space; otherwise return 0.</p>
</div>
<dl class="function">
<dt id="c.pci_find_dvsec_capability">
u16 <code class="sig-name descname">pci_find_dvsec_capability</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, u16<em> vendor</em>, u16<em> dvsec</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_dvsec_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>Find DVSEC for vendor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">vendor</span></code></dt><dd><p>Vendor ID to match for the DVSEC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">dvsec</span></code></dt><dd><p>Designated Vendor-specific capability ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If DVSEC has Vendor ID <strong>vendor</strong> and DVSEC ID <strong>dvsec</strong> return the capability
offset in config space; otherwise return 0.</p>
</div>
<dl class="function">
<dt id="c.pci_find_parent_resource">
struct resource * <code class="sig-name descname">pci_find_parent_resource</code><span class="sig-paren">(</span>const struct pci_dev<em> *dev</em>, struct resource<em> *res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_parent_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>return resource region of parent bus of given region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device structure contains resources to be searched</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>child resource record for which parent is sought</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For given resource region of given device, return the resource region of
parent bus the given region is contained in.</p>
</div>
<dl class="function">
<dt id="c.pci_find_resource">
struct resource * <code class="sig-name descname">pci_find_resource</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, struct resource<em> *res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Return matching PCI device resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>Resource to look for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Goes over standard PCI resources (BARs) and checks if the given resource
is partially or fully contained in any of them. In that case the
matching resource is returned, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.pci_platform_power_transition">
int <code class="sig-name descname">pci_platform_power_transition</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, pci_power_t<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_platform_power_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Use platform to change device power state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt><dd><p>State to put the device into.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pci_set_power_state">
int <code class="sig-name descname">pci_set_power_state</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, pci_power_t<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_power_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the power state of a PCI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt><dd><p>PCI power state (D0, D1, D2, D3hot) to put the device into.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Transition a device to a new power state, using the platform firmware and/or
the device’s PCI PM registers.</p>
<p>RETURN VALUE:
-EINVAL if the requested state is invalid.
-EIO if device does not support PCI PM or its PM capabilities register has a
wrong version, or device doesn’t support the requested state.
0 if the transition is to D1 or D2 but D1 and D2 are not supported.
0 if device already is in the requested state.
0 if the transition is to D3 but D3 is not supported.
0 if device’s power state has been successfully changed.</p>
</div>
<dl class="function">
<dt id="c.pci_save_state">
int <code class="sig-name descname">pci_save_state</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_save_state" title="Permalink to this definition">¶</a></dt>
<dd><p>save the PCI configuration space of a device before suspending</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device that we’re dealing with</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pci_restore_state">
void <code class="sig-name descname">pci_restore_state</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_restore_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore the saved state of a PCI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device that we’re dealing with</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pci_store_saved_state">
struct pci_saved_state * <code class="sig-name descname">pci_store_saved_state</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_store_saved_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and return an opaque struct containing the device saved state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device that we’re dealing with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return NULL if no state or error.</p>
</div>
<dl class="function">
<dt id="c.pci_load_saved_state">
int <code class="sig-name descname">pci_load_saved_state</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, struct pci_saved_state<em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_load_saved_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reload the provided save state into struct pci_dev.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device that we’re dealing with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_saved_state</span> <span class="pre">*state</span></code></dt><dd><p>Saved state returned from <a class="reference internal" href="#c.pci_store_saved_state" title="pci_store_saved_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_store_saved_state()</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pci_load_and_free_saved_state">
int <code class="sig-name descname">pci_load_and_free_saved_state</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, struct pci_saved_state<em> **state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_load_and_free_saved_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reload the save state pointed to by state, and free the memory allocated for it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device that we’re dealing with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_saved_state</span> <span class="pre">**state</span></code></dt><dd><p>Pointer to saved state returned from <a class="reference internal" href="#c.pci_store_saved_state" title="pci_store_saved_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_store_saved_state()</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pci_reenable_device">
int <code class="sig-name descname">pci_reenable_device</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reenable_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume abandoned device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to be resumed</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>This function is a backend of pci_default_resume() and is not supposed
to be called by normal code, write proper resume handler and use it instead.</p>
</div>
<dl class="function">
<dt id="c.pci_enable_device_io">
int <code class="sig-name descname">pci_enable_device_io</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_device_io" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a device for use with IO space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize device before it’s used by a driver. Ask low-level code
to enable I/O resources. Wake up the device if it was suspended.
Beware, this function can fail.</p>
</div>
<dl class="function">
<dt id="c.pci_enable_device_mem">
int <code class="sig-name descname">pci_enable_device_mem</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_device_mem" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a device for use with Memory space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize device before it’s used by a driver. Ask low-level code
to enable Memory resources. Wake up the device if it was suspended.
Beware, this function can fail.</p>
</div>
<dl class="function">
<dt id="c.pci_enable_device">
int <code class="sig-name descname">pci_enable_device</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize device before it’s used by a driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize device before it’s used by a driver. Ask low-level code
to enable I/O and memory. Wake up the device if it was suspended.
Beware, this function can fail.</p>
<p>Note we don’t actually enable the device many times if we call
this function repeatedly (we just increment the count).</p>
</div>
<dl class="function">
<dt id="c.pcim_enable_device">
int <code class="sig-name descname">pcim_enable_device</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcim_enable_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed <a class="reference internal" href="#c.pci_enable_device" title="pci_enable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_device()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.pci_enable_device" title="pci_enable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_device()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.pcim_pin_device">
void <code class="sig-name descname">pcim_pin_device</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcim_pin_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Pin managed PCI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device to pin</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pin managed PCI device <strong>pdev</strong>.  Pinned device won’t be disabled on
driver detach.  <strong>pdev</strong> must have been enabled with
<a class="reference internal" href="#c.pcim_enable_device" title="pcim_enable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pcim_enable_device()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.pci_disable_device">
void <code class="sig-name descname">pci_disable_device</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_disable_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable PCI device after use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to be disabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal to the system that the PCI device is not in use by the system
anymore.  This only involves disabling PCI bus-mastering, if active.</p>
<p>Note we don’t actually disable the device until all callers of
<a class="reference internal" href="#c.pci_enable_device" title="pci_enable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_device()</span></code></a> have called <a class="reference internal" href="#c.pci_disable_device" title="pci_disable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_disable_device()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.pci_set_pcie_reset_state">
int <code class="sig-name descname">pci_set_pcie_reset_state</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, enum pcie_reset_state<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_pcie_reset_state" title="Permalink to this definition">¶</a></dt>
<dd><p>set reset state for device dev</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCIe device reset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pcie_reset_state</span> <span class="pre">state</span></code></dt><dd><p>Reset state to enter into</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the PCI reset state for the device.</p>
</div>
<dl class="function">
<dt id="c.pci_pme_capable">
bool <code class="sig-name descname">pci_pme_capable</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, pci_power_t<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_pme_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>check the capability of PCI device to generate PME#</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt><dd><p>PCI state from which device will issue PME#.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pci_pme_active">
void <code class="sig-name descname">pci_pme_active</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_pme_active" title="Permalink to this definition">¶</a></dt>
<dd><p>enable or disable PCI device’s PME# function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>‘true’ to enable PME# generation; ‘false’ to disable it.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must verify that the device is capable of generating PME# before
calling this function with <strong>enable</strong> equal to ‘true’.</p>
</div>
<dl class="function">
<dt id="c.pci_enable_wake">
int <code class="sig-name descname">pci_enable_wake</code><span class="sig-paren">(</span>struct pci_dev<em> *pci_dev</em>, pci_power_t<em> state</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_wake" title="Permalink to this definition">¶</a></dt>
<dd><p>change wakeup settings for a PCI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pci_dev</span></code></dt><dd><p>Target device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt><dd><p>PCI state from which device will issue wakeup events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>Whether or not to enable event generation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>enable</strong> is set, check device_may_wakeup() for the device before calling
__pci_enable_wake() for it.</p>
</div>
<dl class="function">
<dt id="c.pci_wake_from_d3">
int <code class="sig-name descname">pci_wake_from_d3</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_wake_from_d3" title="Permalink to this definition">¶</a></dt>
<dd><p>enable/disable device to wake up from D3_hot or D3_cold</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to prepare</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>True to enable wake-up event generation; false to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Many drivers want the device to wake up the system from D3_hot or D3_cold
and this function allows them to set that up cleanly - <a class="reference internal" href="#c.pci_enable_wake" title="pci_enable_wake"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_wake()</span></code></a>
should not be called twice in a row to enable wake-up due to PCI PM vs ACPI
ordering constraints.</p>
<p>This function only returns error code if the device is not allowed to wake
up the system from sleep or it is not capable of generating PME# from both
D3_hot and D3_cold and the platform is unable to enable wake-up power for it.</p>
</div>
<dl class="function">
<dt id="c.pci_prepare_to_sleep">
int <code class="sig-name descname">pci_prepare_to_sleep</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_prepare_to_sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare PCI device for system-wide transition into a sleep state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Device to handle.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Choose the power state appropriate for the device depending on whether
it can wake up the system and/or is power manageable by the platform
(PCI_D3hot is the default) and put the device into that state.</p>
</div>
<dl class="function">
<dt id="c.pci_back_from_sleep">
int <code class="sig-name descname">pci_back_from_sleep</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_back_from_sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>turn PCI device on during system-wide transition into working state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Device to handle.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable device’s system wake-up capability and put it into D0.</p>
</div>
<dl class="function">
<dt id="c.pci_dev_run_wake">
bool <code class="sig-name descname">pci_dev_run_wake</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_run_wake" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device can generate run-time wake-up events.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Device to check.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the device itself is capable of generating wake-up events
(through the platform or using the native PCIe PME) or if the device supports
PME and one of its upstream bridges can generate wake-up events.</p>
</div>
<dl class="function">
<dt id="c.pci_choose_state">
pci_power_t <code class="sig-name descname">pci_choose_state</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, pm_message_t<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_choose_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose the power state of a PCI device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Target PCI device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pm_message_t</span> <span class="pre">state</span></code></dt><dd><p>Target state for the whole system.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns PCI power state suitable for <strong>dev</strong> and <strong>state</strong>.</p>
</div>
<dl class="function">
<dt id="c.pci_d3cold_enable">
void <code class="sig-name descname">pci_d3cold_enable</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_d3cold_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable D3cold for device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used in drivers to enable D3cold from the device
they handle.  It also updates upstream PCI bridge PM capabilities
accordingly.</p>
</div>
<dl class="function">
<dt id="c.pci_d3cold_disable">
void <code class="sig-name descname">pci_d3cold_disable</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_d3cold_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable D3cold for device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used in drivers to disable D3cold from the device
they handle.  It also updates upstream PCI bridge PM capabilities
accordingly.</p>
</div>
<dl class="function">
<dt id="c.pci_rebar_get_possible_sizes">
u32 <code class="sig-name descname">pci_rebar_get_possible_sizes</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, int<em> bar</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_rebar_get_possible_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>get possible sizes for BAR</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bar</span></code></dt><dd><p>BAR to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the possible sizes of a resizable BAR as bitmask defined in the spec
(bit 0=1MB, bit 19=512GB). Returns 0 if BAR isn’t resizable.</p>
</div>
<dl class="function">
<dt id="c.pci_enable_atomic_ops_to_root">
int <code class="sig-name descname">pci_enable_atomic_ops_to_root</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, u32<em> cap_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_atomic_ops_to_root" title="Permalink to this definition">¶</a></dt>
<dd><p>enable AtomicOp requests to root port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">cap_mask</span></code></dt><dd><p>mask of desired AtomicOp sizes, including one or more of:
PCI_EXP_DEVCAP2_ATOMIC_COMP32
PCI_EXP_DEVCAP2_ATOMIC_COMP64
PCI_EXP_DEVCAP2_ATOMIC_COMP128</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 if all upstream bridges support AtomicOp routing, egress
blocking is disabled on all upstream ports, and the root port supports
the requested completion capabilities (32-bit, 64-bit and/or 128-bit
AtomicOp completion), or negative otherwise.</p>
</div>
<dl class="function">
<dt id="c.pci_common_swizzle">
u8 <code class="sig-name descname">pci_common_swizzle</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, u8<em> *pinp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_common_swizzle" title="Permalink to this definition">¶</a></dt>
<dd><p>swizzle INTx all the way to root bridge</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*pinp</span></code></dt><dd><p>pointer to the INTx pin value (1=INTA, 2=INTB, 3=INTD, 4=INTD)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform INTx swizzling for a device.  This traverses through all PCI-to-PCI
bridges all the way up to a PCI root bus.</p>
</div>
<dl class="function">
<dt id="c.pci_release_region">
void <code class="sig-name descname">pci_release_region</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, int<em> bar</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_release_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a PCI bar</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources were previously reserved by
<a class="reference internal" href="#c.pci_request_region" title="pci_request_region"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_region()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bar</span></code></dt><dd><p>BAR to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the PCI I/O and memory resources previously reserved by a
successful call to <a class="reference internal" href="#c.pci_request_region" title="pci_request_region"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_region()</span></code></a>.  Call this function only
after all use of the PCI regions has ceased.</p>
</div>
<dl class="function">
<dt id="c.pci_request_region">
int <code class="sig-name descname">pci_request_region</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, int<em> bar</em>, const char<em> *res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve PCI I/O and memory resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources are to be reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bar</span></code></dt><dd><p>BAR to be reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*res_name</span></code></dt><dd><p>Name to be associated with resource</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark the PCI region associated with PCI device <strong>pdev</strong> BAR <strong>bar</strong> as
being reserved by owner <strong>res_name</strong>.  Do not access any
address inside the PCI regions unless this call returns
successfully.</p>
<p>Returns 0 on success, or <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> on error.  A warning
message is also printed on failure.</p>
</div>
<dl class="function">
<dt id="c.pci_release_selected_regions">
void <code class="sig-name descname">pci_release_selected_regions</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, int<em> bars</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_release_selected_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Release selected PCI I/O and memory resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources were previously reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bars</span></code></dt><dd><p>Bitmask of BARs to be released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release selected PCI I/O and memory resources previously reserved.
Call this function only after all use of the PCI regions has ceased.</p>
</div>
<dl class="function">
<dt id="c.pci_request_selected_regions">
int <code class="sig-name descname">pci_request_selected_regions</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, int<em> bars</em>, const char<em> *res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_selected_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve selected PCI I/O and memory resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources are to be reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bars</span></code></dt><dd><p>Bitmask of BARs to be requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*res_name</span></code></dt><dd><p>Name to be associated with resource</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pci_release_regions">
void <code class="sig-name descname">pci_release_regions</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_release_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Release reserved PCI I/O and memory resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources were previously reserved by
<a class="reference internal" href="#c.pci_request_regions" title="pci_request_regions"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_regions()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all PCI I/O and memory resources previously reserved by a
successful call to <a class="reference internal" href="#c.pci_request_regions" title="pci_request_regions"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_regions()</span></code></a>.  Call this function only
after all use of the PCI regions has ceased.</p>
</div>
<dl class="function">
<dt id="c.pci_request_regions">
int <code class="sig-name descname">pci_request_regions</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, const char<em> *res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve PCI I/O and memory resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources are to be reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*res_name</span></code></dt><dd><p>Name to be associated with resource.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark all PCI regions associated with PCI device <strong>pdev</strong> as
being reserved by owner <strong>res_name</strong>.  Do not access any
address inside the PCI regions unless this call returns
successfully.</p>
<p>Returns 0 on success, or <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> on error.  A warning
message is also printed on failure.</p>
</div>
<dl class="function">
<dt id="c.pci_request_regions_exclusive">
int <code class="sig-name descname">pci_request_regions_exclusive</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, const char<em> *res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_regions_exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve PCI I/O and memory resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device whose resources are to be reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*res_name</span></code></dt><dd><p>Name to be associated with resource.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark all PCI regions associated with PCI device <strong>pdev</strong> as being reserved
by owner <strong>res_name</strong>.  Do not access any address inside the PCI regions
unless this call returns successfully.</p>
<p><a class="reference internal" href="#c.pci_request_regions_exclusive" title="pci_request_regions_exclusive"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_regions_exclusive()</span></code></a> will mark the region so that /dev/mem
and the sysfs MMIO access will not be allowed.</p>
<p>Returns 0 on success, or <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> on error.  A warning message is also
printed on failure.</p>
</div>
<dl class="function">
<dt id="c.pci_remap_iospace">
int <code class="sig-name descname">pci_remap_iospace</code><span class="sig-paren">(</span>const struct resource<em> *res</em>, phys_addr_t<em> phys_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_remap_iospace" title="Permalink to this definition">¶</a></dt>
<dd><p>Remap the memory mapped I/O space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>Resource describing the I/O space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phys_addr_t</span> <span class="pre">phys_addr</span></code></dt><dd><p>physical address of range to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remap the memory mapped I/O space described by the <strong>res</strong> and the CPU
physical address <strong>phys_addr</strong> into virtual address space.  Only
architectures that have memory mapped IO functions defined (and the
PCI_IOBASE value defined) should call this function.</p>
</div>
<dl class="function">
<dt id="c.pci_unmap_iospace">
void <code class="sig-name descname">pci_unmap_iospace</code><span class="sig-paren">(</span>struct resource<em> *res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_unmap_iospace" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap the memory mapped I/O space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>resource to be unmapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmap the CPU virtual address <strong>res</strong> from virtual address space.  Only
architectures that have memory mapped IO functions defined (and the
PCI_IOBASE value defined) should call this function.</p>
</div>
<dl class="function">
<dt id="c.devm_pci_remap_iospace">
int <code class="sig-name descname">devm_pci_remap_iospace</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct resource<em> *res</em>, phys_addr_t<em> phys_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pci_remap_iospace" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed <a class="reference internal" href="#c.pci_remap_iospace" title="pci_remap_iospace"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_remap_iospace()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Generic device to remap IO address for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>Resource describing the I/O space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phys_addr_t</span> <span class="pre">phys_addr</span></code></dt><dd><p>physical address of range to be mapped</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.pci_remap_iospace" title="pci_remap_iospace"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_remap_iospace()</span></code></a>.  Map is automatically unmapped on driver
detach.</p>
</div>
<dl class="function">
<dt id="c.devm_pci_remap_cfgspace">
void __iomem * <code class="sig-name descname">devm_pci_remap_cfgspace</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, resource_size_t<em> offset</em>, resource_size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pci_remap_cfgspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed pci_remap_cfgspace()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Generic device to remap IO address for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">offset</span></code></dt><dd><p>Resource address to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of map</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed pci_remap_cfgspace().  Map is automatically unmapped on driver
detach.</p>
</div>
<dl class="function">
<dt id="c.devm_pci_remap_cfg_resource">
void __iomem * <code class="sig-name descname">devm_pci_remap_cfg_resource</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct resource<em> *res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pci_remap_cfg_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>check, request region and ioremap cfg resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>generic device to handle the resource for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>configuration space resource to be handled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that a resource is a valid memory region, requests the memory
region and ioremaps with pci_remap_cfgspace() API that ensures the
proper PCI configuration space memory attributes are guaranteed.</p>
<p>All operations are managed and will be undone on driver detach.</p>
<p>Returns a pointer to the remapped memory or an ERR_PTR() encoded error code
on failure. Usage example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
base = devm_pci_remap_cfg_resource(&amp;pdev-&gt;dev, res);
if (IS_ERR(base))
        return PTR_ERR(base);
</pre></div>
</div>
</div>
<dl class="function">
<dt id="c.pci_set_master">
void <code class="sig-name descname">pci_set_master</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_master" title="Permalink to this definition">¶</a></dt>
<dd><p>enables bus-mastering for device dev</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables bus-mastering on the device and calls pcibios_set_master()
to do the needed arch specific settings.</p>
</div>
<dl class="function">
<dt id="c.pci_clear_master">
void <code class="sig-name descname">pci_clear_master</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_clear_master" title="Permalink to this definition">¶</a></dt>
<dd><p>disables bus-mastering for device dev</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to disable</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pci_set_cacheline_size">
int <code class="sig-name descname">pci_set_cacheline_size</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_cacheline_size" title="Permalink to this definition">¶</a></dt>
<dd><p>ensure the CACHE_LINE_SIZE register is programmed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device for which MWI is to be enabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for pci_set_mwi.
Originally copied from drivers/net/acenic.c.
Copyright 1998-2001 by Jes Sorensen, &lt;jes**trained**-monkey.org&gt;.</p>
<p><strong>Return</strong></p>
<p>An appropriate -ERRNO error value on error, or zero for success.</p>
</div>
<dl class="function">
<dt id="c.pci_set_mwi">
int <code class="sig-name descname">pci_set_mwi</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_mwi" title="Permalink to this definition">¶</a></dt>
<dd><p>enables memory-write-invalidate PCI transaction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device for which MWI is enabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables the Memory-Write-Invalidate transaction in <code class="docutils literal notranslate"><span class="pre">PCI_COMMAND</span></code>.</p>
<p><strong>Return</strong></p>
<p>An appropriate -ERRNO error value on error, or zero for success.</p>
</div>
<dl class="function">
<dt id="c.pcim_set_mwi">
int <code class="sig-name descname">pcim_set_mwi</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcim_set_mwi" title="Permalink to this definition">¶</a></dt>
<dd><p>a device-managed <a class="reference internal" href="#c.pci_set_mwi" title="pci_set_mwi"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_set_mwi()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device for which MWI is enabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.pci_set_mwi" title="pci_set_mwi"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_set_mwi()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>An appropriate -ERRNO error value on error, or zero for success.</p>
</div>
<dl class="function">
<dt id="c.pci_try_set_mwi">
int <code class="sig-name descname">pci_try_set_mwi</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_try_set_mwi" title="Permalink to this definition">¶</a></dt>
<dd><p>enables memory-write-invalidate PCI transaction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device for which MWI is enabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables the Memory-Write-Invalidate transaction in <code class="docutils literal notranslate"><span class="pre">PCI_COMMAND</span></code>.
Callers are not required to check the return value.</p>
<p><strong>Return</strong></p>
<p>An appropriate -ERRNO error value on error, or zero for success.</p>
</div>
<dl class="function">
<dt id="c.pci_clear_mwi">
void <code class="sig-name descname">pci_clear_mwi</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_clear_mwi" title="Permalink to this definition">¶</a></dt>
<dd><p>disables Memory-Write-Invalidate for device dev</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables PCI Memory-Write-Invalidate transaction on the device</p>
</div>
<dl class="function">
<dt id="c.pci_intx">
void <code class="sig-name descname">pci_intx</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, int<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_intx" title="Permalink to this definition">¶</a></dt>
<dd><p>enables/disables PCI INTx for device dev</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">enable</span></code></dt><dd><p>boolean: whether to enable or disable PCI INTx</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables/disables PCI INTx for device <strong>pdev</strong></p>
</div>
<dl class="function">
<dt id="c.pci_check_and_mask_intx">
bool <code class="sig-name descname">pci_check_and_mask_intx</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_check_and_mask_intx" title="Permalink to this definition">¶</a></dt>
<dd><p>mask INTx on pending interrupt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the device dev has its INTx line asserted, mask it and return
true in that case. False is returned if no interrupt was pending.</p>
</div>
<dl class="function">
<dt id="c.pci_check_and_unmask_intx">
bool <code class="sig-name descname">pci_check_and_unmask_intx</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_check_and_unmask_intx" title="Permalink to this definition">¶</a></dt>
<dd><p>unmask INTx if no interrupt is pending</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the device dev has its INTx line asserted, unmask it if not and
return true. False is returned and the mask remains active if there was
still an interrupt pending.</p>
</div>
<dl class="function">
<dt id="c.pci_wait_for_pending_transaction">
int <code class="sig-name descname">pci_wait_for_pending_transaction</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_wait_for_pending_transaction" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for pending transaction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 if transaction is pending 1 otherwise.</p>
</div>
<dl class="function">
<dt id="c.pcie_flr">
int <code class="sig-name descname">pcie_flr</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_flr" title="Permalink to this definition">¶</a></dt>
<dd><p>initiate a PCIe function level reset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initiate a function level reset unconditionally on <strong>dev</strong> without
checking any flags and DEVCAP</p>
</div>
<dl class="function">
<dt id="c.pcie_reset_flr">
int <code class="sig-name descname">pcie_reset_flr</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, bool<em> probe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_reset_flr" title="Permalink to this definition">¶</a></dt>
<dd><p>initiate a PCIe function level reset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device to reset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">probe</span></code></dt><dd><p>if true, return 0 if device can be reset this way</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initiate a function level reset on <strong>dev</strong>.</p>
</div>
<dl class="function">
<dt id="c.pci_bridge_secondary_bus_reset">
int <code class="sig-name descname">pci_bridge_secondary_bus_reset</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bridge_secondary_bus_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the secondary bus on a PCI bridge.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>Bridge device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the bridge control register to assert reset on the secondary bus.
Devices on the secondary bus are left in power-on state.</p>
</div>
<dl class="function">
<dt id="c.__pci_reset_function_locked">
int <code class="sig-name descname">__pci_reset_function_locked</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_reset_function_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a PCI device function while holding the <strong>dev</strong> mutex lock.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.</p>
<p>The device function is presumed to be unused and the caller is holding
the device mutex lock when this function is called.</p>
<p>Resetting the device will make the contents of PCI configuration space
random, so any caller of this must be prepared to reinitialise the
device including MSI, bus mastering, BARs, decoding IO and memory spaces,
etc.</p>
<p>Returns 0 if the device function was successfully reset or negative if the
device doesn’t support resetting a single function.</p>
</div>
<dl class="function">
<dt id="c.pci_reset_function">
int <code class="sig-name descname">pci_reset_function</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reset_function" title="Permalink to this definition">¶</a></dt>
<dd><p>quiesce and reset a PCI device function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.</p>
<p>This function does not just reset the PCI portion of a device, but
clears all the state associated with the device.  This function differs
from <a class="reference internal" href="#c.__pci_reset_function_locked" title="__pci_reset_function_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">__pci_reset_function_locked()</span></code></a> in that it saves and restores device state
over the reset and takes the PCI device lock.</p>
<p>Returns 0 if the device function was successfully reset or negative if the
device doesn’t support resetting a single function.</p>
</div>
<dl class="function">
<dt id="c.pci_reset_function_locked">
int <code class="sig-name descname">pci_reset_function_locked</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reset_function_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>quiesce and reset a PCI device function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.</p>
<p>This function does not just reset the PCI portion of a device, but
clears all the state associated with the device.  This function differs
from <a class="reference internal" href="#c.__pci_reset_function_locked" title="__pci_reset_function_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">__pci_reset_function_locked()</span></code></a> in that it saves and restores device state
over the reset.  It also differs from <a class="reference internal" href="#c.pci_reset_function" title="pci_reset_function"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_reset_function()</span></code></a> in that it
requires the PCI device lock to be held.</p>
<p>Returns 0 if the device function was successfully reset or negative if the
device doesn’t support resetting a single function.</p>
</div>
<dl class="function">
<dt id="c.pci_try_reset_function">
int <code class="sig-name descname">pci_try_reset_function</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_try_reset_function" title="Permalink to this definition">¶</a></dt>
<dd><p>quiesce and reset a PCI device function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to reset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as above, except return -EAGAIN if unable to lock device.</p>
</div>
<dl class="function">
<dt id="c.pci_probe_reset_slot">
int <code class="sig-name descname">pci_probe_reset_slot</code><span class="sig-paren">(</span>struct pci_slot<em> *slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_probe_reset_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>probe whether a PCI slot can be reset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*slot</span></code></dt><dd><p>PCI slot to probe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 if slot can be reset, negative if a slot reset is not supported.</p>
</div>
<dl class="function">
<dt id="c.pci_probe_reset_bus">
int <code class="sig-name descname">pci_probe_reset_bus</code><span class="sig-paren">(</span>struct pci_bus<em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_probe_reset_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>probe whether a PCI bus can be reset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>PCI bus to probe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 if bus can be reset, negative if a bus reset is not supported.</p>
</div>
<dl class="function">
<dt id="c.pci_reset_bus">
int <code class="sig-name descname">pci_reset_bus</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reset_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to reset a PCI bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>top level PCI device to reset via slot/bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as above except return -EAGAIN if the bus cannot be locked</p>
</div>
<dl class="function">
<dt id="c.pcix_get_max_mmrbc">
int <code class="sig-name descname">pcix_get_max_mmrbc</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcix_get_max_mmrbc" title="Permalink to this definition">¶</a></dt>
<dd><p>get PCI-X maximum designed memory read byte count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns mmrbc: maximum designed memory read count in bytes or
appropriate error value.</p>
</div>
<dl class="function">
<dt id="c.pcix_get_mmrbc">
int <code class="sig-name descname">pcix_get_mmrbc</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcix_get_mmrbc" title="Permalink to this definition">¶</a></dt>
<dd><p>get PCI-X maximum memory read byte count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns mmrbc: maximum memory read count in bytes or appropriate error
value.</p>
</div>
<dl class="function">
<dt id="c.pcix_set_mmrbc">
int <code class="sig-name descname">pcix_set_mmrbc</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, int<em> mmrbc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcix_set_mmrbc" title="Permalink to this definition">¶</a></dt>
<dd><p>set PCI-X maximum memory read byte count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mmrbc</span></code></dt><dd><p>maximum memory read count in bytes
valid values are 512, 1024, 2048, 4096</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If possible sets maximum memory read byte count, some bridges have errata
that prevent this.</p>
</div>
<dl class="function">
<dt id="c.pcie_get_readrq">
int <code class="sig-name descname">pcie_get_readrq</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_get_readrq" title="Permalink to this definition">¶</a></dt>
<dd><p>get PCI Express read request size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns maximum memory read request in bytes or appropriate error value.</p>
</div>
<dl class="function">
<dt id="c.pcie_set_readrq">
int <code class="sig-name descname">pcie_set_readrq</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, int<em> rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_set_readrq" title="Permalink to this definition">¶</a></dt>
<dd><p>set PCI Express maximum memory read request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">rq</span></code></dt><dd><p>maximum memory read count in bytes
valid values are 128, 256, 512, 1024, 2048, 4096</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If possible sets maximum memory read request in bytes</p>
</div>
<dl class="function">
<dt id="c.pcie_get_mps">
int <code class="sig-name descname">pcie_get_mps</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_get_mps" title="Permalink to this definition">¶</a></dt>
<dd><p>get PCI Express maximum payload size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns maximum payload size in bytes</p>
</div>
<dl class="function">
<dt id="c.pcie_set_mps">
int <code class="sig-name descname">pcie_set_mps</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, int<em> mps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_set_mps" title="Permalink to this definition">¶</a></dt>
<dd><p>set PCI Express maximum payload size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mps</span></code></dt><dd><p>maximum payload size in bytes
valid values are 128, 256, 512, 1024, 2048, 4096</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If possible sets maximum payload size</p>
</div>
<dl class="function">
<dt id="c.pcie_bandwidth_available">
u32 <code class="sig-name descname">pcie_bandwidth_available</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, struct pci_dev<em> **limiting_dev</em>, enum pci_bus_speed<em> *speed</em>, enum pcie_link_width<em> *width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_bandwidth_available" title="Permalink to this definition">¶</a></dt>
<dd><p>determine minimum link settings of a PCIe device and its bandwidth limitation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">**limiting_dev</span></code></dt><dd><p>storage for device causing the bandwidth limitation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pci_bus_speed</span> <span class="pre">*speed</span></code></dt><dd><p>storage for speed of limiting device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pcie_link_width</span> <span class="pre">*width</span></code></dt><dd><p>storage for width of limiting device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk up the PCI device chain and find the point where the minimum
bandwidth is available.  Return the bandwidth available there and (if
limiting_dev, speed, and width pointers are supplied) information about
that point.  The bandwidth returned is in Mb/s, i.e., megabits/second of
raw bandwidth.</p>
</div>
<dl class="function">
<dt id="c.pcie_get_speed_cap">
enum pci_bus_speed <code class="sig-name descname">pcie_get_speed_cap</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_get_speed_cap" title="Permalink to this definition">¶</a></dt>
<dd><p>query for the PCI device’s link speed capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Query the PCI device speed capability.  Return the maximum link speed
supported by the device.</p>
</div>
<dl class="function">
<dt id="c.pcie_get_width_cap">
enum pcie_link_width <code class="sig-name descname">pcie_get_width_cap</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_get_width_cap" title="Permalink to this definition">¶</a></dt>
<dd><p>query for the PCI device’s link width capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Query the PCI device width capability.  Return the maximum link width
supported by the device.</p>
</div>
<dl class="function">
<dt id="c.pcie_print_link_status">
void <code class="sig-name descname">pcie_print_link_status</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_print_link_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the PCI device’s link speed and width</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Report the available bandwidth at the device.</p>
</div>
<dl class="function">
<dt id="c.pci_select_bars">
int <code class="sig-name descname">pci_select_bars</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, unsigned long<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_select_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Make BAR mask from the type of resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device for which BAR mask is made</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>resource type mask to be selected</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper routine makes bar mask from the type of resource.</p>
</div>
<dl class="function">
<dt id="c.pci_add_dynid">
int <code class="sig-name descname">pci_add_dynid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver">pci_driver</a><em> *drv</em>, unsigned int<em> vendor</em>, unsigned int<em> device</em>, unsigned int<em> subvendor</em>, unsigned int<em> subdevice</em>, unsigned int<em> class</em>, unsigned int<em> class_mask</em>, unsigned long<em> driver_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_add_dynid" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new PCI device ID to this driver and re-probe devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span> <span class="pre">*drv</span></code></dt><dd><p>target pci driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vendor</span></code></dt><dd><p>PCI vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>PCI device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">subvendor</span></code></dt><dd><p>PCI subvendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">subdevice</span></code></dt><dd><p>PCI subdevice ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">class</span></code></dt><dd><p>PCI class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">class_mask</span></code></dt><dd><p>PCI class mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">driver_data</span></code></dt><dd><p>private driver data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a new dynamic pci device ID to this driver and causes the
driver to probe for all devices again.  <strong>drv</strong> must have been
registered prior to calling this function.</p>
<p><strong>Context</strong></p>
<p>Does GFP_KERNEL allocation.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
</div>
<dl class="function">
<dt id="c.pci_match_id">
const struct <a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id">pci_device_id</a> * <code class="sig-name descname">pci_match_id</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id">pci_device_id</a><em> *ids</em>, struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_match_id" title="Permalink to this definition">¶</a></dt>
<dd><p>See if a PCI device matches a given pci_id table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_device_id</span> <span class="pre">*ids</span></code></dt><dd><p>array of PCI device ID structures to search in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device structure to match against.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by a driver to check whether a PCI device is in its list of
supported devices.  Returns the matching pci_device_id structure or
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is no match.</p>
<p>Deprecated; don’t use this as it will not catch any dynamic IDs
that a driver might want to check for.</p>
</div>
<dl class="function">
<dt id="c.__pci_register_driver">
int <code class="sig-name descname">__pci_register_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver">pci_driver</a><em> *drv</em>, struct module<em> *owner</em>, const char<em> *mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new pci driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span> <span class="pre">*drv</span></code></dt><dd><p>the driver structure to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owner module of drv</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>module name string</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the driver structure to the list of registered drivers.
Returns a negative value on error, otherwise 0.
If no error occurred, the driver remains registered even if
no device was claimed during registration.</p>
</div>
<dl class="function">
<dt id="c.pci_unregister_driver">
void <code class="sig-name descname">pci_unregister_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver">pci_driver</a><em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a pci driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span> <span class="pre">*drv</span></code></dt><dd><p>the driver structure to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deletes the driver structure from the list of registered PCI drivers,
gives it a chance to clean up by calling its remove() function for
each device it was responsible for, and marks those devices as
driverless.</p>
</div>
<dl class="function">
<dt id="c.pci_dev_driver">
struct <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver">pci_driver</a> * <code class="sig-name descname">pci_dev_driver</code><span class="sig-paren">(</span>const struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>get the pci_driver of a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the appropriate pci_driver structure or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is no
registered driver for the device.</p>
</div>
<dl class="function">
<dt id="c.pci_dev_get">
struct pci_dev * <code class="sig-name descname">pci_dev_get</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_get" title="Permalink to this definition">¶</a></dt>
<dd><p>increments the reference count of the pci device structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the device being referenced</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each live reference to a device should be refcounted.</p>
<p>Drivers for PCI devices should normally record such references in
their probe() methods, when they bind to a device, and release
them by calling <a class="reference internal" href="#c.pci_dev_put" title="pci_dev_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_dev_put()</span></code></a>, in their disconnect() methods.</p>
<p>A pointer to the device with the incremented reference counter is returned.</p>
</div>
<dl class="function">
<dt id="c.pci_dev_put">
void <code class="sig-name descname">pci_dev_put</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a use of the pci device structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device that’s been disconnected</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called when a user of a device is finished with it.  When the last
user of the device calls this function, the memory of the device is freed.</p>
</div>
<dl class="function">
<dt id="c.pci_stop_and_remove_bus_device">
void <code class="sig-name descname">pci_stop_and_remove_bus_device</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_stop_and_remove_bus_device" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a PCI device and any children</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the device to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a PCI device from the device lists, informing the drivers
that the device has been removed.  We also remove any subordinate
buses and children in a depth-first manner.</p>
<p>For each device we remove, delete the device structure from the
device lists, remove the /proc entry, and notify userspace
(/sbin/hotplug).</p>
</div>
<dl class="function">
<dt id="c.pci_find_bus">
struct pci_bus * <code class="sig-name descname">pci_find_bus</code><span class="sig-paren">(</span>int<em> domain</em>, int<em> busnr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>locate PCI bus from a given domain and bus number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">domain</span></code></dt><dd><p>number of PCI domain to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">busnr</span></code></dt><dd><p>number of desired PCI bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI bus number and domain number, the desired PCI bus is located
in the global list of PCI buses.  If the bus is found, a pointer to its
data structure is returned.  If no bus is found, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
</div>
<dl class="function">
<dt id="c.pci_find_next_bus">
struct pci_bus * <code class="sig-name descname">pci_find_next_bus</code><span class="sig-paren">(</span>const struct pci_bus<em> *from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_next_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>begin or continue searching for a PCI bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*from</span></code></dt><dd><p>Previous PCI bus found, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for new search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI buses.  A new search is
initiated by passing <code class="docutils literal notranslate"><span class="pre">NULL</span></code> as the <strong>from</strong> argument.  Otherwise if
<strong>from</strong> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, searches continue from next device on the
global list.</p>
</div>
<dl class="function">
<dt id="c.pci_get_slot">
struct pci_dev * <code class="sig-name descname">pci_get_slot</code><span class="sig-paren">(</span>struct pci_bus<em> *bus</em>, unsigned int<em> devfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>locate PCI device for a given PCI slot</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>PCI bus on which desired PCI device resides</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">devfn</span></code></dt><dd><p>encodes number of PCI slot in which the desired PCI
device resides and the logical device number within that slot
in case of multi-function devices.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI bus and slot/function number, the desired PCI device
is located in the list of PCI devices.
If the device is found, its reference count is increased and this
function returns a pointer to its data structure.  The caller must
decrement the reference count by calling <a class="reference internal" href="#c.pci_dev_put" title="pci_dev_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_dev_put()</span></code></a>.
If no device is found, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
</div>
<dl class="function">
<dt id="c.pci_get_domain_bus_and_slot">
struct pci_dev * <code class="sig-name descname">pci_get_domain_bus_and_slot</code><span class="sig-paren">(</span>int<em> domain</em>, unsigned int<em> bus</em>, unsigned int<em> devfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_domain_bus_and_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>locate PCI device for a given PCI domain (segment), bus, and slot</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">domain</span></code></dt><dd><p>PCI domain/segment on which the PCI device resides.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bus</span></code></dt><dd><p>PCI bus on which desired PCI device resides</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">devfn</span></code></dt><dd><p>encodes number of PCI slot in which the desired PCI device
resides and the logical device number within that slot in case of
multi-function devices.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI domain, bus, and slot/function number, the desired PCI
device is located in the list of PCI devices. If the device is
found, its reference count is increased and this function returns a
pointer to its data structure.  The caller must decrement the
reference count by calling <a class="reference internal" href="#c.pci_dev_put" title="pci_dev_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_dev_put()</span></code></a>.  If no device is found,
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.</p>
</div>
<dl class="function">
<dt id="c.pci_get_subsys">
struct pci_dev * <code class="sig-name descname">pci_get_subsys</code><span class="sig-paren">(</span>unsigned int<em> vendor</em>, unsigned int<em> device</em>, unsigned int<em> ss_vendor</em>, unsigned int<em> ss_device</em>, struct pci_dev<em> *from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_subsys" title="Permalink to this definition">¶</a></dt>
<dd><p>begin or continue searching for a PCI device by vendor/subvendor/device/subdevice id</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vendor</span></code></dt><dd><p>PCI vendor id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all vendor ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>PCI device id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all device ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ss_vendor</span></code></dt><dd><p>PCI subsystem vendor id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all vendor ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ss_device</span></code></dt><dd><p>PCI subsystem device id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all device ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*from</span></code></dt><dd><p>Previous PCI device found in search, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for new search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI devices.  If a PCI device is found
with a matching <strong>vendor</strong>, <strong>device</strong>, <strong>ss_vendor</strong> and <strong>ss_device</strong>, a pointer to its
device structure is returned, and the reference count to the device is
incremented.  Otherwise, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.  A new search is initiated by
passing <code class="docutils literal notranslate"><span class="pre">NULL</span></code> as the <strong>from</strong> argument.  Otherwise if <strong>from</strong> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>,
searches continue from next device on the global list.
The reference count for <strong>from</strong> is always decremented if it is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="function">
<dt id="c.pci_get_device">
struct pci_dev * <code class="sig-name descname">pci_get_device</code><span class="sig-paren">(</span>unsigned int<em> vendor</em>, unsigned int<em> device</em>, struct pci_dev<em> *from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>begin or continue searching for a PCI device by vendor/device id</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vendor</span></code></dt><dd><p>PCI vendor id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all vendor ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>PCI device id to match, or <code class="docutils literal notranslate"><span class="pre">PCI_ANY_ID</span></code> to match all device ids</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*from</span></code></dt><dd><p>Previous PCI device found in search, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for new search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI devices.  If a PCI device is
found with a matching <strong>vendor</strong> and <strong>device</strong>, the reference count to the
device is incremented and a pointer to its device structure is returned.
Otherwise, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.  A new search is initiated by passing <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
as the <strong>from</strong> argument.  Otherwise if <strong>from</strong> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, searches continue
from next device on the global list.  The reference count for <strong>from</strong> is
always decremented if it is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="function">
<dt id="c.pci_get_class">
struct pci_dev * <code class="sig-name descname">pci_get_class</code><span class="sig-paren">(</span>unsigned int<em> class</em>, struct pci_dev<em> *from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_class" title="Permalink to this definition">¶</a></dt>
<dd><p>begin or continue searching for a PCI device by class</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">class</span></code></dt><dd><p>search for a PCI device with this class designation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*from</span></code></dt><dd><p>Previous PCI device found in search, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for new search.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI devices.  If a PCI device is
found with a matching <strong>class</strong>, the reference count to the device is
incremented and a pointer to its device structure is returned.
Otherwise, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.
A new search is initiated by passing <code class="docutils literal notranslate"><span class="pre">NULL</span></code> as the <strong>from</strong> argument.
Otherwise if <strong>from</strong> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, searches continue from next device
on the global list.  The reference count for <strong>from</strong> is always decremented
if it is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</div>
<dl class="function">
<dt id="c.pci_dev_present">
int <code class="sig-name descname">pci_dev_present</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id">pci_device_id</a><em> *ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_present" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if device matching the device list is present, 0 if not.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_device_id</span> <span class="pre">*ids</span></code></dt><dd><p>A pointer to a null terminated list of <a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_device_id</span></code></a> structures
that describe the type of PCI device the caller is trying to find.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obvious fact: You do not have a reference to any device that might be found
by this function, so if that device is removed from the system right after
this function is finished, the value will be stale.  Use this function to
find devices that are usually built into a system, or for a general hint as
to if another device happens to be present at this specific moment in time.</p>
</div>
<dl class="function">
<dt id="c.pci_msi_mask_irq">
void <code class="sig-name descname">pci_msi_mask_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../core-api/genericirq.html#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_mask_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic IRQ chip callback to mask PCI/MSI interrupts</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>pointer to irqdata associated to that interrupt</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pci_msi_unmask_irq">
void <code class="sig-name descname">pci_msi_unmask_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../core-api/genericirq.html#c.irq_data" title="irq_data">irq_data</a><em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_unmask_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic IRQ chip callback to unmask PCI/MSI interrupts</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*data</span></code></dt><dd><p>pointer to irqdata associated to that interrupt</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pci_msi_vec_count">
int <code class="sig-name descname">pci_msi_vec_count</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_vec_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of MSI vectors a device can send</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device to report about</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the number of MSI vectors a device requested via
Multiple Message Capable register. It returns a negative errno if the
device is not capable sending MSI interrupts. Otherwise, the call succeeds
and returns a power of two, up to a maximum of 2^5 (32), according to the
MSI specification.</p>
</div>
<dl class="function">
<dt id="c.pci_bus_alloc_resource">
int <code class="sig-name descname">pci_bus_alloc_resource</code><span class="sig-paren">(</span>struct pci_bus<em> *bus</em>, struct resource<em> *res</em>, resource_size_t<em> size</em>, resource_size_t<em> align</em>, resource_size_t<em> min</em>, unsigned long<em> type_mask</em>, resource_size_t (<em>*alignf</em>)(void *, const struct resource *, resource_size_t, resource_size_t), void<em> *alignf_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_alloc_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a resource from a parent bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>PCI bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*res</span></code></dt><dd><p>resource to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>size of resource to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">align</span></code></dt><dd><p>alignment of resource to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">min</span></code></dt><dd><p>minimum /proc/iomem address to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">type_mask</span></code></dt><dd><p>IORESOURCE_* type flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">(*alignf)(void</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*,</span> <span class="pre">resource_size_t,</span> <span class="pre">resource_size_t)</span></code></dt><dd><p>resource alignment function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*alignf_data</span></code></dt><dd><p>data argument for resource alignment function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given the PCI bus a device resides on, the size, minimum address,
alignment and type, try to find an acceptable resource allocation
for a specific device resource.</p>
</div>
<dl class="function">
<dt id="c.pci_bus_add_device">
void <code class="sig-name descname">pci_bus_add_device</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_add_device" title="Permalink to this definition">¶</a></dt>
<dd><p>start driver for a single device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>device to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds add sysfs entries and start device drivers</p>
</div>
<dl class="function">
<dt id="c.pci_bus_add_devices">
void <code class="sig-name descname">pci_bus_add_devices</code><span class="sig-paren">(</span>const struct pci_bus<em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_add_devices" title="Permalink to this definition">¶</a></dt>
<dd><p>start driver for PCI devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>bus to check for new devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start driver for PCI devices and add some sysfs entries.</p>
</div>
<dl class="function">
<dt id="c.pci_bus_set_ops">
struct pci_ops * <code class="sig-name descname">pci_bus_set_ops</code><span class="sig-paren">(</span>struct pci_bus<em> *bus</em>, struct pci_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_set_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Set raw operations of pci bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>pci bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_ops</span> <span class="pre">*ops</span></code></dt><dd><p>new raw operations</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return previous raw operations</p>
</div>
<dl class="function">
<dt id="c.pci_cfg_access_lock">
void <code class="sig-name descname">pci_cfg_access_lock</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_cfg_access_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock PCI config reads/writes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pci device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When access is locked, any userspace reads or writes to config
space and concurrent lock requests will sleep until access is
allowed via <a class="reference internal" href="#c.pci_cfg_access_unlock" title="pci_cfg_access_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_cfg_access_unlock()</span></code></a> again.</p>
</div>
<dl class="function">
<dt id="c.pci_cfg_access_trylock">
bool <code class="sig-name descname">pci_cfg_access_trylock</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_cfg_access_trylock" title="Permalink to this definition">¶</a></dt>
<dd><p>try to lock PCI config reads/writes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pci device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as pci_cfg_access_lock, but will return 0 if access is
already locked, 1 otherwise. This function can be used from
atomic contexts.</p>
</div>
<dl class="function">
<dt id="c.pci_cfg_access_unlock">
void <code class="sig-name descname">pci_cfg_access_unlock</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_cfg_access_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock PCI config reads/writes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pci device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows PCI config accesses to resume.</p>
</div>
<dl class="function">
<dt id="c.pci_request_irq">
int <code class="sig-name descname">pci_request_irq</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, unsigned int<em> nr</em>, irq_handler_t<em> handler</em>, irq_handler_t<em> thread_fn</em>, void<em> *dev_id</em>, const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line for a PCI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>device-relative interrupt vector index (0-based).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt><dd><p>Function to be called when the IRQ occurs.
Primary handler for threaded interrupts.
If NULL and thread_fn != NULL the default primary handler is
installed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_handler_t</span> <span class="pre">thread_fn</span></code></dt><dd><p>Function called from the IRQ handler thread
If NULL, no IRQ thread is created</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>Cookie passed back to the handler function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>Printf-like format string naming the handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call allocates interrupt resources and enables the interrupt line and
IRQ handling. From the point this call is made <strong>handler</strong> and <strong>thread_fn</strong> may
be invoked.  All interrupts requested using this function might be shared.</p>
<p><strong>dev_id</strong> must not be NULL and must be globally unique.</p>
</div>
<dl class="function">
<dt id="c.pci_free_irq">
void <code class="sig-name descname">pci_free_irq</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, unsigned int<em> nr</em>, void<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_free_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with pci_request_irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>device-relative interrupt vector index (0-based).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>Device identity to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove an interrupt handler. The handler is removed and if the interrupt
line is no longer in use by any driver it is disabled.  The caller must
ensure the interrupt is disabled on the device before calling this function.
The function does not return until any executing interrupts for this IRQ
have completed.</p>
<p>This function must not be called from interrupt context.</p>
</div>
<dl class="function">
<dt id="c.pcie_relaxed_ordering_enabled">
bool <code class="sig-name descname">pcie_relaxed_ordering_enabled</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_relaxed_ordering_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Probe for PCIe relaxed ordering enable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>PCI device to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the device has enabled relaxed ordering attribute.</p>
</div>
<dl class="function">
<dt id="c.pci_scan_slot">
int <code class="sig-name descname">pci_scan_slot</code><span class="sig-paren">(</span>struct pci_bus<em> *bus</em>, int<em> devfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_scan_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan a PCI slot on a bus for devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>PCI bus to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devfn</span></code></dt><dd><p>slot number to scan (must have zero function)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan a PCI slot on the specified PCI bus for devices, adding
discovered devices to the <strong>bus-&gt;devices</strong> list.  New devices
will not have is_added set.</p>
<p>Returns the number of new devices found.</p>
</div>
<dl class="function">
<dt id="c.pci_scan_child_bus">
unsigned int <code class="sig-name descname">pci_scan_child_bus</code><span class="sig-paren">(</span>struct pci_bus<em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_scan_child_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan devices below a bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>Bus to scan for devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scans devices below <strong>bus</strong> including subordinate buses. Returns new
subordinate number including all the found devices.</p>
</div>
<dl class="function">
<dt id="c.pci_rescan_bus">
unsigned int <code class="sig-name descname">pci_rescan_bus</code><span class="sig-paren">(</span>struct pci_bus<em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_rescan_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan a PCI bus for devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>PCI bus to scan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan a PCI bus and child buses for new devices, add them,
and enable them.</p>
<p>Returns the max number of subordinate bus discovered.</p>
</div>
<dl class="function">
<dt id="c.pci_create_slot">
struct pci_slot * <code class="sig-name descname">pci_create_slot</code><span class="sig-paren">(</span>struct pci_bus<em> *parent</em>, int<em> slot_nr</em>, const char<em> *name</em>, struct hotplug_slot<em> *hotplug</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_create_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>create or increment refcount for physical PCI slot</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*parent</span></code></dt><dd><p>struct pci_bus of parent bridge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">slot_nr</span></code></dt><dd><p>PCI_SLOT(pci_dev-&gt;devfn) or -1 for placeholder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>user visible string presented in /sys/bus/pci/slots/&lt;name&gt;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*hotplug</span></code></dt><dd><p>set if caller is hotplug driver, NULL otherwise</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>PCI slots have first class attributes such as address, speed, width,
and a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span></code> is used to manage them. This interface will
either return a new <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span></code> to the caller, or if the pci_slot
already exists, its refcount will be incremented.</p>
<p>Slots are uniquely identified by a <strong>pci_bus</strong>, <strong>slot_nr</strong> tuple.</p>
<p>There are known platforms with broken firmware that assign the same
name to multiple slots. Workaround these broken platforms by renaming
the slots on behalf of the caller. If firmware assigns name N to
multiple slots:</p>
<p>The first slot is assigned N
The second slot is assigned N-1
The third slot is assigned N-2
etc.</p>
<p>Placeholder slots:
In most cases, <strong>pci_bus</strong>, <strong>slot_nr</strong> will be sufficient to uniquely identify
a slot. There is one notable exception - pSeries (rpaphp), where the
<strong>slot_nr</strong> cannot be determined until a device is actually inserted into
the slot. In this scenario, the caller may pass -1 for <strong>slot_nr</strong>.</p>
<p>The following semantics are imposed when the caller passes <strong>slot_nr</strong> ==
-1. First, we no longer check for an existing <code class="docutils literal notranslate"><span class="pre">struct</span></code> pci_slot, as there
may be many slots with <strong>slot_nr</strong> of -1.  The other change in semantics is
user-visible, which is the ‘address’ parameter presented in sysfs will
consist solely of a dddd:bb tuple, where dddd is the PCI domain of the
<code class="docutils literal notranslate"><span class="pre">struct</span></code> pci_bus and bb is the bus number. In other words, the devfn of
the ‘placeholder’ slot will not be displayed.</p>
</div>
<dl class="function">
<dt id="c.pci_destroy_slot">
void <code class="sig-name descname">pci_destroy_slot</code><span class="sig-paren">(</span>struct pci_slot<em> *slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_destroy_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement refcount for physical PCI slot</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*slot</span></code></dt><dd><p>struct pci_slot to decrement</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span></code> pci_slot is refcounted, so destroying them is really easy; we
just call kobject_put on its kobj and let our release methods do the
rest.</p>
</div>
<dl class="function">
<dt id="c.pci_hp_create_module_link">
void <code class="sig-name descname">pci_hp_create_module_link</code><span class="sig-paren">(</span>struct pci_slot<em> *pci_slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_create_module_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create symbolic link to hotplug driver module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*pci_slot</span></code></dt><dd><p>struct pci_slot</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for pci_hotplug_core.c to create symbolic link to
the hotplug driver module.</p>
</div>
<dl class="function">
<dt id="c.pci_hp_remove_module_link">
void <code class="sig-name descname">pci_hp_remove_module_link</code><span class="sig-paren">(</span>struct pci_slot<em> *pci_slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_remove_module_link" title="Permalink to this definition">¶</a></dt>
<dd><p>remove symbolic link to the hotplug driver module.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*pci_slot</span></code></dt><dd><p>struct pci_slot</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for pci_hotplug_core.c to remove symbolic link to
the hotplug driver module.</p>
</div>
<dl class="function">
<dt id="c.pci_enable_rom">
int <code class="sig-name descname">pci_enable_rom</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>enable ROM decoding for a PCI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable ROM decoding on <strong>dev</strong>.  This involves simply turning on the last
bit of the PCI ROM BAR.  Note that some cards may share address decoders
between the ROM and other resources, so enabling it may disable access
to MMIO registers or other card memory.</p>
</div>
<dl class="function">
<dt id="c.pci_disable_rom">
void <code class="sig-name descname">pci_disable_rom</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_disable_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>disable ROM decoding for a PCI device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable ROM decoding on a PCI device by turning off the last bit in the
ROM BAR.</p>
</div>
<dl class="function">
<dt id="c.pci_map_rom">
void __iomem * <code class="sig-name descname">pci_map_rom</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, size_t<em> *size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_map_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>map a PCI ROM to kernel space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>pointer to pci device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*size</span></code></dt><dd><p>pointer to receive size of pci window over ROM</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>kernel virtual pointer to image of ROM</p>
<p><strong>Description</strong></p>
<p>Map a PCI ROM into kernel space. If ROM is boot video ROM,
the shadow BIOS copy will be returned instead of the
actual ROM.</p>
</div>
<dl class="function">
<dt id="c.pci_unmap_rom">
void <code class="sig-name descname">pci_unmap_rom</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, void __iomem<em> *rom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_unmap_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap the ROM from kernel space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>pointer to pci device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*rom</span></code></dt><dd><p>virtual address of the previous mapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a mapping of a previously mapped ROM</p>
</div>
<dl class="function">
<dt id="c.pci_iov_get_pf_drvdata">
void * <code class="sig-name descname">pci_iov_get_pf_drvdata</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, struct <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver">pci_driver</a><em> *pf_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_iov_get_pf_drvdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the drvdata of a PF</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>VF pci_dev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span> <span class="pre">*pf_driver</span></code></dt><dd><p>Device driver required to own the PF</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called from a context that ensures that a VF driver is attached.
The value returned is invalid once the VF driver completes its remove()
callback.</p>
<p>Locking is achieved by the driver core. A VF driver cannot be probed until
<a class="reference internal" href="#c.pci_enable_sriov" title="pci_enable_sriov"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_sriov()</span></code></a> is called and <a class="reference internal" href="#c.pci_disable_sriov" title="pci_disable_sriov"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_disable_sriov()</span></code></a> does not return until
all VF drivers have completed their remove().</p>
<p>The PF driver must call <a class="reference internal" href="#c.pci_disable_sriov" title="pci_disable_sriov"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_disable_sriov()</span></code></a> before it begins to destroy the
drvdata.</p>
</div>
<dl class="function">
<dt id="c.pci_enable_sriov">
int <code class="sig-name descname">pci_enable_sriov</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, int<em> nr_virtfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_sriov" title="Permalink to this definition">¶</a></dt>
<dd><p>enable the SR-IOV capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_virtfn</span></code></dt><dd><p>number of virtual functions to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, or negative on failure.</p>
</div>
<dl class="function">
<dt id="c.pci_disable_sriov">
void <code class="sig-name descname">pci_disable_sriov</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_disable_sriov" title="Permalink to this definition">¶</a></dt>
<dd><p>disable the SR-IOV capability</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pci_num_vf">
int <code class="sig-name descname">pci_num_vf</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_num_vf" title="Permalink to this definition">¶</a></dt>
<dd><p>return number of VFs associated with a PF device_release_driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of VFs, or 0 if SR-IOV is not enabled.</p>
</div>
<dl class="function">
<dt id="c.pci_vfs_assigned">
int <code class="sig-name descname">pci_vfs_assigned</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_vfs_assigned" title="Permalink to this definition">¶</a></dt>
<dd><p>returns number of VFs are assigned to a guest</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of VFs belonging to this device that are assigned to a guest.
If device is not a physical function returns 0.</p>
</div>
<dl class="function">
<dt id="c.pci_sriov_set_totalvfs">
int <code class="sig-name descname">pci_sriov_set_totalvfs</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, u16<em> numvfs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_sriov_set_totalvfs" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>reduce the TotalVFs available</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI PF device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">numvfs</span></code></dt><dd><p>number that should be used for TotalVFs supported</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from PF driver’s probe routine with
device’s mutex held.</p>
<p>Returns 0 if PF is an SRIOV-capable device and
value of numvfs valid. If not a PF return -ENOSYS;
if numvfs is invalid return -EINVAL;
if VFs already enabled, return -EBUSY.</p>
</div>
<dl class="function">
<dt id="c.pci_sriov_get_totalvfs">
int <code class="sig-name descname">pci_sriov_get_totalvfs</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_sriov_get_totalvfs" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>get total VFs supported on this device</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI PF device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For a PCIe device with SRIOV support, return the PCIe
SRIOV capability value of TotalVFs or the value of driver_max_VFs
if the driver reduced it.  Otherwise 0.</p>
</div>
<dl class="function">
<dt id="c.pci_sriov_configure_simple">
int <code class="sig-name descname">pci_sriov_configure_simple</code><span class="sig-paren">(</span>struct pci_dev<em> *dev</em>, int<em> nr_virtfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_sriov_configure_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to configure SR-IOV</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*dev</span></code></dt><dd><p>the PCI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_virtfn</span></code></dt><dd><p>number of virtual functions to enable, 0 to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable or disable SR-IOV for devices that don’t require any PF setup
before enabling SR-IOV.  Return value is negative on error, or number of
VFs allocated on success.</p>
</div>
<dl class="function">
<dt id="c.pci_read_legacy_io">
ssize_t <code class="sig-name descname">pci_read_legacy_io</code><span class="sig-paren">(</span>struct file<em> *filp</em>, struct kobject<em> *kobj</em>, struct bin_attribute<em> *bin_attr</em>, char<em> *buf</em>, loff_t<em> off</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_read_legacy_io" title="Permalink to this definition">¶</a></dt>
<dd><p>read byte(s) from legacy I/O port space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>open sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject corresponding to file to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*bin_attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to store results</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt><dd><p>offset into legacy I/O port space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific
callback routine (pci_legacy_read).</p>
</div>
<dl class="function">
<dt id="c.pci_write_legacy_io">
ssize_t <code class="sig-name descname">pci_write_legacy_io</code><span class="sig-paren">(</span>struct file<em> *filp</em>, struct kobject<em> *kobj</em>, struct bin_attribute<em> *bin_attr</em>, char<em> *buf</em>, loff_t<em> off</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_write_legacy_io" title="Permalink to this definition">¶</a></dt>
<dd><p>write byte(s) to legacy I/O port space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>open sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject corresponding to file to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*bin_attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer containing value to be written</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt><dd><p>offset into legacy I/O port space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific
callback routine (pci_legacy_write).</p>
</div>
<dl class="function">
<dt id="c.pci_mmap_legacy_mem">
int <code class="sig-name descname">pci_mmap_legacy_mem</code><span class="sig-paren">(</span>struct file<em> *filp</em>, struct kobject<em> *kobj</em>, struct bin_attribute<em> *attr</em>, struct vm_area_struct<em> *vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_mmap_legacy_mem" title="Permalink to this definition">¶</a></dt>
<dd><p>map legacy PCI memory into user memory space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>open sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject corresponding to device to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>struct vm_area_struct passed to mmap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses an arch specific callback, pci_mmap_legacy_mem_page_range, to mmap
legacy memory space (first meg of bus space) into application virtual
memory space.</p>
</div>
<dl class="function">
<dt id="c.pci_mmap_legacy_io">
int <code class="sig-name descname">pci_mmap_legacy_io</code><span class="sig-paren">(</span>struct file<em> *filp</em>, struct kobject<em> *kobj</em>, struct bin_attribute<em> *attr</em>, struct vm_area_struct<em> *vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_mmap_legacy_io" title="Permalink to this definition">¶</a></dt>
<dd><p>map legacy PCI IO into user memory space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>open sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject corresponding to device to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>struct vm_area_struct passed to mmap</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses an arch specific callback, pci_mmap_legacy_io_page_range, to mmap
legacy IO space (first meg of bus space) into application virtual
memory space. Returns -ENOSYS if the operation isn’t supported</p>
</div>
<dl class="function">
<dt id="c.pci_adjust_legacy_attr">
void <code class="sig-name descname">pci_adjust_legacy_attr</code><span class="sig-paren">(</span>struct pci_bus<em> *b</em>, enum pci_mmap_state<em> mmap_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_adjust_legacy_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>adjustment of legacy file attributes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*b</span></code></dt><dd><p>bus to create files under</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pci_mmap_state</span> <span class="pre">mmap_type</span></code></dt><dd><p>I/O port or memory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stub implementation. Can be overridden by arch if necessary.</p>
</div>
<dl class="function">
<dt id="c.pci_create_legacy_files">
void <code class="sig-name descname">pci_create_legacy_files</code><span class="sig-paren">(</span>struct pci_bus<em> *b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_create_legacy_files" title="Permalink to this definition">¶</a></dt>
<dd><p>create legacy I/O port and memory files</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*b</span></code></dt><dd><p>bus to create files under</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some platforms allow access to legacy I/O port and ISA memory space on
a per-bus basis.  This routine creates the files and ties them into
their associated read, write and mmap files from pci-sysfs.c</p>
<p>On error unwind, but don’t propagate the error to the caller
as it is ok to set up the PCI bus without these files.</p>
</div>
<dl class="function">
<dt id="c.pci_mmap_resource">
int <code class="sig-name descname">pci_mmap_resource</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, struct bin_attribute<em> *attr</em>, struct vm_area_struct<em> *vma</em>, int<em> write_combine</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_mmap_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>map a PCI resource into user memory space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject for mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*attr</span></code></dt><dd><p>struct bin_attribute for the file being mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>struct vm_area_struct passed into the mmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">write_combine</span></code></dt><dd><p>1 for write_combine mapping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the regular PCI mapping routines to map a PCI resource into userspace.</p>
</div>
<dl class="function">
<dt id="c.pci_remove_resource_files">
void <code class="sig-name descname">pci_remove_resource_files</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_remove_resource_files" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup resource files</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>dev to cleanup</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If we created resource files for <strong>pdev</strong>, remove them from sysfs and
free their resources.</p>
</div>
<dl class="function">
<dt id="c.pci_create_resource_files">
int <code class="sig-name descname">pci_create_resource_files</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_create_resource_files" title="Permalink to this definition">¶</a></dt>
<dd><p>create resource files in sysfs for <strong>dev</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>dev in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the resources in <strong>pdev</strong> creating files for each resource available.</p>
</div>
<dl class="function">
<dt id="c.pci_write_rom">
ssize_t <code class="sig-name descname">pci_write_rom</code><span class="sig-paren">(</span>struct file<em> *filp</em>, struct kobject<em> *kobj</em>, struct bin_attribute<em> *bin_attr</em>, char<em> *buf</em>, loff_t<em> off</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_write_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>used to enable access to the PCI ROM display</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kernel object handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*bin_attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>user input</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt><dd><p>file offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of byte in input</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>writing anything except 0 enables it</p>
</div>
<dl class="function">
<dt id="c.pci_read_rom">
ssize_t <code class="sig-name descname">pci_read_rom</code><span class="sig-paren">(</span>struct file<em> *filp</em>, struct kobject<em> *kobj</em>, struct bin_attribute<em> *bin_attr</em>, char<em> *buf</em>, loff_t<em> off</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_read_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>read a PCI ROM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>sysfs file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kernel object handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*bin_attr</span></code></dt><dd><p>struct bin_attribute for this file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>where to put the data we read from the ROM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt><dd><p>file offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Put <strong>count</strong> bytes starting at <strong>off</strong> into <strong>buf</strong> from the ROM in the PCI
device corresponding to <strong>kobj</strong>.</p>
</div>
<dl class="function">
<dt id="c.pci_remove_sysfs_dev_files">
void <code class="sig-name descname">pci_remove_sysfs_dev_files</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_remove_sysfs_dev_files" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup PCI specific sysfs files</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>device whose entries we should free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup when <strong>pdev</strong> is removed from sysfs.</p>
</div>
</section>
<section id="pci-hotplug-support-library">
<h1>PCI Hotplug Support Library<a class="headerlink" href="#pci-hotplug-support-library" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="c.__pci_hp_register">
int <code class="sig-name descname">__pci_hp_register</code><span class="sig-paren">(</span>struct hotplug_slot<em> *slot</em>, struct pci_bus<em> *bus</em>, int<em> devnr</em>, const char<em> *name</em>, struct module<em> *owner</em>, const char<em> *mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_hp_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a hotplug_slot with the PCI hotplug subsystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>bus this slot is on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devnr</span></code></dt><dd><p>device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name registered with kobject core</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>caller module owner</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>caller module name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepares a hotplug slot for in-kernel use and immediately publishes it to
user space in one go.  Drivers may alternatively carry out the two steps
separately by invoking pci_hp_initialize() and <a class="reference internal" href="#c.pci_hp_add" title="pci_hp_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_hp_add()</span></code></a>.</p>
<p>Returns 0 if successful, anything else for an error.</p>
</div>
<dl class="function">
<dt id="c.__pci_hp_initialize">
int <code class="sig-name descname">__pci_hp_initialize</code><span class="sig-paren">(</span>struct hotplug_slot<em> *slot</em>, struct pci_bus<em> *bus</em>, int<em> devnr</em>, const char<em> *name</em>, struct module<em> *owner</em>, const char<em> *mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_hp_initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare hotplug slot for in-kernel use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*bus</span></code></dt><dd><p>bus this slot is on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devnr</span></code></dt><dd><p>slot number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name registered with kobject core</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>caller module owner</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>caller module name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and fill in a PCI slot for use by a hotplug driver.  Once this has
been called, the driver may invoke hotplug_slot_name() to get the slot’s
unique name.  The driver must be prepared to handle a -&gt;reset_slot callback
from this point on.</p>
<p>Returns 0 on success or a negative int on error.</p>
</div>
<dl class="function">
<dt id="c.pci_hp_add">
int <code class="sig-name descname">pci_hp_add</code><span class="sig-paren">(</span>struct hotplug_slot<em> *slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_add" title="Permalink to this definition">¶</a></dt>
<dd><p>publish hotplug slot to user space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to publish</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make a hotplug slot’s sysfs interface available and inform user space of its
addition by sending a uevent.  The hotplug driver must be prepared to handle
all <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot_ops</span></code> callbacks from this point on.</p>
<p>Returns 0 on success or a negative int on error.</p>
</div>
<dl class="function">
<dt id="c.pci_hp_deregister">
void <code class="sig-name descname">pci_hp_deregister</code><span class="sig-paren">(</span>struct hotplug_slot<em> *slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_deregister" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a hotplug_slot with the PCI hotplug subsystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to deregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>slot</strong> must have been registered with the pci hotplug subsystem
previously with a call to pci_hp_register().</p>
<p>Returns 0 if successful, anything else for an error.</p>
</div>
<dl class="function">
<dt id="c.pci_hp_del">
void <code class="sig-name descname">pci_hp_del</code><span class="sig-paren">(</span>struct hotplug_slot<em> *slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_del" title="Permalink to this definition">¶</a></dt>
<dd><p>unpublish hotplug slot from user space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to unpublish</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a hotplug slot’s sysfs interface.</p>
<p>Returns 0 on success or a negative int on error.</p>
</div>
<dl class="function">
<dt id="c.pci_hp_destroy">
void <code class="sig-name descname">pci_hp_destroy</code><span class="sig-paren">(</span>struct hotplug_slot<em> *slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>remove hotplug slot from in-kernel use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*slot</span></code></dt><dd><p>pointer to the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to destroy</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroy a PCI slot used by a hotplug driver.  Once this has been called,
the driver may no longer invoke hotplug_slot_name() to get the slot’s
unique name.  The driver no longer needs to handle a -&gt;reset_slot callback
from this point on.</p>
<p>Returns 0 on success or a negative int on error.</p>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">PCI Support Library</a></li>
<li><a class="reference internal" href="#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/pci/pci.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/pci/pci.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>