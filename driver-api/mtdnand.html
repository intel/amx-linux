
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>MTD NAND Driver Programming Interface &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Parallel Port Devices" href="miscellaneous.html" />
    <link rel="prev" title="The Common Mailbox Framework" href="mailbox.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="mtd-nand-driver-programming-interface">
<h1>MTD NAND Driver Programming Interface<a class="headerlink" href="#mtd-nand-driver-programming-interface" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Thomas Gleixner</p>
</dd>
</dl>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The generic NAND driver supports almost all NAND and AG-AND based chips
and connects them to the Memory Technology Devices (MTD) subsystem of
the Linux Kernel.</p>
<p>This documentation is provided for developers who want to implement
board drivers or filesystem drivers suitable for NAND devices.</p>
</section>
<section id="known-bugs-and-assumptions">
<h2>Known Bugs And Assumptions<a class="headerlink" href="#known-bugs-and-assumptions" title="Permalink to this headline">¶</a></h2>
<p>None.</p>
</section>
<section id="documentation-hints">
<h2>Documentation hints<a class="headerlink" href="#documentation-hints" title="Permalink to this headline">¶</a></h2>
<p>The function and structure docs are autogenerated. Each function and
struct member has a short description which is marked with an [XXX]
identifier. The following chapters explain the meaning of those
identifiers.</p>
<section id="function-identifiers-xxx">
<h3>Function identifiers [XXX]<a class="headerlink" href="#function-identifiers-xxx" title="Permalink to this headline">¶</a></h3>
<p>The functions are marked with [XXX] identifiers in the short comment.
The identifiers explain the usage and scope of the functions. Following
identifiers are used:</p>
<ul>
<li><p>[MTD Interface]</p>
<p>These functions provide the interface to the MTD kernel API. They are
not replaceable and provide functionality which is complete hardware
independent.</p>
</li>
<li><p>[NAND Interface]</p>
<p>These functions are exported and provide the interface to the NAND
kernel API.</p>
</li>
<li><p>[GENERIC]</p>
<p>Generic functions are not replaceable and provide functionality which
is complete hardware independent.</p>
</li>
<li><p>[DEFAULT]</p>
<p>Default functions provide hardware related functionality which is
suitable for most of the implementations. These functions can be
replaced by the board driver if necessary. Those functions are called
via pointers in the NAND chip description structure. The board driver
can set the functions which should be replaced by board dependent
functions before calling nand_scan(). If the function pointer is
NULL on entry to nand_scan() then the pointer is set to the default
function which is suitable for the detected chip type.</p>
</li>
</ul>
</section>
<section id="struct-member-identifiers-xxx">
<h3>Struct member identifiers [XXX]<a class="headerlink" href="#struct-member-identifiers-xxx" title="Permalink to this headline">¶</a></h3>
<p>The struct members are marked with [XXX] identifiers in the comment. The
identifiers explain the usage and scope of the members. Following
identifiers are used:</p>
<ul>
<li><p>[INTERN]</p>
<p>These members are for NAND driver internal use only and must not be
modified. Most of these values are calculated from the chip geometry
information which is evaluated during nand_scan().</p>
</li>
<li><p>[REPLACEABLE]</p>
<p>Replaceable members hold hardware related functions which can be
provided by the board driver. The board driver can set the functions
which should be replaced by board dependent functions before calling
nand_scan(). If the function pointer is NULL on entry to
nand_scan() then the pointer is set to the default function which is
suitable for the detected chip type.</p>
</li>
<li><p>[BOARDSPECIFIC]</p>
<p>Board specific members hold hardware related information which must
be provided by the board driver. The board driver must set the
function pointers and datafields before calling nand_scan().</p>
</li>
<li><p>[OPTIONAL]</p>
<p>Optional members can hold information relevant for the board driver.
The generic NAND driver code does not use this information.</p>
</li>
</ul>
</section>
</section>
<section id="basic-board-driver">
<h2>Basic board driver<a class="headerlink" href="#basic-board-driver" title="Permalink to this headline">¶</a></h2>
<p>For most boards it will be sufficient to provide just the basic
functions and fill out some really board dependent members in the nand
chip description structure.</p>
<section id="basic-defines">
<h3>Basic defines<a class="headerlink" href="#basic-defines" title="Permalink to this headline">¶</a></h3>
<p>At least you have to provide a nand_chip structure and a storage for
the ioremap’ed chip address. You can allocate the nand_chip structure
using kmalloc or you can allocate it statically. The NAND chip structure
embeds an mtd structure which will be registered to the MTD subsystem.
You can extract a pointer to the mtd structure from a nand_chip pointer
using the nand_to_mtd() helper.</p>
<p>Kmalloc based example</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct mtd_info *board_mtd;
static void __iomem *baseaddr;
</pre></div>
</div>
<p>Static example</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct nand_chip board_chip;
static void __iomem *baseaddr;
</pre></div>
</div>
</section>
<section id="partition-defines">
<h3>Partition defines<a class="headerlink" href="#partition-defines" title="Permalink to this headline">¶</a></h3>
<p>If you want to divide your device into partitions, then define a
partitioning scheme suitable to your board.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define NUM_PARTITIONS 2
static struct mtd_partition partition_info[] = {
    { .name = &quot;Flash partition 1&quot;,
      .offset =  0,
      .size =    8 * 1024 * 1024 },
    { .name = &quot;Flash partition 2&quot;,
      .offset =  MTDPART_OFS_NEXT,
      .size =    MTDPART_SIZ_FULL },
};
</pre></div>
</div>
</section>
<section id="hardware-control-function">
<h3>Hardware control function<a class="headerlink" href="#hardware-control-function" title="Permalink to this headline">¶</a></h3>
<p>The hardware control function provides access to the control pins of the
NAND chip(s). The access can be done by GPIO pins or by address lines.
If you use address lines, make sure that the timing requirements are
met.</p>
<p><em>GPIO based example</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void board_hwcontrol(struct mtd_info *mtd, int cmd)
{
    switch(cmd){
        case NAND_CTL_SETCLE: /* Set CLE pin high */ break;
        case NAND_CTL_CLRCLE: /* Set CLE pin low */ break;
        case NAND_CTL_SETALE: /* Set ALE pin high */ break;
        case NAND_CTL_CLRALE: /* Set ALE pin low */ break;
        case NAND_CTL_SETNCE: /* Set nCE pin low */ break;
        case NAND_CTL_CLRNCE: /* Set nCE pin high */ break;
    }
}
</pre></div>
</div>
<p><em>Address lines based example.</em> It’s assumed that the nCE pin is driven
by a chip select decoder.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void board_hwcontrol(struct mtd_info *mtd, int cmd)
{
    struct nand_chip *this = mtd_to_nand(mtd);
    switch(cmd){
        case NAND_CTL_SETCLE: this-&gt;legacy.IO_ADDR_W |= CLE_ADRR_BIT;  break;
        case NAND_CTL_CLRCLE: this-&gt;legacy.IO_ADDR_W &amp;= ~CLE_ADRR_BIT; break;
        case NAND_CTL_SETALE: this-&gt;legacy.IO_ADDR_W |= ALE_ADRR_BIT;  break;
        case NAND_CTL_CLRALE: this-&gt;legacy.IO_ADDR_W &amp;= ~ALE_ADRR_BIT; break;
    }
}
</pre></div>
</div>
</section>
<section id="device-ready-function">
<h3>Device ready function<a class="headerlink" href="#device-ready-function" title="Permalink to this headline">¶</a></h3>
<p>If the hardware interface has the ready busy pin of the NAND chip
connected to a GPIO or other accessible I/O pin, this function is used
to read back the state of the pin. The function has no arguments and
should return 0, if the device is busy (R/B pin is low) and 1, if the
device is ready (R/B pin is high). If the hardware interface does not
give access to the ready busy pin, then the function must not be defined
and the function pointer this-&gt;legacy.dev_ready is set to NULL.</p>
</section>
<section id="init-function">
<h3>Init function<a class="headerlink" href="#init-function" title="Permalink to this headline">¶</a></h3>
<p>The init function allocates memory and sets up all the board specific
parameters and function pointers. When everything is set up nand_scan()
is called. This function tries to detect and identify then chip. If a
chip is found all the internal data fields are initialized accordingly.
The structure(s) have to be zeroed out first and then filled with the
necessary information about the device.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int __init board_init (void)
{
    struct nand_chip *this;
    int err = 0;

    /* Allocate memory for MTD device structure and private data */
    this = kzalloc(sizeof(struct nand_chip), GFP_KERNEL);
    if (!this) {
        printk (&quot;Unable to allocate NAND MTD device structure.\n&quot;);
        err = -ENOMEM;
        goto out;
    }

    board_mtd = nand_to_mtd(this);

    /* map physical address */
    baseaddr = ioremap(CHIP_PHYSICAL_ADDRESS, 1024);
    if (!baseaddr) {
        printk(&quot;Ioremap to access NAND chip failed\n&quot;);
        err = -EIO;
        goto out_mtd;
    }

    /* Set address of NAND IO lines */
    this-&gt;legacy.IO_ADDR_R = baseaddr;
    this-&gt;legacy.IO_ADDR_W = baseaddr;
    /* Reference hardware control function */
    this-&gt;hwcontrol = board_hwcontrol;
    /* Set command delay time, see datasheet for correct value */
    this-&gt;legacy.chip_delay = CHIP_DEPENDEND_COMMAND_DELAY;
    /* Assign the device ready function, if available */
    this-&gt;legacy.dev_ready = board_dev_ready;
    this-&gt;eccmode = NAND_ECC_SOFT;

    /* Scan to find existence of the device */
    if (nand_scan (this, 1)) {
        err = -ENXIO;
        goto out_ior;
    }

    add_mtd_partitions(board_mtd, partition_info, NUM_PARTITIONS);
    goto out;

out_ior:
    iounmap(baseaddr);
out_mtd:
    kfree (this);
out:
    return err;
}
module_init(board_init);
</pre></div>
</div>
</section>
<section id="exit-function">
<h3>Exit function<a class="headerlink" href="#exit-function" title="Permalink to this headline">¶</a></h3>
<p>The exit function is only necessary if the driver is compiled as a
module. It releases all resources which are held by the chip driver and
unregisters the partitions in the MTD layer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#ifdef MODULE
static void __exit board_cleanup (void)
{
    /* Unregister device */
    WARN_ON(mtd_device_unregister(board_mtd));
    /* Release resources */
    nand_cleanup(mtd_to_nand(board_mtd));

    /* unmap physical address */
    iounmap(baseaddr);

    /* Free the MTD device structure */
    kfree (mtd_to_nand(board_mtd));
}
module_exit(board_cleanup);
#endif
</pre></div>
</div>
</section>
</section>
<section id="advanced-board-driver-functions">
<h2>Advanced board driver functions<a class="headerlink" href="#advanced-board-driver-functions" title="Permalink to this headline">¶</a></h2>
<p>This chapter describes the advanced functionality of the NAND driver.
For a list of functions which can be overridden by the board driver see
the documentation of the nand_chip structure.</p>
<section id="multiple-chip-control">
<h3>Multiple chip control<a class="headerlink" href="#multiple-chip-control" title="Permalink to this headline">¶</a></h3>
<p>The nand driver can control chip arrays. Therefore the board driver must
provide an own select_chip function. This function must (de)select the
requested chip. The function pointer in the nand_chip structure must be
set before calling nand_scan(). The maxchip parameter of nand_scan()
defines the maximum number of chips to scan for. Make sure that the
select_chip function can handle the requested number of chips.</p>
<p>The nand driver concatenates the chips to one virtual chip and provides
this virtual chip to the MTD layer.</p>
<p><em>Note: The driver can only handle linear chip arrays of equally sized
chips. There is no support for parallel arrays which extend the
buswidth.</em></p>
<p><em>GPIO based example</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void board_select_chip (struct mtd_info *mtd, int chip)
{
    /* Deselect all chips, set all nCE pins high */
    GPIO(BOARD_NAND_NCE) |= 0xff;
    if (chip &gt;= 0)
        GPIO(BOARD_NAND_NCE) &amp;= ~ (1 &lt;&lt; chip);
}
</pre></div>
</div>
<p><em>Address lines based example.</em> Its assumed that the nCE pins are
connected to an address decoder.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void board_select_chip (struct mtd_info *mtd, int chip)
{
    struct nand_chip *this = mtd_to_nand(mtd);

    /* Deselect all chips */
    this-&gt;legacy.IO_ADDR_R &amp;= ~BOARD_NAND_ADDR_MASK;
    this-&gt;legacy.IO_ADDR_W &amp;= ~BOARD_NAND_ADDR_MASK;
    switch (chip) {
    case 0:
        this-&gt;legacy.IO_ADDR_R |= BOARD_NAND_ADDR_CHIP0;
        this-&gt;legacy.IO_ADDR_W |= BOARD_NAND_ADDR_CHIP0;
        break;
    ....
    case n:
        this-&gt;legacy.IO_ADDR_R |= BOARD_NAND_ADDR_CHIPn;
        this-&gt;legacy.IO_ADDR_W |= BOARD_NAND_ADDR_CHIPn;
        break;
    }
}
</pre></div>
</div>
</section>
<section id="hardware-ecc-support">
<h3>Hardware ECC support<a class="headerlink" href="#hardware-ecc-support" title="Permalink to this headline">¶</a></h3>
<section id="functions-and-constants">
<h4>Functions and constants<a class="headerlink" href="#functions-and-constants" title="Permalink to this headline">¶</a></h4>
<p>The nand driver supports three different types of hardware ECC.</p>
<ul>
<li><p>NAND_ECC_HW3_256</p>
<p>Hardware ECC generator providing 3 bytes ECC per 256 byte.</p>
</li>
<li><p>NAND_ECC_HW3_512</p>
<p>Hardware ECC generator providing 3 bytes ECC per 512 byte.</p>
</li>
<li><p>NAND_ECC_HW6_512</p>
<p>Hardware ECC generator providing 6 bytes ECC per 512 byte.</p>
</li>
<li><p>NAND_ECC_HW8_512</p>
<p>Hardware ECC generator providing 8 bytes ECC per 512 byte.</p>
</li>
</ul>
<p>If your hardware generator has a different functionality add it at the
appropriate place in nand_base.c</p>
<p>The board driver must provide following functions:</p>
<ul>
<li><p>enable_hwecc</p>
<p>This function is called before reading / writing to the chip. Reset
or initialize the hardware generator in this function. The function
is called with an argument which let you distinguish between read and
write operations.</p>
</li>
<li><p>calculate_ecc</p>
<p>This function is called after read / write from / to the chip.
Transfer the ECC from the hardware to the buffer. If the option
NAND_HWECC_SYNDROME is set then the function is only called on
write. See below.</p>
</li>
<li><p>correct_data</p>
<p>In case of an ECC error this function is called for error detection
and correction. Return 1 respectively 2 in case the error can be
corrected. If the error is not correctable return -1. If your
hardware generator matches the default algorithm of the nand_ecc
software generator then use the correction function provided by
nand_ecc instead of implementing duplicated code.</p>
</li>
</ul>
</section>
<section id="hardware-ecc-with-syndrome-calculation">
<h4>Hardware ECC with syndrome calculation<a class="headerlink" href="#hardware-ecc-with-syndrome-calculation" title="Permalink to this headline">¶</a></h4>
<p>Many hardware ECC implementations provide Reed-Solomon codes and
calculate an error syndrome on read. The syndrome must be converted to a
standard Reed-Solomon syndrome before calling the error correction code
in the generic Reed-Solomon library.</p>
<p>The ECC bytes must be placed immediately after the data bytes in order
to make the syndrome generator work. This is contrary to the usual
layout used by software ECC. The separation of data and out of band area
is not longer possible. The nand driver code handles this layout and the
remaining free bytes in the oob area are managed by the autoplacement
code. Provide a matching oob-layout in this case. See rts_from4.c and
diskonchip.c for implementation reference. In those cases we must also
use bad block tables on FLASH, because the ECC layout is interfering
with the bad block marker positions. See bad block table support for
details.</p>
</section>
</section>
<section id="bad-block-table-support">
<h3>Bad block table support<a class="headerlink" href="#bad-block-table-support" title="Permalink to this headline">¶</a></h3>
<p>Most NAND chips mark the bad blocks at a defined position in the spare
area. Those blocks must not be erased under any circumstances as the bad
block information would be lost. It is possible to check the bad block
mark each time when the blocks are accessed by reading the spare area of
the first page in the block. This is time consuming so a bad block table
is used.</p>
<p>The nand driver supports various types of bad block tables.</p>
<ul>
<li><p>Per device</p>
<p>The bad block table contains all bad block information of the device
which can consist of multiple chips.</p>
</li>
<li><p>Per chip</p>
<p>A bad block table is used per chip and contains the bad block
information for this particular chip.</p>
</li>
<li><p>Fixed offset</p>
<p>The bad block table is located at a fixed offset in the chip
(device). This applies to various DiskOnChip devices.</p>
</li>
<li><p>Automatic placed</p>
<p>The bad block table is automatically placed and detected either at
the end or at the beginning of a chip (device)</p>
</li>
<li><p>Mirrored tables</p>
<p>The bad block table is mirrored on the chip (device) to allow updates
of the bad block table without data loss.</p>
</li>
</ul>
<p>nand_scan() calls the function nand_default_bbt().
nand_default_bbt() selects appropriate default bad block table
descriptors depending on the chip information which was retrieved by
nand_scan().</p>
<p>The standard policy is scanning the device for bad blocks and build a
ram based bad block table which allows faster access than always
checking the bad block information on the flash chip itself.</p>
<section id="flash-based-tables">
<h4>Flash based tables<a class="headerlink" href="#flash-based-tables" title="Permalink to this headline">¶</a></h4>
<p>It may be desired or necessary to keep a bad block table in FLASH. For
AG-AND chips this is mandatory, as they have no factory marked bad
blocks. They have factory marked good blocks. The marker pattern is
erased when the block is erased to be reused. So in case of powerloss
before writing the pattern back to the chip this block would be lost and
added to the bad blocks. Therefore we scan the chip(s) when we detect
them the first time for good blocks and store this information in a bad
block table before erasing any of the blocks.</p>
<p>The blocks in which the tables are stored are protected against
accidental access by marking them bad in the memory bad block table. The
bad block table management functions are allowed to circumvent this
protection.</p>
<p>The simplest way to activate the FLASH based bad block table support is
to set the option NAND_BBT_USE_FLASH in the bbt_option field of the
nand chip structure before calling nand_scan(). For AG-AND chips is
this done by default. This activates the default FLASH based bad block
table functionality of the NAND driver. The default bad block table
options are</p>
<ul class="simple">
<li><p>Store bad block table per chip</p></li>
<li><p>Use 2 bits per block</p></li>
<li><p>Automatic placement at the end of the chip</p></li>
<li><p>Use mirrored tables with version numbers</p></li>
<li><p>Reserve 4 blocks at the end of the chip</p></li>
</ul>
</section>
<section id="user-defined-tables">
<h4>User defined tables<a class="headerlink" href="#user-defined-tables" title="Permalink to this headline">¶</a></h4>
<p>User defined tables are created by filling out a nand_bbt_descr
structure and storing the pointer in the nand_chip structure member
bbt_td before calling nand_scan(). If a mirror table is necessary a
second structure must be created and a pointer to this structure must be
stored in bbt_md inside the nand_chip structure. If the bbt_md member
is set to NULL then only the main table is used and no scan for the
mirrored table is performed.</p>
<p>The most important field in the nand_bbt_descr structure is the
options field. The options define most of the table properties. Use the
predefined constants from rawnand.h to define the options.</p>
<ul>
<li><p>Number of bits per block</p>
<p>The supported number of bits is 1, 2, 4, 8.</p>
</li>
<li><p>Table per chip</p>
<p>Setting the constant NAND_BBT_PERCHIP selects that a bad block
table is managed for each chip in a chip array. If this option is not
set then a per device bad block table is used.</p>
</li>
<li><p>Table location is absolute</p>
<p>Use the option constant NAND_BBT_ABSPAGE and define the absolute
page number where the bad block table starts in the field pages. If
you have selected bad block tables per chip and you have a multi chip
array then the start page must be given for each chip in the chip
array. Note: there is no scan for a table ident pattern performed, so
the fields pattern, veroffs, offs, len can be left uninitialized</p>
</li>
<li><p>Table location is automatically detected</p>
<p>The table can either be located in the first or the last good blocks
of the chip (device). Set NAND_BBT_LASTBLOCK to place the bad block
table at the end of the chip (device). The bad block tables are
marked and identified by a pattern which is stored in the spare area
of the first page in the block which holds the bad block table. Store
a pointer to the pattern in the pattern field. Further the length of
the pattern has to be stored in len and the offset in the spare area
must be given in the offs member of the nand_bbt_descr structure.
For mirrored bad block tables different patterns are mandatory.</p>
</li>
<li><p>Table creation</p>
<p>Set the option NAND_BBT_CREATE to enable the table creation if no
table can be found during the scan. Usually this is done only once if
a new chip is found.</p>
</li>
<li><p>Table write support</p>
<p>Set the option NAND_BBT_WRITE to enable the table write support.
This allows the update of the bad block table(s) in case a block has
to be marked bad due to wear. The MTD interface function
block_markbad is calling the update function of the bad block table.
If the write support is enabled then the table is updated on FLASH.</p>
<p>Note: Write support should only be enabled for mirrored tables with
version control.</p>
</li>
<li><p>Table version control</p>
<p>Set the option NAND_BBT_VERSION to enable the table version
control. It’s highly recommended to enable this for mirrored tables
with write support. It makes sure that the risk of losing the bad
block table information is reduced to the loss of the information
about the one worn out block which should be marked bad. The version
is stored in 4 consecutive bytes in the spare area of the device. The
position of the version number is defined by the member veroffs in
the bad block table descriptor.</p>
</li>
<li><p>Save block contents on write</p>
<p>In case that the block which holds the bad block table does contain
other useful information, set the option NAND_BBT_SAVECONTENT. When
the bad block table is written then the whole block is read the bad
block table is updated and the block is erased and everything is
written back. If this option is not set only the bad block table is
written and everything else in the block is ignored and erased.</p>
</li>
<li><p>Number of reserved blocks</p>
<p>For automatic placement some blocks must be reserved for bad block
table storage. The number of reserved blocks is defined in the
maxblocks member of the bad block table description structure.
Reserving 4 blocks for mirrored tables should be a reasonable number.
This also limits the number of blocks which are scanned for the bad
block table ident pattern.</p>
</li>
</ul>
</section>
</section>
<section id="spare-area-auto-placement">
<h3>Spare area (auto)placement<a class="headerlink" href="#spare-area-auto-placement" title="Permalink to this headline">¶</a></h3>
<p>The nand driver implements different possibilities for placement of
filesystem data in the spare area,</p>
<ul class="simple">
<li><p>Placement defined by fs driver</p></li>
<li><p>Automatic placement</p></li>
</ul>
<p>The default placement function is automatic placement. The nand driver
has built in default placement schemes for the various chiptypes. If due
to hardware ECC functionality the default placement does not fit then
the board driver can provide a own placement scheme.</p>
<p>File system drivers can provide a own placement scheme which is used
instead of the default placement scheme.</p>
<p>Placement schemes are defined by a nand_oobinfo structure</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_oobinfo {
    int useecc;
    int eccbytes;
    int eccpos[24];
    int oobfree[8][2];
};
</pre></div>
</div>
<ul>
<li><p>useecc</p>
<p>The useecc member controls the ecc and placement function. The header
file include/mtd/mtd-abi.h contains constants to select ecc and
placement. MTD_NANDECC_OFF switches off the ecc complete. This is
not recommended and available for testing and diagnosis only.
MTD_NANDECC_PLACE selects caller defined placement,
MTD_NANDECC_AUTOPLACE selects automatic placement.</p>
</li>
<li><p>eccbytes</p>
<p>The eccbytes member defines the number of ecc bytes per page.</p>
</li>
<li><p>eccpos</p>
<p>The eccpos array holds the byte offsets in the spare area where the
ecc codes are placed.</p>
</li>
<li><p>oobfree</p>
<p>The oobfree array defines the areas in the spare area which can be
used for automatic placement. The information is given in the format
{offset, size}. offset defines the start of the usable area, size the
length in bytes. More than one area can be defined. The list is
terminated by an {0, 0} entry.</p>
</li>
</ul>
<section id="placement-defined-by-fs-driver">
<h4>Placement defined by fs driver<a class="headerlink" href="#placement-defined-by-fs-driver" title="Permalink to this headline">¶</a></h4>
<p>The calling function provides a pointer to a nand_oobinfo structure
which defines the ecc placement. For writes the caller must provide a
spare area buffer along with the data buffer. The spare area buffer size
is (number of pages) * (size of spare area). For reads the buffer size
is (number of pages) * ((size of spare area) + (number of ecc steps per
page) * sizeof (int)). The driver stores the result of the ecc check
for each tuple in the spare buffer. The storage sequence is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;spare data page 0&gt;&lt;ecc result 0&gt;...&lt;ecc result n&gt;

...

&lt;spare data page n&gt;&lt;ecc result 0&gt;...&lt;ecc result n&gt;
</pre></div>
</div>
<p>This is a legacy mode used by YAFFS1.</p>
<p>If the spare area buffer is NULL then only the ECC placement is done
according to the given scheme in the nand_oobinfo structure.</p>
</section>
<section id="automatic-placement">
<h4>Automatic placement<a class="headerlink" href="#automatic-placement" title="Permalink to this headline">¶</a></h4>
<p>Automatic placement uses the built in defaults to place the ecc bytes in
the spare area. If filesystem data have to be stored / read into the
spare area then the calling function must provide a buffer. The buffer
size per page is determined by the oobfree array in the nand_oobinfo
structure.</p>
<p>If the spare area buffer is NULL then only the ECC placement is done
according to the default builtin scheme.</p>
</section>
</section>
<section id="spare-area-autoplacement-default-schemes">
<h3>Spare area autoplacement default schemes<a class="headerlink" href="#spare-area-autoplacement-default-schemes" title="Permalink to this headline">¶</a></h3>
<section id="byte-pagesize">
<h4>256 byte pagesize<a class="headerlink" href="#byte-pagesize" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 23%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Content</p></th>
<th class="head"><p>Comment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00</p></td>
<td><p>ECC byte 0</p></td>
<td><p>Error correction code byte 0</p></td>
</tr>
<tr class="row-odd"><td><p>0x01</p></td>
<td><p>ECC byte 1</p></td>
<td><p>Error correction code byte 1</p></td>
</tr>
<tr class="row-even"><td><p>0x02</p></td>
<td><p>ECC byte 2</p></td>
<td><p>Error correction code byte 2</p></td>
</tr>
<tr class="row-odd"><td><p>0x03</p></td>
<td><p>Autoplace 0</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0x04</p></td>
<td><p>Autoplace 1</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0x05</p></td>
<td><p>Bad block marker</p></td>
<td><p>If any bit in this byte is zero, then this
block is bad. This applies only to the first
page in a block. In the remaining pages this
byte is reserved</p></td>
</tr>
<tr class="row-even"><td><p>0x06</p></td>
<td><p>Autoplace 2</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0x07</p></td>
<td><p>Autoplace 3</p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="id1">
<h4>512 byte pagesize<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 23%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Content</p></th>
<th class="head"><p>Comment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00</p></td>
<td><p>ECC byte 0</p></td>
<td><p>Error correction code byte 0 of the lower
256 Byte data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x01</p></td>
<td><p>ECC byte 1</p></td>
<td><p>Error correction code byte 1 of the lower
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x02</p></td>
<td><p>ECC byte 2</p></td>
<td><p>Error correction code byte 2 of the lower
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x03</p></td>
<td><p>ECC byte 3</p></td>
<td><p>Error correction code byte 0 of the upper
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x04</p></td>
<td><p>reserved</p></td>
<td><p>reserved</p></td>
</tr>
<tr class="row-odd"><td><p>0x05</p></td>
<td><p>Bad block marker</p></td>
<td><p>If any bit in this byte is zero, then this
block is bad. This applies only to the first
page in a block. In the remaining pages this
byte is reserved</p></td>
</tr>
<tr class="row-even"><td><p>0x06</p></td>
<td><p>ECC byte 4</p></td>
<td><p>Error correction code byte 1 of the upper
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x07</p></td>
<td><p>ECC byte 5</p></td>
<td><p>Error correction code byte 2 of the upper
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x08 - 0x0F</p></td>
<td><p>Autoplace 0 - 7</p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="id2">
<h4>2048 byte pagesize<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 23%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Content</p></th>
<th class="head"><p>Comment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00</p></td>
<td><p>Bad block marker</p></td>
<td><p>If any bit in this byte is zero, then this block
is bad. This applies only to the first page in a
block. In the remaining pages this byte is
reserved</p></td>
</tr>
<tr class="row-odd"><td><p>0x01</p></td>
<td><p>Reserved</p></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-even"><td><p>0x02-0x27</p></td>
<td><p>Autoplace 0 - 37</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0x28</p></td>
<td><p>ECC byte 0</p></td>
<td><p>Error correction code byte 0 of the first
256 Byte data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x29</p></td>
<td><p>ECC byte 1</p></td>
<td><p>Error correction code byte 1 of the first
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x2A</p></td>
<td><p>ECC byte 2</p></td>
<td><p>Error correction code byte 2 of the first
256 Bytes data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x2B</p></td>
<td><p>ECC byte 3</p></td>
<td><p>Error correction code byte 0 of the second
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x2C</p></td>
<td><p>ECC byte 4</p></td>
<td><p>Error correction code byte 1 of the second
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x2D</p></td>
<td><p>ECC byte 5</p></td>
<td><p>Error correction code byte 2 of the second
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x2E</p></td>
<td><p>ECC byte 6</p></td>
<td><p>Error correction code byte 0 of the third
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x2F</p></td>
<td><p>ECC byte 7</p></td>
<td><p>Error correction code byte 1 of the third
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x30</p></td>
<td><p>ECC byte 8</p></td>
<td><p>Error correction code byte 2 of the third
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x31</p></td>
<td><p>ECC byte 9</p></td>
<td><p>Error correction code byte 0 of the fourth
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x32</p></td>
<td><p>ECC byte 10</p></td>
<td><p>Error correction code byte 1 of the fourth
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x33</p></td>
<td><p>ECC byte 11</p></td>
<td><p>Error correction code byte 2 of the fourth
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x34</p></td>
<td><p>ECC byte 12</p></td>
<td><p>Error correction code byte 0 of the fifth
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x35</p></td>
<td><p>ECC byte 13</p></td>
<td><p>Error correction code byte 1 of the fifth
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x36</p></td>
<td><p>ECC byte 14</p></td>
<td><p>Error correction code byte 2 of the fifth
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x37</p></td>
<td><p>ECC byte 15</p></td>
<td><p>Error correction code byte 0 of the sixth
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x38</p></td>
<td><p>ECC byte 16</p></td>
<td><p>Error correction code byte 1 of the sixth
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x39</p></td>
<td><p>ECC byte 17</p></td>
<td><p>Error correction code byte 2 of the sixth
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x3A</p></td>
<td><p>ECC byte 18</p></td>
<td><p>Error correction code byte 0 of the seventh
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x3B</p></td>
<td><p>ECC byte 19</p></td>
<td><p>Error correction code byte 1 of the seventh
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x3C</p></td>
<td><p>ECC byte 20</p></td>
<td><p>Error correction code byte 2 of the seventh
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x3D</p></td>
<td><p>ECC byte 21</p></td>
<td><p>Error correction code byte 0 of the eighth
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-odd"><td><p>0x3E</p></td>
<td><p>ECC byte 22</p></td>
<td><p>Error correction code byte 1 of the eighth
256 Bytes of data in this page</p></td>
</tr>
<tr class="row-even"><td><p>0x3F</p></td>
<td><p>ECC byte 23</p></td>
<td><p>Error correction code byte 2 of the eighth
256 Bytes of data in this page</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="filesystem-support">
<h2>Filesystem support<a class="headerlink" href="#filesystem-support" title="Permalink to this headline">¶</a></h2>
<p>The NAND driver provides all necessary functions for a filesystem via
the MTD interface.</p>
<p>Filesystems must be aware of the NAND peculiarities and restrictions.
One major restrictions of NAND Flash is, that you cannot write as often
as you want to a page. The consecutive writes to a page, before erasing
it again, are restricted to 1-3 writes, depending on the manufacturers
specifications. This applies similar to the spare area.</p>
<p>Therefore NAND aware filesystems must either write in page size chunks
or hold a writebuffer to collect smaller writes until they sum up to
pagesize. Available NAND aware filesystems: JFFS2, YAFFS.</p>
<p>The spare area usage to store filesystem data is controlled by the spare
area placement functionality which is described in one of the earlier
chapters.</p>
</section>
<section id="tools">
<h2>Tools<a class="headerlink" href="#tools" title="Permalink to this headline">¶</a></h2>
<p>The MTD project provides a couple of helpful tools to handle NAND Flash.</p>
<ul class="simple">
<li><p>flasherase, flasheraseall: Erase and format FLASH partitions</p></li>
<li><p>nandwrite: write filesystem images to NAND FLASH</p></li>
<li><p>nanddump: dump the contents of a NAND FLASH partitions</p></li>
</ul>
<p>These tools are aware of the NAND restrictions. Please use those tools
instead of complaining about errors which are caused by non NAND aware
access methods.</p>
</section>
<section id="constants">
<h2>Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h2>
<p>This chapter describes the constants which might be relevant for a
driver developer.</p>
<section id="chip-option-constants">
<h3>Chip option constants<a class="headerlink" href="#chip-option-constants" title="Permalink to this headline">¶</a></h3>
<section id="constants-for-chip-id-table">
<h4>Constants for chip id table<a class="headerlink" href="#constants-for-chip-id-table" title="Permalink to this headline">¶</a></h4>
<p>These constants are defined in rawnand.h. They are OR-ed together to
describe the chip functionality:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Buswitdh is 16 bit */
#define NAND_BUSWIDTH_16    0x00000002
/* Device supports partial programming without padding */
#define NAND_NO_PADDING     0x00000004
/* Chip has cache program function */
#define NAND_CACHEPRG       0x00000008
/* Chip has copy back function */
#define NAND_COPYBACK       0x00000010
/* AND Chip which has 4 banks and a confusing page / block
 * assignment. See Renesas datasheet for further information */
#define NAND_IS_AND     0x00000020
/* Chip has a array of 4 pages which can be read without
 * additional ready /busy waits */
#define NAND_4PAGE_ARRAY    0x00000040
</pre></div>
</div>
</section>
<section id="constants-for-runtime-options">
<h4>Constants for runtime options<a class="headerlink" href="#constants-for-runtime-options" title="Permalink to this headline">¶</a></h4>
<p>These constants are defined in rawnand.h. They are OR-ed together to
describe the functionality:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* The hw ecc generator provides a syndrome instead a ecc value on read
 * This can only work if we have the ecc bytes directly behind the
 * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
#define NAND_HWECC_SYNDROME 0x00020000
</pre></div>
</div>
</section>
</section>
<section id="ecc-selection-constants">
<h3>ECC selection constants<a class="headerlink" href="#ecc-selection-constants" title="Permalink to this headline">¶</a></h3>
<p>Use these constants to select the ECC algorithm:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* No ECC. Usage is not recommended ! */
#define NAND_ECC_NONE       0
/* Software ECC 3 byte ECC per 256 Byte data */
#define NAND_ECC_SOFT       1
/* Hardware ECC 3 byte ECC per 256 Byte data */
#define NAND_ECC_HW3_256    2
/* Hardware ECC 3 byte ECC per 512 Byte data */
#define NAND_ECC_HW3_512    3
/* Hardware ECC 6 byte ECC per 512 Byte data */
#define NAND_ECC_HW6_512    4
/* Hardware ECC 8 byte ECC per 512 Byte data */
#define NAND_ECC_HW8_512    6
</pre></div>
</div>
</section>
<section id="hardware-control-related-constants">
<h3>Hardware control related constants<a class="headerlink" href="#hardware-control-related-constants" title="Permalink to this headline">¶</a></h3>
<p>These constants describe the requested hardware access function when the
boardspecific hardware control function is called:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Select the chip by setting nCE to low */
#define NAND_CTL_SETNCE     1
/* Deselect the chip by setting nCE to high */
#define NAND_CTL_CLRNCE     2
/* Select the command latch by setting CLE to high */
#define NAND_CTL_SETCLE     3
/* Deselect the command latch by setting CLE to low */
#define NAND_CTL_CLRCLE     4
/* Select the address latch by setting ALE to high */
#define NAND_CTL_SETALE     5
/* Deselect the address latch by setting ALE to low */
#define NAND_CTL_CLRALE     6
/* Set write protection by setting WP to high. Not used! */
#define NAND_CTL_SETWP      7
/* Clear write protection by setting WP to low. Not used! */
#define NAND_CTL_CLRWP      8
</pre></div>
</div>
</section>
<section id="bad-block-table-related-constants">
<h3>Bad block table related constants<a class="headerlink" href="#bad-block-table-related-constants" title="Permalink to this headline">¶</a></h3>
<p>These constants describe the options used for bad block table
descriptors:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Options for the bad block table descriptors */

/* The number of bits used per block in the bbt on the device */
#define NAND_BBT_NRBITS_MSK 0x0000000F
#define NAND_BBT_1BIT       0x00000001
#define NAND_BBT_2BIT       0x00000002
#define NAND_BBT_4BIT       0x00000004
#define NAND_BBT_8BIT       0x00000008
/* The bad block table is in the last good block of the device */
#define NAND_BBT_LASTBLOCK  0x00000010
/* The bbt is at the given page, else we must scan for the bbt */
#define NAND_BBT_ABSPAGE    0x00000020
/* bbt is stored per chip on multichip devices */
#define NAND_BBT_PERCHIP    0x00000080
/* bbt has a version counter at offset veroffs */
#define NAND_BBT_VERSION    0x00000100
/* Create a bbt if none axists */
#define NAND_BBT_CREATE     0x00000200
/* Write bbt if necessary */
#define NAND_BBT_WRITE      0x00001000
/* Read and write back block contents when writing bbt */
#define NAND_BBT_SAVECONTENT    0x00002000
</pre></div>
</div>
</section>
</section>
<section id="structures">
<h2>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h2>
<p>This chapter contains the autogenerated documentation of the structures
which are used in the NAND driver and might be relevant for a driver
developer. Each struct member has a short description which is marked
with an [XXX] identifier. See the chapter “Documentation hints” for an
explanation.</p>
<dl class="type">
<dt id="c.nand_parameters">
struct <code class="sig-name descname">nand_parameters</code><a class="headerlink" href="#c.nand_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND generic parameters from the parameter page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_parameters {
    const char *model;
    bool supports_set_get_features;
    unsigned long set_feature_list[BITS_TO_LONGS(ONFI_FEATURE_NUMBER)];
    unsigned long get_feature_list[BITS_TO_LONGS(ONFI_FEATURE_NUMBER)];
    struct onfi_params *onfi;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">model</span></code></dt><dd><p>Model name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supports_set_get_features</span></code></dt><dd><p>The NAND chip supports setting/getting features</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_feature_list</span></code></dt><dd><p>Bitmap of features that can be set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_feature_list</span></code></dt><dd><p>Bitmap of features that can be get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">onfi</span></code></dt><dd><p>ONFI specific parameters</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_id">
struct <code class="sig-name descname">nand_id</code><a class="headerlink" href="#c.nand_id" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND id structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_id {
    u8 data[NAND_MAX_ID_LEN];
    int len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>buffer containing the id bytes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>ID length.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_ecc_step_info">
struct <code class="sig-name descname">nand_ecc_step_info</code><a class="headerlink" href="#c.nand_ecc_step_info" title="Permalink to this definition">¶</a></dt>
<dd><p>ECC step information of ECC engine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_ecc_step_info {
    int stepsize;
    const int *strengths;
    int nstrengths;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">stepsize</span></code></dt><dd><p>data bytes per ECC step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">strengths</span></code></dt><dd><p>array of supported strengths</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nstrengths</span></code></dt><dd><p>number of supported strengths</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_ecc_caps">
struct <code class="sig-name descname">nand_ecc_caps</code><a class="headerlink" href="#c.nand_ecc_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>capability of ECC engine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_ecc_caps {
    const struct nand_ecc_step_info *stepinfos;
    int nstepinfos;
    int (*calc_ecc_bytes)(int step_size, int strength);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">stepinfos</span></code></dt><dd><p>array of ECC step information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nstepinfos</span></code></dt><dd><p>number of ECC step information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">calc_ecc_bytes</span></code></dt><dd><p>driver’s hook to calculate ECC bytes per step</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_ecc_ctrl">
struct <code class="sig-name descname">nand_ecc_ctrl</code><a class="headerlink" href="#c.nand_ecc_ctrl" title="Permalink to this definition">¶</a></dt>
<dd><p>Control structure for ECC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_ecc_ctrl {
    enum nand_ecc_engine_type engine_type;
    enum nand_ecc_placement placement;
    enum nand_ecc_algo algo;
    int steps;
    int size;
    int bytes;
    int total;
    int strength;
    int prepad;
    int postpad;
    unsigned int options;
    u8 *calc_buf;
    u8 *code_buf;
    void (*hwctl)(struct nand_chip *chip, int mode);
    int (*calculate)(struct nand_chip *chip, const uint8_t *dat, uint8_t *ecc_code);
    int (*correct)(struct nand_chip *chip, uint8_t *dat, uint8_t *read_ecc, uint8_t *calc_ecc);
    int (*read_page_raw)(struct nand_chip *chip, uint8_t *buf, int oob_required, int page);
    int (*write_page_raw)(struct nand_chip *chip, const uint8_t *buf, int oob_required, int page);
    int (*read_page)(struct nand_chip *chip, uint8_t *buf, int oob_required, int page);
    int (*read_subpage)(struct nand_chip *chip, uint32_t offs, uint32_t len, uint8_t *buf, int page);
    int (*write_subpage)(struct nand_chip *chip, uint32_t offset,uint32_t data_len, const uint8_t *data_buf, int oob_required, int page);
    int (*write_page)(struct nand_chip *chip, const uint8_t *buf, int oob_required, int page);
    int (*write_oob_raw)(struct nand_chip *chip, int page);
    int (*read_oob_raw)(struct nand_chip *chip, int page);
    int (*read_oob)(struct nand_chip *chip, int page);
    int (*write_oob)(struct nand_chip *chip, int page);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">engine_type</span></code></dt><dd><p>ECC engine type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">placement</span></code></dt><dd><p>OOB bytes placement</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">algo</span></code></dt><dd><p>ECC algorithm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">steps</span></code></dt><dd><p>number of ECC steps per page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>data bytes per ECC step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytes</span></code></dt><dd><p>ECC bytes per step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total</span></code></dt><dd><p>total number of ECC bytes per page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">strength</span></code></dt><dd><p>max number of correctible bits per ECC step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepad</span></code></dt><dd><p>padding information for syndrome based ECC generators</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">postpad</span></code></dt><dd><p>padding information for syndrome based ECC generators</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">options</span></code></dt><dd><p>ECC specific options (see NAND_ECC_XXX flags defined above)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">calc_buf</span></code></dt><dd><p>buffer for calculated ECC, size is oobsize.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code_buf</span></code></dt><dd><p>buffer for ECC read from flash, size is oobsize.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwctl</span></code></dt><dd><p>function to control hardware ECC generator. Must only
be provided if an hardware ECC is available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">calculate</span></code></dt><dd><p>function for ECC calculation or readback from ECC hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">correct</span></code></dt><dd><p>function for ECC correction, matching to ECC generator (sw/hw).
Should return a positive number representing the number of
corrected bitflips, -EBADMSG if the number of bitflips exceed
ECC strength, or any other error code if the error is not
directly related to correction.
If -EBADMSG is returned the input buffers should be left
untouched.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_page_raw</span></code></dt><dd><p>function to read a raw page without ECC. This function
should hide the specific layout used by the ECC
controller and always return contiguous in-band and
out-of-band data even if they’re not stored
contiguously on the NAND chip (e.g.
NAND_ECC_PLACEMENT_INTERLEAVED interleaves in-band and
out-of-band data).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_page_raw</span></code></dt><dd><p>function to write a raw page without ECC. This function
should hide the specific layout used by the ECC
controller and consider the passed data as contiguous
in-band and out-of-band data. ECC controller is
responsible for doing the appropriate transformations
to adapt to its specific layout (e.g.
NAND_ECC_PLACEMENT_INTERLEAVED interleaves in-band and
out-of-band data).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_page</span></code></dt><dd><p>function to read a page according to the ECC generator
requirements; returns maximum number of bitflips corrected in
any single ECC step, -EIO hw error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_subpage</span></code></dt><dd><p>function to read parts of the page covered by ECC;
returns same as read_page()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_subpage</span></code></dt><dd><p>function to write parts of the page covered by ECC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_page</span></code></dt><dd><p>function to write a page according to the ECC generator
requirements.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_oob_raw</span></code></dt><dd><p>function to write chip OOB data without ECC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_oob_raw</span></code></dt><dd><p>function to read chip OOB data without ECC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_oob</span></code></dt><dd><p>function to read chip OOB data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_oob</span></code></dt><dd><p>function to write chip OOB data</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_sdr_timings">
struct <code class="sig-name descname">nand_sdr_timings</code><a class="headerlink" href="#c.nand_sdr_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>SDR NAND chip timings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_sdr_timings {
    u64 tBERS_max;
    u32 tCCS_min;
    u64 tPROG_max;
    u64 tR_max;
    u32 tALH_min;
    u32 tADL_min;
    u32 tALS_min;
    u32 tAR_min;
    u32 tCEA_max;
    u32 tCEH_min;
    u32 tCH_min;
    u32 tCHZ_max;
    u32 tCLH_min;
    u32 tCLR_min;
    u32 tCLS_min;
    u32 tCOH_min;
    u32 tCS_min;
    u32 tDH_min;
    u32 tDS_min;
    u32 tFEAT_max;
    u32 tIR_min;
    u32 tITC_max;
    u32 tRC_min;
    u32 tREA_max;
    u32 tREH_min;
    u32 tRHOH_min;
    u32 tRHW_min;
    u32 tRHZ_max;
    u32 tRLOH_min;
    u32 tRP_min;
    u32 tRR_min;
    u64 tRST_max;
    u32 tWB_max;
    u32 tWC_min;
    u32 tWH_min;
    u32 tWHR_min;
    u32 tWP_min;
    u32 tWW_min;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tBERS_max</span></code></dt><dd><p>Block erase time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCCS_min</span></code></dt><dd><p>Change column setup time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tPROG_max</span></code></dt><dd><p>Page program time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tR_max</span></code></dt><dd><p>Page read time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tALH_min</span></code></dt><dd><p>ALE hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tADL_min</span></code></dt><dd><p>ALE to data loading time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tALS_min</span></code></dt><dd><p>ALE setup time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tAR_min</span></code></dt><dd><p>ALE to RE# delay</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCEA_max</span></code></dt><dd><p>CE# access time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCEH_min</span></code></dt><dd><p>CE# high hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCH_min</span></code></dt><dd><p>CE# hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCHZ_max</span></code></dt><dd><p>CE# high to output hi-Z</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCLH_min</span></code></dt><dd><p>CLE hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCLR_min</span></code></dt><dd><p>CLE to RE# delay</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCLS_min</span></code></dt><dd><p>CLE setup time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCOH_min</span></code></dt><dd><p>CE# high to output hold</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCS_min</span></code></dt><dd><p>CE# setup time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tDH_min</span></code></dt><dd><p>Data hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tDS_min</span></code></dt><dd><p>Data setup time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tFEAT_max</span></code></dt><dd><p>Busy time for Set Features and Get Features</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tIR_min</span></code></dt><dd><p>Output hi-Z to RE# low</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tITC_max</span></code></dt><dd><p>Interface and Timing Mode Change time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tRC_min</span></code></dt><dd><p>RE# cycle time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tREA_max</span></code></dt><dd><p>RE# access time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tREH_min</span></code></dt><dd><p>RE# high hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tRHOH_min</span></code></dt><dd><p>RE# high to output hold</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tRHW_min</span></code></dt><dd><p>RE# high to WE# low</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tRHZ_max</span></code></dt><dd><p>RE# high to output hi-Z</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tRLOH_min</span></code></dt><dd><p>RE# low to output hold</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tRP_min</span></code></dt><dd><p>RE# pulse width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tRR_min</span></code></dt><dd><p>Ready to RE# low (data only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tRST_max</span></code></dt><dd><p>Device reset time, measured from the falling edge of R/B# to the
rising edge of R/B#.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tWB_max</span></code></dt><dd><p>WE# high to SR[6] low</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tWC_min</span></code></dt><dd><p>WE# cycle time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tWH_min</span></code></dt><dd><p>WE# high hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tWHR_min</span></code></dt><dd><p>WE# high to RE# low</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tWP_min</span></code></dt><dd><p>WE# pulse width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tWW_min</span></code></dt><dd><p>WP# transition to WE# low</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct defines the timing requirements of a SDR NAND chip.
These information can be found in every NAND datasheets and the timings
meaning are described in the ONFI specifications:
<a class="reference external" href="https://media-www.micron.com/-/media/client/onfi/specs/onfi_3_1_spec.pdf">https://media-www.micron.com/-/media/client/onfi/specs/onfi_3_1_spec.pdf</a>
(chapter 4.15 Timing Parameters)</p>
<p>All these timings are expressed in picoseconds.</p>
<dl class="type">
<dt id="c.nand_nvddr_timings">
struct <code class="sig-name descname">nand_nvddr_timings</code><a class="headerlink" href="#c.nand_nvddr_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>NV-DDR NAND chip timings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_nvddr_timings {
    u64 tBERS_max;
    u32 tCCS_min;
    u64 tPROG_max;
    u64 tR_max;
    u32 tAC_min;
    u32 tAC_max;
    u32 tADL_min;
    u32 tCAD_min;
    u32 tCAH_min;
    u32 tCALH_min;
    u32 tCALS_min;
    u32 tCAS_min;
    u32 tCEH_min;
    u32 tCH_min;
    u32 tCK_min;
    u32 tCS_min;
    u32 tDH_min;
    u32 tDQSCK_min;
    u32 tDQSCK_max;
    u32 tDQSD_min;
    u32 tDQSD_max;
    u32 tDQSHZ_max;
    u32 tDQSQ_max;
    u32 tDS_min;
    u32 tDSC_min;
    u32 tFEAT_max;
    u32 tITC_max;
    u32 tQHS_max;
    u32 tRHW_min;
    u32 tRR_min;
    u32 tRST_max;
    u32 tWB_max;
    u32 tWHR_min;
    u32 tWRCK_min;
    u32 tWW_min;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tBERS_max</span></code></dt><dd><p>Block erase time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCCS_min</span></code></dt><dd><p>Change column setup time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tPROG_max</span></code></dt><dd><p>Page program time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tR_max</span></code></dt><dd><p>Page read time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tAC_min</span></code></dt><dd><p>Access window of DQ[7:0] from CLK</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tAC_max</span></code></dt><dd><p>Access window of DQ[7:0] from CLK</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tADL_min</span></code></dt><dd><p>ALE to data loading time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCAD_min</span></code></dt><dd><p>Command, Address, Data delay</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCAH_min</span></code></dt><dd><p>Command/Address DQ hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCALH_min</span></code></dt><dd><p>W/R_n, CLE and ALE hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCALS_min</span></code></dt><dd><p>W/R_n, CLE and ALE setup time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCAS_min</span></code></dt><dd><p>Command/address DQ setup time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCEH_min</span></code></dt><dd><p>CE# high hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCH_min</span></code></dt><dd><p>CE# hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCK_min</span></code></dt><dd><p>Average clock cycle time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tCS_min</span></code></dt><dd><p>CE# setup time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tDH_min</span></code></dt><dd><p>Data hold time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tDQSCK_min</span></code></dt><dd><p>Start of the access window of DQS from CLK</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tDQSCK_max</span></code></dt><dd><p>End of the access window of DQS from CLK</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tDQSD_min</span></code></dt><dd><p>Min W/R_n low to DQS/DQ driven by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tDQSD_max</span></code></dt><dd><p>Max W/R_n low to DQS/DQ driven by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tDQSHZ_max</span></code></dt><dd><p>W/R_n high to DQS/DQ tri-state by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tDQSQ_max</span></code></dt><dd><p>DQS-DQ skew, DQS to last DQ valid, per access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tDS_min</span></code></dt><dd><p>Data setup time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tDSC_min</span></code></dt><dd><p>DQS cycle time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tFEAT_max</span></code></dt><dd><p>Busy time for Set Features and Get Features</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tITC_max</span></code></dt><dd><p>Interface and Timing Mode Change time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tQHS_max</span></code></dt><dd><p>Data hold skew factor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tRHW_min</span></code></dt><dd><p>Data output cycle to command, address, or data input cycle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tRR_min</span></code></dt><dd><p>Ready to RE# low (data only)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tRST_max</span></code></dt><dd><p>Device reset time, measured from the falling edge of R/B# to the
rising edge of R/B#.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tWB_max</span></code></dt><dd><p>WE# high to SR[6] low</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tWHR_min</span></code></dt><dd><p>WE# high to RE# low</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tWRCK_min</span></code></dt><dd><p>W/R_n low to data output cycle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tWW_min</span></code></dt><dd><p>WP# transition to WE# low</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct defines the timing requirements of a NV-DDR NAND data interface.
These information can be found in every NAND datasheets and the timings
meaning are described in the ONFI specifications:
<a class="reference external" href="https://media-www.micron.com/-/media/client/onfi/specs/onfi_4_1_gold.pdf">https://media-www.micron.com/-/media/client/onfi/specs/onfi_4_1_gold.pdf</a>
(chapter 4.18.2 NV-DDR)</p>
<p>All these timings are expressed in picoseconds.</p>
<dl class="type">
<dt id="c.nand_interface_type">
enum <code class="sig-name descname">nand_interface_type</code><a class="headerlink" href="#c.nand_interface_type" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND interface type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">NAND_SDR_IFACE</span></code></dt><dd><p>Single Data Rate interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NAND_NVDDR_IFACE</span></code></dt><dd><p>Double Data Rate interface</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_interface_config">
struct <code class="sig-name descname">nand_interface_config</code><a class="headerlink" href="#c.nand_interface_config" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND interface timing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_interface_config {
    enum nand_interface_type type;
    struct nand_timings {
        unsigned int mode;
        union {
            struct nand_sdr_timings sdr;
            struct nand_nvddr_timings nvddr;
        };
    } timings;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of the timing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timings</span></code></dt><dd><p>The timing information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timings.mode</span></code></dt><dd><p>Timing mode as defined in the specification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timings.sdr</span></code></dt><dd><p>Use it when <strong>type</strong> is <code class="docutils literal notranslate"><span class="pre">NAND_SDR_IFACE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timings.nvddr</span></code></dt><dd><p>Use it when <strong>type</strong> is <code class="docutils literal notranslate"><span class="pre">NAND_NVDDR_IFACE</span></code>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_interface_is_sdr">
bool <code class="sig-name descname">nand_interface_is_sdr</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.nand_interface_config" title="nand_interface_config">nand_interface_config</a><em> *conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_interface_is_sdr" title="Permalink to this definition">¶</a></dt>
<dd><p>get the interface type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_interface_config</span> <span class="pre">*conf</span></code></dt><dd><p>The data interface</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_interface_is_nvddr">
bool <code class="sig-name descname">nand_interface_is_nvddr</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.nand_interface_config" title="nand_interface_config">nand_interface_config</a><em> *conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_interface_is_nvddr" title="Permalink to this definition">¶</a></dt>
<dd><p>get the interface type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_interface_config</span> <span class="pre">*conf</span></code></dt><dd><p>The data interface</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_get_sdr_timings">
const struct <a class="reference internal" href="#c.nand_sdr_timings" title="nand_sdr_timings">nand_sdr_timings</a> * <code class="sig-name descname">nand_get_sdr_timings</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.nand_interface_config" title="nand_interface_config">nand_interface_config</a><em> *conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_get_sdr_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>get SDR timing from data interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_interface_config</span> <span class="pre">*conf</span></code></dt><dd><p>The data interface</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_get_nvddr_timings">
const struct <a class="reference internal" href="#c.nand_nvddr_timings" title="nand_nvddr_timings">nand_nvddr_timings</a> * <code class="sig-name descname">nand_get_nvddr_timings</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.nand_interface_config" title="nand_interface_config">nand_interface_config</a><em> *conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_get_nvddr_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>get NV-DDR timing from data interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_interface_config</span> <span class="pre">*conf</span></code></dt><dd><p>The data interface</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_op_cmd_instr">
struct <code class="sig-name descname">nand_op_cmd_instr</code><a class="headerlink" href="#c.nand_op_cmd_instr" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition of a command instruction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_op_cmd_instr {
    u8 opcode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">opcode</span></code></dt><dd><p>the command to issue in one cycle</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_op_addr_instr">
struct <code class="sig-name descname">nand_op_addr_instr</code><a class="headerlink" href="#c.nand_op_addr_instr" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition of an address instruction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_op_addr_instr {
    unsigned int naddrs;
    const u8 *addrs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">naddrs</span></code></dt><dd><p>length of the <strong>addrs</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addrs</span></code></dt><dd><p>array containing the address cycles to issue</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_op_data_instr">
struct <code class="sig-name descname">nand_op_data_instr</code><a class="headerlink" href="#c.nand_op_data_instr" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition of a data instruction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_op_data_instr {
    unsigned int len;
    union {
        void *in;
        const void *out;
    } buf;
    bool force_8bit;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>number of data bytes to move</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>buffer to fill</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf.in</span></code></dt><dd><p>buffer to fill when reading from the NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf.out</span></code></dt><dd><p>buffer to read from when writing to the NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">force_8bit</span></code></dt><dd><p>force 8-bit access</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Please note that “in” and “out” are inverted from the ONFI specification
and are from the controller perspective, so a “in” is a read from the NAND
chip while a “out” is a write to the NAND chip.</p>
<dl class="type">
<dt id="c.nand_op_waitrdy_instr">
struct <code class="sig-name descname">nand_op_waitrdy_instr</code><a class="headerlink" href="#c.nand_op_waitrdy_instr" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition of a wait ready instruction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_op_waitrdy_instr {
    unsigned int timeout_ms;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">timeout_ms</span></code></dt><dd><p>maximum delay while waiting for the ready/busy pin in ms</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_op_instr_type">
enum <code class="sig-name descname">nand_op_instr_type</code><a class="headerlink" href="#c.nand_op_instr_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition of all instruction types</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">NAND_OP_CMD_INSTR</span></code></dt><dd><p>command instruction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NAND_OP_ADDR_INSTR</span></code></dt><dd><p>address instruction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NAND_OP_DATA_IN_INSTR</span></code></dt><dd><p>data in instruction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NAND_OP_DATA_OUT_INSTR</span></code></dt><dd><p>data out instruction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NAND_OP_WAITRDY_INSTR</span></code></dt><dd><p>wait ready instruction</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_op_instr">
struct <code class="sig-name descname">nand_op_instr</code><a class="headerlink" href="#c.nand_op_instr" title="Permalink to this definition">¶</a></dt>
<dd><p>Instruction object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_op_instr {
    enum nand_op_instr_type type;
    union {
        struct nand_op_cmd_instr cmd;
        struct nand_op_addr_instr addr;
        struct nand_op_data_instr data;
        struct nand_op_waitrdy_instr waitrdy;
    } ctx;
    unsigned int delay_ns;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the instruction type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx</span></code></dt><dd><p>extra data associated to the instruction. You’ll have to use the
appropriate element depending on <strong>type</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx.cmd</span></code></dt><dd><p>use it if <strong>type</strong> is <code class="docutils literal notranslate"><span class="pre">NAND_OP_CMD_INSTR</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx.addr</span></code></dt><dd><p>use it if <strong>type</strong> is <code class="docutils literal notranslate"><span class="pre">NAND_OP_ADDR_INSTR</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx.data</span></code></dt><dd><p>use it if <strong>type</strong> is <code class="docutils literal notranslate"><span class="pre">NAND_OP_DATA_IN_INSTR</span></code>
or <code class="docutils literal notranslate"><span class="pre">NAND_OP_DATA_OUT_INSTR</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx.waitrdy</span></code></dt><dd><p>use it if <strong>type</strong> is <code class="docutils literal notranslate"><span class="pre">NAND_OP_WAITRDY_INSTR</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delay_ns</span></code></dt><dd><p>delay the controller should apply after the instruction has been
issued on the bus. Most modern controllers have internal timings
control logic, and in this case, the controller driver can ignore
this field.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_subop">
struct <code class="sig-name descname">nand_subop</code><a class="headerlink" href="#c.nand_subop" title="Permalink to this definition">¶</a></dt>
<dd><p>a sub operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_subop {
    unsigned int cs;
    const struct nand_op_instr *instrs;
    unsigned int ninstrs;
    unsigned int first_instr_start_off;
    unsigned int last_instr_end_off;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cs</span></code></dt><dd><p>the CS line to select for this NAND sub-operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">instrs</span></code></dt><dd><p>array of instructions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ninstrs</span></code></dt><dd><p>length of the <strong>instrs</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">first_instr_start_off</span></code></dt><dd><p>offset to start from for the first instruction
of the sub-operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_instr_end_off</span></code></dt><dd><p>offset to end at (excluded) for the last instruction
of the sub-operation</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Both <strong>first_instr_start_off</strong> and <strong>last_instr_end_off</strong> only apply to data or
address instructions.</p>
<p>When an operation cannot be handled as is by the NAND controller, it will
be split by the parser into sub-operations which will be passed to the
controller driver.</p>
<dl class="type">
<dt id="c.nand_op_parser_addr_constraints">
struct <code class="sig-name descname">nand_op_parser_addr_constraints</code><a class="headerlink" href="#c.nand_op_parser_addr_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Constraints for address instructions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_op_parser_addr_constraints {
    unsigned int maxcycles;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">maxcycles</span></code></dt><dd><p>maximum number of address cycles the controller can issue in a
single step</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_op_parser_data_constraints">
struct <code class="sig-name descname">nand_op_parser_data_constraints</code><a class="headerlink" href="#c.nand_op_parser_data_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Constraints for data instructions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_op_parser_data_constraints {
    unsigned int maxlen;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">maxlen</span></code></dt><dd><p>maximum data length that the controller can handle in a single step</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_op_parser_pattern_elem">
struct <code class="sig-name descname">nand_op_parser_pattern_elem</code><a class="headerlink" href="#c.nand_op_parser_pattern_elem" title="Permalink to this definition">¶</a></dt>
<dd><p>One element of a pattern</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_op_parser_pattern_elem {
    enum nand_op_instr_type type;
    bool optional;
    union {
        struct nand_op_parser_addr_constraints addr;
        struct nand_op_parser_data_constraints data;
    } ctx;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the instructuction type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">optional</span></code></dt><dd><p>whether this element of the pattern is optional or mandatory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx</span></code></dt><dd><p>address or data constraint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx.addr</span></code></dt><dd><p>address constraint (number of cycles)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctx.data</span></code></dt><dd><p>data constraint (data length)</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_op_parser_pattern">
struct <code class="sig-name descname">nand_op_parser_pattern</code><a class="headerlink" href="#c.nand_op_parser_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND sub-operation pattern descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_op_parser_pattern {
    const struct nand_op_parser_pattern_elem *elems;
    unsigned int nelems;
    int (*exec)(struct nand_chip *chip, const struct nand_subop *subop);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">elems</span></code></dt><dd><p>array of pattern elements</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nelems</span></code></dt><dd><p>number of pattern elements in <strong>elems</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exec</span></code></dt><dd><p>the function that will issue a sub-operation</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A pattern is a list of elements, each element reprensenting one instruction
with its constraints. The pattern itself is used by the core to match NAND
chip operation with NAND controller operations.
Once a match between a NAND controller operation pattern and a NAND chip
operation (or a sub-set of a NAND operation) is found, the pattern -&gt;exec()
hook is called so that the controller driver can issue the operation on the
bus.</p>
<p>Controller drivers should declare as many patterns as they support and pass
this list of patterns (created with the help of the following macro) to
the <a class="reference internal" href="#c.nand_op_parser_exec_op" title="nand_op_parser_exec_op"><code class="xref c c-func docutils literal notranslate"><span class="pre">nand_op_parser_exec_op()</span></code></a> helper.</p>
<dl class="type">
<dt id="c.nand_op_parser">
struct <code class="sig-name descname">nand_op_parser</code><a class="headerlink" href="#c.nand_op_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND controller operation parser descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_op_parser {
    const struct nand_op_parser_pattern *patterns;
    unsigned int npatterns;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">patterns</span></code></dt><dd><p>array of supported patterns</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">npatterns</span></code></dt><dd><p>length of the <strong>patterns</strong> array</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The parser descriptor is just an array of supported patterns which will be
iterated by <a class="reference internal" href="#c.nand_op_parser_exec_op" title="nand_op_parser_exec_op"><code class="xref c c-func docutils literal notranslate"><span class="pre">nand_op_parser_exec_op()</span></code></a> everytime it tries to execute an
NAND operation (or tries to determine if a specific operation is supported).</p>
<p>It is worth mentioning that patterns will be tested in their declaration
order, and the first match will be taken, so it’s important to order patterns
appropriately so that simple/inefficient patterns are placed at the end of
the list. Usually, this is where you put single instruction patterns.</p>
<dl class="type">
<dt id="c.nand_operation">
struct <code class="sig-name descname">nand_operation</code><a class="headerlink" href="#c.nand_operation" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND operation descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_operation {
    unsigned int cs;
    const struct nand_op_instr *instrs;
    unsigned int ninstrs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cs</span></code></dt><dd><p>the CS line to select for this NAND operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">instrs</span></code></dt><dd><p>array of instructions to execute</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ninstrs</span></code></dt><dd><p>length of the <strong>instrs</strong> array</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The actual operation structure that will be passed to chip-&gt;exec_op().</p>
<dl class="type">
<dt id="c.nand_controller_ops">
struct <code class="sig-name descname">nand_controller_ops</code><a class="headerlink" href="#c.nand_controller_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Controller operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_controller_ops {
    int (*attach_chip)(struct nand_chip *chip);
    void (*detach_chip)(struct nand_chip *chip);
    int (*exec_op)(struct nand_chip *chip,const struct nand_operation *op, bool check_only);
    int (*setup_interface)(struct nand_chip *chip, int chipnr, const struct nand_interface_config *conf);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">attach_chip</span></code></dt><dd><p>this method is called after the NAND detection phase after
flash ID and MTD fields such as erase size, page size and OOB
size have been set up. ECC requirements are available if
provided by the NAND chip or device tree. Typically used to
choose the appropriate ECC configuration and allocate
associated resources.
This hook is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach_chip</span></code></dt><dd><p>free all resources allocated/claimed in
nand_controller_ops-&gt;attach_chip().
This hook is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exec_op</span></code></dt><dd><p>controller specific method to execute NAND operations.
This method replaces chip-&gt;legacy.cmdfunc(),
chip-&gt;legacy.{read,write}_{buf,byte,word}(),
chip-&gt;legacy.dev_ready() and chip-&gt;legacy.waifunc().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup_interface</span></code></dt><dd><p>setup the data interface and timing. If chipnr is set to
<code class="docutils literal notranslate"><span class="pre">NAND_DATA_IFACE_CHECK_ONLY</span></code> this means the configuration
should not be applied but only checked.
This hook is optional.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_controller">
struct <code class="sig-name descname">nand_controller</code><a class="headerlink" href="#c.nand_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure used to describe a NAND controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_controller {
    struct mutex lock;
    const struct nand_controller_ops *ops;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>lock used to serialize accesses to the NAND controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>NAND controller operations.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_legacy">
struct <code class="sig-name descname">nand_legacy</code><a class="headerlink" href="#c.nand_legacy" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND chip legacy fields/hooks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_legacy {
    void __iomem *IO_ADDR_R;
    void __iomem *IO_ADDR_W;
    void (*select_chip)(struct nand_chip *chip, int cs);
    u8 (*read_byte)(struct nand_chip *chip);
    void (*write_byte)(struct nand_chip *chip, u8 byte);
    void (*write_buf)(struct nand_chip *chip, const u8 *buf, int len);
    void (*read_buf)(struct nand_chip *chip, u8 *buf, int len);
    void (*cmd_ctrl)(struct nand_chip *chip, int dat, unsigned int ctrl);
    void (*cmdfunc)(struct nand_chip *chip, unsigned command, int column, int page_addr);
    int (*dev_ready)(struct nand_chip *chip);
    int (*waitfunc)(struct nand_chip *chip);
    int (*block_bad)(struct nand_chip *chip, loff_t ofs);
    int (*block_markbad)(struct nand_chip *chip, loff_t ofs);
    int (*set_features)(struct nand_chip *chip, int feature_addr, u8 *subfeature_para);
    int (*get_features)(struct nand_chip *chip, int feature_addr, u8 *subfeature_para);
    int chip_delay;
    struct nand_controller dummy_controller;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IO_ADDR_R</span></code></dt><dd><p>address to read the 8 I/O lines of the flash device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IO_ADDR_W</span></code></dt><dd><p>address to write the 8 I/O lines of the flash device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">select_chip</span></code></dt><dd><p>select/deselect a specific target/die</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_byte</span></code></dt><dd><p>read one byte from the chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_byte</span></code></dt><dd><p>write a single byte to the chip on the low 8 I/O lines</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_buf</span></code></dt><dd><p>write data from the buffer to the chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_buf</span></code></dt><dd><p>read data from the chip into the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd_ctrl</span></code></dt><dd><p>hardware specific function for controlling ALE/CLE/nCE. Also used
to write command and address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmdfunc</span></code></dt><dd><p>hardware specific function for writing commands to the chip.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_ready</span></code></dt><dd><p>hardware specific function for accessing device ready/busy line.
If set to NULL no access to ready/busy is available and the
ready/busy information is read from the chip status register.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">waitfunc</span></code></dt><dd><p>hardware specific function for wait on ready.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block_bad</span></code></dt><dd><p>check if a block is bad, using OOB markers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block_markbad</span></code></dt><dd><p>mark a block bad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_features</span></code></dt><dd><p>set the NAND chip features</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_features</span></code></dt><dd><p>get the NAND chip features</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip_delay</span></code></dt><dd><p>chip dependent delay for transferring data from array to read
regs (tR).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dummy_controller</span></code></dt><dd><p>dummy controller implementation for drivers that can
only control a single chip</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If you look at this structure you’re already wrong. These fields/hooks are
all deprecated.</p>
<dl class="type">
<dt id="c.nand_chip_ops">
struct <code class="sig-name descname">nand_chip_ops</code><a class="headerlink" href="#c.nand_chip_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND chip operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_chip_ops {
    int (*suspend)(struct nand_chip *chip);
    void (*resume)(struct nand_chip *chip);
    int (*lock_area)(struct nand_chip *chip, loff_t ofs, uint64_t len);
    int (*unlock_area)(struct nand_chip *chip, loff_t ofs, uint64_t len);
    int (*setup_read_retry)(struct nand_chip *chip, int retry_mode);
    int (*choose_interface_config)(struct nand_chip *chip, struct nand_interface_config *iface);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Suspend operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Resume operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock_area</span></code></dt><dd><p>Lock operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unlock_area</span></code></dt><dd><p>Unlock operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">setup_read_retry</span></code></dt><dd><p>Set the read-retry mode (mostly needed for MLC NANDs)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">choose_interface_config</span></code></dt><dd><p>Choose the best interface configuration</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_manufacturer">
struct <code class="sig-name descname">nand_manufacturer</code><a class="headerlink" href="#c.nand_manufacturer" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND manufacturer structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_manufacturer {
    const struct nand_manufacturer_desc *desc;
    void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">desc</span></code></dt><dd><p>The manufacturer description</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>Private information for the manufacturer driver</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_secure_region">
struct <code class="sig-name descname">nand_secure_region</code><a class="headerlink" href="#c.nand_secure_region" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND secure region structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_secure_region {
    u64 offset;
    u64 size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>Offset of the start of the secure region</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the secure region</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_chip">
struct <code class="sig-name descname">nand_chip</code><a class="headerlink" href="#c.nand_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND Private Flash Chip Data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_chip {
    struct nand_device base;
    struct nand_id id;
    struct nand_parameters parameters;
    struct nand_manufacturer manufacturer;
    struct nand_chip_ops ops;
    struct nand_legacy legacy;
    unsigned int options;
    const struct nand_interface_config *current_interface_config;
    struct nand_interface_config *best_interface_config;
    unsigned int bbt_erase_shift;
    unsigned int bbt_options;
    unsigned int badblockpos;
    unsigned int badblockbits;
    struct nand_bbt_descr *bbt_td;
    struct nand_bbt_descr *bbt_md;
    struct nand_bbt_descr *badblock_pattern;
    u8 *bbt;
    unsigned int page_shift;
    unsigned int phys_erase_shift;
    unsigned int chip_shift;
    unsigned int pagemask;
    unsigned int subpagesize;
    u8 *data_buf;
    u8 *oob_poi;
    struct {
        unsigned int bitflips;
        int page;
    } pagecache;
    unsigned long buf_align;
    struct mutex lock;
    unsigned int suspended : 1;
    wait_queue_head_t resume_wq;
    int cur_cs;
    int read_retries;
    struct nand_secure_region *secure_regions;
    u8 nr_secure_regions;
    struct nand_controller *controller;
    struct nand_ecc_ctrl ecc;
    void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Inherit from the generic NAND device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Holds NAND ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parameters</span></code></dt><dd><p>Holds generic parameters under an easily readable form</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">manufacturer</span></code></dt><dd><p>Manufacturer information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>NAND chip operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">legacy</span></code></dt><dd><p>All legacy fields/hooks. If you develop a new driver, don’t even try
to use any of these fields/hooks, and if you’re modifying an
existing driver that is using those fields/hooks, you should
consider reworking the driver and avoid using them.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">options</span></code></dt><dd><p>Various chip options. They can partly be set to inform nand_scan
about special functionality. See the defines for further
explanation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">current_interface_config</span></code></dt><dd><p>The currently used NAND interface configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">best_interface_config</span></code></dt><dd><p>The best NAND interface configuration which fits both
the NAND chip and NAND controller constraints. If
unset, the default reset interface configuration must
be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bbt_erase_shift</span></code></dt><dd><p>Number of address bits in a bbt entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bbt_options</span></code></dt><dd><p>Bad block table specific options. All options used here must
come from bbm.h. By default, these options will be copied to
the appropriate nand_bbt_descr’s.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">badblockpos</span></code></dt><dd><p>Bad block marker position in the oob area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">badblockbits</span></code></dt><dd><p>Minimum number of set bits in a good block’s bad block marker
position; i.e., BBM = 11110111b is good when badblockbits = 7</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bbt_td</span></code></dt><dd><p>Bad block table descriptor for flash lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bbt_md</span></code></dt><dd><p>Bad block table mirror descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">badblock_pattern</span></code></dt><dd><p>Bad block scan pattern used for initial bad block scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bbt</span></code></dt><dd><p>Bad block table pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">page_shift</span></code></dt><dd><p>Number of address bits in a page (column address bits)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phys_erase_shift</span></code></dt><dd><p>Number of address bits in a physical eraseblock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip_shift</span></code></dt><dd><p>Number of address bits in one chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pagemask</span></code></dt><dd><p>Page number mask = number of (pages / chip) - 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subpagesize</span></code></dt><dd><p>Holds the subpagesize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_buf</span></code></dt><dd><p>Buffer for data, size is (page size + oobsize)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oob_poi</span></code></dt><dd><p>pointer on the OOB area covered by data_buf</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pagecache</span></code></dt><dd><p>Structure containing page cache related fields</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pagecache.bitflips</span></code></dt><dd><p>Number of bitflips of the cached page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pagecache.page</span></code></dt><dd><p>Page number currently in the cache. -1 means no page is
currently cached</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_align</span></code></dt><dd><p>Minimum buffer alignment required by a platform</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Lock protecting the suspended field. Also used to serialize accesses
to the NAND device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspended</span></code></dt><dd><p>Set to 1 when the device is suspended, 0 when it’s not</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume_wq</span></code></dt><dd><p>wait queue to sleep if rawnand is in suspended state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur_cs</span></code></dt><dd><p>Currently selected target. -1 means no target selected, otherwise we
should always have cur_cs &gt;= 0 &amp;&amp; cur_cs &lt; nanddev_ntargets().
NAND Controller drivers should not modify this value, but they’re
allowed to read it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_retries</span></code></dt><dd><p>The number of read retry modes supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secure_regions</span></code></dt><dd><p>Structure containing the secure regions info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_secure_regions</span></code></dt><dd><p>Number of secure regions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">controller</span></code></dt><dd><p>The hardware controller structure which is shared among multiple
independent devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ecc</span></code></dt><dd><p>The ECC controller structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>Chip private data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_get_interface_config">
const struct <a class="reference internal" href="#c.nand_interface_config" title="nand_interface_config">nand_interface_config</a> * <code class="sig-name descname">nand_get_interface_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_get_interface_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the current interface configuration of a NAND chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.nand_flash_dev">
struct <code class="sig-name descname">nand_flash_dev</code><a class="headerlink" href="#c.nand_flash_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND Flash Device ID Structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_flash_dev {
    char *name;
    union {
        struct {
            uint8_t mfr_id;
            uint8_t dev_id;
        };
        uint8_t id[NAND_MAX_ID_LEN];
    };
    unsigned int pagesize;
    unsigned int chipsize;
    unsigned int erasesize;
    unsigned int options;
    uint16_t id_len;
    uint16_t oobsize;
    struct {
        uint16_t strength_ds;
        uint16_t step_ds;
    } ecc;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>a human-readable name of the NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mfr_id</span></code></dt><dd><p>manufacturer ID part of the full chip ID array (refers the same
memory address as <code class="docutils literal notranslate"><span class="pre">id[0]</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_id</span></code></dt><dd><p>device ID part of the full chip ID array (refers the same memory
address as <code class="docutils literal notranslate"><span class="pre">id[1]</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>full device ID array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pagesize</span></code></dt><dd><p>size of the NAND page in bytes; if 0, then the real page size (as
well as the eraseblock size) is determined from the extended NAND
chip ID array)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chipsize</span></code></dt><dd><p>total chip size in MiB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">erasesize</span></code></dt><dd><p>eraseblock size in bytes (determined from the extended ID if 0)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">options</span></code></dt><dd><p>stores various chip bit options</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id_len</span></code></dt><dd><p>The valid length of the <strong>id</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">oobsize</span></code></dt><dd><p>OOB size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ecc</span></code></dt><dd><p>ECC correctability and step information from the datasheet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ecc.strength_ds</span></code></dt><dd><p>The ECC correctability from the datasheet, same as the
<strong>ecc_strength_ds</strong> in nand_chip{}.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ecc.step_ds</span></code></dt><dd><p>The ECC step required by the <strong>ecc.strength_ds</strong>, same as the
<strong>ecc_step_ds</strong> in nand_chip{}, also from the datasheet.
For example, the “4bit ECC for each 512Byte” can be set with
NAND_ECC_INFO(4, 512).</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_opcode_8bits">
int <code class="sig-name descname">nand_opcode_8bits</code><span class="sig-paren">(</span>unsigned int<em> command</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_opcode_8bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the opcode’s address should be sent only on the lower 8 bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">command</span></code></dt><dd><p>opcode to check</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_get_data_buf">
void * <code class="sig-name descname">nand_get_data_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_get_data_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the internal page buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the pre-allocated page buffer after invalidating the cache. This
function should be used by drivers that do not want to allocate their own
bounce buffer and still need such a buffer for specific operations (most
commonly when reading OOB data only).</p>
<p>Be careful to never call this function in the write/write_oob path, because
the core may have placed the data to be written out in this buffer.</p>
<p><strong>Return</strong></p>
<p>pointer to the page cache buffer</p>
</div>
</section>
<section id="public-functions-provided">
<h2>Public Functions Provided<a class="headerlink" href="#public-functions-provided" title="Permalink to this headline">¶</a></h2>
<p>This chapter contains the autogenerated documentation of the NAND kernel
API functions which are exported. Each function has a short description
which is marked with an [XXX] identifier. See the chapter “Documentation
hints” for an explanation.</p>
<dl class="function">
<dt id="c.nand_extract_bits">
void <code class="sig-name descname">nand_extract_bits</code><span class="sig-paren">(</span>u8<em> *dst</em>, unsigned int<em> dst_off</em>, const u8<em> *src</em>, unsigned int<em> src_off</em>, unsigned int<em> nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_extract_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy unaligned bits from one buffer to another one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*dst</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dst_off</span></code></dt><dd><p>bit offset at which the writing starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*src</span></code></dt><dd><p>source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">src_off</span></code></dt><dd><p>bit offset at which the reading starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt><dd><p>number of bits to copy from <strong>src</strong> to <strong>dst</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy bits from one memory region to another (overlap authorized).</p>
</div>
<dl class="function">
<dt id="c.nand_select_target">
void <code class="sig-name descname">nand_select_target</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned int<em> cs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_select_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a NAND target (A.K.A. die)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cs</span></code></dt><dd><p>the CS line to select. Note that this CS id is always from the chip
PoV, not the controller one</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Select a NAND target so that further operations executed on <strong>chip</strong> go to the
selected NAND target.</p>
</div>
<dl class="function">
<dt id="c.nand_deselect_target">
void <code class="sig-name descname">nand_deselect_target</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_deselect_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Deselect the currently selected target</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deselect the currently selected NAND target. The result of operations
executed on <strong>chip</strong> after the target has been deselected is undefined.</p>
</div>
<dl class="function">
<dt id="c.nand_soft_waitrdy">
int <code class="sig-name descname">nand_soft_waitrdy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned long<em> timeout_ms</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_soft_waitrdy" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll STATUS reg until RDY bit is set to 1</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout_ms</span></code></dt><dd><p>Timeout in ms</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Poll the STATUS register using -&gt;exec_op() until the RDY bit becomes 1.
If that does not happen whitin the specified timeout, -ETIMEDOUT is
returned.</p>
<p>This helper is intended to be used when the controller does not have access
to the NAND R/B pin.</p>
<p>Be aware that calling this helper from an -&gt;exec_op() implementation means
-&gt;exec_op() must be re-entrant.</p>
<p>Return 0 if the NAND chip is ready, a negative error otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_gpio_waitrdy">
int <code class="sig-name descname">nand_gpio_waitrdy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, struct gpio_desc<em> *gpiod</em>, unsigned long<em> timeout_ms</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_gpio_waitrdy" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll R/B GPIO pin until ready</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*gpiod</span></code></dt><dd><p>GPIO descriptor of R/B pin</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout_ms</span></code></dt><dd><p>Timeout in ms</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Poll the R/B GPIO pin until it becomes ready. If that does not happen
whitin the specified timeout, -ETIMEDOUT is returned.</p>
<p>This helper is intended to be used when the controller has access to the
NAND R/B pin over GPIO.</p>
<p>Return 0 if the R/B pin indicates chip is ready, a negative error otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_read_page_op">
int <code class="sig-name descname">nand_read_page_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned int<em> page</em>, unsigned int<em> offset_in_page</em>, void<em> *buf</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a READ PAGE operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset_in_page</span></code></dt><dd><p>offset within the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer used to store the data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function issues a READ PAGE operation.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_change_read_column_op">
int <code class="sig-name descname">nand_change_read_column_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned int<em> offset_in_page</em>, void<em> *buf</em>, unsigned int<em> len</em>, bool<em> force_8bit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_change_read_column_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a CHANGE READ COLUMN operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset_in_page</span></code></dt><dd><p>offset within the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer used to store the data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force_8bit</span></code></dt><dd><p>force 8-bit bus access</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function issues a CHANGE READ COLUMN operation.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_read_oob_op">
int <code class="sig-name descname">nand_read_oob_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned int<em> page</em>, unsigned int<em> offset_in_oob</em>, void<em> *buf</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_oob_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a READ OOB operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset_in_oob</span></code></dt><dd><p>offset within the OOB area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer used to store the data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function issues a READ OOB operation.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_prog_page_begin_op">
int <code class="sig-name descname">nand_prog_page_begin_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned int<em> page</em>, unsigned int<em> offset_in_page</em>, const void<em> *buf</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_prog_page_begin_op" title="Permalink to this definition">¶</a></dt>
<dd><p>starts a PROG PAGE operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset_in_page</span></code></dt><dd><p>offset within the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer containing the data to write to the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function issues the first half of a PROG PAGE operation.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_prog_page_end_op">
int <code class="sig-name descname">nand_prog_page_end_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_prog_page_end_op" title="Permalink to this definition">¶</a></dt>
<dd><p>ends a PROG PAGE operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function issues the second half of a PROG PAGE operation.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_prog_page_op">
int <code class="sig-name descname">nand_prog_page_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned int<em> page</em>, unsigned int<em> offset_in_page</em>, const void<em> *buf</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_prog_page_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a full PROG PAGE operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset_in_page</span></code></dt><dd><p>offset within the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer containing the data to write to the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function issues a full PROG PAGE operation.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_change_write_column_op">
int <code class="sig-name descname">nand_change_write_column_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned int<em> offset_in_page</em>, const void<em> *buf</em>, unsigned int<em> len</em>, bool<em> force_8bit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_change_write_column_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a CHANGE WRITE COLUMN operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset_in_page</span></code></dt><dd><p>offset within the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer containing the data to send to the NAND</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force_8bit</span></code></dt><dd><p>force 8-bit bus access</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function issues a CHANGE WRITE COLUMN operation.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_readid_op">
int <code class="sig-name descname">nand_readid_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, u8<em> addr</em>, void<em> *buf</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_readid_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a READID operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">addr</span></code></dt><dd><p>address cycle to pass after the READID command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer used to store the ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sends a READID command and reads back the ID returned by the
NAND.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_status_op">
int <code class="sig-name descname">nand_status_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, u8<em> *status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_status_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a STATUS operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*status</span></code></dt><dd><p>out variable to store the NAND status</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sends a STATUS command and reads back the status returned by
the NAND.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_erase_op">
int <code class="sig-name descname">nand_erase_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned int<em> eraseblock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_erase_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do an erase operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">eraseblock</span></code></dt><dd><p>block to erase</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sends an ERASE command and waits for the NAND to be ready
before returning.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_reset_op">
int <code class="sig-name descname">nand_reset_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_reset_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a reset operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sends a RESET command and waits for the NAND to be ready
before returning.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_read_data_op">
int <code class="sig-name descname">nand_read_data_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, void<em> *buf</em>, unsigned int<em> len</em>, bool<em> force_8bit</em>, bool<em> check_only</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_data_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from the NAND</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer used to store the data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force_8bit</span></code></dt><dd><p>force 8-bit bus access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">check_only</span></code></dt><dd><p>do not actually run the command, only checks if the
controller driver supports it</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does a raw data read on the bus. Usually used after launching
another NAND operation like <a class="reference internal" href="#c.nand_read_page_op" title="nand_read_page_op"><code class="xref c c-func docutils literal notranslate"><span class="pre">nand_read_page_op()</span></code></a>.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_write_data_op">
int <code class="sig-name descname">nand_write_data_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const void<em> *buf</em>, unsigned int<em> len</em>, bool<em> force_8bit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_data_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data from the NAND</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer containing the data to send on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force_8bit</span></code></dt><dd><p>force 8-bit bus access</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does a raw data write on the bus. Usually used after launching
another NAND operation like nand_write_page_begin_op().
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_op_parser_exec_op">
int <code class="sig-name descname">nand_op_parser_exec_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const struct <a class="reference internal" href="#c.nand_op_parser" title="nand_op_parser">nand_op_parser</a><em> *parser</em>, const struct <a class="reference internal" href="#c.nand_operation" title="nand_operation">nand_operation</a><em> *op</em>, bool<em> check_only</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_op_parser_exec_op" title="Permalink to this definition">¶</a></dt>
<dd><p>exec_op parser</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>the NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_op_parser</span> <span class="pre">*parser</span></code></dt><dd><p>patterns description provided by the controller driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_operation</span> <span class="pre">*op</span></code></dt><dd><p>the NAND operation to address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">check_only</span></code></dt><dd><p>when true, the function only checks if <strong>op</strong> can be handled but
does not execute the operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function designed to ease integration of NAND controller drivers that
only support a limited set of instruction sequences. The supported sequences
are described in <strong>parser</strong>, and the framework takes care of splitting <strong>op</strong> into
multiple sub-operations (if required) and pass them back to the -&gt;exec()
callback of the matching pattern if <strong>check_only</strong> is set to false.</p>
<p>NAND controller drivers should call this function from their own -&gt;exec_op()
implementation.</p>
<p>Returns 0 on success, a negative error code otherwise. A failure can be
caused by an unsupported operation (none of the supported patterns is able
to handle the requested operation), or an error returned by one of the
matching pattern-&gt;exec() hook.</p>
</div>
<dl class="function">
<dt id="c.nand_subop_get_addr_start_off">
unsigned int <code class="sig-name descname">nand_subop_get_addr_start_off</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.nand_subop" title="nand_subop">nand_subop</a><em> *subop</em>, unsigned int<em> instr_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_subop_get_addr_start_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the start offset in an address array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_subop</span> <span class="pre">*subop</span></code></dt><dd><p>The entire sub-operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">instr_idx</span></code></dt><dd><p>Index of the instruction inside the sub-operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During driver development, one could be tempted to directly use the
-&gt;addr.addrs field of address instructions. This is wrong as address
instructions might be split.</p>
<p>Given an address instruction, returns the offset of the first cycle to issue.</p>
</div>
<dl class="function">
<dt id="c.nand_subop_get_num_addr_cyc">
unsigned int <code class="sig-name descname">nand_subop_get_num_addr_cyc</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.nand_subop" title="nand_subop">nand_subop</a><em> *subop</em>, unsigned int<em> instr_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_subop_get_num_addr_cyc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the remaining address cycles to assert</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_subop</span> <span class="pre">*subop</span></code></dt><dd><p>The entire sub-operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">instr_idx</span></code></dt><dd><p>Index of the instruction inside the sub-operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During driver development, one could be tempted to directly use the
-&gt;addr-&gt;naddrs field of a data instruction. This is wrong as instructions
might be split.</p>
<p>Given an address instruction, returns the number of address cycle to issue.</p>
</div>
<dl class="function">
<dt id="c.nand_subop_get_data_start_off">
unsigned int <code class="sig-name descname">nand_subop_get_data_start_off</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.nand_subop" title="nand_subop">nand_subop</a><em> *subop</em>, unsigned int<em> instr_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_subop_get_data_start_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the start offset in a data array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_subop</span> <span class="pre">*subop</span></code></dt><dd><p>The entire sub-operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">instr_idx</span></code></dt><dd><p>Index of the instruction inside the sub-operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During driver development, one could be tempted to directly use the
-&gt;data-&gt;buf.{in,out} field of data instructions. This is wrong as data
instructions might be split.</p>
<p>Given a data instruction, returns the offset to start from.</p>
</div>
<dl class="function">
<dt id="c.nand_subop_get_data_len">
unsigned int <code class="sig-name descname">nand_subop_get_data_len</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.nand_subop" title="nand_subop">nand_subop</a><em> *subop</em>, unsigned int<em> instr_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_subop_get_data_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of bytes to retrieve</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_subop</span> <span class="pre">*subop</span></code></dt><dd><p>The entire sub-operation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">instr_idx</span></code></dt><dd><p>Index of the instruction inside the sub-operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During driver development, one could be tempted to directly use the
-&gt;data-&gt;len field of a data instruction. This is wrong as data instructions
might be split.</p>
<p>Returns the length of the chunk of data to send/receive.</p>
</div>
<dl class="function">
<dt id="c.nand_reset">
int <code class="sig-name descname">nand_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, int<em> chipnr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset and initialize a NAND device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">chipnr</span></code></dt><dd><p>Internal die id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Save the timings data structure, then apply SDR timings mode 0 (see
nand_reset_interface for details), do the reset operation, and apply
back the previous timings.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_check_erased_ecc_chunk">
int <code class="sig-name descname">nand_check_erased_ecc_chunk</code><span class="sig-paren">(</span>void<em> *data</em>, int<em> datalen</em>, void<em> *ecc</em>, int<em> ecclen</em>, void<em> *extraoob</em>, int<em> extraooblen</em>, int<em> bitflips_threshold</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_check_erased_ecc_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>check if an ECC chunk contains (almost) only 0xff data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data buffer to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">datalen</span></code></dt><dd><p>data length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ecc</span></code></dt><dd><p>ECC buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ecclen</span></code></dt><dd><p>ECC length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*extraoob</span></code></dt><dd><p>extra OOB buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">extraooblen</span></code></dt><dd><p>extra OOB length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bitflips_threshold</span></code></dt><dd><p>maximum number of bitflips</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if a data buffer and its associated ECC and OOB data contains only
0xff pattern, which means the underlying region has been erased and is
ready to be programmed.
The bitflips_threshold specify the maximum number of bitflips before
considering the region as not erased.</p>
<p>Returns a positive number of bitflips less than or equal to
bitflips_threshold, or -ERROR_CODE for bitflips in excess of the
threshold. In case of success, the passed buffers are filled with 0xff.</p>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>1/ ECC algorithms are working on pre-defined block sizes which are usually</dt><dd><p>different from the NAND page size. When fixing bitflips, ECC engines will
report the number of errors per chunk, and the NAND core infrastructure
expect you to return the maximum number of bitflips for the whole page.
This is why you should always use this function on a single chunk and
not on the whole page. After checking each chunk you should update your
max_bitflips value accordingly.</p>
</dd>
<dt>2/ When checking for bitflips in erased pages you should not only check</dt><dd><p>the payload data but also their associated ECC data, because a user might
have programmed almost all bits to 1 but a few. In this case, we
shouldn’t consider the chunk as erased, and checking ECC bytes prevent
this case.</p>
</dd>
<dt>3/ The extraoob argument is optional, and should be used if some of your OOB</dt><dd><p>data are protected by the ECC engine.
It could also be used if you support subpages and want to attach some
extra OOB data to an ECC chunk.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_read_page_raw">
int <code class="sig-name descname">nand_read_page_raw</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] read raw page data without ecc</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to store read data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>caller requires OOB data read to chip-&gt;oob_poi</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not for syndrome calculating ECC controllers, which use a special oob layout.</p>
</div>
<dl class="function">
<dt id="c.nand_monolithic_read_page_raw">
int <code class="sig-name descname">nand_monolithic_read_page_raw</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, u8<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_monolithic_read_page_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>Monolithic page read in raw mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to store read data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>caller requires OOB data read to chip-&gt;oob_poi</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a raw page read, ie. without any error detection/correction.
Monolithic means we are requesting all the relevant data (main plus
eventually OOB) to be loaded in the NAND cache and sent over the
bus (from the NAND chip to the NAND controller) in a single
operation. This is an alternative to <a class="reference internal" href="#c.nand_read_page_raw" title="nand_read_page_raw"><code class="xref c c-func docutils literal notranslate"><span class="pre">nand_read_page_raw()</span></code></a>, which
first reads the main data, and if the OOB data is requested too,
then reads more data on the bus.</p>
</div>
<dl class="function">
<dt id="c.nand_read_page_hwecc_oob_first">
int <code class="sig-name descname">nand_read_page_hwecc_oob_first</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_hwecc_oob_first" title="Permalink to this definition">¶</a></dt>
<dd><p>Hardware ECC page read with ECC data read from OOB area</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to store read data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>caller requires OOB data read to chip-&gt;oob_poi</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hardware ECC for large page chips, which requires the ECC data to be
extracted from the OOB before the actual data is read.</p>
</div>
<dl class="function">
<dt id="c.nand_read_oob_std">
int <code class="sig-name descname">nand_read_oob_std</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_oob_std" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] the most common OOB data read function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to read</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_write_oob_std">
int <code class="sig-name descname">nand_write_oob_std</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_oob_std" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] the most common OOB data write function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to write</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_write_page_raw">
int <code class="sig-name descname">nand_write_page_raw</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] raw page write function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>must write chip-&gt;oob_poi to OOB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not for syndrome calculating ECC controllers, which use a special oob layout.</p>
</div>
<dl class="function">
<dt id="c.nand_monolithic_write_page_raw">
int <code class="sig-name descname">nand_monolithic_write_page_raw</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const u8<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_monolithic_write_page_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>Monolithic page write in raw mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>data buffer to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>must write chip-&gt;oob_poi to OOB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a raw page write, ie. without any error detection/correction.
Monolithic means we are requesting all the relevant data (main plus
eventually OOB) to be sent over the bus and effectively programmed
into the NAND chip arrays in a single operation. This is an
alternative to <a class="reference internal" href="#c.nand_write_page_raw" title="nand_write_page_raw"><code class="xref c c-func docutils literal notranslate"><span class="pre">nand_write_page_raw()</span></code></a>, which first sends the main
data, then eventually send the OOB data by latching more data
cycles on the NAND bus, and finally sends the program command to
synchronyze the NAND chip cache.</p>
</div>
<dl class="function">
<dt id="c.rawnand_dt_parse_gpio_cs">
int <code class="sig-name descname">rawnand_dt_parse_gpio_cs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct gpio_desc<em> ***cs_array</em>, unsigned int<em> *ncs_array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rawnand_dt_parse_gpio_cs" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the gpio-cs property of a controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device that will be parsed. Also used for managed allocations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">***cs_array</span></code></dt><dd><p>Array of GPIO desc pointers allocated on success</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*ncs_array</span></code></dt><dd><p>Number of entries in <strong>cs_array</strong> updated on success.
<strong>return</strong> 0 on success, an error otherwise.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_ecc_choose_conf">
int <code class="sig-name descname">nand_ecc_choose_conf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const struct <a class="reference internal" href="#c.nand_ecc_caps" title="nand_ecc_caps">nand_ecc_caps</a><em> *caps</em>, int<em> oobavail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_ecc_choose_conf" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the ECC strength and ECC step size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_ecc_caps</span> <span class="pre">*caps</span></code></dt><dd><p>ECC engine caps info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oobavail</span></code></dt><dd><p>OOB size that the ECC engine can use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Choose the ECC configuration according to following logic.</p>
<ol class="arabic simple">
<li><p>If both ECC step size and ECC strength are already set (usually by DT)
then check if it is supported by this controller.</p></li>
<li><p>If the user provided the nand-ecc-maximize property, then select maximum
ECC strength.</p></li>
<li><p>Otherwise, try to match the ECC step size and ECC strength closest
to the chip’s requirement. If available OOB size can’t fit the chip
requirement then fallback to the maximum ECC step size and ECC strength.</p></li>
</ol>
<p>On success, the chosen ECC settings are set.</p>
</div>
<dl class="function">
<dt id="c.nand_scan_with_ids">
int <code class="sig-name descname">nand_scan_with_ids</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned int<em> maxchips</em>, struct <a class="reference internal" href="#c.nand_flash_dev" title="nand_flash_dev">nand_flash_dev</a><em> *ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_scan_with_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Scan for the NAND device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">maxchips</span></code></dt><dd><p>number of chips to scan for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_flash_dev</span> <span class="pre">*ids</span></code></dt><dd><p>optional flash IDs table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This fills out all the uninitialized function pointers with the defaults.
The flash ID is read and the mtd/chip structures are filled with the
appropriate values.</p>
</div>
<dl class="function">
<dt id="c.nand_cleanup">
void <code class="sig-name descname">nand_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Free resources held by the NAND device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
</dl>
</div>
</section>
<section id="internal-functions-provided">
<h2>Internal Functions Provided<a class="headerlink" href="#internal-functions-provided" title="Permalink to this headline">¶</a></h2>
<p>This chapter contains the autogenerated documentation of the NAND driver
internal functions. Each function has a short description which is
marked with an [XXX] identifier. See the chapter “Documentation hints”
for an explanation. The functions marked with [DEFAULT] might be
relevant for a board driver developer.</p>
<dl class="function">
<dt id="c.nand_release_device">
void <code class="sig-name descname">nand_release_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_release_device" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] release chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release chip lock and wake up anyone waiting on the device.</p>
</div>
<dl class="function">
<dt id="c.nand_bbm_get_next_page">
int <code class="sig-name descname">nand_bbm_get_next_page</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_bbm_get_next_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next page for bad block markers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>First page to start checking for bad block marker usage</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an integer that corresponds to the page offset within a block, for
a page that is used to store bad block markers. If no more pages are
available, -EINVAL is returned.</p>
</div>
<dl class="function">
<dt id="c.nand_block_bad">
int <code class="sig-name descname">nand_block_bad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, loff_t<em> ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_bad" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] Read bad block marker from the chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt><dd><p>offset from device start</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check, if the block is bad.</p>
</div>
<dl class="function">
<dt id="c.nand_region_is_secured">
bool <code class="sig-name descname">nand_region_is_secured</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, loff_t<em> offset</em>, u64<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_region_is_secured" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the region is secured</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt><dd><p>Offset of the region to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">size</span></code></dt><dd><p>Size of the region to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks if the region is secured by comparing the offset and size with the
list of secure regions obtained from DT. Returns true if the region is
secured else false.</p>
</div>
<dl class="function">
<dt id="c.nand_get_device">
void <code class="sig-name descname">nand_get_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Get chip for selected access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the device and its controller for exclusive access</p>
</div>
<dl class="function">
<dt id="c.nand_check_wp">
int <code class="sig-name descname">nand_check_wp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_check_wp" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] check if the chip is write protected</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check, if the device is write protected. The function expects, that the
device is already selected.</p>
</div>
<dl class="function">
<dt id="c.nand_fill_oob">
uint8_t * <code class="sig-name descname">nand_fill_oob</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, uint8_t<em> *oob</em>, size_t<em> len</em>, struct mtd_oob_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_fill_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] Transfer client buffer to oob</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*oob</span></code></dt><dd><p>oob data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>oob data write length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*ops</span></code></dt><dd><p>oob ops structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_do_write_oob">
int <code class="sig-name descname">nand_do_write_oob</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, loff_t<em> to</em>, struct mtd_oob_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_do_write_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] NAND write out-of-band</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt><dd><p>offset to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*ops</span></code></dt><dd><p>oob operation description structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>NAND write out-of-band.</p>
</div>
<dl class="function">
<dt id="c.nand_default_block_markbad">
int <code class="sig-name descname">nand_default_block_markbad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, loff_t<em> ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_default_block_markbad" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] mark a block bad via bad block marker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt><dd><p>offset from device start</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default implementation, which can be overridden by a hardware
specific driver. It provides the details for writing a bad block marker to a
block.</p>
</div>
<dl class="function">
<dt id="c.nand_markbad_bbm">
int <code class="sig-name descname">nand_markbad_bbm</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, loff_t<em> ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_markbad_bbm" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a block by updating the BBM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt><dd><p>offset of the block to mark bad</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_block_markbad_lowlevel">
int <code class="sig-name descname">nand_block_markbad_lowlevel</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, loff_t<em> ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_markbad_lowlevel" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a block bad</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt><dd><p>offset from device start</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function performs the generic NAND bad block marking steps (i.e., bad
block table(s) and/or marker(s)). We only allow the hardware driver to
specify how to write bad block markers to OOB (chip-&gt;legacy.block_markbad).</p>
<p>We try operations in the following order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>erase the affected block, to allow OOB marker to be written cleanly</p></li>
<li><p>write bad block marker to OOB area of affected block (unless flag
NAND_BBT_NO_OOB_BBM is present)</p></li>
<li><p>update the BBT</p></li>
</ol>
</div></blockquote>
<p>Note that we retain the first error encountered in (2) or (3), finish the
procedures, and dump the error in the end.</p>
</div>
<dl class="function">
<dt id="c.nand_block_isreserved">
int <code class="sig-name descname">nand_block_isreserved</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em>, loff_t<em> ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_isreserved" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Check if a block is marked reserved.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt><dd><p>offset from device start</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the block is marked as reserved.</p>
</div>
<dl class="function">
<dt id="c.nand_block_checkbad">
int <code class="sig-name descname">nand_block_checkbad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, loff_t<em> ofs</em>, int<em> allowbbt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_checkbad" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Check if a block is marked bad</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt><dd><p>offset from device start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">allowbbt</span></code></dt><dd><p>1, if its allowed to access the bbt area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check, if the block is bad. Either by reading the bad block table or
calling of the scan function.</p>
</div>
<dl class="function">
<dt id="c.panic_nand_wait">
void <code class="sig-name descname">panic_nand_wait</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned long<em> timeo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.panic_nand_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] wait until the command is done</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeo</span></code></dt><dd><p>timeout</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for command done. This is a helper function for nand_wait used when
we are in interrupt context. May happen when in panic and trying to write
an oops through mtdoops.</p>
</div>
<dl class="function">
<dt id="c.nand_reset_interface">
int <code class="sig-name descname">nand_reset_interface</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, int<em> chipnr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_reset_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset data interface and timings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">chipnr</span></code></dt><dd><p>Internal die id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset the Data interface and timings to ONFI mode 0.</p>
<p>Returns 0 for success or negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_setup_interface">
int <code class="sig-name descname">nand_setup_interface</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, int<em> chipnr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_setup_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the best data interface and timings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">chipnr</span></code></dt><dd><p>Internal die id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure what has been reported to be the best data interface and NAND
timings supported by the chip and the driver.</p>
<p>Returns 0 for success or negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_choose_best_sdr_timings">
int <code class="sig-name descname">nand_choose_best_sdr_timings</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, struct <a class="reference internal" href="#c.nand_interface_config" title="nand_interface_config">nand_interface_config</a><em> *iface</em>, struct <a class="reference internal" href="#c.nand_sdr_timings" title="nand_sdr_timings">nand_sdr_timings</a><em> *spec_timings</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_choose_best_sdr_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick up the best SDR timings that both the NAND controller and the NAND chip support</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>the NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_interface_config</span> <span class="pre">*iface</span></code></dt><dd><p>the interface configuration (can eventually be updated)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_sdr_timings</span> <span class="pre">*spec_timings</span></code></dt><dd><p>specific timings, when not fitting the ONFI specification</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If specific timings are provided, use them. Otherwise, retrieve supported
timing modes from ONFI information.</p>
</div>
<dl class="function">
<dt id="c.nand_choose_best_nvddr_timings">
int <code class="sig-name descname">nand_choose_best_nvddr_timings</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, struct <a class="reference internal" href="#c.nand_interface_config" title="nand_interface_config">nand_interface_config</a><em> *iface</em>, struct <a class="reference internal" href="#c.nand_nvddr_timings" title="nand_nvddr_timings">nand_nvddr_timings</a><em> *spec_timings</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_choose_best_nvddr_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick up the best NVDDR timings that both the NAND controller and the NAND chip support</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>the NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_interface_config</span> <span class="pre">*iface</span></code></dt><dd><p>the interface configuration (can eventually be updated)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_nvddr_timings</span> <span class="pre">*spec_timings</span></code></dt><dd><p>specific timings, when not fitting the ONFI specification</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If specific timings are provided, use them. Otherwise, retrieve supported
timing modes from ONFI information.</p>
</div>
<dl class="function">
<dt id="c.nand_choose_best_timings">
int <code class="sig-name descname">nand_choose_best_timings</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, struct <a class="reference internal" href="#c.nand_interface_config" title="nand_interface_config">nand_interface_config</a><em> *iface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_choose_best_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick up the best NVDDR or SDR timings that both NAND controller and the NAND chip support</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>the NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_interface_config</span> <span class="pre">*iface</span></code></dt><dd><p>the interface configuration (can eventually be updated)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If specific timings are provided, use them. Otherwise, retrieve supported
timing modes from ONFI information.</p>
</div>
<dl class="function">
<dt id="c.nand_choose_interface_config">
int <code class="sig-name descname">nand_choose_interface_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_choose_interface_config" title="Permalink to this definition">¶</a></dt>
<dd><p>find the best data interface and timings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the best data interface and NAND timings supported by the chip
and the driver. Eventually let the NAND manufacturer driver propose his own
set of timings.</p>
<p>After this function nand_chip-&gt;interface_config is initialized with the best
timing mode available.</p>
<p>Returns 0 for success or negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_fill_column_cycles">
int <code class="sig-name descname">nand_fill_column_cycles</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, u8<em> *addrs</em>, unsigned int<em> offset_in_page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_fill_column_cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>fill the column cycles of an address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*addrs</span></code></dt><dd><p>Array of address cycles to fill</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset_in_page</span></code></dt><dd><p>The offset in the page</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fills the first or the first two bytes of the <strong>addrs</strong> field depending
on the NAND bus width and the page size.</p>
<p>Returns the number of cycles needed to encode the column, or a negative
error code in case one of the arguments is invalid.</p>
</div>
<dl class="function">
<dt id="c.nand_read_param_page_op">
int <code class="sig-name descname">nand_read_param_page_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, u8<em> page</em>, void<em> *buf</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_param_page_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a READ PARAMETER PAGE operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">page</span></code></dt><dd><p>parameter page to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer used to store the data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function issues a READ PARAMETER PAGE operation.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_exit_status_op">
int <code class="sig-name descname">nand_exit_status_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_exit_status_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit a STATUS operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sends a READ0 command to cancel the effect of the STATUS
command to avoid reading only the status until a new read command is sent.</p>
<p>This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_set_features_op">
int <code class="sig-name descname">nand_set_features_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, u8<em> feature</em>, const void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_set_features_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a SET FEATURES operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">feature</span></code></dt><dd><p>feature id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>4 bytes of data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sends a SET FEATURES command and waits for the NAND to be
ready before returning.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_get_features_op">
int <code class="sig-name descname">nand_get_features_op</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, u8<em> feature</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_get_features_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a GET FEATURES operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>The NAND chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">feature</span></code></dt><dd><p>feature id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>4 bytes of data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sends a GET FEATURES command and waits for the NAND to be
ready before returning.
This function does not select/unselect the CS line.</p>
<p>Returns 0 on success, a negative error code otherwise.</p>
</div>
<dl class="type">
<dt id="c.nand_op_parser_ctx">
struct <code class="sig-name descname">nand_op_parser_ctx</code><a class="headerlink" href="#c.nand_op_parser_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Context used by the parser</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nand_op_parser_ctx {
    const struct nand_op_instr *instrs;
    unsigned int ninstrs;
    struct nand_subop subop;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">instrs</span></code></dt><dd><p>array of all the instructions that must be addressed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ninstrs</span></code></dt><dd><p>length of the <strong>instrs</strong> array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subop</span></code></dt><dd><p>Sub-operation to be passed to the NAND controller</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is used by the core to split NAND operations into
sub-operations that can be handled by the NAND controller.</p>
<dl class="function">
<dt id="c.nand_op_parser_must_split_instr">
bool <code class="sig-name descname">nand_op_parser_must_split_instr</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.nand_op_parser_pattern_elem" title="nand_op_parser_pattern_elem">nand_op_parser_pattern_elem</a><em> *pat</em>, const struct <a class="reference internal" href="#c.nand_op_instr" title="nand_op_instr">nand_op_instr</a><em> *instr</em>, unsigned int<em> *start_offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_op_parser_must_split_instr" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if an instruction must be split</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_op_parser_pattern_elem</span> <span class="pre">*pat</span></code></dt><dd><p>the parser pattern element that matches <strong>instr</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_op_instr</span> <span class="pre">*instr</span></code></dt><dd><p>pointer to the instruction to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*start_offset</span></code></dt><dd><p>this is an in/out parameter. If <strong>instr</strong> has already been
split, then <strong>start_offset</strong> is the offset from which to start
(either an address cycle or an offset in the data buffer).
Conversely, if the function returns true (ie. instr must be
split), this parameter is updated to point to the first
data/address cycle that has not been taken care of.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some NAND controllers are limited and cannot send X address cycles with a
unique operation, or cannot read/write more than Y bytes at the same time.
In this case, split the instruction that does not fit in a single
controller-operation into two or more chunks.</p>
<p>Returns true if the instruction must be split, false otherwise.
The <strong>start_offset</strong> parameter is also updated to the offset at which the next
bundle of instruction must start (if an address or a data instruction).</p>
</div>
<dl class="function">
<dt id="c.nand_op_parser_match_pat">
bool <code class="sig-name descname">nand_op_parser_match_pat</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.nand_op_parser_pattern" title="nand_op_parser_pattern">nand_op_parser_pattern</a><em> *pat</em>, struct <a class="reference internal" href="#c.nand_op_parser_ctx" title="nand_op_parser_ctx">nand_op_parser_ctx</a><em> *ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_op_parser_match_pat" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a pattern matches the instructions remaining in the parser context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_op_parser_pattern</span> <span class="pre">*pat</span></code></dt><dd><p>the pattern to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_op_parser_ctx</span> <span class="pre">*ctx</span></code></dt><dd><p>the parser context structure to match with the pattern <strong>pat</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if <strong>pat</strong> matches the set or a sub-set of instructions remaining in <strong>ctx</strong>.
Returns true if this is the case, false ortherwise. When true is returned,
<strong>ctx-&gt;subop</strong> is updated with the set of instructions to be passed to the
controller driver.</p>
</div>
<dl class="function">
<dt id="c.nand_get_features">
int <code class="sig-name descname">nand_get_features</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, int<em> addr</em>, u8<em> *subfeature_param</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_get_features" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper to perform a GET_FEATURE</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>feature address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*subfeature_param</span></code></dt><dd><p>the subfeature parameters, a four bytes array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, a negative error otherwise. Returns -ENOTSUPP if the
operation cannot be handled.</p>
</div>
<dl class="function">
<dt id="c.nand_set_features">
int <code class="sig-name descname">nand_set_features</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, int<em> addr</em>, u8<em> *subfeature_param</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_set_features" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper to perform a SET_FEATURE</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>feature address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*subfeature_param</span></code></dt><dd><p>the subfeature parameters, a four bytes array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, a negative error otherwise. Returns -ENOTSUPP if the
operation cannot be handled.</p>
</div>
<dl class="function">
<dt id="c.nand_check_erased_buf">
int <code class="sig-name descname">nand_check_erased_buf</code><span class="sig-paren">(</span>void<em> *buf</em>, int<em> len</em>, int<em> bitflips_threshold</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_check_erased_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a buffer contains (almost) only 0xff data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>buffer length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bitflips_threshold</span></code></dt><dd><p>maximum number of bitflips</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if a buffer contains only 0xff, which means the underlying region
has been erased and is ready to be programmed.
The bitflips_threshold specify the maximum number of bitflips before
considering the region is not erased.
Returns a positive number of bitflips less than or equal to
bitflips_threshold, or -ERROR_CODE for bitflips in excess of the
threshold.</p>
<p><strong>Note</strong></p>
<p>The logic of this function has been extracted from the memweight
implementation, except that nand_check_erased_buf function exit before
testing the whole buffer if the number of bitflips exceed the
bitflips_threshold value.</p>
</div>
<dl class="function">
<dt id="c.nand_read_page_raw_notsupp">
int <code class="sig-name descname">nand_read_page_raw_notsupp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, u8<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_raw_notsupp" title="Permalink to this definition">¶</a></dt>
<dd><p>dummy read raw page function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to store read data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>caller requires OOB data read to chip-&gt;oob_poi</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -ENOTSUPP unconditionally.</p>
</div>
<dl class="function">
<dt id="c.nand_read_page_raw_syndrome">
int <code class="sig-name descname">nand_read_page_raw_syndrome</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_raw_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] read raw page data without ecc</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to store read data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>caller requires OOB data read to chip-&gt;oob_poi</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We need a special oob layout and handling even when OOB isn’t used.</p>
</div>
<dl class="function">
<dt id="c.nand_read_page_swecc">
int <code class="sig-name descname">nand_read_page_swecc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_swecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] software ECC based page read function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to store read data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>caller requires OOB data read to chip-&gt;oob_poi</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to read</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_read_subpage">
int <code class="sig-name descname">nand_read_subpage</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, uint32_t<em> data_offs</em>, uint32_t<em> readlen</em>, uint8_t<em> *bufpoi</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_subpage" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] ECC based sub-page read function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">data_offs</span></code></dt><dd><p>offset of requested data within the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">readlen</span></code></dt><dd><p>data length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*bufpoi</span></code></dt><dd><p>buffer to store read data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to read</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_read_page_hwecc">
int <code class="sig-name descname">nand_read_page_hwecc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_hwecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] hardware ECC based page read function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to store read data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>caller requires OOB data read to chip-&gt;oob_poi</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not for syndrome calculating ECC controllers which need a special oob layout.</p>
</div>
<dl class="function">
<dt id="c.nand_read_page_syndrome">
int <code class="sig-name descname">nand_read_page_syndrome</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] hardware ECC syndrome based page read</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to store read data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>caller requires OOB data read to chip-&gt;oob_poi</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The hw generator calculates the error syndrome automatically. Therefore we
need a special oob layout and handling.</p>
</div>
<dl class="function">
<dt id="c.nand_transfer_oob">
uint8_t * <code class="sig-name descname">nand_transfer_oob</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, uint8_t<em> *oob</em>, struct mtd_oob_ops<em> *ops</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_transfer_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] Transfer oob to client buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*oob</span></code></dt><dd><p>oob destination address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*ops</span></code></dt><dd><p>oob ops structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>size of oob to transfer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_setup_read_retry">
int <code class="sig-name descname">nand_setup_read_retry</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, int<em> retry_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_setup_read_retry" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] Set the READ RETRY mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">retry_mode</span></code></dt><dd><p>the retry mode to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some vendors supply a special command to shift the Vt threshold, to be used
when there are too many bitflips in a page (i.e., ECC error). After setting
a new threshold, the host should retry reading the page.</p>
</div>
<dl class="function">
<dt id="c.nand_do_read_ops">
int <code class="sig-name descname">nand_do_read_ops</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, loff_t<em> from</em>, struct mtd_oob_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_do_read_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] Read data with ECC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt><dd><p>offset to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*ops</span></code></dt><dd><p>oob ops structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Internal function. Called with chip held.</p>
</div>
<dl class="function">
<dt id="c.nand_read_oob_syndrome">
int <code class="sig-name descname">nand_read_oob_syndrome</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_oob_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] OOB data read function for HW ECC with syndromes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to read</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_write_oob_syndrome">
int <code class="sig-name descname">nand_write_oob_syndrome</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_oob_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] OOB data write function for HW ECC with syndrome - only for large page flash</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to write</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_do_read_oob">
int <code class="sig-name descname">nand_do_read_oob</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, loff_t<em> from</em>, struct mtd_oob_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_do_read_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] NAND read out-of-band</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt><dd><p>offset to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*ops</span></code></dt><dd><p>oob operations description structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>NAND read out-of-band data from the spare area.</p>
</div>
<dl class="function">
<dt id="c.nand_read_oob">
int <code class="sig-name descname">nand_read_oob</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em>, loff_t<em> from</em>, struct mtd_oob_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] NAND read data and/or out-of-band</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt><dd><p>offset to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*ops</span></code></dt><dd><p>oob operation description structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>NAND read data and/or out-of-band data.</p>
</div>
<dl class="function">
<dt id="c.nand_write_page_raw_notsupp">
int <code class="sig-name descname">nand_write_page_raw_notsupp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const u8<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page_raw_notsupp" title="Permalink to this definition">¶</a></dt>
<dd><p>dummy raw page write function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*buf</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>must write chip-&gt;oob_poi to OOB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -ENOTSUPP unconditionally.</p>
</div>
<dl class="function">
<dt id="c.nand_write_page_raw_syndrome">
int <code class="sig-name descname">nand_write_page_raw_syndrome</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page_raw_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] raw page write function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>must write chip-&gt;oob_poi to OOB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We need a special oob layout and handling even when ECC isn’t checked.</p>
</div>
<dl class="function">
<dt id="c.nand_write_page_swecc">
int <code class="sig-name descname">nand_write_page_swecc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page_swecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] software ECC based page write function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>must write chip-&gt;oob_poi to OOB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to write</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_write_page_hwecc">
int <code class="sig-name descname">nand_write_page_hwecc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page_hwecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] hardware ECC based page write function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>must write chip-&gt;oob_poi to OOB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to write</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_write_subpage_hwecc">
int <code class="sig-name descname">nand_write_subpage_hwecc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, uint32_t<em> offset</em>, uint32_t<em> data_len</em>, const uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_subpage_hwecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] hardware ECC based subpage write</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">offset</span></code></dt><dd><p>column address of subpage within the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">data_len</span></code></dt><dd><p>data length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>must write chip-&gt;oob_poi to OOB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to write</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_write_page_syndrome">
int <code class="sig-name descname">nand_write_page_syndrome</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] hardware ECC syndrome based page write</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>must write chip-&gt;oob_poi to OOB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The hw generator calculates the error syndrome automatically. Therefore we
need a special oob layout and handling.</p>
</div>
<dl class="function">
<dt id="c.nand_write_page">
int <code class="sig-name descname">nand_write_page</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, uint32_t<em> offset</em>, int<em> data_len</em>, const uint8_t<em> *buf</em>, int<em> oob_required</em>, int<em> page</em>, int<em> raw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page" title="Permalink to this definition">¶</a></dt>
<dd><p>write one page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint32_t</span> <span class="pre">offset</span></code></dt><dd><p>address offset within the page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">data_len</span></code></dt><dd><p>length of actual data to be written</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>the data to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt><dd><p>must write chip-&gt;oob_poi to OOB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>page number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">raw</span></code></dt><dd><p>use _raw version of write_page</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_do_write_ops">
int <code class="sig-name descname">nand_do_write_ops</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, loff_t<em> to</em>, struct mtd_oob_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_do_write_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] NAND write with ECC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt><dd><p>offset to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*ops</span></code></dt><dd><p>oob operations description structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>NAND write with ECC.</p>
</div>
<dl class="function">
<dt id="c.panic_nand_write">
int <code class="sig-name descname">panic_nand_write</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em>, loff_t<em> to</em>, size_t<em> len</em>, size_t<em> *retlen</em>, const uint8_t<em> *buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.panic_nand_write" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] NAND write with ECC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt><dd><p>offset to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*retlen</span></code></dt><dd><p>pointer to variable to store the number of written bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>the data to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>NAND write with ECC. Used when performing writes in interrupt context, this
may for example be called by mtdoops when writing an oops while in panic.</p>
</div>
<dl class="function">
<dt id="c.nand_write_oob">
int <code class="sig-name descname">nand_write_oob</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em>, loff_t<em> to</em>, struct mtd_oob_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] NAND write data and/or out-of-band</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt><dd><p>offset to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*ops</span></code></dt><dd><p>oob operation description structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_erase">
int <code class="sig-name descname">nand_erase</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em>, struct erase_info<em> *instr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_erase" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] erase block(s)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">erase_info</span> <span class="pre">*instr</span></code></dt><dd><p>erase instruction</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Erase one ore more blocks.</p>
</div>
<dl class="function">
<dt id="c.nand_erase_nand">
int <code class="sig-name descname">nand_erase_nand</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, struct erase_info<em> *instr</em>, int<em> allowbbt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_erase_nand" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] erase block(s)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">erase_info</span> <span class="pre">*instr</span></code></dt><dd><p>erase instruction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">allowbbt</span></code></dt><dd><p>allow erasing the bbt area</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Erase one ore more blocks.</p>
</div>
<dl class="function">
<dt id="c.nand_sync">
void <code class="sig-name descname">nand_sync</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] sync</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sync is actually a wait for chip ready function.</p>
</div>
<dl class="function">
<dt id="c.nand_block_isbad">
int <code class="sig-name descname">nand_block_isbad</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em>, loff_t<em> offs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_isbad" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Check if block at offset is bad</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt><dd><p>offset relative to mtd start</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_block_markbad">
int <code class="sig-name descname">nand_block_markbad</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em>, loff_t<em> ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_markbad" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Mark block at the given offset as bad</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt><dd><p>offset relative to mtd start</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_suspend">
int <code class="sig-name descname">nand_suspend</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Suspend the NAND flash</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success or negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.nand_resume">
void <code class="sig-name descname">nand_resume</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Resume the NAND flash</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_shutdown">
void <code class="sig-name descname">nand_shutdown</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Finish the current NAND operation and prevent further operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_lock">
int <code class="sig-name descname">nand_lock</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em>, loff_t<em> ofs</em>, uint64_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Lock the NAND flash</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt><dd><p>offset byte address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to lock (must be a multiple of block/page size)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_unlock">
int <code class="sig-name descname">nand_unlock</code><span class="sig-paren">(</span>struct mtd_info<em> *mtd</em>, loff_t<em> ofs</em>, uint64_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Unlock the NAND flash</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*mtd</span></code></dt><dd><p>MTD device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt><dd><p>offset byte address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to unlock (must be a multiple of block/page size)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_scan_ident">
int <code class="sig-name descname">nand_scan_ident</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, unsigned int<em> maxchips</em>, struct <a class="reference internal" href="#c.nand_flash_dev" title="nand_flash_dev">nand_flash_dev</a><em> *table</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_scan_ident" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan for the NAND device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">maxchips</span></code></dt><dd><p>number of chips to scan for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_flash_dev</span> <span class="pre">*table</span></code></dt><dd><p>alternative NAND ID table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the first phase of the normal nand_scan() function. It reads the
flash ID and sets up MTD fields accordingly.</p>
<p>This helper used to be called directly from controller drivers that needed
to tweak some ECC-related parameters before <a class="reference internal" href="#c.nand_scan_tail" title="nand_scan_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">nand_scan_tail()</span></code></a>. This separation
prevented dynamic allocations during this phase which was unconvenient and
as been banned for the benefit of the -&gt;init_ecc()/cleanup_ecc() hooks.</p>
</div>
<dl class="function">
<dt id="c.nand_check_ecc_caps">
int <code class="sig-name descname">nand_check_ecc_caps</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const struct <a class="reference internal" href="#c.nand_ecc_caps" title="nand_ecc_caps">nand_ecc_caps</a><em> *caps</em>, int<em> oobavail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_check_ecc_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>check the sanity of preset ECC settings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_ecc_caps</span> <span class="pre">*caps</span></code></dt><dd><p>ECC caps info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oobavail</span></code></dt><dd><p>OOB size that the ECC engine can use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When ECC step size and strength are already set, check if they are supported
by the controller and the calculated ECC bytes fit within the chip’s OOB.
On success, the calculated ECC bytes is set.</p>
</div>
<dl class="function">
<dt id="c.nand_match_ecc_req">
int <code class="sig-name descname">nand_match_ecc_req</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const struct <a class="reference internal" href="#c.nand_ecc_caps" title="nand_ecc_caps">nand_ecc_caps</a><em> *caps</em>, int<em> oobavail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_match_ecc_req" title="Permalink to this definition">¶</a></dt>
<dd><p>meet the chip’s requirement with least ECC bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_ecc_caps</span> <span class="pre">*caps</span></code></dt><dd><p>ECC engine caps info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oobavail</span></code></dt><dd><p>OOB size that the ECC engine can use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a chip’s ECC requirement is provided, try to meet it with the least
number of ECC bytes (i.e. with the largest number of OOB-free bytes).
On success, the chosen ECC settings are set.</p>
</div>
<dl class="function">
<dt id="c.nand_maximize_ecc">
int <code class="sig-name descname">nand_maximize_ecc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em>, const struct <a class="reference internal" href="#c.nand_ecc_caps" title="nand_ecc_caps">nand_ecc_caps</a><em> *caps</em>, int<em> oobavail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_maximize_ecc" title="Permalink to this definition">¶</a></dt>
<dd><p>choose the max ECC strength available</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>nand chip info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_ecc_caps</span> <span class="pre">*caps</span></code></dt><dd><p>ECC engine caps info structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oobavail</span></code></dt><dd><p>OOB size that the ECC engine can use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Choose the max ECC strength that is supported on the controller, and can fit
within the chip’s OOB.  On success, the chosen ECC settings are set.</p>
</div>
<dl class="function">
<dt id="c.nand_scan_tail">
int <code class="sig-name descname">nand_scan_tail</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_scan_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan for the NAND device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*chip</span></code></dt><dd><p>NAND chip object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the second phase of the normal nand_scan() function. It fills out
all the uninitialized function pointers with the defaults and scans for a
bad block table if appropriate.</p>
</div>
<dl class="function">
<dt id="c.check_pattern">
int <code class="sig-name descname">check_pattern</code><span class="sig-paren">(</span>uint8_t<em> *buf</em>, int<em> len</em>, int<em> paglen</em>, struct nand_bbt_descr<em> *td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.check_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] check if a pattern is in the buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>the length of buffer to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">paglen</span></code></dt><dd><p>the pagelength</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>search pattern descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for a pattern at the given place. Used to search bad block tables and
good / bad block identifiers.</p>
</div>
<dl class="function">
<dt id="c.check_short_pattern">
int <code class="sig-name descname">check_short_pattern</code><span class="sig-paren">(</span>uint8_t<em> *buf</em>, struct nand_bbt_descr<em> *td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.check_short_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] check if a pattern is in the buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>the buffer to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>search pattern descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for a pattern at the given place. Used to search bad block tables and
good / bad block identifiers. Same as check_pattern, but no optional empty
check.</p>
</div>
<dl class="function">
<dt id="c.add_marker_len">
u32 <code class="sig-name descname">add_marker_len</code><span class="sig-paren">(</span>struct nand_bbt_descr<em> *td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_marker_len" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the length of the marker in data area</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>BBT descriptor used for computation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The length will be 0 if the marker is located in OOB area.</p>
</div>
<dl class="function">
<dt id="c.read_bbt">
int <code class="sig-name descname">read_bbt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, uint8_t<em> *buf</em>, int<em> page</em>, int<em> num</em>, struct nand_bbt_descr<em> *td</em>, int<em> offs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Read the bad block table starting from page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>temporary buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>the starting page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>the number of bbt descriptors to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>the bbt describtion table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offs</span></code></dt><dd><p>block number offset in the table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the bad block table starting from page.</p>
</div>
<dl class="function">
<dt id="c.read_abs_bbt">
int <code class="sig-name descname">read_abs_bbt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, uint8_t<em> *buf</em>, struct nand_bbt_descr<em> *td</em>, int<em> chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_abs_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Read the bad block table starting at a given page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>temporary buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>descriptor for the bad block table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">chip</span></code></dt><dd><p>read the table for a specific chip, -1 read all chips; applies only if
NAND_BBT_PERCHIP option is set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the bad block table for all chips starting at a given page. We assume
that the bbt bits are in consecutive order.</p>
</div>
<dl class="function">
<dt id="c.scan_read_oob">
int <code class="sig-name descname">scan_read_oob</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, uint8_t<em> *buf</em>, loff_t<em> offs</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scan_read_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Scan data+OOB region to buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>temporary buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt><dd><p>offset at which to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of data region to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan read data from data+OOB. May traverse multiple pages, interleaving
page,OOB,page,OOB,… in buf. Completes transfer and returns the “strongest”
ECC condition (error or bitflip). May quit on the first (non-ECC) error.</p>
</div>
<dl class="function">
<dt id="c.read_abs_bbts">
void <code class="sig-name descname">read_abs_bbts</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, uint8_t<em> *buf</em>, struct nand_bbt_descr<em> *td</em>, struct nand_bbt_descr<em> *md</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_abs_bbts" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Read the bad block table(s) for all chips starting at a given page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>temporary buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>descriptor for the bad block table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*md</span></code></dt><dd><p>descriptor for the bad block table mirror</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the bad block table(s) for all chips starting at a given page. We
assume that the bbt bits are in consecutive order.</p>
</div>
<dl class="function">
<dt id="c.create_bbt">
int <code class="sig-name descname">create_bbt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, uint8_t<em> *buf</em>, struct nand_bbt_descr<em> *bd</em>, int<em> chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.create_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Create a bad block table by scanning the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>temporary buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*bd</span></code></dt><dd><p>descriptor for the good/bad block search pattern</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">chip</span></code></dt><dd><p>create the table for a specific chip, -1 read all chips; applies only
if NAND_BBT_PERCHIP option is set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a bad block table by scanning the device for the given good/bad block
identify pattern.</p>
</div>
<dl class="function">
<dt id="c.search_bbt">
int <code class="sig-name descname">search_bbt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, uint8_t<em> *buf</em>, struct nand_bbt_descr<em> *td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.search_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] scan the device for a specific bad block table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>temporary buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>descriptor for the bad block table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the bad block table by searching for a given ident pattern. Search is
preformed either from the beginning up or from the end of the device
downwards. The search starts always at the start of a block. If the option
NAND_BBT_PERCHIP is given, each chip is searched for a bbt, which contains
the bad block information of this chip. This is necessary to provide support
for certain DOC devices.</p>
<p>The bbt ident pattern resides in the oob area of the first page in a block.</p>
</div>
<dl class="function">
<dt id="c.search_read_bbts">
void <code class="sig-name descname">search_read_bbts</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, uint8_t<em> *buf</em>, struct nand_bbt_descr<em> *td</em>, struct nand_bbt_descr<em> *md</em><span class="sig-paren">)</span><a class="headerlink" href="#c.search_read_bbts" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] scan the device for bad block table(s)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>temporary buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>descriptor for the bad block table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*md</span></code></dt><dd><p>descriptor for the bad block table mirror</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search and read the bad block table(s).</p>
</div>
<dl class="function">
<dt id="c.get_bbt_block">
int <code class="sig-name descname">get_bbt_block</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, struct nand_bbt_descr<em> *td</em>, struct nand_bbt_descr<em> *md</em>, int<em> chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_bbt_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first valid eraseblock suitable to store a BBT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>the NAND device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>the BBT description</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*md</span></code></dt><dd><p>the mirror BBT descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">chip</span></code></dt><dd><p>the CHIP selector</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions returns a positive block number pointing a valid eraseblock
suitable to store a BBT (i.e. in the range reserved for BBT), or -ENOSPC if
all blocks are already used of marked bad. If td-&gt;pages[chip] was already
pointing to a valid block we re-use it, otherwise we search for the next
valid one.</p>
</div>
<dl class="function">
<dt id="c.mark_bbt_block_bad">
void <code class="sig-name descname">mark_bbt_block_bad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, struct nand_bbt_descr<em> *td</em>, int<em> chip</em>, int<em> block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mark_bbt_block_bad" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark one of the block reserved for BBT bad</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>the NAND device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>the BBT description</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">chip</span></code></dt><dd><p>the CHIP selector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">block</span></code></dt><dd><p>the BBT block to mark</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Blocks reserved for BBT can become bad. This functions is an helper to mark
such blocks as bad. It takes care of updating the in-memory BBT, marking the
block as bad using a bad block marker and invalidating the associated
td-&gt;pages[] entry.</p>
</div>
<dl class="function">
<dt id="c.write_bbt">
int <code class="sig-name descname">write_bbt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, uint8_t<em> *buf</em>, struct nand_bbt_descr<em> *td</em>, struct nand_bbt_descr<em> *md</em>, int<em> chipsel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] (Re)write the bad block table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>temporary buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>descriptor for the bad block table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*md</span></code></dt><dd><p>descriptor for the bad block table mirror</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">chipsel</span></code></dt><dd><p>selector for a specific chip, -1 for all</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>(Re)write the bad block table.</p>
</div>
<dl class="function">
<dt id="c.nand_memory_bbt">
int <code class="sig-name descname">nand_memory_bbt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, struct nand_bbt_descr<em> *bd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_memory_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] create a memory based bad block table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*bd</span></code></dt><dd><p>descriptor for the good/bad block search pattern</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function creates a memory based bbt by scanning the device for
manufacturer / software marked good / bad blocks.</p>
</div>
<dl class="function">
<dt id="c.check_create">
int <code class="sig-name descname">check_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, uint8_t<em> *buf</em>, struct nand_bbt_descr<em> *bd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.check_create" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] create and write bbt(s) if necessary</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>the NAND device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint8_t</span> <span class="pre">*buf</span></code></dt><dd><p>temporary buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*bd</span></code></dt><dd><p>descriptor for the good/bad block search pattern</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function checks the results of the previous call to read_bbt and creates
/ updates the bbt(s) if necessary. Creation is necessary if no bbt was found
for the chip/device. Update is necessary if one of the tables is missing or
the version nr. of one table is less than the other.</p>
</div>
<dl class="function">
<dt id="c.nand_update_bbt">
int <code class="sig-name descname">nand_update_bbt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, loff_t<em> offs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_update_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>update bad block table(s)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>the NAND device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt><dd><p>the offset of the newly marked block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function updates the bad block table(s).</p>
</div>
<dl class="function">
<dt id="c.mark_bbt_region">
void <code class="sig-name descname">mark_bbt_region</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, struct nand_bbt_descr<em> *td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mark_bbt_region" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] mark the bad block table regions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>the NAND device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*td</span></code></dt><dd><p>bad block table descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The bad block table regions are marked as “bad” to prevent accidental
erasures / writes. The regions are identified by the mark 0x02.</p>
</div>
<dl class="function">
<dt id="c.verify_bbt_descr">
void <code class="sig-name descname">verify_bbt_descr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, struct nand_bbt_descr<em> *bd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.verify_bbt_descr" title="Permalink to this definition">¶</a></dt>
<dd><p>verify the bad block description</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>the NAND device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*bd</span></code></dt><dd><p>the table to verify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions performs a few sanity checks on the bad block description
table.</p>
</div>
<dl class="function">
<dt id="c.nand_scan_bbt">
int <code class="sig-name descname">nand_scan_bbt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, struct nand_bbt_descr<em> *bd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_scan_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] scan, find, read and maybe create bad block table(s)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>the NAND device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*bd</span></code></dt><dd><p>descriptor for the good/bad block search pattern</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function checks, if a bad block table(s) is/are already available. If
not it scans the device for manufacturer marked good / bad blocks and writes
the bad block table(s) to the selected place.</p>
<p>The bad block table memory is allocated here. It must be freed by calling
the nand_free_bbt function.</p>
</div>
<dl class="function">
<dt id="c.nand_create_badblock_pattern">
int <code class="sig-name descname">nand_create_badblock_pattern</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_create_badblock_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] Creates a BBT descriptor structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip to create descriptor for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates and initializes a nand_bbt_descr for BBM detection
based on the properties of <strong>this</strong>. The new descriptor is stored in
this-&gt;badblock_pattern. Thus, this-&gt;badblock_pattern should be NULL when
passed to this function.</p>
</div>
<dl class="function">
<dt id="c.nand_isreserved_bbt">
int <code class="sig-name descname">nand_isreserved_bbt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, loff_t<em> offs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_isreserved_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Check if a block is reserved</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt><dd><p>offset in the device</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_isbad_bbt">
int <code class="sig-name descname">nand_isbad_bbt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, loff_t<em> offs</em>, int<em> allowbbt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_isbad_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Check if a block is bad</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt><dd><p>offset in the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">allowbbt</span></code></dt><dd><p>allow access to bad block table region</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.nand_markbad_bbt">
int <code class="sig-name descname">nand_markbad_bbt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a><em> *this</em>, loff_t<em> offs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_markbad_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Mark a block bad in the BBT</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*this</span></code></dt><dd><p>NAND chip object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt><dd><p>offset of the bad block</p>
</dd>
</dl>
</div>
</section>
<section id="credits">
<h2>Credits<a class="headerlink" href="#credits" title="Permalink to this headline">¶</a></h2>
<p>The following people have contributed to the NAND driver:</p>
<ol class="arabic simple">
<li><p>Steven J. Hill<a class="reference external" href="mailto:sjhill&#37;&#52;&#48;realitydiluted&#46;com">sjhill<span>&#64;</span>realitydiluted<span>&#46;</span>com</a></p></li>
<li><p>David Woodhouse<a class="reference external" href="mailto:dwmw2&#37;&#52;&#48;infradead&#46;org">dwmw2<span>&#64;</span>infradead<span>&#46;</span>org</a></p></li>
<li><p>Thomas Gleixner<a class="reference external" href="mailto:tglx&#37;&#52;&#48;linutronix&#46;de">tglx<span>&#64;</span>linutronix<span>&#46;</span>de</a></p></li>
</ol>
<p>A lot of users have provided bugfixes, improvements and helping hands
for testing. Thanks a lot.</p>
<p>The following people have contributed to this document:</p>
<ol class="arabic simple">
<li><p>Thomas Gleixner<a class="reference external" href="mailto:tglx&#37;&#52;&#48;linutronix&#46;de">tglx<span>&#64;</span>linutronix<span>&#46;</span>de</a></p></li>
</ol>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">MTD NAND Driver Programming Interface</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#known-bugs-and-assumptions">Known Bugs And Assumptions</a></li>
<li><a class="reference internal" href="#documentation-hints">Documentation hints</a><ul>
<li><a class="reference internal" href="#function-identifiers-xxx">Function identifiers [XXX]</a></li>
<li><a class="reference internal" href="#struct-member-identifiers-xxx">Struct member identifiers [XXX]</a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-board-driver">Basic board driver</a><ul>
<li><a class="reference internal" href="#basic-defines">Basic defines</a></li>
<li><a class="reference internal" href="#partition-defines">Partition defines</a></li>
<li><a class="reference internal" href="#hardware-control-function">Hardware control function</a></li>
<li><a class="reference internal" href="#device-ready-function">Device ready function</a></li>
<li><a class="reference internal" href="#init-function">Init function</a></li>
<li><a class="reference internal" href="#exit-function">Exit function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-board-driver-functions">Advanced board driver functions</a><ul>
<li><a class="reference internal" href="#multiple-chip-control">Multiple chip control</a></li>
<li><a class="reference internal" href="#hardware-ecc-support">Hardware ECC support</a><ul>
<li><a class="reference internal" href="#functions-and-constants">Functions and constants</a></li>
<li><a class="reference internal" href="#hardware-ecc-with-syndrome-calculation">Hardware ECC with syndrome calculation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bad-block-table-support">Bad block table support</a><ul>
<li><a class="reference internal" href="#flash-based-tables">Flash based tables</a></li>
<li><a class="reference internal" href="#user-defined-tables">User defined tables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#spare-area-auto-placement">Spare area (auto)placement</a><ul>
<li><a class="reference internal" href="#placement-defined-by-fs-driver">Placement defined by fs driver</a></li>
<li><a class="reference internal" href="#automatic-placement">Automatic placement</a></li>
</ul>
</li>
<li><a class="reference internal" href="#spare-area-autoplacement-default-schemes">Spare area autoplacement default schemes</a><ul>
<li><a class="reference internal" href="#byte-pagesize">256 byte pagesize</a></li>
<li><a class="reference internal" href="#id1">512 byte pagesize</a></li>
<li><a class="reference internal" href="#id2">2048 byte pagesize</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#filesystem-support">Filesystem support</a></li>
<li><a class="reference internal" href="#tools">Tools</a></li>
<li><a class="reference internal" href="#constants">Constants</a><ul>
<li><a class="reference internal" href="#chip-option-constants">Chip option constants</a><ul>
<li><a class="reference internal" href="#constants-for-chip-id-table">Constants for chip id table</a></li>
<li><a class="reference internal" href="#constants-for-runtime-options">Constants for runtime options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ecc-selection-constants">ECC selection constants</a></li>
<li><a class="reference internal" href="#hardware-control-related-constants">Hardware control related constants</a></li>
<li><a class="reference internal" href="#bad-block-table-related-constants">Bad block table related constants</a></li>
</ul>
</li>
<li><a class="reference internal" href="#structures">Structures</a></li>
<li><a class="reference internal" href="#public-functions-provided">Public Functions Provided</a></li>
<li><a class="reference internal" href="#internal-functions-provided">Internal Functions Provided</a></li>
<li><a class="reference internal" href="#credits">Credits</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/mtdnand.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/mtdnand.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>