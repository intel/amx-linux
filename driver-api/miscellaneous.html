
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Parallel Port Devices &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Intel(R) Management Engine Interface (Intel(R) MEI)" href="mei/index.html" />
    <link rel="prev" title="MTD NAND Driver Programming Interface" href="mtdnand.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="parallel-port-devices">
<h1>Parallel Port Devices<a class="headerlink" href="#parallel-port-devices" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="c.parport_register_driver">
<code class="sig-name descname">parport_register_driver</code><span class="sig-paren">(</span><em>driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>register a parallel port device driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>structure describing the driver</p>
<p>This can be called by a parallel port device driver in order
to receive notifications about ports being found in the
system, as well as ports no longer available.</p>
<p>If devmodel is true then the new device model is used
for registration.</p>
<p>The <strong>driver</strong> structure is allocated by the caller and must not be
deallocated until after calling <a class="reference internal" href="#c.parport_unregister_driver" title="parport_unregister_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_unregister_driver()</span></code></a>.</p>
<p>If using the non device model:
The driver’s attach() function may block.  The port that
attach() is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> to do so.  Calling
parport_register_device() on that port will do this for you.</p>
<p>The driver’s detach() function may block.  The port that
detach() is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> to do so.</p>
<p>Returns 0 on success. The non device model will always succeeds.
but the new device model can fail and will return the error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.module_parport_driver">
<code class="sig-name descname">module_parport_driver</code><span class="sig-paren">(</span><em>__parport_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_parport_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a modular parport driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__parport_driver</span></code></dt><dd><p>struct parport_driver to be used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for parport drivers which do not do anything special in module
init and exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.parport_yield">
int <code class="sig-name descname">parport_yield</code><span class="sig-paren">(</span>struct pardevice<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_yield" title="Permalink to this definition">¶</a></dt>
<dd><p>relinquish a parallel port temporarily</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>a device on the parallel port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function relinquishes the port if it would be helpful to other
drivers to do so.  Afterwards it tries to reclaim the port using
<a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a>, and the return value is the same as for
<a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a>.  If it fails, the port is left unclaimed and it is
the driver’s responsibility to reclaim the port.</p>
<p>The <a class="reference internal" href="#c.parport_yield" title="parport_yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_yield()</span></code></a> and <a class="reference internal" href="#c.parport_yield_blocking" title="parport_yield_blocking"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_yield_blocking()</span></code></a> functions are for
marking points in the driver at which other drivers may claim the
port and use their devices.  Yielding the port is similar to
releasing it and reclaiming it, but is more efficient because no
action is taken if there are no other devices needing the port.  In
fact, nothing is done even if there are other devices waiting but
the current device is still within its “timeslice”.  The default
timeslice is half a second, but it can be adjusted via the /proc
interface.</p>
</div>
<dl class="function">
<dt id="c.parport_yield_blocking">
int <code class="sig-name descname">parport_yield_blocking</code><span class="sig-paren">(</span>struct pardevice<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_yield_blocking" title="Permalink to this definition">¶</a></dt>
<dd><p>relinquish a parallel port temporarily</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>a device on the parallel port</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function relinquishes the port if it would be helpful to other
drivers to do so.  Afterwards it tries to reclaim the port using
<a class="reference internal" href="#c.parport_claim_or_block" title="parport_claim_or_block"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim_or_block()</span></code></a>, and the return value is the same as for
<a class="reference internal" href="#c.parport_claim_or_block" title="parport_claim_or_block"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim_or_block()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.parport_wait_event">
int <code class="sig-name descname">parport_wait_event</code><span class="sig-paren">(</span>struct parport<em> *port</em>, signed long<em> timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_wait_event" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for an event on a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>time to wait (in jiffies)</p>
<p>This function waits for up to <strong>timeout</strong> jiffies for an
interrupt to occur on a parallel port.  If the port timeout is
set to zero, it returns immediately.</p>
<p>If an interrupt occurs before the timeout period elapses, this
function returns zero immediately.  If it times out, it returns
one.  An error code less than zero indicates an error (most
likely a pending signal), and the calling code should finish
what it’s doing as soon as it can.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_wait_peripheral">
int <code class="sig-name descname">parport_wait_peripheral</code><span class="sig-paren">(</span>struct parport<em> *port</em>, unsigned char<em> mask</em>, unsigned char<em> result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_wait_peripheral" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for status lines to change in 35ms</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to watch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">mask</span></code></dt><dd><p>status lines to watch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">result</span></code></dt><dd><p>desired values of chosen status lines</p>
<p>This function waits until the masked status lines have the
desired values, or until 35ms have elapsed (see IEEE 1284-1994
page 24 to 25 for why this value in particular is hardcoded).
The <strong>mask</strong> and <strong>result</strong> parameters are bitmasks, with the bits
defined by the constants in parport.h: <code class="docutils literal notranslate"><span class="pre">PARPORT_STATUS_BUSY</span></code>,
and so on.</p>
<p>The port is polled quickly to start off with, in anticipation
of a fast response from the peripheral.  This fast polling
time is configurable (using /proc), and defaults to 500usec.
If the timeout for this port (see <a class="reference internal" href="#c.parport_set_timeout" title="parport_set_timeout"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_set_timeout()</span></code></a>) is
zero, the fast polling time is 35ms, and this function does
not call schedule().</p>
<p>If the timeout for this port is non-zero, after the fast
polling fails it uses <a class="reference internal" href="#c.parport_wait_event" title="parport_wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_wait_event()</span></code></a> to wait for up to
10ms, waking up if an interrupt occurs.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_negotiate">
int <code class="sig-name descname">parport_negotiate</code><span class="sig-paren">(</span>struct parport<em> *port</em>, int<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_negotiate" title="Permalink to this definition">¶</a></dt>
<dd><p>negotiate an IEEE 1284 mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>mode to negotiate to</p>
<p>Use this to negotiate to a particular IEEE 1284 transfer mode.
The <strong>mode</strong> parameter should be one of the constants in
parport.h starting <code class="docutils literal notranslate"><span class="pre">IEEE1284_MODE_xxx</span></code>.</p>
<p>The return value is 0 if the peripheral has accepted the
negotiation to the mode specified, -1 if the peripheral is not
IEEE 1284 compliant (or not present), or 1 if the peripheral
has rejected the negotiation.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_write">
ssize_t <code class="sig-name descname">parport_write</code><span class="sig-paren">(</span>struct parport<em> *port</em>, const void<em> *buffer</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a block of data to a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>data buffer (in kernel space)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes of data to transfer</p>
<p>This will write up to <strong>len</strong> bytes of <strong>buffer</strong> to the port
specified, using the IEEE 1284 transfer mode most recently
negotiated to (using <a class="reference internal" href="#c.parport_negotiate" title="parport_negotiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_negotiate()</span></code></a>), as long as that
mode supports forward transfers (host to peripheral).</p>
<p>It is the caller’s responsibility to ensure that the first
<strong>len</strong> bytes of <strong>buffer</strong> are valid.</p>
<p>This function returns the number of bytes transferred (if zero
or positive), or else an error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_read">
ssize_t <code class="sig-name descname">parport_read</code><span class="sig-paren">(</span>struct parport<em> *port</em>, void<em> *buffer</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read a block of data from a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>data buffer (in kernel space)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>number of bytes of data to transfer</p>
<p>This will read up to <strong>len</strong> bytes of <strong>buffer</strong> to the port
specified, using the IEEE 1284 transfer mode most recently
negotiated to (using <a class="reference internal" href="#c.parport_negotiate" title="parport_negotiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_negotiate()</span></code></a>), as long as that
mode supports reverse transfers (peripheral to host).</p>
<p>It is the caller’s responsibility to ensure that the first
<strong>len</strong> bytes of <strong>buffer</strong> are available to write to.</p>
<p>This function returns the number of bytes transferred (if zero
or positive), or else an error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_set_timeout">
long <code class="sig-name descname">parport_set_timeout</code><span class="sig-paren">(</span>struct pardevice<em> *dev</em>, long<em> inactivity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_set_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>set the inactivity timeout for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>device on a port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">inactivity</span></code></dt><dd><p>inactivity timeout (in jiffies)</p>
<p>This sets the inactivity timeout for a particular device on a
port.  This affects functions like <a class="reference internal" href="#c.parport_wait_peripheral" title="parport_wait_peripheral"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_wait_peripheral()</span></code></a>.
The special value 0 means not to call schedule() while dealing
with this device.</p>
<p>The return value is the previous inactivity timeout.</p>
<p>Any callers of <a class="reference internal" href="#c.parport_wait_event" title="parport_wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_wait_event()</span></code></a> for this device are woken
up.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__parport_register_driver">
int <code class="sig-name descname">__parport_register_driver</code><span class="sig-paren">(</span>struct parport_driver<em> *drv</em>, struct module<em> *owner</em>, const char<em> *mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__parport_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>register a parallel port device driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport_driver</span> <span class="pre">*drv</span></code></dt><dd><p>structure describing the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>owner module of drv</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mod_name</span></code></dt><dd><p>module name string</p>
<p>This can be called by a parallel port device driver in order
to receive notifications about ports being found in the
system, as well as ports no longer available.</p>
<p>If devmodel is true then the new device model is used
for registration.</p>
<p>The <strong>drv</strong> structure is allocated by the caller and must not be
deallocated until after calling <a class="reference internal" href="#c.parport_unregister_driver" title="parport_unregister_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_unregister_driver()</span></code></a>.</p>
<p>If using the non device model:
The driver’s attach() function may block.  The port that
attach() is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> to do so.  Calling
parport_register_device() on that port will do this for you.</p>
<p>The driver’s detach() function may block.  The port that
detach() is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> to do so.</p>
<p>Returns 0 on success. The non device model will always succeeds.
but the new device model can fail and will return the error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_unregister_driver">
void <code class="sig-name descname">parport_unregister_driver</code><span class="sig-paren">(</span>struct parport_driver<em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a parallel port device driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport_driver</span> <span class="pre">*drv</span></code></dt><dd><p>structure describing the driver that was given to
<a class="reference internal" href="#c.parport_register_driver" title="parport_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_driver()</span></code></a></p>
<blockquote>
<div><p>This should be called by a parallel port device driver that
has registered itself using <a class="reference internal" href="#c.parport_register_driver" title="parport_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_driver()</span></code></a> when it
is about to be unloaded.</p>
<p>When it returns, the driver’s attach() routine will no longer
be called, and for each port that attach() was called for, the
detach() routine will have been called.</p>
<p>All the driver’s attach() and detach() calls are guaranteed to have
finished by the time this function returns.</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_get_port">
struct parport * <code class="sig-name descname">parport_get_port</code><span class="sig-paren">(</span>struct parport<em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_get_port" title="Permalink to this definition">¶</a></dt>
<dd><p>increment a port’s reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>the port</p>
<p>This ensures that a struct parport pointer remains valid
until the matching <a class="reference internal" href="#c.parport_put_port" title="parport_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_put_port()</span></code></a> call.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_put_port">
void <code class="sig-name descname">parport_put_port</code><span class="sig-paren">(</span>struct parport<em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_put_port" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement a port’s reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>the port</p>
<p>This should be called once for each call to <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a>,
once the port is no longer needed. When the reference count reaches
zero (port is no longer used), free_port is called.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_register_port">
struct parport * <code class="sig-name descname">parport_register_port</code><span class="sig-paren">(</span>unsigned long<em> base</em>, int<em> irq</em>, int<em> dma</em>, struct parport_operations<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_register_port" title="Permalink to this definition">¶</a></dt>
<dd><p>register a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">base</span></code></dt><dd><p>base I/O address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>IRQ line</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dma</span></code></dt><dd><p>DMA channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport_operations</span> <span class="pre">*ops</span></code></dt><dd><p>pointer to the port driver’s port operations structure</p>
<p>When a parallel port (lowlevel) driver finds a port that
should be made available to parallel port device drivers, it
should call <a class="reference internal" href="#c.parport_register_port" title="parport_register_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_port()</span></code></a>.  The <strong>base</strong>, <strong>irq</strong>, and
<strong>dma</strong> parameters are for the convenience of port drivers, and
for ports where they aren’t meaningful needn’t be set to
anything special.  They can be altered afterwards by adjusting
the relevant members of the parport structure that is returned
and represents the port.  They should not be tampered with
after calling parport_announce_port, however.</p>
<p>If there are parallel port device drivers in the system that
have registered themselves using <a class="reference internal" href="#c.parport_register_driver" title="parport_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_driver()</span></code></a>,
they are not told about the port at this time; that is done by
<a class="reference internal" href="#c.parport_announce_port" title="parport_announce_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_announce_port()</span></code></a>.</p>
<p>The <strong>ops</strong> structure is allocated by the caller, and must not be
deallocated before calling <a class="reference internal" href="#c.parport_remove_port" title="parport_remove_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_remove_port()</span></code></a>.</p>
<p>If there is no memory to allocate a new parport structure,
this function will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_announce_port">
void <code class="sig-name descname">parport_announce_port</code><span class="sig-paren">(</span>struct parport<em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_announce_port" title="Permalink to this definition">¶</a></dt>
<dd><p>tell device drivers about a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>parallel port to announce</p>
<p>After a port driver has registered a parallel port with
parport_register_port, and performed any necessary
initialisation or adjustments, it should call
<a class="reference internal" href="#c.parport_announce_port" title="parport_announce_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_announce_port()</span></code></a> in order to notify all device drivers
that have called <a class="reference internal" href="#c.parport_register_driver" title="parport_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_driver()</span></code></a>.  Their attach()
functions will be called, with <strong>port</strong> as the parameter.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_remove_port">
void <code class="sig-name descname">parport_remove_port</code><span class="sig-paren">(</span>struct parport<em> *port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_remove_port" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>parallel port to deregister</p>
<p>When a parallel port driver is forcibly unloaded, or a
parallel port becomes inaccessible, the port driver must call
this function in order to deal with device drivers that still
want to use it.</p>
<p>The parport structure associated with the port has its
operations structure replaced with one containing ‘null’
operations that return errors or just don’t do anything.</p>
<p>Any drivers that have registered themselves using
<a class="reference internal" href="#c.parport_register_driver" title="parport_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_register_driver()</span></code></a> are notified that the port is no
longer accessible by having their detach() routines called
with <strong>port</strong> as the parameter.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_register_dev_model">
struct pardevice * <code class="sig-name descname">parport_register_dev_model</code><span class="sig-paren">(</span>struct parport<em> *port</em>, const char<em> *name</em>, const struct pardev_cb<em> *par_dev_cb</em>, int<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_register_dev_model" title="Permalink to this definition">¶</a></dt>
<dd><p>register a device on a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">parport</span> <span class="pre">*port</span></code></dt><dd><p>port to which the device is attached</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a name to refer to the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pardev_cb</span> <span class="pre">*par_dev_cb</span></code></dt><dd><p>struct containing callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>device number to be given to the device</p>
<p>This function, called by parallel port device drivers,
declares that a device is connected to a port, and tells the
system all it needs to know.</p>
<p>The struct pardev_cb contains pointer to callbacks. preemption
callback function, <strong>preempt</strong>, is called when this device driver
has claimed access to the port but another device driver wants
to use it.  It is given, <strong>private</strong>, as its parameter, and should
return zero if it is willing for the system to release the port
to another driver on its behalf. If it wants to keep control of
the port it should return non-zero, and no action will be taken.
It is good manners for the driver to try to release the port at
the earliest opportunity after its preemption callback rejects a
preemption attempt. Note that if a preemption callback is happy
for preemption to go ahead, there is no need to release the
port; it is done automatically. This function may not block, as
it may be called from interrupt context. If the device driver
does not support preemption, <strong>preempt</strong> can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>The wake-up (“kick”) callback function, <strong>wakeup</strong>, is called when
the port is available to be claimed for exclusive access; that
is, <a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a> is guaranteed to succeed when called from
inside the wake-up callback function.  If the driver wants to
claim the port it should do so; otherwise, it need not take
any action.  This function may not block, as it may be called
from interrupt context.  If the device driver does not want to
be explicitly invited to claim the port in this way, <strong>wakeup</strong> can
be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>The interrupt handler, <strong>irq_func</strong>, is called when an interrupt
arrives from the parallel port.  Note that if a device driver
wants to use interrupts it should use parport_enable_irq(),
and can also check the irq member of the parport structure
representing the port.</p>
<p>The parallel port (lowlevel) driver is the one that has called
<a class="reference internal" href="../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> and whose interrupt handler is called first.
This handler does whatever needs to be done to the hardware to
acknowledge the interrupt (for PC-style ports there is nothing
special to be done).  It then tells the IEEE 1284 code about
the interrupt, which may involve reacting to an IEEE 1284
event depending on the current IEEE 1284 phase.  After this,
it calls <strong>irq_func</strong>.  Needless to say, <strong>irq_func</strong> will be called
from interrupt context, and may not block.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PARPORT_DEV_EXCL</span></code> flag is for preventing port sharing, and
so should only be used when sharing the port with other device
drivers is impossible and would lead to incorrect behaviour.
Use it sparingly!  Normally, <strong>flags</strong> will be zero.</p>
<p>This function returns a pointer to a structure that represents
the device on the port, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is not enough memory
to allocate space for that structure.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_unregister_device">
void <code class="sig-name descname">parport_unregister_device</code><span class="sig-paren">(</span>struct pardevice<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a device on a parallel port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to structure representing device</p>
<p>This undoes the effect of parport_register_device().</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_find_number">
struct parport * <code class="sig-name descname">parport_find_number</code><span class="sig-paren">(</span>int<em> number</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_find_number" title="Permalink to this definition">¶</a></dt>
<dd><p>find a parallel port by number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">number</span></code></dt><dd><p>parallel port number</p>
<p>This returns the parallel port with the specified number, or
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is none.</p>
<p>There is an implicit <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> done already; to throw
away the reference to the port that <a class="reference internal" href="#c.parport_find_number" title="parport_find_number"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_find_number()</span></code></a>
gives you, use <a class="reference internal" href="#c.parport_put_port" title="parport_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_put_port()</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_find_base">
struct parport * <code class="sig-name descname">parport_find_base</code><span class="sig-paren">(</span>unsigned long<em> base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_find_base" title="Permalink to this definition">¶</a></dt>
<dd><p>find a parallel port by base address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">base</span></code></dt><dd><p>base I/O address</p>
<p>This returns the parallel port with the specified base
address, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is none.</p>
<p>There is an implicit <a class="reference internal" href="#c.parport_get_port" title="parport_get_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_get_port()</span></code></a> done already; to throw
away the reference to the port that <a class="reference internal" href="#c.parport_find_base" title="parport_find_base"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_find_base()</span></code></a>
gives you, use <a class="reference internal" href="#c.parport_put_port" title="parport_put_port"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_put_port()</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_claim">
int <code class="sig-name descname">parport_claim</code><span class="sig-paren">(</span>struct pardevice<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_claim" title="Permalink to this definition">¶</a></dt>
<dd><p>claim access to a parallel port device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to structure representing a device on the port</p>
<p>This function will not block and so can be used from interrupt
context.  If <a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a> succeeds in claiming access to
the port it returns zero and the port is available to use.  It
may fail (returning non-zero) if the port is in use by another
driver and that driver is not willing to relinquish control of
the port.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_claim_or_block">
int <code class="sig-name descname">parport_claim_or_block</code><span class="sig-paren">(</span>struct pardevice<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_claim_or_block" title="Permalink to this definition">¶</a></dt>
<dd><p>claim access to a parallel port device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to structure representing a device on the port</p>
<p>This behaves like <a class="reference internal" href="#c.parport_claim" title="parport_claim"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_claim()</span></code></a>, but will block if necessary
to wait for the port to be free.  A return value of 1
indicates that it slept; 0 means that it succeeded without
needing to sleep.  A negative error code indicates failure.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_release">
void <code class="sig-name descname">parport_release</code><span class="sig-paren">(</span>struct pardevice<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_release" title="Permalink to this definition">¶</a></dt>
<dd><p>give up access to a parallel port device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to structure representing parallel port device</p>
<p>This function cannot fail, but it should not be called without
the port claimed.  Similarly, if the port is already claimed
you should not try claiming it again.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_open">
struct pardevice * <code class="sig-name descname">parport_open</code><span class="sig-paren">(</span>int<em> devnum</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_open" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by canonical device number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devnum</span></code></dt><dd><p>canonical device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name to associate with the device</p>
<p>This function is similar to parport_register_device(), except
that it locates a device by its number rather than by the port
it is attached to.</p>
<p>All parameters except for <strong>devnum</strong> are the same as for
parport_register_device().  The return value is the same as
for parport_register_device().</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.parport_close">
void <code class="sig-name descname">parport_close</code><span class="sig-paren">(</span>struct pardevice<em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parport_close" title="Permalink to this definition">¶</a></dt>
<dd><p>close a device opened with <a class="reference internal" href="#c.parport_open" title="parport_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_open()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pardevice</span> <span class="pre">*dev</span></code></dt><dd><p>device to close</p>
<p>This is to <a class="reference internal" href="#c.parport_open" title="parport_open"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_open()</span></code></a> as <a class="reference internal" href="#c.parport_unregister_device" title="parport_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">parport_unregister_device()</span></code></a> is to
parport_register_device().</p>
</dd>
</dl>
</div>
</section>
<section id="x50-uart-driver">
<h1>16x50 UART Driver<a class="headerlink" href="#x50-uart-driver" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="c.serial8250_get_port">
struct uart_8250_port * <code class="sig-name descname">serial8250_get_port</code><span class="sig-paren">(</span>int<em> line</em><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_get_port" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve struct uart_8250_port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt><dd><p>serial line number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function retrieves struct uart_8250_port for the specific line.
This struct <em>must</em> <em>not</em> be used to perform a 8250 or serial core operation
which is not accessible otherwise. Its only purpose is to make the struct
accessible to the runtime-pm callbacks for context suspend/restore.
The lock assumption made here is none because runtime-pm suspend/resume
callbacks should not be invoked if there is any operation performed on the
port.</p>
</div>
<dl class="function">
<dt id="c.serial8250_suspend_port">
void <code class="sig-name descname">serial8250_suspend_port</code><span class="sig-paren">(</span>int<em> line</em><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_suspend_port" title="Permalink to this definition">¶</a></dt>
<dd><p>suspend one serial port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt><dd><p>serial line number</p>
<p>Suspend one serial port.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.serial8250_resume_port">
void <code class="sig-name descname">serial8250_resume_port</code><span class="sig-paren">(</span>int<em> line</em><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_resume_port" title="Permalink to this definition">¶</a></dt>
<dd><p>resume one serial port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt><dd><p>serial line number</p>
<p>Resume one serial port.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.serial8250_register_8250_port">
int <code class="sig-name descname">serial8250_register_8250_port</code><span class="sig-paren">(</span>const struct uart_8250_port<em> *up</em><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_register_8250_port" title="Permalink to this definition">¶</a></dt>
<dd><p>register a serial port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">uart_8250_port</span> <span class="pre">*up</span></code></dt><dd><p>serial port template</p>
<p>Configure the serial port specified by the request. If the
port exists and is in use, it is hung up and unregistered
first.</p>
<p>The port is then probed and if necessary the IRQ is autodetected
If this fails an error is returned.</p>
<p>On success the port is ready to use and the line number is returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.serial8250_unregister_port">
void <code class="sig-name descname">serial8250_unregister_port</code><span class="sig-paren">(</span>int<em> line</em><span class="sig-paren">)</span><a class="headerlink" href="#c.serial8250_unregister_port" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a 16x50 serial port at runtime</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">line</span></code></dt><dd><p>serial line number</p>
<p>Remove one serial port.  This may not be called from interrupt
context.  We hand the port back to the our control.</p>
</dd>
</dl>
</div>
<p>See <a class="reference internal" href="serial/driver.html"><span class="doc">Low Level Serial API</span></a> for related APIs.</p>
</section>
<section id="pulse-width-modulation-pwm">
<h1>Pulse-Width Modulation (PWM)<a class="headerlink" href="#pulse-width-modulation-pwm" title="Permalink to this headline">¶</a></h1>
<p>Pulse-width modulation is a modulation technique primarily used to
control power supplied to electrical devices.</p>
<p>The PWM framework provides an abstraction for providers and consumers of
PWM signals. A controller that provides one or more PWM signals is
registered as <a class="reference internal" href="#c.pwm_chip" title="pwm_chip"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span></code></a>. Providers
are expected to embed this structure in a driver-specific structure.
This structure contains fields that describe a particular chip.</p>
<p>A chip exposes one or more PWM signal sources, each of which exposed as
a <a class="reference internal" href="#c.pwm_device" title="pwm_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span></code></a>. Operations can be
performed on PWM devices to control the period, duty cycle, polarity and
active state of the signal.</p>
<p>Note that PWM devices are exclusive resources: they can always only be
used by one consumer at a time.</p>
<dl class="type">
<dt id="c.pwm_polarity">
enum <code class="sig-name descname">pwm_polarity</code><a class="headerlink" href="#c.pwm_polarity" title="Permalink to this definition">¶</a></dt>
<dd><p>polarity of a PWM signal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">PWM_POLARITY_NORMAL</span></code></dt><dd><p>a high signal for the duration of the duty-
cycle, followed by a low signal for the remainder of the pulse
period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PWM_POLARITY_INVERSED</span></code></dt><dd><p>a low signal for the duration of the duty-
cycle, followed by a high signal for the remainder of the pulse
period</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.pwm_args">
struct <code class="sig-name descname">pwm_args</code><a class="headerlink" href="#c.pwm_args" title="Permalink to this definition">¶</a></dt>
<dd><p>board-dependent PWM arguments</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_args {
    u64 period;
    enum pwm_polarity polarity;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">period</span></code></dt><dd><p>reference period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">polarity</span></code></dt><dd><p>reference polarity</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure describes board-dependent arguments attached to a PWM
device. These arguments are usually retrieved from the PWM lookup table or
device tree.</p>
<p>Do not confuse this with the PWM state: PWM arguments represent the initial
configuration that users want to use on this PWM device rather than the
current PWM hardware state.</p>
<dl class="type">
<dt id="c.pwm_device">
struct <code class="sig-name descname">pwm_device</code><a class="headerlink" href="#c.pwm_device" title="Permalink to this definition">¶</a></dt>
<dd><p>PWM channel object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_device {
    const char *label;
    unsigned long flags;
    unsigned int hwpwm;
    unsigned int pwm;
    struct pwm_chip *chip;
    void *chip_data;
    struct pwm_args args;
    struct pwm_state state;
    struct pwm_state last;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">label</span></code></dt><dd><p>name of the PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>flags associated with the PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwpwm</span></code></dt><dd><p>per-chip relative index of the PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pwm</span></code></dt><dd><p>global index of the PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip</span></code></dt><dd><p>PWM chip providing this PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chip_data</span></code></dt><dd><p>chip-private data associated with the PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">args</span></code></dt><dd><p>PWM arguments</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>last applied state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last</span></code></dt><dd><p>last implemented state (for PWM_DEBUG)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pwm_get_state">
void <code class="sig-name descname">pwm_get_state</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em>, struct pwm_state<em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve the current PWM state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>state to fill with the current PWM state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned PWM state represents the state that was applied by a previous call to
<a class="reference internal" href="#c.pwm_apply_state" title="pwm_apply_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_state()</span></code></a>. Drivers may have to slightly tweak that state before programming it to
hardware. If <a class="reference internal" href="#c.pwm_apply_state" title="pwm_apply_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_state()</span></code></a> was never called, this returns either the current hardware
state (if supported) or the default settings.</p>
</div>
<dl class="function">
<dt id="c.pwm_init_state">
void <code class="sig-name descname">pwm_init_state</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em>, struct pwm_state<em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_init_state" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a new state to be applied with <a class="reference internal" href="#c.pwm_apply_state" title="pwm_apply_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_state()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>state to fill with the prepared PWM state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions prepares a state that can later be tweaked and applied
to the PWM device with <a class="reference internal" href="#c.pwm_apply_state" title="pwm_apply_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_state()</span></code></a>. This is a convenient function
that first retrieves the current PWM state and the replaces the period
and polarity fields with the reference values defined in pwm-&gt;args.
Once the function returns, you can adjust the -&gt;enabled and -&gt;duty_cycle
fields according to your needs before calling <a class="reference internal" href="#c.pwm_apply_state" title="pwm_apply_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_state()</span></code></a>.</p>
<p>-&gt;duty_cycle is initially set to zero to avoid cases where the current
-&gt;duty_cycle value exceed the pwm_args-&gt;period one, which would trigger
an error if the user calls <a class="reference internal" href="#c.pwm_apply_state" title="pwm_apply_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_apply_state()</span></code></a> without adjusting -&gt;duty_cycle
first.</p>
</div>
<dl class="function">
<dt id="c.pwm_get_relative_duty_cycle">
unsigned int <code class="sig-name descname">pwm_get_relative_duty_cycle</code><span class="sig-paren">(</span>const struct pwm_state<em> *state</em>, unsigned int<em> scale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get_relative_duty_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a relative duty cycle value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>PWM state to extract the duty cycle from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">scale</span></code></dt><dd><p>target scale of the relative duty cycle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions converts the absolute duty cycle stored in <strong>state</strong> (expressed
in nanosecond) into a value relative to the period.</p>
<p>For example if you want to get the duty_cycle expressed in percent, call:</p>
<p>pwm_get_state(pwm, <code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>);
duty = pwm_get_relative_duty_cycle(<code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>, 100);</p>
</div>
<dl class="function">
<dt id="c.pwm_set_relative_duty_cycle">
int <code class="sig-name descname">pwm_set_relative_duty_cycle</code><span class="sig-paren">(</span>struct pwm_state<em> *state</em>, unsigned int<em> duty_cycle</em>, unsigned int<em> scale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_set_relative_duty_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a relative duty cycle value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>PWM state to fill</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">duty_cycle</span></code></dt><dd><p>relative duty cycle value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">scale</span></code></dt><dd><p>scale in which <strong>duty_cycle</strong> is expressed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions converts a relative into an absolute duty cycle (expressed
in nanoseconds), and puts the result in state-&gt;duty_cycle.</p>
<p>For example if you want to configure a 50% duty cycle, call:</p>
<p>pwm_init_state(pwm, <code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>);
pwm_set_relative_duty_cycle(<code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>, 50, 100);
pwm_apply_state(pwm, <code class="xref c c-type docutils literal notranslate"><span class="pre">state</span></code>);</p>
<p>This functions returns -EINVAL if <strong>duty_cycle</strong> and/or <strong>scale</strong> are
inconsistent (<strong>scale</strong> == 0 or <strong>duty_cycle</strong> &gt; <strong>scale</strong>).</p>
</div>
<dl class="type">
<dt id="c.pwm_capture">
struct <code class="sig-name descname">pwm_capture</code><a class="headerlink" href="#c.pwm_capture" title="Permalink to this definition">¶</a></dt>
<dd><p>PWM capture data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_capture {
    unsigned int period;
    unsigned int duty_cycle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">period</span></code></dt><dd><p>period of the PWM signal (in nanoseconds)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duty_cycle</span></code></dt><dd><p>duty cycle of the PWM signal (in nanoseconds)</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.pwm_ops">
struct <code class="sig-name descname">pwm_ops</code><a class="headerlink" href="#c.pwm_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>PWM controller operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_ops {
    int (*request)(struct pwm_chip *chip, struct pwm_device *pwm);
    void (*free)(struct pwm_chip *chip, struct pwm_device *pwm);
    int (*capture)(struct pwm_chip *chip, struct pwm_device *pwm, struct pwm_capture *result, unsigned long timeout);
    int (*apply)(struct pwm_chip *chip, struct pwm_device *pwm, const struct pwm_state *state);
    int (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm, struct pwm_state *state);
    struct module *owner;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">request</span></code></dt><dd><p>optional hook for requesting a PWM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free</span></code></dt><dd><p>optional hook for freeing a PWM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">capture</span></code></dt><dd><p>capture and report PWM signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">apply</span></code></dt><dd><p>atomically apply a new PWM config</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_state</span></code></dt><dd><p>get the current PWM state. This function is only
called once per PWM device when the PWM chip is
registered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>helps prevent removal of modules exporting active PWMs</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.pwm_chip">
struct <code class="sig-name descname">pwm_chip</code><a class="headerlink" href="#c.pwm_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>abstract a PWM controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pwm_chip {
    struct device *dev;
    const struct pwm_ops *ops;
    int base;
    unsigned int npwm;
    struct pwm_device * (*of_xlate)(struct pwm_chip *pc, const struct of_phandle_args *args);
    unsigned int of_pwm_n_cells;
    struct list_head list;
    struct pwm_device *pwms;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device providing the PWMs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>callbacks for this PWM controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>number of first PWM controlled by this chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">npwm</span></code></dt><dd><p>number of PWMs controlled by this chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_xlate</span></code></dt><dd><p>request a PWM device given a device tree PWM specifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_pwm_n_cells</span></code></dt><dd><p>number of cells expected in the device tree PWM specifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>list node for internal use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pwms</span></code></dt><dd><p>array of PWM devices allocated by the framework</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pwm_config">
int <code class="sig-name descname">pwm_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em>, int<em> duty_ns</em>, int<em> period_ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_config" title="Permalink to this definition">¶</a></dt>
<dd><p>change a PWM device configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">duty_ns</span></code></dt><dd><p>“on” time (in nanoseconds)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">period_ns</span></code></dt><dd><p>duration (in nanoseconds) of one cycle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.pwm_enable">
int <code class="sig-name descname">pwm_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>start a PWM output toggling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.pwm_disable">
void <code class="sig-name descname">pwm_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>stop a PWM output toggling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pwm_set_chip_data">
int <code class="sig-name descname">pwm_set_chip_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_set_chip_data" title="Permalink to this definition">¶</a></dt>
<dd><p>set private chip data for a PWM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>pointer to chip-specific data</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.pwm_get_chip_data">
void * <code class="sig-name descname">pwm_get_chip_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get_chip_data" title="Permalink to this definition">¶</a></dt>
<dd><p>get private chip data for a PWM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the chip-private data for the PWM device.</p>
</div>
<dl class="function">
<dt id="c.pwmchip_add">
int <code class="sig-name descname">pwmchip_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_chip" title="pwm_chip">pwm_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwmchip_add" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new PWM chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span> <span class="pre">*chip</span></code></dt><dd><p>the PWM chip to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a new PWM chip.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.pwmchip_remove">
void <code class="sig-name descname">pwmchip_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_chip" title="pwm_chip">pwm_chip</a><em> *chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwmchip_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a PWM chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span> <span class="pre">*chip</span></code></dt><dd><p>the PWM chip to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a PWM chip. This function may return busy if the PWM chip provides
a PWM device that is still requested.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.pwm_request">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="sig-name descname">pwm_request</code><span class="sig-paren">(</span>int<em> pwm</em>, const char<em> *label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_request" title="Permalink to this definition">¶</a></dt>
<dd><p>request a PWM device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pwm</span></code></dt><dd><p>global PWM device index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*label</span></code></dt><dd><p>PWM device label</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is deprecated, use <a class="reference internal" href="#c.pwm_get" title="pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_get()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>A pointer to a PWM device or an ERR_PTR()-encoded error code on
failure.</p>
</div>
<dl class="function">
<dt id="c.pwm_request_from_chip">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="sig-name descname">pwm_request_from_chip</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_chip" title="pwm_chip">pwm_chip</a><em> *chip</em>, unsigned int<em> index</em>, const char<em> *label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_request_from_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>request a PWM device relative to a PWM chip</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_chip</span> <span class="pre">*chip</span></code></dt><dd><p>PWM chip</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>per-chip index of the PWM to request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*label</span></code></dt><dd><p>a literal description string of this PWM</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A pointer to the PWM device at the given index of the given PWM
chip. A negative error code is returned if the index is not valid for the
specified PWM chip or if the PWM device cannot be requested.</p>
</div>
<dl class="function">
<dt id="c.pwm_free">
void <code class="sig-name descname">pwm_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a PWM device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is deprecated, use <a class="reference internal" href="#c.pwm_put" title="pwm_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_put()</span></code></a> instead.</p>
</div>
<dl class="function">
<dt id="c.pwm_apply_state">
int <code class="sig-name descname">pwm_apply_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em>, const struct pwm_state<em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_apply_state" title="Permalink to this definition">¶</a></dt>
<dd><p>atomically apply a new state to a PWM device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pwm_state</span> <span class="pre">*state</span></code></dt><dd><p>new state to apply</p>
</dd>
</dl>
</div>
<dl class="function">
<dt>
int <code class="sig-name descname">pwm_capture</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em>, struct <a class="reference internal" href="#c.pwm_capture" title="pwm_capture">pwm_capture</a><em> *result</em>, unsigned long<em> timeout</em><span class="sig-paren">)</span></dt>
<dd><p>capture and report a PWM signal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_capture</span> <span class="pre">*result</span></code></dt><dd><p>structure to fill with capture result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>time to wait, in milliseconds, before giving up on capture</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.pwm_adjust_config">
int <code class="sig-name descname">pwm_adjust_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_adjust_config" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the current PWM config to the PWM arguments</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will adjust the PWM config to the PWM arguments provided
by the DT or PWM lookup table. This is particularly useful to adapt
the bootloader config to the Linux one.</p>
</div>
<dl class="function">
<dt id="c.pwm_get">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="sig-name descname">pwm_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_get" title="Permalink to this definition">¶</a></dt>
<dd><p>look up and request a PWM device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for PWM consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>consumer name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lookup is first attempted using DT. If the device was not instantiated from
a device tree, a PWM chip and a relative index is looked up via a table
supplied by board setup code (see pwm_add_table()).</p>
<p>Once a PWM chip has been found the specified PWM device will be requested
and is ready to be used.</p>
<p><strong>Return</strong></p>
<p>A pointer to the requested PWM device or an ERR_PTR()-encoded
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.pwm_put">
void <code class="sig-name descname">pwm_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a><em> *pwm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pwm_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a PWM device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pwm_device</span> <span class="pre">*pwm</span></code></dt><dd><p>PWM device</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.devm_pwm_get">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="sig-name descname">devm_pwm_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pwm_get" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed <a class="reference internal" href="#c.pwm_get" title="pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_get()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for PWM consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>consumer name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function performs like <a class="reference internal" href="#c.pwm_get" title="pwm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">pwm_get()</span></code></a> but the acquired PWM device will
automatically be released on driver detach.</p>
<p><strong>Return</strong></p>
<p>A pointer to the requested PWM device or an ERR_PTR()-encoded
error code on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_fwnode_pwm_get">
struct <a class="reference internal" href="#c.pwm_device" title="pwm_device">pwm_device</a> * <code class="sig-name descname">devm_fwnode_pwm_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct fwnode_handle<em> *fwnode</em>, const char<em> *con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_fwnode_pwm_get" title="Permalink to this definition">¶</a></dt>
<dd><p>request a resource managed PWM from firmware node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for PWM consumer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>firmware node to get the PWM from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*con_id</span></code></dt><dd><p>consumer name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the PWM device parsed from the firmware node. See of_pwm_get() and
acpi_pwm_get() for a detailed description.</p>
<p><strong>Return</strong></p>
<p>A pointer to the requested PWM device or an ERR_PTR()-encoded
error code on failure.</p>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Parallel Port Devices</a></li>
<li><a class="reference internal" href="#x50-uart-driver">16x50 UART Driver</a></li>
<li><a class="reference internal" href="#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/miscellaneous.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/miscellaneous.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>