
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>VME Device Drivers &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux 802.11 Driver Developer’s Guide" href="80211/index.html" />
    <link rel="prev" title="Writing s390 channel device drivers" href="s390-drivers.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="vme-device-drivers">
<h1>VME Device Drivers<a class="headerlink" href="#vme-device-drivers" title="Permalink to this headline">¶</a></h1>
<section id="driver-registration">
<h2>Driver registration<a class="headerlink" href="#driver-registration" title="Permalink to this headline">¶</a></h2>
<p>As with other subsystems within the Linux kernel, VME device drivers register
with the VME subsystem, typically called from the devices init routine.  This is
achieved via a call to <a class="reference internal" href="#c.vme_register_driver" title="vme_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_register_driver()</span></code></a>.</p>
<p>A pointer to a structure of type <a class="reference internal" href="#c.vme_driver" title="vme_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_driver</span></code></a> must
be provided to the registration function. Along with the maximum number of
devices your driver is able to support.</p>
<p>At the minimum, the ‘.name’, ‘.match’ and ‘.probe’ elements of
<a class="reference internal" href="#c.vme_driver" title="vme_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_driver</span></code></a> should be correctly set. The ‘.name’
element is a pointer to a string holding the device driver’s name.</p>
<p>The ‘.match’ function allows control over which VME devices should be registered
with the driver. The match function should return 1 if a device should be
probed and 0 otherwise. This example match function (from vme_user.c) limits
the number of devices probed to one:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define USER_BUS_MAX    1</span>
<span class="p">...</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vme_user_match</span><span class="p">(</span><span class="k">struct</span> <span class="nc">vme_dev</span><span class="w"> </span><span class="o">*</span><span class="n">vdev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">num</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">USER_BUS_MAX</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The ‘.probe’ element should contain a pointer to the probe routine. The
probe routine is passed a <a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a> pointer as an
argument.</p>
<p>Here, the ‘num’ field refers to the sequential device ID for this specific
driver. The bridge number (or bus number) can be accessed using
dev-&gt;bridge-&gt;num.</p>
<p>A function is also provided to unregister the driver from the VME core called
<a class="reference internal" href="#c.vme_unregister_driver" title="vme_unregister_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_unregister_driver()</span></code></a> and should usually be called from the device
driver’s exit routine.</p>
</section>
<section id="resource-management">
<h2>Resource management<a class="headerlink" href="#resource-management" title="Permalink to this headline">¶</a></h2>
<p>Once a driver has registered with the VME core the provided match routine will
be called the number of times specified during the registration. If a match
succeeds, a non-zero value should be returned. A zero return value indicates
failure. For all successful matches, the probe routine of the corresponding
driver is called. The probe routine is passed a pointer to the devices
device structure. This pointer should be saved, it will be required for
requesting VME resources.</p>
<p>The driver can request ownership of one or more master windows
(<a class="reference internal" href="#c.vme_master_request" title="vme_master_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_master_request()</span></code></a>), slave windows (<a class="reference internal" href="#c.vme_slave_request" title="vme_slave_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_slave_request()</span></code></a>)
and/or dma channels (<a class="reference internal" href="#c.vme_dma_request" title="vme_dma_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_request()</span></code></a>). Rather than allowing the device
driver to request a specific window or DMA channel (which may be used by a
different driver) the API allows a resource to be assigned based on the required
attributes of the driver in question. For slave windows these attributes are
split into the VME address spaces that need to be accessed in ‘aspace’ and VME
bus cycle types required in ‘cycle’. Master windows add a further set of
attributes in ‘width’ specifying the required data transfer widths. These
attributes are defined as bitmasks and as such any combination of the
attributes can be requested for a single window, the core will assign a window
that meets the requirements, returning a pointer of type vme_resource that
should be used to identify the allocated resource when it is used. For DMA
controllers, the request function requires the potential direction of any
transfers to be provided in the route attributes. This is typically VME-to-MEM
and/or MEM-to-VME, though some hardware can support VME-to-VME and MEM-to-MEM
transfers as well as test pattern generation. If an unallocated window fitting
the requirements can not be found a NULL pointer will be returned.</p>
<p>Functions are also provided to free window allocations once they are no longer
required. These functions (<a class="reference internal" href="#c.vme_master_free" title="vme_master_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_master_free()</span></code></a>, <a class="reference internal" href="#c.vme_slave_free" title="vme_slave_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_slave_free()</span></code></a>
and <a class="reference internal" href="#c.vme_dma_free" title="vme_dma_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_free()</span></code></a>) should be passed the pointer to the resource
provided during resource allocation.</p>
</section>
<section id="master-windows">
<h2>Master windows<a class="headerlink" href="#master-windows" title="Permalink to this headline">¶</a></h2>
<p>Master windows provide access from the local processor[s] out onto the VME bus.
The number of windows available and the available access modes is dependent on
the underlying chipset. A window must be configured before it can be used.</p>
<section id="master-window-configuration">
<h3>Master window configuration<a class="headerlink" href="#master-window-configuration" title="Permalink to this headline">¶</a></h3>
<p>Once a master window has been assigned <a class="reference internal" href="#c.vme_master_set" title="vme_master_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_master_set()</span></code></a> can be used to
configure it and <a class="reference internal" href="#c.vme_master_get" title="vme_master_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_master_get()</span></code></a> to retrieve the current settings. The
address spaces, transfer widths and cycle types are the same as described
under resource management, however some of the options are mutually exclusive.
For example, only one address space may be specified.</p>
</section>
<section id="master-window-access">
<h3>Master window access<a class="headerlink" href="#master-window-access" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_master_read" title="vme_master_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_master_read()</span></code></a> can be used to read from and
<a class="reference internal" href="#c.vme_master_write" title="vme_master_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_master_write()</span></code></a> used to write to configured master windows.</p>
<p>In addition to simple reads and writes, <a class="reference internal" href="#c.vme_master_rmw" title="vme_master_rmw"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_master_rmw()</span></code></a> is provided to
do a read-modify-write transaction. Parts of a VME window can also be mapped
into user space memory using <a class="reference internal" href="#c.vme_master_mmap" title="vme_master_mmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_master_mmap()</span></code></a>.</p>
</section>
</section>
<section id="slave-windows">
<h2>Slave windows<a class="headerlink" href="#slave-windows" title="Permalink to this headline">¶</a></h2>
<p>Slave windows provide devices on the VME bus access into mapped portions of the
local memory. The number of windows available and the access modes that can be
used is dependent on the underlying chipset. A window must be configured before
it can be used.</p>
<section id="slave-window-configuration">
<h3>Slave window configuration<a class="headerlink" href="#slave-window-configuration" title="Permalink to this headline">¶</a></h3>
<p>Once a slave window has been assigned <a class="reference internal" href="#c.vme_slave_set" title="vme_slave_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_slave_set()</span></code></a> can be used to
configure it and <a class="reference internal" href="#c.vme_slave_get" title="vme_slave_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_slave_get()</span></code></a> to retrieve the current settings.</p>
<p>The address spaces, transfer widths and cycle types are the same as described
under resource management, however some of the options are mutually exclusive.
For example, only one address space may be specified.</p>
</section>
<section id="slave-window-buffer-allocation">
<h3>Slave window buffer allocation<a class="headerlink" href="#slave-window-buffer-allocation" title="Permalink to this headline">¶</a></h3>
<p>Functions are provided to allow the user to allocate
(<a class="reference internal" href="#c.vme_alloc_consistent" title="vme_alloc_consistent"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_alloc_consistent()</span></code></a>) and free (<a class="reference internal" href="#c.vme_free_consistent" title="vme_free_consistent"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_free_consistent()</span></code></a>)
contiguous buffers which will be accessible by the VME bridge. These functions
do not have to be used, other methods can be used to allocate a buffer, though
care must be taken to ensure that they are contiguous and accessible by the VME
bridge.</p>
</section>
<section id="slave-window-access">
<h3>Slave window access<a class="headerlink" href="#slave-window-access" title="Permalink to this headline">¶</a></h3>
<p>Slave windows map local memory onto the VME bus, the standard methods for
accessing memory should be used.</p>
</section>
</section>
<section id="dma-channels">
<h2>DMA channels<a class="headerlink" href="#dma-channels" title="Permalink to this headline">¶</a></h2>
<p>The VME DMA transfer provides the ability to run link-list DMA transfers. The
API introduces the concept of DMA lists. Each DMA list is a link-list which can
be passed to a DMA controller. Multiple lists can be created, extended,
executed, reused and destroyed.</p>
<section id="list-management">
<h3>List Management<a class="headerlink" href="#list-management" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_new_dma_list" title="vme_new_dma_list"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_new_dma_list()</span></code></a> is provided to create and
<a class="reference internal" href="#c.vme_dma_list_free" title="vme_dma_list_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_list_free()</span></code></a> to destroy DMA lists. Execution of a list will not
automatically destroy the list, thus enabling a list to be reused for repetitive
tasks.</p>
</section>
<section id="list-population">
<h3>List Population<a class="headerlink" href="#list-population" title="Permalink to this headline">¶</a></h3>
<p>An item can be added to a list using <a class="reference internal" href="#c.vme_dma_list_add" title="vme_dma_list_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_list_add()</span></code></a> (the source and
destination attributes need to be created before calling this function, this is
covered under “Transfer Attributes”).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The detailed attributes of the transfers source and destination
are not checked until an entry is added to a DMA list, the request
for a DMA channel purely checks the directions in which the
controller is expected to transfer data. As a result it is
possible for this call to return an error, for example if the
source or destination is in an unsupported VME address space.</p>
</div>
</section>
<section id="transfer-attributes">
<h3>Transfer Attributes<a class="headerlink" href="#transfer-attributes" title="Permalink to this headline">¶</a></h3>
<p>The attributes for the source and destination are handled separately from adding
an item to a list. This is due to the diverse attributes required for each type
of source and destination. There are functions to create attributes for PCI, VME
and pattern sources and destinations (where appropriate):</p>
<blockquote>
<div><ul class="simple">
<li><p>PCI source or destination: <a class="reference internal" href="#c.vme_dma_pci_attribute" title="vme_dma_pci_attribute"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_pci_attribute()</span></code></a></p></li>
<li><p>VME source or destination: <a class="reference internal" href="#c.vme_dma_vme_attribute" title="vme_dma_vme_attribute"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_vme_attribute()</span></code></a></p></li>
<li><p>Pattern source: <a class="reference internal" href="#c.vme_dma_pattern_attribute" title="vme_dma_pattern_attribute"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_pattern_attribute()</span></code></a></p></li>
</ul>
</div></blockquote>
<p>The function <a class="reference internal" href="#c.vme_dma_free_attribute" title="vme_dma_free_attribute"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_free_attribute()</span></code></a> should be used to free an
attribute.</p>
</section>
<section id="list-execution">
<h3>List Execution<a class="headerlink" href="#list-execution" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_dma_list_exec" title="vme_dma_list_exec"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_list_exec()</span></code></a> queues a list for execution and will
return once the list has been executed.</p>
</section>
</section>
<section id="interrupts">
<h2>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline">¶</a></h2>
<p>The VME API provides functions to attach and detach callbacks to specific VME
level and status ID combinations and for the generation of VME interrupts with
specific VME level and status IDs.</p>
<section id="attaching-interrupt-handlers">
<h3>Attaching Interrupt Handlers<a class="headerlink" href="#attaching-interrupt-handlers" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_irq_request" title="vme_irq_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_irq_request()</span></code></a> can be used to attach and
<a class="reference internal" href="#c.vme_irq_free" title="vme_irq_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_irq_free()</span></code></a> to free a specific VME level and status ID combination.
Any given combination can only be assigned a single callback function. A void
pointer parameter is provided, the value of which is passed to the callback
function, the use of this pointer is user undefined. The callback parameters are
as follows. Care must be taken in writing a callback function, callback
functions run in interrupt context:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">callback</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">statid</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">priv</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="interrupt-generation">
<h3>Interrupt Generation<a class="headerlink" href="#interrupt-generation" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_irq_generate" title="vme_irq_generate"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_irq_generate()</span></code></a> can be used to generate a VME interrupt
at a given VME level and VME status ID.</p>
</section>
</section>
<section id="location-monitors">
<h2>Location monitors<a class="headerlink" href="#location-monitors" title="Permalink to this headline">¶</a></h2>
<p>The VME API provides the following functionality to configure the location
monitor.</p>
<section id="location-monitor-management">
<h3>Location Monitor Management<a class="headerlink" href="#location-monitor-management" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_lm_request" title="vme_lm_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_lm_request()</span></code></a> is provided to request the use of a block
of location monitors and <a class="reference internal" href="#c.vme_lm_free" title="vme_lm_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_lm_free()</span></code></a> to free them after they are no
longer required. Each block may provide a number of location monitors,
monitoring adjacent locations. The function <a class="reference internal" href="#c.vme_lm_count" title="vme_lm_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_lm_count()</span></code></a> can be used
to determine how many locations are provided.</p>
</section>
<section id="location-monitor-configuration">
<h3>Location Monitor Configuration<a class="headerlink" href="#location-monitor-configuration" title="Permalink to this headline">¶</a></h3>
<p>Once a bank of location monitors has been allocated, the function
<a class="reference internal" href="#c.vme_lm_set" title="vme_lm_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_lm_set()</span></code></a> is provided to configure the location and mode of the
location monitor. The function <a class="reference internal" href="#c.vme_lm_get" title="vme_lm_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_lm_get()</span></code></a> can be used to retrieve
existing settings.</p>
</section>
<section id="location-monitor-use">
<h3>Location Monitor Use<a class="headerlink" href="#location-monitor-use" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_lm_attach" title="vme_lm_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_lm_attach()</span></code></a> enables a callback to be attached and
<a class="reference internal" href="#c.vme_lm_detach" title="vme_lm_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_lm_detach()</span></code></a> allows on to be detached from each location monitor
location. Each location monitor can monitor a number of adjacent locations. The
callback function is declared as follows.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">callback</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="slot-detection">
<h2>Slot Detection<a class="headerlink" href="#slot-detection" title="Permalink to this headline">¶</a></h2>
<p>The function <a class="reference internal" href="#c.vme_slot_num" title="vme_slot_num"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_slot_num()</span></code></a> returns the slot ID of the provided bridge.</p>
</section>
<section id="bus-detection">
<h2>Bus Detection<a class="headerlink" href="#bus-detection" title="Permalink to this headline">¶</a></h2>
<p>The function <a class="reference internal" href="#c.vme_bus_num" title="vme_bus_num"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_bus_num()</span></code></a> returns the bus ID of the provided bridge.</p>
</section>
<section id="vme-api">
<h2>VME API<a class="headerlink" href="#vme-api" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.vme_dev">
struct <code class="sig-name descname">vme_dev</code><a class="headerlink" href="#c.vme_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure representing a VME device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vme_dev {
    int num;
    struct vme_bridge *bridge;
    struct device dev;
    struct list_head drv_list;
    struct list_head bridge_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num</span></code></dt><dd><p>The device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bridge</span></code></dt><dd><p>Pointer to the bridge device this device is on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Internal device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drv_list</span></code></dt><dd><p>List of devices (per driver)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bridge_list</span></code></dt><dd><p>List of devices (per bridge)</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.vme_driver">
struct <code class="sig-name descname">vme_driver</code><a class="headerlink" href="#c.vme_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure representing a VME driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vme_driver {
    const char *name;
    int (*match)(struct vme_dev *);
    int (*probe)(struct vme_dev *);
    void (*remove)(struct vme_dev *);
    struct device_driver driver;
    struct list_head devices;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Driver name, should be unique among VME drivers and usually the same
as the module name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">match</span></code></dt><dd><p>Callback used to determine whether probe should be run.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>Callback for device binding, called when new device is detected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p>Callback, called on device removal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>Underlying generic device driver structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devices</span></code></dt><dd><p>List of VME devices (<a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a>) associated with this driver.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_alloc_consistent">
void * <code class="sig-name descname">vme_alloc_consistent</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, size_t<em> size</em>, dma_addr_t<em> *dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_alloc_consistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate contiguous memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of allocation required.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*dma</span></code></dt><dd><p>Pointer to variable to store physical address of allocation.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a contiguous block of memory for use by the driver. This is used to
create the buffers for the slave windows.</p>
<p><strong>Return</strong></p>
<p>Virtual address of allocation on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.vme_free_consistent">
void <code class="sig-name descname">vme_free_consistent</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, size_t<em> size</em>, void<em> *vaddr</em>, dma_addr_t<em> dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_free_consistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Free previously allocated memory.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of allocation to free.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*vaddr</span></code></dt><dd><p>Virtual address of allocation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">dma</span></code></dt><dd><p>Physical address of allocation.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free previously allocated block of contiguous memory.</p>
</div>
<dl class="function">
<dt id="c.vme_get_size">
size_t <code class="sig-name descname">vme_get_size</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_get_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function returning size of a VME window</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME slave or master resource.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the size of the VME window provided. This is a helper
function, wrappering the call to vme_master_get or vme_slave_get
depending on the type of window resource handed to it.</p>
<p><strong>Return</strong></p>
<p>Size of the window on success, zero on failure.</p>
</div>
<dl class="function">
<dt id="c.vme_slave_request">
struct vme_resource * <code class="sig-name descname">vme_slave_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a><em> *vdev</em>, u32<em> address</em>, u32<em> cycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_slave_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a VME slave window resource.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*vdev</span></code></dt><dd><p>Pointer to VME device <a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a> assigned to driver instance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">address</span></code></dt><dd><p>Required VME address space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt><dd><p>Required VME data transfer cycle type.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request use of a VME window resource capable of being set for the requested
address space and data transfer cycle.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME resource on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.vme_slave_set">
int <code class="sig-name descname">vme_slave_set</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, int<em> enabled</em>, unsigned long long<em> vme_base</em>, unsigned long long<em> size</em>, dma_addr_t<em> buf_base</em>, u32<em> aspace</em>, u32<em> cycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_slave_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set VME slave window configuration.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME slave resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">enabled</span></code></dt><dd><p>State to which the window should be configured.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">vme_base</span></code></dt><dd><p>Base address for the window.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>Size of the VME window.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">buf_base</span></code></dt><dd><p>Based address of buffer used to provide VME slave window storage.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">aspace</span></code></dt><dd><p>VME address space for the VME window.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt><dd><p>VME data transfer cycle type for the VME window.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set configuration for provided VME slave window.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt><dd><p>device, if an invalid resource has been provided or invalid
attributes are provided. Hardware specific errors may also be
returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_slave_get">
int <code class="sig-name descname">vme_slave_get</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, int<em> *enabled</em>, unsigned long long<em> *vme_base</em>, unsigned long long<em> *size</em>, dma_addr_t<em> *buf_base</em>, u32<em> *aspace</em>, u32<em> *cycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_slave_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve VME slave window configuration.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME slave resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*enabled</span></code></dt><dd><p>Pointer to variable for storing state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*vme_base</span></code></dt><dd><p>Pointer to variable for storing window base address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*size</span></code></dt><dd><p>Pointer to variable for storing window size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">*buf_base</span></code></dt><dd><p>Pointer to variable for storing slave buffer base address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*aspace</span></code></dt><dd><p>Pointer to variable for storing VME address space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*cycle</span></code></dt><dd><p>Pointer to variable for storing VME data transfer cycle type.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return configuration for provided VME slave window.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt><dd><p>device or if an invalid resource has been provided.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_slave_free">
void <code class="sig-name descname">vme_slave_free</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_slave_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free VME slave window</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME slave resource.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the provided slave resource so that it may be reallocated.</p>
</div>
<dl class="function">
<dt id="c.vme_master_request">
struct vme_resource * <code class="sig-name descname">vme_master_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a><em> *vdev</em>, u32<em> address</em>, u32<em> cycle</em>, u32<em> dwidth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a VME master window resource.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*vdev</span></code></dt><dd><p>Pointer to VME device <a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a> assigned to driver instance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">address</span></code></dt><dd><p>Required VME address space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt><dd><p>Required VME data transfer cycle type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dwidth</span></code></dt><dd><p>Required VME data transfer width.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request use of a VME window resource capable of being set for the requested
address space, data transfer cycle and width.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME resource on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.vme_master_set">
int <code class="sig-name descname">vme_master_set</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, int<em> enabled</em>, unsigned long long<em> vme_base</em>, unsigned long long<em> size</em>, u32<em> aspace</em>, u32<em> cycle</em>, u32<em> dwidth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set VME master window configuration.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME master resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">enabled</span></code></dt><dd><p>State to which the window should be configured.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">vme_base</span></code></dt><dd><p>Base address for the window.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>Size of the VME window.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">aspace</span></code></dt><dd><p>VME address space for the VME window.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt><dd><p>VME data transfer cycle type for the VME window.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dwidth</span></code></dt><dd><p>VME data transfer width for the VME window.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set configuration for provided VME master window.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt><dd><p>device, if an invalid resource has been provided or invalid
attributes are provided. Hardware specific errors may also be
returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_master_get">
int <code class="sig-name descname">vme_master_get</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, int<em> *enabled</em>, unsigned long long<em> *vme_base</em>, unsigned long long<em> *size</em>, u32<em> *aspace</em>, u32<em> *cycle</em>, u32<em> *dwidth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve VME master window configuration.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME master resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*enabled</span></code></dt><dd><p>Pointer to variable for storing state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*vme_base</span></code></dt><dd><p>Pointer to variable for storing window base address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*size</span></code></dt><dd><p>Pointer to variable for storing window size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*aspace</span></code></dt><dd><p>Pointer to variable for storing VME address space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*cycle</span></code></dt><dd><p>Pointer to variable for storing VME data transfer cycle type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*dwidth</span></code></dt><dd><p>Pointer to variable for storing VME data transfer width.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return configuration for provided VME master window.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt><dd><p>device or if an invalid resource has been provided.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_master_read">
ssize_t <code class="sig-name descname">vme_master_read</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, void<em> *buf</em>, size_t<em> count</em>, loff_t<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from VME space into a buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME master resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>Pointer to buffer where data should be transferred.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>Number of bytes to transfer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt><dd><p>Offset into VME master window at which to start transfer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform read of count bytes of data from location on VME bus which maps into
the VME master window at offset to buf.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Number of bytes read, -EINVAL if resource is not a VME master</dt><dd><p>resource or read operation is not supported. -EFAULT returned if
invalid offset is provided. Hardware specific errors may also be
returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_master_write">
ssize_t <code class="sig-name descname">vme_master_write</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, void<em> *buf</em>, size_t<em> count</em>, loff_t<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data out to VME space from a buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME master resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*buf</span></code></dt><dd><p>Pointer to buffer holding data to transfer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>Number of bytes to transfer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt><dd><p>Offset into VME master window at which to start transfer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform write of count bytes of data from buf to location on VME bus which
maps into the VME master window at offset.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Number of bytes written, -EINVAL if resource is not a VME master</dt><dd><p>resource or write operation is not supported. -EFAULT returned if
invalid offset is provided. Hardware specific errors may also be
returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_master_rmw">
unsigned int <code class="sig-name descname">vme_master_rmw</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, unsigned int<em> mask</em>, unsigned int<em> compare</em>, unsigned int<em> swap</em>, loff_t<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_rmw" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform read-modify-write cycle.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME master resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>Bits to be compared and swapped in operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">compare</span></code></dt><dd><p>Bits to be compared with data read from offset.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">swap</span></code></dt><dd><p>Bits to be swapped in data read from offset.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt><dd><p>Offset into VME master window at which to perform operation.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform read-modify-write cycle on provided location:
- Location on VME bus is read.
- Bits selected by mask are compared with compare.
- Where a selected bit matches that in compare and are selected in swap,
the bit is swapped.
- Result written back to location on VME bus.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Bytes written on success, -EINVAL if resource is not a VME master</dt><dd><p>resource or RMW operation is not supported. Hardware specific
errors may also be returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_master_mmap">
int <code class="sig-name descname">vme_master_mmap</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, struct vm_area_struct<em> *vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Mmap region of VME master window.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME master resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>Pointer to definition of user mapping.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Memory map a region of the VME master window into user space.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL if resource is not a VME master</dt><dd><p>resource or -EFAULT if map exceeds window size. Other generic mmap
errors may also be returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_master_free">
void <code class="sig-name descname">vme_master_free</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free VME master window</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME master resource.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the provided master resource so that it may be reallocated.</p>
</div>
<dl class="function">
<dt id="c.vme_dma_request">
struct vme_resource * <code class="sig-name descname">vme_dma_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a><em> *vdev</em>, u32<em> route</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a DMA controller.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*vdev</span></code></dt><dd><p>Pointer to VME device <a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a> assigned to driver instance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">route</span></code></dt><dd><p>Required src/destination combination.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request a VME DMA controller with capability to perform transfers bewteen
requested source/destination combination.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME DMA resource on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.vme_new_dma_list">
struct vme_dma_list * <code class="sig-name descname">vme_new_dma_list</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_new_dma_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new VME DMA list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME DMA resource.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new VME DMA list. It is the responsibility of the user to free
the list once it is no longer required with <a class="reference internal" href="#c.vme_dma_list_free" title="vme_dma_list_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_list_free()</span></code></a>.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Pointer to new VME DMA list, NULL on allocation failure or invalid</dt><dd><p>VME DMA resource.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_dma_pattern_attribute">
struct vme_dma_attr * <code class="sig-name descname">vme_dma_pattern_attribute</code><span class="sig-paren">(</span>u32<em> pattern</em>, u32<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_pattern_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Create “Pattern” type VME DMA list attribute.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">pattern</span></code></dt><dd><p>Value to use used as pattern</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">type</span></code></dt><dd><p>Type of pattern to be written.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create VME DMA list attribute for pattern generation. It is the
responsibility of the user to free used attributes using
<a class="reference internal" href="#c.vme_dma_free_attribute" title="vme_dma_free_attribute"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_free_attribute()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME DMA attribute, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.vme_dma_pci_attribute">
struct vme_dma_attr * <code class="sig-name descname">vme_dma_pci_attribute</code><span class="sig-paren">(</span>dma_addr_t<em> address</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_pci_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Create “PCI” type VME DMA list attribute.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr_t</span> <span class="pre">address</span></code></dt><dd><p>PCI base address for DMA transfer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create VME DMA list attribute pointing to a location on PCI for DMA
transfers. It is the responsibility of the user to free used attributes
using <a class="reference internal" href="#c.vme_dma_free_attribute" title="vme_dma_free_attribute"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_free_attribute()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME DMA attribute, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.vme_dma_vme_attribute">
struct vme_dma_attr * <code class="sig-name descname">vme_dma_vme_attribute</code><span class="sig-paren">(</span>unsigned long long<em> address</em>, u32<em> aspace</em>, u32<em> cycle</em>, u32<em> dwidth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_vme_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Create “VME” type VME DMA list attribute.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">address</span></code></dt><dd><p>VME base address for DMA transfer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">aspace</span></code></dt><dd><p>VME address space to use for DMA transfer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt><dd><p>VME bus cycle to use for DMA transfer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">dwidth</span></code></dt><dd><p>VME data width to use for DMA transfer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create VME DMA list attribute pointing to a location on the VME bus for DMA
transfers. It is the responsibility of the user to free used attributes
using <a class="reference internal" href="#c.vme_dma_free_attribute" title="vme_dma_free_attribute"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_free_attribute()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME DMA attribute, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.vme_dma_free_attribute">
void <code class="sig-name descname">vme_dma_free_attribute</code><span class="sig-paren">(</span>struct vme_dma_attr<em> *attributes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_free_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Free DMA list attribute.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dma_attr</span> <span class="pre">*attributes</span></code></dt><dd><p>Pointer to DMA list attribute.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free VME DMA list attribute. VME DMA list attributes can be safely freed
once <a class="reference internal" href="#c.vme_dma_list_add" title="vme_dma_list_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">vme_dma_list_add()</span></code></a> has returned.</p>
</div>
<dl class="function">
<dt id="c.vme_dma_list_add">
int <code class="sig-name descname">vme_dma_list_add</code><span class="sig-paren">(</span>struct vme_dma_list<em> *list</em>, struct vme_dma_attr<em> *src</em>, struct vme_dma_attr<em> *dest</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_list_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add enty to a VME DMA list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dma_list</span> <span class="pre">*list</span></code></dt><dd><p>Pointer to VME list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dma_attr</span> <span class="pre">*src</span></code></dt><dd><p>Pointer to DMA list attribute to use as source.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dma_attr</span> <span class="pre">*dest</span></code></dt><dd><p>Pointer to DMA list attribute to use as destination.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>Number of bytes to transfer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an entry to the provided VME DMA list. Entry requires pointers to source
and destination DMA attributes and a count.</p>
<p>Please note, the attributes supported as source and destinations for
transfers are hardware dependent.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt><dd><p>device or if the link list has already been submitted for execution.
Hardware specific errors also possible.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_dma_list_exec">
int <code class="sig-name descname">vme_dma_list_exec</code><span class="sig-paren">(</span>struct vme_dma_list<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_list_exec" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a VME DMA list for execution.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dma_list</span> <span class="pre">*list</span></code></dt><dd><p>Pointer to VME list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue the provided VME DMA list for execution. The call will return once the
list has been executed.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt><dd><p>device. Hardware specific errors also possible.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_dma_list_free">
int <code class="sig-name descname">vme_dma_list_free</code><span class="sig-paren">(</span>struct vme_dma_list<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_list_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a VME DMA list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dma_list</span> <span class="pre">*list</span></code></dt><dd><p>Pointer to VME list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the provided DMA list and all its entries.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL on invalid VME resource, -EBUSY if resource</dt><dd><p>is still in use. Hardware specific errors also possible.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_dma_free">
int <code class="sig-name descname">vme_dma_free</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a VME DMA resource.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME DMA resource.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the provided DMA resource so that it may be reallocated.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL on invalid VME resource, -EBUSY if resource</dt><dd><p>is still active.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_irq_request">
int <code class="sig-name descname">vme_irq_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a><em> *vdev</em>, int<em> level</em>, int<em> statid</em>, void (<em>*callback</em>)(int, int, void *), void<em> *priv_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_irq_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a specific VME interrupt.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*vdev</span></code></dt><dd><p>Pointer to VME device <a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a> assigned to driver instance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">level</span></code></dt><dd><p>Interrupt priority being requested.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">statid</span></code></dt><dd><p>Interrupt vector being requested.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*callback)(int,</span> <span class="pre">int,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Pointer to callback function called when VME interrupt/vector
received.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv_data</span></code></dt><dd><p>Generic pointer that will be passed to the callback function.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request callback to be attached as a handler for VME interrupts with provided
level and statid.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL on invalid vme device, level or if the</dt><dd><p>function is not supported, -EBUSY if the level/statid combination is
already in use. Hardware specific errors also possible.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_irq_free">
void <code class="sig-name descname">vme_irq_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a><em> *vdev</em>, int<em> level</em>, int<em> statid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_irq_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a VME interrupt.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*vdev</span></code></dt><dd><p>Pointer to VME device <a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a> assigned to driver instance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">level</span></code></dt><dd><p>Interrupt priority of interrupt being freed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">statid</span></code></dt><dd><p>Interrupt vector of interrupt being freed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove previously attached callback from VME interrupt priority/vector.</p>
</div>
<dl class="function">
<dt id="c.vme_irq_generate">
int <code class="sig-name descname">vme_irq_generate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a><em> *vdev</em>, int<em> level</em>, int<em> statid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_irq_generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate VME interrupt.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*vdev</span></code></dt><dd><p>Pointer to VME device <a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a> assigned to driver instance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">level</span></code></dt><dd><p>Interrupt priority at which to assert the interrupt.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">statid</span></code></dt><dd><p>Interrupt vector to associate with the interrupt.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate a VME interrupt of the provided level and with the provided
statid.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL on invalid vme device, level or if the</dt><dd><p>function is not supported. Hardware specific errors also possible.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_lm_request">
struct vme_resource * <code class="sig-name descname">vme_lm_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a VME location monitor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*vdev</span></code></dt><dd><p>Pointer to VME device <a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a> assigned to driver instance.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a location monitor resource to the driver. A location monitor
allows the driver to monitor accesses to a contiguous number of
addresses on the VME bus.</p>
<p><strong>Return</strong></p>
<p>Pointer to a VME resource on success or NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.vme_lm_count">
int <code class="sig-name descname">vme_lm_count</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine number of VME Addresses monitored</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME location monitor resource.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The number of contiguous addresses monitored is hardware dependent.
Return the number of contiguous addresses monitored by the
location monitor.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Count of addresses monitored or -EINVAL when provided with an</dt><dd><p>invalid location monitor resource.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_lm_set">
int <code class="sig-name descname">vme_lm_set</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, unsigned long long<em> lm_base</em>, u32<em> aspace</em>, u32<em> cycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure location monitor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME location monitor resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">lm_base</span></code></dt><dd><p>Base address to monitor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">aspace</span></code></dt><dd><p>VME address space to monitor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt><dd><p>VME bus cycle type to monitor.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the base address, address space and cycle type of accesses to be
monitored by the location monitor.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL when provided with an invalid location</dt><dd><p>monitor resource or function is not supported. Hardware specific
errors may also be returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_lm_get">
int <code class="sig-name descname">vme_lm_get</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, unsigned long long<em> *lm_base</em>, u32<em> *aspace</em>, u32<em> *cycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve location monitor settings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME location monitor resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*lm_base</span></code></dt><dd><p>Pointer used to output the base address monitored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*aspace</span></code></dt><dd><p>Pointer used to output the address space monitored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*cycle</span></code></dt><dd><p>Pointer used to output the VME bus cycle type monitored.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve the base address, address space and cycle type of accesses to
be monitored by the location monitor.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL when provided with an invalid location</dt><dd><p>monitor resource or function is not supported. Hardware specific
errors may also be returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_lm_attach">
int <code class="sig-name descname">vme_lm_attach</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, int<em> monitor</em>, void (<em>*callback</em>)(void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide callback for location monitor address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME location monitor resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">monitor</span></code></dt><dd><p>Offset to which callback should be attached.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*callback)(void</span> <span class="pre">*)</span></code></dt><dd><p>Pointer to callback function called when triggered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Generic pointer that will be passed to the callback function.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attach a callback to the specificed offset into the location monitors
monitored addresses. A generic pointer is provided to allow data to be
passed to the callback when called.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL when provided with an invalid location</dt><dd><p>monitor resource or function is not supported. Hardware specific
errors may also be returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_lm_detach">
int <code class="sig-name descname">vme_lm_detach</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em>, int<em> monitor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove callback for location monitor address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME location monitor resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">monitor</span></code></dt><dd><p>Offset to which callback should be removed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove the callback associated with the specificed offset into the
location monitors monitored addresses.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL when provided with an invalid location</dt><dd><p>monitor resource or function is not supported. Hardware specific
errors may also be returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_lm_free">
void <code class="sig-name descname">vme_lm_free</code><span class="sig-paren">(</span>struct vme_resource<em> *resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free allocated VME location monitor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*resource</span></code></dt><dd><p>Pointer to VME location monitor resource.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free allocation of a VME location monitor.</p>
<dl class="simple">
<dt>WARNING: This function currently expects that any callbacks that have</dt><dd><p>been attached to the location monitor have been removed.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Zero on success, -EINVAL when provided with an invalid location</dt><dd><p>monitor resource.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_slot_num">
int <code class="sig-name descname">vme_slot_num</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_slot_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve slot ID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*vdev</span></code></dt><dd><p>Pointer to VME device <a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a> assigned to driver instance.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve the slot ID associated with the provided VME device.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>The slot ID on success, -EINVAL if VME bridge cannot be determined</dt><dd><p>or the function is not supported. Hardware specific errors may also
be returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_bus_num">
int <code class="sig-name descname">vme_bus_num</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_bus_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve bus number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*vdev</span></code></dt><dd><p>Pointer to VME device <a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a> assigned to driver instance.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve the bus enumeration associated with the provided VME device.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>The bus number on success, -EINVAL if VME bridge cannot be</dt><dd><p>determined.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vme_register_driver">
int <code class="sig-name descname">vme_register_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_driver" title="vme_driver">vme_driver</a><em> *drv</em>, unsigned int<em> ndevs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a VME driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_driver</span> <span class="pre">*drv</span></code></dt><dd><p>Pointer to VME driver structure to register.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ndevs</span></code></dt><dd><p>Maximum number of devices to allow to be enumerated.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a VME device driver with the VME subsystem.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error value on registration failure.</p>
</div>
<dl class="function">
<dt id="c.vme_unregister_driver">
void <code class="sig-name descname">vme_unregister_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_driver" title="vme_driver">vme_driver</a><em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a VME driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vme_driver</span> <span class="pre">*drv</span></code></dt><dd><p>Pointer to VME driver structure to unregister.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister a VME device driver from the VME subsystem.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">VME Device Drivers</a><ul>
<li><a class="reference internal" href="#driver-registration">Driver registration</a></li>
<li><a class="reference internal" href="#resource-management">Resource management</a></li>
<li><a class="reference internal" href="#master-windows">Master windows</a><ul>
<li><a class="reference internal" href="#master-window-configuration">Master window configuration</a></li>
<li><a class="reference internal" href="#master-window-access">Master window access</a></li>
</ul>
</li>
<li><a class="reference internal" href="#slave-windows">Slave windows</a><ul>
<li><a class="reference internal" href="#slave-window-configuration">Slave window configuration</a></li>
<li><a class="reference internal" href="#slave-window-buffer-allocation">Slave window buffer allocation</a></li>
<li><a class="reference internal" href="#slave-window-access">Slave window access</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dma-channels">DMA channels</a><ul>
<li><a class="reference internal" href="#list-management">List Management</a></li>
<li><a class="reference internal" href="#list-population">List Population</a></li>
<li><a class="reference internal" href="#transfer-attributes">Transfer Attributes</a></li>
<li><a class="reference internal" href="#list-execution">List Execution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interrupts">Interrupts</a><ul>
<li><a class="reference internal" href="#attaching-interrupt-handlers">Attaching Interrupt Handlers</a></li>
<li><a class="reference internal" href="#interrupt-generation">Interrupt Generation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#location-monitors">Location monitors</a><ul>
<li><a class="reference internal" href="#location-monitor-management">Location Monitor Management</a></li>
<li><a class="reference internal" href="#location-monitor-configuration">Location Monitor Configuration</a></li>
<li><a class="reference internal" href="#location-monitor-use">Location Monitor Use</a></li>
</ul>
</li>
<li><a class="reference internal" href="#slot-detection">Slot Detection</a></li>
<li><a class="reference internal" href="#bus-detection">Bus Detection</a></li>
<li><a class="reference internal" href="#vme-api">VME API</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/vme.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/vme.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>