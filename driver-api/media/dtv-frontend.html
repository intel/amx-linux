
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>3.2. Digital TV Frontend kABI &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="3.3. Digital TV Demux kABI" href="dtv-demux.html" />
    <link rel="prev" title="3.1. Digital TV Common functions" href="dtv-common.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="digital-tv-frontend-kabi">
<h1><span class="section-number">3.2. </span>Digital TV Frontend kABI<a class="headerlink" href="#digital-tv-frontend-kabi" title="Permalink to this headline">¶</a></h1>
<section id="digital-tv-frontend">
<h2><span class="section-number">3.2.1. </span>Digital TV Frontend<a class="headerlink" href="#digital-tv-frontend" title="Permalink to this headline">¶</a></h2>
<p>The Digital TV Frontend kABI defines a driver-internal interface for
registering low-level, hardware specific driver to a hardware independent
frontend layer. It is only of interest for Digital TV device driver writers.
The header file for this API is named <code class="docutils literal notranslate"><span class="pre">dvb_frontend.h</span></code> and located in
<code class="docutils literal notranslate"><span class="pre">include/media/</span></code>.</p>
<section id="demodulator-driver">
<h3><span class="section-number">3.2.1.1. </span>Demodulator driver<a class="headerlink" href="#demodulator-driver" title="Permalink to this headline">¶</a></h3>
<p>The demodulator driver is responsible for talking with the decoding part of the
hardware. Such driver should implement <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops</span></code></a>, which
tells what type of digital TV standards are supported, and points to a
series of functions that allow the DVB core to command the hardware via
the code under <code class="docutils literal notranslate"><span class="pre">include/media/dvb_frontend.c</span></code>.</p>
<p>A typical example of such struct in a driver <code class="docutils literal notranslate"><span class="pre">foo</span></code> is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct dvb_frontend_ops foo_ops = {
        .delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },
        .info = {
                .name   = &quot;foo DVB-T/T2/C driver&quot;,
                .caps = FE_CAN_FEC_1_2 |
                        FE_CAN_FEC_2_3 |
                        FE_CAN_FEC_3_4 |
                        FE_CAN_FEC_5_6 |
                        FE_CAN_FEC_7_8 |
                        FE_CAN_FEC_AUTO |
                        FE_CAN_QPSK |
                        FE_CAN_QAM_16 |
                        FE_CAN_QAM_32 |
                        FE_CAN_QAM_64 |
                        FE_CAN_QAM_128 |
                        FE_CAN_QAM_256 |
                        FE_CAN_QAM_AUTO |
                        FE_CAN_TRANSMISSION_MODE_AUTO |
                        FE_CAN_GUARD_INTERVAL_AUTO |
                        FE_CAN_HIERARCHY_AUTO |
                        FE_CAN_MUTE_TS |
                        FE_CAN_2G_MODULATION,
                .frequency_min = 42000000, /* Hz */
                .frequency_max = 1002000000, /* Hz */
                .symbol_rate_min = 870000,
                .symbol_rate_max = 11700000
        },
        .init = foo_init,
        .sleep = foo_sleep,
        .release = foo_release,
        .set_frontend = foo_set_frontend,
        .get_frontend = foo_get_frontend,
        .read_status = foo_get_status_and_stats,
        .tune = foo_tune,
        .i2c_gate_ctrl = foo_i2c_gate_ctrl,
        .get_frontend_algo = foo_get_algo,
};
</pre></div>
</div>
<p>A typical example of such struct in a driver <code class="docutils literal notranslate"><span class="pre">bar</span></code> meant to be used on
Satellite TV reception is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct dvb_frontend_ops bar_ops = {
        .delsys = { SYS_DVBS, SYS_DVBS2 },
        .info = {
                .name           = &quot;Bar DVB-S/S2 demodulator&quot;,
                .frequency_min  = 500000, /* KHz */
                .frequency_max  = 2500000, /* KHz */
                .frequency_stepsize     = 0,
                .symbol_rate_min = 1000000,
                .symbol_rate_max = 45000000,
                .symbol_rate_tolerance = 500,
                .caps = FE_CAN_INVERSION_AUTO |
                        FE_CAN_FEC_AUTO |
                        FE_CAN_QPSK,
        },
        .init = bar_init,
        .sleep = bar_sleep,
        .release = bar_release,
        .set_frontend = bar_set_frontend,
        .get_frontend = bar_get_frontend,
        .read_status = bar_get_status_and_stats,
        .i2c_gate_ctrl = bar_i2c_gate_ctrl,
        .get_frontend_algo = bar_get_algo,
        .tune = bar_tune,

        /* Satellite-specific */
        .diseqc_send_master_cmd = bar_send_diseqc_msg,
        .diseqc_send_burst = bar_send_burst,
        .set_tone = bar_set_tone,
        .set_voltage = bar_set_voltage,
};
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>For satellite digital TV standards (DVB-S, DVB-S2, ISDB-S), the
frequencies are specified in kHz, while, for terrestrial and cable
standards, they’re specified in Hz. Due to that, if the same frontend
supports both types, you’ll need to have two separate
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops</span></code></a> structures, one for each standard.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">.i2c_gate_ctrl</span></code> field is present only when the hardware has
allows controlling an I2C gate (either directly of via some GPIO pin),
in order to remove the tuner from the I2C bus after a channel is
tuned.</p></li>
<li><p>All new drivers should implement the
<a class="reference internal" href="#dvbv5-stats"><span class="std std-ref">DVBv5 statistics</span></a> via <code class="docutils literal notranslate"><span class="pre">.read_status</span></code>.
Yet, there are a number of callbacks meant to get statistics for
signal strength, S/N and UCB. Those are there to provide backward
compatibility with legacy applications that don’t support the DVBv5
API. Implementing those callbacks are optional. Those callbacks may be
removed in the future, after we have all existing drivers supporting
DVBv5 stats.</p></li>
<li><p>Other callbacks are required for satellite TV standards, in order to
control LNBf and DiSEqC: <code class="docutils literal notranslate"><span class="pre">.diseqc_send_master_cmd</span></code>,
<code class="docutils literal notranslate"><span class="pre">.diseqc_send_burst</span></code>, <code class="docutils literal notranslate"><span class="pre">.set_tone</span></code>, <code class="docutils literal notranslate"><span class="pre">.set_voltage</span></code>.</p></li>
</ol>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">include/media/dvb_frontend.c</span></code> has a kernel thread which is
responsible for tuning the device. It supports multiple algorithms to
detect a channel, as defined at enum <a class="reference internal" href="#c.dvbfe_algo" title="dvbfe_algo"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvbfe_algo()</span></code></a>.</p>
<p>The algorithm to be used is obtained via <code class="docutils literal notranslate"><span class="pre">.get_frontend_algo</span></code>. If the driver
doesn’t fill its field at <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend_ops</span></code></a>, it will default to
<code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_SW</span></code>, meaning that the dvb-core will do a zigzag when tuning,
e. g. it will try first to use the specified center frequency <code class="docutils literal notranslate"><span class="pre">f</span></code>,
then, it will do <code class="docutils literal notranslate"><span class="pre">f</span></code> + Δ, <code class="docutils literal notranslate"><span class="pre">f</span></code> - Δ, <code class="docutils literal notranslate"><span class="pre">f</span></code> + 2 x Δ,
<code class="docutils literal notranslate"><span class="pre">f</span></code> - 2 x Δ and so on.</p>
<p>If the hardware has internally a some sort of zigzag algorithm, you should
define a <code class="docutils literal notranslate"><span class="pre">.get_frontend_algo</span></code> function that would return <code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_HW</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The core frontend support also supports
a third type (<code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_CUSTOM</span></code>), in order to allow the driver to
define its own hardware-assisted algorithm. Very few hardware need to
use it nowadays. Using <code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_CUSTOM</span></code> require to provide other
function callbacks at <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend_ops</span></code></a>.</p>
</div>
</section>
<section id="attaching-frontend-driver-to-the-bridge-driver">
<h3><span class="section-number">3.2.1.2. </span>Attaching frontend driver to the bridge driver<a class="headerlink" href="#attaching-frontend-driver-to-the-bridge-driver" title="Permalink to this headline">¶</a></h3>
<p>Before using the Digital TV frontend core, the bridge driver should attach
the frontend demod, tuner and SEC devices and call
<a class="reference internal" href="#c.dvb_register_frontend" title="dvb_register_frontend"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_register_frontend()</span></code></a>,
in order to register the new frontend at the subsystem. At device
detach/removal, the bridge driver should call
<a class="reference internal" href="#c.dvb_unregister_frontend" title="dvb_unregister_frontend"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_unregister_frontend()</span></code></a> to
remove the frontend from the core and then <a class="reference internal" href="#c.dvb_frontend_detach" title="dvb_frontend_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_frontend_detach()</span></code></a>
to free the memory allocated by the frontend drivers.</p>
<p>The drivers should also call <a class="reference internal" href="#c.dvb_frontend_suspend" title="dvb_frontend_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_frontend_suspend()</span></code></a> as part of
their handler for the <code class="xref c c-type docutils literal notranslate"><span class="pre">device_driver</span></code>.<code class="docutils literal notranslate"><span class="pre">suspend()</span></code>, and
<a class="reference internal" href="#c.dvb_frontend_resume" title="dvb_frontend_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_frontend_resume()</span></code></a> as
part of their handler for <code class="xref c c-type docutils literal notranslate"><span class="pre">device_driver</span></code>.<code class="docutils literal notranslate"><span class="pre">resume()</span></code>.</p>
<p>A few other optional functions are provided to handle some special cases.</p>
</section>
</section>
<section id="digital-tv-frontend-statistics">
<span id="dvbv5-stats"></span><h2><span class="section-number">3.2.2. </span>Digital TV Frontend statistics<a class="headerlink" href="#digital-tv-frontend-statistics" title="Permalink to this headline">¶</a></h2>
<section id="introduction">
<h3><span class="section-number">3.2.2.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>Digital TV frontends provide a range of
<a class="reference internal" href="../../userspace-api/media/dvb/frontend-stat-properties.html#frontend-stat-properties"><span class="std std-ref">statistics</span></a> meant to help tuning the device
and measuring the quality of service.</p>
<p>For each statistics measurement, the driver should set the type of scale used,
or <code class="docutils literal notranslate"><span class="pre">FE_SCALE_NOT_AVAILABLE</span></code> if the statistics is not available on a given
time. Drivers should also provide the number of statistics for each type.
that’s usually 1 for most video standards <a class="footnote-reference brackets" href="#f2" id="id1">1</a>.</p>
<p>Drivers should initialize each statistic counters with length and
scale at its init code. For example, if the frontend provides signal
strength, it should have, on its init code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dtv_frontend_properties *c = &amp;state-&gt;fe.dtv_property_cache;

c-&gt;strength.len = 1;
c-&gt;strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
</pre></div>
</div>
<p>And, when the statistics got updated, set the scale:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>c-&gt;strength.stat[0].scale = FE_SCALE_DECIBEL;
c-&gt;strength.stat[0].uvalue = strength;
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>For ISDB-T, it may provide both a global statistics and a per-layer
set of statistics. On such cases, len should be equal to 4. The first
value corresponds to the global stat; the other ones to each layer, e. g.:</p>
<ul class="simple">
<li><p>c-&gt;cnr.stat[0] for global S/N carrier ratio,</p></li>
<li><p>c-&gt;cnr.stat[1] for Layer A S/N carrier ratio,</p></li>
<li><p>c-&gt;cnr.stat[2] for layer B S/N carrier ratio,</p></li>
<li><p>c-&gt;cnr.stat[3] for layer C S/N carrier ratio.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please prefer to use <code class="docutils literal notranslate"><span class="pre">FE_SCALE_DECIBEL</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">FE_SCALE_RELATIVE</span></code> for signal strength and CNR measurements.</p>
</div>
</section>
<section id="groups-of-statistics">
<h3><span class="section-number">3.2.2.2. </span>Groups of statistics<a class="headerlink" href="#groups-of-statistics" title="Permalink to this headline">¶</a></h3>
<p>There are several groups of statistics currently supported:</p>
<dl>
<dt>Signal strength (<a class="reference internal" href="../../userspace-api/media/dvb/frontend-stat-properties.html#dtv-stat-signal-strength"><span class="std std-ref">DTV_STAT_SIGNAL_STRENGTH</span></a>)</dt><dd><ul class="simple">
<li><p>Measures the signal strength level at the analog part of the tuner or
demod.</p></li>
<li><p>Typically obtained from the gain applied to the tuner and/or frontend
in order to detect the carrier. When no carrier is detected, the gain is
at the maximum value (so, strength is on its minimal).</p></li>
<li><p>As the gain is visible through the set of registers that adjust the gain,
typically, this statistics is always available <a class="footnote-reference brackets" href="#f3" id="id2">2</a>.</p></li>
<li><p>Drivers should try to make it available all the times, as these statistics
can be used when adjusting an antenna position and to check for troubles
at the cabling.</p></li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="f3"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>On a few devices, the gain keeps floating if there is no carrier.
On such devices, strength report should check first if carrier is
detected at the tuner (<code class="docutils literal notranslate"><span class="pre">FE_HAS_CARRIER</span></code>, see <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status</span></code>),
and otherwise return the lowest possible value.</p>
</dd>
</dl>
</dd>
<dt>Carrier Signal to Noise ratio (<a class="reference internal" href="../../userspace-api/media/dvb/frontend-stat-properties.html#dtv-stat-cnr"><span class="std std-ref">DTV_STAT_CNR</span></a>)</dt><dd><ul>
<li><p>Signal to Noise ratio for the main carrier.</p></li>
<li><p>Signal to Noise measurement depends on the device. On some hardware, it is
available when the main carrier is detected. On those hardware, CNR
measurement usually comes from the tuner (e. g. after <code class="docutils literal notranslate"><span class="pre">FE_HAS_CARRIER</span></code>,
see <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status</span></code>).</p>
<p>On other devices, it requires inner FEC decoding,
as the frontend measures it indirectly from other parameters (e. g. after
<code class="docutils literal notranslate"><span class="pre">FE_HAS_VITERBI</span></code>, see <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status</span></code>).</p>
<p>Having it available after inner FEC is more common.</p>
</li>
</ul>
</dd>
<dt>Bit counts post-FEC (<a class="reference internal" href="../../userspace-api/media/dvb/frontend-stat-properties.html#dtv-stat-post-error-bit-count"><span class="std std-ref">DTV_STAT_POST_ERROR_BIT_COUNT</span></a> and <a class="reference internal" href="../../userspace-api/media/dvb/frontend-stat-properties.html#dtv-stat-post-total-bit-count"><span class="std std-ref">DTV_STAT_POST_TOTAL_BIT_COUNT</span></a>)</dt><dd><ul class="simple">
<li><p>Those counters measure the number of bits and bit errors after
the forward error correction (FEC) on the inner coding block
(after Viterbi, LDPC or other inner code).</p></li>
<li><p>Due to its nature, those statistics depend on full coding lock
(e. g. after <code class="docutils literal notranslate"><span class="pre">FE_HAS_SYNC</span></code> or after <code class="docutils literal notranslate"><span class="pre">FE_HAS_LOCK</span></code>,
see <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status</span></code>).</p></li>
</ul>
</dd>
<dt>Bit counts pre-FEC (<a class="reference internal" href="../../userspace-api/media/dvb/frontend-stat-properties.html#dtv-stat-pre-error-bit-count"><span class="std std-ref">DTV_STAT_PRE_ERROR_BIT_COUNT</span></a> and <a class="reference internal" href="../../userspace-api/media/dvb/frontend-stat-properties.html#dtv-stat-pre-total-bit-count"><span class="std std-ref">DTV_STAT_PRE_TOTAL_BIT_COUNT</span></a>)</dt><dd><ul class="simple">
<li><p>Those counters measure the number of bits and bit errors before
the forward error correction (FEC) on the inner coding block
(before Viterbi, LDPC or other inner code).</p></li>
<li><p>Not all frontends provide this kind of statistics.</p></li>
<li><p>Due to its nature, those statistics depend on inner coding lock (e. g.
after <code class="docutils literal notranslate"><span class="pre">FE_HAS_VITERBI</span></code>, see <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status</span></code>).</p></li>
</ul>
</dd>
<dt>Block counts (<a class="reference internal" href="../../userspace-api/media/dvb/frontend-stat-properties.html#dtv-stat-error-block-count"><span class="std std-ref">DTV_STAT_ERROR_BLOCK_COUNT</span></a> and <a class="reference internal" href="../../userspace-api/media/dvb/frontend-stat-properties.html#dtv-stat-total-block-count"><span class="std std-ref">DTV-STAT_TOTAL_BLOCK_COUNT</span></a>)</dt><dd><ul class="simple">
<li><p>Those counters measure the number of blocks and block errors after
the forward error correction (FEC) on the inner coding block
(before Viterbi, LDPC or other inner code).</p></li>
<li><p>Due to its nature, those statistics depend on full coding lock
(e. g. after <code class="docutils literal notranslate"><span class="pre">FE_HAS_SYNC</span></code> or after
<code class="docutils literal notranslate"><span class="pre">FE_HAS_LOCK</span></code>, see <code class="xref c c-type docutils literal notranslate"><span class="pre">fe_status</span></code>).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All counters should be monotonically increased as they’re
collected from the hardware.</p>
</div>
<p>A typical example of the logic that handle status and statistics is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int foo_get_status_and_stats(struct dvb_frontend *fe)
{
        struct foo_state *state = fe-&gt;demodulator_priv;
        struct dtv_frontend_properties *c = &amp;fe-&gt;dtv_property_cache;

        int rc;
        enum fe_status *status;

        /* Both status and strength are always available */
        rc = foo_read_status(fe, &amp;status);
        if (rc &lt; 0)
                return rc;

        rc = foo_read_strength(fe);
        if (rc &lt; 0)
                return rc;

        /* Check if CNR is available */
        if (!(fe-&gt;status &amp; FE_HAS_CARRIER))
                return 0;

        rc = foo_read_cnr(fe);
        if (rc &lt; 0)
                return rc;

        /* Check if pre-BER stats are available */
        if (!(fe-&gt;status &amp; FE_HAS_VITERBI))
                return 0;

        rc = foo_get_pre_ber(fe);
        if (rc &lt; 0)
                return rc;

        /* Check if post-BER stats are available */
        if (!(fe-&gt;status &amp; FE_HAS_SYNC))
                return 0;

        rc = foo_get_post_ber(fe);
        if (rc &lt; 0)
                return rc;
}

static const struct dvb_frontend_ops ops = {
        /* ... */
        .read_status = foo_get_status_and_stats,
};
</pre></div>
</div>
</section>
<section id="statistics-collection">
<h3><span class="section-number">3.2.2.3. </span>Statistics collection<a class="headerlink" href="#statistics-collection" title="Permalink to this headline">¶</a></h3>
<p>On almost all frontend hardware, the bit and byte counts are stored by
the hardware after a certain amount of time or after the total bit/block
counter reaches a certain value (usually programmable), for example, on
every 1000 ms or after receiving 1,000,000 bits.</p>
<p>So, if you read the registers too soon, you’ll end by reading the same
value as in the previous reading, causing the monotonic value to be
incremented too often.</p>
<p>Drivers should take the responsibility to avoid too often reads. That
can be done using two approaches:</p>
<section id="if-the-driver-have-a-bit-that-indicates-when-a-collected-data-is-ready">
<h4><span class="section-number">3.2.2.3.1. </span>if the driver have a bit that indicates when a collected data is ready<a class="headerlink" href="#if-the-driver-have-a-bit-that-indicates-when-a-collected-data-is-ready" title="Permalink to this headline">¶</a></h4>
<p>Driver should check such bit before making the statistics available.</p>
<p>An example of such behavior can be found at this code snippet (adapted
from mb86a20s driver’s logic):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int foo_get_pre_ber(struct dvb_frontend *fe)
{
        struct foo_state *state = fe-&gt;demodulator_priv;
        struct dtv_frontend_properties *c = &amp;fe-&gt;dtv_property_cache;
        int rc, bit_error;

        /* Check if the BER measures are already available */
        rc = foo_read_u8(state, 0x54);
        if (rc &lt; 0)
                return rc;

        if (!rc)
                return 0;

        /* Read Bit Error Count */
        bit_error = foo_read_u32(state, 0x55);
        if (bit_error &lt; 0)
                return bit_error;

        /* Read Total Bit Count */
        rc = foo_read_u32(state, 0x51);
        if (rc &lt; 0)
                return rc;

        c-&gt;pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_error.stat[0].uvalue += bit_error;
        c-&gt;pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_count.stat[0].uvalue += rc;

        return 0;
}
</pre></div>
</div>
</section>
<section id="if-the-driver-doesn-t-provide-a-statistics-available-check-bit">
<h4><span class="section-number">3.2.2.3.2. </span>If the driver doesn’t provide a statistics available check bit<a class="headerlink" href="#if-the-driver-doesn-t-provide-a-statistics-available-check-bit" title="Permalink to this headline">¶</a></h4>
<p>A few devices, however, may not provide a way to check if the stats are
available (or the way to check it is unknown). They may not even provide
a way to directly read the total number of bits or blocks.</p>
<p>On those devices, the driver need to ensure that it won’t be reading from
the register too often and/or estimate the total number of bits/blocks.</p>
<p>On such drivers, a typical routine to get statistics would be like
(adapted from dib8000 driver’s logic):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct foo_state {
        /* ... */

        unsigned long per_jiffies_stats;
}

static int foo_get_pre_ber(struct dvb_frontend *fe)
{
        struct foo_state *state = fe-&gt;demodulator_priv;
        struct dtv_frontend_properties *c = &amp;fe-&gt;dtv_property_cache;
        int rc, bit_error;
        u64 bits;

        /* Check if time for stats was elapsed */
        if (!time_after(jiffies, state-&gt;per_jiffies_stats))
                return 0;

        /* Next stat should be collected in 1000 ms */
        state-&gt;per_jiffies_stats = jiffies + msecs_to_jiffies(1000);

        /* Read Bit Error Count */
        bit_error = foo_read_u32(state, 0x55);
        if (bit_error &lt; 0)
                return bit_error;

        /*
         * On this particular frontend, there&#39;s no register that
         * would provide the number of bits per 1000ms sample. So,
         * some function would calculate it based on DTV properties
         */
        bits = get_number_of_bits_per_1000ms(fe);

        c-&gt;pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_error.stat[0].uvalue += bit_error;
        c-&gt;pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_count.stat[0].uvalue += bits;

        return 0;
}
</pre></div>
</div>
<p>Please notice that, on both cases, we’re getting the statistics using the
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops</span></code></a> <code class="docutils literal notranslate"><span class="pre">.read_status</span></code> callback. The rationale is that
the frontend core will automatically call this function periodically
(usually, 3 times per second, when the frontend is locked).</p>
<p>That warrants that we won’t miss to collect a counter and increment the
monotonic stats at the right time.</p>
</section>
</section>
</section>
<section id="digital-tv-frontend-functions-and-types">
<h2><span class="section-number">3.2.3. </span>Digital TV Frontend functions and types<a class="headerlink" href="#digital-tv-frontend-functions-and-types" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.dvb_frontend_tune_settings">
struct <code class="sig-name descname">dvb_frontend_tune_settings</code><a class="headerlink" href="#c.dvb_frontend_tune_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>parameters to adjust frontend tuning</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dvb_frontend_tune_settings {
    int min_delay_ms;
    int step_size;
    int max_drift;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">min_delay_ms</span></code></dt><dd><p>minimum delay for tuning, in ms</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">step_size</span></code></dt><dd><p>step size between two consecutive frequencies</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_drift</span></code></dt><dd><p>maximum drift</p>
</dd>
</dl>
</div>
<p><strong>NOTE</strong></p>
<p>step_size is in Hz, for terrestrial/cable or kHz for satellite</p>
<dl class="type">
<dt id="c.dvb_tuner_info">
struct <code class="sig-name descname">dvb_tuner_info</code><a class="headerlink" href="#c.dvb_tuner_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Frontend name and min/max ranges/bandwidths</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dvb_tuner_info {
    char name[128];
    u32 frequency_min_hz;
    u32 frequency_max_hz;
    u32 frequency_step_hz;
    u32 bandwidth_min;
    u32 bandwidth_max;
    u32 bandwidth_step;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the Frontend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frequency_min_hz</span></code></dt><dd><p>minimal frequency supported in Hz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frequency_max_hz</span></code></dt><dd><p>maximum frequency supported in Hz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frequency_step_hz</span></code></dt><dd><p>frequency step in Hz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bandwidth_min</span></code></dt><dd><p>minimal frontend bandwidth supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bandwidth_max</span></code></dt><dd><p>maximum frontend bandwidth supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bandwidth_step</span></code></dt><dd><p>frontend bandwidth step</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.analog_parameters">
struct <code class="sig-name descname">analog_parameters</code><a class="headerlink" href="#c.analog_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters to tune into an analog/radio channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct analog_parameters {
    unsigned int frequency;
    unsigned int mode;
    unsigned int audmode;
    u64 std;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">frequency</span></code></dt><dd><p>Frequency used by analog TV tuner (either in 62.5 kHz step,
for TV, or 62.5 Hz for radio)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>Tuner mode, as defined on enum v4l2_tuner_type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audmode</span></code></dt><dd><p>Audio mode as defined for the rxsubchans field at videodev2.h,
e. g. V4L2_TUNER_MODE_*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">std</span></code></dt><dd><p>TV standard bitmap as defined at videodev2.h, e. g. V4L2_STD_*</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Hybrid tuners should be supported by both V4L2 and DVB APIs. This
struct contains the data that are used by the V4L2 side. To avoid
dependencies from V4L2 headers, all enums here are declared as integers.</p>
<dl class="type">
<dt id="c.dvbfe_algo">
enum <code class="sig-name descname">dvbfe_algo</code><a class="headerlink" href="#c.dvbfe_algo" title="Permalink to this definition">¶</a></dt>
<dd><p>defines the algorithm used to tune into a channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_HW</span></code></dt><dd><p>Hardware Algorithm -
Devices that support this algorithm do everything in hardware
and no software support is needed to handle them.
Requesting these devices to LOCK is the only thing required,
device is supposed to do everything in the hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_SW</span></code></dt><dd><p>Software Algorithm -
These are dumb devices, that require software to do everything</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_CUSTOM</span></code></dt><dd><p>Customizable Agorithm -
Devices having this algorithm can be customized to have specific
algorithms in the frontend driver, rather than simply doing a
software zig-zag. In this case the zigzag maybe hardware assisted
or it maybe completely done in hardware. In all cases, usage of
this algorithm, in conjunction with the search and track
callbacks, utilizes the driver specific algorithm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_RECOVERY</span></code></dt><dd><p>Recovery Algorithm -
These devices have AUTO recovery capabilities from LOCK failure</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dvbfe_search">
enum <code class="sig-name descname">dvbfe_search</code><a class="headerlink" href="#c.dvbfe_search" title="Permalink to this definition">¶</a></dt>
<dd><p>search callback possible return status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_SEARCH_SUCCESS</span></code></p>
<blockquote>
<div><p>The frontend search algorithm completed and returned successfully</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_SEARCH_ASLEEP</span></code></p>
<blockquote>
<div><p>The frontend search algorithm is sleeping</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_SEARCH_FAILED</span></code></p>
<blockquote>
<div><p>The frontend search for a signal failed</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_SEARCH_INVALID</span></code></p>
<blockquote>
<div><p>The frontend search algorithm was probably supplied with invalid
parameters and the search is an invalid one</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_SEARCH_AGAIN</span></code></p>
<blockquote>
<div><p>The frontend search algorithm was requested to search again</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">DVBFE_ALGO_SEARCH_ERROR</span></code></p>
<blockquote>
<div><p>The frontend search algorithm failed due to some error</p>
</div></blockquote>
</div>
<dl class="type">
<dt id="c.dvb_tuner_ops">
struct <code class="sig-name descname">dvb_tuner_ops</code><a class="headerlink" href="#c.dvb_tuner_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuner information and callbacks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dvb_tuner_ops {
    struct dvb_tuner_info info;
    void (*release)(struct dvb_frontend *fe);
    int (*init)(struct dvb_frontend *fe);
    int (*sleep)(struct dvb_frontend *fe);
    int (*suspend)(struct dvb_frontend *fe);
    int (*resume)(struct dvb_frontend *fe);
    int (*set_params)(struct dvb_frontend *fe);
    int (*set_analog_params)(struct dvb_frontend *fe, struct analog_parameters *p);
    int (*set_config)(struct dvb_frontend *fe, void *priv_cfg);
    int (*get_frequency)(struct dvb_frontend *fe, u32 *frequency);
    int (*get_bandwidth)(struct dvb_frontend *fe, u32 *bandwidth);
    int (*get_if_frequency)(struct dvb_frontend *fe, u32 *frequency);
#define TUNER_STATUS_LOCKED 1;
#define TUNER_STATUS_STEREO 2;
    int (*get_status)(struct dvb_frontend *fe, u32 *status);
    int (*get_rf_strength)(struct dvb_frontend *fe, u16 *strength);
    int (*get_afc)(struct dvb_frontend *fe, s32 *afc);
    int (*calc_regs)(struct dvb_frontend *fe, u8 *buf, int buf_len);
    int (*set_frequency)(struct dvb_frontend *fe, u32 frequency);
    int (*set_bandwidth)(struct dvb_frontend *fe, u32 bandwidth);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>embedded <a class="reference internal" href="#c.dvb_tuner_info" title="dvb_tuner_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_tuner_info</span></code></a> with tuner properties</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>callback function called when frontend is detached.
drivers should free any allocated memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init</span></code></dt><dd><p>callback function used to initialize the tuner device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sleep</span></code></dt><dd><p>callback function used to put the tuner to sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>callback function used to inform that the Kernel will
suspend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>callback function used to inform that the Kernel is
resuming from suspend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_params</span></code></dt><dd><p>callback function used to inform the tuner to tune
into a digital TV channel. The properties to be used
are stored at <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a>.dtv_property_cache.
The tuner demod can change the parameters to reflect
the changes needed for the channel to be tuned, and
update statistics. This is the recommended way to set
the tuner parameters and should be used on newer
drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_analog_params</span></code></dt><dd><p>callback function used to tune into an analog TV
channel on hybrid tuners. It passes <strong>analog_parameters</strong>
to the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_config</span></code></dt><dd><p>callback function used to send some tuner-specific
parameters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_frequency</span></code></dt><dd><p>get the actual tuned frequency</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_bandwidth</span></code></dt><dd><p>get the bandwidth used by the low pass filters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_if_frequency</span></code></dt><dd><p>get the Intermediate Frequency, in Hz. For baseband,
should return 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_status</span></code></dt><dd><p>returns the frontend lock status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_rf_strength</span></code></dt><dd><p>returns the RF signal strength. Used mostly to support
analog TV and radio. Digital TV should report, instead,
via DVBv5 API (<a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a>.dtv_property_cache).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_afc</span></code></dt><dd><p>Used only by analog TV core. Reports the frequency
drift due to AFC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">calc_regs</span></code></dt><dd><p>callback function used to pass register data settings
for simple tuners.  Shouldn’t be used on newer drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_frequency</span></code></dt><dd><p>Set a new frequency. Shouldn’t be used on newer drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_bandwidth</span></code></dt><dd><p>Set a new frequency. Shouldn’t be used on newer drivers.</p>
</dd>
</dl>
</div>
<p><strong>NOTE</strong></p>
<p>frequencies used on <strong>get_frequency</strong> and <strong>set_frequency</strong> are in Hz for
terrestrial/cable or kHz for satellite.</p>
<dl class="type">
<dt id="c.analog_demod_info">
struct <code class="sig-name descname">analog_demod_info</code><a class="headerlink" href="#c.analog_demod_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Information struct for analog TV part of the demod</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct analog_demod_info {
    char *name;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the analog TV demodulator</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.analog_demod_ops">
struct <code class="sig-name descname">analog_demod_ops</code><a class="headerlink" href="#c.analog_demod_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Demodulation information and callbacks for analog TV and radio</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct analog_demod_ops {
    struct analog_demod_info info;
    void (*set_params)(struct dvb_frontend *fe, struct analog_parameters *params);
    int (*has_signal)(struct dvb_frontend *fe, u16 *signal);
    int (*get_afc)(struct dvb_frontend *fe, s32 *afc);
    void (*tuner_status)(struct dvb_frontend *fe);
    void (*standby)(struct dvb_frontend *fe);
    void (*release)(struct dvb_frontend *fe);
    int (*i2c_gate_ctrl)(struct dvb_frontend *fe, int enable);
    int (*set_config)(struct dvb_frontend *fe, void *priv_cfg);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.analog_demod_info" title="analog_demod_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">analog_demod_info</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_params</span></code></dt><dd><p>callback function used to inform the demod to set the
demodulator parameters needed to decode an analog or
radio channel. The properties are passed via
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">analog_params</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">has_signal</span></code></dt><dd><p>returns 0xffff if has signal, or 0 if it doesn’t.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_afc</span></code></dt><dd><p>Used only by analog TV core. Reports the frequency
drift due to AFC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tuner_status</span></code></dt><dd><p>callback function that returns tuner status bits, e. g.
<code class="docutils literal notranslate"><span class="pre">TUNER_STATUS_LOCKED</span></code> and <code class="docutils literal notranslate"><span class="pre">TUNER_STATUS_STEREO</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">standby</span></code></dt><dd><p>set the tuner to standby mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>callback function called when frontend is detached.
drivers should free any allocated memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i2c_gate_ctrl</span></code></dt><dd><p>controls the I2C gate. Newer drivers should use I2C
mux support instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_config</span></code></dt><dd><p>callback function used to send some tuner-specific
parameters.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dvb_frontend_internal_info">
struct <code class="sig-name descname">dvb_frontend_internal_info</code><a class="headerlink" href="#c.dvb_frontend_internal_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Frontend properties and capabilities</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dvb_frontend_internal_info {
    char name[128];
    u32 frequency_min_hz;
    u32 frequency_max_hz;
    u32 frequency_stepsize_hz;
    u32 frequency_tolerance_hz;
    u32 symbol_rate_min;
    u32 symbol_rate_max;
    u32 symbol_rate_tolerance;
    enum fe_caps caps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the frontend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frequency_min_hz</span></code></dt><dd><p>Minimal frequency supported by the frontend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frequency_max_hz</span></code></dt><dd><p>Minimal frequency supported by the frontend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frequency_stepsize_hz</span></code></dt><dd><p>All frequencies are multiple of this value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frequency_tolerance_hz</span></code></dt><dd><p>Frequency tolerance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">symbol_rate_min</span></code></dt><dd><p>Minimal symbol rate, in bauds
(for Cable/Satellite systems).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">symbol_rate_max</span></code></dt><dd><p>Maximal symbol rate, in bauds
(for Cable/Satellite systems).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">symbol_rate_tolerance</span></code></dt><dd><p>Maximal symbol rate tolerance, in ppm
(for Cable/Satellite systems).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">caps</span></code></dt><dd><p>Capabilities supported by the frontend,
as specified in <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fe_caps</span></code>.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dvb_frontend_ops">
struct <code class="sig-name descname">dvb_frontend_ops</code><a class="headerlink" href="#c.dvb_frontend_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Demodulation information and callbacks for ditialt TV</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dvb_frontend_ops {
    struct dvb_frontend_internal_info info;
    u8 delsys[MAX_DELSYS];
    void (*detach)(struct dvb_frontend *fe);
    void (*release)(struct dvb_frontend* fe);
    void (*release_sec)(struct dvb_frontend* fe);
    int (*init)(struct dvb_frontend* fe);
    int (*sleep)(struct dvb_frontend* fe);
    int (*suspend)(struct dvb_frontend *fe);
    int (*resume)(struct dvb_frontend *fe);
    int (*write)(struct dvb_frontend* fe, const u8 buf[], int len);
    int (*tune)(struct dvb_frontend* fe,bool re_tune,unsigned int mode_flags,unsigned int *delay, enum fe_status *status);
    enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend *fe);
    int (*set_frontend)(struct dvb_frontend *fe);
    int (*get_tune_settings)(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* settings);
    int (*get_frontend)(struct dvb_frontend *fe, struct dtv_frontend_properties *props);
    int (*read_status)(struct dvb_frontend *fe, enum fe_status *status);
    int (*read_ber)(struct dvb_frontend* fe, u32* ber);
    int (*read_signal_strength)(struct dvb_frontend* fe, u16* strength);
    int (*read_snr)(struct dvb_frontend* fe, u16* snr);
    int (*read_ucblocks)(struct dvb_frontend* fe, u32* ucblocks);
    int (*diseqc_reset_overload)(struct dvb_frontend* fe);
    int (*diseqc_send_master_cmd)(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd* cmd);
    int (*diseqc_recv_slave_reply)(struct dvb_frontend* fe, struct dvb_diseqc_slave_reply* reply);
    int (*diseqc_send_burst)(struct dvb_frontend *fe, enum fe_sec_mini_cmd minicmd);
    int (*set_tone)(struct dvb_frontend *fe, enum fe_sec_tone_mode tone);
    int (*set_voltage)(struct dvb_frontend *fe, enum fe_sec_voltage voltage);
    int (*enable_high_lnb_voltage)(struct dvb_frontend* fe, long arg);
    int (*dishnetwork_send_legacy_command)(struct dvb_frontend* fe, unsigned long cmd);
    int (*i2c_gate_ctrl)(struct dvb_frontend* fe, int enable);
    int (*ts_bus_ctrl)(struct dvb_frontend* fe, int acquire);
    int (*set_lna)(struct dvb_frontend *);
    enum dvbfe_search (*search)(struct dvb_frontend *fe);
    struct dvb_tuner_ops tuner_ops;
    struct analog_demod_ops analog_ops;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>embedded <a class="reference internal" href="#c.dvb_tuner_info" title="dvb_tuner_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_tuner_info</span></code></a> with tuner properties</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delsys</span></code></dt><dd><p>Delivery systems supported by the frontend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach</span></code></dt><dd><p>callback function called when frontend is detached.
drivers should clean up, but not yet free the <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">dvb_frontend</span></code></a> allocation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>callback function called when frontend is ready to be
freed.
drivers should free any allocated memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release_sec</span></code></dt><dd><p>callback function requesting that the Satellite Equipment
Control (SEC) driver to release and free any memory
allocated by the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init</span></code></dt><dd><p>callback function used to initialize the tuner device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sleep</span></code></dt><dd><p>callback function used to put the tuner to sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>callback function used to inform that the Kernel will
suspend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>callback function used to inform that the Kernel is
resuming from suspend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p>callback function used by some demod legacy drivers to
allow other drivers to write data into their registers.
Should not be used on new drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tune</span></code></dt><dd><p>callback function used by demod drivers that use
<strong>DVBFE_ALGO_HW</strong> to tune into a frequency.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_frontend_algo</span></code></dt><dd><p>returns the desired hardware algorithm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_frontend</span></code></dt><dd><p>callback function used to inform the demod to set the
parameters for demodulating a digital TV channel.
The properties to be used are stored at <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">dvb_frontend</span></code></a>.dtv_property_cache. The demod can change
the parameters to reflect the changes needed for the
channel to be decoded, and update statistics.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_tune_settings</span></code></dt><dd><p>callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_frontend</span></code></dt><dd><p>callback function used to inform the parameters
actuall in use. The properties to be used are stored at
<a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a>.dtv_property_cache and update
statistics. Please notice that it should not return
an error code if the statistics are not available
because the demog is not locked.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_status</span></code></dt><dd><p>returns the locking status of the frontend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_ber</span></code></dt><dd><p>legacy callback function to return the bit error rate.
Newer drivers should provide such info via DVBv5 API,
e. g. <strong>set_frontend</strong>;/<strong>get_frontend</strong>, implementing this
callback only if DVBv3 API compatibility is wanted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_signal_strength</span></code></dt><dd><p>legacy callback function to return the signal
strength. Newer drivers should provide such info via
DVBv5 API, e. g. <strong>set_frontend</strong>/<strong>get_frontend</strong>,
implementing this callback only if DVBv3 API
compatibility is wanted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_snr</span></code></dt><dd><p>legacy callback function to return the Signal/Noise
rate. Newer drivers should provide such info via
DVBv5 API, e. g. <strong>set_frontend</strong>/<strong>get_frontend</strong>,
implementing this callback only if DVBv3 API
compatibility is wanted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_ucblocks</span></code></dt><dd><p>legacy callback function to return the Uncorrected Error
Blocks. Newer drivers should provide such info via
DVBv5 API, e. g. <strong>set_frontend</strong>/<strong>get_frontend</strong>,
implementing this callback only if DVBv3 API
compatibility is wanted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">diseqc_reset_overload</span></code></dt><dd><p>callback function to implement the
FE_DISEQC_RESET_OVERLOAD() ioctl (only Satellite)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">diseqc_send_master_cmd</span></code></dt><dd><p>callback function to implement the
FE_DISEQC_SEND_MASTER_CMD() ioctl (only Satellite).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">diseqc_recv_slave_reply</span></code></dt><dd><p>callback function to implement the
FE_DISEQC_RECV_SLAVE_REPLY() ioctl (only Satellite)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">diseqc_send_burst</span></code></dt><dd><p>callback function to implement the
FE_DISEQC_SEND_BURST() ioctl (only Satellite).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_tone</span></code></dt><dd><p>callback function to implement the
FE_SET_TONE() ioctl (only Satellite).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_voltage</span></code></dt><dd><p>callback function to implement the
FE_SET_VOLTAGE() ioctl (only Satellite).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_high_lnb_voltage</span></code></dt><dd><p>callback function to implement the
FE_ENABLE_HIGH_LNB_VOLTAGE() ioctl (only Satellite).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dishnetwork_send_legacy_command</span></code></dt><dd><p>callback function to implement the
FE_DISHNETWORK_SEND_LEGACY_CMD() ioctl (only Satellite).
Drivers should not use this, except when the DVB
core emulation fails to provide proper support (e.g.
if <strong>set_voltage</strong> takes more than 8ms to work), and
when backward compatibility with this legacy API is
required.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i2c_gate_ctrl</span></code></dt><dd><p>controls the I2C gate. Newer drivers should use I2C
mux support instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ts_bus_ctrl</span></code></dt><dd><p>callback function used to take control of the TS bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_lna</span></code></dt><dd><p>callback function to power on/off/auto the LNA.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">search</span></code></dt><dd><p>callback function used on some custom algo search algos.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tuner_ops</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_tuner_ops" title="dvb_tuner_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_tuner_ops</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">analog_ops</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.analog_demod_ops" title="analog_demod_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">analog_demod_ops</span></code></a></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dtv_frontend_properties">
struct <code class="sig-name descname">dtv_frontend_properties</code><a class="headerlink" href="#c.dtv_frontend_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>contains a list of properties that are specific to a digital TV standard.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dtv_frontend_properties {
    u32 frequency;
    enum fe_modulation      modulation;
    enum fe_sec_voltage     voltage;
    enum fe_sec_tone_mode   sectone;
    enum fe_spectral_inversion inversion;
    enum fe_code_rate       fec_inner;
    enum fe_transmit_mode   transmission_mode;
    u32 bandwidth_hz;
    enum fe_guard_interval  guard_interval;
    enum fe_hierarchy       hierarchy;
    u32 symbol_rate;
    enum fe_code_rate       code_rate_HP;
    enum fe_code_rate       code_rate_LP;
    enum fe_pilot           pilot;
    enum fe_rolloff         rolloff;
    enum fe_delivery_system delivery_system;
    enum fe_interleaving    interleaving;
    u8 isdbt_partial_reception;
    u8 isdbt_sb_mode;
    u8 isdbt_sb_subchannel;
    u32 isdbt_sb_segment_idx;
    u32 isdbt_sb_segment_count;
    u8 isdbt_layer_enabled;
    struct {
        u8 segment_count;
        enum fe_code_rate   fec;
        enum fe_modulation  modulation;
        u8 interleaving;
    } layer[3];
    u32 stream_id;
    u32 scrambling_sequence_index;
    u8 atscmh_fic_ver;
    u8 atscmh_parade_id;
    u8 atscmh_nog;
    u8 atscmh_tnog;
    u8 atscmh_sgn;
    u8 atscmh_prc;
    u8 atscmh_rs_frame_mode;
    u8 atscmh_rs_frame_ensemble;
    u8 atscmh_rs_code_mode_pri;
    u8 atscmh_rs_code_mode_sec;
    u8 atscmh_sccc_block_mode;
    u8 atscmh_sccc_code_mode_a;
    u8 atscmh_sccc_code_mode_b;
    u8 atscmh_sccc_code_mode_c;
    u8 atscmh_sccc_code_mode_d;
    u32 lna;
    struct dtv_fe_stats     strength;
    struct dtv_fe_stats     cnr;
    struct dtv_fe_stats     pre_bit_error;
    struct dtv_fe_stats     pre_bit_count;
    struct dtv_fe_stats     post_bit_error;
    struct dtv_fe_stats     post_bit_count;
    struct dtv_fe_stats     block_error;
    struct dtv_fe_stats     block_count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">frequency</span></code></dt><dd><p>frequency in Hz for terrestrial/cable or in kHz for
Satellite</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">modulation</span></code></dt><dd><p>Frontend modulation type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">voltage</span></code></dt><dd><p>SEC voltage (only Satellite)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sectone</span></code></dt><dd><p>SEC tone mode (only Satellite)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inversion</span></code></dt><dd><p>Spectral inversion</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fec_inner</span></code></dt><dd><p>Forward error correction inner Code Rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transmission_mode</span></code></dt><dd><p>Transmission Mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bandwidth_hz</span></code></dt><dd><p>Bandwidth, in Hz. A zero value means that userspace
wants to autodetect.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">guard_interval</span></code></dt><dd><p>Guard Interval</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hierarchy</span></code></dt><dd><p>Hierarchy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">symbol_rate</span></code></dt><dd><p>Symbol Rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code_rate_HP</span></code></dt><dd><p>high priority stream code rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code_rate_LP</span></code></dt><dd><p>low priority stream code rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pilot</span></code></dt><dd><p>Enable/disable/autodetect pilot tones</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rolloff</span></code></dt><dd><p>Rolloff factor (alpha)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">delivery_system</span></code></dt><dd><p>FE delivery system (e. g. digital TV standard)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interleaving</span></code></dt><dd><p>interleaving</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isdbt_partial_reception</span></code></dt><dd><p>ISDB-T partial reception (only ISDB standard)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isdbt_sb_mode</span></code></dt><dd><p>ISDB-T Sound Broadcast (SB) mode (only ISDB standard)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isdbt_sb_subchannel</span></code></dt><dd><p>ISDB-T SB subchannel (only ISDB standard)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isdbt_sb_segment_idx</span></code></dt><dd><p>ISDB-T SB segment index (only ISDB standard)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isdbt_sb_segment_count</span></code></dt><dd><p>ISDB-T SB segment count (only ISDB standard)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">isdbt_layer_enabled</span></code></dt><dd><p>ISDB Layer enabled (only ISDB standard)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">layer</span></code></dt><dd><p>ISDB per-layer data (only ISDB standard)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">layer.segment_count</span></code></dt><dd><p>Segment Count;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">layer.fec</span></code></dt><dd><p>per layer code rate;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">layer.modulation</span></code></dt><dd><p>per layer modulation;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">layer.interleaving</span></code></dt><dd><p>per layer interleaving.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream_id</span></code></dt><dd><p>If different than zero, enable substream filtering, if
hardware supports (DVB-S2 and DVB-T2).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scrambling_sequence_index</span></code></dt><dd><p>Carries the index of the DVB-S2 physical layer
scrambling sequence.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_fic_ver</span></code></dt><dd><p>Version number of the FIC (Fast Information Channel)
signaling data (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_parade_id</span></code></dt><dd><p>Parade identification number (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_nog</span></code></dt><dd><p>Number of MH groups per MH subframe for a designated
parade (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_tnog</span></code></dt><dd><p>Total number of MH groups including all MH groups
belonging to all MH parades in one MH subframe
(only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_sgn</span></code></dt><dd><p>Start group number (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_prc</span></code></dt><dd><p>Parade repetition cycle (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_rs_frame_mode</span></code></dt><dd><p>Reed Solomon (RS) frame mode (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_rs_frame_ensemble</span></code></dt><dd><p>RS frame ensemble (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_rs_code_mode_pri</span></code></dt><dd><p>RS code mode pri (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_rs_code_mode_sec</span></code></dt><dd><p>RS code mode sec (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_sccc_block_mode</span></code></dt><dd><p>Series Concatenated Convolutional Code (SCCC)
Block Mode (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_sccc_code_mode_a</span></code></dt><dd><p>SCCC code mode A (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_sccc_code_mode_b</span></code></dt><dd><p>SCCC code mode B (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_sccc_code_mode_c</span></code></dt><dd><p>SCCC code mode C (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atscmh_sccc_code_mode_d</span></code></dt><dd><p>SCCC code mode D (only ATSC-M/H)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lna</span></code></dt><dd><p>Power ON/OFF/AUTO the Linear Now-noise Amplifier (LNA)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">strength</span></code></dt><dd><p>DVBv5 API statistics: Signal Strength</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cnr</span></code></dt><dd><p>DVBv5 API statistics: Signal to Noise ratio of the
(main) carrier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pre_bit_error</span></code></dt><dd><p>DVBv5 API statistics: pre-Viterbi bit error count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pre_bit_count</span></code></dt><dd><p>DVBv5 API statistics: pre-Viterbi bit count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">post_bit_error</span></code></dt><dd><p>DVBv5 API statistics: post-Viterbi bit error count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">post_bit_count</span></code></dt><dd><p>DVBv5 API statistics: post-Viterbi bit count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block_error</span></code></dt><dd><p>DVBv5 API statistics: block error count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block_count</span></code></dt><dd><p>DVBv5 API statistics: block count</p>
</dd>
</dl>
</div>
<p><strong>NOTE</strong></p>
<p>derivated statistics like Uncorrected Error blocks (UCE) are
calculated on userspace.</p>
<p><strong>Description</strong></p>
<p>Only a subset of the properties are needed for a given delivery system.
For more info, consult the media_api.html with the documentation of the
Userspace API.</p>
<dl class="type">
<dt id="c.dvb_frontend">
struct <code class="sig-name descname">dvb_frontend</code><a class="headerlink" href="#c.dvb_frontend" title="Permalink to this definition">¶</a></dt>
<dd><p>Frontend structure to be used on drivers.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dvb_frontend {
    struct kref refcount;
    struct dvb_frontend_ops ops;
    struct dvb_adapter *dvb;
    void *demodulator_priv;
    void *tuner_priv;
    void *frontend_priv;
    void *sec_priv;
    void *analog_demod_priv;
    struct dtv_frontend_properties dtv_property_cache;
#define DVB_FRONTEND_COMPONENT_TUNER 0;
#define DVB_FRONTEND_COMPONENT_DEMOD 1;
    int (*callback)(void *adapter_priv, int component, int cmd, int arg);
    int id;
    unsigned int exit;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt><dd><p>refcount to keep track of <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a>
references</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>embedded <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend_ops</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dvb</span></code></dt><dd><p>pointer to <a class="reference internal" href="dtv-common.html#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">demodulator_priv</span></code></dt><dd><p>demod private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tuner_priv</span></code></dt><dd><p>tuner private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frontend_priv</span></code></dt><dd><p>frontend private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sec_priv</span></code></dt><dd><p>SEC private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">analog_demod_priv</span></code></dt><dd><p>Analog demod private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dtv_property_cache</span></code></dt><dd><p>embedded <a class="reference internal" href="#c.dtv_frontend_properties" title="dtv_frontend_properties"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dtv_frontend_properties</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">callback</span></code></dt><dd><p>callback function used on some drivers to call
either the tuner or the demodulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Frontend ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exit</span></code></dt><dd><p>Used to inform the DVB core that the frontend
thread should exit (usually, means that the hardware
got disconnected.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dvb_register_frontend">
int <code class="sig-name descname">dvb_register_frontend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="dtv-common.html#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a><em> *dvb</em>, struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a><em> *fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_register_frontend" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a DVB frontend at the adapter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*dvb</span></code></dt><dd><p>pointer to <a class="reference internal" href="dtv-common.html#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*fe</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and initialize the private data needed by the frontend core to
manage the frontend and calls <a class="reference internal" href="dtv-common.html#c.dvb_register_device" title="dvb_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_register_device()</span></code></a> to register a new
frontend. It also cleans the property cache that stores the frontend
parameters and selects the first available delivery system.</p>
</div>
<dl class="function">
<dt id="c.dvb_unregister_frontend">
int <code class="sig-name descname">dvb_unregister_frontend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a><em> *fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_unregister_frontend" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters a DVB frontend</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*fe</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops the frontend kthread, calls <a class="reference internal" href="dtv-common.html#c.dvb_unregister_device" title="dvb_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_unregister_device()</span></code></a> and frees the
private frontend data allocated by <a class="reference internal" href="#c.dvb_register_frontend" title="dvb_register_frontend"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_register_frontend()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>This function doesn’t frees the memory allocated by the demod,
by the SEC driver and by the tuner. In order to free it, an explicit call to
<a class="reference internal" href="#c.dvb_frontend_detach" title="dvb_frontend_detach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_frontend_detach()</span></code></a> is needed, after calling this function.</p>
</div>
<dl class="function">
<dt id="c.dvb_frontend_detach">
void <code class="sig-name descname">dvb_frontend_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a><em> *fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_frontend_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Detaches and frees frontend specific data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*fe</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called after <a class="reference internal" href="#c.dvb_unregister_frontend" title="dvb_unregister_frontend"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_unregister_frontend()</span></code></a>. It
calls the SEC, tuner and demod release functions:
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.release_sec</span></code></a>, <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.release,
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.analog_ops</span></code></a>.release and <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.release</span></code></a>.</p>
<p>If the driver is compiled with <code class="docutils literal notranslate"><span class="pre">CONFIG_MEDIA_ATTACH</span></code>, it also decreases
the module reference count, needed to allow userspace to remove the
previously used DVB frontend modules.</p>
</div>
<dl class="function">
<dt id="c.dvb_frontend_suspend">
int <code class="sig-name descname">dvb_frontend_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a><em> *fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_frontend_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Suspends a Digital TV frontend</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*fe</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function prepares a Digital TV frontend to suspend.</p>
<p>In order to prepare the tuner to suspend, if
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.suspend() is available, it calls it. Otherwise,
it will call <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.sleep(), if available.</p>
<p>It will also call <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.suspend</span></code></a>() to put the demod to suspend,
if available. Otherwise it will call <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.sleep</span></code></a>().</p>
<p>The drivers should also call <a class="reference internal" href="#c.dvb_frontend_suspend" title="dvb_frontend_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_frontend_suspend()</span></code></a> as part of their
handler for the <code class="xref c c-type docutils literal notranslate"><span class="pre">device_driver.suspend</span></code>().</p>
</div>
<dl class="function">
<dt id="c.dvb_frontend_resume">
int <code class="sig-name descname">dvb_frontend_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a><em> *fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_frontend_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Resumes a Digital TV frontend</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*fe</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function resumes the usual operation of the tuner after resume.</p>
<p>In order to resume the frontend, it calls the demod
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.resume</span></code></a>() if available. Otherwise it calls demod
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.init</span></code></a>().</p>
<p>If <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.resume() is available, It, it calls it.
Otherwise,t will call <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.init(), if available.</p>
<p>Once tuner and demods are resumed, it will enforce that the SEC voltage and
tone are restored to their previous values and wake up the frontend’s
kthread in order to retune the frontend.</p>
<p>The drivers should also call <a class="reference internal" href="#c.dvb_frontend_resume" title="dvb_frontend_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">dvb_frontend_resume()</span></code></a> as part of their
handler for the <code class="xref c c-type docutils literal notranslate"><span class="pre">device_driver.resume</span></code>().</p>
</div>
<dl class="function">
<dt id="c.dvb_frontend_reinitialise">
void <code class="sig-name descname">dvb_frontend_reinitialise</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a><em> *fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_frontend_reinitialise" title="Permalink to this definition">¶</a></dt>
<dd><p>forces a reinitialisation at the frontend</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*fe</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.init</span></code></a>() and <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.init(),
and resets SEC tone and voltage (for Satellite systems).</p>
<p><strong>NOTE</strong></p>
<p>Currently, this function is used only by one driver (budget-av).
It seems to be due to address some special issue with that specific
frontend.</p>
</div>
<dl class="function">
<dt id="c.dvb_frontend_sleep_until">
void <code class="sig-name descname">dvb_frontend_sleep_until</code><span class="sig-paren">(</span>ktime_t<em> *waketime</em>, u32<em> add_usec</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_frontend_sleep_until" title="Permalink to this definition">¶</a></dt>
<dd><p>Sleep for the amount of time given by add_usec parameter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*waketime</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ktime_t</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">add_usec</span></code></dt><dd><p>time to sleep, in microseconds</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to measure the time required for the
FE_DISHNETWORK_SEND_LEGACY_CMD() ioctl to work. It needs to be as precise
as possible, as it affects the detection of the dish tone command at the
satellite subsystem.</p>
<p>Its used internally by the DVB frontend core, in order to emulate
FE_DISHNETWORK_SEND_LEGACY_CMD() using the <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.set_voltage</span></code></a>()
callback.</p>
<p><strong>NOTE</strong></p>
<p>it should not be used at the drivers, as the emulation for the
legacy callback is provided by the Kernel. The only situation where this
should be at the drivers is when there are some bugs at the hardware that
would prevent the core emulation to work. On such cases, the driver would
be writing a <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">dvb_frontend_ops.dishnetwork_send_legacy_command</span></code></a>() and
calling this function directly.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3.2. Digital TV Frontend kABI</a><ul>
<li><a class="reference internal" href="#digital-tv-frontend">3.2.1. Digital TV Frontend</a><ul>
<li><a class="reference internal" href="#demodulator-driver">3.2.1.1. Demodulator driver</a></li>
<li><a class="reference internal" href="#attaching-frontend-driver-to-the-bridge-driver">3.2.1.2. Attaching frontend driver to the bridge driver</a></li>
</ul>
</li>
<li><a class="reference internal" href="#digital-tv-frontend-statistics">3.2.2. Digital TV Frontend statistics</a><ul>
<li><a class="reference internal" href="#introduction">3.2.2.1. Introduction</a></li>
<li><a class="reference internal" href="#groups-of-statistics">3.2.2.2. Groups of statistics</a></li>
<li><a class="reference internal" href="#statistics-collection">3.2.2.3. Statistics collection</a><ul>
<li><a class="reference internal" href="#if-the-driver-have-a-bit-that-indicates-when-a-collected-data-is-ready">3.2.2.3.1. if the driver have a bit that indicates when a collected data is ready</a></li>
<li><a class="reference internal" href="#if-the-driver-doesn-t-provide-a-statistics-available-check-bit">3.2.2.3.2. If the driver doesn’t provide a statistics available check bit</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#digital-tv-frontend-functions-and-types">3.2.3. Digital TV Frontend functions and types</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/media/dtv-frontend.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/media/dtv-frontend.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>