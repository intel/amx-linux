
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>2.4. Video device’ s internal representation &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="2.5. V4L2 device instance" href="v4l2-device.html" />
    <link rel="prev" title="2.1. Introduction" href="v4l2-intro.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="video-device-s-internal-representation">
<h1><span class="section-number">2.4. </span>Video device’ s internal representation<a class="headerlink" href="#video-device-s-internal-representation" title="Permalink to this headline">¶</a></h1>
<p>The actual device nodes in the <code class="docutils literal notranslate"><span class="pre">/dev</span></code> directory are created using the
<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a> struct (<code class="docutils literal notranslate"><span class="pre">v4l2-dev.h</span></code>). This struct can either be
allocated dynamically or embedded in a larger struct.</p>
<p>To allocate it dynamically use <a class="reference internal" href="#c.video_device_alloc" title="video_device_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_alloc()</span></code></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">video_device</span><span class="w"> </span><span class="o">*</span><span class="n">vdev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">video_device_alloc</span><span class="p">();</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vdev</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span><span class="w"></span>

<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">release</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">video_device_release</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>If you embed it in a larger struct, then you must set the <code class="docutils literal notranslate"><span class="pre">release()</span></code>
callback to your own function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">video_device</span><span class="w"> </span><span class="o">*</span><span class="n">vdev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_vdev</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">;</span><span class="w"></span>

<span class="n">vdev</span><span class="o">-&gt;</span><span class="n">release</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_vdev_release</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">release()</span></code> callback must be set and it is called when the last user
of the video device exits.</p>
<p>The default <a class="reference internal" href="#c.video_device_release" title="video_device_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_release()</span></code></a> callback currently
just calls <code class="docutils literal notranslate"><span class="pre">kfree</span></code> to free the allocated memory.</p>
<p>There is also a <a class="reference internal" href="#c.video_device_release_empty" title="video_device_release_empty"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_release_empty()</span></code></a> function that does
nothing (is empty) and should be used if the struct is embedded and there
is nothing to do when it is released.</p>
<p>You should also set these fields of <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>:</p>
<ul>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;v4l2_dev: must be set to the <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_device</span></code></a>
parent device.</p></li>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;name: set to something descriptive and unique.</p></li>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;vfl_dir: set this to <code class="docutils literal notranslate"><span class="pre">VFL_DIR_RX</span></code> for capture
devices (<code class="docutils literal notranslate"><span class="pre">VFL_DIR_RX</span></code> has value 0, so this is normally already the
default), set to <code class="docutils literal notranslate"><span class="pre">VFL_DIR_TX</span></code> for output devices and <code class="docutils literal notranslate"><span class="pre">VFL_DIR_M2M</span></code> for mem2mem (codec) devices.</p></li>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;fops: set to the <a class="reference internal" href="#c.v4l2_file_operations" title="v4l2_file_operations"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_file_operations</span></code></a>
struct.</p></li>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;ioctl_ops: if you use the <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops</span></code></a>
to simplify ioctl maintenance (highly recommended to use this and it might
become compulsory in the future!), then set this to your
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops</span></code></a> struct. The <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;vfl_type and
<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;vfl_dir fields are used to disable ops that do not
match the type/dir combination. E.g. VBI ops are disabled for non-VBI nodes,
and output ops  are disabled for a capture device. This makes it possible to
provide just one <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops</span></code></a> struct for both vbi and
video nodes.</p></li>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;lock: leave to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if you want to do all the
locking  in the driver. Otherwise you give it a pointer to a struct
<code class="docutils literal notranslate"><span class="pre">mutex_lock</span></code> and before the <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;unlocked_ioctl
file operation is called this lock will be taken by the core and released
afterwards. See the next section for more details.</p></li>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;queue: a pointer to the <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a>
associated with this device node.
If queue is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, and queue-&gt;lock is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then queue-&gt;lock
is used for the queuing ioctls (<code class="docutils literal notranslate"><span class="pre">VIDIOC_REQBUFS</span></code>, <code class="docutils literal notranslate"><span class="pre">CREATE_BUFS</span></code>,
<code class="docutils literal notranslate"><span class="pre">QBUF</span></code>, <code class="docutils literal notranslate"><span class="pre">DQBUF</span></code>,  <code class="docutils literal notranslate"><span class="pre">QUERYBUF</span></code>, <code class="docutils literal notranslate"><span class="pre">PREPARE_BUF</span></code>, <code class="docutils literal notranslate"><span class="pre">STREAMON</span></code> and
<code class="docutils literal notranslate"><span class="pre">STREAMOFF</span></code>) instead of the lock above.
That way the <a class="reference internal" href="v4l2-videobuf2.html#vb2-framework"><span class="std std-ref">vb2</span></a> queuing framework does not have
to wait for other ioctls.   This queue pointer is also used by the
<a class="reference internal" href="v4l2-videobuf2.html#vb2-framework"><span class="std std-ref">vb2</span></a> helper functions to check for
queuing ownership (i.e. is the filehandle calling it allowed to do the
operation).</p></li>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;prio: keeps track of the priorities. Used to
implement <code class="docutils literal notranslate"><span class="pre">VIDIOC_G_PRIORITY</span></code> and <code class="docutils literal notranslate"><span class="pre">VIDIOC_S_PRIORITY</span></code>.
If left to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then it will use the <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span></code></a>
in <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_device</span></code></a>. If you want to have a separate priority state per
(group of) device node(s),   then you can point it to your own struct
<a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_prio_state</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;dev_parent: you only set this if v4l2_device was
registered with <code class="docutils literal notranslate"><span class="pre">NULL</span></code> as the parent <code class="docutils literal notranslate"><span class="pre">device</span></code> struct. This only happens
in cases where one hardware device has multiple PCI devices that all share
the same <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_device</span></code></a> core.</p>
<p>The cx88 driver is an example of this: one core <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_device</span></code></a> struct,
but   it is used by both a raw video PCI device (cx8800) and a MPEG PCI device
(cx8802). Since the <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_device</span></code></a> cannot be associated with two PCI
devices at the same time it is setup without a parent device. But when the
<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> is initialized you <strong>do</strong> know which parent
PCI device to use and so you set <code class="docutils literal notranslate"><span class="pre">dev_device</span></code> to the correct PCI device.</p>
</li>
</ul>
<p>If you use <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops</span></code></a>, then you should set
<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;unlocked_ioctl to <a class="reference internal" href="v4l2-common.html#c.video_ioctl2" title="video_ioctl2"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_ioctl2()</span></code></a> in your
<a class="reference internal" href="#c.v4l2_file_operations" title="v4l2_file_operations"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_file_operations</span></code></a> struct.</p>
<p>In some cases you want to tell the core that a function you had specified in
your <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops</span></code></a> should be ignored. You can mark such ioctls by
calling this function before <a class="reference internal" href="#c.video_register_device" title="video_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_register_device()</span></code></a> is called:</p>
<blockquote>
<div><p><a class="reference internal" href="#c.v4l2_disable_ioctl" title="v4l2_disable_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_disable_ioctl</span></code></a>
(<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">vdev</span></code></a>, cmd).</p>
</div></blockquote>
<p>This tends to be needed if based on external factors (e.g. which card is
being used) you want to turns off certain features in <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops</span></code></a>
without having to make a new struct.</p>
<p>The <a class="reference internal" href="#c.v4l2_file_operations" title="v4l2_file_operations"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_file_operations</span></code></a> struct is a subset of file_operations.
The main difference is that the inode argument is omitted since it is never
used.</p>
<p>If integration with the media framework is needed, you must initialize the
<a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a> struct embedded in the <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a> struct
(entity field) by calling <a class="reference internal" href="mc-core.html#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_pads_init()</span></code></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">media_pad</span><span class="w"> </span><span class="o">*</span><span class="n">pad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_vdev</span><span class="o">-&gt;</span><span class="n">pad</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">media_entity_pads_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">entity</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">pad</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The pads array must have been previously initialized. There is no need to
manually set the <a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a> type and name fields.</p>
<p>A reference to the entity will be automatically acquired/released when the
video device is opened/closed.</p>
<section id="ioctls-and-locking">
<h2><span class="section-number">2.4.1. </span>ioctls and locking<a class="headerlink" href="#ioctls-and-locking" title="Permalink to this headline">¶</a></h2>
<p>The V4L core provides optional locking services. The main service is the
lock field in <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a>, which is a pointer to a mutex.
If you set this pointer, then that will be used by unlocked_ioctl to
serialize all ioctls.</p>
<p>If you are using the <a class="reference internal" href="v4l2-videobuf2.html#vb2-framework"><span class="std std-ref">videobuf2 framework</span></a>, then there
is a second lock that you can set: <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;queue-&gt;lock. If
set, then this lock will be used instead of <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;lock
to serialize all queuing ioctls (see the previous section
for the full list of those ioctls).</p>
<p>The advantage of using a different lock for the queuing ioctls is that for some
drivers (particularly USB drivers) certain commands such as setting controls
can take a long time, so you want to use a separate lock for the buffer queuing
ioctls. That way your <code class="docutils literal notranslate"><span class="pre">VIDIOC_DQBUF</span></code> doesn’t stall because the driver is busy
changing the e.g. exposure of the webcam.</p>
<p>Of course, you can always do all the locking yourself by leaving both lock
pointers at <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>If you use the old <a class="reference internal" href="v4l2-videobuf.html#vb-framework"><span class="std std-ref">videobuf framework</span></a> then you must
pass the <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;lock to the videobuf queue initialize
function: if videobuf has to wait for a frame to arrive, then it will
temporarily unlock the lock and relock it afterwards. If your driver also
waits in the code, then you should do the same to allow other
processes to access the device node while the first process is waiting for
something.</p>
<p>In the case of <a class="reference internal" href="v4l2-videobuf2.html#vb2-framework"><span class="std std-ref">videobuf2</span></a> you will need to implement the
<code class="docutils literal notranslate"><span class="pre">wait_prepare()</span></code> and <code class="docutils literal notranslate"><span class="pre">wait_finish()</span></code> callbacks to unlock/lock if applicable.
If you use the <code class="docutils literal notranslate"><span class="pre">queue-&gt;lock</span></code> pointer, then you can use the helper functions
<a class="reference internal" href="v4l2-videobuf2.html#c.vb2_ops_wait_prepare" title="vb2_ops_wait_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_ops_wait_prepare()</span></code></a> and <a class="reference internal" href="v4l2-videobuf2.html#c.vb2_ops_wait_finish" title="vb2_ops_wait_finish"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_ops_wait_finish()</span></code></a>.</p>
<p>The implementation of a hotplug disconnect should also take the lock from
<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a> before calling v4l2_device_disconnect. If you are also
using <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;queue-&gt;lock, then you have to first lock
<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;queue-&gt;lock followed by <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;lock.
That way you can be sure no ioctl is running when you call
<a class="reference internal" href="v4l2-device.html#c.v4l2_device_disconnect" title="v4l2_device_disconnect"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_device_disconnect()</span></code></a>.</p>
</section>
<section id="video-device-registration">
<h2><span class="section-number">2.4.2. </span>Video device registration<a class="headerlink" href="#video-device-registration" title="Permalink to this headline">¶</a></h2>
<p>Next you register the video device with <a class="reference internal" href="#c.video_register_device" title="video_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_register_device()</span></code></a>.
This will create the character device for you.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">video_register_device</span><span class="p">(</span><span class="n">vdev</span><span class="p">,</span><span class="w"> </span><span class="n">VFL_TYPE_VIDEO</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">video_device_release</span><span class="p">(</span><span class="n">vdev</span><span class="p">);</span><span class="w"> </span><span class="cm">/* or kfree(my_vdev); */</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>If the <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_device</span></code></a> parent device has a not <code class="docutils literal notranslate"><span class="pre">NULL</span></code> mdev field,
the video device entity will be automatically registered with the media
device.</p>
<p>Which device is registered depends on the type argument. The following
types exist:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 26%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#c.vfl_devnode_type" title="vfl_devnode_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">vfl_devnode_type</span></code></a></p></th>
<th class="head"><p>Device name</p></th>
<th class="head"><p>Usage</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_VIDEO</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/dev/videoX</span></code></p></td>
<td><p>for video input/output devices</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_VBI</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/dev/vbiX</span></code></p></td>
<td><p>for vertical blank data (i.e.
closed captions, teletext)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_RADIO</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/dev/radioX</span></code></p></td>
<td><p>for radio tuners</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_SUBDEV</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/dev/v4l-subdevX</span></code></p></td>
<td><p>for V4L2 subdevices</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_SDR</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/dev/swradioX</span></code></p></td>
<td><p>for Software Defined Radio
(SDR) tuners</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_TOUCH</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/dev/v4l-touchX</span></code></p></td>
<td><p>for touch sensors</p></td>
</tr>
</tbody>
</table>
<p>The last argument gives you a certain amount of control over the device
node number used (i.e. the X in <code class="docutils literal notranslate"><span class="pre">videoX</span></code>). Normally you will pass -1
to let the v4l2 framework pick the first free number. But sometimes users
want to select a specific node number. It is common that drivers allow
the user to select a specific device node number through a driver module
option. That number is then passed to this function and video_register_device
will attempt to select that device node number. If that number was already
in use, then the next free device node number will be selected and it
will send a warning to the kernel log.</p>
<p>Another use-case is if a driver creates many devices. In that case it can
be useful to place different video devices in separate ranges. For example,
video capture devices start at 0, video output devices start at 16.
So you can use the last argument to specify a minimum device node number
and the v4l2 framework will try to pick the first free number that is equal
or higher to what you passed. If that fails, then it will just pick the
first free number.</p>
<p>Since in this case you do not care about a warning about not being able
to select the specified device node number, you can call the function
<a class="reference internal" href="#c.video_register_device_no_warn" title="video_register_device_no_warn"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_register_device_no_warn()</span></code></a> instead.</p>
<p>Whenever a device node is created some attributes are also created for you.
If you look in <code class="docutils literal notranslate"><span class="pre">/sys/class/video4linux</span></code> you see the devices. Go into e.g.
<code class="docutils literal notranslate"><span class="pre">video0</span></code> and you will see ‘name’, ‘dev_debug’ and ‘index’ attributes. The
‘name’ attribute is the ‘name’ field of the video_device struct. The
‘dev_debug’ attribute can be used to enable core debugging. See the next
section for more detailed information on this.</p>
<p>The ‘index’ attribute is the index of the device node: for each call to
<a class="reference internal" href="#c.video_register_device" title="video_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_register_device()</span></code></a> the index is just increased by 1. The
first video device node you register always starts with index 0.</p>
<p>Users can setup udev rules that utilize the index attribute to make fancy
device names (e.g. ‘<code class="docutils literal notranslate"><span class="pre">mpegX</span></code>’ for MPEG video capture device nodes).</p>
<p>After the device was successfully registered, then you can use these fields:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;vfl_type: the device type passed to
<a class="reference internal" href="#c.video_register_device" title="video_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_register_device()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;minor: the assigned device minor number.</p></li>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;num: the device node number (i.e. the X in
<code class="docutils literal notranslate"><span class="pre">videoX</span></code>).</p></li>
<li><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>-&gt;index: the device index number.</p></li>
</ul>
<p>If the registration failed, then you need to call
<a class="reference internal" href="#c.video_device_release" title="video_device_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_release()</span></code></a> to free the allocated <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a>
struct, or free your own struct if the <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a> was embedded in
it. The <code class="docutils literal notranslate"><span class="pre">vdev-&gt;release()</span></code> callback will never be called if the registration
failed, nor should you ever attempt to unregister the device if the
registration failed.</p>
</section>
<section id="video-device-debugging">
<h2><span class="section-number">2.4.3. </span>video device debugging<a class="headerlink" href="#video-device-debugging" title="Permalink to this headline">¶</a></h2>
<p>The ‘dev_debug’ attribute that is created for each video, vbi, radio or swradio
device in <code class="docutils literal notranslate"><span class="pre">/sys/class/video4linux/&lt;devX&gt;/</span></code> allows you to enable logging of
file operations.</p>
<p>It is a bitmask and the following bits can be set:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 7%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Mask</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x01</p></td>
<td><p>Log the ioctl name and error code. VIDIOC_(D)QBUF ioctls are
only logged if bit 0x08 is also set.</p></td>
</tr>
<tr class="row-odd"><td><p>0x02</p></td>
<td><p>Log the ioctl name arguments and error code. VIDIOC_(D)QBUF
ioctls are
only logged if bit 0x08 is also set.</p></td>
</tr>
<tr class="row-even"><td><p>0x04</p></td>
<td><p>Log the file operations open, release, read, write, mmap and
get_unmapped_area. The read and write operations are only
logged if bit 0x08 is also set.</p></td>
</tr>
<tr class="row-odd"><td><p>0x08</p></td>
<td><p>Log the read and write file operations and the VIDIOC_QBUF and
VIDIOC_DQBUF ioctls.</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>Log the poll file operation.</p></td>
</tr>
<tr class="row-odd"><td><p>0x20</p></td>
<td><p>Log error and messages in the control operations.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="video-device-cleanup">
<h2><span class="section-number">2.4.4. </span>Video device cleanup<a class="headerlink" href="#video-device-cleanup" title="Permalink to this headline">¶</a></h2>
<p>When the video device nodes have to be removed, either during the unload
of the driver or because the USB device was disconnected, then you should
unregister them with:</p>
<blockquote>
<div><p><a class="reference internal" href="#c.video_unregister_device" title="video_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_unregister_device()</span></code></a>
(<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">vdev</span></code></a>);</p>
</div></blockquote>
<p>This will remove the device nodes from sysfs (causing udev to remove them
from <code class="docutils literal notranslate"><span class="pre">/dev</span></code>).</p>
<p>After <a class="reference internal" href="#c.video_unregister_device" title="video_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_unregister_device()</span></code></a> returns no new opens can be done.
However, in the case of USB devices some application might still have one of
these device nodes open. So after the unregister all file operations (except
release, of course) will return an error as well.</p>
<p>When the last user of the video device node exits, then the <code class="docutils literal notranslate"><span class="pre">vdev-&gt;release()</span></code>
callback is called and you can do the final cleanup there.</p>
<p>Don’t forget to cleanup the media entity associated with the video device if
it has been initialized:</p>
<blockquote>
<div><p><a class="reference internal" href="mc-core.html#c.media_entity_cleanup" title="media_entity_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_cleanup</span></code></a>
(&amp;vdev-&gt;entity);</p>
</div></blockquote>
<p>This can be done from the release callback.</p>
</section>
<section id="helper-functions">
<h2><span class="section-number">2.4.5. </span>helper functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h2>
<p>There are a few useful helper functions:</p>
<ul class="simple">
<li><p>file and <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a> private data</p></li>
</ul>
<p>You can set/get driver private data in the video_device struct using:</p>
<blockquote>
<div><p><a class="reference internal" href="#c.video_get_drvdata" title="video_get_drvdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_get_drvdata</span></code></a>
(<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">vdev</span></code></a>);</p>
<p><a class="reference internal" href="#c.video_set_drvdata" title="video_set_drvdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_set_drvdata</span></code></a>
(<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">vdev</span></code></a>);</p>
</div></blockquote>
<p>Note that you can safely call <a class="reference internal" href="#c.video_set_drvdata" title="video_set_drvdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_set_drvdata()</span></code></a> before calling
<a class="reference internal" href="#c.video_register_device" title="video_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_register_device()</span></code></a>.</p>
<p>And this function:</p>
<blockquote>
<div><p><a class="reference internal" href="#c.video_devdata" title="video_devdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_devdata</span></code></a>
(struct file *file);</p>
</div></blockquote>
<p>returns the video_device belonging to the file struct.</p>
<p>The <a class="reference internal" href="#c.video_devdata" title="video_devdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_devdata()</span></code></a> function combines <a class="reference internal" href="#c.video_get_drvdata" title="video_get_drvdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_get_drvdata()</span></code></a>
with <a class="reference internal" href="#c.video_devdata" title="video_devdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_devdata()</span></code></a>:</p>
<blockquote>
<div><p><a class="reference internal" href="#c.video_drvdata" title="video_drvdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_drvdata</span></code></a>
(struct file *file);</p>
</div></blockquote>
<p>You can go from a <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a> struct to the v4l2_device struct using:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">v4l2_device</span><span class="w"> </span><span class="o">*</span><span class="n">v4l2_dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Device node name</p></li>
</ul>
<p>The <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">video_device</span></code></a> node kernel name can be retrieved using:</p>
<blockquote>
<div><p><a class="reference internal" href="#c.video_device_node_name" title="video_device_node_name"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_node_name</span></code></a>
(<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">vdev</span></code></a>);</p>
</div></blockquote>
<p>The name is used as a hint by userspace tools such as udev. The function
should be used where possible instead of accessing the video_device::num and
video_device::minor fields.</p>
</section>
<section id="video-device-functions-and-data-structures">
<h2><span class="section-number">2.4.6. </span>video_device functions and data structures<a class="headerlink" href="#video-device-functions-and-data-structures" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.vfl_devnode_type">
enum <code class="sig-name descname">vfl_devnode_type</code><a class="headerlink" href="#c.vfl_devnode_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of V4L2 device node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_VIDEO</span></code></dt><dd><p>for video input/output devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_VBI</span></code></dt><dd><p>for vertical blank data (i.e. closed captions, teletext)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_RADIO</span></code></dt><dd><p>for radio tuners</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_SUBDEV</span></code></dt><dd><p>for V4L2 subdevices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_SDR</span></code></dt><dd><p>for Software Defined Radio tuners</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_TOUCH</span></code></dt><dd><p>for touch sensors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VFL_TYPE_MAX</span></code></dt><dd><p>number of VFL types, must always be last in the enum</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.vfl_devnode_direction">
enum <code class="sig-name descname">vfl_devnode_direction</code><a class="headerlink" href="#c.vfl_devnode_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Identifies if a <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> corresponds to a receiver, a transmitter or a mem-to-mem device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">VFL_DIR_RX</span></code></dt><dd><p>device is a receiver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VFL_DIR_TX</span></code></dt><dd><p>device is a transmitter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VFL_DIR_M2M</span></code></dt><dd><p>device is a memory to memory device.</p>
</dd>
</dl>
</div>
<p><strong>Note</strong></p>
<p>Ignored if <a class="reference internal" href="#c.vfl_devnode_type" title="vfl_devnode_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vfl_devnode_type</span></code></a> is <code class="docutils literal notranslate"><span class="pre">VFL_TYPE_SUBDEV</span></code>.</p>
<dl class="type">
<dt id="c.v4l2_video_device_flags">
enum <code class="sig-name descname">v4l2_video_device_flags</code><a class="headerlink" href="#c.v4l2_video_device_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags used by <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">V4L2_FL_REGISTERED</span></code></p>
<blockquote>
<div><p>indicates that a <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> is registered.
Drivers can clear this flag if they want to block all future
device access. It is cleared by video_unregister_device.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">V4L2_FL_USES_V4L2_FH</span></code></p>
<blockquote>
<div><p>indicates that file-&gt;private_data points to <a class="reference internal" href="v4l2-fh.html#c.v4l2_fh" title="v4l2_fh"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_fh</span></code></a>.
This flag is set by the core when <a class="reference internal" href="v4l2-fh.html#c.v4l2_fh_init" title="v4l2_fh_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_fh_init()</span></code></a> is called.
All new drivers should use it.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">V4L2_FL_QUIRK_INVERTED_CROP</span></code></p>
<blockquote>
<div><p>some old M2M drivers use g/s_crop/cropcap incorrectly: crop and
compose are swapped. If this flag is set, then the selection
targets are swapped in the g/s_crop/cropcap functions in v4l2-ioctl.c.
This allows those drivers to correctly implement the selection API,
but the old crop API will still work as expected in order to preserve
backwards compatibility.
Never set this flag for new drivers.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">V4L2_FL_SUBDEV_RO_DEVNODE</span></code></p>
<blockquote>
<div><p>indicates that the video device node is registered in read-only mode.
The flag only applies to device nodes registered for sub-devices, it is
set by the core when the sub-devices device nodes are registered with
<a class="reference internal" href="v4l2-device.html#c.v4l2_device_register_ro_subdev_nodes" title="v4l2_device_register_ro_subdev_nodes"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_device_register_ro_subdev_nodes()</span></code></a> and used by the sub-device ioctl
handler to restrict access to some ioctl calls.</p>
</div></blockquote>
</div>
<dl class="type">
<dt id="c.v4l2_prio_state">
struct <code class="sig-name descname">v4l2_prio_state</code><a class="headerlink" href="#c.v4l2_prio_state" title="Permalink to this definition">¶</a></dt>
<dd><p>stores the priority states</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_prio_state {
    atomic_t prios[4];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">prios</span></code></dt><dd><p>array with elements to store the array priorities</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The size of <strong>prios</strong> array matches the number of priority types defined
by enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_priority</span></code>.</p>
</div>
<dl class="function">
<dt id="c.v4l2_prio_init">
void <code class="sig-name descname">v4l2_prio_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state">v4l2_prio_state</a><em> *global</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_prio_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes a <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span> <span class="pre">*global</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.v4l2_prio_change">
int <code class="sig-name descname">v4l2_prio_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state">v4l2_prio_state</a><em> *global</em>, enum v4l2_priority<em> *local</em>, enum v4l2_priority<em> new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_prio_change" title="Permalink to this definition">¶</a></dt>
<dd><p>changes the v4l2 file handler priority</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span> <span class="pre">*global</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span></code></a> of the device node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_priority</span> <span class="pre">*local</span></code></dt><dd><p>pointer to the desired priority, as defined by enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_priority</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_priority</span> <span class="pre">new</span></code></dt><dd><p>Priority type requested, as defined by enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_priority</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should be used only by the V4L2 core.</p>
</div>
</div>
<dl class="function">
<dt id="c.v4l2_prio_open">
void <code class="sig-name descname">v4l2_prio_open</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state">v4l2_prio_state</a><em> *global</em>, enum v4l2_priority<em> *local</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_prio_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the priority logic for a file handler open</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span> <span class="pre">*global</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span></code></a> of the device node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_priority</span> <span class="pre">*local</span></code></dt><dd><p>pointer to the desired priority, as defined by enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_priority</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should be used only by the V4L2 core.</p>
</div>
</div>
<dl class="function">
<dt id="c.v4l2_prio_close">
void <code class="sig-name descname">v4l2_prio_close</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state">v4l2_prio_state</a><em> *global</em>, enum v4l2_priority<em> local</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_prio_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the priority logic for a file handler close</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span> <span class="pre">*global</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span></code></a> of the device node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_priority</span> <span class="pre">local</span></code></dt><dd><p>priority to be released, as defined by enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_priority</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should be used only by the V4L2 core.</p>
</div>
</div>
<dl class="function">
<dt id="c.v4l2_prio_max">
enum v4l2_priority <code class="sig-name descname">v4l2_prio_max</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state">v4l2_prio_state</a><em> *global</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_prio_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum priority, as stored at the <strong>global</strong> array.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span> <span class="pre">*global</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span></code></a> of the device node.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should be used only by the V4L2 core.</p>
</div>
</div>
<dl class="function">
<dt id="c.v4l2_prio_check">
int <code class="sig-name descname">v4l2_prio_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state">v4l2_prio_state</a><em> *global</em>, enum v4l2_priority<em> local</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_prio_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the priority logic for a file handler close</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span> <span class="pre">*global</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span></code></a> of the device node.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_priority</span> <span class="pre">local</span></code></dt><dd><p>desired priority, as defined by enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_priority</span></code> local</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function should be used only by the V4L2 core.</p>
</div>
</div>
<dl class="type">
<dt id="c.v4l2_file_operations">
struct <code class="sig-name descname">v4l2_file_operations</code><a class="headerlink" href="#c.v4l2_file_operations" title="Permalink to this definition">¶</a></dt>
<dd><p>fs operations used by a V4L2 device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_file_operations {
    struct module *owner;
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    __poll_t (*poll) (struct file *, struct poll_table_struct *);
    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
#ifdef CONFIG_COMPAT;
    long (*compat_ioctl32) (struct file *, unsigned int, unsigned long);
#endif;
    unsigned long (*get_unmapped_area) (struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
    int (*mmap) (struct file *, struct vm_area_struct *);
    int (*open) (struct file *);
    int (*release) (struct file *);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>pointer to struct module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read</span></code></dt><dd><p>operations needed to implement the read() syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p>operations needed to implement the write() syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll</span></code></dt><dd><p>operations needed to implement the poll() syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unlocked_ioctl</span></code></dt><dd><p>operations needed to implement the ioctl() syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_ioctl32</span></code></dt><dd><p>operations needed to implement the ioctl() syscall for
the special case where the Kernel uses 64 bits instructions, but
the userspace uses 32 bits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_unmapped_area</span></code></dt><dd><p>called by the mmap() syscall, used when %!CONFIG_MMU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap</span></code></dt><dd><p>operations needed to implement the mmap() syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>operations needed to implement the open() syscall</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>operations needed to implement the release() syscall</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Those operations are used to implemente the fs struct file_operations
at the V4L2 drivers. The V4L2 core overrides the fs ops with some
extra logic needed by the subsystem.</p>
</div>
<dl class="type">
<dt id="c.video_device">
struct <code class="sig-name descname">video_device</code><a class="headerlink" href="#c.video_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure used to create and manage the V4L2 device nodes.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct video_device {
#if defined(CONFIG_MEDIA_CONTROLLER);
    struct media_entity entity;
    struct media_intf_devnode *intf_devnode;
    struct media_pipeline pipe;
#endif;
    const struct v4l2_file_operations *fops;
    u32 device_caps;
    struct device dev;
    struct cdev *cdev;
    struct v4l2_device *v4l2_dev;
    struct device *dev_parent;
    struct v4l2_ctrl_handler *ctrl_handler;
    struct vb2_queue *queue;
    struct v4l2_prio_state *prio;
    char name[32];
    enum vfl_devnode_type vfl_type;
    enum vfl_devnode_direction vfl_dir;
    int minor;
    u16 num;
    unsigned long flags;
    int index;
    spinlock_t fh_lock;
    struct list_head        fh_list;
    int dev_debug;
    v4l2_std_id tvnorms;
    void (*release)(struct video_device *vdev);
    const struct v4l2_ioctl_ops *ioctl_ops;
    unsigned long valid_ioctls[BITS_TO_LONGS(BASE_VIDIOC_PRIVATE)];
    struct mutex *lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entity</span></code></dt><dd><p><a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">intf_devnode</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_intf_devnode" title="media_intf_devnode"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_intf_devnode</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pipe</span></code></dt><dd><p><a class="reference internal" href="mc-core.html#c.media_pipeline" title="media_pipeline"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pipeline</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fops</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_file_operations" title="v4l2_file_operations"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_file_operations</span></code></a> for the video device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_caps</span></code></dt><dd><p>device capabilities as used in v4l2_capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p><a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> for the video device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cdev</span></code></dt><dd><p>character device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">v4l2_dev</span></code></dt><dd><p>pointer to <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_device</span></code></a> parent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_parent</span></code></dt><dd><p>pointer to <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> parent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctrl_handler</span></code></dt><dd><p>Control handler associated with this device node.
May be NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue</span></code></dt><dd><p><a class="reference internal" href="v4l2-videobuf2.html#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> associated with this device node. May be NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prio</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_prio_state" title="v4l2_prio_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_prio_state</span></code></a> with device’s Priority state.
If NULL, then v4l2_dev-&gt;prio will be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>video device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vfl_type</span></code></dt><dd><p>V4L device type, as defined by <a class="reference internal" href="#c.vfl_devnode_type" title="vfl_devnode_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vfl_devnode_type</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vfl_dir</span></code></dt><dd><p>V4L receiver, transmitter or m2m</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor</span></code></dt><dd><p>device node ‘minor’. It is set to -1 if the registration failed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num</span></code></dt><dd><p>number of the video device node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>video device flags. Use bitops to set/clear/test flags.
Contains a set of <a class="reference internal" href="#c.v4l2_video_device_flags" title="v4l2_video_device_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_video_device_flags</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>attribute to differentiate multiple indices on one physical device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fh_lock</span></code></dt><dd><p>Lock for all v4l2_fhs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fh_list</span></code></dt><dd><p>List of <a class="reference internal" href="v4l2-fh.html#c.v4l2_fh" title="v4l2_fh"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_fh</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_debug</span></code></dt><dd><p>Internal device debug flags, not for use by drivers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tvnorms</span></code></dt><dd><p>Supported tv norms</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>video device release() callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioctl_ops</span></code></dt><dd><p>pointer to <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_ioctl_ops</span></code></a> with ioctl callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid_ioctls</span></code></dt><dd><p>bitmap with the valid ioctls for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span></code> serialization lock</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only set <strong>dev_parent</strong> if that can’t be deduced from <strong>v4l2_dev</strong>.</p>
</div>
<dl class="function">
<dt id="c.media_entity_to_video_device">
<code class="sig-name descname">media_entity_to_video_device</code><span class="sig-paren">(</span><em>__entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_to_video_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> from the <a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a> embedded on it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__entity</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.to_video_device">
<code class="sig-name descname">to_video_device</code><span class="sig-paren">(</span><em>cd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.to_video_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> from the <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> embedded on it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cd</span></code></dt><dd><p>pointer to <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__video_register_device">
int <code class="sig-name descname">__video_register_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em>, enum <a class="reference internal" href="#c.vfl_devnode_type" title="vfl_devnode_type">vfl_devnode_type</a><em> type</em>, int<em> nr</em>, int<em> warn_if_nr_in_use</em>, struct module<em> *owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__video_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register video4linux devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vfl_devnode_type</span> <span class="pre">type</span></code></dt><dd><p>type of device to register, as defined by <a class="reference internal" href="#c.vfl_devnode_type" title="vfl_devnode_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vfl_devnode_type</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>which device node number is desired:
(0 == /dev/video0, 1 == /dev/video1, …, -1 == first free)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">warn_if_nr_in_use</span></code></dt><dd><p>warn if the desired device node number
was already in use and another number was chosen instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module that owns the video device node</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The registration code assigns minor numbers and device node numbers
based on the requested type and registers the new device node with
the kernel.</p>
<p>This function assumes that <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> was zeroed when it
was allocated and does not contain any stale date.</p>
<p>An error is returned if no free minor or device node number could be
found, or if the registration of the device node failed.</p>
<p>Returns 0 on success.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is meant to be used only inside the V4L2 core.
Drivers should use <a class="reference internal" href="#c.video_register_device" title="video_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_register_device()</span></code></a> or
<a class="reference internal" href="#c.video_register_device_no_warn" title="video_register_device_no_warn"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_register_device_no_warn()</span></code></a>.</p>
</div>
</div>
<dl class="function">
<dt id="c.video_register_device">
int <code class="sig-name descname">video_register_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em>, enum <a class="reference internal" href="#c.vfl_devnode_type" title="vfl_devnode_type">vfl_devnode_type</a><em> type</em>, int<em> nr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register video4linux devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vfl_devnode_type</span> <span class="pre">type</span></code></dt><dd><p>type of device to register, as defined by <a class="reference internal" href="#c.vfl_devnode_type" title="vfl_devnode_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vfl_devnode_type</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>which device node number is desired:
(0 == /dev/video0, 1 == /dev/video1, …, -1 == first free)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Internally, it calls <a class="reference internal" href="#c.__video_register_device" title="__video_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">__video_register_device()</span></code></a>. Please see its
documentation for more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if video_register_device fails, the release() callback of
<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> structure is <em>not</em> called, so the caller
is responsible for freeing any data. Usually that means that
you <a class="reference internal" href="#c.video_device_release" title="video_device_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_release()</span></code></a> should be called on failure.</p>
</div>
</div>
<dl class="function">
<dt id="c.video_register_device_no_warn">
int <code class="sig-name descname">video_register_device_no_warn</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em>, enum <a class="reference internal" href="#c.vfl_devnode_type" title="vfl_devnode_type">vfl_devnode_type</a><em> type</em>, int<em> nr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_register_device_no_warn" title="Permalink to this definition">¶</a></dt>
<dd><p>register video4linux devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vfl_devnode_type</span> <span class="pre">type</span></code></dt><dd><p>type of device to register, as defined by <a class="reference internal" href="#c.vfl_devnode_type" title="vfl_devnode_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vfl_devnode_type</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr</span></code></dt><dd><p>which device node number is desired:
(0 == /dev/video0, 1 == /dev/video1, …, -1 == first free)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is identical to <a class="reference internal" href="#c.video_register_device" title="video_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_register_device()</span></code></a> except that no
warning is issued if the desired device node number was already in use.</p>
<p>Internally, it calls <a class="reference internal" href="#c.__video_register_device" title="__video_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">__video_register_device()</span></code></a>. Please see its
documentation for more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if video_register_device fails, the release() callback of
<a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> structure is <em>not</em> called, so the caller
is responsible for freeing any data. Usually that means that
you <a class="reference internal" href="#c.video_device_release" title="video_device_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_release()</span></code></a> should be called on failure.</p>
</div>
</div>
<dl class="function">
<dt id="c.video_unregister_device">
void <code class="sig-name descname">video_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister video devices.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p><a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Does nothing if vdev == NULL or if <a class="reference internal" href="#c.video_is_registered" title="video_is_registered"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_is_registered()</span></code></a> returns false.</p>
</div>
<dl class="function">
<dt id="c.video_device_alloc">
struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a> * <code class="sig-name descname">video_device_alloc</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.video_device_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to alloc <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if <code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> or a <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> on success.</p>
</div>
<dl class="function">
<dt id="c.video_device_release">
void <code class="sig-name descname">video_device_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_device_release" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to release <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Can also be used for video_device-&gt;release().</p>
</div>
<dl class="function">
<dt id="c.video_device_release_empty">
void <code class="sig-name descname">video_device_release_empty</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_device_release_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to implement the video_device-&gt;release() callback.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This release function does nothing.</p>
<p>It should be used when the video_device is a static global struct.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Having a static video_device is a dubious construction at best.</p>
</div>
</div>
<dl class="function">
<dt id="c.v4l2_disable_ioctl">
void <code class="sig-name descname">v4l2_disable_ioctl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em>, unsigned int<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_disable_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>mark that a given command isn’t implemented. shouldn’t use core locking</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows drivers to provide just one v4l2_ioctl_ops struct, but
disable ioctls based on the specific card that is actually found.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This must be called before video_register_device.
See also the comments for determine_valid_ioctls().</p>
</div>
</div>
<dl class="function">
<dt id="c.video_get_drvdata">
void * <code class="sig-name descname">video_get_drvdata</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_get_drvdata" title="Permalink to this definition">¶</a></dt>
<dd><p>gets private data from <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns a pointer to the private data</p>
</div>
<dl class="function">
<dt id="c.video_set_drvdata">
void <code class="sig-name descname">video_set_drvdata</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_set_drvdata" title="Permalink to this definition">¶</a></dt>
<dd><p>sets private data from <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>private data pointer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.video_devdata">
struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a> * <code class="sig-name descname">video_devdata</code><span class="sig-paren">(</span>struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_devdata" title="Permalink to this definition">¶</a></dt>
<dd><p>gets <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> from struct file.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>pointer to struct file</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.video_drvdata">
void * <code class="sig-name descname">video_drvdata</code><span class="sig-paren">(</span>struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_drvdata" title="Permalink to this definition">¶</a></dt>
<dd><p>gets private data from <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> using the struct file.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>pointer to struct file</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is function combines both <a class="reference internal" href="#c.video_get_drvdata" title="video_get_drvdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_get_drvdata()</span></code></a> and <a class="reference internal" href="#c.video_devdata" title="video_devdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_devdata()</span></code></a>
as this is used very often.</p>
</div>
<dl class="function">
<dt id="c.video_device_node_name">
const char * <code class="sig-name descname">video_device_node_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_device_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the video device name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the device name string</p>
</div>
<dl class="function">
<dt id="c.video_is_registered">
int <code class="sig-name descname">video_is_registered</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_is_registered" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> is registered.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
</div>
<dl class="function">
<dt id="c.video_device_pipeline_start">
int <code class="sig-name descname">video_device_pipeline_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em>, struct <a class="reference internal" href="mc-core.html#c.media_pipeline" title="media_pipeline">media_pipeline</a><em> *pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_device_pipeline_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a pipeline as streaming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>Starting video device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pipeline</span> <span class="pre">*pipe</span></code></dt><dd><p>Media pipeline to be assigned to all entities in the pipeline.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark all entities connected to a given video device through enabled links,
either directly or indirectly, as streaming. The given pipeline object is
assigned to every pad in the pipeline and stored in the media_pad pipe
field.</p>
<p>Calls to this function can be nested, in which case the same number of
<a class="reference internal" href="#c.video_device_pipeline_stop" title="video_device_pipeline_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_pipeline_stop()</span></code></a> calls will be required to stop streaming. The
pipeline pointer must be identical for all nested calls to
<a class="reference internal" href="#c.video_device_pipeline_start" title="video_device_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_pipeline_start()</span></code></a>.</p>
<p>The video device must contain a single pad.</p>
<p>This is a convenience wrapper around <a class="reference internal" href="mc-core.html#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_start()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.__video_device_pipeline_start">
int <code class="sig-name descname">__video_device_pipeline_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em>, struct <a class="reference internal" href="mc-core.html#c.media_pipeline" title="media_pipeline">media_pipeline</a><em> *pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__video_device_pipeline_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a pipeline as streaming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>Starting video device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_pipeline</span> <span class="pre">*pipe</span></code></dt><dd><p>Media pipeline to be assigned to all entities in the pipeline.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>..note:: This is the non-locking version of <a class="reference internal" href="#c.video_device_pipeline_start" title="video_device_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_pipeline_start()</span></code></a></p>
<p>The video device must contain a single pad.</p>
<p>This is a convenience wrapper around <a class="reference internal" href="mc-core.html#c.__media_pipeline_start" title="__media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">__media_pipeline_start()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.video_device_pipeline_stop">
void <code class="sig-name descname">video_device_pipeline_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_device_pipeline_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a pipeline as not streaming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>Starting video device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark all entities connected to a given video device through enabled links,
either directly or indirectly, as not streaming. The media_pad pipe field
is reset to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>If multiple calls to <a class="reference internal" href="mc-core.html#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_start()</span></code></a> have been made, the same
number of calls to this function are required to mark the pipeline as not
streaming.</p>
<p>The video device must contain a single pad.</p>
<p>This is a convenience wrapper around <a class="reference internal" href="mc-core.html#c.media_pipeline_stop" title="media_pipeline_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_stop()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.__video_device_pipeline_stop">
void <code class="sig-name descname">__video_device_pipeline_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__video_device_pipeline_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a pipeline as not streaming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>Starting video device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the non-locking version of <a class="reference internal" href="mc-core.html#c.media_pipeline_stop" title="media_pipeline_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_pipeline_stop()</span></code></a></p>
</div>
<p>The video device must contain a single pad.</p>
<p>This is a convenience wrapper around <a class="reference internal" href="mc-core.html#c.__media_pipeline_stop" title="__media_pipeline_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">__media_pipeline_stop()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.video_device_pipeline_alloc_start">
int <code class="sig-name descname">video_device_pipeline_alloc_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_device_pipeline_alloc_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a pipeline as streaming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>Starting video device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.video_device_pipeline_alloc_start" title="video_device_pipeline_alloc_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_pipeline_alloc_start()</span></code></a> is similar to <a class="reference internal" href="#c.video_device_pipeline_start" title="video_device_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_pipeline_start()</span></code></a>
but instead of working on a given pipeline the function will use an
existing pipeline if the video device is already part of a pipeline, or
allocate a new pipeline.</p>
<p>Calls to <a class="reference internal" href="#c.video_device_pipeline_alloc_start" title="video_device_pipeline_alloc_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_pipeline_alloc_start()</span></code></a> must be matched with
<a class="reference internal" href="#c.video_device_pipeline_stop" title="video_device_pipeline_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_pipeline_stop()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.video_device_pipeline">
struct <a class="reference internal" href="mc-core.html#c.media_pipeline" title="media_pipeline">media_pipeline</a> * <code class="sig-name descname">video_device_pipeline</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.video_device" title="video_device">video_device</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.video_device_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the media pipeline a video device is part of</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>The video device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the media pipeline that a video device has been
associated with when constructing the pipeline with
<a class="reference internal" href="#c.video_device_pipeline_start" title="video_device_pipeline_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_pipeline_start()</span></code></a>. The pointer remains valid until
<a class="reference internal" href="#c.video_device_pipeline_stop" title="video_device_pipeline_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_device_pipeline_stop()</span></code></a> is called.</p>
<p>The video device must contain a single pad.</p>
<p>This is a convenience wrapper around <a class="reference internal" href="mc-core.html#c.media_entity_pipeline" title="media_entity_pipeline"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_pipeline()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>The media_pipeline the video device is part of, or NULL if the video
device is not part of any pipeline.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.4. Video device’ s internal representation</a><ul>
<li><a class="reference internal" href="#ioctls-and-locking">2.4.1. ioctls and locking</a></li>
<li><a class="reference internal" href="#video-device-registration">2.4.2. Video device registration</a></li>
<li><a class="reference internal" href="#video-device-debugging">2.4.3. video device debugging</a></li>
<li><a class="reference internal" href="#video-device-cleanup">2.4.4. Video device cleanup</a></li>
<li><a class="reference internal" href="#helper-functions">2.4.5. helper functions</a></li>
<li><a class="reference internal" href="#video-device-functions-and-data-structures">2.4.6. video_device functions and data structures</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/media/v4l2-dev.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/media/v4l2-dev.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>