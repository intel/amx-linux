
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>2.16. V4L2 videobuf2 functions and data structures &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="2.17. V4L2 DV Timings functions" href="v4l2-dv-timings.html" />
    <link rel="prev" title="2.15. Videobuf Framework" href="v4l2-videobuf.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="v4l2-videobuf2-functions-and-data-structures">
<span id="vb2-framework"></span><h1><span class="section-number">2.16. </span>V4L2 videobuf2 functions and data structures<a class="headerlink" href="#v4l2-videobuf2-functions-and-data-structures" title="Permalink to this headline">¶</a></h1>
<dl class="type">
<dt id="c.vb2_memory">
enum <code class="sig-name descname">vb2_memory</code><a class="headerlink" href="#c.vb2_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>type of memory model used to make the buffers visible on userspace.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">VB2_MEMORY_UNKNOWN</span></code></dt><dd><p>Buffer status is unknown or it is not used yet on
userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_MEMORY_MMAP</span></code></dt><dd><p>The buffers are allocated by the Kernel and it is
memory mapped via mmap() ioctl. This model is
also used when the user is using the buffers via
read() or write() system calls.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_MEMORY_USERPTR</span></code></dt><dd><p>The buffers was allocated in userspace and it is
memory mapped via mmap() ioctl.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_MEMORY_DMABUF</span></code></dt><dd><p>The buffers are passed to userspace via DMA buffer.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.vb2_mem_ops">
struct <code class="sig-name descname">vb2_mem_ops</code><a class="headerlink" href="#c.vb2_mem_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>memory handling/memory allocator operations.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vb2_mem_ops {
    void *(*alloc)(struct vb2_buffer *vb,struct device *dev, unsigned long size);
    void (*put)(void *buf_priv);
    struct dma_buf *(*get_dmabuf)(struct vb2_buffer *vb,void *buf_priv, unsigned long flags);
    void *(*get_userptr)(struct vb2_buffer *vb,struct device *dev,unsigned long vaddr, unsigned long size);
    void (*put_userptr)(void *buf_priv);
    void (*prepare)(void *buf_priv);
    void (*finish)(void *buf_priv);
    void *(*attach_dmabuf)(struct vb2_buffer *vb,struct device *dev,struct dma_buf *dbuf, unsigned long size);
    void (*detach_dmabuf)(void *buf_priv);
    int (*map_dmabuf)(void *buf_priv);
    void (*unmap_dmabuf)(void *buf_priv);
    void *(*vaddr)(struct vb2_buffer *vb, void *buf_priv);
    void *(*cookie)(struct vb2_buffer *vb, void *buf_priv);
    unsigned int    (*num_users)(void *buf_priv);
    int (*mmap)(void *buf_priv, struct vm_area_struct *vma);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">alloc</span></code></dt><dd><p>allocate video memory and, optionally, allocator private data,
return ERR_PTR() on failure or a pointer to allocator private,
per-buffer data on success; the returned private structure
will then be passed as <strong>buf_priv</strong> argument to other ops in this
structure. The size argument to this function shall be
<em>page aligned</em>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">put</span></code></dt><dd><p>inform the allocator that the buffer will no longer be used;
usually will result in the allocator freeing the buffer (if
no other users of this buffer are present); the <strong>buf_priv</strong>
argument is the allocator private per-buffer structure
previously returned from the alloc callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_dmabuf</span></code></dt><dd><p>acquire userspace memory for a hardware operation; used for
DMABUF memory types.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_userptr</span></code></dt><dd><p>acquire userspace memory for a hardware operation; used for
USERPTR memory types; vaddr is the address passed to the
videobuf2 layer when queuing a video buffer of USERPTR type;
should return an allocator private per-buffer structure
associated with the buffer on success, ERR_PTR() on failure;
the returned private structure will then be passed as <strong>buf_priv</strong>
argument to other ops in this structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">put_userptr</span></code></dt><dd><p>inform the allocator that a USERPTR buffer will no longer
be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare</span></code></dt><dd><p>called every time the buffer is passed from userspace to the
driver, useful for cache synchronisation, optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">finish</span></code></dt><dd><p>called every time the buffer is passed back from the driver
to the userspace, also optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">attach_dmabuf</span></code></dt><dd><p>attach a shared <a class="reference internal" href="../dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a> for a hardware operation;
used for DMABUF memory types; dev is the alloc device
dbuf is the shared dma_buf; returns ERR_PTR() on failure;
allocator private per-buffer structure on success;
this needs to be used for further accesses to the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach_dmabuf</span></code></dt><dd><p>inform the exporter of the buffer that the current DMABUF
buffer is no longer used; the <strong>buf_priv</strong> argument is the
allocator private per-buffer structure previously returned
from the attach_dmabuf callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map_dmabuf</span></code></dt><dd><p>request for access to the dmabuf from allocator; the allocator
of dmabuf is informed that this driver is going to use the
dmabuf.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unmap_dmabuf</span></code></dt><dd><p>releases access control to the dmabuf - allocator is notified
that this driver is done using the dmabuf for now.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vaddr</span></code></dt><dd><p>return a kernel virtual address to a given memory buffer
associated with the passed private structure or NULL if no
such mapping exists.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cookie</span></code></dt><dd><p>return allocator specific cookie for a given memory buffer
associated with the passed private structure or NULL if not
available.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_users</span></code></dt><dd><p>return the current number of users of a memory buffer;
return 1 if the videobuf2 layer (or actually the driver using
it) is the only user.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap</span></code></dt><dd><p>setup a userspace mapping for a given memory buffer under
the provided virtual memory region.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Those operations are used by the videobuf2 core to implement the memory
handling/memory allocators for each type of supported streaming I/O method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Required ops for USERPTR types: get_userptr, put_userptr.</p></li>
<li><p>Required ops for MMAP types: alloc, put, num_users, mmap.</p></li>
<li><p>Required ops for read/write access types: alloc, put, num_users, vaddr.</p></li>
<li><p>Required ops for DMABUF types: attach_dmabuf, detach_dmabuf,
map_dmabuf, unmap_dmabuf.</p></li>
</ol>
</div>
<dl class="type">
<dt id="c.vb2_plane">
struct <code class="sig-name descname">vb2_plane</code><a class="headerlink" href="#c.vb2_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>plane information.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vb2_plane {
    void *mem_priv;
    struct dma_buf          *dbuf;
    unsigned int            dbuf_mapped;
    unsigned int            bytesused;
    unsigned int            length;
    unsigned int            min_length;
    union {
        unsigned int    offset;
        unsigned long   userptr;
        int fd;
    } m;
    unsigned int            data_offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mem_priv</span></code></dt><dd><p>private data with this plane.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dbuf</span></code></dt><dd><p>dma_buf - shared buffer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dbuf_mapped</span></code></dt><dd><p>flag to show whether dbuf is mapped or not</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bytesused</span></code></dt><dd><p>number of bytes occupied by data in the plane (payload).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>size of this plane (NOT the payload) in bytes. The maximum
valid size is MAX_UINT - PAGE_SIZE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_length</span></code></dt><dd><p>minimum required size of this plane (NOT the payload) in bytes.
<strong>length</strong> is always greater or equal to <strong>min_length</strong>, and like
<strong>length</strong>, it is limited to MAX_UINT - PAGE_SIZE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">m</span></code></dt><dd><p>Union with memtype-specific data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">m.offset</span></code></dt><dd><p>when memory in the associated <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> is
<code class="docutils literal notranslate"><span class="pre">VB2_MEMORY_MMAP</span></code>, equals the offset from the start of
the device memory for this plane (or is a “cookie” that
should be passed to mmap() called on the video node).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">m.userptr</span></code></dt><dd><p>when memory is <code class="docutils literal notranslate"><span class="pre">VB2_MEMORY_USERPTR</span></code>, a userspace pointer
pointing to this plane.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">m.fd</span></code></dt><dd><p>when memory is <code class="docutils literal notranslate"><span class="pre">VB2_MEMORY_DMABUF</span></code>, a userspace file
descriptor associated with this plane.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_offset</span></code></dt><dd><p>offset in the plane to the start of data; usually 0,
unless there is a header in front of the data.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Should contain enough information to be able to cover all the fields
of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_plane</span></code> at videodev2.h.</p>
<dl class="type">
<dt id="c.vb2_io_modes">
enum <code class="sig-name descname">vb2_io_modes</code><a class="headerlink" href="#c.vb2_io_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>queue access methods.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">VB2_MMAP</span></code></dt><dd><p>driver supports MMAP with streaming API.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_USERPTR</span></code></dt><dd><p>driver supports USERPTR with streaming API.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_READ</span></code></dt><dd><p>driver supports read() style access.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_WRITE</span></code></dt><dd><p>driver supports write() style access.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_DMABUF</span></code></dt><dd><p>driver supports DMABUF with streaming API.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.vb2_buffer_state">
enum <code class="sig-name descname">vb2_buffer_state</code><a class="headerlink" href="#c.vb2_buffer_state" title="Permalink to this definition">¶</a></dt>
<dd><p>current video buffer state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_DEQUEUED</span></code></dt><dd><p>buffer under userspace control.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_IN_REQUEST</span></code></dt><dd><p>buffer is queued in media request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_PREPARING</span></code></dt><dd><p>buffer is being prepared in videobuf2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_QUEUED</span></code></dt><dd><p>buffer queued in videobuf2, but not in driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_ACTIVE</span></code></dt><dd><p>buffer queued in driver and possibly used
in a hardware operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_DONE</span></code></dt><dd><p>buffer returned from driver to videobuf2, but
not yet dequeued to userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_ERROR</span></code></dt><dd><p>same as above, but the operation on the buffer
has ended with an error, which will be reported
to the userspace when it is dequeued.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.vb2_buffer">
struct <code class="sig-name descname">vb2_buffer</code><a class="headerlink" href="#c.vb2_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a video buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vb2_buffer {
    struct vb2_queue        *vb2_queue;
    unsigned int            index;
    unsigned int            type;
    unsigned int            memory;
    unsigned int            num_planes;
    u64 timestamp;
    struct media_request    *request;
    struct media_request_object     req_obj;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vb2_queue</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with the queue to
which this driver belongs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>id number of the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>buffer type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">memory</span></code></dt><dd><p>the method, in which the actual data is passed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_planes</span></code></dt><dd><p>number of planes in the buffer
on an internal driver queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timestamp</span></code></dt><dd><p>frame timestamp in ns.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request</span></code></dt><dd><p>the request this buffer is associated with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">req_obj</span></code></dt><dd><p>used to bind this buffer to a request. This
request object has a refcount.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.vb2_ops">
struct <code class="sig-name descname">vb2_ops</code><a class="headerlink" href="#c.vb2_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>driver-specific callbacks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vb2_ops {
    int (*queue_setup)(struct vb2_queue *q,unsigned int *num_buffers, unsigned int *num_planes, unsigned int sizes[], struct device *alloc_devs[]);
    void (*wait_prepare)(struct vb2_queue *q);
    void (*wait_finish)(struct vb2_queue *q);
    int (*buf_out_validate)(struct vb2_buffer *vb);
    int (*buf_init)(struct vb2_buffer *vb);
    int (*buf_prepare)(struct vb2_buffer *vb);
    void (*buf_finish)(struct vb2_buffer *vb);
    void (*buf_cleanup)(struct vb2_buffer *vb);
    int (*prepare_streaming)(struct vb2_queue *q);
    int (*start_streaming)(struct vb2_queue *q, unsigned int count);
    void (*stop_streaming)(struct vb2_queue *q);
    void (*unprepare_streaming)(struct vb2_queue *q);
    void (*buf_queue)(struct vb2_buffer *vb);
    void (*buf_request_complete)(struct vb2_buffer *vb);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">queue_setup</span></code></dt><dd><p>called from VIDIOC_REQBUFS() and VIDIOC_CREATE_BUFS()
handlers before memory allocation. It can be called
twice: if the original number of requested buffers
could not be allocated, then it will be called a
second time with the actually allocated number of
buffers to verify if that is OK.
The driver should return the required number of buffers
in *num_buffers, the required number of planes per
buffer in *num_planes, the size of each plane should be
set in the sizes[] array and optional per-plane
allocator specific device in the alloc_devs[] array.
When called from VIDIOC_REQBUFS(), *num_planes == 0,
the driver has to use the currently configured format to
determine the plane sizes and *num_buffers is the total
number of buffers that are being allocated. When called
from VIDIOC_CREATE_BUFS(), *num_planes != 0 and it
describes the requested number of planes and sizes[]
contains the requested plane sizes. In this case
*num_buffers are being allocated additionally to
q-&gt;num_buffers. If either *num_planes or the requested
sizes are invalid callback must return <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_prepare</span></code></dt><dd><p>release any locks taken while calling vb2 functions;
it is called before an ioctl needs to wait for a new
buffer to arrive; required to avoid a deadlock in
blocking access type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_finish</span></code></dt><dd><p>reacquire all locks released in the previous callback;
required to continue operation after sleeping while
waiting for a new buffer to arrive.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_out_validate</span></code></dt><dd><p>called when the output buffer is prepared or queued
to a request; drivers can use this to validate
userspace-provided information; this is required only
for OUTPUT queues.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_init</span></code></dt><dd><p>called once after allocating a buffer (in MMAP case)
or after acquiring a new USERPTR buffer; drivers may
perform additional buffer-related initialization;
initialization failure (return != 0) will prevent
queue setup from completing successfully; optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_prepare</span></code></dt><dd><p>called every time the buffer is queued from userspace
and from the VIDIOC_PREPARE_BUF() ioctl; drivers may
perform any initialization required before each
hardware operation in this callback; drivers can
access/modify the buffer here as it is still synced for
the CPU; drivers that support VIDIOC_CREATE_BUFS() must
also validate the buffer size; if an error is returned,
the buffer will not be queued in driver; optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_finish</span></code></dt><dd><p>called before every dequeue of the buffer back to
userspace; the buffer is synced for the CPU, so drivers
can access/modify the buffer contents; drivers may
perform any operations required before userspace
accesses the buffer; optional. The buffer state can be
one of the following: <code class="docutils literal notranslate"><span class="pre">DONE</span></code> and <code class="docutils literal notranslate"><span class="pre">ERROR</span></code> occur while
streaming is in progress, and the <code class="docutils literal notranslate"><span class="pre">PREPARED</span></code> state occurs
when the queue has been canceled and all pending
buffers are being returned to their default <code class="docutils literal notranslate"><span class="pre">DEQUEUED</span></code>
state. Typically you only have to do something if the
state is <code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_DONE</span></code>, since in all other cases
the buffer contents will be ignored anyway.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_cleanup</span></code></dt><dd><p>called once before the buffer is freed; drivers may
perform any additional cleanup; optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prepare_streaming</span></code></dt><dd><p>called once to prepare for ‘streaming’ state; this is
where validation can be done to verify everything is
okay and streaming resources can be claimed. It is
called when the VIDIOC_STREAMON ioctl is called. The
actual streaming starts when <strong>start_streaming</strong> is called.
Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_streaming</span></code></dt><dd><p>called once to enter ‘streaming’ state; the driver may
receive buffers with <strong>buf_queue</strong> callback
before <strong>start_streaming</strong> is called; the driver gets the
number of already queued buffers in count parameter;
driver can return an error if hardware fails, in that
case all buffers that have been already given by
the <strong>buf_queue</strong> callback are to be returned by the driver
by calling <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_buffer_done()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_QUEUED</span></code>.
If you need a minimum number of buffers before you can
start streaming, then set
<a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_queue-&gt;min_buffers_needed</span></code></a>. If that is non-zero
then <strong>start_streaming</strong> won’t be called until at least
that many buffers have been queued up by userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop_streaming</span></code></dt><dd><p>called when ‘streaming’ state must be disabled; driver
should stop any DMA transactions or wait until they
finish and give back all buffers it got from <code class="xref c c-type docutils literal notranslate"><span class="pre">buf_queue</span></code>
callback by calling <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_buffer_done()</span></code></a> with either
<code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_DONE</span></code> or <code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_ERROR</span></code>; may use
<a class="reference internal" href="#c.vb2_wait_for_all_buffers" title="vb2_wait_for_all_buffers"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_wait_for_all_buffers()</span></code></a> function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unprepare_streaming</span></code></dt><dd><p>called as counterpart to <strong>prepare_streaming</strong>; any claimed
streaming resources can be released here. It is
called when the VIDIOC_STREAMOFF ioctls is called or
when the streaming filehandle is closed. Optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_queue</span></code></dt><dd><p>passes buffer vb to the driver; driver may start
hardware operation on this buffer; driver should give
the buffer back by calling <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_buffer_done()</span></code></a> function;
it is always called after calling VIDIOC_STREAMON()
ioctl; might be called before <strong>start_streaming</strong> callback
if user pre-queued buffers before calling
VIDIOC_STREAMON().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_request_complete</span></code></dt><dd><p>a buffer that was never queued to the driver but is
associated with a queued request was canceled.
The driver will have to mark associated objects in the
request as completed; required if requests are
supported.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These operations are not called from interrupt context except where
mentioned specifically.</p>
<dl class="type">
<dt id="c.vb2_buf_ops">
struct <code class="sig-name descname">vb2_buf_ops</code><a class="headerlink" href="#c.vb2_buf_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>driver-specific callbacks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vb2_buf_ops {
    int (*verify_planes_array)(struct vb2_buffer *vb, const void *pb);
    void (*init_buffer)(struct vb2_buffer *vb);
    void (*fill_user_buffer)(struct vb2_buffer *vb, void *pb);
    int (*fill_vb2_buffer)(struct vb2_buffer *vb, struct vb2_plane *planes);
    void (*copy_timestamp)(struct vb2_buffer *vb, const void *pb);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">verify_planes_array</span></code></dt><dd><p>Verify that a given user space structure contains
enough planes for the buffer. This is called
for each dequeued buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_buffer</span></code></dt><dd><p>given a <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_buffer</span></code></a> initialize the extra data after
<a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a>.
For V4L2 this is a <a class="reference internal" href="#c.vb2_v4l2_buffer" title="vb2_v4l2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_v4l2_buffer</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fill_user_buffer</span></code></dt><dd><p>given a <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_buffer</span></code></a> fill in the userspace structure.
For V4L2 this is a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fill_vb2_buffer</span></code></dt><dd><p>given a userspace structure, fill in the <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_buffer</span></code></a>.
If the userspace structure is invalid, then this op
will return an error.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copy_timestamp</span></code></dt><dd><p>copy the timestamp from a userspace structure to
the <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.vb2_queue">
struct <code class="sig-name descname">vb2_queue</code><a class="headerlink" href="#c.vb2_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>a videobuf2 queue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vb2_queue {
    unsigned int                    type;
    unsigned int                    io_modes;
    struct device                   *dev;
    unsigned long                   dma_attrs;
    unsigned int                    bidirectional:1;
    unsigned int                    fileio_read_once:1;
    unsigned int                    fileio_write_immediately:1;
    unsigned int                    allow_zero_bytesused:1;
    unsigned int               quirk_poll_must_check_waiting_for_buffers:1;
    unsigned int                    supports_requests:1;
    unsigned int                    requires_requests:1;
    unsigned int                    uses_qbuf:1;
    unsigned int                    uses_requests:1;
    unsigned int                    allow_cache_hints:1;
    unsigned int                    non_coherent_mem:1;
    struct mutex                    *lock;
    void *owner;
    const struct vb2_ops            *ops;
    const struct vb2_mem_ops        *mem_ops;
    const struct vb2_buf_ops        *buf_ops;
    void *drv_priv;
    u32 subsystem_flags;
    unsigned int                    buf_struct_size;
    u32 timestamp_flags;
    gfp_t gfp_flags;
    u32 min_buffers_needed;
    struct device                   *alloc_devs[VB2_MAX_PLANES];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>private buffer type whose content is defined by the vb2-core
caller. For example, for V4L2, it should match
the types defined on <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">io_modes</span></code></dt><dd><p>supported io methods (see <a class="reference internal" href="#c.vb2_io_modes" title="vb2_io_modes"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vb2_io_modes</span></code></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device to use for the default allocation context if the driver
doesn’t fill in the <strong>alloc_devs</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_attrs</span></code></dt><dd><p>DMA attributes to use for the DMA.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bidirectional</span></code></dt><dd><p>when this flag is set the DMA direction for the buffers of
this queue will be overridden with <code class="docutils literal notranslate"><span class="pre">DMA_BIDIRECTIONAL</span></code> direction.
This is useful in cases where the hardware (firmware) writes to
a buffer which is mapped as read (<code class="docutils literal notranslate"><span class="pre">DMA_TO_DEVICE</span></code>), or reads from
buffer which is mapped for write (<code class="docutils literal notranslate"><span class="pre">DMA_FROM_DEVICE</span></code>) in order
to satisfy some internal hardware restrictions or adds a padding
needed by the processing algorithm. In case the DMA mapping is
not bidirectional but the hardware (firmware) trying to access
the buffer (in the opposite direction) this could lead to an
IOMMU protection faults.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fileio_read_once</span></code></dt><dd><p>report EOF after reading the first buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fileio_write_immediately</span></code></dt><dd><p>queue buffer after each write() call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allow_zero_bytesused</span></code></dt><dd><p>allow bytesused == 0 to be passed to the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">quirk_poll_must_check_waiting_for_buffers</span></code></dt><dd><p>Return <code class="docutils literal notranslate"><span class="pre">EPOLLERR</span></code> at poll when QBUF
has not been called. This is a vb1 idiom that has been adopted
also by vb2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supports_requests</span></code></dt><dd><p>this queue supports the Request API.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">requires_requests</span></code></dt><dd><p>this queue requires the Request API. If this is set to 1,
then supports_requests must be set to 1 as well.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uses_qbuf</span></code></dt><dd><p>qbuf was used directly for this queue. Set to 1 the first
time this is called. Set to 0 when the queue is canceled.
If this is 1, then you cannot queue buffers from a request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uses_requests</span></code></dt><dd><p>requests are used for this queue. Set to 1 the first time
a request is queued. Set to 0 when the queue is canceled.
If this is 1, then you cannot queue buffers directly.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allow_cache_hints</span></code></dt><dd><p>when set user-space can pass cache management hints in
order to skip cache flush/invalidation on -&gt;prepare() or/and
-&gt;finish().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">non_coherent_mem</span></code></dt><dd><p>when set queue will attempt to allocate buffers using
non-coherent memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>pointer to a mutex that protects the <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a>. The
driver can set this to a mutex to let the v4l2 core serialize
the queuing ioctls. If the driver wants to handle locking
itself, then this should be set to NULL. This lock is not used
by the videobuf2 core API.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>The filehandle that ‘owns’ the buffers, i.e. the filehandle
that called reqbufs, create_buffers or started fileio.
This field is not used by the videobuf2 core API, but it allows
drivers to easily associate an owner filehandle with the queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>driver-specific callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_ops</span></code></dt><dd><p>memory allocator specific callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_ops</span></code></dt><dd><p>callbacks to deliver buffer information.
between user-space and kernel-space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drv_priv</span></code></dt><dd><p>driver private data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subsystem_flags</span></code></dt><dd><p>Flags specific to the subsystem (V4L2/DVB/etc.). Not used
by the vb2 core.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_struct_size</span></code></dt><dd><p>size of the driver-specific buffer structure;
“0” indicates the driver doesn’t want to use a custom buffer
structure type. In that case a subsystem-specific struct
will be used (in the case of V4L2 that is
<code class="docutils literal notranslate"><span class="pre">sizeof(struct</span> <span class="pre">vb2_v4l2_buffer)</span></code>). The first field of the
driver-specific buffer structure must be the subsystem-specific
struct (vb2_v4l2_buffer in the case of V4L2).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timestamp_flags</span></code></dt><dd><p>Timestamp flags; <code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_TIMESTAMP_*</span></code> and
<code class="docutils literal notranslate"><span class="pre">V4L2_BUF_FLAG_TSTAMP_SRC_*</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_flags</span></code></dt><dd><p>additional gfp flags used when allocating the buffers.
Typically this is 0, but it may be e.g. <code class="docutils literal notranslate"><span class="pre">GFP_DMA</span></code> or <code class="docutils literal notranslate"><span class="pre">__GFP_DMA32</span></code>
to force the buffer allocation to a specific memory zone.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_buffers_needed</span></code></dt><dd><p>the minimum number of buffers needed before
<strong>start_streaming</strong> can be called. Used when a DMA engine
cannot be started unless at least this number of buffers
have been queued into the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alloc_devs</span></code></dt><dd><p><a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> memory type/allocator-specific per-plane device</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_queue_allows_cache_hints">
bool <code class="sig-name descname">vb2_queue_allows_cache_hints</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_allows_cache_hints" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the queue allows cache and memory consistency hints.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_plane_vaddr">
void * <code class="sig-name descname">vb2_plane_vaddr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a><em> *vb</em>, unsigned int<em> plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_plane_vaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a kernel virtual address of a given plane.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*vb</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to which the plane in
question belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt><dd><p>plane number for which the address is to be returned.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a kernel virtual address of a given plane if
such a mapping exist, NULL otherwise.</p>
</div>
<dl class="function">
<dt id="c.vb2_plane_cookie">
void * <code class="sig-name descname">vb2_plane_cookie</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a><em> *vb</em>, unsigned int<em> plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_plane_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Return allocator specific cookie for the given plane.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*vb</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to which the plane in
question belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt><dd><p>plane number for which the cookie is to be returned.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns an allocator specific cookie for a given plane if
available, NULL otherwise. The allocator should provide some simple static
inline function, which would convert this cookie to the allocator specific
type that can be used directly by the driver to access the buffer. This can
be for example physical address, pointer to scatter list or IOMMU mapping.</p>
</div>
<dl class="function">
<dt id="c.vb2_buffer_done">
void <code class="sig-name descname">vb2_buffer_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a><em> *vb</em>, enum <a class="reference internal" href="#c.vb2_buffer_state" title="vb2_buffer_state">vb2_buffer_state</a><em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_buffer_done" title="Permalink to this definition">¶</a></dt>
<dd><p>inform videobuf2 that an operation on a buffer is finished.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*vb</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vb2_buffer_state</span> <span class="pre">state</span></code></dt><dd><p>state of the buffer, as defined by <a class="reference internal" href="#c.vb2_buffer_state" title="vb2_buffer_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vb2_buffer_state</span></code></a>.
Either <code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_DONE</span></code> if the operation finished
successfully, <code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_ERROR</span></code> if the operation finished
with an error or <code class="docutils literal notranslate"><span class="pre">VB2_BUF_STATE_QUEUED</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called by the driver after a hardware operation on
a buffer is finished and the buffer may be returned to userspace. The driver
cannot use this buffer anymore until it is queued back to it by videobuf
by the means of <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> callback. Only buffers previously queued
to the driver by <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> can be passed to this function.</p>
<p>While streaming a buffer can only be returned in state DONE or ERROR.
The <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;start_streaming</span></code></a> op can also return them in case the DMA engine
cannot be started for some reason. In that case the buffers should be
returned with state QUEUED to put them back into the queue.</p>
</div>
<dl class="function">
<dt id="c.vb2_discard_done">
void <code class="sig-name descname">vb2_discard_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_discard_done" title="Permalink to this definition">¶</a></dt>
<dd><p>discard all buffers marked as DONE.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is intended to be used with suspend/resume operations. It
discards all ‘done’ buffers as they would be too old to be requested after
resume.</p>
<p>Drivers must stop the hardware and synchronize with interrupt handlers and/or
delayed works before calling this function to make sure no buffer will be
touched by the driver and/or hardware.</p>
</div>
<dl class="function">
<dt id="c.vb2_wait_for_all_buffers">
int <code class="sig-name descname">vb2_wait_for_all_buffers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_wait_for_all_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until all buffers are given back to vb2.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will wait until all buffers that have been given to the driver
by <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> are given back to vb2 with <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_buffer_done()</span></code></a>. It
doesn’t call <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;wait_prepare</span></code></a>/<a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;wait_finish</span></code></a> pair.
It is intended to be called with all locks taken, for example from
<a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;stop_streaming</span></code></a> callback.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_querybuf">
void <code class="sig-name descname">vb2_core_querybuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, unsigned int<em> index</em>, void<em> *pb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_querybuf" title="Permalink to this definition">¶</a></dt>
<dd><p>query video buffer information.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>id number of the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*pb</span></code></dt><dd><p>buffer struct passed from userspace.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement VIDIOC_QUERYBUF() operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal notranslate"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>The passed buffer should have been verified.</p>
<p>This function fills the relevant information for the userspace.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_reqbufs">
int <code class="sig-name descname">vb2_core_reqbufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory">vb2_memory</a><em> memory</em>, unsigned int<em> flags</em>, unsigned int<em> *count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_reqbufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiate streaming.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vb2_memory</span> <span class="pre">memory</span></code></dt><dd><p>memory type, as defined by <a class="reference internal" href="#c.vb2_memory" title="vb2_memory"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vb2_memory</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>auxiliary queue/buffer management flags. Currently, the only
used flag is <code class="docutils literal notranslate"><span class="pre">V4L2_MEMORY_FLAG_NON_COHERENT</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*count</span></code></dt><dd><p>requested buffer count.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement VIDIOC_REQBUF() operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal notranslate"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>This function:</p>
<ol class="arabic simple">
<li><p>verifies streaming parameters passed from the userspace;</p></li>
<li><p>sets up the queue;</p></li>
<li><p>negotiates number of buffers and planes per buffer with the driver
to be used during streaming;</p></li>
<li><p>allocates internal buffer structures (<a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a>), according to
the agreed parameters;</p></li>
<li><p>for MMAP memory type, allocates actual video memory, using the
memory handling/allocation routines provided during queue initialization.</p></li>
</ol>
<p>If req-&gt;count is 0, all the memory will be freed instead.</p>
<p>If the queue has been allocated previously by a previous <a class="reference internal" href="#c.vb2_core_reqbufs" title="vb2_core_reqbufs"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_core_reqbufs()</span></code></a>
call and the queue is not busy, memory will be reallocated.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_create_bufs">
int <code class="sig-name descname">vb2_core_create_bufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory">vb2_memory</a><em> memory</em>, unsigned int<em> flags</em>, unsigned int<em> *count</em>, unsigned int<em> requested_planes</em>, const unsigned int<em> requested_sizes[]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_create_bufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate buffers and any required auxiliary structs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vb2_memory</span> <span class="pre">memory</span></code></dt><dd><p>memory type, as defined by <a class="reference internal" href="#c.vb2_memory" title="vb2_memory"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vb2_memory</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>auxiliary queue/buffer management flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*count</span></code></dt><dd><p>requested buffer count.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">requested_planes</span></code></dt><dd><p>number of planes requested.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">requested_sizes[]</span></code></dt><dd><p>array with the size of the planes.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement VIDIOC_CREATE_BUFS() operation. It is
called internally by VB2 by an API-specific handler, like
<code class="docutils literal notranslate"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>This function:</p>
<ol class="arabic simple">
<li><p>verifies parameter sanity;</p></li>
<li><p>calls the <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;queue_setup</span></code></a> queue operation;</p></li>
<li><p>performs any necessary memory allocations.</p></li>
</ol>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_prepare_buf">
int <code class="sig-name descname">vb2_core_prepare_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, unsigned int<em> index</em>, void<em> *pb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_prepare_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass ownership of a buffer from userspace to the kernel.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>id number of the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*pb</span></code></dt><dd><p>buffer structure passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_prepare_buf</span></code></a> handler in driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement VIDIOC_PREPARE_BUF() operation. It is
called internally by VB2 by an API-specific handler, like
<code class="docutils literal notranslate"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>The passed buffer should have been verified.</p>
<p>This function calls vb2_ops-&gt;buf_prepare callback in the driver
(if provided), in which driver-specific buffer initialization can
be performed.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_qbuf">
int <code class="sig-name descname">vb2_core_qbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, unsigned int<em> index</em>, void<em> *pb</em>, struct <a class="reference internal" href="mc-core.html#c.media_request" title="media_request">media_request</a><em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_qbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a buffer from userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>id number of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*pb</span></code></dt><dd><p>buffer structure passed from userspace to
v4l2_ioctl_ops-&gt;vidioc_qbuf handler in driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span> <span class="pre">*req</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_request" title="media_request"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span></code></a>, may be NULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement VIDIOC_QBUF() operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal notranslate"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>This function:</p>
<ol class="arabic simple">
<li><p>If <strong>req</strong> is non-NULL, then the buffer will be bound to this
media request and it returns. The buffer will be prepared and
queued to the driver (i.e. the next two steps) when the request
itself is queued.</p></li>
<li><p>if necessary, calls <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;buf_prepare</span></code></a> callback in the driver
(if provided), in which driver-specific buffer initialization can
be performed;</p></li>
<li><p>if streaming is on, queues the buffer in driver by the means of
<a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> callback for processing.</p></li>
</ol>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_dqbuf">
int <code class="sig-name descname">vb2_core_dqbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, unsigned int<em> *pindex</em>, void<em> *pb</em>, bool<em> nonblocking</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_dqbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Dequeue a buffer to the userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*pindex</span></code></dt><dd><p>pointer to the buffer index. May be NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*pb</span></code></dt><dd><p>buffer structure passed from userspace to
v4l2_ioctl_ops-&gt;vidioc_dqbuf handler in driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">nonblocking</span></code></dt><dd><p>if true, this call will not sleep waiting for a buffer if no
buffers ready for dequeuing are present. Normally the driver
would be passing (file-&gt;f_flags &amp; O_NONBLOCK) here.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement VIDIOC_DQBUF() operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal notranslate"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>This function:</p>
<ol class="arabic simple">
<li><p>calls buf_finish callback in the driver (if provided), in which
driver can perform any additional operations that may be required before
returning the buffer to userspace, such as cache sync,</p></li>
<li><p>the buffer struct members are filled with relevant information for
the userspace.</p></li>
</ol>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_streamon">
int <code class="sig-name descname">vb2_core_streamon</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, unsigned int<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_streamon" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements VB2 stream ON logic</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>type of the queue to be started.
For V4L2, this is defined by <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span></code> type.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement VIDIOC_STREAMON() operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal notranslate"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_streamoff">
int <code class="sig-name descname">vb2_core_streamoff</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, unsigned int<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_streamoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements VB2 stream OFF logic</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>type of the queue to be started.
For V4L2, this is defined by <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span></code> type.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement VIDIOC_STREAMOFF() operation. It is
called internally by VB2 by an API-specific handler, like
<code class="docutils literal notranslate"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_expbuf">
int <code class="sig-name descname">vb2_core_expbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, int<em> *fd</em>, unsigned int<em> type</em>, unsigned int<em> index</em>, unsigned int<em> plane</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_expbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a buffer as a file descriptor.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*fd</span></code></dt><dd><p>pointer to the file descriptor associated with DMABUF
(set by driver).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>buffer type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>id number of the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane</span></code></dt><dd><p>index of the plane to be exported, 0 for single plane queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>file flags for newly created file, as defined at
include/uapi/asm-generic/fcntl.h.
Currently, the only used flag is <code class="docutils literal notranslate"><span class="pre">O_CLOEXEC</span></code>.
is supported, refer to manual of open syscall for more details.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement VIDIOC_EXPBUF() operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal notranslate"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_queue_init">
int <code class="sig-name descname">vb2_core_queue_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_queue_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a videobuf2 queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.
This structure should be allocated in driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_queue</span></code></a> structure should be allocated by the driver. The driver is
responsible of clearing it’s content and setting initial values for some
required entries before calling this function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following fields at <strong>q</strong> should be set before calling this function:
<a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_queue-&gt;ops</span></code></a>, <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_queue-&gt;mem_ops</span></code></a>, <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_queue-&gt;type</span></code></a>.</p>
</div>
</div>
<dl class="function">
<dt id="c.vb2_core_queue_release">
void <code class="sig-name descname">vb2_core_queue_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_queue_release" title="Permalink to this definition">¶</a></dt>
<dd><p>stop streaming, release the queue and free memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function stops streaming and performs necessary clean ups, including
freeing video buffer memory. The driver is responsible for freeing
the <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> itself.</p>
</div>
<dl class="function">
<dt id="c.vb2_queue_error">
void <code class="sig-name descname">vb2_queue_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_error" title="Permalink to this definition">¶</a></dt>
<dd><p>signal a fatal error on the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flag that a fatal unrecoverable error has occurred and wake up all processes
waiting on the queue. Polling will now set <code class="docutils literal notranslate"><span class="pre">EPOLLERR</span></code> and queuing and dequeuing
buffers will return <code class="docutils literal notranslate"><span class="pre">-EIO</span></code>.</p>
<p>The error flag will be cleared when canceling the queue, either from
<a class="reference internal" href="#c.vb2_streamoff" title="vb2_streamoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_streamoff()</span></code></a> or <a class="reference internal" href="#c.vb2_queue_release" title="vb2_queue_release"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_queue_release()</span></code></a>. Drivers should thus not call this
function before starting the stream, otherwise the error flag will remain set
until the queue is released when closing the device node.</p>
</div>
<dl class="function">
<dt id="c.vb2_mmap">
int <code class="sig-name descname">vb2_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, struct vm_area_struct<em> *vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>map video buffers into application address space.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*vma</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code> with the vma passed
to the mmap file operation handler in the driver.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from mmap file operation handler of a driver.
This function maps one plane of one of the available video buffers to
userspace. To map whole video memory allocated on reqbufs, this function
has to be called once per each plane per each buffer previously allocated.</p>
<p>When the userspace application calls mmap, it passes to it an offset returned
to it earlier by the means of <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_querybuf</span></code></a> handler.
That offset acts as a “cookie”, which is then used to identify the plane
to be mapped.</p>
<p>This function finds a plane with a matching offset and a mapping is performed
by the means of a provided memory operation.</p>
<p>The return values from this function are intended to be directly returned
from the mmap handler in driver.</p>
</div>
<dl class="function">
<dt id="c.vb2_get_unmapped_area">
unsigned long <code class="sig-name descname">vb2_get_unmapped_area</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, unsigned long<em> addr</em>, unsigned long<em> len</em>, unsigned long<em> pgoff</em>, unsigned long<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_get_unmapped_area" title="Permalink to this definition">¶</a></dt>
<dd><p>map video buffers into application address space.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>memory address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">len</span></code></dt><dd><p>buffer size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt><dd><p>page offset.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>memory flags.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used in noMMU platforms to propose address mapping
for a given buffer. It’s intended to be used as a handler for the
<code class="xref c c-type docutils literal notranslate"><span class="pre">file_operations-&gt;get_unmapped_area</span></code> operation.</p>
<p>This is called by the mmap() syscall routines will call this
to get a proposed address for the mapping, when <code class="docutils literal notranslate"><span class="pre">!CONFIG_MMU</span></code>.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_poll">
__poll_t <code class="sig-name descname">vb2_core_poll</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, struct file<em> *file</em>, poll_table<em> *wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>implements poll syscall() logic.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code> argument passed to the poll
file operation handler.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*wait</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">poll_table</span></code> wait argument passed to the poll
file operation handler.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements poll file operation handler for a driver.
For CAPTURE queues, if a buffer is ready to be dequeued, the userspace will
be informed that the file descriptor of a video device is available for
reading.
For OUTPUT queues, if a buffer is ready to be dequeued, the file descriptor
will be reported as available for writing.</p>
<p>The return values from this function are intended to be directly returned
from poll handler in driver.</p>
</div>
<dl class="function">
<dt id="c.vb2_read">
size_t <code class="sig-name descname">vb2_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, char __user<em> *data</em>, size_t<em> count</em>, loff_t<em> *ppos</em>, int<em> nonblock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_read" title="Permalink to this definition">¶</a></dt>
<dd><p>implements read() syscall logic.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*data</span></code></dt><dd><p>pointed to target userspace buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file handle position tracking pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nonblock</span></code></dt><dd><p>mode selector (1 means blocking calls, 0 means nonblocking)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_write">
size_t <code class="sig-name descname">vb2_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, const char __user<em> *data</em>, size_t<em> count</em>, loff_t<em> *ppos</em>, int<em> nonblock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_write" title="Permalink to this definition">¶</a></dt>
<dd><p>implements write() syscall logic.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*data</span></code></dt><dd><p>pointed to target userspace buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loff_t</span> <span class="pre">*ppos</span></code></dt><dd><p>file handle position tracking pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nonblock</span></code></dt><dd><p>mode selector (1 means blocking calls, 0 means nonblocking)</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.vb2_thread_fnc">
<code class="sig-name descname">vb2_thread_fnc</code><a class="headerlink" href="#c.vb2_thread_fnc" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Typedef</strong>: callback function for use with vb2_thread.</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">vb2_thread_fnc</span> <span class="pre">(struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*vb,</span> <span class="pre">void</span> <span class="pre">*priv)</span></code></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*vb</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_buffer</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>pointer to a private data.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called whenever a buffer is dequeued in the thread.</p>
</div>
<dl class="function">
<dt id="c.vb2_thread_start">
int <code class="sig-name descname">vb2_thread_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, <a class="reference internal" href="#c.vb2_thread_fnc" title="vb2_thread_fnc">vb2_thread_fnc</a><em> fnc</em>, void<em> *priv</em>, const char<em> *thread_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_thread_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start a thread for the given queue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vb2_thread_fnc</span> <span class="pre">fnc</span></code></dt><dd><p><a class="reference internal" href="#c.vb2_thread_fnc" title="vb2_thread_fnc"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_thread_fnc</span></code></a> callback function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*priv</span></code></dt><dd><p>priv pointer passed to the callback function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*thread_name</span></code></dt><dd><p>the name of the thread. This will be prefixed with “vb2-“.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This starts a thread that will queue and dequeue until an error occurs
or <a class="reference internal" href="#c.vb2_thread_stop" title="vb2_thread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_thread_stop()</span></code></a> is called.</p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>This function should not be used for anything else but the videobuf2-dvb
support. If you think you have another good use-case for this, then please
contact the linux-media mailing list first.</p>
</div>
</div>
<dl class="function">
<dt id="c.vb2_thread_stop">
int <code class="sig-name descname">vb2_thread_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_thread_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the thread for the given queue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_is_streaming">
bool <code class="sig-name descname">vb2_is_streaming</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_is_streaming" title="Permalink to this definition">¶</a></dt>
<dd><p>return streaming status of the queue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_fileio_is_active">
bool <code class="sig-name descname">vb2_fileio_is_active</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_fileio_is_active" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if fileio is active.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns true if read() or write() is used to stream the data
as opposed to stream I/O. This is almost never an important distinction,
except in rare cases. One such case is that using read() or write() to
stream a format using <code class="docutils literal notranslate"><span class="pre">V4L2_FIELD_ALTERNATE</span></code> is not allowed since there
is no way you can pass the field information of each buffer to/from
userspace. A driver that supports this field format should check for
this in the <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;queue_setup</span></code></a> op and reject it if this function returns
true.</p>
</div>
<dl class="function">
<dt id="c.vb2_is_busy">
bool <code class="sig-name descname">vb2_is_busy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_is_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>return busy status of the queue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks if queue has any buffers allocated.</p>
</div>
<dl class="function">
<dt id="c.vb2_get_drv_priv">
void * <code class="sig-name descname">vb2_get_drv_priv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_get_drv_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>return driver private data associated with the queue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_set_plane_payload">
void <code class="sig-name descname">vb2_set_plane_payload</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a><em> *vb</em>, unsigned int<em> plane_no</em>, unsigned long<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_set_plane_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>set bytesused for the plane <strong>plane_no</strong>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*vb</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to which the plane in
question belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt><dd><p>plane number for which payload should be set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt><dd><p>payload in bytes.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_get_plane_payload">
unsigned long <code class="sig-name descname">vb2_get_plane_payload</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a><em> *vb</em>, unsigned int<em> plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_get_plane_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>get bytesused for the plane plane_no</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*vb</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to which the plane in
question belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt><dd><p>plane number for which payload should be set.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_plane_size">
unsigned long <code class="sig-name descname">vb2_plane_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a><em> *vb</em>, unsigned int<em> plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_plane_size" title="Permalink to this definition">¶</a></dt>
<dd><p>return plane size in bytes.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*vb</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to which the plane in
question belongs to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt><dd><p>plane number for which size should be returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_start_streaming_called">
bool <code class="sig-name descname">vb2_start_streaming_called</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_start_streaming_called" title="Permalink to this definition">¶</a></dt>
<dd><p>return streaming status of driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_clear_last_buffer_dequeued">
void <code class="sig-name descname">vb2_clear_last_buffer_dequeued</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_clear_last_buffer_dequeued" title="Permalink to this definition">¶</a></dt>
<dd><p>clear last buffer dequeued flag of queue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_get_buffer">
struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> * <code class="sig-name descname">vb2_get_buffer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, unsigned int<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_get_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>get a buffer from a queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p>buffer index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function obtains a buffer from a queue, by its index.
Keep in mind that there is no refcounting involved in this
operation, so the buffer lifetime should be taken into
consideration.</p>
</div>
<dl class="function">
<dt id="c.vb2_buffer_in_use">
bool <code class="sig-name descname">vb2_buffer_in_use</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a><em> *vb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_buffer_in_use" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if the buffer is in use and the queue cannot be freed (by the means of VIDIOC_REQBUFS(0)) call.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*vb</span></code></dt><dd><p>buffer for which plane size should be returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_verify_memory_type">
int <code class="sig-name descname">vb2_verify_memory_type</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory">vb2_memory</a><em> memory</em>, unsigned int<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_verify_memory_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the memory type and buffer type passed to a buffer operation are compatible with the queue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">vb2_memory</span> <span class="pre">memory</span></code></dt><dd><p>memory model, as defined by enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_memory</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>private buffer type whose content is defined by the vb2-core
caller. For example, for V4L2, it should match
the types defined on enum <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_buf_type</span></code>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_request_object_is_buffer">
bool <code class="sig-name descname">vb2_request_object_is_buffer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mc-core.html#c.media_request_object" title="media_request_object">media_request_object</a><em> *obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_request_object_is_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if the object is a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request_object</span> <span class="pre">*obj</span></code></dt><dd><p>the request object.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_request_buffer_cnt">
unsigned int <code class="sig-name descname">vb2_request_buffer_cnt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mc-core.html#c.media_request" title="media_request">media_request</a><em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_request_buffer_cnt" title="Permalink to this definition">¶</a></dt>
<dd><p>return the number of buffers in the request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_request</span> <span class="pre">*req</span></code></dt><dd><p>the request.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.vb2_v4l2_buffer">
struct <code class="sig-name descname">vb2_v4l2_buffer</code><a class="headerlink" href="#c.vb2_v4l2_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>video buffer information for v4l2.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vb2_v4l2_buffer {
    struct vb2_buffer       vb2_buf;
    __u32 flags;
    __u32 field;
    struct v4l2_timecode    timecode;
    __u32 sequence;
    __s32 request_fd;
    bool is_held;
    struct vb2_plane        planes[VB2_MAX_PLANES];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vb2_buf</span></code></dt><dd><p>embedded struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_buffer</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>buffer informational flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">field</span></code></dt><dd><p>field order of the image in the buffer, as defined by
<a class="reference internal" href="../../userspace-api/media/v4l/field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_field</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timecode</span></code></dt><dd><p>frame timecode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sequence</span></code></dt><dd><p>sequence count of this frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request_fd</span></code></dt><dd><p>the request_fd associated with this buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_held</span></code></dt><dd><p>if true, then this capture buffer was held</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">planes</span></code></dt><dd><p>plane information (userptr/fd, length, bytesused, data_offset).</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Should contain enough information to be able to cover all the fields
of <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span></code> at <code class="docutils literal notranslate"><span class="pre">videodev2.h</span></code>.</p>
<dl class="function">
<dt id="c.vb2_find_buffer">
struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> * <code class="sig-name descname">vb2_find_buffer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, u64<em> timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_find_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a buffer with given timestamp</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">timestamp</span></code></dt><dd><p>the timestamp to find.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the buffer with the given <strong>timestamp</strong>, or NULL if not found.</p>
</div>
<dl class="function">
<dt id="c.vb2_reqbufs">
int <code class="sig-name descname">vb2_reqbufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, struct v4l2_requestbuffers<em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_reqbufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#c.vb2_core_reqbufs" title="vb2_core_reqbufs"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_core_reqbufs()</span></code></a> that also verifies the memory and type values.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_requestbuffers</span> <span class="pre">*req</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_requestbuffers</span></code> passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_reqbufs</span></code></a> handler in driver.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_create_bufs">
int <code class="sig-name descname">vb2_create_bufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, struct v4l2_create_buffers<em> *create</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_create_bufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#c.vb2_core_create_bufs" title="vb2_core_create_bufs"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_core_create_bufs()</span></code></a> that also verifies the memory and type values.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_create_buffers</span> <span class="pre">*create</span></code></dt><dd><p>creation parameters, passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_create_bufs</span></code></a> handler in driver</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vb2_prepare_buf">
int <code class="sig-name descname">vb2_prepare_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, struct <a class="reference internal" href="mc-core.html#c.media_device" title="media_device">media_device</a><em> *mdev</em>, struct v4l2_buffer<em> *b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_prepare_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass ownership of a buffer from userspace to the kernel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span></code></a>, may be NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span> <span class="pre">*b</span></code></dt><dd><p>buffer structure passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_prepare_buf</span></code></a> handler in driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_prepare_buf</span></code></a> ioctl handler
of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li><p>verifies the passed buffer,</p></li>
<li><p>calls <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;buf_prepare</span></code></a> callback in the driver (if provided),
in which driver-specific buffer initialization can be performed.</p></li>
<li><p>if <strong>b-&gt;request_fd</strong> is non-zero and <strong>mdev-&gt;ops-&gt;req_queue</strong> is set,
then bind the prepared buffer to the request.</p></li>
</ol>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_prepare_buf</span></code></a> handler in driver.</p>
</div>
<dl class="function">
<dt id="c.vb2_qbuf">
int <code class="sig-name descname">vb2_qbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, struct <a class="reference internal" href="mc-core.html#c.media_device" title="media_device">media_device</a><em> *mdev</em>, struct v4l2_buffer<em> *b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_qbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a buffer from userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*mdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_device" title="media_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_device</span></code></a>, may be NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span> <span class="pre">*b</span></code></dt><dd><p>buffer structure passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_qbuf</span></code></a> handler in driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_qbuf</span></code></a> handler of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li><p>verifies the passed buffer;</p></li>
<li><p>if <strong>b-&gt;request_fd</strong> is non-zero and <strong>mdev-&gt;ops-&gt;req_queue</strong> is set,
then bind the buffer to the request.</p></li>
<li><p>if necessary, calls <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;buf_prepare</span></code></a> callback in the driver
(if provided), in which driver-specific buffer initialization can
be performed;</p></li>
<li><p>if streaming is on, queues the buffer in driver by the means of
<a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> callback for processing.</p></li>
</ol>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_qbuf</span></code></a> handler in driver.</p>
</div>
<dl class="function">
<dt id="c.vb2_expbuf">
int <code class="sig-name descname">vb2_expbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, struct v4l2_exportbuffer<em> *eb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_expbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a buffer as a file descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_exportbuffer</span> <span class="pre">*eb</span></code></dt><dd><p>export buffer structure passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_expbuf</span></code></a> handler in driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_expbuf</span></code></a> handler in driver.</p>
</div>
<dl class="function">
<dt id="c.vb2_dqbuf">
int <code class="sig-name descname">vb2_dqbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, struct v4l2_buffer<em> *b</em>, bool<em> nonblocking</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_dqbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Dequeue a buffer to the userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span> <span class="pre">*b</span></code></dt><dd><p>buffer structure passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_dqbuf</span></code></a> handler in driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">nonblocking</span></code></dt><dd><p>if true, this call will not sleep waiting for a buffer if no
buffers ready for dequeuing are present. Normally the driver
would be passing (<code class="xref c c-type docutils literal notranslate"><span class="pre">file-&gt;f_flags</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">O_NONBLOCK</span></code>) here</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_dqbuf</span></code></a> ioctl handler
of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li><p>verifies the passed buffer;</p></li>
<li><p>calls <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_ops-&gt;buf_finish</span></code></a> callback in the driver (if provided), in which
driver can perform any additional operations that may be required before
returning the buffer to userspace, such as cache sync;</p></li>
<li><p>the buffer struct members are filled with relevant information for
the userspace.</p></li>
</ol>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_dqbuf</span></code></a> handler in driver.</p>
</div>
<dl class="function">
<dt id="c.vb2_streamon">
int <code class="sig-name descname">vb2_streamon</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, enum v4l2_buf_type<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_streamon" title="Permalink to this definition">¶</a></dt>
<dd><p>start streaming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span> <span class="pre">type</span></code></dt><dd><p>type argument passed from userspace to vidioc_streamon handler,
as defined by <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_streamon</span></code></a> handler of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li><p>verifies current state</p></li>
<li><p>passes any previously queued buffers to the driver and starts streaming</p></li>
</ol>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_streamon</span></code></a> handler in the driver.</p>
</div>
<dl class="function">
<dt id="c.vb2_streamoff">
int <code class="sig-name descname">vb2_streamoff</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, enum v4l2_buf_type<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_streamoff" title="Permalink to this definition">¶</a></dt>
<dd><p>stop streaming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span> <span class="pre">type</span></code></dt><dd><p>type argument passed from userspace to vidioc_streamoff handler</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from vidioc_streamoff handler of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li><p>verifies current state,</p></li>
<li><p>stop streaming and dequeues any queued buffers, including those previously
passed to the driver (after waiting for the driver to finish).</p></li>
</ol>
<p>This call can be used for pausing playback.
The return values from this function are intended to be directly returned
from vidioc_streamoff handler in the driver</p>
</div>
<dl class="function">
<dt id="c.vb2_queue_init">
int <code class="sig-name descname">vb2_queue_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a videobuf2 queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vb2_queue structure should be allocated by the driver. The driver is
responsible of clearing it’s content and setting initial values for some
required entries before calling this function.
q-&gt;ops, q-&gt;mem_ops, q-&gt;type and q-&gt;io_modes are mandatory. Please refer
to the <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> description in include/media/videobuf2-core.h
for more information.</p>
</div>
<dl class="function">
<dt id="c.vb2_queue_init_name">
int <code class="sig-name descname">vb2_queue_init_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_init_name" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a videobuf2 queue with a name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the queue name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes the vb2_queue exactly like <a class="reference internal" href="#c.vb2_queue_init" title="vb2_queue_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_queue_init()</span></code></a>,
and additionally sets the queue name. The queue name is used for logging
purpose, and should uniquely identify the queue within the context of the
device it belongs to. This is useful to attribute kernel log messages to the
right queue for m2m devices or other devices that handle multiple queues.</p>
</div>
<dl class="function">
<dt id="c.vb2_queue_release">
void <code class="sig-name descname">vb2_queue_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_release" title="Permalink to this definition">¶</a></dt>
<dd><p>stop streaming, release the queue and free memory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function stops streaming and performs necessary clean ups, including
freeing video buffer memory. The driver is responsible for freeing
the vb2_queue structure itself.</p>
</div>
<dl class="function">
<dt id="c.vb2_queue_change_type">
int <code class="sig-name descname">vb2_queue_change_type</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, unsigned int<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_change_type" title="Permalink to this definition">¶</a></dt>
<dd><p>change the type of an inactive vb2_queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>the type to change to (V4L2_BUF_TYPE_VIDEO_*)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function changes the type of the vb2_queue. This is only possible
if the queue is not busy (i.e. no buffers have been allocated).</p>
<p><a class="reference internal" href="#c.vb2_queue_change_type" title="vb2_queue_change_type"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_queue_change_type()</span></code></a> can be used to support multiple buffer types using
the same queue. The driver can implement v4l2_ioctl_ops.vidioc_reqbufs and
v4l2_ioctl_ops.vidioc_create_bufs functions and call <a class="reference internal" href="#c.vb2_queue_change_type" title="vb2_queue_change_type"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_queue_change_type()</span></code></a>
before calling vb2_ioctl_reqbufs() or vb2_ioctl_create_bufs(), and thus
“lock” the buffer type until the buffers have been released.</p>
</div>
<dl class="function">
<dt id="c.vb2_poll">
__poll_t <code class="sig-name descname">vb2_poll</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, struct file<em> *file</em>, poll_table<em> *wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>implements poll userspace operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file argument passed to the poll file operation handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*wait</span></code></dt><dd><p>wait argument passed to the poll file operation handler</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements poll file operation handler for a driver.
For CAPTURE queues, if a buffer is ready to be dequeued, the userspace will
be informed that the file descriptor of a video device is available for
reading.
For OUTPUT queues, if a buffer is ready to be dequeued, the file descriptor
will be reported as available for writing.</p>
<p>If the driver uses <a class="reference internal" href="v4l2-fh.html#c.v4l2_fh" title="v4l2_fh"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_fh</span></code></a>, then <a class="reference internal" href="#c.vb2_poll" title="vb2_poll"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_poll()</span></code></a> will also check for any
pending events.</p>
<p>The return values from this function are intended to be directly returned
from poll handler in driver.</p>
</div>
<dl class="function">
<dt id="c.vb2_queue_is_busy">
bool <code class="sig-name descname">vb2_queue_is_busy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *q</em>, struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_is_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the queue is busy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*q</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file through which the vb2 queue access is performed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The queue is considered busy if it has an owner and the owner is not the
<strong>file</strong>.</p>
<p>Queue ownership is acquired and checked by some of the v4l2_ioctl_ops helpers
below. Drivers can also use this function directly when they need to
open-code ioctl handlers, for instance to add additional checks between the
queue ownership test and the call to the corresponding vb2 operation.</p>
</div>
<dl class="function">
<dt id="c.vb2_video_unregister_device">
void <code class="sig-name descname">vb2_video_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="v4l2-dev.html#c.video_device" title="video_device">video_device</a><em> *vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_video_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister the video device and release queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span> <span class="pre">*vdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="v4l2-dev.html#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the driver uses vb2_fop_release()/_vb2_fop_release(), then it should use
<a class="reference internal" href="#c.vb2_video_unregister_device" title="vb2_video_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">vb2_video_unregister_device()</span></code></a> instead of <a class="reference internal" href="v4l2-dev.html#c.video_unregister_device" title="video_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_unregister_device()</span></code></a>.</p>
<p>This function will call <a class="reference internal" href="v4l2-dev.html#c.video_unregister_device" title="video_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_unregister_device()</span></code></a> and then release the
vb2_queue if streaming is in progress. This will stop streaming and
this will simplify the unbind sequence since after this call all subdevs
will have stopped streaming as well.</p>
</div>
<dl class="function">
<dt id="c.vb2_ops_wait_prepare">
void <code class="sig-name descname">vb2_ops_wait_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *vq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_ops_wait_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to lock a struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_queue</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*vq</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>..note:: only use if vq-&gt;lock is non-NULL.</p>
</div>
<dl class="function">
<dt id="c.vb2_ops_wait_finish">
void <code class="sig-name descname">vb2_ops_wait_finish</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a><em> *vq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_ops_wait_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to unlock a struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">vb2_queue</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*vq</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>..note:: only use if vq-&gt;lock is non-NULL.</p>
</div>
<dl class="type">
<dt id="c.vb2_vmarea_handler">
struct <code class="sig-name descname">vb2_vmarea_handler</code><a class="headerlink" href="#c.vb2_vmarea_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>common vma refcount tracking handler.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct vb2_vmarea_handler {
    refcount_t *refcount;
    void (*put)(void *arg);
    void *arg;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount</span></code></dt><dd><p>pointer to <a class="reference internal" href="../basics.html#c.refcount_t" title="refcount_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">refcount_t</span></code></a> entry in the buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">put</span></code></dt><dd><p>callback to function that decreases buffer refcount.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">arg</span></code></dt><dd><p>argument for <strong>put</strong> callback.</p>
</dd>
</dl>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/media/v4l2-videobuf2.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/media/v4l2-videobuf2.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>