
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>4. Remote Controller devices &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="5. Media Controller devices" href="mc-core.html" />
    <link rel="prev" title="3.5. Digital TV Network kABI" href="dtv-net.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="remote-controller-devices">
<h1><span class="section-number">4. </span>Remote Controller devices<a class="headerlink" href="#remote-controller-devices" title="Permalink to this headline">¶</a></h1>
<section id="remote-controller-core">
<h2><span class="section-number">4.1. </span>Remote Controller core<a class="headerlink" href="#remote-controller-core" title="Permalink to this headline">¶</a></h2>
<p>The remote controller core implements infrastructure to receive and send
remote controller keyboard keystrokes and mouse events.</p>
<p>Every time a key is pressed on a remote controller, a scan code is produced.
Also, on most hardware, keeping a key pressed for more than a few dozens of
milliseconds produce a repeat key event. That’s somewhat similar to what
a normal keyboard or mouse is handled internally on Linux<a class="footnote-reference brackets" href="#f1" id="id1">1</a>. So, the
remote controller core is implemented on the top of the linux input/evdev
interface.</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>The main difference is that, on keyboard events, the keyboard controller
produces one event for a key press and another one for key release. On
infrared-based remote controllers, there’s no key release event. Instead,
an extra code is produced to indicate key repeats.</p>
</dd>
</dl>
<p>However, most of the remote controllers use infrared (IR) to transmit signals.
As there are several protocols used to modulate infrared signals, one
important part of the core is dedicated to adjust the driver and the core
system to support the infrared protocol used by the emitter.</p>
<p>The infrared transmission is done by blinking a infrared emitter using a
carrier. The carrier can be switched on or off by the IR transmitter
hardware. When the carrier is switched on, it is called <em>PULSE</em>.
When the carrier is switched off, it is called <em>SPACE</em>.</p>
<p>In other words, a typical IR transmission can be viewed as a sequence of
<em>PULSE</em> and <em>SPACE</em> events, each with a given duration.</p>
<p>The carrier parameters (frequency, duty cycle) and the intervals for
<em>PULSE</em> and <em>SPACE</em> events depend on the protocol.
For example, the NEC protocol uses a carrier of 38kHz, and transmissions
start with a 9ms <em>PULSE</em> and a 4.5ms SPACE. It then transmits 16 bits of
scan code, being 8 bits for address (usually it is a fixed number for a
given remote controller), followed by 8 bits of code. A bit “1” is modulated
with 560µs <em>PULSE</em> followed by 1690µs <em>SPACE</em> and a bit “0”  is modulated
with 560µs <em>PULSE</em> followed by 560µs <em>SPACE</em>.</p>
<p>At receiver, a simple low-pass filter can be used to convert the received
signal in a sequence of <em>PULSE/SPACE</em> events, filtering out the carrier
frequency. Due to that, the receiver doesn’t care about the carrier’s
actual frequency parameters: all it has to do is to measure the amount
of time it receives <em>PULSE/SPACE</em> events.
So, a simple IR receiver hardware will just provide a sequence of timings
for those events to the Kernel. The drivers for hardware with such kind of
receivers are identified by  <code class="docutils literal notranslate"><span class="pre">RC_DRIVER_IR_RAW</span></code>, as defined by
<a class="reference internal" href="#c.rc_driver_type" title="rc_driver_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">rc_driver_type</span></code></a><a class="footnote-reference brackets" href="#f2" id="id2">2</a>. Other hardware come with a
microcontroller that decode the <em>PULSE/SPACE</em> sequence and return scan
codes to the Kernel. Such kind of receivers are identified
by <code class="docutils literal notranslate"><span class="pre">RC_DRIVER_SCANCODE</span></code>.</p>
<dl class="footnote brackets">
<dt class="label" id="f2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>The RC core also supports devices that have just IR emitters,
without any receivers. Right now, all such devices work only in
raw TX mode. Such kind of hardware is identified as
<code class="docutils literal notranslate"><span class="pre">RC_DRIVER_IR_RAW_TX</span></code>.</p>
</dd>
</dl>
<p>When the RC core receives events produced by <code class="docutils literal notranslate"><span class="pre">RC_DRIVER_IR_RAW</span></code> IR
receivers, it needs to decode the IR protocol, in order to obtain the
corresponding scan code. The protocols supported by the RC core are
defined at enum <code class="xref c c-type docutils literal notranslate"><span class="pre">rc_proto</span></code>.</p>
<p>When the RC code receives a scan code (either directly, by a driver
of the type <code class="docutils literal notranslate"><span class="pre">RC_DRIVER_SCANCODE</span></code>, or via its IR decoders), it needs
to convert into a Linux input event code. This is done via a mapping
table.</p>
<p>The Kernel has support for mapping tables available on most media
devices. It also supports loading a table in runtime, via some
sysfs nodes. See the <a class="reference internal" href="../../userspace-api/media/rc/rc-intro.html#remote-controllers-intro"><span class="std std-ref">RC userspace API</span></a>
for more details.</p>
<section id="remote-controller-data-structures-and-functions">
<h3><span class="section-number">4.1.1. </span>Remote controller data structures and functions<a class="headerlink" href="#remote-controller-data-structures-and-functions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.rc_driver_type">
enum <code class="sig-name descname">rc_driver_type</code><a class="headerlink" href="#c.rc_driver_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of the RC driver.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">RC_DRIVER_SCANCODE</span></code></dt><dd><p>Driver or hardware generates a scancode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_DRIVER_IR_RAW</span></code></dt><dd><p>Driver or hardware generates pulse/space sequences.
It needs a Infra-Red pulse/space decoder</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_DRIVER_IR_RAW_TX</span></code></dt><dd><p>Device transmitter only,
driver requires pulse/space data sequence.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.rc_scancode_filter">
struct <code class="sig-name descname">rc_scancode_filter</code><a class="headerlink" href="#c.rc_scancode_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter scan codes.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rc_scancode_filter {
    u32 data;
    u32 mask;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Scancode data to match.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>Mask of bits of scancode to compare.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.rc_filter_type">
enum <code class="sig-name descname">rc_filter_type</code><a class="headerlink" href="#c.rc_filter_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter type constants.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">RC_FILTER_NORMAL</span></code></dt><dd><p>Filter for normal operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_FILTER_WAKEUP</span></code></dt><dd><p>Filter for waking from suspend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RC_FILTER_MAX</span></code></dt><dd><p>Number of filter types.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.lirc_fh">
struct <code class="sig-name descname">lirc_fh</code><a class="headerlink" href="#c.lirc_fh" title="Permalink to this definition">¶</a></dt>
<dd><p>represents an open lirc file</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct lirc_fh {
    struct list_head list;
    struct rc_dev *rc;
    int carrier_low;
    unsigned int *rawir;
    struct lirc_scancode *scancodes;
    wait_queue_head_t wait_poll;
    u8 send_mode;
    u8 rec_mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>list of open file handles</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc</span></code></dt><dd><p>rcdev for this lirc chardev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">carrier_low</span></code></dt><dd><p>when setting the carrier range, first the low end must be
set with an ioctl and then the high end with another ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rawir</span></code></dt><dd><p>queue for incoming raw IR</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scancodes</span></code></dt><dd><p>queue for incoming decoded scancodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_poll</span></code></dt><dd><p>poll struct for lirc device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_mode</span></code></dt><dd><p>lirc mode for sending, either LIRC_MODE_SCANCODE or
LIRC_MODE_PULSE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rec_mode</span></code></dt><dd><p>lirc mode for receiving, either LIRC_MODE_SCANCODE or
LIRC_MODE_MODE2</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.rc_dev">
struct <code class="sig-name descname">rc_dev</code><a class="headerlink" href="#c.rc_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a remote control device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rc_dev {
    struct device                   dev;
    bool managed_alloc;
    const struct attribute_group    *sysfs_groups[5];
    const char                      *device_name;
    const char                      *input_phys;
    struct input_id                 input_id;
    const char                      *driver_name;
    const char                      *map_name;
    struct rc_map                   rc_map;
    struct mutex                    lock;
    unsigned int                    minor;
    struct ir_raw_event_ctrl        *raw;
    struct input_dev                *input_dev;
    enum rc_driver_type             driver_type;
    bool idle;
    bool encode_wakeup;
    u64 allowed_protocols;
    u64 enabled_protocols;
    u64 allowed_wakeup_protocols;
    enum rc_proto                   wakeup_protocol;
    struct rc_scancode_filter       scancode_filter;
    struct rc_scancode_filter       scancode_wakeup_filter;
    u32 scancode_mask;
    u32 users;
    void *priv;
    spinlock_t keylock;
    bool keypressed;
    unsigned long                   keyup_jiffies;
    struct timer_list               timer_keyup;
    struct timer_list               timer_repeat;
    u32 last_keycode;
    enum rc_proto                   last_protocol;
    u64 last_scancode;
    u8 last_toggle;
    u32 timeout;
    u32 min_timeout;
    u32 max_timeout;
    u32 rx_resolution;
    u32 tx_resolution;
#ifdef CONFIG_LIRC;
    struct device                   lirc_dev;
    struct cdev                     lirc_cdev;
    ktime_t gap_start;
    spinlock_t lirc_fh_lock;
    struct list_head                lirc_fh;
#endif;
    bool registered;
    int (*change_protocol)(struct rc_dev *dev, u64 *rc_proto);
    int (*open)(struct rc_dev *dev);
    void (*close)(struct rc_dev *dev);
    int (*s_tx_mask)(struct rc_dev *dev, u32 mask);
    int (*s_tx_carrier)(struct rc_dev *dev, u32 carrier);
    int (*s_tx_duty_cycle)(struct rc_dev *dev, u32 duty_cycle);
    int (*s_rx_carrier_range)(struct rc_dev *dev, u32 min, u32 max);
    int (*tx_ir)(struct rc_dev *dev, unsigned *txbuf, unsigned n);
    void (*s_idle)(struct rc_dev *dev, bool enable);
    int (*s_wideband_receiver)(struct rc_dev *dev, int enable);
    int (*s_carrier_report) (struct rc_dev *dev, int enable);
    int (*s_filter)(struct rc_dev *dev, struct rc_scancode_filter *filter);
    int (*s_wakeup_filter)(struct rc_dev *dev, struct rc_scancode_filter *filter);
    int (*s_timeout)(struct rc_dev *dev, unsigned int timeout);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>driver model’s view of this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">managed_alloc</span></code></dt><dd><p>devm_rc_allocate_device was used to create rc_dev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs_groups</span></code></dt><dd><p>sysfs attribute groups</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_name</span></code></dt><dd><p>name of the rc child device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input_phys</span></code></dt><dd><p>physical path to the input child device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input_id</span></code></dt><dd><p>id of the input child device (struct input_id)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_name</span></code></dt><dd><p>name of the hardware driver which registered this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map_name</span></code></dt><dd><p>name of the default keymap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_map</span></code></dt><dd><p>current scan/key table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>used to ensure we’ve filled in all protocol details before
anyone can call show_protocols or store_protocols</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor</span></code></dt><dd><p>unique minor remote control device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">raw</span></code></dt><dd><p>additional data for raw pulse/space devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input_dev</span></code></dt><dd><p>the input child device used to communicate events to userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_type</span></code></dt><dd><p>specifies if protocol decoding is done in hardware or software</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idle</span></code></dt><dd><p>used to keep track of RX state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encode_wakeup</span></code></dt><dd><p>wakeup filtering uses IR encode API, therefore the allowed
wakeup protocols is the set of all raw encoders</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allowed_protocols</span></code></dt><dd><p>bitmask with the supported RC_PROTO_BIT_* protocols</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled_protocols</span></code></dt><dd><p>bitmask with the enabled RC_PROTO_BIT_* protocols</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allowed_wakeup_protocols</span></code></dt><dd><p>bitmask with the supported RC_PROTO_BIT_* wakeup
protocols</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wakeup_protocol</span></code></dt><dd><p>the enabled RC_PROTO_* wakeup protocol or
RC_PROTO_UNKNOWN if disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scancode_filter</span></code></dt><dd><p>scancode filter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scancode_wakeup_filter</span></code></dt><dd><p>scancode wakeup filters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scancode_mask</span></code></dt><dd><p>some hardware decoders are not capable of providing the full
scancode to the application. As this is a hardware limit, we can’t do
anything with it. Yet, as the same keycode table can be used with other
devices, a mask is provided to allow its usage. Drivers should generally
leave this field in blank</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">users</span></code></dt><dd><p>number of current users of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>driver-specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keylock</span></code></dt><dd><p>protects the remaining members of the struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keypressed</span></code></dt><dd><p>whether a key is currently pressed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keyup_jiffies</span></code></dt><dd><p>time (in jiffies) when the current keypress should be released</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer_keyup</span></code></dt><dd><p>timer for releasing a keypress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer_repeat</span></code></dt><dd><p>timer for autorepeat events. This is needed for CEC, which
has non-standard repeats.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_keycode</span></code></dt><dd><p>keycode of last keypress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_protocol</span></code></dt><dd><p>protocol of last keypress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_scancode</span></code></dt><dd><p>scancode of last keypress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_toggle</span></code></dt><dd><p>toggle value of last command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>optional time after which device stops sending data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_timeout</span></code></dt><dd><p>minimum timeout supported by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_timeout</span></code></dt><dd><p>maximum timeout supported by device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_resolution</span></code></dt><dd><p>resolution (in us) of input sampler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_resolution</span></code></dt><dd><p>resolution (in us) of output sampler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lirc_dev</span></code></dt><dd><p>lirc device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lirc_cdev</span></code></dt><dd><p>lirc char cdev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gap_start</span></code></dt><dd><p>start time for gap after timeout if non-zero</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lirc_fh_lock</span></code></dt><dd><p>protects lirc_fh list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lirc_fh</span></code></dt><dd><p>list of open files</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">registered</span></code></dt><dd><p>set to true by <a class="reference internal" href="#c.rc_register_device" title="rc_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">rc_register_device()</span></code></a>, false by
rc_unregister_device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">change_protocol</span></code></dt><dd><p>allow changing the protocol used on hardware decoders</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>callback to allow drivers to enable polling/irq when IR input device
is opened.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">close</span></code></dt><dd><p>callback to allow drivers to disable polling/irq when IR input device
is opened.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_tx_mask</span></code></dt><dd><p>set transmitter mask (for devices with multiple tx outputs)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_tx_carrier</span></code></dt><dd><p>set transmit carrier frequency</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_tx_duty_cycle</span></code></dt><dd><p>set transmit duty cycle (0% - 100%)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_rx_carrier_range</span></code></dt><dd><p>inform driver about carrier it is expected to handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_ir</span></code></dt><dd><p>transmit IR</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_idle</span></code></dt><dd><p>enable/disable hardware idle mode, upon which,
device doesn’t interrupt host until it sees IR pulses</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_wideband_receiver</span></code></dt><dd><p>enable wide band receiver used for learning</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_carrier_report</span></code></dt><dd><p>enable carrier reports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_filter</span></code></dt><dd><p>set the scancode filter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_wakeup_filter</span></code></dt><dd><p>set the wakeup scancode filter. If the mask is zero
then wakeup should be disabled. wakeup_protocol will be set to
a valid protocol if mask is nonzero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_timeout</span></code></dt><dd><p>set hardware timeout in us</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rc_allocate_device">
struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a> * <code class="sig-name descname">rc_allocate_device</code><span class="sig-paren">(</span>enum<em> rc_driver_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_allocate_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates a RC device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rc_driver_type</span></code></dt><dd><p>specifies the type of the RC output to be allocated
returns a pointer to <a class="reference internal" href="#c.rc_dev" title="rc_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.devm_rc_allocate_device">
struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a> * <code class="sig-name descname">devm_rc_allocate_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *dev</em>, enum<em> rc_driver_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_rc_allocate_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed RC device allocation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rc_driver_type</span></code></dt><dd><p>specifies the type of the RC output to be allocated
returns a pointer to <a class="reference internal" href="#c.rc_dev" title="rc_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rc_free_device">
void <code class="sig-name descname">rc_free_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_free_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees a RC device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.rc_dev" title="rc_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rc_register_device">
int <code class="sig-name descname">rc_register_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a RC device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.rc_dev" title="rc_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.devm_rc_register_device">
int <code class="sig-name descname">devm_rc_register_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *parent</em>, struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_rc_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Manageded registering of a RC device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>pointer to <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.rc_dev" title="rc_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rc_unregister_device">
void <code class="sig-name descname">rc_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.rc_dev" title="rc_dev">rc_dev</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters a RC device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.rc_dev" title="rc_dev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_dev</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.rc_map_table">
struct <code class="sig-name descname">rc_map_table</code><a class="headerlink" href="#c.rc_map_table" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a scancode/keycode pair</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rc_map_table {
    u64 scancode;
    u32 keycode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">scancode</span></code></dt><dd><p>scan code (u64)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keycode</span></code></dt><dd><p>Linux input keycode</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.rc_map">
struct <code class="sig-name descname">rc_map</code><a class="headerlink" href="#c.rc_map" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a keycode map table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rc_map {
    struct rc_map_table     *scan;
    unsigned int            size;
    unsigned int            len;
    unsigned int            alloc;
    enum rc_proto           rc_proto;
    const char              *name;
    spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">scan</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.rc_map_table" title="rc_map_table"><code class="xref c c-type docutils literal notranslate"><span class="pre">rc_map_table</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Max number of entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>Number of entries that are in use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alloc</span></code></dt><dd><p>size of *scan, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rc_proto</span></code></dt><dd><p>type of the remote controller protocol, as defined at
enum <code class="xref c c-type docutils literal notranslate"><span class="pre">rc_proto</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the key map table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>lock to protect access to this structure</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.rc_map_list">
struct <code class="sig-name descname">rc_map_list</code><a class="headerlink" href="#c.rc_map_list" title="Permalink to this definition">¶</a></dt>
<dd><p>list of the registered <a class="reference internal" href="#c.rc_map" title="rc_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">rc_map</span></code></a> maps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rc_map_list {
    struct list_head         list;
    struct rc_map map;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>pointer to struct <code class="xref c c-type docutils literal notranslate"><span class="pre">list_head</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.rc_map" title="rc_map"><code class="xref c c-type docutils literal notranslate"><span class="pre">rc_map</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rc_map_register">
int <code class="sig-name descname">rc_map_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.rc_map_list" title="rc_map_list">rc_map_list</a><em> *map</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_map_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a Remote Controller scancode map</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_map_list</span> <span class="pre">*map</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.rc_map_list" title="rc_map_list"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_map_list</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rc_map_unregister">
void <code class="sig-name descname">rc_map_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.rc_map_list" title="rc_map_list">rc_map_list</a><em> *map</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_map_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters a Remote Controller scancode map</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_map_list</span> <span class="pre">*map</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.rc_map_list" title="rc_map_list"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rc_map_list</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rc_map_get">
struct <a class="reference internal" href="#c.rc_map" title="rc_map">rc_map</a> * <code class="sig-name descname">rc_map_get</code><span class="sig-paren">(</span>const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rc_map_get" title="Permalink to this definition">¶</a></dt>
<dd><p>gets an RC map from its name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the RC scancode map</p>
</dd>
</dl>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4. Remote Controller devices</a><ul>
<li><a class="reference internal" href="#remote-controller-core">4.1. Remote Controller core</a><ul>
<li><a class="reference internal" href="#remote-controller-data-structures-and-functions">4.1.1. Remote controller data structures and functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/media/rc-core.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/media/rc-core.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>