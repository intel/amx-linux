
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>2.7. V4L2 sub-devices &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="2.13. V4L2 events" href="v4l2-event.html" />
    <link rel="prev" title="2.6. V4L2 File handlers" href="v4l2-fh.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="v4l2-sub-devices">
<h1><span class="section-number">2.7. </span>V4L2 sub-devices<a class="headerlink" href="#v4l2-sub-devices" title="Permalink to this headline">¶</a></h1>
<p>Many drivers need to communicate with sub-devices. These devices can do all
sort of tasks, but most commonly they handle audio and/or video muxing,
encoding or decoding. For webcams common sub-devices are sensors and camera
controllers.</p>
<p>Usually these are I2C devices, but not necessarily. In order to provide the
driver with a consistent interface to these sub-devices the
<a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> struct (v4l2-subdev.h) was created.</p>
<p>Each sub-device driver must have a <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> struct. This struct
can be stand-alone for simple sub-devices or it might be embedded in a larger
struct if more state information needs to be stored. Usually there is a
low-level device struct (e.g. <code class="docutils literal notranslate"><span class="pre">i2c_client</span></code>) that contains the device data as
setup by the kernel. It is recommended to store that pointer in the private
data of <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> using <a class="reference internal" href="#c.v4l2_set_subdevdata" title="v4l2_set_subdevdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_set_subdevdata()</span></code></a>. That makes
it easy to go from a <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> to the actual low-level bus-specific
device data.</p>
<p>You also need a way to go from the low-level struct to <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a>.
For the common i2c_client struct the i2c_set_clientdata() call is used to store
a <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> pointer, for other buses you may have to use other
methods.</p>
<p>Bridges might also need to store per-subdev private data, such as a pointer to
bridge-specific per-subdev private data. The <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> structure
provides host private data for that purpose that can be accessed with
<a class="reference internal" href="#c.v4l2_get_subdev_hostdata" title="v4l2_get_subdev_hostdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_get_subdev_hostdata()</span></code></a> and <a class="reference internal" href="#c.v4l2_set_subdev_hostdata" title="v4l2_set_subdev_hostdata"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_set_subdev_hostdata()</span></code></a>.</p>
<p>From the bridge driver perspective, you load the sub-device module and somehow
obtain the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> pointer. For i2c devices this is easy: you call
<code class="docutils literal notranslate"><span class="pre">i2c_get_clientdata()</span></code>. For other buses something similar needs to be done.
Helper functions exist for sub-devices on an I2C bus that do most of this
tricky work for you.</p>
<p>Each <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> contains function pointers that sub-device drivers
can implement (or leave <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if it is not applicable). Since sub-devices can
do so many different things and you do not want to end up with a huge ops struct
of which only a handful of ops are commonly implemented, the function pointers
are sorted according to category and each category has its own ops struct.</p>
<p>The top-level ops struct contains pointers to the category ops structs, which
may be NULL if the subdev driver does not support anything from that category.</p>
<p>It looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">v4l2_subdev_core_ops</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">log_status</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">v4l2_subdev</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">v4l2_subdev</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">v4l2_subdev_tuner_ops</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">v4l2_subdev_audio_ops</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">v4l2_subdev_video_ops</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">v4l2_subdev_pad_ops</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">v4l2_subdev_ops</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">v4l2_subdev_core_ops</span><span class="w">  </span><span class="o">*</span><span class="n">core</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">v4l2_subdev_tuner_ops</span><span class="w"> </span><span class="o">*</span><span class="n">tuner</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">v4l2_subdev_audio_ops</span><span class="w"> </span><span class="o">*</span><span class="n">audio</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">v4l2_subdev_video_ops</span><span class="w"> </span><span class="o">*</span><span class="n">video</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">v4l2_subdev_pad_ops</span><span class="w"> </span><span class="o">*</span><span class="n">video</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The core ops are common to all subdevs, the other categories are implemented
depending on the sub-device. E.g. a video device is unlikely to support the
audio ops and vice versa.</p>
<p>This setup limits the number of function pointers while still making it easy
to add new ops and categories.</p>
<p>A sub-device driver initializes the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> struct using:</p>
<blockquote>
<div><p><a class="reference internal" href="#c.v4l2_subdev_init" title="v4l2_subdev_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_init</span></code></a>
(<a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a>, &amp;<a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">ops</span></code></a>).</p>
</div></blockquote>
<p>Afterwards you need to initialize <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a>-&gt;name with a
unique name and set the module owner. This is done for you if you use the
i2c helper functions.</p>
<p>If integration with the media framework is needed, you must initialize the
<a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">media_entity</span></code></a> struct embedded in the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> struct
(entity field) by calling <a class="reference internal" href="mc-core.html#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_pads_init()</span></code></a>, if the entity has
pads:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">media_pad</span><span class="w"> </span><span class="o">*</span><span class="n">pads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_sd</span><span class="o">-&gt;</span><span class="n">pads</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>

<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">media_entity_pads_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">entity</span><span class="p">,</span><span class="w"> </span><span class="n">npads</span><span class="p">,</span><span class="w"> </span><span class="n">pads</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The pads array must have been previously initialized. There is no need to
manually set the <a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a> function and name fields, but the
revision field must be initialized if needed.</p>
<p>A reference to the entity will be automatically acquired/released when the
subdev device node (if any) is opened/closed.</p>
<p>Don’t forget to cleanup the media entity before the sub-device is destroyed:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">media_entity_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">entity</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>If a sub-device driver implements sink pads, the subdev driver may set the
link_validate field in <a class="reference internal" href="#c.v4l2_subdev_pad_ops" title="v4l2_subdev_pad_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev_pad_ops</span></code></a> to provide its own link
validation function. For every link in the pipeline, the link_validate pad
operation of the sink end of the link is called. In both cases the driver is
still responsible for validating the correctness of the format configuration
between sub-devices and video nodes.</p>
<p>If link_validate op is not set, the default function
<a class="reference internal" href="#c.v4l2_subdev_link_validate_default" title="v4l2_subdev_link_validate_default"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_link_validate_default()</span></code></a> is used instead. This function
ensures that width, height and the media bus pixel code are equal on both source
and sink of the link. Subdev drivers are also free to use this function to
perform the checks mentioned above in addition to their own checks.</p>
<section id="subdev-registration">
<h2><span class="section-number">2.7.1. </span>Subdev registration<a class="headerlink" href="#subdev-registration" title="Permalink to this headline">¶</a></h2>
<p>There are currently two ways to register subdevices with the V4L2 core. The
first (traditional) possibility is to have subdevices registered by bridge
drivers. This can be done when the bridge driver has the complete information
about subdevices connected to it and knows exactly when to register them. This
is typically the case for internal subdevices, like video data processing units
within SoCs or complex PCI(e) boards, camera sensors in USB cameras or connected
to SoCs, which pass information about them to bridge drivers, usually in their
platform data.</p>
<p>There are however also situations where subdevices have to be registered
asynchronously to bridge devices. An example of such a configuration is a Device
Tree based system where information about subdevices is made available to the
system independently from the bridge devices, e.g. when subdevices are defined
in DT as I2C device nodes. The API used in this second case is described further
below.</p>
<p>Using one or the other registration method only affects the probing process, the
run-time bridge-subdevice interaction is in both cases the same.</p>
<p>In the <strong>synchronous</strong> case a device (bridge) driver needs to register the
<a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> with the v4l2_device:</p>
<blockquote>
<div><p><a class="reference internal" href="v4l2-device.html#c.v4l2_device_register_subdev" title="v4l2_device_register_subdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_device_register_subdev</span></code></a>
(<a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_dev</span></code></a>, <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a>).</p>
</div></blockquote>
<p>This can fail if the subdev module disappeared before it could be registered.
After this function was called successfully the subdev-&gt;dev field points to
the <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_device</span></code></a>.</p>
<p>If the v4l2_device parent device has a non-NULL mdev field, the sub-device
entity will be automatically registered with the media device.</p>
<p>You can unregister a sub-device using:</p>
<blockquote>
<div><p><a class="reference internal" href="v4l2-device.html#c.v4l2_device_unregister_subdev" title="v4l2_device_unregister_subdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_device_unregister_subdev</span></code></a>
(<a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a>).</p>
</div></blockquote>
<p>Afterwards the subdev module can be unloaded and
<a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a>-&gt;dev == <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>In the <strong>asynchronous</strong> case subdevice probing can be invoked independently of
the bridge driver availability. The subdevice driver then has to verify whether
all the requirements for a successful probing are satisfied. This can include a
check for a master clock availability. If any of the conditions aren’t satisfied
the driver might decide to return <code class="docutils literal notranslate"><span class="pre">-EPROBE_DEFER</span></code> to request further reprobing
attempts. Once all conditions are met the subdevice shall be registered using
the <a class="reference internal" href="v4l2-async.html#c.v4l2_async_register_subdev" title="v4l2_async_register_subdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_async_register_subdev()</span></code></a> function. Unregistration is
performed using the <a class="reference internal" href="v4l2-async.html#c.v4l2_async_unregister_subdev" title="v4l2_async_unregister_subdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_async_unregister_subdev()</span></code></a> call. Subdevices
registered this way are stored in a global list of subdevices, ready to be
picked up by bridge drivers.</p>
<p>Bridge drivers in turn have to register a notifier object. This is
performed using the <a class="reference internal" href="v4l2-async.html#c.v4l2_async_nf_register" title="v4l2_async_nf_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_async_nf_register()</span></code></a> call. To
unregister the notifier the driver has to call
<a class="reference internal" href="v4l2-async.html#c.v4l2_async_nf_unregister" title="v4l2_async_nf_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_async_nf_unregister()</span></code></a>. The former of the two functions
takes two arguments: a pointer to struct <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_device</span></code></a> and a
pointer to struct <a class="reference internal" href="v4l2-async.html#c.v4l2_async_notifier" title="v4l2_async_notifier"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_async_notifier</span></code></a>.</p>
<p>Before registering the notifier, bridge drivers must do two things: first, the
notifier must be initialized using the <a class="reference internal" href="v4l2-async.html#c.v4l2_async_nf_init" title="v4l2_async_nf_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_async_nf_init()</span></code></a>.
Second, bridge drivers can then begin to form a list of subdevice descriptors
that the bridge device needs for its operation. Several functions are available
to add subdevice descriptors to a notifier, depending on the type of device and
the needs of the driver.</p>
<p><a class="reference internal" href="v4l2-async.html#c.v4l2_async_nf_add_fwnode_remote" title="v4l2_async_nf_add_fwnode_remote"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_async_nf_add_fwnode_remote()</span></code></a> and
<a class="reference internal" href="v4l2-async.html#c.v4l2_async_nf_add_i2c" title="v4l2_async_nf_add_i2c"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_async_nf_add_i2c()</span></code></a> are for bridge and ISP drivers for
registering their async sub-devices with the notifier.</p>
<p><a class="reference internal" href="v4l2-async.html#c.v4l2_async_register_subdev_sensor" title="v4l2_async_register_subdev_sensor"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_async_register_subdev_sensor()</span></code></a> is a helper function for
sensor drivers registering their own async sub-device, but it also registers a
notifier and further registers async sub-devices for lens and flash devices
found in firmware. The notifier for the sub-device is unregistered with the
async sub-device.</p>
<p>These functions allocate an async sub-device descriptor which is of type struct
<a class="reference internal" href="v4l2-async.html#c.v4l2_async_subdev" title="v4l2_async_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_async_subdev</span></code></a> embedded in a driver-specific struct. The &amp;struct
<a class="reference internal" href="v4l2-async.html#c.v4l2_async_subdev" title="v4l2_async_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_async_subdev</span></code></a> shall be the first member of this struct:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">my_async_subdev</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">v4l2_async_subdev</span><span class="w"> </span><span class="n">asd</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">my_async_subdev</span><span class="w"> </span><span class="o">*</span><span class="n">my_asd</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">fwnode_handle</span><span class="w"> </span><span class="o">*</span><span class="n">ep</span><span class="p">;</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>

<span class="n">my_asd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v4l2_async_nf_add_fwnode_remote</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notifier</span><span class="p">,</span><span class="w"> </span><span class="n">ep</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="k">struct</span> <span class="nc">my_async_subdev</span><span class="p">);</span><span class="w"></span>
<span class="n">fwnode_handle_put</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">asd</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">asd</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The V4L2 core will then use these descriptors to match asynchronously
registered subdevices to them. If a match is detected the <code class="docutils literal notranslate"><span class="pre">.bound()</span></code>
notifier callback is called. After all subdevices have been located the
.complete() callback is called. When a subdevice is removed from the
system the .unbind() method is called. All three callbacks are optional.</p>
<p>Drivers can store any type of custom data in their driver-specific
<a class="reference internal" href="v4l2-async.html#c.v4l2_async_subdev" title="v4l2_async_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_async_subdev</span></code></a> wrapper. If any of that data requires special
handling when the structure is freed, drivers must implement the <code class="docutils literal notranslate"><span class="pre">.destroy()</span></code>
notifier callback. The framework will call it right before freeing the
<a class="reference internal" href="v4l2-async.html#c.v4l2_async_subdev" title="v4l2_async_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_async_subdev</span></code></a>.</p>
</section>
<section id="calling-subdev-operations">
<h2><span class="section-number">2.7.2. </span>Calling subdev operations<a class="headerlink" href="#calling-subdev-operations" title="Permalink to this headline">¶</a></h2>
<p>The advantage of using <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> is that it is a generic struct and
does not contain any knowledge about the underlying hardware. So a driver might
contain several subdevs that use an I2C bus, but also a subdev that is
controlled through GPIO pins. This distinction is only relevant when setting
up the device, but once the subdev is registered it is completely transparent.</p>
<p>Once the subdev has been registered you can call an ops function either
directly:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">core</span><span class="o">-&gt;</span><span class="n">g_std</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">norm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>but it is better and easier to use this macro:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v4l2_subdev_call</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="n">g_std</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">norm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The macro will do the right <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer checks and returns <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code>
if <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, <code class="docutils literal notranslate"><span class="pre">-ENOIOCTLCMD</span></code> if either
<a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a>-&gt;core or <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a>-&gt;core-&gt;g_std is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, or the actual result of the
<a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a>-&gt;ops-&gt;core-&gt;g_std ops.</p>
<p>It is also possible to call all or a subset of the sub-devices:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">v4l2_device_call_all</span><span class="p">(</span><span class="n">v4l2_dev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="n">g_std</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">norm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Any subdev that does not support this ops is skipped and error results are
ignored. If you want to check for errors use this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v4l2_device_call_until_err</span><span class="p">(</span><span class="n">v4l2_dev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">core</span><span class="p">,</span><span class="w"> </span><span class="n">g_std</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">norm</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Any error except <code class="docutils literal notranslate"><span class="pre">-ENOIOCTLCMD</span></code> will exit the loop with that error. If no
errors (except <code class="docutils literal notranslate"><span class="pre">-ENOIOCTLCMD</span></code>) occurred, then 0 is returned.</p>
<p>The second argument to both calls is a group ID. If 0, then all subdevs are
called. If non-zero, then only those whose group ID match that value will
be called. Before a bridge driver registers a subdev it can set
<a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a>-&gt;grp_id to whatever value it wants (it’s 0 by
default). This value is owned by the bridge driver and the sub-device driver
will never modify or use it.</p>
<p>The group ID gives the bridge driver more control how callbacks are called.
For example, there may be multiple audio chips on a board, each capable of
changing the volume. But usually only one will actually be used when the
user want to change the volume. You can set the group ID for that subdev to
e.g. AUDIO_CONTROLLER and specify that as the group ID value when calling
<code class="docutils literal notranslate"><span class="pre">v4l2_device_call_all()</span></code>. That ensures that it will only go to the subdev
that needs it.</p>
<p>If the sub-device needs to notify its v4l2_device parent of an event, then
it can call <code class="docutils literal notranslate"><span class="pre">v4l2_subdev_notify(sd,</span> <span class="pre">notification,</span> <span class="pre">arg)</span></code>. This macro checks
whether there is a <code class="docutils literal notranslate"><span class="pre">notify()</span></code> callback defined and returns <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code> if not.
Otherwise the result of the <code class="docutils literal notranslate"><span class="pre">notify()</span></code> call is returned.</p>
</section>
</section>
<section id="v4l2-sub-device-userspace-api">
<h1><span class="section-number">2.8. </span>V4L2 sub-device userspace API<a class="headerlink" href="#v4l2-sub-device-userspace-api" title="Permalink to this headline">¶</a></h1>
<p>Bridge drivers traditionally expose one or multiple video nodes to userspace,
and control subdevices through the <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev_ops</span></code></a> operations in
response to video node operations. This hides the complexity of the underlying
hardware from applications. For complex devices, finer-grained control of the
device than what the video nodes offer may be required. In those cases, bridge
drivers that implement <a class="reference internal" href="../../userspace-api/media/mediactl/media-controller.html#media-controller"><span class="std std-ref">the media controller API</span></a> may
opt for making the subdevice operations directly accessible from userpace.</p>
<p>Device nodes named <code class="docutils literal notranslate"><span class="pre">v4l-subdev</span></code><em>X</em> can be created in <code class="docutils literal notranslate"><span class="pre">/dev</span></code> to access
sub-devices directly. If a sub-device supports direct userspace configuration
it must set the <code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FL_HAS_DEVNODE</span></code> flag before being registered.</p>
<p>After registering sub-devices, the <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_device</span></code></a> driver can create
device nodes for all registered sub-devices marked with
<code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FL_HAS_DEVNODE</span></code> by calling
<a class="reference internal" href="v4l2-device.html#c.v4l2_device_register_subdev_nodes" title="v4l2_device_register_subdev_nodes"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_device_register_subdev_nodes()</span></code></a>. Those device nodes will be
automatically removed when sub-devices are unregistered.</p>
<p>The device node handles a subset of the V4L2 API.</p>
<p><code class="docutils literal notranslate"><span class="pre">VIDIOC_QUERYCTRL</span></code>,
<code class="docutils literal notranslate"><span class="pre">VIDIOC_QUERYMENU</span></code>,
<code class="docutils literal notranslate"><span class="pre">VIDIOC_G_CTRL</span></code>,
<code class="docutils literal notranslate"><span class="pre">VIDIOC_S_CTRL</span></code>,
<code class="docutils literal notranslate"><span class="pre">VIDIOC_G_EXT_CTRLS</span></code>,
<code class="docutils literal notranslate"><span class="pre">VIDIOC_S_EXT_CTRLS</span></code> and
<code class="docutils literal notranslate"><span class="pre">VIDIOC_TRY_EXT_CTRLS</span></code>:</p>
<blockquote>
<div><p>The controls ioctls are identical to the ones defined in V4L2. They
behave identically, with the only exception that they deal only with
controls implemented in the sub-device. Depending on the driver, those
controls can be also be accessed through one (or several) V4L2 device
nodes.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">VIDIOC_DQEVENT</span></code>,
<code class="docutils literal notranslate"><span class="pre">VIDIOC_SUBSCRIBE_EVENT</span></code> and
<code class="docutils literal notranslate"><span class="pre">VIDIOC_UNSUBSCRIBE_EVENT</span></code></p>
<blockquote>
<div><p>The events ioctls are identical to the ones defined in V4L2. They
behave identically, with the only exception that they deal only with
events generated by the sub-device. Depending on the driver, those
events can also be reported by one (or several) V4L2 device nodes.</p>
<p>Sub-device drivers that want to use events need to set the
<code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FL_HAS_EVENTS</span></code> <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a>.flags before registering
the sub-device. After registration events can be queued as usual on the
<a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a>.devnode device node.</p>
<p>To properly support events, the <code class="docutils literal notranslate"><span class="pre">poll()</span></code> file operation is also
implemented.</p>
</div></blockquote>
<p>Private ioctls</p>
<blockquote>
<div><p>All ioctls not in the above list are passed directly to the sub-device
driver through the core::ioctl operation.</p>
</div></blockquote>
</section>
<section id="read-only-sub-device-userspace-api">
<h1><span class="section-number">2.9. </span>Read-only sub-device userspace API<a class="headerlink" href="#read-only-sub-device-userspace-api" title="Permalink to this headline">¶</a></h1>
<p>Bridge drivers that control their connected subdevices through direct calls to
the kernel API realized by <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev_ops</span></code></a> structure do not usually
want userspace to be able to change the same parameters through the subdevice
device node and thus do not usually register any.</p>
<p>It is sometimes useful to report to userspace the current subdevice
configuration through a read-only API, that does not permit applications to
change to the device parameters but allows interfacing to the subdevice device
node to inspect them.</p>
<p>For instance, to implement cameras based on computational photography, userspace
needs to know the detailed camera sensor configuration (in terms of skipping,
binning, cropping and scaling) for each supported output resolution. To support
such use cases, bridge drivers may expose the subdevice operations to userspace
through a read-only API.</p>
<p>To create a read-only device node for all the subdevices registered with the
<code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FL_HAS_DEVNODE</span></code> set, the <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_device</span></code></a> driver should call
<a class="reference internal" href="v4l2-device.html#c.v4l2_device_register_ro_subdev_nodes" title="v4l2_device_register_ro_subdev_nodes"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_device_register_ro_subdev_nodes()</span></code></a>.</p>
<p>Access to the following ioctls for userspace applications is restricted on
sub-device device nodes registered with
<a class="reference internal" href="v4l2-device.html#c.v4l2_device_register_ro_subdev_nodes" title="v4l2_device_register_ro_subdev_nodes"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_device_register_ro_subdev_nodes()</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">VIDIOC_SUBDEV_S_FMT</span></code>,
<code class="docutils literal notranslate"><span class="pre">VIDIOC_SUBDEV_S_CROP</span></code>,
<code class="docutils literal notranslate"><span class="pre">VIDIOC_SUBDEV_S_SELECTION</span></code>:</p>
<blockquote>
<div><p>These ioctls are only allowed on a read-only subdevice device node
for the <a class="reference internal" href="../../userspace-api/media/v4l/vidioc-subdev-g-fmt.html#v4l2-subdev-format-whence"><span class="std std-ref">V4L2_SUBDEV_FORMAT_TRY</span></a>
formats and selection rectangles.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">VIDIOC_SUBDEV_S_FRAME_INTERVAL</span></code>,
<code class="docutils literal notranslate"><span class="pre">VIDIOC_SUBDEV_S_DV_TIMINGS</span></code>,
<code class="docutils literal notranslate"><span class="pre">VIDIOC_SUBDEV_S_STD</span></code>:</p>
<blockquote>
<div><p>These ioctls are not allowed on a read-only subdevice node.</p>
</div></blockquote>
<p>In case the ioctl is not allowed, or the format to modify is set to
<code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FORMAT_ACTIVE</span></code>, the core returns a negative error code and
the errno variable is set to <code class="docutils literal notranslate"><span class="pre">-EPERM</span></code>.</p>
</section>
<section id="i2c-sub-device-drivers">
<h1><span class="section-number">2.10. </span>I2C sub-device drivers<a class="headerlink" href="#i2c-sub-device-drivers" title="Permalink to this headline">¶</a></h1>
<p>Since these drivers are so common, special helper functions are available to
ease the use of these drivers (<code class="docutils literal notranslate"><span class="pre">v4l2-common.h</span></code>).</p>
<p>The recommended method of adding <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> support to an I2C driver
is to embed the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> struct into the state struct that is
created for each I2C device instance. Very simple devices have no state
struct and in that case you can just create a <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> directly.</p>
<p>A typical state struct would look like this (where ‘chipname’ is replaced by
the name of the chip):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">chipname_state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">v4l2_subdev</span><span class="w"> </span><span class="n">sd</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w">  </span><span class="cm">/* additional state fields */</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Initialize the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> struct as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">v4l2_i2c_subdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">client</span><span class="p">,</span><span class="w"> </span><span class="n">subdev_ops</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This function will fill in all the fields of <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> ensure that
the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> and i2c_client both point to one another.</p>
<p>You should also add a helper inline function to go from a <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a>
pointer to a chipname_state struct:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">struct</span> <span class="nc">chipname_state</span><span class="w"> </span><span class="o">*</span><span class="n">to_state</span><span class="p">(</span><span class="k">struct</span> <span class="nc">v4l2_subdev</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">chipname_state</span><span class="p">,</span><span class="w"> </span><span class="n">sd</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Use this to go from the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> struct to the <code class="docutils literal notranslate"><span class="pre">i2c_client</span></code>
struct:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">i2c_client</span><span class="w"> </span><span class="o">*</span><span class="n">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v4l2_get_subdevdata</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>And this to go from an <code class="docutils literal notranslate"><span class="pre">i2c_client</span></code> to a <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> struct:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">v4l2_subdev</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_get_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Make sure to call
<a class="reference internal" href="v4l2-device.html#c.v4l2_device_unregister_subdev" title="v4l2_device_unregister_subdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_device_unregister_subdev()</span></code></a>(<a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a>)
when the <code class="docutils literal notranslate"><span class="pre">remove()</span></code> callback is called. This will unregister the sub-device
from the bridge driver. It is safe to call this even if the sub-device was
never registered.</p>
<p>You need to do this because when the bridge driver destroys the i2c adapter
the <code class="docutils literal notranslate"><span class="pre">remove()</span></code> callbacks are called of the i2c devices on that adapter.
After that the corresponding v4l2_subdev structures are invalid, so they
have to be unregistered first. Calling
<a class="reference internal" href="v4l2-device.html#c.v4l2_device_unregister_subdev" title="v4l2_device_unregister_subdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_device_unregister_subdev()</span></code></a>(<a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">sd</span></code></a>)
from the <code class="docutils literal notranslate"><span class="pre">remove()</span></code> callback ensures that this is always done correctly.</p>
<p>The bridge driver also has some helper functions it can use:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">v4l2_subdev</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v4l2_i2c_new_subdev</span><span class="p">(</span><span class="n">v4l2_dev</span><span class="p">,</span><span class="w"> </span><span class="n">adapter</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="s">&quot;module_foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;chipid&quot;</span><span class="p">,</span><span class="w"> </span><span class="mh">0x36</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This loads the given module (can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no module needs to be loaded)
and calls <a class="reference internal" href="../i2c.html#c.i2c_new_client_device" title="i2c_new_client_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_new_client_device()</span></code></a> with the given <code class="docutils literal notranslate"><span class="pre">i2c_adapter</span></code> and
chip/address arguments. If all goes well, then it registers the subdev with
the v4l2_device.</p>
<p>You can also use the last argument of <a class="reference internal" href="v4l2-common.html#c.v4l2_i2c_new_subdev" title="v4l2_i2c_new_subdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_i2c_new_subdev()</span></code></a> to pass
an array of possible I2C addresses that it should probe. These probe addresses
are only used if the previous argument is 0. A non-zero argument means that you
know the exact i2c address so in that case no probing will take place.</p>
<p>Both functions return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if something went wrong.</p>
<p>Note that the chipid you pass to <a class="reference internal" href="v4l2-common.html#c.v4l2_i2c_new_subdev" title="v4l2_i2c_new_subdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_i2c_new_subdev()</span></code></a> is usually
the same as the module name. It allows you to specify a chip variant, e.g.
“saa7114” or “saa7115”. In general though the i2c driver autodetects this.
The use of chipid is something that needs to be looked at more closely at a
later date. It differs between i2c drivers and as such can be confusing.
To see which chip variants are supported you can look in the i2c driver code
for the i2c_device_id table. This lists all the possibilities.</p>
<p>There are one more helper function:</p>
<p><a class="reference internal" href="v4l2-common.html#c.v4l2_i2c_new_subdev_board" title="v4l2_i2c_new_subdev_board"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_i2c_new_subdev_board()</span></code></a> uses an <a class="reference internal" href="../i2c.html#c.i2c_board_info" title="i2c_board_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">i2c_board_info</span></code></a> struct
which is passed to the i2c driver and replaces the irq, platform_data and addr
arguments.</p>
<p>If the subdev supports the s_config core ops, then that op is called with
the irq and platform_data arguments after the subdev was setup.</p>
<p>The <a class="reference internal" href="v4l2-common.html#c.v4l2_i2c_new_subdev" title="v4l2_i2c_new_subdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_i2c_new_subdev()</span></code></a> function will call
<a class="reference internal" href="v4l2-common.html#c.v4l2_i2c_new_subdev_board" title="v4l2_i2c_new_subdev_board"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_i2c_new_subdev_board()</span></code></a>, internally filling a
<a class="reference internal" href="../i2c.html#c.i2c_board_info" title="i2c_board_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">i2c_board_info</span></code></a> structure using the <code class="docutils literal notranslate"><span class="pre">client_type</span></code> and the
<code class="docutils literal notranslate"><span class="pre">addr</span></code> to fill it.</p>
</section>
<section id="centrally-managed-subdev-active-state">
<h1><span class="section-number">2.11. </span>Centrally managed subdev active state<a class="headerlink" href="#centrally-managed-subdev-active-state" title="Permalink to this headline">¶</a></h1>
<p>Traditionally V4L2 subdev drivers maintained internal state for the active
device configuration. This is often implemented as e.g. an array of struct
v4l2_mbus_framefmt, one entry for each pad, and similarly for crop and compose
rectangles.</p>
<p>In addition to the active configuration, each subdev file handle has an array of
<a class="reference internal" href="#c.v4l2_subdev_pad_config" title="v4l2_subdev_pad_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_pad_config</span></code></a>, managed by the V4L2 core, which contains the try
configuration.</p>
<p>To simplify the subdev drivers the V4L2 subdev API now optionally supports a
centrally managed active configuration represented by
<a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev_state</span></code></a>. One instance of state, which contains the active
device configuration, is stored in the sub-device itself as part of
the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a> structure, while the core associates a try state to
each open file handle, to store the try configuration related to that file
handle.</p>
<p>Sub-device drivers can opt-in and use state to manage their active configuration
by initializing the subdevice state with a call to <a class="reference internal" href="#c.v4l2_subdev_init_finalize" title="v4l2_subdev_init_finalize"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_init_finalize()</span></code></a>
before registering the sub-device. They must also call <a class="reference internal" href="#c.v4l2_subdev_cleanup" title="v4l2_subdev_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_cleanup()</span></code></a>
to release all the allocated resources before unregistering the sub-device.
The core automatically allocates and initializes a state for each open file
handle to store the try configurations and frees it when closing the file
handle.</p>
<p>V4L2 sub-device operations that use both the <a class="reference internal" href="../../userspace-api/media/v4l/vidioc-subdev-g-fmt.html#v4l2-subdev-format-whence"><span class="std std-ref">ACTIVE and TRY formats</span></a> receive the correct state to operate on through
the ‘state’ parameter. The state must be locked and unlocked by the
caller by calling <a class="reference internal" href="#c.v4l2_subdev_lock_state" title="v4l2_subdev_lock_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_lock_state()</span></code></a> and
<a class="reference internal" href="#c.v4l2_subdev_unlock_state" title="v4l2_subdev_unlock_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_unlock_state()</span></code></a>. The caller can do so by calling the subdev
operation through the <a class="reference internal" href="#c.v4l2_subdev_call_state_active" title="v4l2_subdev_call_state_active"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_call_state_active()</span></code></a> macro.</p>
<p>Operations that do not receive a state parameter implicitly operate on the
subdevice active state, which drivers can exclusively access by
calling <a class="reference internal" href="#c.v4l2_subdev_lock_and_get_active_state" title="v4l2_subdev_lock_and_get_active_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_lock_and_get_active_state()</span></code></a>. The sub-device active
state must equally be released by calling <a class="reference internal" href="#c.v4l2_subdev_unlock_state" title="v4l2_subdev_unlock_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_unlock_state()</span></code></a>.</p>
<p>Drivers must never manually access the state stored in the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev</span></code></a>
or in the file handle without going through the designated helpers.</p>
<p>While the V4L2 core passes the correct try or active state to the subdevice
operations, many existing device drivers pass a NULL state when calling
operations with <a class="reference internal" href="#c.v4l2_subdev_call" title="v4l2_subdev_call"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_call()</span></code></a>. This legacy construct causes
issues with subdevice drivers that let the V4L2 core manage the active state,
as they expect to receive the appropriate state as a parameter. To help the
conversion of subdevice drivers to a managed active state without having to
convert all callers at the same time, an additional wrapper layer has been
added to <a class="reference internal" href="#c.v4l2_subdev_call" title="v4l2_subdev_call"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_call()</span></code></a>, which handles the NULL case by geting and locking
the callee’s active state with <a class="reference internal" href="#c.v4l2_subdev_lock_and_get_active_state" title="v4l2_subdev_lock_and_get_active_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_lock_and_get_active_state()</span></code></a>,
and unlocking the state after the call.</p>
<p>The whole subdev state is in reality split into three parts: the
v4l2_subdev_state, subdev controls and subdev driver’s internal state. In the
future these parts should be combined into a single state. For the time being
we need a way to handle the locking for these parts. This can be accomplished
by sharing a lock. The v4l2_ctrl_handler already supports this via its ‘lock’
pointer and the same model is used with states. The driver can do the following
before calling <a class="reference internal" href="#c.v4l2_subdev_init_finalize" title="v4l2_subdev_init_finalize"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_init_finalize()</span></code></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">ctrl_handler</span><span class="o">-&gt;</span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">;</span><span class="w"></span>
<span class="n">sd</span><span class="o">-&gt;</span><span class="n">state_lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>This shares the driver’s private mutex between the controls and the states.</p>
</section>
<section id="v4l2-sub-device-functions-and-data-structures">
<h1><span class="section-number">2.12. </span>V4L2 sub-device functions and data structures<a class="headerlink" href="#v4l2-sub-device-functions-and-data-structures" title="Permalink to this headline">¶</a></h1>
<dl class="type">
<dt id="c.v4l2_decode_vbi_line">
struct <code class="sig-name descname">v4l2_decode_vbi_line</code><a class="headerlink" href="#c.v4l2_decode_vbi_line" title="Permalink to this definition">¶</a></dt>
<dd><p>used to decode_vbi_line</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_decode_vbi_line {
    u32 is_second_field;
    u8 *p;
    u32 line;
    u32 type;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">is_second_field</span></code></dt><dd><p>Set to 0 for the first (odd) field;
set to 1 for the second (even) field.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>Pointer to the sliced VBI data from the decoder. On exit, points to
the start of the payload.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">line</span></code></dt><dd><p>Line number of the sliced VBI data (1-23)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>VBI service type (V4L2_SLICED_*). 0 if no service found</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_io_pin_bits">
enum <code class="sig-name descname">v4l2_subdev_io_pin_bits</code><a class="headerlink" href="#c.v4l2_subdev_io_pin_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdevice external IO pin configuration bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_IO_PIN_DISABLE</span></code></dt><dd><p>disables a pin config. ENABLE assumed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_IO_PIN_OUTPUT</span></code></dt><dd><p>set it if pin is an output.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_IO_PIN_INPUT</span></code></dt><dd><p>set it if pin is an input.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_IO_PIN_SET_VALUE</span></code></dt><dd><p>to set the output value via
<a class="reference internal" href="#c.v4l2_subdev_io_pin_config" title="v4l2_subdev_io_pin_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_io_pin_config</span></code></a>-&gt;value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_IO_PIN_ACTIVE_LOW</span></code></dt><dd><p>pin active is bit 0.
Otherwise, ACTIVE HIGH is assumed.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_io_pin_config">
struct <code class="sig-name descname">v4l2_subdev_io_pin_config</code><a class="headerlink" href="#c.v4l2_subdev_io_pin_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdevice external IO pin configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_io_pin_config {
    u32 flags;
    u8 pin;
    u8 function;
    u8 value;
    u8 strength;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>bitmask with flags for this pin’s config, whose bits are defined by
<a class="reference internal" href="#c.v4l2_subdev_io_pin_bits" title="v4l2_subdev_io_pin_bits"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_subdev_io_pin_bits</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pin</span></code></dt><dd><p>Chip external IO pin to configure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function</span></code></dt><dd><p>Internal signal pad/function to route to IO pin</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>Initial value for pin - e.g. GPIO output value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">strength</span></code></dt><dd><p>Pin drive strength</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_core_ops">
struct <code class="sig-name descname">v4l2_subdev_core_ops</code><a class="headerlink" href="#c.v4l2_subdev_core_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Define core ops callbacks for subdevs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_core_ops {
    int (*log_status)(struct v4l2_subdev *sd);
    int (*s_io_pin_config)(struct v4l2_subdev *sd, size_t n, struct v4l2_subdev_io_pin_config *pincfg);
    int (*init)(struct v4l2_subdev *sd, u32 val);
    int (*load_fw)(struct v4l2_subdev *sd);
    int (*reset)(struct v4l2_subdev *sd, u32 val);
    int (*s_gpio)(struct v4l2_subdev *sd, u32 val);
    long (*command)(struct v4l2_subdev *sd, unsigned int cmd, void *arg);
    long (*ioctl)(struct v4l2_subdev *sd, unsigned int cmd, void *arg);
#ifdef CONFIG_COMPAT;
    long (*compat_ioctl32)(struct v4l2_subdev *sd, unsigned int cmd, unsigned long arg);
#endif;
#ifdef CONFIG_VIDEO_ADV_DEBUG;
    int (*g_register)(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg);
    int (*s_register)(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg);
#endif;
    int (*s_power)(struct v4l2_subdev *sd, int on);
    int (*interrupt_service_routine)(struct v4l2_subdev *sd, u32 status, bool *handled);
    int (*subscribe_event)(struct v4l2_subdev *sd, struct v4l2_fh *fh, struct v4l2_event_subscription *sub);
    int (*unsubscribe_event)(struct v4l2_subdev *sd, struct v4l2_fh *fh, struct v4l2_event_subscription *sub);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">log_status</span></code></dt><dd><p>callback for VIDIOC_LOG_STATUS() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_io_pin_config</span></code></dt><dd><p>configure one or more chip I/O pins for chips that
multiplex different internal signal pads out to IO pins.  This function
takes a pointer to an array of ‘n’ pin configuration entries, one for
each pin being configured.  This function could be called at times
other than just subdevice initialization.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init</span></code></dt><dd><p>initialize the sensor registers to some sort of reasonable default
values. Do not use for new drivers and should be removed in existing
drivers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">load_fw</span></code></dt><dd><p>load firmware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset</span></code></dt><dd><p>generic reset command. The argument selects which subsystems to
reset. Passing 0 will always reset the whole chip. Do not use for new
drivers without discussing this first on the linux-media mailinglist.
There should be no reason normally to reset a device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_gpio</span></code></dt><dd><p>set GPIO pins. Very simple right now, might need to be extended with
a direction argument if needed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">command</span></code></dt><dd><p>called by in-kernel drivers in order to call functions internal
to subdev drivers driver that have a separate callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioctl</span></code></dt><dd><p>called at the end of ioctl() syscall handler at the V4L2 core.
used to provide support for private ioctls used on the driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_ioctl32</span></code></dt><dd><p>called when a 32 bits application uses a 64 bits Kernel,
in order to fix data passed from/to userspace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_register</span></code></dt><dd><p>callback for VIDIOC_DBG_G_REGISTER() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_register</span></code></dt><dd><p>callback for VIDIOC_DBG_S_REGISTER() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_power</span></code></dt><dd><p>puts subdevice in power saving mode (on == 0) or normal operation
mode (on == 1). DEPRECATED. See
<a class="reference internal" href="camera-sensor.html"><span class="doc">Writing camera sensor drivers</span></a> . pre_streamon and
post_streamoff callbacks can be used for e.g. setting the bus to LP-11
mode before s_stream is called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interrupt_service_routine</span></code></dt><dd><p>Called by the bridge chip’s interrupt service
handler, when an interrupt status has be raised due to this subdev,
so that this subdev can handle the details.  It may schedule work to be
performed later.  It must not sleep. <strong>Called from an IRQ context</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subscribe_event</span></code></dt><dd><p>used by the drivers to request the control framework that
for it to be warned when the value of a control changes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsubscribe_event</span></code></dt><dd><p>remove event subscription from the control framework.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_tuner_ops">
struct <code class="sig-name descname">v4l2_subdev_tuner_ops</code><a class="headerlink" href="#c.v4l2_subdev_tuner_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Callbacks used when v4l device was opened in radio mode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_tuner_ops {
    int (*standby)(struct v4l2_subdev *sd);
    int (*s_radio)(struct v4l2_subdev *sd);
    int (*s_frequency)(struct v4l2_subdev *sd, const struct v4l2_frequency *freq);
    int (*g_frequency)(struct v4l2_subdev *sd, struct v4l2_frequency *freq);
    int (*enum_freq_bands)(struct v4l2_subdev *sd, struct v4l2_frequency_band *band);
    int (*g_tuner)(struct v4l2_subdev *sd, struct v4l2_tuner *vt);
    int (*s_tuner)(struct v4l2_subdev *sd, const struct v4l2_tuner *vt);
    int (*g_modulator)(struct v4l2_subdev *sd, struct v4l2_modulator *vm);
    int (*s_modulator)(struct v4l2_subdev *sd, const struct v4l2_modulator *vm);
    int (*s_type_addr)(struct v4l2_subdev *sd, struct tuner_setup *type);
    int (*s_config)(struct v4l2_subdev *sd, const struct v4l2_priv_tun_config *config);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">standby</span></code></dt><dd><p>puts the tuner in standby mode. It will be woken up
automatically the next time it is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_radio</span></code></dt><dd><p>callback that switches the tuner to radio mode.
drivers should explicitly call it when a tuner ops should
operate on radio mode, before being able to handle it.
Used on devices that have both AM/FM radio receiver and TV.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_frequency</span></code></dt><dd><p>callback for VIDIOC_S_FREQUENCY() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_frequency</span></code></dt><dd><p>callback for VIDIOC_G_FREQUENCY() ioctl handler code.
freq-&gt;type must be filled in. Normally done by <a class="reference internal" href="v4l2-common.html#c.video_ioctl2" title="video_ioctl2"><code class="xref c c-func docutils literal notranslate"><span class="pre">video_ioctl2()</span></code></a>
or the bridge driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum_freq_bands</span></code></dt><dd><p>callback for VIDIOC_ENUM_FREQ_BANDS() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_tuner</span></code></dt><dd><p>callback for VIDIOC_G_TUNER() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_tuner</span></code></dt><dd><p>callback for VIDIOC_S_TUNER() ioctl handler code. <strong>vt-&gt;type</strong> must be
filled in. Normally done by video_ioctl2 or the
bridge driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_modulator</span></code></dt><dd><p>callback for VIDIOC_G_MODULATOR() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_modulator</span></code></dt><dd><p>callback for VIDIOC_S_MODULATOR() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_type_addr</span></code></dt><dd><p>sets tuner type and its I2C addr.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_config</span></code></dt><dd><p>sets tda9887 specific stuff, like port1, port2 and qss</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On devices that have both AM/FM and TV, it is up to the driver
to explicitly call s_radio when the tuner should be switched to
radio mode, before handling other <a class="reference internal" href="#c.v4l2_subdev_tuner_ops" title="v4l2_subdev_tuner_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_tuner_ops</span></code></a>
that would require it. An example of such usage is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void s_frequency(void *priv, const struct v4l2_frequency *f)
{
      ...
      if (f.type == V4L2_TUNER_RADIO)
              v4l2_device_call_all(v4l2_dev, 0, tuner, s_radio);
      ...
      v4l2_device_call_all(v4l2_dev, 0, tuner, s_frequency);
}
</pre></div>
</div>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_audio_ops">
struct <code class="sig-name descname">v4l2_subdev_audio_ops</code><a class="headerlink" href="#c.v4l2_subdev_audio_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Callbacks used for audio-related settings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_audio_ops {
    int (*s_clock_freq)(struct v4l2_subdev *sd, u32 freq);
    int (*s_i2s_clock_freq)(struct v4l2_subdev *sd, u32 freq);
    int (*s_routing)(struct v4l2_subdev *sd, u32 input, u32 output, u32 config);
    int (*s_stream)(struct v4l2_subdev *sd, int enable);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s_clock_freq</span></code></dt><dd><p>set the frequency (in Hz) of the audio clock output.
Used to slave an audio processor to the video decoder, ensuring that
audio and video remain synchronized. Usual values for the frequency
are 48000, 44100 or 32000 Hz. If the frequency is not supported, then
-EINVAL is returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_i2s_clock_freq</span></code></dt><dd><p>sets I2S speed in bps. This is used to provide a standard
way to select I2S clock used by driving digital audio streams at some
board designs. Usual values for the frequency are 1024000 and 2048000.
If the frequency is not supported, then <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> is returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_routing</span></code></dt><dd><p>used to define the input and/or output pins of an audio chip,
and any additional configuration data.
Never attempt to use user-level input IDs (e.g. Composite, S-Video,
Tuner) at this level. An i2c device shouldn’t know about whether an
input pin is connected to a Composite connector, become on another
board or platform it might be connected to something else entirely.
The calling driver is responsible for mapping a user-level input to
the right pins on the i2c device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_stream</span></code></dt><dd><p>used to notify the audio code that stream will start or has
stopped.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_mbus_frame_desc_entry_csi2">
struct <code class="sig-name descname">v4l2_mbus_frame_desc_entry_csi2</code><a class="headerlink" href="#c.v4l2_mbus_frame_desc_entry_csi2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_mbus_frame_desc_entry_csi2 {
    u8 vc;
    u8 dt;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vc</span></code></dt><dd><p>CSI-2 virtual channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dt</span></code></dt><dd><p>CSI-2 data type ID</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_mbus_frame_desc_flags">
enum <code class="sig-name descname">v4l2_mbus_frame_desc_flags</code><a class="headerlink" href="#c.v4l2_mbus_frame_desc_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>media bus frame description flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">V4L2_MBUS_FRAME_DESC_FL_LEN_MAX</span></code></p>
<blockquote>
<div><p>Indicates that <a class="reference internal" href="#c.v4l2_mbus_frame_desc_entry" title="v4l2_mbus_frame_desc_entry"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_mbus_frame_desc_entry</span></code></a>-&gt;length field
specifies maximum data length.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">V4L2_MBUS_FRAME_DESC_FL_BLOB</span></code></p>
<blockquote>
<div><p>Indicates that the format does not have line offsets, i.e.
the receiver should use 1D DMA.</p>
</div></blockquote>
</div>
<dl class="type">
<dt id="c.v4l2_mbus_frame_desc_entry">
struct <code class="sig-name descname">v4l2_mbus_frame_desc_entry</code><a class="headerlink" href="#c.v4l2_mbus_frame_desc_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>media bus frame description structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_mbus_frame_desc_entry {
    enum v4l2_mbus_frame_desc_flags flags;
    u32 pixelcode;
    u32 length;
    union {
        struct v4l2_mbus_frame_desc_entry_csi2 csi2;
    } bus;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>bitmask flags, as defined by <a class="reference internal" href="#c.v4l2_mbus_frame_desc_flags" title="v4l2_mbus_frame_desc_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_mbus_frame_desc_flags</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pixelcode</span></code></dt><dd><p>media bus pixel code, valid if <strong>flags</strong>
<code class="docutils literal notranslate"><span class="pre">FRAME_DESC_FL_BLOB</span></code> is not set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>number of octets per frame, valid if <strong>flags</strong>
<code class="docutils literal notranslate"><span class="pre">V4L2_MBUS_FRAME_DESC_FL_LEN_MAX</span></code> is set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus</span></code></dt><dd><p>Bus-specific frame descriptor parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus.csi2</span></code></dt><dd><p>CSI-2-specific bus configuration</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_mbus_frame_desc_type">
enum <code class="sig-name descname">v4l2_mbus_frame_desc_type</code><a class="headerlink" href="#c.v4l2_mbus_frame_desc_type" title="Permalink to this definition">¶</a></dt>
<dd><p>media bus frame description type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">V4L2_MBUS_FRAME_DESC_TYPE_UNDEFINED</span></code></p>
<blockquote>
<div><p>Undefined frame desc type. Drivers should not use this, it is
for backwards compatibility.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">V4L2_MBUS_FRAME_DESC_TYPE_PARALLEL</span></code></p>
<blockquote>
<div><p>Parallel media bus.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">V4L2_MBUS_FRAME_DESC_TYPE_CSI2</span></code></p>
<blockquote>
<div><p>CSI-2 media bus. Frame desc parameters must be set in
<a class="reference internal" href="#c.v4l2_mbus_frame_desc_entry" title="v4l2_mbus_frame_desc_entry"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_mbus_frame_desc_entry</span></code></a>-&gt;csi2.</p>
</div></blockquote>
</div>
<dl class="type">
<dt id="c.v4l2_mbus_frame_desc">
struct <code class="sig-name descname">v4l2_mbus_frame_desc</code><a class="headerlink" href="#c.v4l2_mbus_frame_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>media bus data frame description</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_mbus_frame_desc {
    enum v4l2_mbus_frame_desc_type type;
    struct v4l2_mbus_frame_desc_entry entry[V4L2_FRAME_DESC_ENTRY_MAX];
    unsigned short num_entries;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of the bus (<a class="reference internal" href="#c.v4l2_mbus_frame_desc_type" title="v4l2_mbus_frame_desc_type"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_mbus_frame_desc_type</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">entry</span></code></dt><dd><p>frame descriptors array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_entries</span></code></dt><dd><p>number of entries in <strong>entry</strong> array</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_pre_streamon_flags">
enum <code class="sig-name descname">v4l2_subdev_pre_streamon_flags</code><a class="headerlink" href="#c.v4l2_subdev_pre_streamon_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags for pre_streamon subdev core op</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_PRE_STREAMON_FL_MANUAL_LP</span></code></dt><dd><p>Set the transmitter to either LP-11
or LP-111 mode before call to s_stream().</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_video_ops">
struct <code class="sig-name descname">v4l2_subdev_video_ops</code><a class="headerlink" href="#c.v4l2_subdev_video_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Callbacks used when v4l device was opened in video mode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_video_ops {
    int (*s_routing)(struct v4l2_subdev *sd, u32 input, u32 output, u32 config);
    int (*s_crystal_freq)(struct v4l2_subdev *sd, u32 freq, u32 flags);
    int (*g_std)(struct v4l2_subdev *sd, v4l2_std_id *norm);
    int (*s_std)(struct v4l2_subdev *sd, v4l2_std_id norm);
    int (*s_std_output)(struct v4l2_subdev *sd, v4l2_std_id std);
    int (*g_std_output)(struct v4l2_subdev *sd, v4l2_std_id *std);
    int (*querystd)(struct v4l2_subdev *sd, v4l2_std_id *std);
    int (*g_tvnorms)(struct v4l2_subdev *sd, v4l2_std_id *std);
    int (*g_tvnorms_output)(struct v4l2_subdev *sd, v4l2_std_id *std);
    int (*g_input_status)(struct v4l2_subdev *sd, u32 *status);
    int (*s_stream)(struct v4l2_subdev *sd, int enable);
    int (*g_pixelaspect)(struct v4l2_subdev *sd, struct v4l2_fract *aspect);
    int (*g_frame_interval)(struct v4l2_subdev *sd, struct v4l2_subdev_frame_interval *interval);
    int (*s_frame_interval)(struct v4l2_subdev *sd, struct v4l2_subdev_frame_interval *interval);
    int (*s_dv_timings)(struct v4l2_subdev *sd, struct v4l2_dv_timings *timings);
    int (*g_dv_timings)(struct v4l2_subdev *sd, struct v4l2_dv_timings *timings);
    int (*query_dv_timings)(struct v4l2_subdev *sd, struct v4l2_dv_timings *timings);
    int (*s_rx_buffer)(struct v4l2_subdev *sd, void *buf, unsigned int *size);
    int (*pre_streamon)(struct v4l2_subdev *sd, u32 flags);
    int (*post_streamoff)(struct v4l2_subdev *sd);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">s_routing</span></code></dt><dd><p>see s_routing in audio_ops, except this version is for video
devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_crystal_freq</span></code></dt><dd><p>sets the frequency of the crystal used to generate the
clocks in Hz. An extra flags field allows device specific configuration
regarding clock frequency dividers, etc. If not used, then set flags
to 0. If the frequency is not supported, then -EINVAL is returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_std</span></code></dt><dd><p>callback for VIDIOC_G_STD() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_std</span></code></dt><dd><p>callback for VIDIOC_S_STD() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_std_output</span></code></dt><dd><p>set v4l2_std_id for video OUTPUT devices. This is ignored by
video input devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_std_output</span></code></dt><dd><p>get current standard for video OUTPUT devices. This is ignored
by video input devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">querystd</span></code></dt><dd><p>callback for VIDIOC_QUERYSTD() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_tvnorms</span></code></dt><dd><p>get <code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_std_id</span></code> with all standards supported by the video
CAPTURE device. This is ignored by video output devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_tvnorms_output</span></code></dt><dd><p>get v4l2_std_id with all standards supported by the video
OUTPUT device. This is ignored by video capture devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_input_status</span></code></dt><dd><p>get input status. Same as the status field in the
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_input</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_stream</span></code></dt><dd><p>start (enabled == 1) or stop (enabled == 0) streaming on the
sub-device. Failure on stop will remove any resources acquired in
streaming start, while the error code is still returned by the driver.
Also see call_s_stream wrapper in v4l2-subdev.c.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_pixelaspect</span></code></dt><dd><p>callback to return the pixelaspect ratio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_frame_interval</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_G_FRAME_INTERVAL()
ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_frame_interval</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_S_FRAME_INTERVAL()
ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_dv_timings</span></code></dt><dd><p>Set custom dv timings in the sub device. This is used
when sub device is capable of setting detailed timing information
in the hardware to generate/detect the video signal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_dv_timings</span></code></dt><dd><p>Get custom dv timings in the sub device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">query_dv_timings</span></code></dt><dd><p>callback for VIDIOC_QUERY_DV_TIMINGS() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_rx_buffer</span></code></dt><dd><p>set a host allocated memory buffer for the subdev. The subdev
can adjust <strong>size</strong> to a lower value and must not write more data to the
buffer starting at <strong>data</strong> than the original value of <strong>size</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pre_streamon</span></code></dt><dd><p>May be called before streaming is actually started, to help
initialising the bus. Current usage is to set a CSI-2 transmitter to
LP-11 or LP-111 mode before streaming. See <a class="reference internal" href="#c.v4l2_subdev_pre_streamon_flags" title="v4l2_subdev_pre_streamon_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span>
<span class="pre">v4l2_subdev_pre_streamon_flags</span></code></a>.</p>
<p>pre_streamon shall return error if it cannot perform the operation as
indicated by the flags argument. In particular, -EACCES indicates lack
of support for the operation. The caller shall call post_streamoff for
each successful call of pre_streamon.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">post_streamoff</span></code></dt><dd><p>Called after streaming is stopped, but if and only if
pre_streamon was called earlier.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_vbi_ops">
struct <code class="sig-name descname">v4l2_subdev_vbi_ops</code><a class="headerlink" href="#c.v4l2_subdev_vbi_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Callbacks used when v4l device was opened in video mode via the vbi device node.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_vbi_ops {
    int (*decode_vbi_line)(struct v4l2_subdev *sd, struct v4l2_decode_vbi_line *vbi_line);
    int (*s_vbi_data)(struct v4l2_subdev *sd, const struct v4l2_sliced_vbi_data *vbi_data);
    int (*g_vbi_data)(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_data *vbi_data);
    int (*g_sliced_vbi_cap)(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_cap *cap);
    int (*s_raw_fmt)(struct v4l2_subdev *sd, struct v4l2_vbi_format *fmt);
    int (*g_sliced_fmt)(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *fmt);
    int (*s_sliced_fmt)(struct v4l2_subdev *sd, struct v4l2_sliced_vbi_format *fmt);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">decode_vbi_line</span></code></dt><dd><p>video decoders that support sliced VBI need to implement
this ioctl. Field p of the <a class="reference internal" href="#c.v4l2_decode_vbi_line" title="v4l2_decode_vbi_line"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_decode_vbi_line</span></code></a> is set to the
start of the VBI data that was generated by the decoder. The driver
then parses the sliced VBI data and sets the other fields in the
struct accordingly. The pointer p is updated to point to the start of
the payload which can be copied verbatim into the data field of the
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_sliced_vbi_data</span></code>. If no valid VBI data was found, then the
type field is set to 0 on return.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_vbi_data</span></code></dt><dd><p>used to generate VBI signals on a video signal.
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_sliced_vbi_data</span></code> is filled with the data packets that
should be output. Note that if you set the line field to 0, then that
VBI signal is disabled. If no valid VBI data was found, then the type
field is set to 0 on return.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_vbi_data</span></code></dt><dd><p>used to obtain the sliced VBI packet from a readback register.
Not all video decoders support this. If no data is available because
the readback register contains invalid or erroneous data <code class="docutils literal notranslate"><span class="pre">-EIO</span></code> is
returned. Note that you must fill in the ‘id’ member and the ‘field’
member (to determine whether CC data from the first or second field
should be obtained).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_sliced_vbi_cap</span></code></dt><dd><p>callback for VIDIOC_G_SLICED_VBI_CAP() ioctl handler
code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_raw_fmt</span></code></dt><dd><p>setup the video encoder/decoder for raw VBI.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_sliced_fmt</span></code></dt><dd><p>retrieve the current sliced VBI settings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s_sliced_fmt</span></code></dt><dd><p>setup the sliced VBI settings.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_sensor_ops">
struct <code class="sig-name descname">v4l2_subdev_sensor_ops</code><a class="headerlink" href="#c.v4l2_subdev_sensor_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>v4l2-subdev sensor operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_sensor_ops {
    int (*g_skip_top_lines)(struct v4l2_subdev *sd, u32 *lines);
    int (*g_skip_frames)(struct v4l2_subdev *sd, u32 *frames);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">g_skip_top_lines</span></code></dt><dd><p>number of lines at the top of the image to be skipped.
This is needed for some sensors, which always corrupt
several top lines of the output image, or which send their
metadata in them.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_skip_frames</span></code></dt><dd><p>number of frames to skip at stream start. This is needed for
buggy sensors that generate faulty frames when they are
turned on.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_ir_mode">
enum <code class="sig-name descname">v4l2_subdev_ir_mode</code><a class="headerlink" href="#c.v4l2_subdev_ir_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>describes the type of IR supported</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_IR_MODE_PULSE_WIDTH</span></code></dt><dd><p>IR uses struct ir_raw_event records</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_ir_parameters">
struct <code class="sig-name descname">v4l2_subdev_ir_parameters</code><a class="headerlink" href="#c.v4l2_subdev_ir_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters for IR TX or TX</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_ir_parameters {
    unsigned int bytes_per_data_element;
    enum v4l2_subdev_ir_mode mode;
    bool enable;
    bool interrupt_enable;
    bool shutdown;
    bool modulation;
    u32 max_pulse_width;
    unsigned int carrier_freq;
    unsigned int duty_cycle;
    bool invert_level;
    bool invert_carrier_sense;
    u32 noise_filter_min_width;
    unsigned int carrier_range_lower;
    unsigned int carrier_range_upper;
    u32 resolution;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bytes_per_data_element</span></code></dt><dd><p>bytes per data element of data in read or
write call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>IR mode as defined by <a class="reference internal" href="#c.v4l2_subdev_ir_mode" title="v4l2_subdev_ir_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">v4l2_subdev_ir_mode</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>device is active if true</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interrupt_enable</span></code></dt><dd><p>IR interrupts are enabled if true</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p>if true: set hardware to low/no power, false: normal mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">modulation</span></code></dt><dd><p>if true, it uses carrier, if false: baseband</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_pulse_width</span></code></dt><dd><p>maximum pulse width in ns, valid only for baseband signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">carrier_freq</span></code></dt><dd><p>carrier frequency in Hz, valid only for modulated signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duty_cycle</span></code></dt><dd><p>duty cycle percentage, valid only for modulated signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">invert_level</span></code></dt><dd><p>invert signal level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">invert_carrier_sense</span></code></dt><dd><p>Send 0/space as a carrier burst. used only in TX.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">noise_filter_min_width</span></code></dt><dd><p>min time of a valid pulse, in ns. Used only for RX.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">carrier_range_lower</span></code></dt><dd><p>Lower carrier range, in Hz, valid only for modulated
signal. Used only for RX.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">carrier_range_upper</span></code></dt><dd><p>Upper carrier range, in Hz, valid only for modulated
signal. Used only for RX.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resolution</span></code></dt><dd><p>The receive resolution, in ns . Used only for RX.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_ir_ops">
struct <code class="sig-name descname">v4l2_subdev_ir_ops</code><a class="headerlink" href="#c.v4l2_subdev_ir_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>operations for IR subdevices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_ir_ops {
    int (*rx_read)(struct v4l2_subdev *sd, u8 *buf, size_t count, ssize_t *num);
    int (*rx_g_parameters)(struct v4l2_subdev *sd, struct v4l2_subdev_ir_parameters *params);
    int (*rx_s_parameters)(struct v4l2_subdev *sd, struct v4l2_subdev_ir_parameters *params);
    int (*tx_write)(struct v4l2_subdev *sd, u8 *buf, size_t count, ssize_t *num);
    int (*tx_g_parameters)(struct v4l2_subdev *sd, struct v4l2_subdev_ir_parameters *params);
    int (*tx_s_parameters)(struct v4l2_subdev *sd, struct v4l2_subdev_ir_parameters *params);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rx_read</span></code></dt><dd><p>Reads received codes or pulse width data.
The semantics are similar to a non-blocking read() call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_g_parameters</span></code></dt><dd><p>Get the current operating parameters and state of
the IR receiver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_s_parameters</span></code></dt><dd><p>Set the current operating parameters and state of
the IR receiver.  It is recommended to call
[rt]x_g_parameters first to fill out the current state, and only change
the fields that need to be changed.  Upon return, the actual device
operating parameters and state will be returned.  Note that hardware
limitations may prevent the actual settings from matching the requested
settings - e.g. an actual carrier setting of 35,904 Hz when 36,000 Hz
was requested.  An exception is when the shutdown parameter is true.
The last used operational parameters will be returned, but the actual
state of the hardware be different to minimize power consumption and
processing when shutdown is true.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_write</span></code></dt><dd><p>Writes codes or pulse width data for transmission.
The semantics are similar to a non-blocking write() call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_g_parameters</span></code></dt><dd><p>Get the current operating parameters and state of
the IR transmitter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_s_parameters</span></code></dt><dd><p>Set the current operating parameters and state of
the IR transmitter.  It is recommended to call
[rt]x_g_parameters first to fill out the current state, and only change
the fields that need to be changed.  Upon return, the actual device
operating parameters and state will be returned.  Note that hardware
limitations may prevent the actual settings from matching the requested
settings - e.g. an actual carrier setting of 35,904 Hz when 36,000 Hz
was requested.  An exception is when the shutdown parameter is true.
The last used operational parameters will be returned, but the actual
state of the hardware be different to minimize power consumption and
processing when shutdown is true.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_pad_config">
struct <code class="sig-name descname">v4l2_subdev_pad_config</code><a class="headerlink" href="#c.v4l2_subdev_pad_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Used for storing subdev pad information.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_pad_config {
    struct v4l2_mbus_framefmt try_fmt;
    struct v4l2_rect try_crop;
    struct v4l2_rect try_compose;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">try_fmt</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_mbus_framefmt</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">try_crop</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_rect</span></code> to be used for crop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">try_compose</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_rect</span></code> to be used for compose</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure only needs to be passed to the pad op if the ‘which’ field
of the main argument is set to <code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FORMAT_TRY</span></code>. For
<code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FORMAT_ACTIVE</span></code> it is safe to pass <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p><strong>Note</strong></p>
<p>This struct is also used in active state, and the ‘try’ prefix is
historical and to be removed.</p>
<dl class="type">
<dt id="c.v4l2_subdev_state">
struct <code class="sig-name descname">v4l2_subdev_state</code><a class="headerlink" href="#c.v4l2_subdev_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Used for storing subdev state information.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_state {
    struct mutex _lock;
    struct mutex *lock;
    struct v4l2_subdev_pad_config *pads;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_lock</span></code></dt><dd><p>default for ‘lock’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>mutex for the state. May be replaced by the user.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pads</span></code></dt><dd><p><a class="reference internal" href="#c.v4l2_subdev_pad_config" title="v4l2_subdev_pad_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_pad_config</span></code></a> array</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure only needs to be passed to the pad op if the ‘which’ field
of the main argument is set to <code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FORMAT_TRY</span></code>. For
<code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FORMAT_ACTIVE</span></code> it is safe to pass <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<dl class="type">
<dt id="c.v4l2_subdev_pad_ops">
struct <code class="sig-name descname">v4l2_subdev_pad_ops</code><a class="headerlink" href="#c.v4l2_subdev_pad_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>v4l2-subdev pad level operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_pad_ops {
    int (*init_cfg)(struct v4l2_subdev *sd, struct v4l2_subdev_state *state);
    int (*enum_mbus_code)(struct v4l2_subdev *sd,struct v4l2_subdev_state *state, struct v4l2_subdev_mbus_code_enum *code);
    int (*enum_frame_size)(struct v4l2_subdev *sd,struct v4l2_subdev_state *state, struct v4l2_subdev_frame_size_enum *fse);
    int (*enum_frame_interval)(struct v4l2_subdev *sd,struct v4l2_subdev_state *state, struct v4l2_subdev_frame_interval_enum *fie);
    int (*get_fmt)(struct v4l2_subdev *sd,struct v4l2_subdev_state *state, struct v4l2_subdev_format *format);
    int (*set_fmt)(struct v4l2_subdev *sd,struct v4l2_subdev_state *state, struct v4l2_subdev_format *format);
    int (*get_selection)(struct v4l2_subdev *sd,struct v4l2_subdev_state *state, struct v4l2_subdev_selection *sel);
    int (*set_selection)(struct v4l2_subdev *sd,struct v4l2_subdev_state *state, struct v4l2_subdev_selection *sel);
    int (*get_edid)(struct v4l2_subdev *sd, struct v4l2_edid *edid);
    int (*set_edid)(struct v4l2_subdev *sd, struct v4l2_edid *edid);
    int (*dv_timings_cap)(struct v4l2_subdev *sd, struct v4l2_dv_timings_cap *cap);
    int (*enum_dv_timings)(struct v4l2_subdev *sd, struct v4l2_enum_dv_timings *timings);
#ifdef CONFIG_MEDIA_CONTROLLER;
    int (*link_validate)(struct v4l2_subdev *sd, struct media_link *link,struct v4l2_subdev_format *source_fmt, struct v4l2_subdev_format *sink_fmt);
#endif ;
    int (*get_frame_desc)(struct v4l2_subdev *sd, unsigned int pad, struct v4l2_mbus_frame_desc *fd);
    int (*set_frame_desc)(struct v4l2_subdev *sd, unsigned int pad, struct v4l2_mbus_frame_desc *fd);
    int (*get_mbus_config)(struct v4l2_subdev *sd, unsigned int pad, struct v4l2_mbus_config *config);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">init_cfg</span></code></dt><dd><p>initialize the pad config to default values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum_mbus_code</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_ENUM_MBUS_CODE() ioctl handler
code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum_frame_size</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_ENUM_FRAME_SIZE() ioctl handler
code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum_frame_interval</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL() ioctl
handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_fmt</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_G_FMT() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_fmt</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_S_FMT() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_selection</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_G_SELECTION() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_selection</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_S_SELECTION() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_edid</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_G_EDID() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_edid</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_S_EDID() ioctl handler code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dv_timings_cap</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_DV_TIMINGS_CAP() ioctl handler
code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum_dv_timings</span></code></dt><dd><p>callback for VIDIOC_SUBDEV_ENUM_DV_TIMINGS() ioctl handler
code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_validate</span></code></dt><dd><p>used by the media controller code to check if the links
that belongs to a pipeline can be used for stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_frame_desc</span></code></dt><dd><p>get the current low level media bus frame parameters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_frame_desc</span></code></dt><dd><p>set the low level media bus frame parameters, <strong>fd</strong> array
may be adjusted by the subdev driver to device capabilities.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_mbus_config</span></code></dt><dd><p>get the media bus configuration of a remote sub-device.
The media bus configuration is usually retrieved from the
firmware interface at sub-device probe time, immediately
applied to the hardware and eventually adjusted by the
driver. Remote sub-devices (usually video receivers) shall
use this operation to query the transmitting end bus
configuration in order to adjust their own one accordingly.
Callers should make sure they get the most up-to-date as
possible configuration from the remote end, likely calling
this operation as close as possible to stream on time. The
operation shall fail if the pad index it has been called on
is not valid or in case of unrecoverable failures.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_ops">
struct <code class="sig-name descname">v4l2_subdev_ops</code><a class="headerlink" href="#c.v4l2_subdev_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdev operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_ops {
    const struct v4l2_subdev_core_ops       *core;
    const struct v4l2_subdev_tuner_ops      *tuner;
    const struct v4l2_subdev_audio_ops      *audio;
    const struct v4l2_subdev_video_ops      *video;
    const struct v4l2_subdev_vbi_ops        *vbi;
    const struct v4l2_subdev_ir_ops         *ir;
    const struct v4l2_subdev_sensor_ops     *sensor;
    const struct v4l2_subdev_pad_ops        *pad;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">core</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_core_ops" title="v4l2_subdev_core_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_core_ops</span></code></a>. Can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tuner</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_tuner_ops" title="v4l2_subdev_tuner_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_tuner_ops</span></code></a>. Can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">audio</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_audio_ops" title="v4l2_subdev_audio_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_audio_ops</span></code></a>. Can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">video</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_video_ops" title="v4l2_subdev_video_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_video_ops</span></code></a>. Can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vbi</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_vbi_ops" title="v4l2_subdev_vbi_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_vbi_ops</span></code></a>. Can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ir</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_ir_ops" title="v4l2_subdev_ir_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_ir_ops</span></code></a>. Can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sensor</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_sensor_ops" title="v4l2_subdev_sensor_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_sensor_ops</span></code></a>. Can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pad</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_pad_ops" title="v4l2_subdev_pad_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_pad_ops</span></code></a>. Can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_internal_ops">
struct <code class="sig-name descname">v4l2_subdev_internal_ops</code><a class="headerlink" href="#c.v4l2_subdev_internal_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>V4L2 subdev internal ops</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_internal_ops {
    int (*registered)(struct v4l2_subdev *sd);
    void (*unregistered)(struct v4l2_subdev *sd);
    int (*open)(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);
    int (*close)(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);
    void (*release)(struct v4l2_subdev *sd);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">registered</span></code></dt><dd><p>called when this subdev is registered. When called the v4l2_dev
field is set to the correct v4l2_device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unregistered</span></code></dt><dd><p>called when this subdev is unregistered. When called the
v4l2_dev field is still set to the correct v4l2_device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>called when the subdev device node is opened by an application.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">close</span></code></dt><dd><p>called when the subdev device node is closed. Please note that
it is possible for <strong>close</strong> to be called after <strong>unregistered</strong>!</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">release</span></code></dt><dd><p>called when the last user of the subdev device is gone. This
happens after the <strong>unregistered</strong> callback and when the last open
filehandle to the v4l-subdevX device node was closed. If no device
node was created for this sub-device, then the <strong>release</strong> callback
is called right after the <strong>unregistered</strong> callback.
The <strong>release</strong> callback is typically used to free the memory containing
the v4l2_subdev structure. It is almost certainly required for any
sub-device that sets the V4L2_SUBDEV_FL_HAS_DEVNODE flag.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Never call this from drivers, only the v4l2 framework can call
these ops.</p>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_platform_data">
struct <code class="sig-name descname">v4l2_subdev_platform_data</code><a class="headerlink" href="#c.v4l2_subdev_platform_data" title="Permalink to this definition">¶</a></dt>
<dd><p>regulators config struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_platform_data {
    struct regulator_bulk_data *regulators;
    int num_regulators;
    void *host_priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">regulators</span></code></dt><dd><p>Optional regulators used to power on/off the subdevice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_regulators</span></code></dt><dd><p>Number of regululators</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">host_priv</span></code></dt><dd><p>Per-subdevice data, specific for a certain video host device</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev">
struct <code class="sig-name descname">v4l2_subdev</code><a class="headerlink" href="#c.v4l2_subdev" title="Permalink to this definition">¶</a></dt>
<dd><p>describes a V4L2 sub-device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev {
#if defined(CONFIG_MEDIA_CONTROLLER);
    struct media_entity entity;
#endif;
    struct list_head list;
    struct module *owner;
    bool owner_v4l2_dev;
    u32 flags;
    struct v4l2_device *v4l2_dev;
    const struct v4l2_subdev_ops *ops;
    const struct v4l2_subdev_internal_ops *internal_ops;
    struct v4l2_ctrl_handler *ctrl_handler;
    char name[V4L2_SUBDEV_NAME_SIZE];
    u32 grp_id;
    void *dev_priv;
    void *host_priv;
    struct video_device *devnode;
    struct device *dev;
    struct fwnode_handle *fwnode;
    struct list_head async_list;
    struct v4l2_async_subdev *asd;
    struct v4l2_async_notifier *notifier;
    struct v4l2_async_notifier *subdev_notifier;
    struct v4l2_subdev_platform_data *pdata;
    struct mutex *state_lock;
    struct v4l2_subdev_state *active_state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">entity</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>List of sub-devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>The owner is the same as the driver’s <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> owner.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner_v4l2_dev</span></code></dt><dd><p>true if the <code class="xref c c-type docutils literal notranslate"><span class="pre">sd-&gt;owner</span></code> matches the owner of <strong>v4l2_dev-&gt;dev</strong>
owner. Initialized by <a class="reference internal" href="v4l2-device.html#c.v4l2_device_register_subdev" title="v4l2_device_register_subdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_device_register_subdev()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>subdev flags. Can be:
<code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FL_IS_I2C</span></code> - Set this flag if this subdev is a i2c device;
<code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FL_IS_SPI</span></code> - Set this flag if this subdev is a spi device;
<code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FL_HAS_DEVNODE</span></code> - Set this flag if this subdev needs a
device node;
<code class="docutils literal notranslate"><span class="pre">V4L2_SUBDEV_FL_HAS_EVENTS</span></code> -  Set this flag if this subdev generates
events.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">v4l2_dev</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="v4l2-device.html#c.v4l2_device" title="v4l2_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev_ops</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">internal_ops</span></code></dt><dd><p>pointer to struct <a class="reference internal" href="#c.v4l2_subdev_internal_ops" title="v4l2_subdev_internal_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">v4l2_subdev_internal_ops</span></code></a>.
Never call these internal ops from within a driver!</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctrl_handler</span></code></dt><dd><p>The control handler of this subdev. May be NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the sub-device. Please notice that the name must be unique.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">grp_id</span></code></dt><dd><p>can be used to group similar subdevs. Value is driver-specific</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_priv</span></code></dt><dd><p>pointer to private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">host_priv</span></code></dt><dd><p>pointer to private data used by the device where the subdev
is attached.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devnode</span></code></dt><dd><p>subdev device node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>pointer to the physical device, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fwnode</span></code></dt><dd><p>The fwnode_handle of the subdev, usually the same as
either dev-&gt;of_node-&gt;fwnode or dev-&gt;fwnode (whichever is non-NULL).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">async_list</span></code></dt><dd><p>Links this subdev to a global subdev_list or <strong>notifier-&gt;done</strong>
list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">asd</span></code></dt><dd><p>Pointer to respective <a class="reference internal" href="v4l2-async.html#c.v4l2_async_subdev" title="v4l2_async_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_async_subdev</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notifier</span></code></dt><dd><p>Pointer to the managing notifier.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subdev_notifier</span></code></dt><dd><p>A sub-device notifier implicitly registered for the sub-
device using <a class="reference internal" href="v4l2-async.html#c.v4l2_async_register_subdev_sensor" title="v4l2_async_register_subdev_sensor"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_async_register_subdev_sensor()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pdata</span></code></dt><dd><p>common part of subdevice platform data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_lock</span></code></dt><dd><p>A pointer to a lock used for all the subdev’s states, set by the
driver. This is optional. If NULL, each state instance will get
a lock of its own.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_state</span></code></dt><dd><p>Active state for the subdev (NULL for subdevs tracking the
state internally). Initialized by calling
<a class="reference internal" href="#c.v4l2_subdev_init_finalize" title="v4l2_subdev_init_finalize"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_init_finalize()</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Each instance of a subdev driver should create this struct, either
stand-alone or embedded in a larger struct.</p>
<p>This structure should be initialized by <a class="reference internal" href="#c.v4l2_subdev_init" title="v4l2_subdev_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_init()</span></code></a> or one of
its variants: <a class="reference internal" href="v4l2-common.html#c.v4l2_spi_subdev_init" title="v4l2_spi_subdev_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_spi_subdev_init()</span></code></a>, <a class="reference internal" href="v4l2-common.html#c.v4l2_i2c_subdev_init" title="v4l2_i2c_subdev_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_i2c_subdev_init()</span></code></a>.</p>
<dl class="function">
<dt id="c.media_entity_to_v4l2_subdev">
<code class="sig-name descname">media_entity_to_v4l2_subdev</code><span class="sig-paren">(</span><em>ent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_to_v4l2_subdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a> from the <a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a> embedded in it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ent</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.vdev_to_v4l2_subdev">
<code class="sig-name descname">vdev_to_v4l2_subdev</code><span class="sig-paren">(</span><em>vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vdev_to_v4l2_subdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a> from the <a class="reference internal" href="v4l2-dev.html#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a> embedded on it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vdev</span></code></dt><dd><p>pointer to <a class="reference internal" href="v4l2-dev.html#c.video_device" title="video_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">video_device</span></code></a></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.v4l2_subdev_fh">
struct <code class="sig-name descname">v4l2_subdev_fh</code><a class="headerlink" href="#c.v4l2_subdev_fh" title="Permalink to this definition">¶</a></dt>
<dd><p>Used for storing subdev information per file handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct v4l2_subdev_fh {
    struct v4l2_fh vfh;
    struct module *owner;
#if defined(CONFIG_VIDEO_V4L2_SUBDEV_API);
    struct v4l2_subdev_state *state;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vfh</span></code></dt><dd><p>pointer to <a class="reference internal" href="v4l2-fh.html#c.v4l2_fh" title="v4l2_fh"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_fh</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>module pointer to the owner of this file handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.to_v4l2_subdev_fh">
<code class="sig-name descname">to_v4l2_subdev_fh</code><span class="sig-paren">(</span><em>fh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.to_v4l2_subdev_fh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#c.v4l2_subdev_fh" title="v4l2_subdev_fh"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_fh</span></code></a> from the <a class="reference internal" href="v4l2-fh.html#c.v4l2_fh" title="v4l2_fh"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_fh</span></code></a> embedded on it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fh</span></code></dt><dd><p>pointer to <a class="reference internal" href="v4l2-fh.html#c.v4l2_fh" title="v4l2_fh"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_fh</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_get_pad_format">
struct v4l2_mbus_framefmt * <code class="sig-name descname">v4l2_subdev_get_pad_format</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em>, struct <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state">v4l2_subdev_state</a><em> *state</em>, unsigned int<em> pad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_get_pad_format" title="Permalink to this definition">¶</a></dt>
<dd><p>ancillary routine to call <a class="reference internal" href="#c.v4l2_subdev_pad_config" title="v4l2_subdev_pad_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_pad_config</span></code></a>-&gt;try_fmt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span> <span class="pre">*state</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pad</span></code></dt><dd><p>index of the pad in the <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span></code></a>-&gt;pads array</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_get_pad_crop">
struct v4l2_rect * <code class="sig-name descname">v4l2_subdev_get_pad_crop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em>, struct <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state">v4l2_subdev_state</a><em> *state</em>, unsigned int<em> pad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_get_pad_crop" title="Permalink to this definition">¶</a></dt>
<dd><p>ancillary routine to call <a class="reference internal" href="#c.v4l2_subdev_pad_config" title="v4l2_subdev_pad_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_pad_config</span></code></a>-&gt;try_crop</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span> <span class="pre">*state</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pad</span></code></dt><dd><p>index of the pad in the <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span></code></a>-&gt;pads array.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_get_pad_compose">
struct v4l2_rect * <code class="sig-name descname">v4l2_subdev_get_pad_compose</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em>, struct <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state">v4l2_subdev_state</a><em> *state</em>, unsigned int<em> pad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_get_pad_compose" title="Permalink to this definition">¶</a></dt>
<dd><p>ancillary routine to call <a class="reference internal" href="#c.v4l2_subdev_pad_config" title="v4l2_subdev_pad_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_pad_config</span></code></a>-&gt;try_compose</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span> <span class="pre">*state</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pad</span></code></dt><dd><p>index of the pad in the <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span></code></a>-&gt;pads array.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.v4l2_set_subdevdata">
void <code class="sig-name descname">v4l2_set_subdevdata</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em>, void<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_set_subdevdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets V4L2 dev private device data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>pointer to the private device data to be stored.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.v4l2_get_subdevdata">
void * <code class="sig-name descname">v4l2_get_subdevdata</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_get_subdevdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets V4L2 dev private device data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the pointer to the private device data to be stored.</p>
</div>
<dl class="function">
<dt id="c.v4l2_set_subdev_hostdata">
void <code class="sig-name descname">v4l2_set_subdev_hostdata</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em>, void<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_set_subdev_hostdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets V4L2 dev private host data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>pointer to the private data to be stored.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.v4l2_get_subdev_hostdata">
void * <code class="sig-name descname">v4l2_get_subdev_hostdata</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_get_subdev_hostdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets V4L2 dev private data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the pointer to the private host data to be stored.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_get_fwnode_pad_1_to_1">
int <code class="sig-name descname">v4l2_subdev_get_fwnode_pad_1_to_1</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mc-core.html#c.media_entity" title="media_entity">media_entity</a><em> *entity</em>, struct fwnode_endpoint<em> *endpoint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_get_fwnode_pad_1_to_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Get pad number from a subdev fwnode endpoint, assuming 1:1 port:pad</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*entity</span></code></dt><dd><p>Pointer to the subdev entity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_endpoint</span> <span class="pre">*endpoint</span></code></dt><dd><p>Pointer to a parsed fwnode endpoint</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as the .get_fwnode_pad operation for
subdevices that map port numbers and pad indexes 1:1. If the endpoint
is owned by the subdevice, the function returns the endpoint port
number.</p>
<p>Returns the endpoint port number on success or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_link_validate_default">
int <code class="sig-name descname">v4l2_subdev_link_validate_default</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em>, struct <a class="reference internal" href="mc-core.html#c.media_link" title="media_link">media_link</a><em> *link</em>, struct v4l2_subdev_format<em> *source_fmt</em>, struct v4l2_subdev_format<em> *sink_fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_link_validate_default" title="Permalink to this definition">¶</a></dt>
<dd><p>validates a media link</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_link</span> <span class="pre">*link</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_link" title="media_link"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_link</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_format</span> <span class="pre">*source_fmt</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_format</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_format</span> <span class="pre">*sink_fmt</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_format</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function ensures that width, height and the media bus pixel
code are equal on both source and sink of the link.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_link_validate">
int <code class="sig-name descname">v4l2_subdev_link_validate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mc-core.html#c.media_link" title="media_link">media_link</a><em> *link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_link_validate" title="Permalink to this definition">¶</a></dt>
<dd><p>validates a media link</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_link</span> <span class="pre">*link</span></code></dt><dd><p>pointer to <a class="reference internal" href="mc-core.html#c.media_link" title="media_link"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">media_link</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function calls the subdev’s link_validate ops to validate
if a media link is valid for streaming. It also internally
calls <a class="reference internal" href="#c.v4l2_subdev_link_validate_default" title="v4l2_subdev_link_validate_default"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_link_validate_default()</span></code></a> to ensure that
width, height and the media bus pixel code are equal on both
source and sink of the link.</p>
</div>
<dl class="function">
<dt id="c.__v4l2_subdev_state_alloc">
struct <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state">v4l2_subdev_state</a> * <code class="sig-name descname">__v4l2_subdev_state_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em>, const char<em> *lock_name</em>, struct lock_class_key<em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__v4l2_subdev_state_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate v4l2_subdev_state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a> for which the state is being allocated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*lock_name</span></code></dt><dd><p>name of the state lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*key</span></code></dt><dd><p>lock_class_key for the lock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must call <a class="reference internal" href="#c.__v4l2_subdev_state_free" title="__v4l2_subdev_state_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">__v4l2_subdev_state_free()</span></code></a> when state is no longer needed.</p>
<p>Not to be called directly by the drivers.</p>
</div>
<dl class="function">
<dt id="c.__v4l2_subdev_state_free">
void <code class="sig-name descname">__v4l2_subdev_state_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state">v4l2_subdev_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__v4l2_subdev_state_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a v4l2_subdev_state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span> <span class="pre">*state</span></code></dt><dd><p>v4l2_subdev_state to be freed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not to be called directly by the drivers.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_init_finalize">
<code class="sig-name descname">v4l2_subdev_init_finalize</code><span class="sig-paren">(</span><em>sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_init_finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalizes the initialization of the subdevice</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sd</span></code></dt><dd><p>The subdev</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function finalizes the initialization of the subdev, including
allocation of the active state for the subdev.</p>
<p>This function must be called by the subdev drivers that use the centralized
active state, after the subdev struct has been initialized and
<a class="reference internal" href="mc-core.html#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">media_entity_pads_init()</span></code></a> has been called, but before registering the
subdev.</p>
<p>The user must call <a class="reference internal" href="#c.v4l2_subdev_cleanup" title="v4l2_subdev_cleanup"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_cleanup()</span></code></a> when the subdev is being removed.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_cleanup">
void <code class="sig-name descname">v4l2_subdev_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases the resources allocated by the subdevice</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>The subdevice</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will release the resources allocated in
v4l2_subdev_init_finalize.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_lock_state">
void <code class="sig-name descname">v4l2_subdev_lock_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state">v4l2_subdev_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_lock_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Locks the subdev state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span> <span class="pre">*state</span></code></dt><dd><p>The subdevice state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Locks the given subdev state.</p>
<p>The state must be unlocked with <a class="reference internal" href="#c.v4l2_subdev_unlock_state" title="v4l2_subdev_unlock_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_unlock_state()</span></code></a> after use.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_unlock_state">
void <code class="sig-name descname">v4l2_subdev_unlock_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state">v4l2_subdev_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_unlock_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlocks the subdev state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span> <span class="pre">*state</span></code></dt><dd><p>The subdevice state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the given subdev state.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_get_unlocked_active_state">
struct <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state">v4l2_subdev_state</a> * <code class="sig-name descname">v4l2_subdev_get_unlocked_active_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_get_unlocked_active_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the active subdev state is unlocked and returns it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>The subdevice</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the active state for the subdevice, or NULL if the subdev does not
support active state. If the state is not NULL, calls
lockdep_assert_not_held() to issue a warning if the state is locked.</p>
<p>This function is to be used e.g. when getting the active state for the sole
purpose of passing it forward, without accessing the state fields.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_get_locked_active_state">
struct <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state">v4l2_subdev_state</a> * <code class="sig-name descname">v4l2_subdev_get_locked_active_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_get_locked_active_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the active subdev state is locked and returns it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>The subdevice</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the active state for the subdevice, or NULL if the subdev does not
support active state. If the state is not NULL, calls lockdep_assert_held()
to issue a warning if the state is not locked.</p>
<p>This function is to be used when the caller knows that the active state is
already locked.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_lock_and_get_active_state">
struct <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state">v4l2_subdev_state</a> * <code class="sig-name descname">v4l2_subdev_lock_and_get_active_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_lock_and_get_active_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Locks and returns the active subdev state for the subdevice</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>The subdevice</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the locked active state for the subdevice, or NULL if the subdev
does not support active state.</p>
<p>The state must be unlocked with <a class="reference internal" href="#c.v4l2_subdev_unlock_state" title="v4l2_subdev_unlock_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_unlock_state()</span></code></a> after use.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_get_fmt">
int <code class="sig-name descname">v4l2_subdev_get_fmt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em>, struct <a class="reference internal" href="#c.v4l2_subdev_state" title="v4l2_subdev_state">v4l2_subdev_state</a><em> *state</em>, struct v4l2_subdev_format<em> *format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_get_fmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill format based on state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>subdevice</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_state</span> <span class="pre">*state</span></code></dt><dd><p>subdevice state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_format</span> <span class="pre">*format</span></code></dt><dd><p>pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_format</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill <strong>format-&gt;format</strong> field based on the information in the <strong>format</strong> struct.</p>
<p>This function can be used by the subdev drivers which support active state to
implement v4l2_subdev_pad_ops.get_fmt if the subdev driver does not need to
do anything special in their get_fmt op.</p>
<p>Returns 0 on success, error value otherwise.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_init">
void <code class="sig-name descname">v4l2_subdev_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em>, const struct <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops">v4l2_subdev_ops</a><em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes the sub-device struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a> to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">v4l2_subdev_ops</span> <span class="pre">*ops</span></code></dt><dd><p>pointer to <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_ops</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_call">
<code class="sig-name descname">v4l2_subdev_call</code><span class="sig-paren">(</span><em>sd</em>, <em>o</em>, <em>f</em>, <em>args…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_call" title="Permalink to this definition">¶</a></dt>
<dd><p>call an operation of a v4l2_subdev.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sd</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">o</span></code></dt><dd><p>name of the element at <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_ops</span></code></a> that contains <strong>f</strong>.
Each element there groups a set of callbacks functions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code></dt><dd><p>callback function to be called.
The callback functions are defined in groups, according to
each element at <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_ops</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">args...</span></code></dt><dd><p>arguments for <strong>f</strong>.</p>
</dd>
</dl>
<p><strong>Example</strong></p>
<p>err = v4l2_subdev_call(sd, video, s_std, norm);</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_call_state_active">
<code class="sig-name descname">v4l2_subdev_call_state_active</code><span class="sig-paren">(</span><em>sd</em>, <em>o</em>, <em>f</em>, <em>args…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_call_state_active" title="Permalink to this definition">¶</a></dt>
<dd><p>call an operation of a v4l2_subdev which takes state as a parameter, passing the subdev its active state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sd</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">o</span></code></dt><dd><p>name of the element at <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_ops</span></code></a> that contains <strong>f</strong>.
Each element there groups a set of callbacks functions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code></dt><dd><p>callback function to be called.
The callback functions are defined in groups, according to
each element at <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_ops</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">args...</span></code></dt><dd><p>arguments for <strong>f</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to <a class="reference internal" href="#c.v4l2_subdev_call" title="v4l2_subdev_call"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_call()</span></code></a>, except that this version can only be
used for ops that take a subdev state as a parameter. The macro will get the
active state, lock it before calling the op and unlock it after the call.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_call_state_try">
<code class="sig-name descname">v4l2_subdev_call_state_try</code><span class="sig-paren">(</span><em>sd</em>, <em>o</em>, <em>f</em>, <em>args…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_call_state_try" title="Permalink to this definition">¶</a></dt>
<dd><p>call an operation of a v4l2_subdev which takes state as a parameter, passing the subdev a newly allocated try state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sd</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">o</span></code></dt><dd><p>name of the element at <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_ops</span></code></a> that contains <strong>f</strong>.
Each element there groups a set of callbacks functions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code></dt><dd><p>callback function to be called.
The callback functions are defined in groups, according to
each element at <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_ops</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">args...</span></code></dt><dd><p>arguments for <strong>f</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to <a class="reference internal" href="#c.v4l2_subdev_call_state_active" title="v4l2_subdev_call_state_active"><code class="xref c c-func docutils literal notranslate"><span class="pre">v4l2_subdev_call_state_active()</span></code></a>, except that as this
version allocates a new state, this is only usable for
V4L2_SUBDEV_FORMAT_TRY use cases.</p>
<p><strong>Note</strong></p>
<p>only legacy non-MC drivers may need this macro.</p>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_has_op">
<code class="sig-name descname">v4l2_subdev_has_op</code><span class="sig-paren">(</span><em>sd</em>, <em>o</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_has_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a subdev defines a certain operation.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sd</span></code></dt><dd><p>pointer to the <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">o</span></code></dt><dd><p>The group of callback functions in <a class="reference internal" href="#c.v4l2_subdev_ops" title="v4l2_subdev_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev_ops</span></code></a>
which <strong>f</strong> is a part of.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code></dt><dd><p>callback function to be checked for its existence.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.v4l2_subdev_notify_event">
void <code class="sig-name descname">v4l2_subdev_notify_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.v4l2_subdev" title="v4l2_subdev">v4l2_subdev</a><em> *sd</em>, const struct v4l2_event<em> *ev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.v4l2_subdev_notify_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Delivers event notification for subdevice</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">v4l2_subdev</span> <span class="pre">*sd</span></code></dt><dd><p>The subdev for which to deliver the event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">v4l2_event</span> <span class="pre">*ev</span></code></dt><dd><p>The event to deliver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will deliver the specified event to all userspace event listeners which are
subscribed to the v42l subdev event queue as well as to the bridge driver
using the notify callback. The notification type for the notify callback
will be <code class="docutils literal notranslate"><span class="pre">V4L2_DEVICE_NOTIFY_EVENT</span></code>.</p>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.7. V4L2 sub-devices</a><ul>
<li><a class="reference internal" href="#subdev-registration">2.7.1. Subdev registration</a></li>
<li><a class="reference internal" href="#calling-subdev-operations">2.7.2. Calling subdev operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#v4l2-sub-device-userspace-api">2.8. V4L2 sub-device userspace API</a></li>
<li><a class="reference internal" href="#read-only-sub-device-userspace-api">2.9. Read-only sub-device userspace API</a></li>
<li><a class="reference internal" href="#i2c-sub-device-drivers">2.10. I2C sub-device drivers</a></li>
<li><a class="reference internal" href="#centrally-managed-subdev-active-state">2.11. Centrally managed subdev active state</a></li>
<li><a class="reference internal" href="#v4l2-sub-device-functions-and-data-structures">2.12. V4L2 sub-device functions and data structures</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/media/v4l2-subdev.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/media/v4l2-subdev.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>