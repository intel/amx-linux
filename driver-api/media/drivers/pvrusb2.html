
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>9.1.7. The pvrusb2 driver &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="9.1.8. PXA-Camera Host Driver" href="pxa_camera.html" />
    <link rel="prev" title="9.1.6. The Samsung S5P/EXYNOS4 FIMC driver" href="fimc-devel.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="the-pvrusb2-driver">
<h1><span class="section-number">9.1.7. </span>The pvrusb2 driver<a class="headerlink" href="#the-pvrusb2-driver" title="Permalink to this headline">¶</a></h1>
<p>Author: Mike Isely &lt;<a class="reference external" href="mailto:isely&#37;&#52;&#48;pobox&#46;com">isely<span>&#64;</span>pobox<span>&#46;</span>com</a>&gt;</p>
<section id="background">
<h2><span class="section-number">9.1.7.1. </span>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>This driver is intended for the “Hauppauge WinTV PVR USB 2.0”, which
is a USB 2.0 hosted TV Tuner.  This driver is a work in progress.
Its history started with the reverse-engineering effort by Björn
Danielsson &lt;<a class="reference external" href="mailto:pvrusb2&#37;&#52;&#48;dax&#46;nu">pvrusb2<span>&#64;</span>dax<span>&#46;</span>nu</a>&gt; whose web page can be found here:
<a class="reference external" href="http://pvrusb2.dax.nu/">http://pvrusb2.dax.nu/</a></p>
<p>From there Aurelien Alleaume &lt;<a class="reference external" href="mailto:slts&#37;&#52;&#48;free&#46;fr">slts<span>&#64;</span>free<span>&#46;</span>fr</a>&gt; began an effort to
create a video4linux compatible driver.  I began with Aurelien’s
last known snapshot and evolved the driver to the state it is in
here.</p>
<p>More information on this driver can be found at:
<a class="reference external" href="https://www.isely.net/pvrusb2.html">https://www.isely.net/pvrusb2.html</a></p>
<p>This driver has a strong separation of layers.  They are very
roughly:</p>
<ol class="arabic simple">
<li><p>Low level wire-protocol implementation with the device.</p></li>
<li><p>I2C adaptor implementation and corresponding I2C client drivers
implemented elsewhere in V4L.</p></li>
<li><p>High level hardware driver implementation which coordinates all
activities that ensure correct operation of the device.</p></li>
<li><p>A “context” layer which manages instancing of driver, setup,
tear-down, arbitration, and interaction with high level
interfaces appropriately as devices are hotplugged in the
system.</p></li>
<li><p>High level interfaces which glue the driver to various published
Linux APIs (V4L, sysfs, maybe DVB in the future).</p></li>
</ol>
<p>The most important shearing layer is between the top 2 layers.  A
lot of work went into the driver to ensure that any kind of
conceivable API can be laid on top of the core driver.  (Yes, the
driver internally leverages V4L to do its work but that really has
nothing to do with the API published by the driver to the outside
world.)  The architecture allows for different APIs to
simultaneously access the driver.  I have a strong sense of fairness
about APIs and also feel that it is a good design principle to keep
implementation and interface isolated from each other.  Thus while
right now the V4L high level interface is the most complete, the
sysfs high level interface will work equally well for similar
functions, and there’s no reason I see right now why it shouldn’t be
possible to produce a DVB high level interface that can sit right
alongside V4L.</p>
</section>
<section id="building">
<h2><span class="section-number">9.1.7.2. </span>Building<a class="headerlink" href="#building" title="Permalink to this headline">¶</a></h2>
<p>To build these modules essentially amounts to just running “Make”,
but you need the kernel source tree nearby and you will likely also
want to set a few controlling environment variables first in order
to link things up with that source tree.  Please see the Makefile
here for comments that explain how to do that.</p>
</section>
<section id="source-file-list-functional-overview">
<h2><span class="section-number">9.1.7.3. </span>Source file list / functional overview<a class="headerlink" href="#source-file-list-functional-overview" title="Permalink to this headline">¶</a></h2>
<p>(Note: The term “module” used below generally refers to loosely
defined functional units within the pvrusb2 driver and bears no
relation to the Linux kernel’s concept of a loadable module.)</p>
<dl class="simple">
<dt>pvrusb2-audio.[ch] - This is glue logic that resides between this</dt><dd><p>driver and the msp3400.ko I2C client driver (which is found
elsewhere in V4L).</p>
</dd>
<dt>pvrusb2-context.[ch] - This module implements the context for an</dt><dd><p>instance of the driver.  Everything else eventually ties back to
or is otherwise instanced within the data structures implemented
here.  Hotplugging is ultimately coordinated here.  All high level
interfaces tie into the driver through this module.  This module
helps arbitrate each interface’s access to the actual driver core,
and is designed to allow concurrent access through multiple
instances of multiple interfaces (thus you can for example change
the tuner’s frequency through sysfs while simultaneously streaming
video through V4L out to an instance of mplayer).</p>
</dd>
<dt>pvrusb2-debug.h - This header defines a printk() wrapper and a mask</dt><dd><p>of debugging bit definitions for the various kinds of debug
messages that can be enabled within the driver.</p>
</dd>
<dt>pvrusb2-debugifc.[ch] - This module implements a crude command line</dt><dd><p>oriented debug interface into the driver.  Aside from being part
of the process for implementing manual firmware extraction (see
the pvrusb2 web site mentioned earlier), probably I’m the only one
who has ever used this.  It is mainly a debugging aid.</p>
</dd>
<dt>pvrusb2-eeprom.[ch] - This is glue logic that resides between this</dt><dd><p>driver the tveeprom.ko module, which is itself implemented
elsewhere in V4L.</p>
</dd>
<dt>pvrusb2-encoder.[ch] - This module implements all protocol needed to</dt><dd><p>interact with the Conexant mpeg2 encoder chip within the pvrusb2
device.  It is a crude echo of corresponding logic in ivtv,
however the design goals (strict isolation) and physical layer
(proxy through USB instead of PCI) are enough different that this
implementation had to be completely different.</p>
</dd>
<dt>pvrusb2-hdw-internal.h - This header defines the core data structure</dt><dd><p>in the driver used to track ALL internal state related to control
of the hardware.  Nobody outside of the core hardware-handling
modules should have any business using this header.  All external
access to the driver should be through one of the high level
interfaces (e.g. V4L, sysfs, etc), and in fact even those high
level interfaces are restricted to the API defined in
pvrusb2-hdw.h and NOT this header.</p>
</dd>
<dt>pvrusb2-hdw.h - This header defines the full internal API for</dt><dd><p>controlling the hardware.  High level interfaces (e.g. V4L, sysfs)
will work through here.</p>
</dd>
<dt>pvrusb2-hdw.c - This module implements all the various bits of logic</dt><dd><p>that handle overall control of a specific pvrusb2 device.
(Policy, instantiation, and arbitration of pvrusb2 devices fall
within the jurisdiction of pvrusb-context not here).</p>
</dd>
<dt>pvrusb2-i2c-chips-*.c - These modules implement the glue logic to</dt><dd><p>tie together and configure various I2C modules as they attach to
the I2C bus.  There are two versions of this file.  The “v4l2”
version is intended to be used in-tree alongside V4L, where we
implement just the logic that makes sense for a pure V4L
environment.  The “all” version is intended for use outside of
V4L, where we might encounter other possibly “challenging” modules
from ivtv or older kernel snapshots (or even the support modules
in the standalone snapshot).</p>
</dd>
<dt>pvrusb2-i2c-cmd-v4l1.[ch] - This module implements generic V4L1</dt><dd><p>compatible commands to the I2C modules.  It is here where state
changes inside the pvrusb2 driver are translated into V4L1
commands that are in turn send to the various I2C modules.</p>
</dd>
<dt>pvrusb2-i2c-cmd-v4l2.[ch] - This module implements generic V4L2</dt><dd><p>compatible commands to the I2C modules.  It is here where state
changes inside the pvrusb2 driver are translated into V4L2
commands that are in turn send to the various I2C modules.</p>
</dd>
<dt>pvrusb2-i2c-core.[ch] - This module provides an implementation of a</dt><dd><p>kernel-friendly I2C adaptor driver, through which other external
I2C client drivers (e.g. msp3400, tuner, lirc) may connect and
operate corresponding chips within the pvrusb2 device.  It is
through here that other V4L modules can reach into this driver to
operate specific pieces (and those modules are in turn driven by
glue logic which is coordinated by pvrusb2-hdw, doled out by
pvrusb2-context, and then ultimately made available to users
through one of the high level interfaces).</p>
</dd>
<dt>pvrusb2-io.[ch] - This module implements a very low level ring of</dt><dd><p>transfer buffers, required in order to stream data from the
device.  This module is <em>very</em> low level.  It only operates the
buffers and makes no attempt to define any policy or mechanism for
how such buffers might be used.</p>
</dd>
<dt>pvrusb2-ioread.[ch] - This module layers on top of pvrusb2-io.[ch]</dt><dd><p>to provide a streaming API usable by a read() system call style of
I/O.  Right now this is the only layer on top of pvrusb2-io.[ch],
however the underlying architecture here was intended to allow for
other styles of I/O to be implemented with additional modules, like
mmap()’ed buffers or something even more exotic.</p>
</dd>
<dt>pvrusb2-main.c - This is the top level of the driver.  Module level</dt><dd><p>and USB core entry points are here.  This is our “main”.</p>
</dd>
<dt>pvrusb2-sysfs.[ch] - This is the high level interface which ties the</dt><dd><p>pvrusb2 driver into sysfs.  Through this interface you can do
everything with the driver except actually stream data.</p>
</dd>
<dt>pvrusb2-tuner.[ch] - This is glue logic that resides between this</dt><dd><p>driver and the tuner.ko I2C client driver (which is found
elsewhere in V4L).</p>
</dd>
<dt>pvrusb2-util.h - This header defines some common macros used</dt><dd><p>throughout the driver.  These macros are not really specific to
the driver, but they had to go somewhere.</p>
</dd>
<dt>pvrusb2-v4l2.[ch] - This is the high level interface which ties the</dt><dd><p>pvrusb2 driver into video4linux.  It is through here that V4L
applications can open and operate the driver in the usual V4L
ways.  Note that <strong>ALL</strong> V4L functionality is published only
through here and nowhere else.</p>
</dd>
<dt>pvrusb2-video-*.[ch] - This is glue logic that resides between this</dt><dd><p>driver and the saa711x.ko I2C client driver (which is found
elsewhere in V4L).  Note that saa711x.ko used to be known as
saa7115.ko in ivtv.  There are two versions of this; one is
selected depending on the particular saa711[5x].ko that is found.</p>
</dd>
<dt>pvrusb2.h - This header contains compile time tunable parameters</dt><dd><p>(and at the moment the driver has very little that needs to be
tuned).</p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">9.1.7. The pvrusb2 driver</a><ul>
<li><a class="reference internal" href="#background">9.1.7.1. Background</a></li>
<li><a class="reference internal" href="#building">9.1.7.2. Building</a></li>
<li><a class="reference internal" href="#source-file-list-functional-overview">9.1.7.3. Source file list / functional overview</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/driver-api/media/drivers/pvrusb2.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/driver-api/media/drivers/pvrusb2.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>