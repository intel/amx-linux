
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Driver Basics &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Device drivers infrastructure" href="infrastructure.html" />
    <link rel="prev" title="Porting Drivers to the New Driver Model" href="driver-model/porting.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="driver-basics">
<h1>Driver Basics<a class="headerlink" href="#driver-basics" title="Permalink to this headline">¶</a></h1>
<section id="driver-entry-and-exit-points">
<h2>Driver Entry and Exit points<a class="headerlink" href="#driver-entry-and-exit-points" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.module_init">
<code class="sig-name descname">module_init</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_init" title="Permalink to this definition">¶</a></dt>
<dd><p>driver initialization entry point</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>function to be run at kernel boot time or module insertion</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> will either be called during do_initcalls() (if
builtin) or at module insertion time (if a module).  There can only
be one per module.</p>
</div>
<dl class="function">
<dt id="c.module_exit">
<code class="sig-name descname">module_exit</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>driver exit entry point</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>function to be run when driver is removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a> will wrap the driver clean-up code
with cleanup_module() when used with rmmod when
the driver is a module.  If the driver is statically
compiled into the kernel, <a class="reference internal" href="#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a> has no effect.
There can only be one per module.</p>
</div>
</section>
<section id="driver-device-table">
<h2>Driver device table<a class="headerlink" href="#driver-device-table" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.usb_device_id">
struct <code class="sig-name descname">usb_device_id</code><a class="headerlink" href="#c.usb_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>identifies USB devices for probing and hotplugging</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct usb_device_id {
    __u16 match_flags;
    __u16 idVendor;
    __u16 idProduct;
    __u16 bcdDevice_lo;
    __u16 bcdDevice_hi;
    __u8 bDeviceClass;
    __u8 bDeviceSubClass;
    __u8 bDeviceProtocol;
    __u8 bInterfaceClass;
    __u8 bInterfaceSubClass;
    __u8 bInterfaceProtocol;
    __u8 bInterfaceNumber;
    kernel_ulong_t driver_info ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">match_flags</span></code></dt><dd><p>Bit mask controlling which of the other fields are used to
match against new devices. Any field except for driver_info may be
used, although some only make sense in conjunction with other fields.
This is usually set by a USB_DEVICE_*() macro, which sets all
other fields in this structure except for driver_info.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idVendor</span></code></dt><dd><p>USB vendor ID for a device; numbers are assigned
by the USB forum to its members.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">idProduct</span></code></dt><dd><p>Vendor-assigned product ID.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bcdDevice_lo</span></code></dt><dd><p>Low end of range of vendor-assigned product version numbers.
This is also used to identify individual product versions, for
a range consisting of a single device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bcdDevice_hi</span></code></dt><dd><p>High end of version number range.  The range of product
versions is inclusive.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bDeviceClass</span></code></dt><dd><p>Class of device; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Device classes specify behavior of all
the interfaces on a device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bDeviceSubClass</span></code></dt><dd><p>Subclass of device; associated with bDeviceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bDeviceProtocol</span></code></dt><dd><p>Protocol of device; associated with bDeviceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceClass</span></code></dt><dd><p>Class of interface; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Interface classes specify behavior only
of a given interface; other interfaces may support other classes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceSubClass</span></code></dt><dd><p>Subclass of interface; associated with bInterfaceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceProtocol</span></code></dt><dd><p>Protocol of interface; associated with bInterfaceClass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bInterfaceNumber</span></code></dt><dd><p>Number of interface; composite devices may use
fixed interface numbers to differentiate between vendor-specific
interfaces.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_info</span></code></dt><dd><p>Holds information used by the driver.  Usually it holds
a pointer to a descriptor understood by the driver, or perhaps
device flags.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>In most cases, drivers will create a table of device IDs by using
<a class="reference internal" href="usb/usb.html#c.USB_DEVICE" title="USB_DEVICE"><code class="xref c c-func docutils literal notranslate"><span class="pre">USB_DEVICE()</span></code></a>, or similar macros designed for that purpose.
They will then export it to userspace using MODULE_DEVICE_TABLE(),
and provide it to the USB core through their usb_driver structure.</p>
<p>See the <a class="reference internal" href="usb/usb.html#c.usb_match_id" title="usb_match_id"><code class="xref c c-func docutils literal notranslate"><span class="pre">usb_match_id()</span></code></a> function for information about how matches are
performed.  Briefly, you will normally use one of several macros to help
construct these entries.  Each entry you provide will either identify
one or more specific products, or will identify a class of products
which have agreed to behave the same.  You should put the more specific
matches towards the beginning of your table, so that driver_info can
record quirks of specific products.</p>
<dl class="type">
<dt id="c.mdio_device_id">
struct <code class="sig-name descname">mdio_device_id</code><a class="headerlink" href="#c.mdio_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>identifies PHY devices on an MDIO/MII bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mdio_device_id {
    __u32 phy_id;
    __u32 phy_id_mask;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phy_id</span></code></dt><dd><p>The result of
(mdio_read(<code class="xref c c-type docutils literal notranslate"><span class="pre">MII_PHYSID1</span></code>) &lt;&lt; 16 | mdio_read(<code class="xref c c-type docutils literal notranslate"><span class="pre">MII_PHYSID2</span></code>)) &amp; <strong>phy_id_mask</strong>
for this PHY type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_id_mask</span></code></dt><dd><p>Defines the significant bits of <strong>phy_id</strong>.  A value of 0
is used to terminate an array of <a class="reference internal" href="#c.mdio_device_id" title="mdio_device_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device_id</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.amba_id">
struct <code class="sig-name descname">amba_id</code><a class="headerlink" href="#c.amba_id" title="Permalink to this definition">¶</a></dt>
<dd><p>identifies a device on an AMBA bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct amba_id {
    unsigned int            id;
    unsigned int            mask;
    void *data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>The significant bits if the hardware device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>Bitmask specifying which bits of the id field are significant when
matching.  A driver binds to a device when ((hardware device ID) &amp; mask)
== id.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Private data used by the driver.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.mips_cdmm_device_id">
struct <code class="sig-name descname">mips_cdmm_device_id</code><a class="headerlink" href="#c.mips_cdmm_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>identifies devices in MIPS CDMM bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mips_cdmm_device_id {
    __u8 type;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Device type identifier.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.mei_cl_device_id">
struct <code class="sig-name descname">mei_cl_device_id</code><a class="headerlink" href="#c.mei_cl_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>MEI client device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mei_cl_device_id {
    char name[MEI_CL_NAME_SIZE];
    uuid_le uuid;
    __u8 version;
    kernel_ulong_t driver_info;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>helper name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uuid</span></code></dt><dd><p>client uuid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">version</span></code></dt><dd><p>client protocol version</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_info</span></code></dt><dd><p>information used by the driver.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>identifies mei client device by uuid and name</p>
<dl class="type">
<dt id="c.rio_device_id">
struct <code class="sig-name descname">rio_device_id</code><a class="headerlink" href="#c.rio_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>RIO device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct rio_device_id {
    __u16 did, vid;
    __u16 asm_did, asm_vid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">did</span></code></dt><dd><p>RapidIO device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vid</span></code></dt><dd><p>RapidIO vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">asm_did</span></code></dt><dd><p>RapidIO assembly device ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">asm_vid</span></code></dt><dd><p>RapidIO assembly vendor ID</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Identifies a RapidIO device based on both the device/vendor IDs and
the assembly device/vendor IDs.</p>
<dl class="type">
<dt id="c.fsl_mc_device_id">
struct <code class="sig-name descname">fsl_mc_device_id</code><a class="headerlink" href="#c.fsl_mc_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>MC object device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fsl_mc_device_id {
    __u16 vendor;
    const char obj_type[16];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">vendor</span></code></dt><dd><p>vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">obj_type</span></code></dt><dd><p>MC object type</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Type of entries in the “device Id” table for MC object devices supported by
a MC object device driver. The last entry of the table has vendor set to 0x0</p>
<dl class="type">
<dt id="c.tb_service_id">
struct <code class="sig-name descname">tb_service_id</code><a class="headerlink" href="#c.tb_service_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Thunderbolt service identifiers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tb_service_id {
    __u32 match_flags;
    char protocol_key[8 + 1];
    __u32 protocol_id;
    __u32 protocol_version;
    __u32 protocol_revision;
    kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">match_flags</span></code></dt><dd><p>Flags used to match the structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_key</span></code></dt><dd><p>Protocol key the service supports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_id</span></code></dt><dd><p>Protocol id the service supports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_version</span></code></dt><dd><p>Version of the protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol_revision</span></code></dt><dd><p>Revision of the protocol software</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>Driver specific data</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Thunderbolt XDomain services are exposed as devices where each device
carries the protocol information the service supports. Thunderbolt
XDomain service drivers match against that information.</p>
<dl class="type">
<dt id="c.typec_device_id">
struct <code class="sig-name descname">typec_device_id</code><a class="headerlink" href="#c.typec_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>USB Type-C alternate mode identifiers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct typec_device_id {
    __u16 svid;
    __u8 mode;
    kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">svid</span></code></dt><dd><p>Standard or Vendor ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>Mode index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>Driver specific data</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.tee_client_device_id">
struct <code class="sig-name descname">tee_client_device_id</code><a class="headerlink" href="#c.tee_client_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>tee based device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tee_client_device_id {
    uuid_t uuid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uuid</span></code></dt><dd><p>For TEE based client devices we use the device uuid as
the identifier.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.wmi_device_id">
struct <code class="sig-name descname">wmi_device_id</code><a class="headerlink" href="#c.wmi_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>WMI device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct wmi_device_id {
    const char guid_string[UUID_STRING_LEN+1];
    const void *context;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">guid_string</span></code></dt><dd><p>36 char string of the form fa50ff2b-f2e8-45de-83fa-65417f2f49ba</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">context</span></code></dt><dd><p>pointer to driver specific data</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.mhi_device_id">
struct <code class="sig-name descname">mhi_device_id</code><a class="headerlink" href="#c.mhi_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>MHI device identification</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mhi_device_id {
    const char chan[MHI_NAME_SIZE];
    kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">chan</span></code></dt><dd><p>MHI channel name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>driver data;</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.dfl_device_id">
struct <code class="sig-name descname">dfl_device_id</code><a class="headerlink" href="#c.dfl_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>dfl device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dfl_device_id {
    __u16 type;
    __u16 feature_id;
    kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>DFL FIU type of the device. See enum dfl_id_type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">feature_id</span></code></dt><dd><p>feature identifier local to its DFL FIU type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>driver specific data.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.ishtp_device_id">
struct <code class="sig-name descname">ishtp_device_id</code><a class="headerlink" href="#c.ishtp_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>ISHTP device identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ishtp_device_id {
    guid_t guid;
    kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">guid</span></code></dt><dd><p>GUID of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>pointer to driver specific data</p>
</dd>
</dl>
</div>
</section>
<section id="delaying-scheduling-and-timer-routines">
<h2>Delaying, scheduling, and timer routines<a class="headerlink" href="#delaying-scheduling-and-timer-routines" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.prev_cputime">
struct <code class="sig-name descname">prev_cputime</code><a class="headerlink" href="#c.prev_cputime" title="Permalink to this definition">¶</a></dt>
<dd><p>snapshot of system and user cputime</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct prev_cputime {
#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE;
    u64 utime;
    u64 stime;
    raw_spinlock_t lock;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">utime</span></code></dt><dd><p>time spent in user mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stime</span></code></dt><dd><p>time spent in system mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>protects the above two fields</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Stores previous user/system time values such that we can guarantee
monotonicity.</p>
<dl class="type">
<dt id="c.util_est">
struct <code class="sig-name descname">util_est</code><a class="headerlink" href="#c.util_est" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimation utilization of FAIR tasks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct util_est {
    unsigned int                    enqueued;
    unsigned int                    ewma;
#define UTIL_EST_WEIGHT_SHIFT           2;
#define UTIL_AVG_UNCHANGED              0x80000000;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enqueued</span></code></dt><dd><p>instantaneous estimated utilization of a task/cpu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ewma</span></code></dt><dd><p>the Exponential Weighted Moving Average (EWMA)
utilization of a task</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Support data structure to track an Exponential Weighted Moving Average
(EWMA) of a FAIR task’s utilization. New samples are added to the moving
average each time a task completes an activation. Sample’s weight is chosen
so that the EWMA will be relatively insensitive to transient changes to the
task’s workload.</p>
<p>The enqueued attribute has a slightly different meaning for tasks and cpus:
- task:   the task’s util_avg at last task dequeue time
- cfs_rq: the sum of util_est.enqueued for each RUNNABLE task on that CPU
Thus, the util_est.enqueued of a task represents the contribution on the
estimated utilization of the CPU where that task is currently enqueued.</p>
<p>Only for tasks we track a moving average of the past instantaneous
estimated utilization. This allows to absorb sporadic drops in utilization
of an otherwise almost periodic task.</p>
<p>The UTIL_AVG_UNCHANGED flag is used to synchronize util_est with util_avg
updates. When a task is dequeued, its util_est should not be updated if its
util_avg has not been updated in the meantime.
This information is mapped into the MSB bit of util_est.enqueued at dequeue
time. Since max value of util_est.enqueued for a task is 1024 (PELT util_avg
for a task) it is safe to use MSB.</p>
<dl class="function">
<dt id="c.pid_alive">
int <code class="sig-name descname">pid_alive</code><span class="sig-paren">(</span>const struct task_struct<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pid_alive" title="Permalink to this definition">¶</a></dt>
<dd><p>check that a task structure is not stale</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>Task structure to be checked.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test if a process is not yet dead (at most zombie state)
If pid_alive fails, then pointers within the task structure
can be stale and must not be dereferenced.</p>
<p><strong>Return</strong></p>
<p>1 if the process is alive. 0 otherwise.</p>
</div>
<dl class="function">
<dt id="c.is_global_init">
int <code class="sig-name descname">is_global_init</code><span class="sig-paren">(</span>struct task_struct<em> *tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_global_init" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a task structure is init. Since init is free to have sub-threads we need to check tgid.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>Task structure to be checked.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if a task structure is the first user space task the kernel created.</p>
<p><strong>Return</strong></p>
<p>1 if the task structure is init. 0 otherwise.</p>
</div>
<dl class="function">
<dt id="c.task_nice">
int <code class="sig-name descname">task_nice</code><span class="sig-paren">(</span>const struct task_struct<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_nice" title="Permalink to this definition">¶</a></dt>
<dd><p>return the nice value of a given task.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>the task in question.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The nice value [ -20 … 0 … 19 ].</p>
</div>
<dl class="function">
<dt id="c.is_idle_task">
bool <code class="sig-name descname">is_idle_task</code><span class="sig-paren">(</span>const struct task_struct<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_idle_task" title="Permalink to this definition">¶</a></dt>
<dd><p>is the specified task an idle task?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>the task in question.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if <strong>p</strong> is an idle task. 0 otherwise.</p>
</div>
<dl class="function">
<dt id="c.wake_up_process">
int <code class="sig-name descname">wake_up_process</code><span class="sig-paren">(</span>struct task_struct<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wake_up_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Wake up a specific process</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>The process to be woken up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to wake up the nominated process and move it to the set of runnable
processes.</p>
<p>This function executes a full memory barrier before accessing the task state.</p>
<p><strong>Return</strong></p>
<p>1 if the process was woken up, 0 if it was already running.</p>
</div>
<dl class="function">
<dt id="c.preempt_notifier_register">
void <code class="sig-name descname">preempt_notifier_register</code><span class="sig-paren">(</span>struct preempt_notifier<em> *notifier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_notifier_register" title="Permalink to this definition">¶</a></dt>
<dd><p>tell me when current is being preempted &amp; rescheduled</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">preempt_notifier</span> <span class="pre">*notifier</span></code></dt><dd><p>notifier struct to register</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.preempt_notifier_unregister">
void <code class="sig-name descname">preempt_notifier_unregister</code><span class="sig-paren">(</span>struct preempt_notifier<em> *notifier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_notifier_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>no longer interested in preemption notifications</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">preempt_notifier</span> <span class="pre">*notifier</span></code></dt><dd><p>notifier struct to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is <em>not</em> safe to call from within a preemption notifier.</p>
</div>
<dl class="function">
<dt id="c.preempt_schedule_notrace">
__visible void notrace <code class="sig-name descname">preempt_schedule_notrace</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_schedule_notrace" title="Permalink to this definition">¶</a></dt>
<dd><p>preempt_schedule called by tracing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The tracing infrastructure uses preempt_enable_notrace to prevent
recursion and tracing preempt enabling caused by the tracing
infrastructure itself. But as tracing can happen in areas coming
from userspace or just about to enter userspace, a preempt enable
can occur before user_exit() is called. This will cause the scheduler
to be called when the system is still in usermode.</p>
<p>To prevent this, the preempt_enable_notrace will use this function
instead of preempt_schedule() to exit user context if needed before
calling the scheduler.</p>
</div>
<dl class="function">
<dt id="c.yield">
void <code class="sig-name descname">yield</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.yield" title="Permalink to this definition">¶</a></dt>
<dd><p>yield the current processor to other threads.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not ever use this function, there’s a 99% chance you’re doing it wrong.</p>
<p>The scheduler is at all times free to pick the calling task as the most
eligible task to run, if removing the <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a> call from your code breaks
it, it’s already broken.</p>
<p>Typical broken usage is:</p>
<dl class="simple">
<dt>while (!event)</dt><dd><p><a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a>;</p>
</dd>
</dl>
<p>where one assumes that <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a> will let ‘the other’ process run that will
make event true. If the current task is a SCHED_FIFO task that will never
happen. Never use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a> as a progress guarantee!!</p>
<p>If you want to use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a> to wait for something, use <a class="reference internal" href="#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_event()</span></code></a>.
If you want to use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a> to be ‘nice’ for others, use cond_resched().
If you still want to use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal notranslate"><span class="pre">yield()</span></code></a>, do not!</p>
</div>
<dl class="function">
<dt id="c.yield_to">
int <code class="sig-name descname">yield_to</code><span class="sig-paren">(</span>struct task_struct<em> *p</em>, bool<em> preempt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.yield_to" title="Permalink to this definition">¶</a></dt>
<dd><p>yield the current processor to another thread in your thread group, or accelerate that thread toward the processor it’s on.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">preempt</span></code></dt><dd><p>whether task preemption is allowed or not</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It’s the caller’s job to ensure that the target task struct
can’t go away on us before we can do any checks.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>true (&gt;0) if we indeed boosted the target task.
false (0) if we failed to boost the target.
-ESRCH if there’s no task to yield to.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.cpupri_find_fitness">
int <code class="sig-name descname">cpupri_find_fitness</code><span class="sig-paren">(</span>struct cpupri<em> *cp</em>, struct task_struct<em> *p</em>, struct cpumask<em> *lowest_mask</em>, bool (<em>*fitness_fn</em>)(struct task_struct *p, int cpu)<span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_find_fitness" title="Permalink to this definition">¶</a></dt>
<dd><p>find the best (lowest-pri) CPU in the system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>The task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpumask</span> <span class="pre">*lowest_mask</span></code></dt><dd><p>A mask to fill in with selected CPUs (or NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">(*fitness_fn)(struct</span> <span class="pre">task_struct</span> <span class="pre">*p,</span> <span class="pre">int</span> <span class="pre">cpu)</span></code></dt><dd><p>A pointer to a function to do custom checks whether the CPU
fits a specific criteria so that we only return those CPUs.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function returns the recommended CPUs as calculated during the
current invocation.  By the time the call returns, the CPUs may have in
fact changed priorities any number of times.  While not ideal, it is not
an issue of correctness since the normal rebalancer logic will correct
any discrepancies created by racing against the uncertainty of the current
priority configuration.</p>
<p><strong>Return</strong></p>
<p>(int)bool - CPUs were found</p>
</div>
<dl class="function">
<dt id="c.cpupri_set">
void <code class="sig-name descname">cpupri_set</code><span class="sig-paren">(</span>struct cpupri<em> *cp</em>, int<em> cpu</em>, int<em> newpri</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_set" title="Permalink to this definition">¶</a></dt>
<dd><p>update the CPU priority setting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>The target CPU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">newpri</span></code></dt><dd><p>The priority (INVALID,NORMAL,RT1-RT99,HIGHER) to assign to this CPU</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>Assumes cpu_rq(cpu)-&gt;lock is locked</p>
<p><strong>Return</strong></p>
<p>(void)</p>
</div>
<dl class="function">
<dt id="c.cpupri_init">
int <code class="sig-name descname">cpupri_init</code><span class="sig-paren">(</span>struct cpupri<em> *cp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the cpupri structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>-ENOMEM on memory allocation failure.</p>
</div>
<dl class="function">
<dt id="c.cpupri_cleanup">
void <code class="sig-name descname">cpupri_cleanup</code><span class="sig-paren">(</span>struct cpupri<em> *cp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>clean up the cpupri structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*cp</span></code></dt><dd><p>The cpupri context</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.update_tg_load_avg">
void <code class="sig-name descname">update_tg_load_avg</code><span class="sig-paren">(</span>struct cfs_rq<em> *cfs_rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_tg_load_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>update the tg’s load avg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>the cfs_rq whose avg changed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function ‘ensures’: tg-&gt;load_avg := Sum tg-&gt;cfs_rq[]-&gt;avg.load.
However, because tg-&gt;load_avg is a global value there are performance
considerations.</p>
<p>In order to avoid having to look at the other cfs_rq’s, we use a
differential update where we store the last value we propagated. This in
turn allows skipping updates if the differential is ‘small’.</p>
<p>Updating tg’s load_avg is necessary before update_cfs_share().</p>
</div>
<dl class="function">
<dt id="c.update_cfs_rq_load_avg">
int <code class="sig-name descname">update_cfs_rq_load_avg</code><span class="sig-paren">(</span>u64<em> now</em>, struct cfs_rq<em> *cfs_rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_cfs_rq_load_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>update the cfs_rq’s load/util averages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">now</span></code></dt><dd><p>current time, as per cfs_rq_clock_pelt()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>cfs_rq to update</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The cfs_rq avg is the direct sum of all its entities (blocked and runnable)
avg. The immediate corollary is that all (fair) tasks must be attached.</p>
<p>cfs_rq-&gt;avg is used for task_h_load() and update_cfs_share() for example.</p>
<p>Since both these conditions indicate a changed cfs_rq-&gt;avg.load we should
call <a class="reference internal" href="#c.update_tg_load_avg" title="update_tg_load_avg"><code class="xref c c-func docutils literal notranslate"><span class="pre">update_tg_load_avg()</span></code></a> when this function returns true.</p>
<p><strong>Return</strong></p>
<p>true if the load decayed or we removed load.</p>
</div>
<dl class="function">
<dt id="c.attach_entity_load_avg">
void <code class="sig-name descname">attach_entity_load_avg</code><span class="sig-paren">(</span>struct cfs_rq<em> *cfs_rq</em>, struct sched_entity<em> *se</em><span class="sig-paren">)</span><a class="headerlink" href="#c.attach_entity_load_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>attach this entity to its cfs_rq load avg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>cfs_rq to attach to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_entity</span> <span class="pre">*se</span></code></dt><dd><p>sched_entity to attach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must call <a class="reference internal" href="#c.update_cfs_rq_load_avg" title="update_cfs_rq_load_avg"><code class="xref c c-func docutils literal notranslate"><span class="pre">update_cfs_rq_load_avg()</span></code></a> before this, since we rely on
cfs_rq-&gt;avg.last_update_time being current.</p>
</div>
<dl class="function">
<dt id="c.detach_entity_load_avg">
void <code class="sig-name descname">detach_entity_load_avg</code><span class="sig-paren">(</span>struct cfs_rq<em> *cfs_rq</em>, struct sched_entity<em> *se</em><span class="sig-paren">)</span><a class="headerlink" href="#c.detach_entity_load_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>detach this entity from its cfs_rq load avg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*cfs_rq</span></code></dt><dd><p>cfs_rq to detach from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_entity</span> <span class="pre">*se</span></code></dt><dd><p>sched_entity to detach</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must call <a class="reference internal" href="#c.update_cfs_rq_load_avg" title="update_cfs_rq_load_avg"><code class="xref c c-func docutils literal notranslate"><span class="pre">update_cfs_rq_load_avg()</span></code></a> before this, since we rely on
cfs_rq-&gt;avg.last_update_time being current.</p>
</div>
<dl class="function">
<dt id="c.asym_smt_can_pull_tasks">
bool <code class="sig-name descname">asym_smt_can_pull_tasks</code><span class="sig-paren">(</span>int<em> dst_cpu</em>, struct sd_lb_stats<em> *sds</em>, struct sg_lb_stats<em> *sgs</em>, struct sched_group<em> *sg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.asym_smt_can_pull_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the load balancing CPU can pull tasks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dst_cpu</span></code></dt><dd><p>Destination CPU of the load balancing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>Load-balancing data with statistics of the local group</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_lb_stats</span> <span class="pre">*sgs</span></code></dt><dd><p>Load-balancing statistics of the candidate busiest group</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_group</span> <span class="pre">*sg</span></code></dt><dd><p>The candidate busiest group</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the state of the SMT siblings of both <strong>sds</strong>::local and <strong>sg</strong> and decide
if <strong>dst_cpu</strong> can pull tasks.</p>
<p>If <strong>dst_cpu</strong> does not have SMT siblings, it can pull tasks if two or more of
the SMT siblings of <strong>sg</strong> are busy. If only one CPU in <strong>sg</strong> is busy, pull tasks
only if <strong>dst_cpu</strong> has higher priority.</p>
<p>If both <strong>dst_cpu</strong> and <strong>sg</strong> have SMT siblings, and <strong>sg</strong> has exactly one more
busy CPU than <strong>sds</strong>::local, let <strong>dst_cpu</strong> pull tasks if it has higher priority.
Bigger imbalances in the number of busy CPUs will be dealt with in
<a class="reference internal" href="#c.update_sd_pick_busiest" title="update_sd_pick_busiest"><code class="xref c c-func docutils literal notranslate"><span class="pre">update_sd_pick_busiest()</span></code></a>.</p>
<p>If <strong>sg</strong> does not have SMT siblings, only pull tasks if all of the SMT siblings
of <strong>dst_cpu</strong> are idle and <strong>sg</strong> has lower priority.</p>
<p><strong>Return</strong></p>
<p>true if <strong>dst_cpu</strong> can pull tasks, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.update_sg_lb_stats">
void <code class="sig-name descname">update_sg_lb_stats</code><span class="sig-paren">(</span>struct lb_env<em> *env</em>, struct sd_lb_stats<em> *sds</em>, struct sched_group<em> *group</em>, struct sg_lb_stats<em> *sgs</em>, int<em> *sg_status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sg_lb_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Update sched_group’s statistics for load balancing.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>Load-balancing data with statistics of the local group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_group</span> <span class="pre">*group</span></code></dt><dd><p>sched_group whose statistics are to be updated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_lb_stats</span> <span class="pre">*sgs</span></code></dt><dd><p>variable to hold the statistics for this group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*sg_status</span></code></dt><dd><p>Holds flag indicating the status of the sched_group</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.update_sd_pick_busiest">
bool <code class="sig-name descname">update_sd_pick_busiest</code><span class="sig-paren">(</span>struct lb_env<em> *env</em>, struct sd_lb_stats<em> *sds</em>, struct sched_group<em> *sg</em>, struct sg_lb_stats<em> *sgs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sd_pick_busiest" title="Permalink to this definition">¶</a></dt>
<dd><p>return 1 on busiest group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>sched_domain statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sched_group</span> <span class="pre">*sg</span></code></dt><dd><p>sched_group candidate to be checked for being the busiest</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sg_lb_stats</span> <span class="pre">*sgs</span></code></dt><dd><p>sched_group statistics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if <strong>sg</strong> is a busier group than the previously selected
busiest group.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>sg</strong> is a busier group than the previously selected
busiest group. <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.idle_cpu_without">
int <code class="sig-name descname">idle_cpu_without</code><span class="sig-paren">(</span>int<em> cpu</em>, struct task_struct<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idle_cpu_without" title="Permalink to this definition">¶</a></dt>
<dd><p>would a given CPU be idle without p ?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor on which idleness is tested.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task which should be ignored.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the CPU would be idle. 0 otherwise.</p>
</div>
<dl class="function">
<dt id="c.update_sd_lb_stats">
void <code class="sig-name descname">update_sd_lb_stats</code><span class="sig-paren">(</span>struct lb_env<em> *env</em>, struct sd_lb_stats<em> *sds</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sd_lb_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Update sched_domain’s statistics for load balancing.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>variable to hold the statistics for this sched_domain.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.calculate_imbalance">
void <code class="sig-name descname">calculate_imbalance</code><span class="sig-paren">(</span>struct lb_env<em> *env</em>, struct sd_lb_stats<em> *sds</em><span class="sig-paren">)</span><a class="headerlink" href="#c.calculate_imbalance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the amount of imbalance present within the groups of a given sched_domain during load balance.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>load balance environment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*sds</span></code></dt><dd><p>statistics of the sched_domain whose imbalance is to be calculated.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.find_busiest_group">
struct sched_group * <code class="sig-name descname">find_busiest_group</code><span class="sig-paren">(</span>struct lb_env<em> *env</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_busiest_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the busiest group within the sched_domain if there is an imbalance.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*env</span></code></dt><dd><p>The load balancing environment.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Also calculates the amount of runnable load which should be moved
to restore balance.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>The busiest group if imbalance exists.</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.DECLARE_COMPLETION">
<code class="sig-name descname">DECLARE_COMPLETION</code><span class="sig-paren">(</span><em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_COMPLETION" title="Permalink to this definition">¶</a></dt>
<dd><p>declare and initialize a completion structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>identifier for the completion structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro declares and initializes a completion structure. Generally used
for static declarations. You should use the _ONSTACK variant for automatic
variables.</p>
</div>
<dl class="function">
<dt id="c.DECLARE_COMPLETION_ONSTACK">
<code class="sig-name descname">DECLARE_COMPLETION_ONSTACK</code><span class="sig-paren">(</span><em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_COMPLETION_ONSTACK" title="Permalink to this definition">¶</a></dt>
<dd><p>declare and initialize a completion structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>identifier for the completion structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro declares and initializes a completion structure on the kernel
stack.</p>
</div>
<dl class="function">
<dt id="c.init_completion">
void <code class="sig-name descname">init_completion</code><span class="sig-paren">(</span>struct completion<em> *x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_completion" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a dynamically allocated completion</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">completion</span> <span class="pre">*x</span></code></dt><dd><p>pointer to completion structure that is to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This inline function will initialize a dynamically created completion
structure.</p>
</div>
<dl class="function">
<dt id="c.reinit_completion">
void <code class="sig-name descname">reinit_completion</code><span class="sig-paren">(</span>struct completion<em> *x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reinit_completion" title="Permalink to this definition">¶</a></dt>
<dd><p>reinitialize a completion structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">completion</span> <span class="pre">*x</span></code></dt><dd><p>pointer to completion structure that is to be reinitialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This inline function should be used to reinitialize a completion structure so it can
be reused. This is especially important after complete_all() is used.</p>
</div>
<dl class="function">
<dt id="c.__round_jiffies">
unsigned long <code class="sig-name descname">__round_jiffies</code><span class="sig-paren">(</span>unsigned long<em> j</em>, int<em> cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (absolute) jiffies that should be rounded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor number on which the timeout will happen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.__round_jiffies" title="__round_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">__round_jiffies()</span></code></a> rounds an absolute time in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The exact rounding is skewed for each processor to avoid all
processors firing at the exact same time, which could lead
to lock contention or spurious cache line bouncing.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
</div>
<dl class="function">
<dt id="c.__round_jiffies_relative">
unsigned long <code class="sig-name descname">__round_jiffies_relative</code><span class="sig-paren">(</span>unsigned long<em> j</em>, int<em> cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies_relative" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor number on which the timeout will happen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.__round_jiffies_relative" title="__round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">__round_jiffies_relative()</span></code></a> rounds a time delta  in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The exact rounding is skewed for each processor to avoid all
processors firing at the exact same time, which could lead
to lock contention or spurious cache line bouncing.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
</div>
<dl class="function">
<dt id="c.round_jiffies">
unsigned long <code class="sig-name descname">round_jiffies</code><span class="sig-paren">(</span>unsigned long<em> j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (absolute) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.round_jiffies" title="round_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies()</span></code></a> rounds an absolute time in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
</div>
<dl class="function">
<dt id="c.round_jiffies_relative">
unsigned long <code class="sig-name descname">round_jiffies_relative</code><span class="sig-paren">(</span>unsigned long<em> j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_relative" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.round_jiffies_relative" title="round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies_relative()</span></code></a> rounds a time delta  in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
</div>
<dl class="function">
<dt id="c.__round_jiffies_up">
unsigned long <code class="sig-name descname">__round_jiffies_up</code><span class="sig-paren">(</span>unsigned long<em> j</em>, int<em> cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies_up" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (absolute) jiffies that should be rounded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor number on which the timeout will happen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.__round_jiffies" title="__round_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">__round_jiffies()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don’t fire too
early.</p>
</div>
<dl class="function">
<dt id="c.__round_jiffies_up_relative">
unsigned long <code class="sig-name descname">__round_jiffies_up_relative</code><span class="sig-paren">(</span>unsigned long<em> j</em>, int<em> cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies_up_relative" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>the processor number on which the timeout will happen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.__round_jiffies_relative" title="__round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">__round_jiffies_relative()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don’t fire too
early.</p>
</div>
<dl class="function">
<dt id="c.round_jiffies_up">
unsigned long <code class="sig-name descname">round_jiffies_up</code><span class="sig-paren">(</span>unsigned long<em> j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_up" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (absolute) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.round_jiffies" title="round_jiffies"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don’t fire too
early.</p>
</div>
<dl class="function">
<dt id="c.round_jiffies_up_relative">
unsigned long <code class="sig-name descname">round_jiffies_up_relative</code><span class="sig-paren">(</span>unsigned long<em> j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_up_relative" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>the time in (relative) jiffies that should be rounded</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.round_jiffies_relative" title="round_jiffies_relative"><code class="xref c c-func docutils literal notranslate"><span class="pre">round_jiffies_relative()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don’t fire too
early.</p>
</div>
<dl class="function">
<dt id="c.init_timer_key">
void <code class="sig-name descname">init_timer_key</code><span class="sig-paren">(</span>struct timer_list<em> *timer</em>, void (<em>*func</em>)(struct timer_list *), unsigned int<em> flags</em>, const char<em> *name</em>, struct lock_class_key<em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_timer_key" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*func)(struct</span> <span class="pre">timer_list</span> <span class="pre">*)</span></code></dt><dd><p>timer callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>timer flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*key</span></code></dt><dd><p>lockdep class key of the fake lock used for tracking timer
sync lock dependencies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.init_timer_key" title="init_timer_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">init_timer_key()</span></code></a> must be done to a timer prior calling <em>any</em> of the
other timer functions.</p>
</div>
<dl class="function">
<dt id="c.mod_timer_pending">
int <code class="sig-name descname">mod_timer_pending</code><span class="sig-paren">(</span>struct timer_list<em> *timer</em>, unsigned long<em> expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_timer_pending" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify a pending timer’s timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The pending timer to be modified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt><dd><p>New absolute timeout in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mod_timer_pending" title="mod_timer_pending"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer_pending()</span></code></a> is the same for pending timers as <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a>, but
will not activate inactive timers.</p>
<p>If <strong>timer-&gt;function</strong> == NULL then the start operation is silently
discarded.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was inactive and not modified or was in</dt><dd><p>shutdown state and the operation was discarded</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was active and requeued to expire at <strong>expires</strong></p></li>
</ul>
</div>
<dl class="function">
<dt id="c.mod_timer">
int <code class="sig-name descname">mod_timer</code><span class="sig-paren">(</span>struct timer_list<em> *timer</em>, unsigned long<em> expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify a timer’s timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be modified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt><dd><p>New absolute timeout in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>mod_timer(timer, expires) is equivalent to:</p>
<blockquote>
<div><p>del_timer(timer); timer-&gt;expires = expires; add_timer(timer);</p>
</div></blockquote>
<p><a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a> is more efficient than the above open coded sequence. In
case that the timer is inactive, the del_timer() part is a NOP. The
timer is in any case activated with the new expiry time <strong>expires</strong>.</p>
<p>Note that if there are multiple unserialized concurrent users of the
same timer, then <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a> is the only safe way to modify the timeout,
since <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> cannot modify an already running timer.</p>
<p>If <strong>timer-&gt;function</strong> == NULL then the start operation is silently
discarded. In this case the return value is 0 and meaningless.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was inactive and started or was in shutdown</dt><dd><p>state and the operation was discarded</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was active and requeued to expire at <strong>expires</strong> or</dt><dd><p>the timer was active and not modified because <strong>expires</strong> did
not change the effective expiry time</p>
</dd>
</dl>
</li>
</ul>
</div>
<dl class="function">
<dt id="c.timer_reduce">
int <code class="sig-name descname">timer_reduce</code><span class="sig-paren">(</span>struct timer_list<em> *timer</em>, unsigned long<em> expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify a timer’s timeout if it would reduce the timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be modified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt><dd><p>New absolute timeout in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.timer_reduce" title="timer_reduce"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_reduce()</span></code></a> is very similar to <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">mod_timer()</span></code></a>, except that it will only
modify an enqueued timer if that would reduce the expiration time. If
<strong>timer</strong> is not enqueued it starts the timer.</p>
<p>If <strong>timer-&gt;function</strong> == NULL then the start operation is silently
discarded.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was inactive and started or was in shutdown</dt><dd><p>state and the operation was discarded</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was active and requeued to expire at <strong>expires</strong> or</dt><dd><p>the timer was active and not modified because <strong>expires</strong>
did not change the effective expiry time such that the
timer would expire earlier than already scheduled</p>
</dd>
</dl>
</li>
</ul>
</div>
<dl class="function">
<dt id="c.add_timer">
void <code class="sig-name descname">add_timer</code><span class="sig-paren">(</span>struct timer_list<em> *timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be started</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start <strong>timer</strong> to expire at <strong>timer-&gt;expires</strong> in the future. <strong>timer-&gt;expires</strong>
is the absolute expiry time measured in ‘jiffies’. When the timer expires
timer-&gt;function(timer) will be invoked from soft interrupt context.</p>
<p>The <strong>timer-&gt;expires</strong> and <strong>timer-&gt;function</strong> fields must be set prior
to calling this function.</p>
<p>If <strong>timer-&gt;function</strong> == NULL then the start operation is silently
discarded.</p>
<p>If <strong>timer-&gt;expires</strong> is already in the past <strong>timer</strong> will be queued to
expire at the next timer tick.</p>
<p>This can only operate on an inactive timer. Attempts to invoke this on
an active timer are rejected with a warning.</p>
</div>
<dl class="function">
<dt id="c.add_timer_on">
void <code class="sig-name descname">add_timer_on</code><span class="sig-paren">(</span>struct timer_list<em> *timer</em>, int<em> cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_timer_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a timer on a particular CPU</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be started</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>The CPU to start it on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> except that it starts the timer on the given CPU.</p>
<p>See <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> for further details.</p>
</div>
<dl class="function">
<dt id="c.timer_delete">
int <code class="sig-name descname">timer_delete</code><span class="sig-paren">(</span>struct timer_list<em> *timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Deactivate a timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be deactivated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function only deactivates a pending timer, but contrary to
<a class="reference internal" href="#c.timer_delete_sync" title="timer_delete_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete_sync()</span></code></a> it does not take into account whether the timer’s
callback function is concurrently executed on a different CPU or not.
It neither prevents rearming of the timer.  If <strong>timer</strong> can be rearmed
concurrently then the return value of this function is meaningless.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was not pending</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was pending and deactivated</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.timer_shutdown">
int <code class="sig-name descname">timer_shutdown</code><span class="sig-paren">(</span>struct timer_list<em> *timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Deactivate a timer and prevent rearming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be deactivated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function does not wait for an eventually running timer callback on a
different CPU but it prevents rearming of the timer. Any attempt to arm
<strong>timer</strong> after this function returns will be silently ignored.</p>
<p>This function is useful for teardown code and should only be used when
<a class="reference internal" href="#c.timer_shutdown_sync" title="timer_shutdown_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_shutdown_sync()</span></code></a> cannot be invoked due to locking or context constraints.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was not pending</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was pending</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.try_to_del_timer_sync">
int <code class="sig-name descname">try_to_del_timer_sync</code><span class="sig-paren">(</span>struct timer_list<em> *timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_del_timer_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to deactivate a timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>Timer to deactivate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tries to deactivate a timer. On success the timer is not
queued and the timer callback function is not running on any CPU.</p>
<p>This function does not guarantee that the timer cannot be rearmed right
after dropping the base lock. That needs to be prevented by the calling
code if necessary.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>  - The timer was not pending</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code>  - The timer was pending and deactivated</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code> - The timer callback function is running on a different CPU</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.timer_delete_sync">
int <code class="sig-name descname">timer_delete_sync</code><span class="sig-paren">(</span>struct timer_list<em> *timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_delete_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Deactivate a timer and wait for the handler to finish.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be deactivated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Synchronization rules: Callers must prevent restarting of the timer,
otherwise this function is meaningless. It must not be called from
interrupt contexts unless the timer is an irqsafe one. The caller must
not hold locks which would prevent completion of the timer’s callback
function. The timer’s handler must not call <a class="reference internal" href="#c.add_timer_on" title="add_timer_on"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer_on()</span></code></a>. Upon exit
the timer is not queued and the handler is not running on any CPU.</p>
<p>For !irqsafe timers, the caller must not hold locks that are held in
interrupt context. Even if the lock has nothing to do with the timer in
question.  Here’s why:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU0                             CPU1
----                             ----
                                 &lt;SOFTIRQ&gt;
                                   call_timer_fn();
                                   base-&gt;running_timer = mytimer;
spin_lock_irq(somelock);
                                 &lt;IRQ&gt;
                                    spin_lock(somelock);
timer_delete_sync(mytimer);
while (base-&gt;running_timer == mytimer);
</pre></div>
</div>
<p>Now <a class="reference internal" href="#c.timer_delete_sync" title="timer_delete_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete_sync()</span></code></a> will never return and never release somelock.
The interrupt on the other CPU is waiting to grab somelock but it has
interrupted the softirq that CPU0 is waiting to finish.</p>
<p>This function cannot guarantee that the timer is not rearmed again by
some concurrent or preempting code, right after it dropped the base
lock. If there is the possibility of a concurrent rearm then the return
value of the function is meaningless.</p>
<p>If such a guarantee is needed, e.g. for teardown situations then use
<a class="reference internal" href="#c.timer_shutdown_sync" title="timer_shutdown_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_shutdown_sync()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was not pending</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was pending and deactivated</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.timer_shutdown_sync">
int <code class="sig-name descname">timer_shutdown_sync</code><span class="sig-paren">(</span>struct timer_list<em> *timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_shutdown_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown a timer and prevent rearming</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*timer</span></code></dt><dd><p>The timer to be shutdown</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>When the function returns it is guaranteed that:</dt><dd><ul class="simple">
<li><p><strong>timer</strong> is not queued</p></li>
<li><p>The callback function of <strong>timer</strong> is not running</p></li>
<li><p><strong>timer</strong> cannot be enqueued again. Any attempt to rearm
<strong>timer</strong> is silently ignored.</p></li>
</ul>
</dd>
</dl>
<p>See <a class="reference internal" href="#c.timer_delete_sync" title="timer_delete_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete_sync()</span></code></a> for synchronization rules.</p>
<p>This function is useful for final teardown of an infrastructure where
the timer is subject to a circular dependency problem.</p>
<p>A common pattern for this is a timer and a workqueue where the timer can
schedule work and work can arm the timer. On shutdown the workqueue must
be destroyed and the timer must be prevented from rearming. Unless the
code has conditionals like ‘if (mything-&gt;in_shutdown)’ to prevent that
there is no way to get this correct with <a class="reference internal" href="#c.timer_delete_sync" title="timer_delete_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete_sync()</span></code></a>.</p>
<p><a class="reference internal" href="#c.timer_shutdown_sync" title="timer_shutdown_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_shutdown_sync()</span></code></a> is solving the problem. The correct ordering of
calls in this case is:</p>
<blockquote>
<div><p>timer_shutdown_sync(<code class="xref c c-type docutils literal notranslate"><span class="pre">mything-&gt;timer</span></code>);
workqueue_destroy(<code class="xref c c-type docutils literal notranslate"><span class="pre">mything-&gt;workqueue</span></code>);</p>
</div></blockquote>
<p>After this ‘mything’ can be safely freed.</p>
<p>This obviously implies that the timer is not required to be functional
for the rest of the shutdown operation.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code> - The timer was not pending</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> - The timer was pending</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.schedule_timeout">
signed long <code class="sig-name descname">schedule_timeout</code><span class="sig-paren">(</span>signed long<em> timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt><dd><p>timeout value in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make the current task sleep until <strong>timeout</strong> jiffies have elapsed.
The function behavior depends on the current task state
(see also set_current_state() description):</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_RUNNING</span></code> - the scheduler is called, but the task does not sleep
at all. That happens because sched_submit_work() does nothing for
tasks in <code class="docutils literal notranslate"><span class="pre">TASK_RUNNING</span></code> state.</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_UNINTERRUPTIBLE</span></code> - at least <strong>timeout</strong> jiffies are guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>).</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_INTERRUPTIBLE</span></code> - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.</p>
<p>The current task state is guaranteed to be <code class="docutils literal notranslate"><span class="pre">TASK_RUNNING</span></code> when this
routine returns.</p>
<p>Specifying a <strong>timeout</strong> value of <code class="docutils literal notranslate"><span class="pre">MAX_SCHEDULE_TIMEOUT</span></code> will schedule
the CPU away without a bound on the timeout. In this case the return
value will be <code class="docutils literal notranslate"><span class="pre">MAX_SCHEDULE_TIMEOUT</span></code>.</p>
<p>Returns 0 when the timer has expired otherwise the remaining time in
jiffies will be returned. In all cases the return value is guaranteed
to be non-negative.</p>
</div>
<dl class="function">
<dt id="c.msleep">
void <code class="sig-name descname">msleep</code><span class="sig-paren">(</span>unsigned int<em> msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.msleep" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep safely even with waitqueue interruptions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msecs</span></code></dt><dd><p>Time in milliseconds to sleep for</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.msleep_interruptible">
unsigned long <code class="sig-name descname">msleep_interruptible</code><span class="sig-paren">(</span>unsigned int<em> msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.msleep_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep waiting for signals</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msecs</span></code></dt><dd><p>Time in milliseconds to sleep for</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.usleep_range_state">
void <code class="sig-name descname">usleep_range_state</code><span class="sig-paren">(</span>unsigned long<em> min</em>, unsigned long<em> max</em>, unsigned int<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usleep_range_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Sleep for an approximate time in a given state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt><dd><p>Minimum time in usecs to sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt><dd><p>Maximum time in usecs to sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">state</span></code></dt><dd><p>State of the current task that will be while sleeping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In non-atomic context where the exact wakeup time is flexible, use
<a class="reference internal" href="#c.usleep_range_state" title="usleep_range_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">usleep_range_state()</span></code></a> instead of udelay().  The sleep improves responsiveness
by avoiding the CPU-hogging busy-wait of udelay(), and the range reduces
power usage by allowing hrtimers to take advantage of an already-
scheduled interrupt instead of scheduling a new one just for this sleep.</p>
</div>
</section>
<section id="wait-queues-and-wake-events">
<h2>Wait queues and Wake events<a class="headerlink" href="#wait-queues-and-wake-events" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.waitqueue_active">
int <code class="sig-name descname">waitqueue_active</code><span class="sig-paren">(</span>struct wait_queue_head<em> *wq_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.waitqueue_active" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>locklessly test for waiters on the queue</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue to test for waiters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns true if the wait list is not empty</p>
<p>Use either while holding wait_queue_head::lock or when used for wakeups
with an extra smp_mb() like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU0 - waker                    CPU1 - waiter

                                for (;;) {
@cond = true;                     prepare_to_wait(&amp;wq_head, &amp;wait, state);
smp_mb();                         // smp_mb() from set_current_state()
if (waitqueue_active(wq_head))         if (@cond)
  wake_up(wq_head);                      break;
                                  schedule();
                                }
                                finish_wait(&amp;wq_head, &amp;wait);
</pre></div>
</div>
<p>Because without the explicit smp_mb() it’s possible for the
<a class="reference internal" href="#c.waitqueue_active" title="waitqueue_active"><code class="xref c c-func docutils literal notranslate"><span class="pre">waitqueue_active()</span></code></a> load to get hoisted over the <strong>cond</strong> store such that we’ll
observe an empty wait list while the waiter might not observe <strong>cond</strong>.</p>
<p>Also note that this ‘optimization’ trades a spin_lock() for an smp_mb(),
which (when the lock is uncontended) are of roughly equal cost.</p>
<p><strong>NOTE</strong></p>
<p>this function is lockless and requires care, incorrect usage _will_
lead to sporadic and non-obvious failure.</p>
</div>
<dl class="function">
<dt id="c.wq_has_single_sleeper">
bool <code class="sig-name descname">wq_has_single_sleeper</code><span class="sig-paren">(</span>struct wait_queue_head<em> *wq_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_has_single_sleeper" title="Permalink to this definition">¶</a></dt>
<dd><p>check if there is only one sleeper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>wait queue head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true of wq_head has only one sleeper on the list.</p>
<p>Please refer to the comment for waitqueue_active.</p>
</div>
<dl class="function">
<dt id="c.wq_has_sleeper">
bool <code class="sig-name descname">wq_has_sleeper</code><span class="sig-paren">(</span>struct wait_queue_head<em> *wq_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_has_sleeper" title="Permalink to this definition">¶</a></dt>
<dd><p>check if there are any waiting processes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>wait queue head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if wq_head has waiting processes</p>
<p>Please refer to the comment for waitqueue_active.</p>
</div>
<dl class="function">
<dt id="c.wake_up_pollfree">
void <code class="sig-name descname">wake_up_pollfree</code><span class="sig-paren">(</span>struct wait_queue_head<em> *wq_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wake_up_pollfree" title="Permalink to this definition">¶</a></dt>
<dd><p>signal that a polled waitqueue is going away</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the wait queue head</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In the very rare cases where a -&gt;poll() implementation uses a waitqueue whose
lifetime is tied to a task rather than to the ‘struct file’ being polled,
this function must be called before the waitqueue is freed so that
non-blocking polls (e.g. epoll) are notified that the queue is going away.</p>
<p>The caller must also RCU-delay the freeing of the wait_queue_head, e.g. via
an explicit <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> or <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, or via SLAB_TYPESAFE_BY_RCU.</p>
</div>
<dl class="function">
<dt id="c.wait_event">
<code class="sig-name descname">wait_event</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
</div>
<dl class="function">
<dt id="c.wait_event_freezable">
<code class="sig-name descname">wait_event_freezable</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_freezable" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep (or freeze) until a condition gets true</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE – so as not to contribute
to system load) until the <strong>condition</strong> evaluates to true. The
<strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
</div>
<dl class="function">
<dt id="c.wait_event_timeout">
<code class="sig-name descname">wait_event_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
</div>
<dl class="function">
<dt id="c.wait_event_cmd">
<code class="sig-name descname">wait_event_cmd</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>cmd1</em>, <em>cmd2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd1</span></code></dt><dd><p>the command will be executed before sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd2</span></code></dt><dd><p>the command will be executed after sleep</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
</div>
<dl class="function">
<dt id="c.wait_event_interruptible">
<code class="sig-name descname">wait_event_interruptible</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="function">
<dt id="c.wait_event_interruptible_timeout">
<code class="sig-name descname">wait_event_interruptible_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed, or -<code class="docutils literal notranslate"><span class="pre">ERESTARTSYS</span></code> if it was
interrupted by a signal.</p>
</div>
<dl class="function">
<dt id="c.wait_event_hrtimeout">
<code class="sig-name descname">wait_event_hrtimeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_hrtimeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, as a ktime_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function returns 0 if <strong>condition</strong> became true, or -ETIME if the timeout
elapsed.</p>
</div>
<dl class="function">
<dt id="c.wait_event_interruptible_hrtimeout">
<code class="sig-name descname">wait_event_interruptible_hrtimeout</code><span class="sig-paren">(</span><em>wq</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_hrtimeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, as a ktime_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function returns 0 if <strong>condition</strong> became true, -ERESTARTSYS if it was
interrupted by a signal, or -ETIME if the timeout elapsed.</p>
</div>
<dl class="function">
<dt id="c.wait_event_idle">
<code class="sig-name descname">wait_event_idle</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for a condition without contributing to system load</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
</div>
<dl class="function">
<dt id="c.wait_event_idle_exclusive">
<code class="sig-name descname">wait_event_idle_exclusive</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_idle_exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for a condition with contributing to system load</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus if other processes wait on the same list, when this
process is woken further processes are not considered.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
</div>
<dl class="function">
<dt id="c.wait_event_idle_timeout">
<code class="sig-name descname">wait_event_idle_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_idle_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep without load until a condition becomes true or a timeout elapses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
</div>
<dl class="function">
<dt id="c.wait_event_idle_exclusive_timeout">
<code class="sig-name descname">wait_event_idle_exclusive_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_idle_exclusive_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep without load until a condition becomes true or a timeout elapses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus if other processes wait on the same list, when this
process is woken further processes are not considered.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
</div>
<dl class="function">
<dt id="c.wait_event_interruptible_locked">
<code class="sig-name descname">wait_event_interruptible_locked</code><span class="sig-paren">(</span><em>wq</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock()/spin_unlock()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="function">
<dt id="c.wait_event_interruptible_locked_irq">
<code class="sig-name descname">wait_event_interruptible_locked_irq</code><span class="sig-paren">(</span><em>wq</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_locked_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock_irq()/spin_unlock_irq()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="function">
<dt id="c.wait_event_interruptible_exclusive_locked">
<code class="sig-name descname">wait_event_interruptible_exclusive_locked</code><span class="sig-paren">(</span><em>wq</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_exclusive_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep exclusively until a condition gets true</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock()/spin_unlock()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus when other process waits process on the list if this
process is awaken further processes are not considered.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="function">
<dt id="c.wait_event_interruptible_exclusive_locked_irq">
<code class="sig-name descname">wait_event_interruptible_exclusive_locked_irq</code><span class="sig-paren">(</span><em>wq</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_exclusive_locked_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using spin_lock_irq()/spin_unlock_irq()
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus when other process waits process on the list if this
process is awaken further processes are not considered.</p>
<p>wake_up_locked() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="function">
<dt id="c.wait_event_killable">
<code class="sig-name descname">wait_event_killable</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_killable" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_KILLABLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="function">
<dt id="c.wait_event_state">
<code class="sig-name descname">wait_event_state</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_state" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>state to sleep in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (<strong>state</strong>) until the <strong>condition</strong> evaluates to true
or a signal is received (when allowed by <strong>state</strong>).  The <strong>condition</strong> is checked
each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a signal
(when allowed by <strong>state</strong>) and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="function">
<dt id="c.wait_event_killable_timeout">
<code class="sig-name descname">wait_event_killable_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_killable_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_KILLABLE) until the
<strong>condition</strong> evaluates to true or a kill signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>Only kill signals interrupt this process.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal notranslate"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal notranslate"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed, or -<code class="docutils literal notranslate"><span class="pre">ERESTARTSYS</span></code> if it was
interrupted by a kill signal.</p>
</div>
<dl class="function">
<dt id="c.wait_event_lock_irq_cmd">
<code class="sig-name descname">wait_event_lock_irq_cmd</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>lock</em>, <em>cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_lock_irq_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before cmd
and schedule() and reacquired afterwards.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>a command which is invoked outside the critical section before
sleep</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before invoking the cmd and going to sleep and is reacquired
afterwards.</p>
</div>
<dl class="function">
<dt id="c.wait_event_lock_irq">
<code class="sig-name descname">wait_event_lock_irq</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_lock_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before schedule()
and reacquired afterwards.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
</div>
<dl class="function">
<dt id="c.wait_event_interruptible_lock_irq_cmd">
<code class="sig-name descname">wait_event_interruptible_lock_irq_cmd</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>lock</em>, <em>cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_lock_irq_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before cmd and
schedule() and reacquired afterwards.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cmd</span></code></dt><dd><p>a command which is invoked outside the critical section before
sleep</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before invoking the cmd and going to sleep and is reacquired
afterwards.</p>
<p>The macro will return -ERESTARTSYS if it was interrupted by a signal
and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="function">
<dt id="c.wait_event_interruptible_lock_irq">
<code class="sig-name descname">wait_event_interruptible_lock_irq</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_lock_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before schedule()
and reacquired afterwards.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
<p>The macro will return -ERESTARTSYS if it was interrupted by a signal
and 0 if <strong>condition</strong> evaluated to true.</p>
</div>
<dl class="function">
<dt id="c.wait_event_interruptible_lock_irq_timeout">
<code class="sig-name descname">wait_event_interruptible_lock_irq_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>lock</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_lock_irq_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">wq_head</span></code></dt><dd><p>the waitqueue to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">condition</span></code></dt><dd><p>a C expression for the event to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>a locked spinlock_t, which will be released before schedule()
and reacquired afterwards.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>timeout, in jiffies</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>wake_up() has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
<p>The function returns 0 if the <strong>timeout</strong> elapsed, -ERESTARTSYS if it
was interrupted by a signal, and the remaining jiffies otherwise
if the condition evaluated to true before the timeout elapsed.</p>
</div>
<dl class="function">
<dt id="c.__wake_up">
int <code class="sig-name descname">__wake_up</code><span class="sig-paren">(</span>struct wait_queue_head<em> *wq_head</em>, unsigned int<em> mode</em>, int<em> nr_exclusive</em>, void<em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__wake_up" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up threads blocked on a waitqueue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>which threads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_exclusive</span></code></dt><dd><p>how many wake-one or wake-many threads to wake up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*key</span></code></dt><dd><p>is directly passed to the wakeup function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If this function wakes up a task, it executes a full memory barrier
before accessing the task state.  Returns the number of exclusive
tasks that were awaken.</p>
</div>
<dl class="function">
<dt id="c.__wake_up_sync_key">
void <code class="sig-name descname">__wake_up_sync_key</code><span class="sig-paren">(</span>struct wait_queue_head<em> *wq_head</em>, unsigned int<em> mode</em>, void<em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__wake_up_sync_key" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up threads blocked on a waitqueue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>which threads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*key</span></code></dt><dd><p>opaque value to be passed to wakeup targets</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The sync wakeup differs that the waker knows that it will schedule
away soon, so while the target thread will be woken up, it will not
be migrated to another CPU - ie. the two threads are ‘synchronized’
with each other. This can prevent needless bouncing between CPUs.</p>
<p>On UP it can prevent extra preemption.</p>
<p>If this function wakes up a task, it executes a full memory barrier before
accessing the task state.</p>
</div>
<dl class="function">
<dt id="c.__wake_up_locked_sync_key">
void <code class="sig-name descname">__wake_up_locked_sync_key</code><span class="sig-paren">(</span>struct wait_queue_head<em> *wq_head</em>, unsigned int<em> mode</em>, void<em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__wake_up_locked_sync_key" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up a thread blocked on a locked waitqueue.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>the waitqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>which threads</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*key</span></code></dt><dd><p>opaque value to be passed to wakeup targets</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The sync wakeup differs in that the waker knows that it will schedule
away soon, so while the target thread will be woken up, it will not
be migrated to another CPU - ie. the two threads are ‘synchronized’
with each other. This can prevent needless bouncing between CPUs.</p>
<p>On UP it can prevent extra preemption.</p>
<p>If this function wakes up a task, it executes a full memory barrier before
accessing the task state.</p>
</div>
<dl class="function">
<dt id="c.finish_wait">
void <code class="sig-name descname">finish_wait</code><span class="sig-paren">(</span>struct wait_queue_head<em> *wq_head</em>, struct wait_queue_entry<em> *wq_entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.finish_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>clean up after waiting in a queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*wq_head</span></code></dt><dd><p>waitqueue waited on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_queue_entry</span> <span class="pre">*wq_entry</span></code></dt><dd><p>wait descriptor</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets current thread back to running state and removes
the wait descriptor from the given waitqueue if still
queued.</p>
</div>
</section>
<section id="high-resolution-timers">
<h2>High-resolution timers<a class="headerlink" href="#high-resolution-timers" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.ktime_set">
ktime_t <code class="sig-name descname">ktime_set</code><span class="sig-paren">(</span>const s64<em> secs</em>, const unsigned long<em> nsecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a ktime_t variable from a seconds/nanoseconds value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">s64</span> <span class="pre">secs</span></code></dt><dd><p>seconds to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nsecs</span></code></dt><dd><p>nanoseconds to set</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The ktime_t representation of the value.</p>
</div>
<dl class="function">
<dt id="c.ktime_compare">
int <code class="sig-name descname">ktime_compare</code><span class="sig-paren">(</span>const ktime_t<em> cmp1</em>, const ktime_t<em> cmp2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two ktime_t variables for less, greater or equal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt><dd><p>comparable1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt><dd><p>comparable2</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>…</dt><dd><p>cmp1  &lt; cmp2: return &lt;0
cmp1 == cmp2: return 0
cmp1  &gt; cmp2: return &gt;0</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ktime_after">
bool <code class="sig-name descname">ktime_after</code><span class="sig-paren">(</span>const ktime_t<em> cmp1</em>, const ktime_t<em> cmp2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_after" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare if a ktime_t value is bigger than another one.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt><dd><p>comparable1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt><dd><p>comparable2</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if cmp1 happened after cmp2.</p>
</div>
<dl class="function">
<dt id="c.ktime_before">
bool <code class="sig-name descname">ktime_before</code><span class="sig-paren">(</span>const ktime_t<em> cmp1</em>, const ktime_t<em> cmp2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_before" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare if a ktime_t value is smaller than another one.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt><dd><p>comparable1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt><dd><p>comparable2</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if cmp1 happened before cmp2.</p>
</div>
<dl class="function">
<dt id="c.ktime_to_timespec64_cond">
bool <code class="sig-name descname">ktime_to_timespec64_cond</code><span class="sig-paren">(</span>const ktime_t<em> kt</em>, struct timespec64<em> *ts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_to_timespec64_cond" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a ktime_t variable to timespec64 format only if the variable contains data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">kt</span></code></dt><dd><p>the ktime_t variable to convert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>the timespec variable to store the result in</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if there was a successful conversion, <code class="docutils literal notranslate"><span class="pre">false</span></code> if kt was 0.</p>
</div>
<dl class="type">
<dt id="c.hrtimer">
struct <code class="sig-name descname">hrtimer</code><a class="headerlink" href="#c.hrtimer" title="Permalink to this definition">¶</a></dt>
<dd><p>the basic hrtimer structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hrtimer {
    struct timerqueue_node          node;
    ktime_t _softexpires;
    enum hrtimer_restart            (*function)(struct hrtimer *);
    struct hrtimer_clock_base       *base;
    u8 state;
    u8 is_rel;
    u8 is_soft;
    u8 is_hard;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>timerqueue node, which also manages node.expires,
the absolute expiry time in the hrtimers internal
representation. The time is related to the clock on
which the timer is based. Is setup by adding
slack to the _softexpires value. For non range timers
identical to _softexpires.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_softexpires</span></code></dt><dd><p>the absolute earliest expiry time of the hrtimer.
The time which was given as expiry time when the timer
was armed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function</span></code></dt><dd><p>timer expiry callback function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>pointer to the timer base (per cpu and per clock)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>state information (See bit values above)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_rel</span></code></dt><dd><p>Set if the timer was armed relative</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_soft</span></code></dt><dd><p>Set if hrtimer will be expired in soft interrupt context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_hard</span></code></dt><dd><p>Set if hrtimer will be expired in hard interrupt context
even on RT.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The hrtimer structure must be initialized by <a class="reference internal" href="#c.hrtimer_init" title="hrtimer_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">hrtimer_init()</span></code></a></p>
<dl class="type">
<dt id="c.hrtimer_sleeper">
struct <code class="sig-name descname">hrtimer_sleeper</code><a class="headerlink" href="#c.hrtimer_sleeper" title="Permalink to this definition">¶</a></dt>
<dd><p>simple sleeper structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hrtimer_sleeper {
    struct hrtimer timer;
    struct task_struct *task;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">timer</span></code></dt><dd><p>embedded timer structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task</span></code></dt><dd><p>task to wake up</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>task is set to NULL, when the timer expires.</p>
<dl class="type">
<dt id="c.hrtimer_clock_base">
struct <code class="sig-name descname">hrtimer_clock_base</code><a class="headerlink" href="#c.hrtimer_clock_base" title="Permalink to this definition">¶</a></dt>
<dd><p>the timer base for a specific clock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hrtimer_clock_base {
    struct hrtimer_cpu_base *cpu_base;
    unsigned int            index;
    clockid_t clockid;
    seqcount_raw_spinlock_t seq;
    struct hrtimer          *running;
    struct timerqueue_head  active;
    ktime_t (*get_time)(void);
    ktime_t offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cpu_base</span></code></dt><dd><p>per cpu clock base</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index</span></code></dt><dd><p>clock type index for per_cpu support when moving a
timer to a base on another cpu.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clockid</span></code></dt><dd><p>clock id for per_cpu support</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seq</span></code></dt><dd><p>seqcount around __run_hrtimer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">running</span></code></dt><dd><p>pointer to the currently running hrtimer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active</span></code></dt><dd><p>red black tree root node for the active timers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_time</span></code></dt><dd><p>function to retrieve the current time of the clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>offset of this clock to the monotonic base</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.hrtimer_cpu_base">
struct <code class="sig-name descname">hrtimer_cpu_base</code><a class="headerlink" href="#c.hrtimer_cpu_base" title="Permalink to this definition">¶</a></dt>
<dd><p>the per cpu clock bases</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hrtimer_cpu_base {
    raw_spinlock_t lock;
    unsigned int                    cpu;
    unsigned int                    active_bases;
    unsigned int                    clock_was_set_seq;
    unsigned int                    hres_active             : 1,in_hrtirq               : 1,hang_detected           : 1, softirq_activated       : 1;
#ifdef CONFIG_HIGH_RES_TIMERS;
    unsigned int                    nr_events;
    unsigned short                  nr_retries;
    unsigned short                  nr_hangs;
    unsigned int                    max_hang_time;
#endif;
#ifdef CONFIG_PREEMPT_RT;
    spinlock_t softirq_expiry_lock;
    atomic_t timer_waiters;
#endif;
    ktime_t expires_next;
    struct hrtimer                  *next_timer;
    ktime_t softirq_expires_next;
    struct hrtimer                  *softirq_next_timer;
    struct hrtimer_clock_base       clock_base[HRTIMER_MAX_CLOCK_BASES];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>lock protecting the base and associated clock bases
and timers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpu</span></code></dt><dd><p>cpu number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_bases</span></code></dt><dd><p>Bitfield to mark bases with active timers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clock_was_set_seq</span></code></dt><dd><p>Sequence counter of clock was set events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hres_active</span></code></dt><dd><p>State of high resolution mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in_hrtirq</span></code></dt><dd><p>hrtimer_interrupt() is currently executing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hang_detected</span></code></dt><dd><p>The last hrtimer interrupt detected a hang</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">softirq_activated</span></code></dt><dd><p>displays, if the softirq is raised - update of softirq
related settings is not required then.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_events</span></code></dt><dd><p>Total number of hrtimer interrupt events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_retries</span></code></dt><dd><p>Total number of hrtimer interrupt retries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_hangs</span></code></dt><dd><p>Total number of hrtimer interrupt hangs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_hang_time</span></code></dt><dd><p>Maximum time spent in hrtimer_interrupt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">softirq_expiry_lock</span></code></dt><dd><p>Lock which is taken while softirq based hrtimer are
expired</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timer_waiters</span></code></dt><dd><p>A <a class="reference internal" href="#c.hrtimer_cancel" title="hrtimer_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">hrtimer_cancel()</span></code></a> invocation waits for the timer
callback to finish.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">expires_next</span></code></dt><dd><p>absolute time of the next event, is required for remote
hrtimer enqueue; it is the total first expiry time (hard
and soft hrtimer are taken into account)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next_timer</span></code></dt><dd><p>Pointer to the first expiring timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">softirq_expires_next</span></code></dt><dd><p>Time to check, if soft queues needs also to be expired</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">softirq_next_timer</span></code></dt><dd><p>Pointer to the first expiring softirq based timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clock_base</span></code></dt><dd><p>array of clock bases for this cpu</p>
</dd>
</dl>
</div>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>next_timer is just an optimization for __remove_hrtimer().</dt><dd><p>Do not dereference the pointer because it is not reliable on
cross cpu removals.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.hrtimer_start">
void <code class="sig-name descname">hrtimer_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a><em> *timer</em>, ktime_t<em> tim</em>, const enum hrtimer_mode<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_start" title="Permalink to this definition">¶</a></dt>
<dd><p>(re)start an hrtimer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">tim</span></code></dt><dd><p>expiry time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode: absolute (HRTIMER_MODE_ABS) or
relative (HRTIMER_MODE_REL), and pinned (HRTIMER_MODE_PINNED);
softirq based mode is considered for debug purpose only!</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.hrtimer_get_remaining">
ktime_t <code class="sig-name descname">hrtimer_get_remaining</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a><em> *timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_get_remaining" title="Permalink to this definition">¶</a></dt>
<dd><p>get remaining time for the timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to read</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.hrtimer_is_queued">
bool <code class="sig-name descname">hrtimer_is_queued</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a><em> *timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_is_queued" title="Permalink to this definition">¶</a></dt>
<dd><p>check, whether the timer is on one of the queues</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>Timer to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the timer is queued, false otherwise</p>
<p><strong>Description</strong></p>
<p>The function can be used lockless, but it gives only a current snapshot.</p>
</div>
<dl class="function">
<dt id="c.hrtimer_forward_now">
u64 <code class="sig-name descname">hrtimer_forward_now</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a><em> *timer</em>, ktime_t<em> interval</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_forward_now" title="Permalink to this definition">¶</a></dt>
<dd><p>forward the timer expiry so it expires after now</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>hrtimer to forward</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">interval</span></code></dt><dd><p>the interval to forward</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forward the timer expiry so it will expire after the current time
of the hrtimer clock base. Returns the number of overruns.</p>
<p>Can be safely called from the callback function of <strong>timer</strong>. If
called from other contexts <strong>timer</strong> must neither be enqueued nor
running the callback and the caller needs to take care of
serialization.</p>
<p><strong>Note</strong></p>
<p>This only updates the timer expiry value and does not requeue
the timer.</p>
</div>
<dl class="function">
<dt id="c.hrtimer_forward">
u64 <code class="sig-name descname">hrtimer_forward</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a><em> *timer</em>, ktime_t<em> now</em>, ktime_t<em> interval</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_forward" title="Permalink to this definition">¶</a></dt>
<dd><p>forward the timer expiry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>hrtimer to forward</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">now</span></code></dt><dd><p>forward past this time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">interval</span></code></dt><dd><p>the interval to forward</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forward the timer expiry so it will expire in the future.
Returns the number of overruns.</p>
<p>Can be safely called from the callback function of <strong>timer</strong>. If
called from other contexts <strong>timer</strong> must neither be enqueued nor
running the callback and the caller needs to take care of
serialization.</p>
<p><strong>Note</strong></p>
<p>This only updates the timer expiry value and does not requeue
the timer.</p>
</div>
<dl class="function">
<dt id="c.hrtimer_start_range_ns">
void <code class="sig-name descname">hrtimer_start_range_ns</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a><em> *timer</em>, ktime_t<em> tim</em>, u64<em> delta_ns</em>, const enum hrtimer_mode<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_start_range_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>(re)start an hrtimer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">tim</span></code></dt><dd><p>expiry time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">delta_ns</span></code></dt><dd><p>“slack” range for the timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode: absolute (HRTIMER_MODE_ABS) or
relative (HRTIMER_MODE_REL), and pinned (HRTIMER_MODE_PINNED);
softirq based mode is considered for debug purpose only!</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.hrtimer_try_to_cancel">
int <code class="sig-name descname">hrtimer_try_to_cancel</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a><em> *timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_try_to_cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>try to deactivate a timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>hrtimer to stop</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>0 when the timer was not active</p></li>
<li><p>1 when the timer was active</p></li>
<li><p>-1 when the timer is currently executing the callback function and
cannot be stopped</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.hrtimer_cancel">
int <code class="sig-name descname">hrtimer_cancel</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a><em> *timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel a timer and wait for the handler to finish.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be cancelled</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><p>0 when the timer was not active
1 when the timer was active</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.__hrtimer_get_remaining">
ktime_t <code class="sig-name descname">__hrtimer_get_remaining</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a><em> *timer</em>, bool<em> adjust</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__hrtimer_get_remaining" title="Permalink to this definition">¶</a></dt>
<dd><p>get remaining time for the timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">adjust</span></code></dt><dd><p>adjust relative timers when CONFIG_TIME_LOW_RES=y</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.hrtimer_init">
void <code class="sig-name descname">hrtimer_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a><em> *timer</em>, clockid_t<em> clock_id</em>, enum hrtimer_mode<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a timer to the given clock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*timer</span></code></dt><dd><p>the timer to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clockid_t</span> <span class="pre">clock_id</span></code></dt><dd><p>the clock to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>The modes which are relevant for initialization:
HRTIMER_MODE_ABS, HRTIMER_MODE_REL, HRTIMER_MODE_ABS_SOFT,
HRTIMER_MODE_REL_SOFT</p>
<p>The PINNED variants of the above can be handed in,
but the PINNED bit is ignored as pinning happens
when the hrtimer is started</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.hrtimer_sleeper_start_expires">
void <code class="sig-name descname">hrtimer_sleeper_start_expires</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *sl</em>, enum hrtimer_mode<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_sleeper_start_expires" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a hrtimer sleeper timer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*sl</span></code></dt><dd><p>sleeper to be started</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode abs/rel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper around hrtimer_start_expires() for hrtimer_sleeper based timers
to allow PREEMPT_RT to tweak the delivery mode (soft/hardirq context)</p>
</div>
<dl class="function">
<dt id="c.hrtimer_init_sleeper">
void <code class="sig-name descname">hrtimer_init_sleeper</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *sl</em>, clockid_t<em> clock_id</em>, enum hrtimer_mode<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_init_sleeper" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize sleeper to the given clock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*sl</span></code></dt><dd><p>sleeper to be initialized</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clockid_t</span> <span class="pre">clock_id</span></code></dt><dd><p>the clock to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode abs/rel</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.schedule_hrtimeout_range_clock">
int <code class="sig-name descname">schedule_hrtimeout_range_clock</code><span class="sig-paren">(</span>ktime_t<em> *expires</em>, u64<em> delta</em>, const enum hrtimer_mode<em> mode</em>, clockid_t<em> clock_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_hrtimeout_range_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*expires</span></code></dt><dd><p>timeout value (ktime_t)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">delta</span></code></dt><dd><p>slack in expires timeout (ktime_t)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clockid_t</span> <span class="pre">clock_id</span></code></dt><dd><p>timer clock to be used</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.schedule_hrtimeout_range">
int <code class="sig-name descname">schedule_hrtimeout_range</code><span class="sig-paren">(</span>ktime_t<em> *expires</em>, u64<em> delta</em>, const enum hrtimer_mode<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_hrtimeout_range" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*expires</span></code></dt><dd><p>timeout value (ktime_t)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">delta</span></code></dt><dd><p>slack in expires timeout (ktime_t)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make the current task sleep until the given expiry time has
elapsed. The routine will return immediately unless
the current task state has been set (see set_current_state()).</p>
<p>The <strong>delta</strong> argument gives the kernel the freedom to schedule the
actual wakeup to a time that is both power and performance friendly.
The kernel give the normal best effort behavior for “<strong>expires**+**delta</strong>”,
but may decide to fire the timer earlier, but no earlier than <strong>expires</strong>.</p>
<p>You can set the task state as follows -</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_UNINTERRUPTIBLE</span></code> - at least <strong>timeout</strong> time is guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>).</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_INTERRUPTIBLE</span></code> - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.</p>
<p>The current task state is guaranteed to be TASK_RUNNING when this
routine returns.</p>
<p>Returns 0 when the timer has expired. If the task was woken before the
timer expired by a signal (only possible in state TASK_INTERRUPTIBLE) or
by an explicit wakeup, it returns -EINTR.</p>
</div>
<dl class="function">
<dt id="c.schedule_hrtimeout">
int <code class="sig-name descname">schedule_hrtimeout</code><span class="sig-paren">(</span>ktime_t<em> *expires</em>, const enum hrtimer_mode<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_hrtimeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*expires</span></code></dt><dd><p>timeout value (ktime_t)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt><dd><p>timer mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make the current task sleep until the given expiry time has
elapsed. The routine will return immediately unless
the current task state has been set (see set_current_state()).</p>
<p>You can set the task state as follows -</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_UNINTERRUPTIBLE</span></code> - at least <strong>timeout</strong> time is guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>).</p>
<p><code class="docutils literal notranslate"><span class="pre">TASK_INTERRUPTIBLE</span></code> - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.</p>
<p>The current task state is guaranteed to be TASK_RUNNING when this
routine returns.</p>
<p>Returns 0 when the timer has expired. If the task was woken before the
timer expired by a signal (only possible in state TASK_INTERRUPTIBLE) or
by an explicit wakeup, it returns -EINTR.</p>
</div>
</section>
<section id="internal-functions">
<h2>Internal Functions<a class="headerlink" href="#internal-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.wait_task_stopped">
int <code class="sig-name descname">wait_task_stopped</code><span class="sig-paren">(</span>struct wait_opts<em> *wo</em>, int<em> ptrace</em>, struct task_struct<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_task_stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for <code class="docutils literal notranslate"><span class="pre">TASK_STOPPED</span></code> or <code class="docutils literal notranslate"><span class="pre">TASK_TRACED</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">wait_opts</span> <span class="pre">*wo</span></code></dt><dd><p>wait options</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ptrace</span></code></dt><dd><p>is the wait for ptrace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>task to wait for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle sys_wait4() work for <code class="docutils literal notranslate"><span class="pre">p</span></code> in state <code class="docutils literal notranslate"><span class="pre">TASK_STOPPED</span></code> or <code class="docutils literal notranslate"><span class="pre">TASK_TRACED</span></code>.</p>
<p><strong>Context</strong></p>
<p>read_lock(<code class="xref c c-type docutils literal notranslate"><span class="pre">tasklist_lock</span></code>), which is released if return value is
non-zero.  Also, grabs and releases <strong>p-&gt;sighand-&gt;siglock</strong>.</p>
<p><strong>Return</strong></p>
<p>0 if wait condition didn’t exist and search for other wait conditions
should continue.  Non-zero return, -errno on failure and <strong>p</strong>’s pid on
success, implies that tasklist_lock is released and wait condition
search should terminate.</p>
</div>
<dl class="function">
<dt id="c.task_set_jobctl_pending">
bool <code class="sig-name descname">task_set_jobctl_pending</code><span class="sig-paren">(</span>struct task_struct<em> *task</em>, unsigned long<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_set_jobctl_pending" title="Permalink to this definition">¶</a></dt>
<dd><p>set jobctl pending bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>pending bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear <strong>mask</strong> from <strong>task-&gt;jobctl</strong>.  <strong>mask</strong> must be subset of
<code class="docutils literal notranslate"><span class="pre">JOBCTL_PENDING_MASK</span></code> | <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_CONSUME</span></code> | <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_SIGMASK</span></code> |
<code class="docutils literal notranslate"><span class="pre">JOBCTL_TRAPPING</span></code>.  If stop signo is being set, the existing signo is
cleared.  If <strong>task</strong> is already being killed or exiting, this function
becomes noop.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>mask</strong> is set, <code class="docutils literal notranslate"><span class="pre">false</span></code> if made noop because <strong>task</strong> was dying.</p>
</div>
<dl class="function">
<dt id="c.task_clear_jobctl_trapping">
void <code class="sig-name descname">task_clear_jobctl_trapping</code><span class="sig-paren">(</span>struct task_struct<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_clear_jobctl_trapping" title="Permalink to this definition">¶</a></dt>
<dd><p>clear jobctl trapping bit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>target task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If JOBCTL_TRAPPING is set, a ptracer is waiting for us to enter TRACED.
Clear it and wake up the ptracer.  Note that we don’t need any further
locking.  <strong>task-&gt;siglock</strong> guarantees that <strong>task-&gt;parent</strong> points to the
ptracer.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
</div>
<dl class="function">
<dt id="c.task_clear_jobctl_pending">
void <code class="sig-name descname">task_clear_jobctl_pending</code><span class="sig-paren">(</span>struct task_struct<em> *task</em>, unsigned long<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_clear_jobctl_pending" title="Permalink to this definition">¶</a></dt>
<dd><p>clear jobctl pending bits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>target task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt><dd><p>pending bits to clear</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear <strong>mask</strong> from <strong>task-&gt;jobctl</strong>.  <strong>mask</strong> must be subset of
<code class="docutils literal notranslate"><span class="pre">JOBCTL_PENDING_MASK</span></code>.  If <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_PENDING</span></code> is being cleared, other
STOP bits are cleared together.</p>
<p>If clearing of <strong>mask</strong> leaves no stop or trap pending, this function calls
<a class="reference internal" href="#c.task_clear_jobctl_trapping" title="task_clear_jobctl_trapping"><code class="xref c c-func docutils literal notranslate"><span class="pre">task_clear_jobctl_trapping()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
</div>
<dl class="function">
<dt id="c.task_participate_group_stop">
bool <code class="sig-name descname">task_participate_group_stop</code><span class="sig-paren">(</span>struct task_struct<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_participate_group_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>participate in a group stop</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>task participating in a group stop</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>task</strong> has <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_PENDING</span></code> set and is participating in a group stop.
Group stop states are cleared and the group stop count is consumed if
<code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_CONSUME</span></code> was set.  If the consumption completes the group
stop, the appropriate <cite>SIGNAL_*</cite> flags are set.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if group stop completion should be notified to the parent, <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise.</p>
</div>
<dl class="function">
<dt id="c.ptrace_trap_notify">
void <code class="sig-name descname">ptrace_trap_notify</code><span class="sig-paren">(</span>struct task_struct<em> *t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ptrace_trap_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule trap to notify ptracer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*t</span></code></dt><dd><p>tracee wanting to notify tracer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function schedules sticky ptrace trap which is cleared on the next
TRAP_STOP to notify ptracer of an event.  <strong>t</strong> must have been seized by
ptracer.</p>
<p>If <strong>t</strong> is running, STOP trap will be taken.  If trapped for STOP and
ptracer is listening for events, tracee is woken up so that it can
re-trap for the new event.  If trapped otherwise, STOP trap will be
eventually taken without returning to userland after the existing traps
are finished by PTRACE_CONT.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task-&gt;sighand-&gt;siglock</strong> held.</p>
</div>
<dl class="function">
<dt id="c.force_sig_seccomp">
int <code class="sig-name descname">force_sig_seccomp</code><span class="sig-paren">(</span>int<em> syscall</em>, int<em> reason</em>, bool<em> force_coredump</em><span class="sig-paren">)</span><a class="headerlink" href="#c.force_sig_seccomp" title="Permalink to this definition">¶</a></dt>
<dd><p>signals the task to allow in-process syscall emulation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">syscall</span></code></dt><dd><p>syscall number to send to userland</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">reason</span></code></dt><dd><p>filter-supplied reason code to send to userland (via si_errno)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">force_coredump</span></code></dt><dd><p>true to trigger a coredump</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forces a SIGSYS with a code of SYS_SECCOMP and related sigsys info.</p>
</div>
<dl class="function">
<dt id="c.do_notify_parent_cldstop">
void <code class="sig-name descname">do_notify_parent_cldstop</code><span class="sig-paren">(</span>struct task_struct<em> *tsk</em>, bool<em> for_ptracer</em>, int<em> why</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_notify_parent_cldstop" title="Permalink to this definition">¶</a></dt>
<dd><p>notify parent of stopped/continued state change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>task reporting the state change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">for_ptracer</span></code></dt><dd><p>the notification is for ptracer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">why</span></code></dt><dd><p>CLD_{CONTINUED|STOPPED|TRAPPED} to report</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notify <strong>tsk</strong>’s parent that the stopped/continued state has changed.  If
<strong>for_ptracer</strong> is <code class="docutils literal notranslate"><span class="pre">false</span></code>, <strong>tsk</strong>’s group leader notifies to its real parent.
If <code class="docutils literal notranslate"><span class="pre">true</span></code>, <strong>tsk</strong> reports to <strong>tsk-&gt;parent</strong> which should be the ptracer.</p>
<p><strong>Context</strong></p>
<p>Must be called with tasklist_lock at least read locked.</p>
</div>
<dl class="function">
<dt id="c.do_signal_stop">
bool <code class="sig-name descname">do_signal_stop</code><span class="sig-paren">(</span>int<em> signr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_signal_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>handle group stop for SIGSTOP and other stop signals</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">signr</span></code></dt><dd><p>signr causing group stop if initiating</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <code class="docutils literal notranslate"><span class="pre">JOBCTL_STOP_PENDING</span></code> is not set yet, initiate group stop with <strong>signr</strong>
and participate in it.  If already set, participate in the existing
group stop.  If participated in a group stop (and thus slept), <code class="docutils literal notranslate"><span class="pre">true</span></code> is
returned with siglock released.</p>
<p>If ptraced, this function doesn’t handle stop itself.  Instead,
<code class="docutils literal notranslate"><span class="pre">JOBCTL_TRAP_STOP</span></code> is scheduled and <code class="docutils literal notranslate"><span class="pre">false</span></code> is returned with siglock
untouched.  The caller must ensure that INTERRUPT trap handling takes
places afterwards.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>current-&gt;sighand-&gt;siglock</strong> held, which is released
on <code class="docutils literal notranslate"><span class="pre">true</span></code> return.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if group stop is already cancelled or ptrace trap is scheduled.
<code class="docutils literal notranslate"><span class="pre">true</span></code> if participated in group stop.</p>
</div>
<dl class="function">
<dt id="c.do_jobctl_trap">
void <code class="sig-name descname">do_jobctl_trap</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.do_jobctl_trap" title="Permalink to this definition">¶</a></dt>
<dd><p>take care of ptrace jobctl traps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When PT_SEIZED, it’s used for both group stop and explicit
SEIZE/INTERRUPT traps.  Both generate PTRACE_EVENT_STOP trap with
accompanying siginfo.  If stopped, lower eight bits of exit_code contain
the stop signal; otherwise, <code class="docutils literal notranslate"><span class="pre">SIGTRAP</span></code>.</p>
<p>When !PT_SEIZED, it’s used only for group stop trap with stop signal
number as exit_code and no siginfo.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>current-&gt;sighand-&gt;siglock</strong> held, which may be
released and re-acquired before returning with intervening sleep.</p>
</div>
<dl class="function">
<dt id="c.do_freezer_trap">
void <code class="sig-name descname">do_freezer_trap</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.do_freezer_trap" title="Permalink to this definition">¶</a></dt>
<dd><p>handle the freezer jobctl trap</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Puts the task into frozen state, if only the task is not about to quit.
In this case it drops JOBCTL_TRAP_FREEZE.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>current-&gt;sighand-&gt;siglock</strong> held,
which is always released before returning.</p>
</div>
<dl class="function">
<dt id="c.signal_delivered">
void <code class="sig-name descname">signal_delivered</code><span class="sig-paren">(</span>struct ksignal<em> *ksig</em>, int<em> stepping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.signal_delivered" title="Permalink to this definition">¶</a></dt>
<dd><p>called after signal delivery to update blocked signals</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ksignal</span> <span class="pre">*ksig</span></code></dt><dd><p>kernel signal struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stepping</span></code></dt><dd><p>nonzero if debugger single-step or block-step in use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called when a signal has successfully been
delivered. It updates the blocked signals accordingly (<strong>ksig-&gt;ka.sa.sa_mask</strong>
is always blocked), and the signal itself is blocked unless <code class="docutils literal notranslate"><span class="pre">SA_NODEFER</span></code>
is set in <strong>ksig-&gt;ka.sa.sa_flags</strong>.  Tracing is notified.</p>
</div>
<dl class="function">
<dt id="c.sys_restart_syscall">
long <code class="sig-name descname">sys_restart_syscall</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.sys_restart_syscall" title="Permalink to this definition">¶</a></dt>
<dd><p>restart a system call</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.set_current_blocked">
void <code class="sig-name descname">set_current_blocked</code><span class="sig-paren">(</span>sigset_t<em> *newset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_current_blocked" title="Permalink to this definition">¶</a></dt>
<dd><p>change current-&gt;blocked mask</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">*newset</span></code></dt><dd><p>new mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is wrong to change -&gt;blocked directly, this helper should be used
to ensure the process can’t miss a shared signal we are going to block.</p>
</div>
<dl class="function">
<dt id="c.sys_rt_sigprocmask">
long <code class="sig-name descname">sys_rt_sigprocmask</code><span class="sig-paren">(</span>int<em> how</em>, sigset_t __user *<em> nset</em>, sigset_t __user *<em> oset</em>, size_t<em> sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigprocmask" title="Permalink to this definition">¶</a></dt>
<dd><p>change the list of currently blocked signals</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">how</span></code></dt><dd><p>whether to add, remove, or set signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">nset</span></code></dt><dd><p>stores pending signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oset</span></code></dt><dd><p>previous value of signal mask if non-null</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sys_rt_sigpending">
long <code class="sig-name descname">sys_rt_sigpending</code><span class="sig-paren">(</span>sigset_t __user *<em> uset</em>, size_t<em> sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigpending" title="Permalink to this definition">¶</a></dt>
<dd><p>examine a pending signal that has been raised while blocked</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uset</span></code></dt><dd><p>stores pending signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type or larger</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.copy_siginfo_to_external32">
void <code class="sig-name descname">copy_siginfo_to_external32</code><span class="sig-paren">(</span>struct compat_siginfo<em> *to</em>, const struct kernel_siginfo<em> *from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_siginfo_to_external32" title="Permalink to this definition">¶</a></dt>
<dd><p>copy a kernel siginfo into a compat user siginfo</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">compat_siginfo</span> <span class="pre">*to</span></code></dt><dd><p>compat siginfo destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kernel_siginfo</span> <span class="pre">*from</span></code></dt><dd><p>kernel siginfo source</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function does not work properly for the SIGCHLD on x32, but
fortunately it doesn’t have to.  The only valid callers for this function are
copy_siginfo_to_user32, which is overriden for x32 and the coredump code.
The latter does not care because SIGCHLD will never cause a coredump.</p>
</div>
<dl class="function">
<dt id="c.do_sigtimedwait">
int <code class="sig-name descname">do_sigtimedwait</code><span class="sig-paren">(</span>const sigset_t<em> *which</em>, kernel_siginfo_t<em> *info</em>, const struct timespec64<em> *ts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_sigtimedwait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for queued signals specified in <strong>which</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">sigset_t</span> <span class="pre">*which</span></code></dt><dd><p>queued signals to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kernel_siginfo_t</span> <span class="pre">*info</span></code></dt><dd><p>if non-null, the signal’s siginfo is returned here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*ts</span></code></dt><dd><p>upper bound on process time suspension</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sys_rt_sigtimedwait">
long <code class="sig-name descname">sys_rt_sigtimedwait</code><span class="sig-paren">(</span>const sigset_t __user *<em> uthese</em>, siginfo_t __user *<em> uinfo</em>, const struct __kernel_timespec __user *<em> uts</em>, size_t<em> sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigtimedwait" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronously wait for queued signals specified in <strong>uthese</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uthese</span></code></dt><dd><p>queued signals to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">siginfo_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt><dd><p>if non-null, the signal’s siginfo is returned here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">__kernel_timespec</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uts</span></code></dt><dd><p>upper bound on process time suspension</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sys_kill">
long <code class="sig-name descname">sys_kill</code><span class="sig-paren">(</span>pid_t<em> pid</em>, int<em> sig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_kill" title="Permalink to this definition">¶</a></dt>
<dd><p>send a signal to a process</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sys_pidfd_send_signal">
long <code class="sig-name descname">sys_pidfd_send_signal</code><span class="sig-paren">(</span>int<em> pidfd</em>, int<em> sig</em>, siginfo_t __user *<em> info</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_pidfd_send_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Signal a process through a pidfd</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pidfd</span></code></dt><dd><p>file descriptor of the process</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to send</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">siginfo_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>signal info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>future flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The syscall currently only signals via PIDTYPE_PID which covers
kill(&lt;positive-pid&gt;, &lt;signal&gt;. It does not signal threads or process
groups.
In order to extend the syscall to threads and process groups the <strong>flags</strong>
argument should be used. In essence, the <strong>flags</strong> argument will determine
what is signaled and not the file descriptor itself. Put in other words,
grouping is a property of the flags argument not a property of the file
descriptor.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative errno on failure</p>
</div>
<dl class="function">
<dt id="c.sys_tgkill">
long <code class="sig-name descname">sys_tgkill</code><span class="sig-paren">(</span>pid_t<em> tgid</em>, pid_t<em> pid</em>, int<em> sig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_tgkill" title="Permalink to this definition">¶</a></dt>
<dd><p>send signal to one specific thread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">tgid</span></code></dt><dd><p>the thread group ID of the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
<p>This syscall also checks the <strong>tgid</strong> and returns -ESRCH even if the PID
exists but it’s not belonging to the target process anymore. This
method solves the problem of threads exiting and PIDs getting reused.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sys_tkill">
long <code class="sig-name descname">sys_tkill</code><span class="sig-paren">(</span>pid_t<em> pid</em>, int<em> sig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_tkill" title="Permalink to this definition">¶</a></dt>
<dd><p>send signal to one specific task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
<p>Send a signal to only one task, even if it’s a CLONE_THREAD task.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sys_rt_sigqueueinfo">
long <code class="sig-name descname">sys_rt_sigqueueinfo</code><span class="sig-paren">(</span>pid_t<em> pid</em>, int<em> sig</em>, siginfo_t __user *<em> uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigqueueinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>send signal information to a signal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt><dd><p>the PID of the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">siginfo_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt><dd><p>signal info to be sent</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sys_sigpending">
long <code class="sig-name descname">sys_sigpending</code><span class="sig-paren">(</span>old_sigset_t __user *<em> uset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_sigpending" title="Permalink to this definition">¶</a></dt>
<dd><p>examine pending signals</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uset</span></code></dt><dd><p>where mask of pending signal is returned</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sys_sigprocmask">
long <code class="sig-name descname">sys_sigprocmask</code><span class="sig-paren">(</span>int<em> how</em>, old_sigset_t __user *<em> nset</em>, old_sigset_t __user *<em> oset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_sigprocmask" title="Permalink to this definition">¶</a></dt>
<dd><p>examine and change blocked signals</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">how</span></code></dt><dd><p>whether to add, remove, or set signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">nset</span></code></dt><dd><p>signals to add or remove (if non-null)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oset</span></code></dt><dd><p>previous value of signal mask if non-null</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some platforms have their own version with special arguments;
others support only sys_rt_sigprocmask.</p>
</div>
<dl class="function">
<dt id="c.sys_rt_sigaction">
long <code class="sig-name descname">sys_rt_sigaction</code><span class="sig-paren">(</span>int<em> sig</em>, const struct sigaction __user *<em> act</em>, struct sigaction __user *<em> oact</em>, size_t<em> sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigaction" title="Permalink to this definition">¶</a></dt>
<dd><p>alter an action taken by a process</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sig</span></code></dt><dd><p>signal to be sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sigaction</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">act</span></code></dt><dd><p>new sigaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sigaction</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oact</span></code></dt><dd><p>used to save the previous sigaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sys_rt_sigsuspend">
long <code class="sig-name descname">sys_rt_sigsuspend</code><span class="sig-paren">(</span>sigset_t __user *<em> unewset</em>, size_t<em> sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigsuspend" title="Permalink to this definition">¶</a></dt>
<dd><p>replace the signal mask for a value with the <strong>unewset</strong> value until a signal is received</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">unewset</span></code></dt><dd><p>new signal mask value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt><dd><p>size of sigset_t type</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kthread_create">
<code class="sig-name descname">kthread_create</code><span class="sig-paren">(</span><em>threadfn</em>, <em>data</em>, <em>namefmt</em>, <em>arg…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a kthread on the current node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">threadfn</span></code></dt><dd><p>the function to run in the thread</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>data pointer for <strong>threadfn()</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">namefmt</span></code></dt><dd><p>printf-style format string for the thread name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">arg...</span></code></dt><dd><p>arguments for <strong>namefmt</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro will create a kthread on the current node, leaving it in
the stopped state.  This is just a helper for <a class="reference internal" href="#c.kthread_create_on_node" title="kthread_create_on_node"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create_on_node()</span></code></a>;
see the documentation there for more details.</p>
</div>
<dl class="function">
<dt id="c.kthread_run">
<code class="sig-name descname">kthread_run</code><span class="sig-paren">(</span><em>threadfn</em>, <em>data</em>, <em>namefmt</em>, <em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_run" title="Permalink to this definition">¶</a></dt>
<dd><p>create and wake a thread.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">threadfn</span></code></dt><dd><p>the function to run until signal_pending(current).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>data ptr for <strong>threadfn</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">namefmt</span></code></dt><dd><p>printf-style name for the thread.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convenient wrapper for <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a> followed by
<a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>.  Returns the kthread or ERR_PTR(-ENOMEM).</p>
</div>
<dl class="function">
<dt id="c.kthread_run_on_cpu">
struct task_struct * <code class="sig-name descname">kthread_run_on_cpu</code><span class="sig-paren">(</span>int (<em>*threadfn</em>)(void *data), void<em> *data</em>, unsigned int<em> cpu</em>, const char<em> *namefmt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_run_on_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>create and wake a cpu bound thread.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*threadfn)(void</span> <span class="pre">*data)</span></code></dt><dd><p>the function to run until signal_pending(current).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data ptr for <strong>threadfn</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>The cpu on which the thread should be bound,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*namefmt</span></code></dt><dd><p>printf-style name for the thread. Format is restricted
to “name.*``u``”. Code fills in cpu number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convenient wrapper for <a class="reference internal" href="#c.kthread_create_on_cpu" title="kthread_create_on_cpu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create_on_cpu()</span></code></a>
followed by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>.  Returns the kthread or
ERR_PTR(-ENOMEM).</p>
</div>
<dl class="function">
<dt id="c.kthread_should_stop">
bool <code class="sig-name descname">kthread_should_stop</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_should_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>should this kthread return now?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When someone calls <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a> on your kthread, it will be woken
and this will return true.  You should then return, and your return
value will be passed through to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.kthread_should_park">
bool <code class="sig-name descname">kthread_should_park</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_should_park" title="Permalink to this definition">¶</a></dt>
<dd><p>should this kthread park now?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When someone calls <a class="reference internal" href="#c.kthread_park" title="kthread_park"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_park()</span></code></a> on your kthread, it will be woken
and this will return true.  You should then do the necessary
cleanup and call kthread_parkme()</p>
<p>Similar to <a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a>, but this keeps the thread alive
and in a park position. <a class="reference internal" href="#c.kthread_unpark" title="kthread_unpark"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_unpark()</span></code></a> “restarts” the thread and
calls the thread function again.</p>
</div>
<dl class="function">
<dt id="c.kthread_freezable_should_stop">
bool <code class="sig-name descname">kthread_freezable_should_stop</code><span class="sig-paren">(</span>bool<em> *was_frozen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_freezable_should_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>should this freezable kthread return now?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*was_frozen</span></code></dt><dd><p>optional out parameter, indicates whether <code class="docutils literal notranslate"><span class="pre">current</span></code> was frozen</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a> for freezable kthreads, which will enter
refrigerator if necessary.  This function is safe from <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a> /
freezer deadlock and freezable kthreads should use this function instead
of calling try_to_freeze() directly.</p>
</div>
<dl class="function">
<dt id="c.kthread_func">
void * <code class="sig-name descname">kthread_func</code><span class="sig-paren">(</span>struct task_struct<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_func" title="Permalink to this definition">¶</a></dt>
<dd><p>return the function specified on kthread creation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>kthread task in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the task is not a kthread.</p>
</div>
<dl class="function">
<dt id="c.kthread_data">
void * <code class="sig-name descname">kthread_data</code><span class="sig-paren">(</span>struct task_struct<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_data" title="Permalink to this definition">¶</a></dt>
<dd><p>return data value specified on kthread creation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>kthread task in question</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the data value specified when kthread <strong>task</strong> was created.
The caller is responsible for ensuring the validity of <strong>task</strong> when
calling this function.</p>
</div>
<dl class="function">
<dt id="c.kthread_complete_and_exit">
void __noreturn <code class="sig-name descname">kthread_complete_and_exit</code><span class="sig-paren">(</span>struct completion<em> *comp</em>, long<em> code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_complete_and_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit the current kthread.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">completion</span> <span class="pre">*comp</span></code></dt><dd><p>Completion to complete</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">code</span></code></dt><dd><p>The integer value to return to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If present complete <strong>comp</strong> and the reuturn code to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
<p>A kernel thread whose module may be removed after the completion of
<strong>comp</strong> can use this function exit safely.</p>
<p>Does not return.</p>
</div>
<dl class="function">
<dt id="c.kthread_create_on_node">
struct task_struct * <code class="sig-name descname">kthread_create_on_node</code><span class="sig-paren">(</span>int (<em>*threadfn</em>)(void *data), void<em> *data</em>, int<em> node</em>, const char<em> namefmt[]</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_on_node" title="Permalink to this definition">¶</a></dt>
<dd><p>create a kthread.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*threadfn)(void</span> <span class="pre">*data)</span></code></dt><dd><p>the function to run until signal_pending(current).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data ptr for <strong>threadfn</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>task and thread structures for the thread are allocated on this node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt[]</span></code></dt><dd><p>printf-style name for the thread.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function creates and names a kernel
thread.  The thread will be stopped: use <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a> to start
it.  See also <a class="reference internal" href="#c.kthread_run" title="kthread_run"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_run()</span></code></a>.  The new thread has SCHED_NORMAL policy and
is affine to all CPUs.</p>
<p>If thread is going to be bound on a particular cpu, give its node
in <strong>node</strong>, to get NUMA affinity for kthread stack, or else give NUMA_NO_NODE.
When woken, the thread will run <strong>threadfn()</strong> with <strong>data</strong> as its
argument. <strong>threadfn()</strong> can either return directly if it is a
standalone thread for which no one will call <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>, or
return when ‘<a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a>’ is true (which means
<a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a> has been called).  The return value should be zero
or a negative error number; it will be passed to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>.</p>
<p>Returns a task_struct or ERR_PTR(-ENOMEM) or ERR_PTR(-EINTR).</p>
</div>
<dl class="function">
<dt id="c.kthread_bind">
void <code class="sig-name descname">kthread_bind</code><span class="sig-paren">(</span>struct task_struct<em> *p</em>, unsigned int<em> cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>bind a just-created kthread to a cpu.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*p</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>cpu (might not be online, must be possible) for <strong>k</strong> to run on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is equivalent to set_cpus_allowed(),
except that <strong>cpu</strong> doesn’t need to be online, and the thread must be
stopped (i.e., just returned from <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>).</p>
</div>
<dl class="function">
<dt id="c.kthread_create_on_cpu">
struct task_struct * <code class="sig-name descname">kthread_create_on_cpu</code><span class="sig-paren">(</span>int (<em>*threadfn</em>)(void *data), void<em> *data</em>, unsigned int<em> cpu</em>, const char<em> *namefmt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_on_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cpu bound kthread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*threadfn)(void</span> <span class="pre">*data)</span></code></dt><dd><p>the function to run until signal_pending(current).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data ptr for <strong>threadfn</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>The cpu on which the thread should be bound,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*namefmt</span></code></dt><dd><p>printf-style name for the thread. Format is restricted
to “name.*``u``”. Code fills in cpu number.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function creates and names a kernel thread</p>
</div>
<dl class="function">
<dt id="c.kthread_unpark">
void <code class="sig-name descname">kthread_unpark</code><span class="sig-paren">(</span>struct task_struct<em> *k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_unpark" title="Permalink to this definition">¶</a></dt>
<dd><p>unpark a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*k</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_park" title="kthread_should_park"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_park()</span></code></a> for <strong>k</strong> to return false, wakes it, and
waits for it to return. If the thread is marked percpu then its
bound to the cpu again.</p>
</div>
<dl class="function">
<dt id="c.kthread_park">
int <code class="sig-name descname">kthread_park</code><span class="sig-paren">(</span>struct task_struct<em> *k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_park" title="Permalink to this definition">¶</a></dt>
<dd><p>park a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*k</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_park" title="kthread_should_park"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_park()</span></code></a> for <strong>k</strong> to return true, wakes it, and
waits for it to return. This can also be called after <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>
instead of calling <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>: the thread will park without
calling threadfn().</p>
<p>Returns 0 if the thread is parked, -ENOSYS if the thread exited.
If called by the kthread itself just the park bit is set.</p>
</div>
<dl class="function">
<dt id="c.kthread_stop">
int <code class="sig-name descname">kthread_stop</code><span class="sig-paren">(</span>struct task_struct<em> *k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stop a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*k</span></code></dt><dd><p>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_should_stop()</span></code></a> for <strong>k</strong> to return true, wakes it, and
waits for it to exit. This can also be called after <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_create()</span></code></a>
instead of calling <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>: the thread will exit without
calling threadfn().</p>
<p>If threadfn() may call kthread_exit() itself, the caller must ensure
task_struct can’t go away.</p>
<p>Returns the result of threadfn(), or <code class="docutils literal notranslate"><span class="pre">-EINTR</span></code> if <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up_process()</span></code></a>
was never called.</p>
</div>
<dl class="function">
<dt id="c.kthread_worker_fn">
int <code class="sig-name descname">kthread_worker_fn</code><span class="sig-paren">(</span>void<em> *worker_ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_worker_fn" title="Permalink to this definition">¶</a></dt>
<dd><p>kthread function to process kthread_worker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*worker_ptr</span></code></dt><dd><p>pointer to initialized kthread_worker</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements the main cycle of kthread worker. It processes
work_list until it is stopped with <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_stop()</span></code></a>. It sleeps when the queue
is empty.</p>
<p>The works are not allowed to keep any locks, disable preemption or interrupts
when they finish. There is defined a safe point for freezing when one work
finishes and before a new one is started.</p>
<p>Also the works must not be handled by more than one worker at the same time,
see also <a class="reference internal" href="#c.kthread_queue_work" title="kthread_queue_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_queue_work()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.kthread_create_worker">
struct kthread_worker * <code class="sig-name descname">kthread_create_worker</code><span class="sig-paren">(</span>unsigned int<em> flags</em>, const char<em> namefmt[]</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>create a kthread worker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags modifying the default behavior of the worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt[]</span></code></dt><dd><p>printf-style name for the kthread worker (task).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the allocated worker on success, ERR_PTR(-ENOMEM)
when the needed structures could not get allocated, and ERR_PTR(-EINTR)
when the caller was killed by a fatal signal.</p>
</div>
<dl class="function">
<dt id="c.kthread_create_worker_on_cpu">
struct kthread_worker * <code class="sig-name descname">kthread_create_worker_on_cpu</code><span class="sig-paren">(</span>int<em> cpu</em>, unsigned int<em> flags</em>, const char<em> namefmt[]</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_worker_on_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>create a kthread worker and bind it to a given CPU and the associated NUMA node.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>CPU number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags modifying the default behavior of the worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt[]</span></code></dt><dd><p>printf-style name for the kthread worker (task).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use a valid CPU number if you want to bind the kthread worker
to the given CPU and the associated NUMA node.</p>
<p>A good practice is to add the cpu number also into the worker name.
For example, use kthread_create_worker_on_cpu(cpu, “helper/<code class="docutils literal notranslate"><span class="pre">d</span></code>”, cpu).</p>
<p>CPU hotplug:
The kthread worker API is simple and generic. It just provides a way
to create, use, and destroy workers.</p>
<p>It is up to the API user how to handle CPU hotplug. They have to decide
how to handle pending work items, prevent queuing new ones, and
restore the functionality when the CPU goes off and on. There are a
few catches:</p>
<blockquote>
<div><ul class="simple">
<li><p>CPU affinity gets lost when it is scheduled on an offline CPU.</p></li>
<li><p>The worker might not exist when the CPU was off when the user
created the workers.</p></li>
</ul>
</div></blockquote>
<p>Good practice is to implement two CPU hotplug callbacks and to
destroy/create the worker when the CPU goes down/up.</p>
<p><strong>Return</strong></p>
<p>The pointer to the allocated worker on success, ERR_PTR(-ENOMEM)
when the needed structures could not get allocated, and ERR_PTR(-EINTR)
when the caller was killed by a fatal signal.</p>
</div>
<dl class="function">
<dt id="c.kthread_queue_work">
bool <code class="sig-name descname">kthread_queue_work</code><span class="sig-paren">(</span>struct kthread_worker<em> *worker</em>, struct kthread_work<em> *work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_queue_work" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a kthread_work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>target kthread_worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*work</span></code></dt><dd><p>kthread_work to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue <strong>work</strong> to work processor <strong>task</strong> for async execution.  <strong>task</strong>
must have been created with kthread_worker_create().  Returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
if <strong>work</strong> was successfully queued, <code class="docutils literal notranslate"><span class="pre">false</span></code> if it was already pending.</p>
<p>Reinitialize the work if it needs to be used by another worker.
For example, when the worker was stopped and started again.</p>
</div>
<dl class="function">
<dt id="c.kthread_delayed_work_timer_fn">
void <code class="sig-name descname">kthread_delayed_work_timer_fn</code><span class="sig-paren">(</span>struct timer_list<em> *t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_delayed_work_timer_fn" title="Permalink to this definition">¶</a></dt>
<dd><p>callback that queues the associated kthread delayed work when the timer expires.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*t</span></code></dt><dd><p>pointer to the expired timer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The format of the function is defined by struct timer_list.
It should have been called from irqsafe timer with irq already off.</p>
</div>
<dl class="function">
<dt id="c.kthread_queue_delayed_work">
bool <code class="sig-name descname">kthread_queue_delayed_work</code><span class="sig-paren">(</span>struct kthread_worker<em> *worker</em>, struct kthread_delayed_work<em> *dwork</em>, unsigned long<em> delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_queue_delayed_work" title="Permalink to this definition">¶</a></dt>
<dd><p>queue the associated kthread work after a delay.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>target kthread_worker</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>kthread_delayed_work to queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait before queuing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the work has not been pending it starts a timer that will queue
the work after the given <strong>delay</strong>. If <strong>delay</strong> is zero, it queues the
work immediately.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if the <strong>work</strong> has already been pending. It means that
either the timer was running or the work was queued. It returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
otherwise.</p>
</div>
<dl class="function">
<dt id="c.kthread_flush_work">
void <code class="sig-name descname">kthread_flush_work</code><span class="sig-paren">(</span>struct kthread_work<em> *work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_flush_work" title="Permalink to this definition">¶</a></dt>
<dd><p>flush a kthread_work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*work</span></code></dt><dd><p>work to flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>work</strong> is queued or executing, wait for it to finish execution.</p>
</div>
<dl class="function">
<dt id="c.kthread_mod_delayed_work">
bool <code class="sig-name descname">kthread_mod_delayed_work</code><span class="sig-paren">(</span>struct kthread_worker<em> *worker</em>, struct kthread_delayed_work<em> *dwork</em>, unsigned long<em> delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_mod_delayed_work" title="Permalink to this definition">¶</a></dt>
<dd><p>modify delay of or queue a kthread delayed work</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>kthread worker to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>kthread delayed work to queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt><dd><p>number of jiffies to wait before queuing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>dwork</strong> is idle, equivalent to <a class="reference internal" href="#c.kthread_queue_delayed_work" title="kthread_queue_delayed_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_queue_delayed_work()</span></code></a>. Otherwise,
modify <strong>dwork</strong>’s timer so that it expires after <strong>delay</strong>. If <strong>delay</strong> is zero,
<strong>work</strong> is guaranteed to be queued immediately.</p>
<p>A special case is when the work is being canceled in parallel.
It might be caused either by the real <a class="reference internal" href="#c.kthread_cancel_delayed_work_sync" title="kthread_cancel_delayed_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_cancel_delayed_work_sync()</span></code></a>
or yet another <a class="reference internal" href="#c.kthread_mod_delayed_work" title="kthread_mod_delayed_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_mod_delayed_work()</span></code></a> call. We let the other command
win and return <code class="docutils literal notranslate"><span class="pre">true</span></code> here. The return value can be used for reference
counting and the number of queued works stays the same. Anyway, the caller
is supposed to synchronize these operations a reasonable way.</p>
<p>This function is safe to call from any context including IRQ handler.
See __kthread_cancel_work() and <a class="reference internal" href="#c.kthread_delayed_work_timer_fn" title="kthread_delayed_work_timer_fn"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_delayed_work_timer_fn()</span></code></a>
for details.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">false</span></code> if <strong>dwork</strong> was idle and queued, <code class="docutils literal notranslate"><span class="pre">true</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.kthread_cancel_work_sync">
bool <code class="sig-name descname">kthread_cancel_work_sync</code><span class="sig-paren">(</span>struct kthread_work<em> *work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_cancel_work_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel a kthread work and wait for it to finish</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*work</span></code></dt><dd><p>the kthread work to cancel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cancel <strong>work</strong> and wait for its execution to finish.  This function
can be used even if the work re-queues itself. On return from this
function, <strong>work</strong> is guaranteed to be not pending or executing on any CPU.</p>
<p>kthread_cancel_work_sync(<code class="xref c c-type docutils literal notranslate"><span class="pre">delayed_work-&gt;work</span></code>) must not be used for
delayed_work’s. Use <a class="reference internal" href="#c.kthread_cancel_delayed_work_sync" title="kthread_cancel_delayed_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_cancel_delayed_work_sync()</span></code></a> instead.</p>
<p>The caller must ensure that the worker on which <strong>work</strong> was last
queued can’t be destroyed before this function returns.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>work</strong> was pending, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.kthread_cancel_delayed_work_sync">
bool <code class="sig-name descname">kthread_cancel_delayed_work_sync</code><span class="sig-paren">(</span>struct kthread_delayed_work<em> *dwork</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_cancel_delayed_work_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel a kthread delayed work and wait for it to finish.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*dwork</span></code></dt><dd><p>the kthread delayed work to cancel</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is <a class="reference internal" href="#c.kthread_cancel_work_sync" title="kthread_cancel_work_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_cancel_work_sync()</span></code></a> for delayed works.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <strong>dwork</strong> was pending, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.kthread_flush_worker">
void <code class="sig-name descname">kthread_flush_worker</code><span class="sig-paren">(</span>struct kthread_worker<em> *worker</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_flush_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>flush all current works on a kthread_worker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker to flush</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until all currently executing or pending works on <strong>worker</strong> are
finished.</p>
</div>
<dl class="function">
<dt id="c.kthread_destroy_worker">
void <code class="sig-name descname">kthread_destroy_worker</code><span class="sig-paren">(</span>struct kthread_worker<em> *worker</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_destroy_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a kthread worker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*worker</span></code></dt><dd><p>worker to be destroyed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush and destroy <strong>worker</strong>.  The simple flush is enough because the kthread
worker API is used only in trivial scenarios.  There are no multi-step state
machines needed.</p>
</div>
<dl class="function">
<dt id="c.kthread_use_mm">
void <code class="sig-name descname">kthread_use_mm</code><span class="sig-paren">(</span>struct mm_struct<em> *mm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_use_mm" title="Permalink to this definition">¶</a></dt>
<dd><p>make the calling kthread operate on an address space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>address space to operate on</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kthread_unuse_mm">
void <code class="sig-name descname">kthread_unuse_mm</code><span class="sig-paren">(</span>struct mm_struct<em> *mm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_unuse_mm" title="Permalink to this definition">¶</a></dt>
<dd><p>reverse the effect of <a class="reference internal" href="#c.kthread_use_mm" title="kthread_use_mm"><code class="xref c c-func docutils literal notranslate"><span class="pre">kthread_use_mm()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*mm</span></code></dt><dd><p>address space to operate on</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kthread_associate_blkcg">
void <code class="sig-name descname">kthread_associate_blkcg</code><span class="sig-paren">(</span>struct cgroup_subsys_state<em> *css</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_associate_blkcg" title="Permalink to this definition">¶</a></dt>
<dd><p>associate blkcg to current kthread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cgroup_subsys_state</span> <span class="pre">*css</span></code></dt><dd><p>the cgroup info</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Current thread must be a kthread. The thread is running jobs on behalf of
other threads. In some cases, we expect the jobs attach cgroup info of
original threads instead of that of current thread. This function stores
original thread’s cgroup info in current kthread context for later
retrieval.</p>
</div>
</section>
<section id="reference-counting">
<h2>Reference counting<a class="headerlink" href="#reference-counting" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.refcount_t">
typedef <code class="sig-name descname">refcount_t</code><a class="headerlink" href="#c.refcount_t" title="Permalink to this definition">¶</a></dt>
<dd><p>variant of atomic_t specialized for reference counts</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>The counter saturates at REFCOUNT_SATURATED and will not move once
there. This avoids wrapping the counter and causing ‘spurious’
use-after-free bugs.</p>
<dl class="function">
<dt id="c.refcount_set">
void <code class="sig-name descname">refcount_set</code><span class="sig-paren">(</span><a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em>, int<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set a refcount’s value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n</span></code></dt><dd><p>value to which the refcount will be set</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.refcount_read">
unsigned int <code class="sig-name descname">refcount_read</code><span class="sig-paren">(</span>const <a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_read" title="Permalink to this definition">¶</a></dt>
<dd><p>get a refcount’s value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the refcount’s value</p>
</div>
<dl class="function">
<dt id="c.refcount_add_not_zero">
bool <code class="sig-name descname">refcount_add_not_zero</code><span class="sig-paren">(</span>int<em> i</em>, <a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_add_not_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>add a value to a refcount unless it is 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>the value to add to the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will saturate at REFCOUNT_SATURATED and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <a class="reference internal" href="#c.refcount_inc" title="refcount_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_inc()</span></code></a>, or one of its variants, should instead be used to
increment a reference count.</p>
<p><strong>Return</strong></p>
<p>false if the passed refcount is 0, true otherwise</p>
</div>
<dl class="function">
<dt id="c.refcount_add">
void <code class="sig-name descname">refcount_add</code><span class="sig-paren">(</span>int<em> i</em>, <a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a value to a refcount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>the value to add to the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_add(), but will saturate at REFCOUNT_SATURATED and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <a class="reference internal" href="#c.refcount_inc" title="refcount_inc"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_inc()</span></code></a>, or one of its variants, should instead be used to
increment a reference count.</p>
</div>
<dl class="function">
<dt id="c.refcount_inc_not_zero">
bool <code class="sig-name descname">refcount_inc_not_zero</code><span class="sig-paren">(</span><a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_inc_not_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>increment a refcount unless it is 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount to increment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_inc_not_zero(), but will saturate at REFCOUNT_SATURATED
and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p><strong>Return</strong></p>
<p>true if the increment was successful, false otherwise</p>
</div>
<dl class="function">
<dt id="c.refcount_inc">
void <code class="sig-name descname">refcount_inc</code><span class="sig-paren">(</span><a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>increment a refcount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount to increment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_inc(), but will saturate at REFCOUNT_SATURATED and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller already has a
reference on the object.</p>
<p>Will WARN if the refcount is 0, as this represents a possible use-after-free
condition.</p>
</div>
<dl class="function">
<dt id="c.refcount_sub_and_test">
bool <code class="sig-name descname">refcount_sub_and_test</code><span class="sig-paren">(</span>int<em> i</em>, <a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_sub_and_test" title="Permalink to this definition">¶</a></dt>
<dd><p>subtract from a refcount and test if it is 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>amount to subtract from the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_dec_and_test(), but it will WARN, return false and
ultimately leak on underflow and will fail to decrement when saturated
at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides an acquire ordering on success such that free()
must come after.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <a class="reference internal" href="#c.refcount_dec" title="refcount_dec"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_dec()</span></code></a>, or one of its variants, should instead be used to
decrement a reference count.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
</div>
<dl class="function">
<dt id="c.refcount_dec_and_test">
bool <code class="sig-name descname">refcount_dec_and_test</code><span class="sig-paren">(</span><a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_test" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement a refcount and test if it is 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_dec_and_test(), it will WARN on underflow and fail to
decrement when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides an acquire ordering on success such that free()
must come after.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
</div>
<dl class="function">
<dt id="c.refcount_dec">
void <code class="sig-name descname">refcount_dec</code><span class="sig-paren">(</span><a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement a refcount</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_dec(), it will WARN on underflow and fail to decrement
when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before.</p>
</div>
<dl class="function">
<dt id="c.refcount_dec_if_one">
bool <code class="sig-name descname">refcount_dec_if_one</code><span class="sig-paren">(</span><a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_if_one" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement a refcount if it is 1</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>No atomic_t counterpart, it attempts a 1 -&gt; 0 transition and returns the
success thereof.</p>
<p>Like all decrement operations, it provides release memory order and provides
a control dependency.</p>
<p>It can be used like a try-delete operator; this explicit case is provided
and not cmpxchg in generic, because that would allow implementing unsafe
operations.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
</div>
<dl class="function">
<dt id="c.refcount_dec_not_one">
bool <code class="sig-name descname">refcount_dec_not_one</code><span class="sig-paren">(</span><a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_not_one" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement a refcount if it is not 1</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>No atomic_t counterpart, it decrements unless the value is 1, in which case
it will return false.</p>
<p>Was often done like: atomic_add_unless(<code class="xref c c-type docutils literal notranslate"><span class="pre">var</span></code>, -1, 1)</p>
<p><strong>Return</strong></p>
<p>true if the decrement operation was successful, false otherwise</p>
</div>
<dl class="function">
<dt id="c.refcount_dec_and_mutex_lock">
bool <code class="sig-name descname">refcount_dec_and_mutex_lock</code><span class="sig-paren">(</span><a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em>, struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>return holding mutex if able to decrement refcount to 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be locked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="../kernel-hacking/locking.html#c.atomic_dec_and_mutex_lock" title="atomic_dec_and_mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_and_mutex_lock()</span></code></a>, it will WARN on underflow and fail
to decrement when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that free() must come after.
See the comment on top.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>true and hold mutex if able to decrement refcount to 0, false</dt><dd><p>otherwise</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.refcount_dec_and_lock">
bool <code class="sig-name descname">refcount_dec_and_lock</code><span class="sig-paren">(</span><a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em>, spinlock_t<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>return holding spinlock if able to decrement refcount to 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>the spinlock to be locked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to atomic_dec_and_lock(), it will WARN on underflow and fail to
decrement when saturated at REFCOUNT_SATURATED.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that free() must come after.
See the comment on top.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>true and hold spinlock if able to decrement refcount to 0, false</dt><dd><p>otherwise</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.refcount_dec_and_lock_irqsave">
bool <code class="sig-name descname">refcount_dec_and_lock_irqsave</code><span class="sig-paren">(</span><a class="reference internal" href="#c.refcount_t" title="refcount_t">refcount_t</a><em> *r</em>, spinlock_t<em> *lock</em>, unsigned long<em> *flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_lock_irqsave" title="Permalink to this definition">¶</a></dt>
<dd><p>return holding spinlock with disabled interrupts if able to decrement refcount to 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcount_t</span> <span class="pre">*r</span></code></dt><dd><p>the refcount</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>the spinlock to be locked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*flags</span></code></dt><dd><p>saved IRQ-flags if the is acquired</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.refcount_dec_and_lock" title="refcount_dec_and_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">refcount_dec_and_lock()</span></code></a> above except that the spinlock is acquired
with disabled interrupts.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>true and hold spinlock if able to decrement refcount to 0, false</dt><dd><p>otherwise</p>
</dd>
</dl>
</div>
</section>
<section id="atomics">
<h2>Atomics<a class="headerlink" href="#atomics" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.arch_atomic_read">
int <code class="sig-name descname">arch_atomic_read</code><span class="sig-paren">(</span>const atomic_t<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read atomic variable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically reads the value of <strong>v</strong>.</p>
</div>
<dl class="function">
<dt id="c.arch_atomic_set">
void <code class="sig-name descname">arch_atomic_set</code><span class="sig-paren">(</span>atomic_t<em> *v</em>, int<em> i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set atomic variable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>required value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets the value of <strong>v</strong> to <strong>i</strong>.</p>
</div>
<dl class="function">
<dt id="c.arch_atomic_add">
void <code class="sig-name descname">arch_atomic_add</code><span class="sig-paren">(</span>int<em> i</em>, atomic_t<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add integer to atomic variable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically adds <strong>i</strong> to <strong>v</strong>.</p>
</div>
<dl class="function">
<dt id="c.arch_atomic_sub">
void <code class="sig-name descname">arch_atomic_sub</code><span class="sig-paren">(</span>int<em> i</em>, atomic_t<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>subtract integer from atomic variable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically subtracts <strong>i</strong> from <strong>v</strong>.</p>
</div>
<dl class="function">
<dt id="c.arch_atomic_sub_and_test">
bool <code class="sig-name descname">arch_atomic_sub_and_test</code><span class="sig-paren">(</span>int<em> i</em>, atomic_t<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_sub_and_test" title="Permalink to this definition">¶</a></dt>
<dd><p>subtract value from variable and test result</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically subtracts <strong>i</strong> from <strong>v</strong> and returns
true if the result is zero, or false for all
other cases.</p>
</div>
<dl class="function">
<dt id="c.arch_atomic_inc">
void <code class="sig-name descname">arch_atomic_inc</code><span class="sig-paren">(</span>atomic_t<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>increment atomic variable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically increments <strong>v</strong> by 1.</p>
</div>
<dl class="function">
<dt id="c.arch_atomic_dec">
void <code class="sig-name descname">arch_atomic_dec</code><span class="sig-paren">(</span>atomic_t<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_dec" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement atomic variable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically decrements <strong>v</strong> by 1.</p>
</div>
<dl class="function">
<dt id="c.arch_atomic_dec_and_test">
bool <code class="sig-name descname">arch_atomic_dec_and_test</code><span class="sig-paren">(</span>atomic_t<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_dec_and_test" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement and test</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically decrements <strong>v</strong> by 1 and
returns true if the result is 0, or false for all other
cases.</p>
</div>
<dl class="function">
<dt id="c.arch_atomic_inc_and_test">
bool <code class="sig-name descname">arch_atomic_inc_and_test</code><span class="sig-paren">(</span>atomic_t<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_inc_and_test" title="Permalink to this definition">¶</a></dt>
<dd><p>increment and test</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically increments <strong>v</strong> by 1
and returns true if the result is zero, or false for all
other cases.</p>
</div>
<dl class="function">
<dt id="c.arch_atomic_add_negative">
bool <code class="sig-name descname">arch_atomic_add_negative</code><span class="sig-paren">(</span>int<em> i</em>, atomic_t<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_add_negative" title="Permalink to this definition">¶</a></dt>
<dd><p>add and test if negative</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically adds <strong>i</strong> to <strong>v</strong> and returns true
if the result is negative, or false when
result is greater than or equal to zero.</p>
</div>
<dl class="function">
<dt id="c.arch_atomic_add_return">
int <code class="sig-name descname">arch_atomic_add_return</code><span class="sig-paren">(</span>int<em> i</em>, atomic_t<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_add_return" title="Permalink to this definition">¶</a></dt>
<dd><p>add integer and return</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically adds <strong>i</strong> to <strong>v</strong> and returns <strong>i</strong> + <strong>v</strong></p>
</div>
<dl class="function">
<dt id="c.arch_atomic_sub_return">
int <code class="sig-name descname">arch_atomic_sub_return</code><span class="sig-paren">(</span>int<em> i</em>, atomic_t<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_sub_return" title="Permalink to this definition">¶</a></dt>
<dd><p>subtract integer and return</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>integer value to subtract</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*v</span></code></dt><dd><p>pointer of type atomic_t</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically subtracts <strong>i</strong> from <strong>v</strong> and returns <strong>v</strong> - <strong>i</strong></p>
</div>
</section>
<section id="kernel-objects-manipulation">
<h2>Kernel objects manipulation<a class="headerlink" href="#kernel-objects-manipulation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.kobject_get_path">
char * <code class="sig-name descname">kobject_get_path</code><span class="sig-paren">(</span>const struct kobject<em> *kobj</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_get_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate memory and fill in the path for <strong>kobj</strong>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>kobject in question, with which to build the path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>the allocation type used to allocate the path</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The newly allocated memory, caller must free with <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.kobject_set_name">
int <code class="sig-name descname">kobject_set_name</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the name of a kobject.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>struct kobject to set the name of</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format string used to build the name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This sets the name of the kobject.  If you have already added the
kobject to the system, you must call <a class="reference internal" href="#c.kobject_rename" title="kobject_rename"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_rename()</span></code></a> in order to
change the name of the kobject.</p>
</div>
<dl class="function">
<dt id="c.kobject_init">
void <code class="sig-name descname">kobject_init</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const struct kobj_type<em> *ktype</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a kobject structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>pointer to the kobject to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kobj_type</span> <span class="pre">*ktype</span></code></dt><dd><p>pointer to the ktype for this kobject.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will properly initialize a kobject such that it can then
be passed to the <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a> call.</p>
<p>After this function is called, the kobject MUST be cleaned up by a call
to <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a>, not by a call to kfree directly to ensure that all of
the memory is cleaned up properly.</p>
</div>
<dl class="function">
<dt id="c.kobject_add">
int <code class="sig-name descname">kobject_add</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, struct kobject<em> *parent</em>, const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_add" title="Permalink to this definition">¶</a></dt>
<dd><p>The main kobject add function.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>the kobject to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent</span></code></dt><dd><p>pointer to the parent of the kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>format to name the kobject with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The kobject name is set and added to the kobject hierarchy in this
function.</p>
<p>If <strong>parent</strong> is set, then the parent of the <strong>kobj</strong> will be set to it.
If <strong>parent</strong> is NULL, then the parent of the <strong>kobj</strong> will be set to the
kobject associated with the kset assigned to this kobject.  If no kset
is assigned to the kobject, then the kobject will be located in the
root of the sysfs tree.</p>
<p>Note, no “add” uevent will be created with this call, the caller should set
up all of the necessary sysfs files for the object and then call
kobject_uevent() with the UEVENT_ADD parameter to ensure that
userspace is properly notified of this kobject’s creation.</p>
<p><strong>Return</strong></p>
<dl>
<dt>If this function returns an error, kobject_put() must be</dt><dd><p>called to properly clean up the memory associated with the
object.  Under no instance should the kobject that is passed
to this function be directly freed with a call to <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>,
that can leak memory.</p>
<p>If this function returns success, <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> must also be called
in order to properly clean up the memory associated with the object.</p>
<p>In short, once this function is called, <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> MUST be called
when the use of the object is finished in order to properly free
everything.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kobject_init_and_add">
int <code class="sig-name descname">kobject_init_and_add</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const struct kobj_type<em> *ktype</em>, struct kobject<em> *parent</em>, const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_init_and_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a kobject structure and add it to the kobject hierarchy.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>pointer to the kobject to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kobj_type</span> <span class="pre">*ktype</span></code></dt><dd><p>pointer to the ktype for this kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent</span></code></dt><dd><p>pointer to the parent of this kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>the name of the kobject.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function combines the call to <a class="reference internal" href="#c.kobject_init" title="kobject_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_init()</span></code></a> and <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a>.</p>
<p>If this function returns an error, <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> must be called to
properly clean up the memory associated with the object.  This is the
same type of error handling after a call to <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a> and kobject
lifetime rules are the same here.</p>
</div>
<dl class="function">
<dt id="c.kobject_rename">
int <code class="sig-name descname">kobject_rename</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, const char<em> *new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the name of an object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object in question.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*new_name</span></code></dt><dd><p>object’s new name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the responsibility of the caller to provide mutual
exclusion between two different calls of kobject_rename
on the same kobject and to ensure that new_name is valid and
won’t conflict with other kobjects.</p>
</div>
<dl class="function">
<dt id="c.kobject_move">
int <code class="sig-name descname">kobject_move</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em>, struct kobject<em> *new_parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move object to another parent.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object in question.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*new_parent</span></code></dt><dd><p>object’s new parent (can be NULL)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kobject_del">
void <code class="sig-name descname">kobject_del</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_del" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlink kobject from hierarchy.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the function that should be called to delete an object
successfully added via <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_add()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.kobject_get">
struct kobject * <code class="sig-name descname">kobject_get</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment refcount for object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kobject_put">
void <code class="sig-name descname">kobject_put</code><span class="sig-paren">(</span>struct kobject<em> *kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement refcount for object.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*kobj</span></code></dt><dd><p>object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement the refcount, and if 0, call kobject_cleanup().</p>
</div>
<dl class="function">
<dt id="c.kobject_create_and_add">
struct kobject * <code class="sig-name descname">kobject_create_and_add</code><span class="sig-paren">(</span>const char<em> *name</em>, struct kobject<em> *parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_create_and_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a struct kobject dynamically and register it with sysfs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name for the kobject</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent</span></code></dt><dd><p>the parent kobject of this kobject, if any.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a kobject structure dynamically and registers it
with sysfs.  When you are finished with this structure, call
<a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">kobject_put()</span></code></a> and the structure will be dynamically freed when
it is no longer being used.</p>
<p>If the kobject was not able to be created, NULL will be returned.</p>
</div>
<dl class="function">
<dt id="c.kset_register">
int <code class="sig-name descname">kset_register</code><span class="sig-paren">(</span>struct kset<em> *k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize and add a kset.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*k</span></code></dt><dd><p>kset.</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>On error, the kset.kobj.name allocated by() kobj_set_name()
is freed, it can not be used any more.</p>
</div>
<dl class="function">
<dt id="c.kset_unregister">
void <code class="sig-name descname">kset_unregister</code><span class="sig-paren">(</span>struct kset<em> *k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a kset.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*k</span></code></dt><dd><p>kset.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kset_find_obj">
struct kobject * <code class="sig-name descname">kset_find_obj</code><span class="sig-paren">(</span>struct kset<em> *kset</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_find_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for object in kset.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*kset</span></code></dt><dd><p>kset we’re looking in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>object’s name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock kset via <strong>kset-&gt;subsys</strong>, and iterate over <strong>kset-&gt;list</strong>,
looking for a matching kobject. If matching object is found
take a reference and return the object.</p>
</div>
<dl class="function">
<dt id="c.kset_create_and_add">
struct kset * <code class="sig-name descname">kset_create_and_add</code><span class="sig-paren">(</span>const char<em> *name</em>, const struct kset_uevent_ops<em> *uevent_ops</em>, struct kobject<em> *parent_kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_create_and_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a struct kset dynamically and add it to sysfs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name for the kset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kset_uevent_ops</span> <span class="pre">*uevent_ops</span></code></dt><dd><p>a struct kset_uevent_ops for the kset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*parent_kobj</span></code></dt><dd><p>the parent kobject of this kset, if any.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a kset structure dynamically and registers it
with sysfs.  When you are finished with this structure, call
<a class="reference internal" href="#c.kset_unregister" title="kset_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">kset_unregister()</span></code></a> and the structure will be dynamically freed when it
is no longer being used.</p>
<p>If the kset was not able to be created, NULL will be returned.</p>
</div>
</section>
<section id="kernel-utility-functions">
<h2>Kernel utility functions<a class="headerlink" href="#kernel-utility-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.REPEAT_BYTE">
<code class="sig-name descname">REPEAT_BYTE</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.REPEAT_BYTE" title="Permalink to this definition">¶</a></dt>
<dd><p>repeat the value <strong>x</strong> multiple times as an unsigned long value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">x</span></code></dt><dd><p>value to repeat</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p><strong>x</strong> is not checked for &gt; 0xff; larger values produce odd results.</p>
</div>
<dl class="function">
<dt id="c.ARRAY_SIZE">
<code class="sig-name descname">ARRAY_SIZE</code><span class="sig-paren">(</span><em>arr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ARRAY_SIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>get the number of elements in array <strong>arr</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">arr</span></code></dt><dd><p>array to be sized</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.upper_32_bits">
<code class="sig-name descname">upper_32_bits</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.upper_32_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>return bits 32-63 of a number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>the number we’re accessing</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress
the “right shift count &gt;= width of type” warning when that quantity is
32-bits.</p>
</div>
<dl class="function">
<dt id="c.lower_32_bits">
<code class="sig-name descname">lower_32_bits</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lower_32_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>return bits 0-31 of a number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>the number we’re accessing</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.upper_16_bits">
<code class="sig-name descname">upper_16_bits</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.upper_16_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>return bits 16-31 of a number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>the number we’re accessing</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.lower_16_bits">
<code class="sig-name descname">lower_16_bits</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lower_16_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>return bits 0-15 of a number</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>the number we’re accessing</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.might_sleep">
<code class="sig-name descname">might_sleep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.might_sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>annotation for functions that can sleep</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>this macro will print a stack trace if it is executed in an atomic
context (spinlock, irq-handler, …). Additional sections where blocking is
not allowed can be annotated with <a class="reference internal" href="#c.non_block_start" title="non_block_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">non_block_start()</span></code></a> and <a class="reference internal" href="#c.non_block_end" title="non_block_end"><code class="xref c c-func docutils literal notranslate"><span class="pre">non_block_end()</span></code></a>
pairs.</p>
<p>This is a useful debugging help to be able to catch problems early and not
be bitten later when the calling function happens to sleep when it is not
supposed to.</p>
</div>
<dl class="function">
<dt id="c.cant_sleep">
<code class="sig-name descname">cant_sleep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.cant_sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>annotation for functions that cannot sleep</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>this macro will print a stack trace if it is executed with preemption enabled</p>
</div>
<dl class="function">
<dt id="c.cant_migrate">
<code class="sig-name descname">cant_migrate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.cant_migrate" title="Permalink to this definition">¶</a></dt>
<dd><p>annotation for functions that cannot migrate</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Will print a stack trace if executed in code which is migratable</p>
</div>
<dl class="function">
<dt id="c.non_block_start">
<code class="sig-name descname">non_block_start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.non_block_start" title="Permalink to this definition">¶</a></dt>
<dd><p>annotate the start of section where sleeping is prohibited</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This is on behalf of the oom reaper, specifically when it is calling the mmu
notifiers. The problem is that if the notifier were to block on, for example,
<a class="reference internal" href="../kernel-hacking/locking.html#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a> and if the process which holds that mutex were to perform a
sleeping memory allocation, the oom reaper is now blocked on completion of
that memory allocation. Other blocking calls like <a class="reference internal" href="#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_event()</span></code></a> pose similar
issues.</p>
</div>
<dl class="function">
<dt id="c.non_block_end">
<code class="sig-name descname">non_block_end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.non_block_end" title="Permalink to this definition">¶</a></dt>
<dd><p>annotate the end of section where sleeping is prohibited</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Closes a section opened by <a class="reference internal" href="#c.non_block_start" title="non_block_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">non_block_start()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.trace_printk">
<code class="sig-name descname">trace_printk</code><span class="sig-paren">(</span><em>fmt</em>, <em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.trace_printk" title="Permalink to this definition">¶</a></dt>
<dd><p>printf formatting in the ftrace buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fmt</span></code></dt><dd><p>the printf format for printing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>__trace_printk is an internal function for trace_printk() and</dt><dd><p>the <strong>ip</strong> is passed in via the <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> macro.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows a kernel developer to debug fast path sections
that printk is not appropriate for. By scattering in various
printk like tracing in the code, a developer can quickly see
where problems are occurring.</p>
<p>This is intended as a debugging tool for the developer only.
Please refrain from leaving trace_printks scattered around in
your code. (Extra memory is used for special buffers that are
allocated when <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> is used.)</p>
<p>A little optimization trick is done here. If there’s only one
argument, there’s no need to scan the string for printf formats.
The <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a> will suffice. But how can we take advantage of
using <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a> when <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> has only one argument?
By stringifying the args and checking the size we can tell
whether or not there are args. __stringify((__VA_ARGS__)) will
turn into “()0” with a size of 3 when there are no args, anything
else will be bigger. All we need to do is define a string to this,
and then take its size and compare to 3. If it’s bigger, use
do_trace_printk() otherwise, optimize it to <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a>. Then just
let gcc optimize the rest.</p>
</div>
<dl class="function">
<dt id="c.trace_puts">
<code class="sig-name descname">trace_puts</code><span class="sig-paren">(</span><em>str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.trace_puts" title="Permalink to this definition">¶</a></dt>
<dd><p>write a string into the ftrace buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">str</span></code></dt><dd><p>the string to record</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>__trace_bputs is an internal function for trace_puts and</dt><dd><p>the <strong>ip</strong> is passed in via the trace_puts macro.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_printk()</span></code></a> but is made for those really fast
paths that a developer wants the least amount of “Heisenbug” effects,
where the processing of the print format is still too much.</p>
<p>This function allows a kernel developer to debug fast path sections
that printk is not appropriate for. By scattering in various
printk like tracing in the code, a developer can quickly see
where problems are occurring.</p>
<p>This is intended as a debugging tool for the developer only.
Please refrain from leaving trace_puts scattered around in
your code. (Extra memory is used for special buffers that are
allocated when <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal notranslate"><span class="pre">trace_puts()</span></code></a> is used.)</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0 if nothing was written, positive # if string was.</dt><dd><p>(1 when __trace_bputs is used, strlen(str) when __trace_puts is used)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.console_list_lock">
void <code class="sig-name descname">console_list_lock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_list_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the console list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For console list or console-&gt;flags updates</p>
</div>
<dl class="function">
<dt id="c.console_list_unlock">
void <code class="sig-name descname">console_list_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_list_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the console list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Counterpart to <a class="reference internal" href="#c.console_list_lock" title="console_list_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_list_lock()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.console_srcu_read_lock">
int <code class="sig-name descname">console_srcu_read_lock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_srcu_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a new reader for the SRCU-protected console list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use for_each_console_srcu() to iterate the console list</p>
<p><strong>Context</strong></p>
<p>Any context.</p>
<p><strong>Return</strong></p>
<p>A cookie to pass to <a class="reference internal" href="#c.console_srcu_read_unlock" title="console_srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_srcu_read_unlock()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.console_srcu_read_unlock">
void <code class="sig-name descname">console_srcu_read_unlock</code><span class="sig-paren">(</span>int<em> cookie</em><span class="sig-paren">)</span><a class="headerlink" href="#c.console_srcu_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister an old reader from the SRCU-protected console list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cookie</span></code></dt><dd><p>cookie returned from <a class="reference internal" href="#c.console_srcu_read_lock" title="console_srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_srcu_read_lock()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Counterpart to <a class="reference internal" href="#c.console_srcu_read_lock" title="console_srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_srcu_read_lock()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.console_lock">
void <code class="sig-name descname">console_lock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>block the console subsystem from printing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires a lock which guarantees that no consoles will
be in or enter their write() callback.</p>
<p>Can sleep, returns nothing.</p>
</div>
<dl class="function">
<dt id="c.console_trylock">
int <code class="sig-name descname">console_trylock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_trylock" title="Permalink to this definition">¶</a></dt>
<dd><p>try to block the console subsystem from printing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to acquire a lock which guarantees that no consoles will
be in or enter their write() callback.</p>
<p>returns 1 on success, and 0 on failure to acquire the lock.</p>
</div>
<dl class="function">
<dt id="c.console_unlock">
void <code class="sig-name descname">console_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>unblock the console subsystem from printing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the console_lock which the caller holds to block printing of
the console subsystem.</p>
<p>While the console_lock was held, console output may have been buffered
by <a class="reference internal" href="../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a>.  If this is the case, <a class="reference internal" href="#c.console_unlock" title="console_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_unlock()</span></code></a>; emits
the output prior to releasing the lock.</p>
<p><a class="reference internal" href="#c.console_unlock" title="console_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_unlock()</span></code></a>; may be called from any context.</p>
</div>
<dl class="function">
<dt id="c.console_conditional_schedule">
void <code class="sig-name descname">console_conditional_schedule</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_conditional_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>yield the CPU if required</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the console code is currently allowed to sleep, and
if this CPU should yield the CPU to another task, do
so here.</p>
<p>Must be called within <a class="reference internal" href="#c.console_lock" title="console_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_lock()</span></code></a>;.</p>
</div>
<dl class="function">
<dt id="c.console_force_preferred_locked">
void <code class="sig-name descname">console_force_preferred_locked</code><span class="sig-paren">(</span>struct console<em> *con</em><span class="sig-paren">)</span><a class="headerlink" href="#c.console_force_preferred_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>force a registered console preferred</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">console</span> <span class="pre">*con</span></code></dt><dd><p>The registered console to force preferred.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called under <a class="reference internal" href="#c.console_list_lock" title="console_list_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">console_list_lock()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.printk_timed_ratelimit">
bool <code class="sig-name descname">printk_timed_ratelimit</code><span class="sig-paren">(</span>unsigned long<em> *caller_jiffies</em>, unsigned int<em> interval_msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.printk_timed_ratelimit" title="Permalink to this definition">¶</a></dt>
<dd><p>caller-controlled printk ratelimiting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*caller_jiffies</span></code></dt><dd><p>pointer to caller’s state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">interval_msecs</span></code></dt><dd><p>minimum interval between prints</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.printk_timed_ratelimit" title="printk_timed_ratelimit"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk_timed_ratelimit()</span></code></a> returns true if more than <strong>interval_msecs</strong>
milliseconds have elapsed since the last time <a class="reference internal" href="#c.printk_timed_ratelimit" title="printk_timed_ratelimit"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk_timed_ratelimit()</span></code></a>
returned true.</p>
</div>
<dl class="function">
<dt id="c.kmsg_dump_register">
int <code class="sig-name descname">kmsg_dump_register</code><span class="sig-paren">(</span>struct kmsg_dumper<em> *dumper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a kernel log dumper.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*dumper</span></code></dt><dd><p>pointer to the kmsg_dumper structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a kernel log dumper to the system. The dump callback in the
structure will be called when the kernel oopses or panics and must be
set. Returns zero on success and <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> or <code class="docutils literal notranslate"><span class="pre">-EBUSY</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.kmsg_dump_unregister">
int <code class="sig-name descname">kmsg_dump_unregister</code><span class="sig-paren">(</span>struct kmsg_dumper<em> *dumper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a kmsg dumper.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*dumper</span></code></dt><dd><p>pointer to the kmsg_dumper structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a dump device from the system. Returns zero on success and
<code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.kmsg_dump_get_line">
bool <code class="sig-name descname">kmsg_dump_get_line</code><span class="sig-paren">(</span>struct kmsg_dump_iter<em> *iter</em>, bool<em> syslog</em>, char<em> *line</em>, size_t<em> size</em>, size_t<em> *len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_get_line" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve one kmsg log line</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dump_iter</span> <span class="pre">*iter</span></code></dt><dd><p>kmsg dump iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">syslog</span></code></dt><dd><p>include the “&lt;4&gt;” prefixes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*line</span></code></dt><dd><p>buffer to copy the line to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>maximum size of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*len</span></code></dt><dd><p>length of line placed into buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start at the beginning of the kmsg buffer, with the oldest kmsg
record, and copy one record into the provided buffer.</p>
<p>Consecutive calls will return the next available record moving
towards the end of the buffer with the youngest messages.</p>
<p>A return value of FALSE indicates that there are no more records to
read.</p>
</div>
<dl class="function">
<dt id="c.kmsg_dump_get_buffer">
bool <code class="sig-name descname">kmsg_dump_get_buffer</code><span class="sig-paren">(</span>struct kmsg_dump_iter<em> *iter</em>, bool<em> syslog</em>, char<em> *buf</em>, size_t<em> size</em>, size_t<em> *len_out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_get_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>copy kmsg log lines</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dump_iter</span> <span class="pre">*iter</span></code></dt><dd><p>kmsg dump iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">syslog</span></code></dt><dd><p>include the “&lt;4&gt;” prefixes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>buffer to copy the line to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>maximum size of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*len_out</span></code></dt><dd><p>length of line placed into buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start at the end of the kmsg buffer and fill the provided buffer
with as many of the <em>youngest</em> kmsg records that fit into it.
If the buffer is large enough, all available kmsg records will be
copied with a single call.</p>
<p>Consecutive calls will fill the buffer with the next block of
available older records, not including the earlier retrieved ones.</p>
<p>A return value of FALSE indicates that there are no more records to
read.</p>
</div>
<dl class="function">
<dt id="c.kmsg_dump_rewind">
void <code class="sig-name descname">kmsg_dump_rewind</code><span class="sig-paren">(</span>struct kmsg_dump_iter<em> *iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kmsg_dump_iter</span> <span class="pre">*iter</span></code></dt><dd><p>kmsg dump iterator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset the dumper’s iterator so that <a class="reference internal" href="#c.kmsg_dump_get_line" title="kmsg_dump_get_line"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmsg_dump_get_line()</span></code></a> and
<a class="reference internal" href="#c.kmsg_dump_get_buffer" title="kmsg_dump_get_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmsg_dump_get_buffer()</span></code></a> can be called again and used multiple
times within the same dumper.dump() callback.</p>
</div>
<dl class="function">
<dt id="c.__printk_cpu_sync_wait">
void <code class="sig-name descname">__printk_cpu_sync_wait</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.__printk_cpu_sync_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Busy wait until the printk cpu-reentrant spinning lock is not owned by any CPU.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Any context.</p>
</div>
<dl class="function">
<dt id="c.__printk_cpu_sync_try_get">
int <code class="sig-name descname">__printk_cpu_sync_try_get</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.__printk_cpu_sync_try_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to acquire the printk cpu-reentrant spinning lock.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If no processor has the lock, the calling processor takes the lock and
becomes the owner. If the calling processor is already the owner of the
lock, this function succeeds immediately.</p>
<p><strong>Context</strong></p>
<p>Any context. Expects interrupts to be disabled.</p>
<p><strong>Return</strong></p>
<p>1 on success, otherwise 0.</p>
</div>
<dl class="function">
<dt id="c.__printk_cpu_sync_put">
void <code class="sig-name descname">__printk_cpu_sync_put</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.__printk_cpu_sync_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the printk cpu-reentrant spinning lock.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The calling processor must be the owner of the lock.</p>
<p><strong>Context</strong></p>
<p>Any context. Expects interrupts to be disabled.</p>
</div>
<dl class="function">
<dt id="c.panic">
void <code class="sig-name descname">panic</code><span class="sig-paren">(</span>const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.panic" title="Permalink to this definition">¶</a></dt>
<dd><p>halt the system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The text string to print</p>
<p>Display a message, then perform cleanups.</p>
<p>This function never returns.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.add_taint">
void <code class="sig-name descname">add_taint</code><span class="sig-paren">(</span>unsigned<em> flag</em>, enum lockdep_ok<em> lockdep_ok</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_taint" title="Permalink to this definition">¶</a></dt>
<dd><p>add a taint flag if not already set.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flag</span></code></dt><dd><p>one of the TAINT_* constants.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">lockdep_ok</span> <span class="pre">lockdep_ok</span></code></dt><dd><p>whether lock debugging is still OK.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If something bad has gone wrong, you’ll want <strong>lockdebug_ok</strong> = false, but for
some notewortht-but-not-corrupting cases, it can be set to true.</p>
</div>
</section>
<section id="device-resource-management">
<h2>Device Resource Management<a class="headerlink" href="#device-resource-management" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.__devres_alloc_node">
void * <code class="sig-name descname">__devres_alloc_node</code><span class="sig-paren">(</span>dr_release_t<em> release</em>, size_t<em> size</em>, gfp_t<em> gfp</em>, int<em> nid</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__devres_alloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate device resource data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Release function devres will be associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nid</span></code></dt><dd><p>NUMA node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the resource</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate devres of <strong>size</strong> bytes.  The allocated area is zeroed, then
associated with <strong>release</strong>.  The returned pointer can be passed to
other devres_*() functions.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated devres on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.devres_for_each_res">
void <code class="sig-name descname">devres_for_each_res</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, dr_release_t<em> release</em>, dr_match_t<em> match</em>, void<em> *match_data</em>, void (<em>*fn</em>)(struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *, void *, void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_for_each_res" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource iterator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to iterate resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*fn)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Function to be called for each matched resource.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Data for <strong>fn</strong>, the 3rd parameter of <strong>fn</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <strong>fn</strong> for each devres of <strong>dev</strong> which is associated with <strong>release</strong>
and for which <strong>match</strong> returns 1.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>void</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.devres_free">
void <code class="sig-name descname">devres_free</code><span class="sig-paren">(</span>void<em> *res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free device resource data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*res</span></code></dt><dd><p>Pointer to devres data to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free devres created with devres_alloc().</p>
</div>
<dl class="function">
<dt id="c.devres_add">
void <code class="sig-name descname">devres_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Register device resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to add resource to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*res</span></code></dt><dd><p>Resource to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register devres <strong>res</strong> to <strong>dev</strong>.  <strong>res</strong> should have been allocated
using devres_alloc().  On driver detach, the associated release
function will be invoked and devres will be freed automatically.</p>
</div>
<dl class="function">
<dt id="c.devres_find">
void * <code class="sig-name descname">devres_find</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, dr_release_t<em> release</em>, dr_match_t<em> match</em>, void<em> *match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find device resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to lookup resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> which is associated with <strong>release</strong>
and for which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered
to match all.</p>
<p><strong>Return</strong></p>
<p>Pointer to found devres, NULL if not found.</p>
</div>
<dl class="function">
<dt id="c.devres_get">
void * <code class="sig-name descname">devres_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *new_res</em>, dr_match_t<em> match</em>, void<em> *match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Find devres, if non-existent, add one atomically</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to lookup or add devres for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*new_res</span></code></dt><dd><p>Pointer to new initialized devres to add if not found</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> which has the same release function
as <strong>new_res</strong> and for which <strong>match</strong> return 1.  If found, <strong>new_res</strong> is
freed; otherwise, <strong>new_res</strong> is added atomically.</p>
<p><strong>Return</strong></p>
<p>Pointer to found or added devres.</p>
</div>
<dl class="function">
<dt id="c.devres_remove">
void * <code class="sig-name descname">devres_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, dr_release_t<em> release</em>, dr_match_t<em> match</em>, void<em> *match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a device resource and remove it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to find resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered to
match all.  If found, the resource is removed atomically and
returned.</p>
<p><strong>Return</strong></p>
<p>Pointer to removed devres on success, NULL if not found.</p>
</div>
<dl class="function">
<dt id="c.devres_destroy">
int <code class="sig-name descname">devres_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, dr_release_t<em> release</em>, dr_match_t<em> match</em>, void<em> *match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a device resource and destroy it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to find resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered to
match all.  If found, the resource is removed atomically and freed.</p>
<p>Note that the release function for the resource will not be called,
only the devres-allocated data will be freed.  The caller becomes
responsible for freeing any other data.</p>
<p><strong>Return</strong></p>
<p>0 if devres is found and freed, -ENOENT if not found.</p>
</div>
<dl class="function">
<dt id="c.devres_release">
int <code class="sig-name descname">devres_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, dr_release_t<em> release</em>, dr_match_t<em> match</em>, void<em> *match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a device resource and destroy it, calling release</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to find resource from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt><dd><p>Look for resources associated with this release function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt><dd><p>Match function (optional)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*match_data</span></code></dt><dd><p>Data for the match function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it’s considered to
match all.  If found, the resource is removed atomically, the
release function called and the resource freed.</p>
<p><strong>Return</strong></p>
<p>0 if devres is found and freed, -ENOENT if not found.</p>
</div>
<dl class="function">
<dt id="c.devres_open_group">
void * <code class="sig-name descname">devres_open_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *id</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_open_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a new devres group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to open devres group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>Separator ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open a new devres group for <strong>dev</strong> with <strong>id</strong>.  For <strong>id</strong>, using a
pointer to an object which won’t be used for another group is
recommended.  If <strong>id</strong> is NULL, address-wise unique ID is created.</p>
<p><strong>Return</strong></p>
<p>ID of the new group, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.devres_close_group">
void <code class="sig-name descname">devres_close_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_close_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a devres group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to close devres group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>ID of target group, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Close the group identified by <strong>id</strong>.  If <strong>id</strong> is NULL, the latest open
group is selected.</p>
</div>
<dl class="function">
<dt id="c.devres_remove_group">
void <code class="sig-name descname">devres_remove_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_remove_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a devres group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to remove group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>ID of target group, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove the group identified by <strong>id</strong>.  If <strong>id</strong> is NULL, the latest
open group is selected.  Note that removing a group doesn’t affect
any other resources.</p>
</div>
<dl class="function">
<dt id="c.devres_release_group">
int <code class="sig-name descname">devres_release_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_release_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resources in a devres group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to release group for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*id</span></code></dt><dd><p>ID of target group, can be NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release all resources in the group identified by <strong>id</strong>.  If <strong>id</strong> is
NULL, the latest open group is selected.  The selected group and
groups properly nested inside the selected group are removed.</p>
<p><strong>Return</strong></p>
<p>The number of released non-group resources.</p>
</div>
<dl class="function">
<dt id="c.devm_add_action">
int <code class="sig-name descname">devm_add_action</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void (<em>*action</em>)(void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_add_action" title="Permalink to this definition">¶</a></dt>
<dd><p>add a custom action to list of managed resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device that owns the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*action)(void</span> <span class="pre">*)</span></code></dt><dd><p>Function that should be called</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to data passed to <strong>action</strong> implementation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds a custom action to the list of managed resources so that
it gets executed as part of standard resource unwinding.</p>
</div>
<dl class="function">
<dt id="c.devm_remove_action">
void <code class="sig-name descname">devm_remove_action</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void (<em>*action</em>)(void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_remove_action" title="Permalink to this definition">¶</a></dt>
<dd><p>removes previously added custom action</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device that owns the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*action)(void</span> <span class="pre">*)</span></code></dt><dd><p>Function implementing the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to data passed to <strong>action</strong> implementation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes instance of <strong>action</strong> previously added by <a class="reference internal" href="#c.devm_add_action" title="devm_add_action"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_add_action()</span></code></a>.
Both action and data should match one of the existing entries.</p>
</div>
<dl class="function">
<dt id="c.devm_release_action">
void <code class="sig-name descname">devm_release_action</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void (<em>*action</em>)(void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_release_action" title="Permalink to this definition">¶</a></dt>
<dd><p>release previously added custom action</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device that owns the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*action)(void</span> <span class="pre">*)</span></code></dt><dd><p>Function implementing the action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>Pointer to data passed to <strong>action</strong> implementation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases and removes instance of <strong>action</strong> previously added by
<a class="reference internal" href="#c.devm_add_action" title="devm_add_action"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_add_action()</span></code></a>.  Both action and data should match one of the
existing entries.</p>
</div>
<dl class="function">
<dt id="c.devm_kmalloc">
void * <code class="sig-name descname">devm_kmalloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, size_t<em> size</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kmalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed kmalloc</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation gfp flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed kmalloc.  Memory allocated with this function is
automatically freed on driver detach.  Like all other devres
resources, guaranteed alignment is unsigned long long.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_krealloc">
void * <code class="sig-name descname">devm_krealloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void<em> *ptr</em>, size_t<em> new_size</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_krealloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="../core-api/mm-api.html#c.krealloc" title="krealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">krealloc()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to re-allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>Pointer to the memory chunk to re-allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">new_size</span></code></dt><dd><p>New allocation size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>Allocation gfp flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="../core-api/mm-api.html#c.krealloc" title="krealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">krealloc()</span></code></a>. Resizes the memory chunk allocated with <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a>.
Behaves similarly to regular <a class="reference internal" href="../core-api/mm-api.html#c.krealloc" title="krealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">krealloc()</span></code></a>: if <strong>ptr</strong> is NULL or ZERO_SIZE_PTR,
it’s the equivalent of <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a>. If new_size is zero, it frees the
previously allocated memory and returns ZERO_SIZE_PTR. This function doesn’t
change the order in which the release callback for the re-alloc’ed devres
will be called (except when falling back to <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> or when freeing
resources when new_size is zero). The contents of the memory are preserved
up to the lesser of new and old sizes.</p>
</div>
<dl class="function">
<dt id="c.devm_kstrdup">
char * <code class="sig-name descname">devm_kstrdup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *s</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kstrdup" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate resource managed space and copy an existing string into that.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_kstrdup_const">
const char * <code class="sig-name descname">devm_kstrdup_const</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *s</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kstrdup_const" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed conditional string duplication</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for which to duplicate the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*s</span></code></dt><dd><p>the string to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> call when allocating memory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Strings allocated by devm_kstrdup_const will be automatically freed when
the associated device is detached.</p>
<p><strong>Return</strong></p>
<p>Source string if it is in .rodata section otherwise it falls back to
devm_kstrdup.</p>
</div>
<dl class="function">
<dt id="c.devm_kvasprintf">
char * <code class="sig-name descname">devm_kvasprintf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, gfp_t<em> gfp</em>, const char<em> *fmt</em>, va_list<em> ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kvasprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate resource managed space and format a string into that.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The printf()-style format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">va_list</span> <span class="pre">ap</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_kasprintf">
char * <code class="sig-name descname">devm_kasprintf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, gfp_t<em> gfp</em>, const char<em> *fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kasprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate resource managed space and format a string into that.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt</span></code></dt><dd><p>The printf()-style format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>Arguments for the format string</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_kfree">
void <code class="sig-name descname">devm_kfree</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const void<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kfree" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed kfree</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>Memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.devm_kmemdup">
void * <code class="sig-name descname">devm_kmemdup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const void<em> *src</em>, size_t<em> len</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kmemdup" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed kmemdup</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*src</span></code></dt><dd><p>Memory region to duplicate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>Memory region length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>GFP mask to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Duplicate region of a memory using resource managed kmalloc</p>
</div>
<dl class="function">
<dt id="c.devm_get_free_pages">
unsigned long <code class="sig-name descname">devm_get_free_pages</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, gfp_t<em> gfp_mask</em>, unsigned int<em> order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_get_free_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed __get_free_pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>Allocation gfp flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>Allocation size is (1 &lt;&lt; order) pages</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed get_free_pages.  Memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Address of allocated memory on success, 0 on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_free_pages">
void <code class="sig-name descname">devm_free_pages</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, unsigned long<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_free_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed free_pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>Memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="#c.devm_get_free_pages" title="devm_get_free_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_get_free_pages()</span></code></a>. Unlike free_pages,
there is no need to supply the <strong>order</strong>.</p>
</div>
<dl class="function">
<dt id="c.__devm_alloc_percpu">
void __percpu * <code class="sig-name descname">__devm_alloc_percpu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, size_t<em> size</em>, size_t<em> align</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__devm_alloc_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed alloc_percpu</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to allocate per-cpu memory for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of per-cpu memory to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">align</span></code></dt><dd><p>Alignment of per-cpu memory to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed alloc_percpu. Per-cpu memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.devm_free_percpu">
void <code class="sig-name descname">devm_free_percpu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void __percpu<em> *pdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_free_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed free_percpu</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device this memory belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*pdata</span></code></dt><dd><p>Per-cpu memory to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="infrastructure.html#c.devm_alloc_percpu" title="devm_alloc_percpu"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_alloc_percpu()</span></code></a>.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Driver Basics</a><ul>
<li><a class="reference internal" href="#driver-entry-and-exit-points">Driver Entry and Exit points</a></li>
<li><a class="reference internal" href="#driver-device-table">Driver device table</a></li>
<li><a class="reference internal" href="#delaying-scheduling-and-timer-routines">Delaying, scheduling, and timer routines</a></li>
<li><a class="reference internal" href="#wait-queues-and-wake-events">Wait queues and Wake events</a></li>
<li><a class="reference internal" href="#high-resolution-timers">High-resolution timers</a></li>
<li><a class="reference internal" href="#internal-functions">Internal Functions</a></li>
<li><a class="reference internal" href="#reference-counting">Reference counting</a></li>
<li><a class="reference internal" href="#atomics">Atomics</a></li>
<li><a class="reference internal" href="#kernel-objects-manipulation">Kernel objects manipulation</a></li>
<li><a class="reference internal" href="#kernel-utility-functions">Kernel utility functions</a></li>
<li><a class="reference internal" href="#device-resource-management">Device Resource Management</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/basics.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/basics.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>