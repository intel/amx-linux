
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Linux kernel SLIMbus support &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SoundWire Documentation" href="soundwire/index.html" />
    <link rel="prev" title="PXA/MMP - DMA Slave controller" href="dmaengine/pxa_dma.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="linux-kernel-slimbus-support">
<h1>Linux kernel SLIMbus support<a class="headerlink" href="#linux-kernel-slimbus-support" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<section id="what-is-slimbus">
<h3>What is SLIMbus?<a class="headerlink" href="#what-is-slimbus" title="Permalink to this headline">¶</a></h3>
<p>SLIMbus (Serial Low Power Interchip Media Bus) is a specification developed by
MIPI (Mobile Industry Processor Interface) alliance. The bus uses master/slave
configuration, and is a 2-wire multi-drop implementation (clock, and data).</p>
<p>Currently, SLIMbus is used to interface between application processors of SoCs
(System-on-Chip) and peripheral components (typically codec). SLIMbus uses
Time-Division-Multiplexing to accommodate multiple data channels, and
a control channel.</p>
<p>The control channel is used for various control functions such as bus
management, configuration and status updates. These messages can be unicast (e.g.
reading/writing device specific values), or multicast (e.g. data channel
reconfiguration sequence is a broadcast message announced to all devices)</p>
<p>A data channel is used for data-transfer between 2 SLIMbus devices. Data
channel uses dedicated ports on the device.</p>
</section>
<section id="hardware-description">
<h3>Hardware description:<a class="headerlink" href="#hardware-description" title="Permalink to this headline">¶</a></h3>
<p>SLIMbus specification has different types of device classifications based on
their capabilities.
A manager device is responsible for enumeration, configuration, and dynamic
channel allocation. Every bus has 1 active manager.</p>
<p>A generic device is a device providing application functionality (e.g. codec).</p>
<p>Framer device is responsible for clocking the bus, and transmitting frame-sync
and framing information on the bus.</p>
<p>Each SLIMbus component has an interface device for monitoring physical layer.</p>
<p>Typically each SoC contains SLIMbus component having 1 manager, 1 framer device,
1 generic device (for data channel support), and 1 interface device.
External peripheral SLIMbus component usually has 1 generic device (for
functionality/data channel support), and an associated interface device.
The generic device’s registers are mapped as ‘value elements’ so that they can
be written/read using SLIMbus control channel exchanging control/status type of
information.
In case there are multiple framer devices on the same bus, manager device is
responsible to select the active-framer for clocking the bus.</p>
<p>Per specification, SLIMbus uses “clock gears” to do power management based on
current frequency and bandwidth requirements. There are 10 clock gears and each
gear changes the SLIMbus frequency to be twice its previous gear.</p>
<p>Each device has a 6-byte enumeration-address and the manager assigns every
device with a 1-byte logical address after the devices report presence on the
bus.</p>
</section>
<section id="software-description">
<h3>Software description:<a class="headerlink" href="#software-description" title="Permalink to this headline">¶</a></h3>
<p>There are 2 types of SLIMbus drivers:</p>
<p>slim_controller represents a ‘controller’ for SLIMbus. This driver should
implement duties needed by the SoC (manager device, associated
interface device for monitoring the layers and reporting errors, default
framer device).</p>
<p>slim_device represents the ‘generic device/component’ for SLIMbus, and a
slim_driver should implement driver for that slim_device.</p>
</section>
<section id="device-notifications-to-the-driver">
<h3>Device notifications to the driver:<a class="headerlink" href="#device-notifications-to-the-driver" title="Permalink to this headline">¶</a></h3>
<p>Since SLIMbus devices have mechanisms for reporting their presence, the
framework allows drivers to bind when corresponding devices report their
presence on the bus.
However, it is possible that the driver needs to be probed
first so that it can enable corresponding SLIMbus device (e.g. power it up and/or
take it out of reset). To support that behavior, the framework allows drivers
to probe first as well  (e.g. using standard DeviceTree compatibility field).
This creates the necessity for the driver to know when the device is functional
(i.e. reported present). device_up callback is used for that reason when the
device reports present and is assigned a logical address by the controller.</p>
<p>Similarly, SLIMbus devices ‘report absent’ when they go down. A ‘device_down’
callback notifies the driver when the device reports absent and its logical
address assignment is invalidated by the controller.</p>
<p>Another notification “boot_device” is used to notify the slim_driver when
controller resets the bus. This notification allows the driver to take necessary
steps to boot the device so that it’s functional after the bus has been reset.</p>
</section>
<section id="driver-and-controller-apis">
<h3>Driver and Controller APIs:<a class="headerlink" href="#driver-and-controller-apis" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.slim_eaddr">
struct <code class="sig-name descname">slim_eaddr</code><a class="headerlink" href="#c.slim_eaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumeration address for a SLIMbus device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_eaddr {
    u8 instance;
    u8 dev_index;
    u16 prod_code;
    u16 manf_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">instance</span></code></dt><dd><p>Instance value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_index</span></code></dt><dd><p>Device index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prod_code</span></code></dt><dd><p>Product code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">manf_id</span></code></dt><dd><p>Manufacturer Id for the device</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_device_status">
enum <code class="sig-name descname">slim_device_status</code><a class="headerlink" href="#c.slim_device_status" title="Permalink to this definition">¶</a></dt>
<dd><p>slim device status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_DEVICE_STATUS_DOWN</span></code></dt><dd><p>Slim device is absent or not reported yet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_DEVICE_STATUS_UP</span></code></dt><dd><p>Slim device is announced on the bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_DEVICE_STATUS_RESERVED</span></code></dt><dd><p>Reserved for future use.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_device">
struct <code class="sig-name descname">slim_device</code><a class="headerlink" href="#c.slim_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Slim device handle.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_device {
    struct device           dev;
    struct slim_eaddr       e_addr;
    struct slim_controller  *ctrl;
    enum slim_device_status status;
    u8 laddr;
    bool is_laddr_valid;
    struct list_head        stream_list;
    spinlock_t stream_list_lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Driver model representation of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_addr</span></code></dt><dd><p>Enumeration address of this device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ctrl</span></code></dt><dd><p>slim controller instance.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">status</span></code></dt><dd><p>slim device status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">laddr</span></code></dt><dd><p>1-byte Logical address of this device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_laddr_valid</span></code></dt><dd><p>indicates if the laddr is valid or not</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream_list</span></code></dt><dd><p>List of streams on this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stream_list_lock</span></code></dt><dd><p>lock to protect the stream list</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This is the client/device handle returned when a SLIMbus
device is registered with a controller.
Pointer to this structure is used by client-driver as a handle.</p>
<dl class="type">
<dt id="c.slim_driver">
struct <code class="sig-name descname">slim_driver</code><a class="headerlink" href="#c.slim_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus ‘generic device’ (slave) device driver (similar to ‘spi_device’ on SPI)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_driver {
    int (*probe)(struct slim_device *sl);
    void (*remove)(struct slim_device *sl);
    void (*shutdown)(struct slim_device *sl);
    int (*device_status)(struct slim_device *sl, enum slim_device_status s);
    struct device_driver            driver;
    const struct slim_device_id     *id_table;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>Binds this driver to a SLIMbus device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p>Unbinds this driver from the SLIMbus device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p>Standard shutdown callback used during powerdown/halt.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_status</span></code></dt><dd><p>This callback is called when
- The device reports present and gets a laddr assigned
- The device reports absent, or the bus goes down.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver</span></code></dt><dd><p>SLIMbus device drivers should initialize name and owner field of
this structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id_table</span></code></dt><dd><p>List of SLIMbus devices supported by this driver</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_val_inf">
struct <code class="sig-name descname">slim_val_inf</code><a class="headerlink" href="#c.slim_val_inf" title="Permalink to this definition">¶</a></dt>
<dd><p>Slimbus value or information element</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_val_inf {
    u16 start_offset;
    u8 num_bytes;
    u8 *rbuf;
    const u8                *wbuf;
    struct completion      *comp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">start_offset</span></code></dt><dd><p>Specifies starting offset in information/value element map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_bytes</span></code></dt><dd><p>upto 16. This ensures that the message will fit the slicesize
per SLIMbus spec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rbuf</span></code></dt><dd><p>buffer to read the values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wbuf</span></code></dt><dd><p>buffer to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">comp</span></code></dt><dd><p>completion for asynchronous operations, valid only if TID is
required for transaction, like REQUEST operations.
Rest of the transactions are synchronous anyway.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_stream_config">
struct <code class="sig-name descname">slim_stream_config</code><a class="headerlink" href="#c.slim_stream_config" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus stream configuration Configuring a stream is done at hw_params or prepare call from audio drivers where they have all the required information regarding rate, number of channels and so on. There is a 1:1 mapping of channel and ports.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_stream_config {
    unsigned int rate;
    unsigned int bps;
    unsigned int ch_count;
    unsigned int *chs;
    unsigned long port_mask;
    int direction;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rate</span></code></dt><dd><p>data rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bps</span></code></dt><dd><p>bits per data sample</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ch_count</span></code></dt><dd><p>number of channels</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chs</span></code></dt><dd><p>pointer to list of channel numbers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port_mask</span></code></dt><dd><p>port mask of ports to use for this stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction</span></code></dt><dd><p>direction of the stream, SNDRV_PCM_STREAM_PLAYBACK
or SNDRV_PCM_STREAM_CAPTURE.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.module_slim_driver">
<code class="sig-name descname">module_slim_driver</code><span class="sig-paren">(</span><em>__slim_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_slim_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a SLIMbus driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__slim_driver</span></code></dt><dd><p>slimbus_driver struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for SLIMbus drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a></p>
</div>
<dl class="type">
<dt id="c.slim_framer">
struct <code class="sig-name descname">slim_framer</code><a class="headerlink" href="#c.slim_framer" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents SLIMbus framer. Every controller may have multiple framers. There is 1 active framer device responsible for clocking the bus. Manager is responsible for framer hand-over.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_framer {
    struct device           dev;
    struct slim_eaddr       e_addr;
    int rootfreq;
    int superfreq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Driver model representation of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_addr</span></code></dt><dd><p>Enumeration address of the framer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rootfreq</span></code></dt><dd><p>Root Frequency at which the framer can run. This is maximum
frequency (‘clock gear 10’) at which the bus can operate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">superfreq</span></code></dt><dd><p>Superframes per root frequency. Every frame is 6144 bits.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_msg_txn">
struct <code class="sig-name descname">slim_msg_txn</code><a class="headerlink" href="#c.slim_msg_txn" title="Permalink to this definition">¶</a></dt>
<dd><p>Message to be sent by the controller. This structure has packet header, payload and buffer to be filled (if any)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_msg_txn {
    u8 rl;
    u8 mt;
    u8 mc;
    u8 dt;
    u16 ec;
    u8 tid;
    u8 la;
    struct slim_val_inf     *msg;
    struct completion      *comp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rl</span></code></dt><dd><p>Header field. remaining length.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mt</span></code></dt><dd><p>Header field. Message type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mc</span></code></dt><dd><p>Header field. LSB is message code for type mt.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dt</span></code></dt><dd><p>Header field. Destination type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ec</span></code></dt><dd><p>Element code. Used for elemental access APIs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid</span></code></dt><dd><p>Transaction ID. Used for messages expecting response.
(relevant for message-codes involving read operation)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">la</span></code></dt><dd><p>Logical address of the device this message is going to.
(Not used when destination type is broadcast.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">msg</span></code></dt><dd><p>Elemental access message to be read/written</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">comp</span></code></dt><dd><p>completion if read/write is synchronous, used internally
for tid based transactions.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_clk_state">
enum <code class="sig-name descname">slim_clk_state</code><a class="headerlink" href="#c.slim_clk_state" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus controller’s clock state used internally for maintaining current clock state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CLK_ACTIVE</span></code></dt><dd><p>SLIMbus clock is active</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CLK_ENTERING_PAUSE</span></code></dt><dd><p>SLIMbus clock pause sequence is being sent on the
bus. If this succeeds, state changes to SLIM_CLK_PAUSED. If the
transition fails, state changes back to SLIM_CLK_ACTIVE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CLK_PAUSED</span></code></dt><dd><p>SLIMbus controller clock has paused.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_sched">
struct <code class="sig-name descname">slim_sched</code><a class="headerlink" href="#c.slim_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Framework uses this structure internally for scheduling.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_sched {
    enum slim_clk_state     clk_state;
    struct completion       pause_comp;
    struct mutex            m_reconf;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">clk_state</span></code></dt><dd><p>Controller’s clock state from <a class="reference internal" href="#c.slim_clk_state" title="slim_clk_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">slim_clk_state</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pause_comp</span></code></dt><dd><p>Signals completion of clock pause sequence. This is useful when
client tries to call SLIMbus transaction when controller is entering
clock pause.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">m_reconf</span></code></dt><dd><p>This mutex is held until current reconfiguration (data channel
scheduling, message bandwidth reservation) is done. Message APIs can
use the bus concurrently when this mutex is held since elemental access
messages can be sent on the bus when reconfiguration is in progress.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_port_direction">
enum <code class="sig-name descname">slim_port_direction</code><a class="headerlink" href="#c.slim_port_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus port direction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PORT_SINK</span></code></dt><dd><p>SLIMbus port is a sink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PORT_SOURCE</span></code></dt><dd><p>SLIMbus port is a source</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_port_state">
enum <code class="sig-name descname">slim_port_state</code><a class="headerlink" href="#c.slim_port_state" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus Port/Endpoint state machine according to SLIMbus Spec 2.0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PORT_DISCONNECTED</span></code></dt><dd><p>SLIMbus port is disconnected
entered from Unconfigure/configured state after
DISCONNECT_PORT or REMOVE_CHANNEL core command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PORT_UNCONFIGURED</span></code></dt><dd><p>SLIMbus port is in unconfigured state.
entered from disconnect state after CONNECT_SOURCE/SINK core command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PORT_CONFIGURED</span></code></dt><dd><p>SLIMbus port is in configured state.
entered from unconfigured state after DEFINE_CHANNEL, DEFINE_CONTENT
and ACTIVATE_CHANNEL core commands. Ready for data transmission.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_channel_state">
enum <code class="sig-name descname">slim_channel_state</code><a class="headerlink" href="#c.slim_channel_state" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus channel state machine used by core.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_STATE_DISCONNECTED</span></code></dt><dd><p>SLIMbus channel is disconnected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_STATE_ALLOCATED</span></code></dt><dd><p>SLIMbus channel is allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_STATE_ASSOCIATED</span></code></dt><dd><p>SLIMbus channel is associated with port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_STATE_DEFINED</span></code></dt><dd><p>SLIMbus channel parameters are defined</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_STATE_CONTENT_DEFINED</span></code></dt><dd><p>SLIMbus channel content is defined</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_STATE_ACTIVE</span></code></dt><dd><p>SLIMbus channel is active and ready for data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_STATE_REMOVED</span></code></dt><dd><p>SLIMbus channel is inactive and removed</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_ch_data_fmt">
enum <code class="sig-name descname">slim_ch_data_fmt</code><a class="headerlink" href="#c.slim_ch_data_fmt" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus channel data Type identifiers according to Table 60 of SLIMbus Spec 1.01.01</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_DATA_FMT_NOT_DEFINED</span></code></dt><dd><p>Undefined</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_DATA_FMT_LPCM_AUDIO</span></code></dt><dd><p>LPCM audio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_DATA_FMT_IEC61937_COMP_AUDIO</span></code></dt><dd><p>IEC61937 Compressed audio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_DATA_FMT_PACKED_PDM_AUDIO</span></code></dt><dd><p>Packed PDM audio</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_ch_aux_bit_fmt">
enum <code class="sig-name descname">slim_ch_aux_bit_fmt</code><a class="headerlink" href="#c.slim_ch_aux_bit_fmt" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus channel Aux Field format IDs according to Table 63 of SLIMbus Spec 2.0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_AUX_FMT_NOT_APPLICABLE</span></code></dt><dd><p>Undefined</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_AUX_FMT_ZCUV_TUNNEL_IEC60958</span></code></dt><dd><p>ZCUV for tunneling IEC60958</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_CH_AUX_FMT_USER_DEFINED</span></code></dt><dd><p>User defined</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_channel">
struct <code class="sig-name descname">slim_channel</code><a class="headerlink" href="#c.slim_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus channel, used for state machine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_channel {
    int id;
    int prrate;
    int seg_dist;
    enum slim_ch_data_fmt data_fmt;
    enum slim_ch_aux_bit_fmt aux_fmt;
    enum slim_channel_state state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>ID of channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prrate</span></code></dt><dd><p>Presense rate of channel from Table 66 of SLIMbus 2.0 Specs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">seg_dist</span></code></dt><dd><p>segment distribution code from Table 20 of SLIMbus 2.0 Specs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_fmt</span></code></dt><dd><p>Data format of channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aux_fmt</span></code></dt><dd><p>Aux format for this channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>channel state machine</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_port">
struct <code class="sig-name descname">slim_port</code><a class="headerlink" href="#c.slim_port" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_port {
    int id;
    enum slim_port_direction direction;
    enum slim_port_state state;
    struct slim_channel ch;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Port id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction</span></code></dt><dd><p>Port direction, Source or Sink.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>state machine of port.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ch</span></code></dt><dd><p>channel associated with this port.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_transport_protocol">
enum <code class="sig-name descname">slim_transport_protocol</code><a class="headerlink" href="#c.slim_transport_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus Transport protocol list from Table 47 of SLIMbus 2.0 specs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PROTO_ISO</span></code></dt><dd><p>Isochronous Protocol, no flow control as data rate match
channel rate flow control embedded in the data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PROTO_PUSH</span></code></dt><dd><p>Pushed Protocol, includes flow control, Used to carry
data whose rate is equal to, or lower than the channel rate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PROTO_PULL</span></code></dt><dd><p>Pulled Protocol, similar usage as pushed protocol
but pull is a unicast.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PROTO_LOCKED</span></code></dt><dd><p>Locked Protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PROTO_ASYNC_SMPLX</span></code></dt><dd><p>Asynchronous Protocol-Simplex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PROTO_ASYNC_HALF_DUP</span></code></dt><dd><p>Asynchronous Protocol-Half-duplex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PROTO_EXT_SMPLX</span></code></dt><dd><p>Extended Asynchronous Protocol-Simplex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SLIM_PROTO_EXT_HALF_DUP</span></code></dt><dd><p>Extended Asynchronous Protocol-Half-duplex</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_stream_runtime">
struct <code class="sig-name descname">slim_stream_runtime</code><a class="headerlink" href="#c.slim_stream_runtime" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus stream runtime instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_stream_runtime {
    const char *name;
    struct slim_device *dev;
    int direction;
    enum slim_transport_protocol prot;
    unsigned int rate;
    unsigned int bps;
    unsigned int ratem;
    int num_ports;
    struct slim_port *ports;
    struct list_head node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>SLIM Device instance associated with this stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction</span></code></dt><dd><p>direction of stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prot</span></code></dt><dd><p>Transport protocol used in this stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate</span></code></dt><dd><p>Data rate of samples *</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bps</span></code></dt><dd><p>bits per sample</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ratem</span></code></dt><dd><p>rate multipler which is super frame rate/data rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ports</span></code></dt><dd><p>number of ports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ports</span></code></dt><dd><p>pointer to instance of ports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>list head for stream associated with slim device.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.slim_controller">
struct <code class="sig-name descname">slim_controller</code><a class="headerlink" href="#c.slim_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls every instance of SLIMbus (similar to ‘master’ on SPI)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct slim_controller {
    struct device           *dev;
    unsigned int            id;
    char name[SLIMBUS_NAME_SIZE];
    int min_cg;
    int max_cg;
    int clkgear;
    struct ida              laddr_ida;
    struct slim_framer      *a_framer;
    struct mutex            lock;
    struct list_head        devices;
    struct idr              tid_idr;
    spinlock_t txn_lock;
    struct slim_sched       sched;
    int (*xfer_msg)(struct slim_controller *ctrl, struct slim_msg_txn *tx);
    int (*set_laddr)(struct slim_controller *ctrl, struct slim_eaddr *ea, u8 laddr);
    int (*get_laddr)(struct slim_controller *ctrl, struct slim_eaddr *ea, u8 *laddr);
    int (*enable_stream)(struct slim_stream_runtime *rt);
    int (*disable_stream)(struct slim_stream_runtime *rt);
    int (*wakeup)(struct slim_controller *ctrl);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Device interface to this driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Board-specific number identifier for this controller/bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name for this controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_cg</span></code></dt><dd><p>Minimum clock gear supported by this controller (default value: 1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_cg</span></code></dt><dd><p>Maximum clock gear supported by this controller (default value: 10)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clkgear</span></code></dt><dd><p>Current clock gear in which this bus is running</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">laddr_ida</span></code></dt><dd><p>logical address id allocator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">a_framer</span></code></dt><dd><p>Active framer which is clocking the bus managed by this controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Mutex protecting controller data structures</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devices</span></code></dt><dd><p>Slim device list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_idr</span></code></dt><dd><p>tid id allocator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">txn_lock</span></code></dt><dd><p>Lock to protect table of transactions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sched</span></code></dt><dd><p>scheduler structure used by the controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfer_msg</span></code></dt><dd><p>Transfer a message on this controller (this can be a broadcast
control/status message like data channel setup, or a unicast message
like value element read/write.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_laddr</span></code></dt><dd><p>Setup logical address at laddr for the slave with elemental
address e_addr. Drivers implementing controller will be expected to
send unicast message to this device with its logical address.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_laddr</span></code></dt><dd><p>It is possible that controller needs to set fixed logical
address table and get_laddr can be used in that case so that controller
can do this assignment. Use case is when the master is on the remote
processor side, who is resposible for allocating laddr.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_stream</span></code></dt><dd><p>This function pointer implements controller-specific procedure
to enable a stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_stream</span></code></dt><dd><p>This function pointer implements controller-specific procedure
to disable stream.</p>
<p>‘Manager device’ is responsible for  device management, bandwidth
allocation, channel setup, and port associations per channel.
Device management means Logical address assignment/removal based on
enumeration (report-present, report-absent) of a device.
Bandwidth allocation is done dynamically by the manager based on active
channels on the bus, message-bandwidth requests made by SLIMbus devices.
Based on current bandwidth usage, manager chooses a frequency to run
the bus at (in steps of ‘clock-gear’, 1 through 10, each clock gear
representing twice the frequency than the previous gear).
Manager is also responsible for entering (and exiting) low-power-mode
(known as ‘clock pause’).
Manager can do handover of framer if there are multiple framers on the
bus and a certain usecase warrants using certain framer to avoid keeping
previous framer being powered-on.</p>
<p>Controller here performs duties of the manager device, and ‘interface
device’. Interface device is responsible for monitoring the bus and
reporting information such as loss-of-synchronization, data
slot-collision.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wakeup</span></code></dt><dd><p>This function pointer implements controller-specific procedure
to wake it up from clock-pause. Framework will call this to bring
the controller out of clock pause.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.slim_unregister_controller">
int <code class="sig-name descname">slim_unregister_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a><em> *ctrl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_unregister_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>Controller tear-down.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*ctrl</span></code></dt><dd><p>Controller to tear-down.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.slim_report_absent">
void <code class="sig-name descname">slim_report_absent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a><em> *sbdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_report_absent" title="Permalink to this definition">¶</a></dt>
<dd><p>Controller calls this function when a device reports absent, OR when the device cannot be communicated with</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*sbdev</span></code></dt><dd><p>Device that cannot be reached, or sent report absent</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.slim_get_device">
struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a> * <code class="sig-name descname">slim_get_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a><em> *ctrl</em>, struct <a class="reference internal" href="#c.slim_eaddr" title="slim_eaddr">slim_eaddr</a><em> *e_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>get handle to a device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*ctrl</span></code></dt><dd><p>Controller on which this device will be added/queried</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_eaddr</span> <span class="pre">*e_addr</span></code></dt><dd><p>Enumeration address of the device to be queried</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>pointer to a device if it has already reported. Creates a new
device and returns pointer to it if the device has not yet enumerated.</p>
</div>
<dl class="function">
<dt id="c.of_slim_get_device">
struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a> * <code class="sig-name descname">of_slim_get_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a><em> *ctrl</em>, struct device_node<em> *np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_slim_get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>get handle to a device using dt node.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*ctrl</span></code></dt><dd><p>Controller on which this device will be added/queried</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*np</span></code></dt><dd><p>node pointer to device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>pointer to a device if it has already reported. Creates a new
device and returns pointer to it if the device has not yet enumerated.</p>
</div>
<dl class="function">
<dt id="c.slim_device_report_present">
int <code class="sig-name descname">slim_device_report_present</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a><em> *ctrl</em>, struct <a class="reference internal" href="#c.slim_eaddr" title="slim_eaddr">slim_eaddr</a><em> *e_addr</em>, u8<em> *laddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_device_report_present" title="Permalink to this definition">¶</a></dt>
<dd><p>Report enumerated device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*ctrl</span></code></dt><dd><p>Controller with which device is enumerated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_eaddr</span> <span class="pre">*e_addr</span></code></dt><dd><p>Enumeration address of the device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*laddr</span></code></dt><dd><p>Return logical address (if valid flag is false)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by controller in response to REPORT_PRESENT. Framework will assign
a logical address to this enumeration address.
Function returns -EXFULL to indicate that all logical addresses are already
taken.</p>
</div>
<dl class="function">
<dt id="c.slim_get_logical_addr">
int <code class="sig-name descname">slim_get_logical_addr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a><em> *sbdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_get_logical_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>get/allocate logical address of a SLIMbus device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*sbdev</span></code></dt><dd><p>client handle requesting the address.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero if a logical address is valid or a new logical address
has been assigned. error code in case of error.</p>
</div>
</section>
<section id="clock-pause">
<h3>Clock-pause:<a class="headerlink" href="#clock-pause" title="Permalink to this headline">¶</a></h3>
<p>SLIMbus mandates that a reconfiguration sequence (known as clock-pause) be
broadcast to all active devices on the bus before the bus can enter low-power
mode. Controller uses this sequence when it decides to enter low-power mode so
that corresponding clocks and/or power-rails can be turned off to save power.
Clock-pause is exited by waking up framer device (if controller driver initiates
exiting low power mode), or by toggling the data line (if a slave device wants
to initiate it).</p>
<section id="clock-pause-apis">
<h4>Clock-pause APIs:<a class="headerlink" href="#clock-pause-apis" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="c.slim_ctrl_clk_pause">
int <code class="sig-name descname">slim_ctrl_clk_pause</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a><em> *ctrl</em>, bool<em> wakeup</em>, u8<em> restart</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_ctrl_clk_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by slimbus controller to enter/exit ‘clock pause’</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*ctrl</span></code></dt><dd><p>controller requesting bus to be paused or woken up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">wakeup</span></code></dt><dd><p>Wakeup this controller from clock pause.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">restart</span></code></dt><dd><p>Restart time value per spec used for clock pause. This value
isn’t used when controller is to be woken up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Slimbus specification needs this sequence to turn-off clocks for the bus.
The sequence involves sending 3 broadcast messages (reconfiguration
sequence) to inform all devices on the bus.
To exit clock-pause, controller typically wakes up active framer device.
This API executes clock pause reconfiguration sequence if wakeup is false.
If wakeup is true, controller’s wakeup is called.
For entering clock-pause, -EBUSY is returned if a message txn in pending.</p>
</div>
</section>
</section>
<section id="messaging">
<h3>Messaging:<a class="headerlink" href="#messaging" title="Permalink to this headline">¶</a></h3>
<p>The framework supports regmap and read/write apis to exchange control-information
with a SLIMbus device. APIs can be synchronous or asynchronous.
The header file &lt;linux/slimbus.h&gt; has more documentation about messaging APIs.</p>
<section id="messaging-apis">
<h4>Messaging APIs:<a class="headerlink" href="#messaging-apis" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="c.slim_msg_response">
void <code class="sig-name descname">slim_msg_response</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a><em> *ctrl</em>, u8<em> *reply</em>, u8<em> tid</em>, u8<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_msg_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Deliver Message response received from a device to the framework.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*ctrl</span></code></dt><dd><p>Controller handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*reply</span></code></dt><dd><p>Reply received from the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">tid</span></code></dt><dd><p>Transaction ID received with which framework can associate reply.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">len</span></code></dt><dd><p>Length of the reply</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by controller to inform framework about the response received.
This helps in making the API asynchronous, and controller-driver doesn’t need
to manage 1 more table other than the one managed by framework mapping TID
with buffers</p>
</div>
<dl class="function">
<dt id="c.slim_alloc_txn_tid">
int <code class="sig-name descname">slim_alloc_txn_tid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a><em> *ctrl</em>, struct <a class="reference internal" href="#c.slim_msg_txn" title="slim_msg_txn">slim_msg_txn</a><em> *txn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_alloc_txn_tid" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a tid to txn</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*ctrl</span></code></dt><dd><p>Controller handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_msg_txn</span> <span class="pre">*txn</span></code></dt><dd><p>transaction to be allocated with tid.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero on success with valid txn-&gt;tid and error code on failures.</p>
</div>
<dl class="function">
<dt id="c.slim_free_txn_tid">
void <code class="sig-name descname">slim_free_txn_tid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a><em> *ctrl</em>, struct <a class="reference internal" href="#c.slim_msg_txn" title="slim_msg_txn">slim_msg_txn</a><em> *txn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_free_txn_tid" title="Permalink to this definition">¶</a></dt>
<dd><p>Free tid of txn</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*ctrl</span></code></dt><dd><p>Controller handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_msg_txn</span> <span class="pre">*txn</span></code></dt><dd><p>transaction whose tid should be freed</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.slim_do_transfer">
int <code class="sig-name descname">slim_do_transfer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a><em> *ctrl</em>, struct <a class="reference internal" href="#c.slim_msg_txn" title="slim_msg_txn">slim_msg_txn</a><em> *txn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_do_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a SLIMbus-messaging transaction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*ctrl</span></code></dt><dd><p>Controller handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_msg_txn</span> <span class="pre">*txn</span></code></dt><dd><p>Transaction to be sent over SLIMbus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by controller to transmit messaging transactions not dealing with
Interface/Value elements. (e.g. transmitting a message to assign logical
address to a slave device</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>-ETIMEDOUT: If transmission of this message timed out</dt><dd><p>(e.g. due to bus lines not being clocked or driven by controller)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.slim_xfer_msg">
int <code class="sig-name descname">slim_xfer_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a><em> *sbdev</em>, struct <a class="reference internal" href="#c.slim_val_inf" title="slim_val_inf">slim_val_inf</a><em> *msg</em>, u8<em> mc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_xfer_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer a value info message on slim device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*sbdev</span></code></dt><dd><p>slim device to which this msg has to be transfered</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_val_inf</span> <span class="pre">*msg</span></code></dt><dd><p>value info message pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">mc</span></code></dt><dd><p>message code of the message</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by drivers which want to transfer a vlaue or info elements.</p>
<p><strong>Return</strong></p>
<p>-ETIMEDOUT: If transmission of this message timed out</p>
</div>
<dl class="function">
<dt id="c.slim_read">
int <code class="sig-name descname">slim_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a><em> *sdev</em>, u32<em> addr</em>, size_t<em> count</em>, u8<em> *val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read SLIMbus value element</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*sdev</span></code></dt><dd><p>client handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">addr</span></code></dt><dd><p>address of value element to read.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to read. Maximum bytes allowed are 16.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*val</span></code></dt><dd><p>will return what the value element value was</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>-EINVAL for Invalid parameters, -ETIMEDOUT If transmission of
this message timed out (e.g. due to bus lines not being clocked
or driven by controller)</p>
</div>
<dl class="function">
<dt id="c.slim_readb">
int <code class="sig-name descname">slim_readb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a><em> *sdev</em>, u32<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_readb" title="Permalink to this definition">¶</a></dt>
<dd><p>Read byte from SLIMbus value element</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*sdev</span></code></dt><dd><p>client handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">addr</span></code></dt><dd><p>address in the value element to read.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>byte value of value element.</p>
</div>
<dl class="function">
<dt id="c.slim_write">
int <code class="sig-name descname">slim_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a><em> *sdev</em>, u32<em> addr</em>, size_t<em> count</em>, u8<em> *val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write SLIMbus value element</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*sdev</span></code></dt><dd><p>client handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">addr</span></code></dt><dd><p>address in the value element to write.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>number of bytes to write. Maximum bytes allowed are 16.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*val</span></code></dt><dd><p>value to write to value element</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>-EINVAL for Invalid parameters, -ETIMEDOUT If transmission of
this message timed out (e.g. due to bus lines not being clocked
or driven by controller)</p>
</div>
<dl class="function">
<dt id="c.slim_writeb">
int <code class="sig-name descname">slim_writeb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a><em> *sdev</em>, u32<em> addr</em>, u8<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_writeb" title="Permalink to this definition">¶</a></dt>
<dd><p>Write byte to SLIMbus value element</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*sdev</span></code></dt><dd><p>client handle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">addr</span></code></dt><dd><p>address of value element to write.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">value</span></code></dt><dd><p>value to write to value element</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>-EINVAL for Invalid parameters, -ETIMEDOUT If transmission of
this message timed out (e.g. due to bus lines not being clocked
or driven by controller)</p>
</div>
</section>
<section id="streaming-apis">
<h4>Streaming APIs:<a class="headerlink" href="#streaming-apis" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="c.slim_stream_allocate">
struct <a class="reference internal" href="#c.slim_stream_runtime" title="slim_stream_runtime">slim_stream_runtime</a> * <code class="sig-name descname">slim_stream_allocate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a><em> *dev</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_stream_allocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a new SLIMbus Stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*dev</span></code></dt><dd><p>Slim device to be associated with</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of the stream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is very first call for SLIMbus streaming, this API will allocate
a new SLIMbus stream and return a valid stream runtime pointer for client
to use it in subsequent stream apis. state of stream is set to ALLOCATED</p>
<p><strong>Return</strong></p>
<p>valid pointer on success and error code on failure.
From ASoC DPCM framework, this state is linked to startup() operation.</p>
</div>
<dl class="function">
<dt id="c.slim_stream_prepare">
int <code class="sig-name descname">slim_stream_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_stream_runtime" title="slim_stream_runtime">slim_stream_runtime</a><em> *rt</em>, struct <a class="reference internal" href="#c.slim_stream_config" title="slim_stream_config">slim_stream_config</a><em> *cfg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_stream_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a SLIMbus Stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_stream_runtime</span> <span class="pre">*rt</span></code></dt><dd><p>instance of slim stream runtime to configure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_stream_config</span> <span class="pre">*cfg</span></code></dt><dd><p>new configuration for the stream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This API will configure SLIMbus stream with config parameters from cfg.
return zero on success and error code on failure. From ASoC DPCM framework,
this state is linked to hw_params() operation.</p>
</div>
<dl class="function">
<dt id="c.slim_stream_enable">
int <code class="sig-name descname">slim_stream_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_stream_runtime" title="slim_stream_runtime">slim_stream_runtime</a><em> *stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_stream_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable a prepared SLIMbus Stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_stream_runtime</span> <span class="pre">*stream</span></code></dt><dd><p>instance of slim stream runtime to enable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This API will enable all the ports and channels associated with
SLIMbus stream</p>
<p><strong>Return</strong></p>
<p>zero on success and error code on failure. From ASoC DPCM framework,
this state is linked to trigger() start operation.</p>
</div>
<dl class="function">
<dt id="c.slim_stream_disable">
int <code class="sig-name descname">slim_stream_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_stream_runtime" title="slim_stream_runtime">slim_stream_runtime</a><em> *stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_stream_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable a SLIMbus Stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_stream_runtime</span> <span class="pre">*stream</span></code></dt><dd><p>instance of slim stream runtime to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This API will disable all the ports and channels associated with
SLIMbus stream</p>
<p><strong>Return</strong></p>
<p>zero on success and error code on failure. From ASoC DPCM framework,
this state is linked to trigger() pause operation.</p>
</div>
<dl class="function">
<dt id="c.slim_stream_unprepare">
int <code class="sig-name descname">slim_stream_unprepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_stream_runtime" title="slim_stream_runtime">slim_stream_runtime</a><em> *stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_stream_unprepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-prepare a SLIMbus Stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_stream_runtime</span> <span class="pre">*stream</span></code></dt><dd><p>instance of slim stream runtime to unprepare</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This API will un allocate all the ports and channels associated with
SLIMbus stream</p>
<p><strong>Return</strong></p>
<p>zero on success and error code on failure. From ASoC DPCM framework,
this state is linked to trigger() stop operation.</p>
</div>
<dl class="function">
<dt id="c.slim_stream_free">
int <code class="sig-name descname">slim_stream_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_stream_runtime" title="slim_stream_runtime">slim_stream_runtime</a><em> *stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_stream_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a SLIMbus Stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">slim_stream_runtime</span> <span class="pre">*stream</span></code></dt><dd><p>instance of slim stream runtime to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This API will un allocate all the memory associated with
slim stream runtime, user is not allowed to make an dereference
to stream after this call.</p>
<p><strong>Return</strong></p>
<p>zero on success and error code on failure. From ASoC DPCM framework,
this state is linked to shutdown() operation.</p>
</div>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Linux kernel SLIMbus support</a><ul>
<li><a class="reference internal" href="#overview">Overview</a><ul>
<li><a class="reference internal" href="#what-is-slimbus">What is SLIMbus?</a></li>
<li><a class="reference internal" href="#hardware-description">Hardware description:</a></li>
<li><a class="reference internal" href="#software-description">Software description:</a></li>
<li><a class="reference internal" href="#device-notifications-to-the-driver">Device notifications to the driver:</a></li>
<li><a class="reference internal" href="#driver-and-controller-apis">Driver and Controller APIs:</a></li>
<li><a class="reference internal" href="#clock-pause">Clock-pause:</a><ul>
<li><a class="reference internal" href="#clock-pause-apis">Clock-pause APIs:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#messaging">Messaging:</a><ul>
<li><a class="reference internal" href="#messaging-apis">Messaging APIs:</a></li>
<li><a class="reference internal" href="#streaming-apis">Streaming APIs:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/slimbus.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/slimbus.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>