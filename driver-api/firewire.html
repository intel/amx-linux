
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Firewire (IEEE 1394) driver Interface Guide &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Linux PCI driver implementer’s API guide" href="pci/index.html" />
    <link rel="prev" title="USB3 debug port" href="usb/usb3-debug-port.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="firewire-ieee-1394-driver-interface-guide">
<h1>Firewire (IEEE 1394) driver Interface Guide<a class="headerlink" href="#firewire-ieee-1394-driver-interface-guide" title="Permalink to this headline">¶</a></h1>
<section id="introduction-and-overview">
<h2>Introduction and Overview<a class="headerlink" href="#introduction-and-overview" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>The Linux FireWire subsystem adds some interfaces into the Linux system to</dt><dd><p>use/maintain+any resource on IEEE 1394 bus.</p>
</dd>
</dl>
<p>The main purpose of these interfaces is to access address space on each node
on IEEE 1394 bus by ISO/IEC 13213 (IEEE 1212) procedure, and to control
isochronous resources on the bus by IEEE 1394 procedure.</p>
<p>Two types of interfaces are added, according to consumers of the interface. A
set of userspace interfaces is available via <cite>firewire character devices</cite>. A set
of kernel interfaces is available via exported symbols in <cite>firewire-core</cite> module.</p>
</section>
<section id="firewire-char-device-data-structures">
<h2>Firewire char device data structures<a class="headerlink" href="#firewire-char-device-data-structures" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">What:           /dev/fw[0-9]+
Date:           May 2007
KernelVersion:  2.6.22
Contact:        linux1394-devel&#64;lists.sourceforge.net
Description:
                The character device files /dev/fw* are the interface between
                firewire-core and IEEE 1394 device drivers implemented in
                userspace.  The ioctl(2)- and read(2)-based ABI is defined and
                documented in &lt;linux/firewire-cdev.h&gt;.

                This ABI offers most of the features which firewire-core also
                exposes to kernelspace IEEE 1394 drivers.

                Each /dev/fw* is associated with one IEEE 1394 node, which can
                be remote or local nodes.  Operations on a /dev/fw* file have
                different scope:

                  - The 1394 node which is associated with the file:

                          - Asynchronous request transmission
                          - Get the Configuration ROM
                          - Query node ID
                          - Query maximum speed of the path between this node
                            and local node

                  - The 1394 bus (i.e. &quot;card&quot;) to which the node is attached to:

                          - Isochronous stream transmission and reception
                          - Asynchronous stream transmission and reception
                          - Asynchronous broadcast request transmission
                          - PHY packet transmission and reception
                          - Allocate, reallocate, deallocate isochronous
                            resources (channels, bandwidth) at the bus's IRM
                          - Query node IDs of local node, root node, IRM, bus
                            manager
                          - Query cycle time
                          - Bus reset initiation, bus reset event reception

                  - All 1394 buses:

                          - Allocation of IEEE 1212 address ranges on the local
                            link layers, reception of inbound requests to such
                            an address range, asynchronous response transmission
                            to inbound requests
                          - Addition of descriptors or directories to the local
                            nodes' Configuration ROM

                Due to the different scope of operations and in order to let
                userland implement different access permission models, some
                operations are restricted to /dev/fw* files that are associated
                with a local node:

                          - Addition of descriptors or directories to the local
                            nodes' Configuration ROM
                          - PHY packet transmission and reception

                A /dev/fw* file remains associated with one particular node
                during its entire life time.  Bus topology changes, and hence
                node ID changes, are tracked by firewire-core.  ABI users do not
                need to be aware of topology.

                The following file operations are supported:

                open(2)
                    Currently the only useful flags are O_RDWR.

                ioctl(2)
                    Initiate various actions.  Some take immediate effect, others
                    are performed asynchronously while or after the ioctl returns.
                    See the inline documentation in &lt;linux/firewire-cdev.h&gt; for
                    descriptions of all ioctls.

                poll(2), select(2), epoll_wait(2) etc.
                    Watch for events to become available to be read.

                read(2)
                    Receive various events.  There are solicited events like
                    outbound asynchronous transaction completion or isochronous
                    buffer completion, and unsolicited events such as bus resets,
                    request reception, or PHY packet reception.  Always use a read
                    buffer which is large enough to receive the largest event that
                    could ever arrive.  See &lt;linux/firewire-cdev.h&gt; for descriptions
                    of all event types and for which ioctls affect reception of
                    events.

                mmap(2)
                    Allocate a DMA buffer for isochronous reception or transmission
                    and map it into the process address space.  The arguments should
                    be used as follows:  addr = NULL, length = the desired buffer
                    size, i.e. number of packets times size of largest packet,
                    prot = at least PROT_READ for reception and at least PROT_WRITE
                    for transmission, flags = MAP_SHARED, fd = the handle to the
                    /dev/fw*, offset = 0.

                Isochronous reception works in packet-per-buffer fashion except
                for multichannel reception which works in buffer-fill mode.

                munmap(2)
                    Unmap the isochronous I/O buffer from the process address space.

                close(2)
                    Besides stopping and freeing I/O contexts that were associated
                    with the file descriptor, back out any changes to the local
                    nodes' Configuration ROM.  Deallocate isochronous channels and
                    bandwidth at the IRM that were marked for kernel-assisted
                    re- and deallocation.

Users:          libraw1394;
                libdc1394;
                libhinawa;
                tools like linux-firewire-utils, fwhack, ...
</pre>
<dl class="type">
<dt id="c.fw_cdev_event_common">
struct <code class="sig-name descname">fw_cdev_event_common</code><a class="headerlink" href="#c.fw_cdev_event_common" title="Permalink to this definition">¶</a></dt>
<dd><p>Common part of all fw_cdev_event_* types</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_event_common {
    __u64 closure;
    __u32 type;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>For arbitrary use by userspace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Discriminates the fw_cdev_event_* types</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct may be used to access generic members of all fw_cdev_event_*
types regardless of the specific type.</p>
<p>Data passed in the <strong>closure</strong> field for a request will be returned in the
corresponding event.  It is big enough to hold a pointer on all platforms.
The ioctl used to set <strong>closure</strong> depends on the <strong>type</strong> of event.</p>
<dl class="type">
<dt id="c.fw_cdev_event_bus_reset">
struct <code class="sig-name descname">fw_cdev_event_bus_reset</code><a class="headerlink" href="#c.fw_cdev_event_bus_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Sent when a bus reset occurred</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_event_bus_reset {
    __u64 closure;
    __u32 type;
    __u32 node_id;
    __u32 local_node_id;
    __u32 bm_node_id;
    __u32 irm_node_id;
    __u32 root_node_id;
    __u32 generation;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>; set by <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_GET_INFO</span></code> ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>; always <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_BUS_RESET</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">node_id</span></code></dt><dd><p>New node ID of this node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">local_node_id</span></code></dt><dd><p>Node ID of the local node, i.e. of the controller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bm_node_id</span></code></dt><dd><p>Node ID of the bus manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irm_node_id</span></code></dt><dd><p>Node ID of the iso resource manager</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">root_node_id</span></code></dt><dd><p>Node ID of the root node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">generation</span></code></dt><dd><p>New bus generation</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This event is sent when the bus the device belongs to goes through a bus
reset.  It provides information about the new bus configuration, such as
new node ID for this device, new root ID, and others.</p>
<p>If <strong>bm_node_id</strong> is 0xffff right after bus reset it can be reread by an
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_GET_INFO</span></code> ioctl after bus manager selection was finished.
Kernels with ABI version &lt; 4 do not set <strong>bm_node_id</strong>.</p>
<dl class="type">
<dt id="c.fw_cdev_event_response">
struct <code class="sig-name descname">fw_cdev_event_response</code><a class="headerlink" href="#c.fw_cdev_event_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Sent when a response packet was received</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_event_response {
    __u64 closure;
    __u32 type;
    __u32 rcode;
    __u32 length;
    __u32 data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>; set by <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_SEND_REQUEST</span></code>
or <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_SEND_BROADCAST_REQUEST</span></code>
or <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_SEND_STREAM_PACKET</span></code> ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>; always <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_RESPONSE</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcode</span></code></dt><dd><p>Response code returned by the remote node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Data length, i.e. the response’s payload size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Payload data, if any</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This event is sent when the stack receives a response to an outgoing request
sent by <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_SEND_REQUEST</span></code> ioctl.  The payload data for responses
carrying data (read and lock responses) follows immediately and can be
accessed through the <strong>data</strong> field.</p>
<p>The event is also generated after conclusions of transactions that do not
involve response packets.  This includes unified write transactions,
broadcast write transactions, and transmission of asynchronous stream
packets.  <strong>rcode</strong> indicates success or failure of such transmissions.</p>
<dl class="type">
<dt id="c.fw_cdev_event_request">
struct <code class="sig-name descname">fw_cdev_event_request</code><a class="headerlink" href="#c.fw_cdev_event_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Old version of <a class="reference internal" href="#c.fw_cdev_event_request2" title="fw_cdev_event_request2"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_request2</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_event_request {
    __u64 closure;
    __u32 type;
    __u32 tcode;
    __u64 offset;
    __u32 handle;
    __u32 length;
    __u32 data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>; set by <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_ALLOCATE</span></code> ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>; always <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_REQUEST</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tcode</span></code></dt><dd><p>Transaction code of the incoming request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>The offset into the 48-bit per-node address space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Reference to the kernel-side pending request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Data length, i.e. the request’s payload size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Incoming data, if any</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This event is sent instead of <a class="reference internal" href="#c.fw_cdev_event_request2" title="fw_cdev_event_request2"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_request2</span></code></a> if the kernel or
the client implements ABI version &lt;= 3.  <a class="reference internal" href="#c.fw_cdev_event_request" title="fw_cdev_event_request"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_request</span></code></a> lacks
essential information; use <a class="reference internal" href="#c.fw_cdev_event_request2" title="fw_cdev_event_request2"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_request2</span></code></a> instead.</p>
<dl class="type">
<dt id="c.fw_cdev_event_request2">
struct <code class="sig-name descname">fw_cdev_event_request2</code><a class="headerlink" href="#c.fw_cdev_event_request2" title="Permalink to this definition">¶</a></dt>
<dd><p>Sent on incoming request to an address region</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_event_request2 {
    __u64 closure;
    __u32 type;
    __u32 tcode;
    __u64 offset;
    __u32 source_node_id;
    __u32 destination_node_id;
    __u32 card;
    __u32 generation;
    __u32 handle;
    __u32 length;
    __u32 data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>; set by <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_ALLOCATE</span></code> ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>; always <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_REQUEST2</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tcode</span></code></dt><dd><p>Transaction code of the incoming request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>The offset into the 48-bit per-node address space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">source_node_id</span></code></dt><dd><p>Sender node ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destination_node_id</span></code></dt><dd><p>Destination node ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">card</span></code></dt><dd><p>The index of the card from which the request came</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">generation</span></code></dt><dd><p>Bus generation in which the request is valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Reference to the kernel-side pending request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Data length, i.e. the request’s payload size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Incoming data, if any</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This event is sent when the stack receives an incoming request to an address
region registered using the <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_ALLOCATE</span></code> ioctl.  The request is
guaranteed to be completely contained in the specified region.  Userspace is
responsible for sending the response by <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_SEND_RESPONSE</span></code> ioctl,
using the same <strong>handle</strong>.</p>
<p>The payload data for requests carrying data (write and lock requests)
follows immediately and can be accessed through the <strong>data</strong> field.</p>
<p>Unlike <a class="reference internal" href="#c.fw_cdev_event_request" title="fw_cdev_event_request"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_request</span></code></a>, <strong>tcode</strong> of lock requests is one of the
firewire-core specific <code class="docutils literal notranslate"><span class="pre">TCODE_LOCK_MASK_SWAP</span></code>…``TCODE_LOCK_VENDOR_DEPENDENT``,
i.e. encodes the extended transaction code.</p>
<p><strong>card</strong> may differ from <a class="reference internal" href="#c.fw_cdev_get_info" title="fw_cdev_get_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_get_info.card</span></code></a> because requests are received
from all cards of the Linux host.  <strong>source_node_id</strong>, <strong>destination_node_id</strong>, and
<strong>generation</strong> pertain to that card.  Destination node ID and bus generation may
therefore differ from the corresponding fields of the last
<a class="reference internal" href="#c.fw_cdev_event_bus_reset" title="fw_cdev_event_bus_reset"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_bus_reset</span></code></a>.</p>
<p><strong>destination_node_id</strong> may also differ from the current node ID because of a
non-local bus ID part or in case of a broadcast write request.  Note, a
client must call an <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_SEND_RESPONSE</span></code> ioctl even in case of a
broadcast write request; the kernel will then release the kernel-side pending
request but will not actually send a response packet.</p>
<p>In case of a write request to FCP_REQUEST or FCP_RESPONSE, the kernel already
sent a write response immediately after the request was received; in this
case the client must still call an <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_SEND_RESPONSE</span></code> ioctl to
release the kernel-side pending request, though another response won’t be
sent.</p>
<p>If the client subsequently needs to initiate requests to the sender node of
an <a class="reference internal" href="#c.fw_cdev_event_request2" title="fw_cdev_event_request2"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_request2</span></code></a>, it needs to use a device file with matching
card index, node ID, and generation for outbound requests.</p>
<dl class="type">
<dt id="c.fw_cdev_event_iso_interrupt">
struct <code class="sig-name descname">fw_cdev_event_iso_interrupt</code><a class="headerlink" href="#c.fw_cdev_event_iso_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Sent when an iso packet was completed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_event_iso_interrupt {
    __u64 closure;
    __u32 type;
    __u32 cycle;
    __u32 header_length;
    __u32 header[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>;
set by <code class="docutils literal notranslate"><span class="pre">FW_CDEV_CREATE_ISO_CONTEXT</span></code> ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>; always <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_INTERRUPT</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cycle</span></code></dt><dd><p>Cycle counter of the last completed packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header_length</span></code></dt><dd><p>Total length of following headers, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header</span></code></dt><dd><p>Stripped headers, if any</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This event is sent when the controller has completed an <a class="reference internal" href="#c.fw_cdev_iso_packet" title="fw_cdev_iso_packet"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_iso_packet</span></code></a>
with the <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_INTERRUPT</span></code> bit set, when explicitly requested with
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_FLUSH_ISO</span></code>, or when there have been so many completed packets
without the interrupt bit set that the kernel’s internal buffer for <strong>header</strong>
is about to overflow.  (In the last case, ABI versions &lt; 5 drop header data
up to the next interrupt packet.)</p>
<p>Isochronous transmit events (context type <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_TRANSMIT</span></code>):</p>
<p>In version 3 and some implementations of version 2 of the ABI, <code class="xref c c-type docutils literal notranslate"><span class="pre">header_length</span></code>
is a multiple of 4 and <code class="xref c c-type docutils literal notranslate"><span class="pre">header</span></code> contains timestamps of all packets up until
the interrupt packet.  The format of the timestamps is as described below for
isochronous reception.  In version 1 of the ABI, <code class="xref c c-type docutils literal notranslate"><span class="pre">header_length</span></code> was 0.</p>
<p>Isochronous receive events (context type <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_RECEIVE</span></code>):</p>
<p>The headers stripped of all packets up until and including the interrupt
packet are returned in the <strong>header</strong> field.  The amount of header data per
packet is as specified at iso context creation by
<a class="reference internal" href="#c.fw_cdev_create_iso_context" title="fw_cdev_create_iso_context"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_create_iso_context.header_size</span></code></a>.</p>
<p>Hence, _interrupt.header_length / _context.header_size is the number of
packets received in this interrupt event.  The client can now iterate
through the mmap()’ed DMA buffer according to this number of packets and
to the buffer sizes as the client specified in <a class="reference internal" href="#c.fw_cdev_queue_iso" title="fw_cdev_queue_iso"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_queue_iso</span></code></a>.</p>
<p>Since version 2 of this ABI, the portion for each packet in _interrupt.header
consists of the 1394 isochronous packet header, followed by a timestamp
quadlet if <a class="reference internal" href="#c.fw_cdev_create_iso_context" title="fw_cdev_create_iso_context"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_create_iso_context.header_size</span></code></a> &gt; 4, followed by quadlets
from the packet payload if <a class="reference internal" href="#c.fw_cdev_create_iso_context" title="fw_cdev_create_iso_context"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_create_iso_context.header_size</span></code></a> &gt; 8.</p>
<p>Format of 1394 iso packet header:  16 bits data_length, 2 bits tag, 6 bits
channel, 4 bits tcode, 4 bits sy, in big endian byte order.
data_length is the actual received size of the packet without the four
1394 iso packet header bytes.</p>
<p>Format of timestamp:  16 bits invalid, 3 bits cycleSeconds, 13 bits
cycleCount, in big endian byte order.</p>
<p>In version 1 of the ABI, no timestamp quadlet was inserted; instead, payload
data followed directly after the 1394 is header if header_size &gt; 4.
Behaviour of ver. 1 of this ABI is no longer available since ABI ver. 2.</p>
<dl class="type">
<dt id="c.fw_cdev_event_iso_interrupt_mc">
struct <code class="sig-name descname">fw_cdev_event_iso_interrupt_mc</code><a class="headerlink" href="#c.fw_cdev_event_iso_interrupt_mc" title="Permalink to this definition">¶</a></dt>
<dd><p>An iso buffer chunk was completed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_event_iso_interrupt_mc {
    __u64 closure;
    __u32 type;
    __u32 completed;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>;
set by <code class="docutils literal notranslate"><span class="pre">FW_CDEV_CREATE_ISO_CONTEXT</span></code> ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">completed</span></code></dt><dd><p>Offset into the receive buffer; data before this offset is valid</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This event is sent in multichannel contexts (context type
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span></code>) for <a class="reference internal" href="#c.fw_cdev_iso_packet" title="fw_cdev_iso_packet"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_iso_packet</span></code></a> buffer
chunks that have been completely filled and that have the
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_INTERRUPT</span></code> bit set, or when explicitly requested with
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_FLUSH_ISO</span></code>.</p>
<dl class="simple">
<dt>The buffer is continuously filled with the following data, per packet:</dt><dd><ul class="simple">
<li><p>the 1394 iso packet header as described at <a class="reference internal" href="#c.fw_cdev_event_iso_interrupt" title="fw_cdev_event_iso_interrupt"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_iso_interrupt</span></code></a>,
but in little endian byte order,</p></li>
<li><p>packet payload (as many bytes as specified in the data_length field of
the 1394 iso packet header) in big endian byte order,</p></li>
<li><p>0…3 padding bytes as needed to align the following trailer quadlet,</p></li>
<li><p>trailer quadlet, containing the reception timestamp as described at
<a class="reference internal" href="#c.fw_cdev_event_iso_interrupt" title="fw_cdev_event_iso_interrupt"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_iso_interrupt</span></code></a>, but in little endian byte order.</p></li>
</ul>
</dd>
</dl>
<p>Hence the per-packet size is data_length (rounded up to a multiple of 4) + 8.
When processing the data, stop before a packet that would cross the
<strong>completed</strong> offset.</p>
<p>A packet near the end of a buffer chunk will typically spill over into the
next queued buffer chunk.  It is the responsibility of the client to check
for this condition, assemble a broken-up packet from its parts, and not to
re-queue any buffer chunks in which as yet unread packet parts reside.</p>
<dl class="type">
<dt id="c.fw_cdev_event_iso_resource">
struct <code class="sig-name descname">fw_cdev_event_iso_resource</code><a class="headerlink" href="#c.fw_cdev_event_iso_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Iso resources were allocated or freed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_event_iso_resource {
    __u64 closure;
    __u32 type;
    __u32 handle;
    __s32 channel;
    __s32 bandwidth;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>;
set by``FW_CDEV_IOC_(DE)ALLOCATE_ISO_RESOURCE(_ONCE)`` ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED</span></code> or
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Reference by which an allocated resource can be deallocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>Isochronous channel which was (de)allocated, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bandwidth</span></code></dt><dd><p>Bandwidth allocation units which were (de)allocated, if any</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>An <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED</span></code> event is sent after an isochronous
resource was allocated at the IRM.  The client has to check <strong>channel</strong> and
<strong>bandwidth</strong> for whether the allocation actually succeeded.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED</span></code> event is sent after an isochronous
resource was deallocated at the IRM.  It is also sent when automatic
reallocation after a bus reset failed.</p>
<p><strong>channel</strong> is &lt;0 if no channel was (de)allocated or if reallocation failed.
<strong>bandwidth</strong> is 0 if no bandwidth was (de)allocated or if reallocation failed.</p>
<dl class="type">
<dt id="c.fw_cdev_event_phy_packet">
struct <code class="sig-name descname">fw_cdev_event_phy_packet</code><a class="headerlink" href="#c.fw_cdev_event_phy_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>A PHY packet was transmitted or received</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_event_phy_packet {
    __u64 closure;
    __u32 type;
    __u32 rcode;
    __u32 length;
    __u32 data[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>See <a class="reference internal" href="#c.fw_cdev_event_common" title="fw_cdev_event_common"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_common</span></code></a>; set by <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_SEND_PHY_PACKET</span></code>
or <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_RECEIVE_PHY_PACKETS</span></code> ioctl</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_PHY_PACKET_SENT</span></code> or %…_RECEIVED</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcode</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">RCODE_</span></code>…, indicates success or failure of transmission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Data length in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Incoming data</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If <strong>type</strong> is <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_PHY_PACKET_SENT</span></code>, <strong>length</strong> is 0 and <strong>data</strong> empty,
except in case of a ping packet:  Then, <strong>length</strong> is 4, and <strong>data**[0] is the
ping time in 49.152MHz clocks if **rcode</strong> is <code class="docutils literal notranslate"><span class="pre">RCODE_COMPLETE</span></code>.</p>
<p>If <strong>type</strong> is <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_PHY_PACKET_RECEIVED</span></code>, <strong>length</strong> is 8 and <strong>data</strong>
consists of the two PHY packet quadlets, in host byte order.</p>
<dl class="type">
<dt id="c.fw_cdev_event">
union <code class="sig-name descname">fw_cdev_event</code><a class="headerlink" href="#c.fw_cdev_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience union of fw_cdev_event_* types</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>union fw_cdev_event {
    struct fw_cdev_event_common             common;
    struct fw_cdev_event_bus_reset          bus_reset;
    struct fw_cdev_event_response           response;
    struct fw_cdev_event_request            request;
    struct fw_cdev_event_request2           request2;
    struct fw_cdev_event_iso_interrupt      iso_interrupt;
    struct fw_cdev_event_iso_interrupt_mc   iso_interrupt_mc;
    struct fw_cdev_event_iso_resource       iso_resource;
    struct fw_cdev_event_phy_packet         phy_packet;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">common</span></code></dt><dd><p>Valid for all types</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_reset</span></code></dt><dd><p>Valid if <strong>common.type</strong> == <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_BUS_RESET</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">response</span></code></dt><dd><p>Valid if <strong>common.type</strong> == <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_RESPONSE</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request</span></code></dt><dd><p>Valid if <strong>common.type</strong> == <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_REQUEST</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request2</span></code></dt><dd><p>Valid if <strong>common.type</strong> == <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_REQUEST2</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iso_interrupt</span></code></dt><dd><p>Valid if <strong>common.type</strong> == <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_INTERRUPT</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iso_interrupt_mc</span></code></dt><dd><p>Valid if <strong>common.type</strong> ==
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iso_resource</span></code></dt><dd><p>Valid if <strong>common.type</strong> ==
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED</span></code> or
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_packet</span></code></dt><dd><p>Valid if <strong>common.type</strong> ==
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_PHY_PACKET_SENT</span></code> or
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_PHY_PACKET_RECEIVED</span></code></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Convenience union for userspace use.  Events could be read(2) into an
appropriately aligned char buffer and then cast to this union for further
processing.  Note that for a request, response or iso_interrupt event,
the data[] or header[] may make the size of the full event larger than
sizeof(<a class="reference internal" href="#c.fw_cdev_event" title="fw_cdev_event"><code class="xref c c-type docutils literal notranslate"><span class="pre">union</span> <span class="pre">fw_cdev_event</span></code></a>).  Also note that if you attempt to read(2)
an event into a buffer that is not large enough for it, the data that does
not fit will be discarded so that the next read(2) will return a new event.</p>
<dl class="type">
<dt id="c.fw_cdev_get_info">
struct <code class="sig-name descname">fw_cdev_get_info</code><a class="headerlink" href="#c.fw_cdev_get_info" title="Permalink to this definition">¶</a></dt>
<dd><p>General purpose information ioctl</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_get_info {
    __u32 version;
    __u32 rom_length;
    __u64 rom;
    __u64 bus_reset;
    __u64 bus_reset_closure;
    __u32 card;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">version</span></code></dt><dd><p>The version field is just a running serial number.  Both an
input parameter (ABI version implemented by the client) and
output parameter (ABI version implemented by the kernel).
A client shall fill in the ABI <strong>version</strong> for which the client
was implemented.  This is necessary for forward compatibility.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rom_length</span></code></dt><dd><p>If <strong>rom</strong> is non-zero, up to <strong>rom_length</strong> bytes of Configuration
ROM will be copied into that user space address.  In either
case, <strong>rom_length</strong> is updated with the actual length of the
Configuration ROM.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rom</span></code></dt><dd><p>If non-zero, address of a buffer to be filled by a copy of the
device’s Configuration ROM</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_reset</span></code></dt><dd><p>If non-zero, address of a buffer to be filled by a
<a class="reference internal" href="#c.fw_cdev_event_bus_reset" title="fw_cdev_event_bus_reset"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fw_cdev_event_bus_reset</span></code></a> with the current state
of the bus.  This does not cause a bus reset to happen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_reset_closure</span></code></dt><dd><p>Value of <code class="xref c c-type docutils literal notranslate"><span class="pre">closure</span></code> in this and subsequent bus reset events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">card</span></code></dt><dd><p>The index of the card this device belongs to</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_GET_INFO</span></code> ioctl is usually the very first one which a client
performs right after it opened a /dev/fw* file.</p>
<p>As a side effect, reception of <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_BUS_RESET</span></code> events to be read(2)
is started by this ioctl.</p>
<dl class="type">
<dt id="c.fw_cdev_send_request">
struct <code class="sig-name descname">fw_cdev_send_request</code><a class="headerlink" href="#c.fw_cdev_send_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Send an asynchronous request packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_send_request {
    __u32 tcode;
    __u32 length;
    __u64 offset;
    __u64 closure;
    __u64 data;
    __u32 generation;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tcode</span></code></dt><dd><p>Transaction code of the request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Length of outgoing payload, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>48-bit offset at destination node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>Passed back to userspace in the response event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Userspace pointer to payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">generation</span></code></dt><dd><p>The bus generation where packet is valid</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Send a request to the device.  This ioctl implements all outgoing requests.
Both quadlet and block request specify the payload as a pointer to the data
in the <strong>data</strong> field.  Once the transaction completes, the kernel writes an
<a class="reference internal" href="#c.fw_cdev_event_response" title="fw_cdev_event_response"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_response</span></code></a> event back.  The <strong>closure</strong> field is passed back to
user space in the response event.</p>
<dl class="type">
<dt id="c.fw_cdev_send_response">
struct <code class="sig-name descname">fw_cdev_send_response</code><a class="headerlink" href="#c.fw_cdev_send_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Send an asynchronous response packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_send_response {
    __u32 rcode;
    __u32 length;
    __u64 data;
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcode</span></code></dt><dd><p>Response code as determined by the userspace handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Length of outgoing payload, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Userspace pointer to payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>The handle from the <a class="reference internal" href="#c.fw_cdev_event_request" title="fw_cdev_event_request"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_request</span></code></a></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Send a response to an incoming request.  By setting up an address range using
the <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_ALLOCATE</span></code> ioctl, userspace can listen for incoming requests.  An
incoming request will generate an <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_REQUEST</span></code>, and userspace must
send a reply using this ioctl.  The event has a handle to the kernel-side
pending transaction, which should be used with this ioctl.</p>
<dl class="type">
<dt id="c.fw_cdev_allocate">
struct <code class="sig-name descname">fw_cdev_allocate</code><a class="headerlink" href="#c.fw_cdev_allocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a CSR in an address range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_allocate {
    __u64 offset;
    __u64 closure;
    __u32 length;
    __u32 handle;
    __u64 region_end;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>Start offset of the address range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>To be passed back to userspace in request events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Length of the CSR, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle to the allocation, written by the kernel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">region_end</span></code></dt><dd><p>First address above the address range (added in ABI v4, 2.6.36)</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Allocate an address range in the 48-bit address space on the local node
(the controller).  This allows userspace to listen for requests with an
offset within that address range.  Every time when the kernel receives a
request within the range, an <a class="reference internal" href="#c.fw_cdev_event_request2" title="fw_cdev_event_request2"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_request2</span></code></a> event will be emitted.
(If the kernel or the client implements ABI version &lt;= 3, an
<a class="reference internal" href="#c.fw_cdev_event_request" title="fw_cdev_event_request"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_request</span></code></a> will be generated instead.)</p>
<p>The <strong>closure</strong> field is passed back to userspace in these request events.
The <strong>handle</strong> field is an out parameter, returning a handle to the allocated
range to be used for later deallocation of the range.</p>
<p>The address range is allocated on all local nodes.  The address allocation
is exclusive except for the FCP command and response registers.  If an
exclusive address region is already in use, the ioctl fails with errno set
to <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code>.</p>
<p>If kernel and client implement ABI version &gt;= 4, the kernel looks up a free
spot of size <strong>length</strong> inside [<strong>offset</strong>..**region_end**) and, if found, writes
the start address of the new CSR back in <strong>offset</strong>.  I.e. <strong>offset</strong> is an
in and out parameter.  If this automatic placement of a CSR in a bigger
address range is not desired, the client simply needs to set <strong>region_end</strong>
= <strong>offset</strong> + <strong>length</strong>.</p>
<p>If the kernel or the client implements ABI version &lt;= 3, <strong>region_end</strong> is
ignored and effectively assumed to be <strong>offset</strong> + <strong>length</strong>.</p>
<p><strong>region_end</strong> is only present in a kernel header &gt;= 2.6.36.  If necessary,
this can for example be tested by #ifdef FW_CDEV_EVENT_REQUEST2.</p>
<dl class="type">
<dt id="c.fw_cdev_deallocate">
struct <code class="sig-name descname">fw_cdev_deallocate</code><a class="headerlink" href="#c.fw_cdev_deallocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a CSR address range or isochronous resource</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_deallocate {
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle to the address range or iso resource, as returned by the
kernel when the range or resource was allocated</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.fw_cdev_initiate_bus_reset">
struct <code class="sig-name descname">fw_cdev_initiate_bus_reset</code><a class="headerlink" href="#c.fw_cdev_initiate_bus_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiate a bus reset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_initiate_bus_reset {
    __u32 type;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">FW_CDEV_SHORT_RESET</span></code> or <code class="docutils literal notranslate"><span class="pre">FW_CDEV_LONG_RESET</span></code></p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Initiate a bus reset for the bus this device is on.  The bus reset can be
either the original (long) bus reset or the arbitrated (short) bus reset
introduced in 1394a-2000.</p>
<p>The ioctl returns immediately.  A subsequent <a class="reference internal" href="#c.fw_cdev_event_bus_reset" title="fw_cdev_event_bus_reset"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_bus_reset</span></code></a>
indicates when the reset actually happened.  Since ABI v4, this may be
considerably later than the ioctl because the kernel ensures a grace period
between subsequent bus resets as per IEEE 1394 bus management specification.</p>
<dl class="type">
<dt id="c.fw_cdev_add_descriptor">
struct <code class="sig-name descname">fw_cdev_add_descriptor</code><a class="headerlink" href="#c.fw_cdev_add_descriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Add contents to the local node’s config ROM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_add_descriptor {
    __u32 immediate;
    __u32 key;
    __u64 data;
    __u32 length;
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">immediate</span></code></dt><dd><p>If non-zero, immediate key to insert before pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>Upper 8 bits of root directory pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Userspace pointer to contents of descriptor block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Length of descriptor block data, in quadlets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle to the descriptor, written by the kernel</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Add a descriptor block and optionally a preceding immediate key to the local
node’s Configuration ROM.</p>
<p>The <strong>key</strong> field specifies the upper 8 bits of the descriptor root directory
pointer and the <strong>data</strong> and <strong>length</strong> fields specify the contents. The <strong>key</strong>
should be of the form 0xXX000000. The offset part of the root directory entry
will be filled in by the kernel.</p>
<p>If not 0, the <strong>immediate</strong> field specifies an immediate key which will be
inserted before the root directory pointer.</p>
<p><strong>immediate</strong>, <strong>key</strong>, and <strong>data</strong> array elements are CPU-endian quadlets.</p>
<p>If successful, the kernel adds the descriptor and writes back a <strong>handle</strong> to
the kernel-side object to be used for later removal of the descriptor block
and immediate key.  The kernel will also generate a bus reset to signal the
change of the Configuration ROM to other nodes.</p>
<p>This ioctl affects the Configuration ROMs of all local nodes.
The ioctl only succeeds on device files which represent a local node.</p>
<dl class="type">
<dt id="c.fw_cdev_remove_descriptor">
struct <code class="sig-name descname">fw_cdev_remove_descriptor</code><a class="headerlink" href="#c.fw_cdev_remove_descriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove contents from the Configuration ROM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_remove_descriptor {
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle to the descriptor, as returned by the kernel when the
descriptor was added</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Remove a descriptor block and accompanying immediate key from the local
nodes’ Configuration ROMs.  The kernel will also generate a bus reset to
signal the change of the Configuration ROM to other nodes.</p>
<dl class="type">
<dt id="c.fw_cdev_create_iso_context">
struct <code class="sig-name descname">fw_cdev_create_iso_context</code><a class="headerlink" href="#c.fw_cdev_create_iso_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a context for isochronous I/O</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_create_iso_context {
    __u32 type;
    __u32 header_size;
    __u32 channel;
    __u32 speed;
    __u64 closure;
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_TRANSMIT</span></code> or <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_RECEIVE</span></code> or
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header_size</span></code></dt><dd><p>Header size to strip in single-channel reception</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>Channel to bind to in single-channel reception or transmission</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">speed</span></code></dt><dd><p>Transmission speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>To be returned in <a class="reference internal" href="#c.fw_cdev_event_iso_interrupt" title="fw_cdev_event_iso_interrupt"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_iso_interrupt</span></code></a> or
<code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_iso_interrupt_multichannel</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle to context, written back by kernel</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Prior to sending or receiving isochronous I/O, a context must be created.
The context records information about the transmit or receive configuration
and typically maps to an underlying hardware resource.  A context is set up
for either sending or receiving.  It is bound to a specific isochronous
<strong>channel</strong>.</p>
<p>In case of multichannel reception, <strong>header_size</strong> and <strong>channel</strong> are ignored
and the channels are selected by <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_SET_ISO_CHANNELS</span></code>.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_RECEIVE</span></code> contexts, <strong>header_size</strong> must be at least 4
and must be a multiple of 4.  It is ignored in other context types.</p>
<p><strong>speed</strong> is ignored in receive context types.</p>
<p>If a context was successfully created, the kernel writes back a handle to the
context, which must be passed in for subsequent operations on that context.</p>
<p>Limitations:
No more than one iso context can be created per fd.
The total number of contexts that all userspace and kernelspace drivers can
create on a card at a time is a hardware limit, typically 4 or 8 contexts per
direction, and of them at most one multichannel receive context.</p>
<dl class="type">
<dt id="c.fw_cdev_set_iso_channels">
struct <code class="sig-name descname">fw_cdev_set_iso_channels</code><a class="headerlink" href="#c.fw_cdev_set_iso_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Select channels in multichannel reception</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_set_iso_channels {
    __u64 channels;
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">channels</span></code></dt><dd><p>Bitmask of channels to listen to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle of the mutichannel receive context</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p><strong>channels</strong> is the bitwise or of 1ULL &lt;&lt; n for each channel n to listen to.</p>
<p>The ioctl fails with errno <code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> if there is already another receive context
on a channel in <strong>channels</strong>.  In that case, the bitmask of all unoccupied
channels is returned in <strong>channels</strong>.</p>
<dl class="type">
<dt id="c.fw_cdev_iso_packet">
struct <code class="sig-name descname">fw_cdev_iso_packet</code><a class="headerlink" href="#c.fw_cdev_iso_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Isochronous packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_iso_packet {
    __u32 control;
    __u32 header[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">control</span></code></dt><dd><p>Contains the header length (8 uppermost bits),
the sy field (4 bits), the tag field (2 bits), a sync flag
or a skip flag (1 bit), an interrupt flag (1 bit), and the
payload length (16 lowermost bits)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header</span></code></dt><dd><p>Header and payload in case of a transmit context.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.fw_cdev_iso_packet" title="fw_cdev_iso_packet"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fw_cdev_iso_packet</span></code></a> is used to describe isochronous packet queues.
Use the FW_CDEV_ISO_* macros to fill in <strong>control</strong>.
The <strong>header</strong> array is empty in case of receive contexts.</p>
<p>Context type <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_TRANSMIT</span></code>:</p>
<p><strong>control.HEADER_LENGTH</strong> must be a multiple of 4.  It specifies the numbers of
bytes in <strong>header</strong> that will be prepended to the packet’s payload.  These bytes
are copied into the kernel and will not be accessed after the ioctl has
returned.</p>
<p>The <strong>control.SY</strong> and TAG fields are copied to the iso packet header.  These
fields are specified by IEEE 1394a and IEC 61883-1.</p>
<p>The <strong>control.SKIP</strong> flag specifies that no packet is to be sent in a frame.
When using this, all other fields except <strong>control.INTERRUPT</strong> must be zero.</p>
<p>When a packet with the <strong>control.INTERRUPT</strong> flag set has been completed, an
<a class="reference internal" href="#c.fw_cdev_event_iso_interrupt" title="fw_cdev_event_iso_interrupt"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_iso_interrupt</span></code></a> event will be sent.</p>
<p>Context type <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_RECEIVE</span></code>:</p>
<p><strong>control.HEADER_LENGTH</strong> must be a multiple of the context’s header_size.
If the HEADER_LENGTH is larger than the context’s header_size, multiple
packets are queued for this entry.</p>
<p>The <strong>control.SY</strong> and TAG fields are ignored.</p>
<p>If the <strong>control.SYNC</strong> flag is set, the context drops all packets until a
packet with a sy field is received which matches <a class="reference internal" href="#c.fw_cdev_start_iso" title="fw_cdev_start_iso"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_start_iso.sync</span></code></a>.</p>
<p><strong>control.PAYLOAD_LENGTH</strong> defines how many payload bytes can be received for
one packet (in addition to payload quadlets that have been defined as headers
and are stripped and returned in the <a class="reference internal" href="#c.fw_cdev_event_iso_interrupt" title="fw_cdev_event_iso_interrupt"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_iso_interrupt</span></code></a> structure).
If more bytes are received, the additional bytes are dropped.  If less bytes
are received, the remaining bytes in this part of the payload buffer will not
be written to, not even by the next packet.  I.e., packets received in
consecutive frames will not necessarily be consecutive in memory.  If an
entry has queued multiple packets, the PAYLOAD_LENGTH is divided equally
among them.</p>
<p>When a packet with the <strong>control.INTERRUPT</strong> flag set has been completed, an
<a class="reference internal" href="#c.fw_cdev_event_iso_interrupt" title="fw_cdev_event_iso_interrupt"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_iso_interrupt</span></code></a> event will be sent.  An entry that has queued
multiple receive packets is completed when its last packet is completed.</p>
<p>Context type <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span></code>:</p>
<p>Here, <a class="reference internal" href="#c.fw_cdev_iso_packet" title="fw_cdev_iso_packet"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_iso_packet</span></code></a> would be more aptly named _iso_buffer_chunk since
it specifies a chunk of the mmap()’ed buffer, while the number and alignment
of packets to be placed into the buffer chunk is not known beforehand.</p>
<p><strong>control.PAYLOAD_LENGTH</strong> is the size of the buffer chunk and specifies room
for header, payload, padding, and trailer bytes of one or more packets.
It must be a multiple of 4.</p>
<p><strong>control.HEADER_LENGTH</strong>, TAG and SY are ignored.  SYNC is treated as described
for single-channel reception.</p>
<p>When a buffer chunk with the <strong>control.INTERRUPT</strong> flag set has been filled
entirely, an <a class="reference internal" href="#c.fw_cdev_event_iso_interrupt_mc" title="fw_cdev_event_iso_interrupt_mc"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_iso_interrupt_mc</span></code></a> event will be sent.</p>
<dl class="type">
<dt id="c.fw_cdev_queue_iso">
struct <code class="sig-name descname">fw_cdev_queue_iso</code><a class="headerlink" href="#c.fw_cdev_queue_iso" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue isochronous packets for I/O</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_queue_iso {
    __u64 packets;
    __u64 data;
    __u32 size;
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">packets</span></code></dt><dd><p>Userspace pointer to an array of <a class="reference internal" href="#c.fw_cdev_iso_packet" title="fw_cdev_iso_packet"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_iso_packet</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Pointer into mmap()’ed payload buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Size of the <strong>packets</strong> array, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Isochronous context handle</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Queue a number of isochronous packets for reception or transmission.
This ioctl takes a pointer to an array of <a class="reference internal" href="#c.fw_cdev_iso_packet" title="fw_cdev_iso_packet"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_iso_packet</span></code></a> structs,
which describe how to transmit from or receive into a contiguous region
of a mmap()’ed payload buffer.  As part of transmit packet descriptors,
a series of headers can be supplied, which will be prepended to the
payload during DMA.</p>
<p>The kernel may or may not queue all packets, but will write back updated
values of the <strong>packets</strong>, <strong>data</strong> and <strong>size</strong> fields, so the ioctl can be
resubmitted easily.</p>
<p>In case of a multichannel receive context, <strong>data</strong> must be quadlet-aligned
relative to the buffer start.</p>
<dl class="type">
<dt id="c.fw_cdev_start_iso">
struct <code class="sig-name descname">fw_cdev_start_iso</code><a class="headerlink" href="#c.fw_cdev_start_iso" title="Permalink to this definition">¶</a></dt>
<dd><p>Start an isochronous transmission or reception</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_start_iso {
    __s32 cycle;
    __u32 sync;
    __u32 tags;
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cycle</span></code></dt><dd><p>Cycle in which to start I/O.  If <strong>cycle</strong> is greater than or
equal to 0, the I/O will start on that cycle.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sync</span></code></dt><dd><p>Determines the value to wait for receive packets that have
the <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_SYNC</span></code> bit set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tags</span></code></dt><dd><p>Tag filter bit mask.  Only valid for isochronous reception.
Determines the tag values for which packets will be accepted.
Use FW_CDEV_ISO_CONTEXT_MATCH_* macros to set <strong>tags</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Isochronous context handle within which to transmit or receive</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.fw_cdev_stop_iso">
struct <code class="sig-name descname">fw_cdev_stop_iso</code><a class="headerlink" href="#c.fw_cdev_stop_iso" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop an isochronous transmission or reception</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_stop_iso {
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle of isochronous context to stop</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.fw_cdev_flush_iso">
struct <code class="sig-name descname">fw_cdev_flush_iso</code><a class="headerlink" href="#c.fw_cdev_flush_iso" title="Permalink to this definition">¶</a></dt>
<dd><p>flush completed iso packets</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_flush_iso {
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>handle of isochronous context to flush</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>For <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_TRANSMIT</span></code> or <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_RECEIVE</span></code> contexts,
report any completed packets.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">FW_CDEV_ISO_CONTEXT_RECEIVE_MULTICHANNEL</span></code> contexts, report the current
offset in the receive buffer, if it has changed; this is typically in the
middle of some buffer chunk.</p>
<p>Any <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_INTERRUPT</span></code> or <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL</span></code>
events generated by this ioctl are sent synchronously, i.e., are available
for reading from the file descriptor when this ioctl returns.</p>
<dl class="type">
<dt id="c.fw_cdev_get_cycle_timer">
struct <code class="sig-name descname">fw_cdev_get_cycle_timer</code><a class="headerlink" href="#c.fw_cdev_get_cycle_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>read cycle timer register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_get_cycle_timer {
    __u64 local_time;
    __u32 cycle_timer;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">local_time</span></code></dt><dd><p>system time, in microseconds since the Epoch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cycle_timer</span></code></dt><dd><p>Cycle Time register contents</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Same as <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_GET_CYCLE_TIMER2</span></code>, but fixed to use <code class="docutils literal notranslate"><span class="pre">CLOCK_REALTIME</span></code>
and only with microseconds resolution.</p>
<p>In version 1 and 2 of the ABI, this ioctl returned unreliable (non-
monotonic) <strong>cycle_timer</strong> values on certain controllers.</p>
<dl class="type">
<dt id="c.fw_cdev_get_cycle_timer2">
struct <code class="sig-name descname">fw_cdev_get_cycle_timer2</code><a class="headerlink" href="#c.fw_cdev_get_cycle_timer2" title="Permalink to this definition">¶</a></dt>
<dd><p>read cycle timer register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_get_cycle_timer2 {
    __s64 tv_sec;
    __s32 tv_nsec;
    __s32 clk_id;
    __u32 cycle_timer;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tv_sec</span></code></dt><dd><p>system time, seconds</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tv_nsec</span></code></dt><dd><p>system time, sub-seconds part in nanoseconds</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clk_id</span></code></dt><dd><p>input parameter, clock from which to get the system time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cycle_timer</span></code></dt><dd><p>Cycle Time register contents</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_GET_CYCLE_TIMER2</span></code> ioctl reads the isochronous cycle timer
and also the system clock.  This allows to correlate reception time of
isochronous packets with system time.</p>
<p><strong>clk_id</strong> lets you choose a clock like with POSIX’ clock_gettime function.
Supported <strong>clk_id</strong> values are POSIX’ <code class="docutils literal notranslate"><span class="pre">CLOCK_REALTIME</span></code> and <code class="docutils literal notranslate"><span class="pre">CLOCK_MONOTONIC</span></code>
and Linux’ <code class="docutils literal notranslate"><span class="pre">CLOCK_MONOTONIC_RAW</span></code>.</p>
<p><strong>cycle_timer</strong> consists of 7 bits cycleSeconds, 13 bits cycleCount, and
12 bits cycleOffset, in host byte order.  Cf. the Cycle Time register
per IEEE 1394 or Isochronous Cycle Timer register per OHCI-1394.</p>
<dl class="type">
<dt id="c.fw_cdev_allocate_iso_resource">
struct <code class="sig-name descname">fw_cdev_allocate_iso_resource</code><a class="headerlink" href="#c.fw_cdev_allocate_iso_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>(De)allocate a channel or bandwidth</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_allocate_iso_resource {
    __u64 closure;
    __u64 channels;
    __u32 bandwidth;
    __u32 handle;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>Passed back to userspace in corresponding iso resource events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channels</span></code></dt><dd><p>Isochronous channels of which one is to be (de)allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bandwidth</span></code></dt><dd><p>Isochronous bandwidth units to be (de)allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle</span></code></dt><dd><p>Handle to the allocation, written by the kernel (only valid in
case of <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE</span></code> ioctls)</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE</span></code> ioctl initiates allocation of an
isochronous channel and/or of isochronous bandwidth at the isochronous
resource manager (IRM).  Only one of the channels specified in <strong>channels</strong> is
allocated.  An <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED</span></code> is sent after
communication with the IRM, indicating success or failure in the event data.
The kernel will automatically reallocate the resources after bus resets.
Should a reallocation fail, an <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED</span></code> event
will be sent.  The kernel will also automatically deallocate the resources
when the file descriptor is closed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE</span></code> ioctl can be used to initiate
deallocation of resources which were allocated as described above.
An <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED</span></code> event concludes this operation.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE</span></code> ioctl is a variant of allocation
without automatic re- or deallocation.
An <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED</span></code> event concludes this operation,
indicating success or failure in its data.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE_ONCE</span></code> ioctl works like
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE</span></code> except that resources are freed
instead of allocated.
An <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED</span></code> event concludes this operation.</p>
<p>To summarize, <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE</span></code> allocates iso resources
for the lifetime of the fd or <strong>handle</strong>.
In contrast, <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE</span></code> allocates iso resources
for the duration of a bus generation.</p>
<p><strong>channels</strong> is a host-endian bitfield with the least significant bit
representing channel 0 and the most significant bit representing channel 63:
1ULL &lt;&lt; c for each channel c that is a candidate for (de)allocation.</p>
<p><strong>bandwidth</strong> is expressed in bandwidth allocation units, i.e. the time to send
one quadlet of data (payload or header data) at speed S1600.</p>
<dl class="type">
<dt id="c.fw_cdev_send_stream_packet">
struct <code class="sig-name descname">fw_cdev_send_stream_packet</code><a class="headerlink" href="#c.fw_cdev_send_stream_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>send an asynchronous stream packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_send_stream_packet {
    __u32 length;
    __u32 tag;
    __u32 channel;
    __u32 sy;
    __u64 closure;
    __u64 data;
    __u32 generation;
    __u32 speed;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">length</span></code></dt><dd><p>Length of outgoing payload, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tag</span></code></dt><dd><p>Data format tag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>Isochronous channel to transmit to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sy</span></code></dt><dd><p>Synchronization code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>Passed back to userspace in the response event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Userspace pointer to payload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">generation</span></code></dt><dd><p>The bus generation where packet is valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">speed</span></code></dt><dd><p>Speed to transmit at</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_SEND_STREAM_PACKET</span></code> ioctl sends an asynchronous stream packet
to every device which is listening to the specified channel.  The kernel
writes an <a class="reference internal" href="#c.fw_cdev_event_response" title="fw_cdev_event_response"><code class="xref c c-type docutils literal notranslate"><span class="pre">fw_cdev_event_response</span></code></a> event which indicates success or failure of
the transmission.</p>
<dl class="type">
<dt id="c.fw_cdev_send_phy_packet">
struct <code class="sig-name descname">fw_cdev_send_phy_packet</code><a class="headerlink" href="#c.fw_cdev_send_phy_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>send a PHY packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_send_phy_packet {
    __u64 closure;
    __u32 data[2];
    __u32 generation;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>Passed back to userspace in the PHY-packet-sent event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>First and second quadlet of the PHY packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">generation</span></code></dt><dd><p>The bus generation where packet is valid</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">FW_CDEV_IOC_SEND_PHY_PACKET</span></code> ioctl sends a PHY packet to all nodes
on the same card as this device.  After transmission, an
<code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_PHY_PACKET_SENT</span></code> event is generated.</p>
<p>The payload <strong>data</strong>[] shall be specified in host byte order.  Usually,
<strong>data</strong>[1] needs to be the bitwise inverse of <strong>data</strong>[0].  VersaPHY packets
are an exception to this rule.</p>
<p>The ioctl is only permitted on device files which represent a local node.</p>
<dl class="type">
<dt id="c.fw_cdev_receive_phy_packets">
struct <code class="sig-name descname">fw_cdev_receive_phy_packets</code><a class="headerlink" href="#c.fw_cdev_receive_phy_packets" title="Permalink to this definition">¶</a></dt>
<dd><p>start reception of PHY packets</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fw_cdev_receive_phy_packets {
    __u64 closure;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">closure</span></code></dt><dd><p>Passed back to userspace in phy packet events</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This ioctl activates issuing of <code class="docutils literal notranslate"><span class="pre">FW_CDEV_EVENT_PHY_PACKET_RECEIVED</span></code> due to
incoming PHY packets from any node on the same bus as the device.</p>
<p>The ioctl is only permitted on device files which represent a local node.</p>
</section>
<section id="firewire-device-probing-and-sysfs-interfaces">
<h2>Firewire device probing and sysfs interfaces<a class="headerlink" href="#firewire-device-probing-and-sysfs-interfaces" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">What:           /sys/bus/firewire/devices/fw[0-9]+/
Date:           May 2007
KernelVersion:  2.6.22
Contact:        linux1394-devel&#64;lists.sourceforge.net
Description:
                IEEE 1394 node device attributes.
                Read-only.  Mutable during the node device's lifetime.
                See IEEE 1212 for semantic definitions.

                config_rom
                        Contents of the Configuration ROM register.
                        Binary attribute; an array of host-endian u32.

                guid
                        The node's EUI-64 in the bus information block of
                        Configuration ROM.
                        Hexadecimal string representation of an u64.


What:           /sys/bus/firewire/devices/fw[0-9]+/units
Date:           June 2009
KernelVersion:  2.6.31
Contact:        linux1394-devel&#64;lists.sourceforge.net
Description:
                IEEE 1394 node device attribute.
                Read-only.  Mutable during the node device's lifetime.
                See IEEE 1212 for semantic definitions.

                units
                        Summary of all units present in an IEEE 1394 node.
                        Contains space-separated tuples of specifier_id and
                        version of each unit present in the node.  Specifier_id
                        and version are hexadecimal string representations of
                        u24 of the respective unit directory entries.
                        Specifier_id and version within each tuple are separated
                        by a colon.

Users:          udev rules to set ownership and access permissions or ACLs of
                /dev/fw[0-9]+ character device files


What:           /sys/bus/firewire/devices/fw[0-9]+/is_local
Date:           July 2012
KernelVersion:  3.6
Contact:        linux1394-devel&#64;lists.sourceforge.net
Description:
                IEEE 1394 node device attribute.
                Read-only and immutable.
Values:         1: The sysfs entry represents a local node (a controller card).

                0: The sysfs entry represents a remote node.


What:           /sys/bus/firewire/devices/fw[0-9]+[.][0-9]+/
Date:           May 2007
KernelVersion:  2.6.22
Contact:        linux1394-devel&#64;lists.sourceforge.net
Description:
                IEEE 1394 unit device attributes.
                Read-only.  Immutable during the unit device's lifetime.
                See IEEE 1212 for semantic definitions.

                modalias
                        Same as MODALIAS in the uevent at device creation.

                rom_index
                        Offset of the unit directory within the parent device's
                        (node device's) Configuration ROM, in quadlets.
                        Decimal string representation.


What:           /sys/bus/firewire/devices/*/
Date:           May 2007
KernelVersion:  2.6.22
Contact:        linux1394-devel&#64;lists.sourceforge.net
Description:
                Attributes common to IEEE 1394 node devices and unit devices.
                Read-only.  Mutable during the node device's lifetime.
                Immutable during the unit device's lifetime.
                See IEEE 1212 for semantic definitions.

                These attributes are only created if the root directory of an
                IEEE 1394 node or the unit directory of an IEEE 1394 unit
                actually contains according entries.

                hardware_version
                        Hexadecimal string representation of an u24.

                hardware_version_name
                        Contents of a respective textual descriptor leaf.

                model
                        Hexadecimal string representation of an u24.

                model_name
                        Contents of a respective textual descriptor leaf.

                specifier_id
                        Hexadecimal string representation of an u24.
                        Mandatory in unit directories according to IEEE 1212.

                vendor
                        Hexadecimal string representation of an u24.
                        Mandatory in the root directory according to IEEE 1212.

                vendor_name
                        Contents of a respective textual descriptor leaf.

                version
                        Hexadecimal string representation of an u24.
                        Mandatory in unit directories according to IEEE 1212.


What:           /sys/bus/firewire/drivers/sbp2/fw*/host*/target*/*:*:*:*/ieee1394_id
                formerly
                /sys/bus/ieee1394/drivers/sbp2/fw*/host*/target*/*:*:*:*/ieee1394_id
Date:           Feb 2004
KernelVersion:  2.6.4
Contact:        linux1394-devel&#64;lists.sourceforge.net
Description:
                SCSI target port identifier and logical unit identifier of a
                logical unit of an SBP-2 target.  The identifiers are specified
                in SAM-2...SAM-4 annex A.  They are persistent and world-wide
                unique properties the SBP-2 attached target.

                Read-only attribute, immutable during the target's lifetime.
                Format, as exposed by firewire-sbp2 since 2.6.22, May 2007:
                Colon-separated hexadecimal string representations of

                        u64 EUI-64 : u24 directory_ID : u16 LUN

                without 0x prefixes, without whitespace.  The former sbp2 driver
                (removed in 2.6.37 after being superseded by firewire-sbp2) used
                a somewhat shorter format which was not as close to SAM.

Users:          udev rules to create /dev/disk/by-id/ symlinks
</pre>
<dl class="function">
<dt id="c.fw_csr_string">
int <code class="sig-name descname">fw_csr_string</code><span class="sig-paren">(</span>const u32<em> *directory</em>, int<em> key</em>, char<em> *buf</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fw_csr_string" title="Permalink to this definition">¶</a></dt>
<dd><p>reads a string from the configuration ROM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*directory</span></code></dt><dd><p>e.g. root directory or unit directory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">key</span></code></dt><dd><p>the key of the preceding directory entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>where to put the string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of <strong>buf</strong>, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The string is taken from a minimal ASCII text descriptor leaf after
the immediate entry with <strong>key</strong>.  The string is zero-terminated.
An overlong string is silently truncated such that it and the
zero byte fit into <strong>size</strong>.</p>
<p>Returns strlen(buf) or a negative error code.</p>
</div>
</section>
<section id="firewire-core-transaction-interfaces">
<h2>Firewire core transaction interfaces<a class="headerlink" href="#firewire-core-transaction-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.fw_send_request">
void <code class="sig-name descname">fw_send_request</code><span class="sig-paren">(</span>struct fw_card<em> *card</em>, struct fw_transaction<em> *t</em>, int<em> tcode</em>, int<em> destination_id</em>, int<em> generation</em>, int<em> speed</em>, unsigned long long<em> offset</em>, void<em> *payload</em>, size_t<em> length</em>, fw_transaction_callback_t<em> callback</em>, void<em> *callback_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fw_send_request" title="Permalink to this definition">¶</a></dt>
<dd><p>submit a request packet for transmission</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fw_card</span> <span class="pre">*card</span></code></dt><dd><p>interface to send the request at</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fw_transaction</span> <span class="pre">*t</span></code></dt><dd><p>transaction instance to which the request belongs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">tcode</span></code></dt><dd><p>transaction code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">destination_id</span></code></dt><dd><p>destination node ID, consisting of bus_ID and phy_ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">generation</span></code></dt><dd><p>bus generation in which request and response are valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>transmission speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">offset</span></code></dt><dd><p>48bit wide offset into destination’s address space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*payload</span></code></dt><dd><p>data payload for the request subaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>length of the payload, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fw_transaction_callback_t</span> <span class="pre">callback</span></code></dt><dd><p>function to be called when the transaction is completed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*callback_data</span></code></dt><dd><p>data to be passed to the transaction completion callback</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Submit a request packet into the asynchronous request transmission queue.
Can be called from atomic context.  If you prefer a blocking API, use
<a class="reference internal" href="#c.fw_run_transaction" title="fw_run_transaction"><code class="xref c c-func docutils literal notranslate"><span class="pre">fw_run_transaction()</span></code></a> in a context that can sleep.</p>
<p>In case of lock requests, specify one of the firewire-core specific <code class="docutils literal notranslate"><span class="pre">TCODE_</span></code>
constants instead of <code class="docutils literal notranslate"><span class="pre">TCODE_LOCK_REQUEST</span></code> in <strong>tcode</strong>.</p>
<p>Make sure that the value in <strong>destination_id</strong> is not older than the one in
<strong>generation</strong>.  Otherwise the request is in danger to be sent to a wrong node.</p>
<p>In case of asynchronous stream packets i.e. <code class="docutils literal notranslate"><span class="pre">TCODE_STREAM_DATA</span></code>, the caller
needs to synthesize <strong>destination_id</strong> with fw_stream_packet_destination_id().
It will contain tag, channel, and sy data instead of a node ID then.</p>
<p>The payload buffer at <strong>data</strong> is going to be DMA-mapped except in case of
<strong>length</strong> &lt;= 8 or of local (loopback) requests.  Hence make sure that the
buffer complies with the restrictions of the streaming DMA mapping API.
<strong>payload</strong> must not be freed before the <strong>callback</strong> is called.</p>
<p>In case of request types without payload, <strong>data</strong> is NULL and <strong>length</strong> is 0.</p>
<p>After the transaction is completed successfully or unsuccessfully, the
<strong>callback</strong> will be called.  Among its parameters is the response code which
is either one of the rcodes per IEEE 1394 or, in case of internal errors,
the firewire-core specific <code class="docutils literal notranslate"><span class="pre">RCODE_SEND_ERROR</span></code>.  The other firewire-core
specific rcodes (<code class="docutils literal notranslate"><span class="pre">RCODE_CANCELLED</span></code>, <code class="docutils literal notranslate"><span class="pre">RCODE_BUSY</span></code>, <code class="docutils literal notranslate"><span class="pre">RCODE_GENERATION</span></code>,
<code class="docutils literal notranslate"><span class="pre">RCODE_NO_ACK</span></code>) denote transaction timeout, busy responder, stale request
generation, or missing ACK respectively.</p>
<p>Note some timing corner cases:  <a class="reference internal" href="#c.fw_send_request" title="fw_send_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">fw_send_request()</span></code></a> may complete much earlier
than when the request packet actually hits the wire.  On the other hand,
transaction completion and hence execution of <strong>callback</strong> may happen even
before <a class="reference internal" href="#c.fw_send_request" title="fw_send_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">fw_send_request()</span></code></a> returns.</p>
</div>
<dl class="function">
<dt id="c.fw_run_transaction">
int <code class="sig-name descname">fw_run_transaction</code><span class="sig-paren">(</span>struct fw_card<em> *card</em>, int<em> tcode</em>, int<em> destination_id</em>, int<em> generation</em>, int<em> speed</em>, unsigned long long<em> offset</em>, void<em> *payload</em>, size_t<em> length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fw_run_transaction" title="Permalink to this definition">¶</a></dt>
<dd><p>send request and sleep until transaction is completed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fw_card</span> <span class="pre">*card</span></code></dt><dd><p>card interface for this request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">tcode</span></code></dt><dd><p>transaction code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">destination_id</span></code></dt><dd><p>destination node ID, consisting of bus_ID and phy_ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">generation</span></code></dt><dd><p>bus generation in which request and response are valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>transmission speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">offset</span></code></dt><dd><p>48bit wide offset into destination’s address space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*payload</span></code></dt><dd><p>data payload for the request subaction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">length</span></code></dt><dd><p>length of the payload, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the RCODE.  See <a class="reference internal" href="#c.fw_send_request" title="fw_send_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">fw_send_request()</span></code></a> for parameter documentation.
Unlike <a class="reference internal" href="#c.fw_send_request" title="fw_send_request"><code class="xref c c-func docutils literal notranslate"><span class="pre">fw_send_request()</span></code></a>, <strong>data</strong> points to the payload of the request or/and
to the payload of the response.  DMA mapping restrictions apply to outbound
request payloads of &gt;= 8 bytes but not to inbound response payloads.</p>
</div>
<dl class="function">
<dt id="c.fw_core_add_address_handler">
int <code class="sig-name descname">fw_core_add_address_handler</code><span class="sig-paren">(</span>struct fw_address_handler<em> *handler</em>, const struct fw_address_region<em> *region</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fw_core_add_address_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>register for incoming requests</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fw_address_handler</span> <span class="pre">*handler</span></code></dt><dd><p>callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fw_address_region</span> <span class="pre">*region</span></code></dt><dd><p>region in the IEEE 1212 node space address range</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>region-&gt;start, -&gt;end, and handler-&gt;length have to be quadlet-aligned.</p>
<p>When a request is received that falls within the specified address range,
the specified callback is invoked.  The parameters passed to the callback
give the details of the particular request.</p>
<p>To be called in process context.
Return value:  0 on success, non-zero otherwise.</p>
<p>The start offset of the handler’s address region is determined by
<a class="reference internal" href="#c.fw_core_add_address_handler" title="fw_core_add_address_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">fw_core_add_address_handler()</span></code></a> and is returned in handler-&gt;offset.</p>
<p>Address allocations are exclusive, except for the FCP registers.</p>
</div>
<dl class="function">
<dt id="c.fw_core_remove_address_handler">
void <code class="sig-name descname">fw_core_remove_address_handler</code><span class="sig-paren">(</span>struct fw_address_handler<em> *handler</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fw_core_remove_address_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an address handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fw_address_handler</span> <span class="pre">*handler</span></code></dt><dd><p>callback</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>To be called in process context.</p>
<p>When <a class="reference internal" href="#c.fw_core_remove_address_handler" title="fw_core_remove_address_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">fw_core_remove_address_handler()</span></code></a> returns, <strong>handler-&gt;callback()</strong> is
guaranteed to not run on any CPU anymore.</p>
</div>
<dl class="function">
<dt id="c.fw_get_request_speed">
int <code class="sig-name descname">fw_get_request_speed</code><span class="sig-paren">(</span>struct fw_request<em> *request</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fw_get_request_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>returns speed at which the <strong>request</strong> was received</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fw_request</span> <span class="pre">*request</span></code></dt><dd><p>firewire request data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.fw_request_get_timestamp">
u32 <code class="sig-name descname">fw_request_get_timestamp</code><span class="sig-paren">(</span>const struct fw_request<em> *request</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fw_request_get_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get timestamp of the request.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">fw_request</span> <span class="pre">*request</span></code></dt><dd><p>The opaque pointer to request structure.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get timestamp when 1394 OHCI controller receives the asynchronous request subaction. The
timestamp consists of the low order 3 bits of second field and the full 13 bits of count
field of isochronous cycle time register.</p>
<p><strong>Return</strong></p>
<p>timestamp of the request.</p>
</div>
<dl class="function">
<dt id="c.fw_rcode_string">
const char * <code class="sig-name descname">fw_rcode_string</code><span class="sig-paren">(</span>int<em> rcode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fw_rcode_string" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a firewire result code to an error description</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">rcode</span></code></dt><dd><p>the result code</p>
</dd>
</dl>
</div>
</section>
<section id="firewire-isochronous-i-o-interfaces">
<h2>Firewire Isochronous I/O interfaces<a class="headerlink" href="#firewire-isochronous-i-o-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.fw_iso_resource_manage">
void <code class="sig-name descname">fw_iso_resource_manage</code><span class="sig-paren">(</span>struct fw_card<em> *card</em>, int<em> generation</em>, u64<em> channels_mask</em>, int<em> *channel</em>, int<em> *bandwidth</em>, bool<em> allocate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fw_iso_resource_manage" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate or deallocate a channel and/or bandwidth</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fw_card</span> <span class="pre">*card</span></code></dt><dd><p>card interface for this action</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">generation</span></code></dt><dd><p>bus generation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">channels_mask</span></code></dt><dd><p>bitmask for channel allocation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*channel</span></code></dt><dd><p>pointer for returning channel allocation result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*bandwidth</span></code></dt><dd><p>pointer for returning bandwidth allocation result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">allocate</span></code></dt><dd><p>whether to allocate (true) or deallocate (false)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In parameters: card, generation, channels_mask, bandwidth, allocate
Out parameters: channel, bandwidth</p>
<p>This function blocks (sleeps) during communication with the IRM.</p>
<p>Allocates or deallocates at most one channel out of channels_mask.
channels_mask is a bitfield with MSB for channel 63 and LSB for channel 0.
(Note, the IRM’s CHANNELS_AVAILABLE is a big-endian bitfield with MSB for
channel 0 and LSB for channel 63.)
Allocates or deallocates as many bandwidth allocation units as specified.</p>
<p>Returns channel &lt; 0 if no channel was allocated or deallocated.
Returns bandwidth = 0 if no bandwidth was allocated or deallocated.</p>
<p>If generation is stale, deallocations succeed but allocations fail with
channel = -EAGAIN.</p>
<p>If channel allocation fails, no bandwidth will be allocated either.
If bandwidth allocation fails, no channel will be allocated either.
But deallocations of channel and bandwidth are tried independently
of each other’s success.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Firewire (IEEE 1394) driver Interface Guide</a><ul>
<li><a class="reference internal" href="#introduction-and-overview">Introduction and Overview</a></li>
<li><a class="reference internal" href="#firewire-char-device-data-structures">Firewire char device data structures</a></li>
<li><a class="reference internal" href="#firewire-device-probing-and-sysfs-interfaces">Firewire device probing and sysfs interfaces</a></li>
<li><a class="reference internal" href="#firewire-core-transaction-interfaces">Firewire core transaction interfaces</a></li>
<li><a class="reference internal" href="#firewire-isochronous-i-o-interfaces">Firewire Isochronous I/O interfaces</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/firewire.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/firewire.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>