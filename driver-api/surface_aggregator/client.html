
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Writing Client Drivers &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Client Driver API Documentation" href="client-api.html" />
    <link rel="prev" title="Overview" href="overview.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="writing-client-drivers">
<h1>Writing Client Drivers<a class="headerlink" href="#writing-client-drivers" title="Permalink to this headline">¶</a></h1>
<p>For the API documentation, refer to:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="client-api.html">Client Driver API Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="client-api.html#serial-hub-communication">Serial Hub Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="client-api.html#controller-and-core-interface">Controller and Core Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="client-api.html#client-bus-and-client-device-api">Client Bus and Client Device API</a></li>
</ul>
</li>
</ul>
</div>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Client drivers can be set up in two main ways, depending on how the
corresponding device is made available to the system. We specifically
differentiate between devices that are presented to the system via one of
the conventional ways, e.g. as platform devices via ACPI, and devices that
are non-discoverable and instead need to be explicitly provided by some
other mechanism, as discussed further below.</p>
</section>
<section id="non-ssam-client-drivers">
<h2>Non-SSAM Client Drivers<a class="headerlink" href="#non-ssam-client-drivers" title="Permalink to this headline">¶</a></h2>
<p>All communication with the SAM EC is handled via the <a class="reference internal" href="internal-api.html#c.ssam_controller" title="ssam_controller"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ssam_controller</span></code></a>
representing that EC to the kernel. Drivers targeting a non-SSAM device (and
thus not being a <a class="reference internal" href="client-api.html#c.ssam_device_driver" title="ssam_device_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ssam_device_driver</span></code></a>) need to explicitly establish a
connection/relation to that controller. This can be done via the
<a class="reference internal" href="client-api.html#c.ssam_client_bind" title="ssam_client_bind"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_client_bind()</span></code></a> function. Said function returns a reference to the SSAM
controller, but, more importantly, also establishes a device link between
client device and controller (this can also be done separate via
<a class="reference internal" href="client-api.html#c.ssam_client_link" title="ssam_client_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_client_link()</span></code></a>). It is important to do this, as it, first, guarantees
that the returned controller is valid for use in the client driver for as
long as this driver is bound to its device, i.e. that the driver gets
unbound before the controller ever becomes invalid, and, second, as it
ensures correct suspend/resume ordering. This setup should be done in the
driver’s probe function, and may be used to defer probing in case the SSAM
subsystem is not ready yet, for example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">client_driver_probe</span><span class="p">(</span><span class="k">struct</span> <span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">ssam_controller</span><span class="w"> </span><span class="o">*</span><span class="n">ctrl</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">ctrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ssam_client_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ctrl</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ctrl</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="n">ENODEV</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">-</span><span class="nl">EPROBE_DEFER</span> <span class="p">:</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ctrl</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// ...</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The controller may be separately obtained via <a class="reference internal" href="client-api.html#c.ssam_get_controller" title="ssam_get_controller"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_get_controller()</span></code></a> and its
lifetime be guaranteed via <a class="reference internal" href="client-api.html#c.ssam_controller_get" title="ssam_controller_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_controller_get()</span></code></a> and <a class="reference internal" href="client-api.html#c.ssam_controller_put" title="ssam_controller_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_controller_put()</span></code></a>.
Note that none of these functions, however, guarantee that the controller
will not be shut down or suspended. These functions essentially only operate
on the reference, i.e. only guarantee a bare minimum of accessibility
without any guarantees at all on practical operability.</p>
</section>
<section id="adding-ssam-devices">
<h2>Adding SSAM Devices<a class="headerlink" href="#adding-ssam-devices" title="Permalink to this headline">¶</a></h2>
<p>If a device does not already exist/is not already provided via conventional
means, it should be provided as <a class="reference internal" href="client-api.html#c.ssam_device" title="ssam_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ssam_device</span></code></a> via the SSAM client device
hub. New devices can be added to this hub by entering their UID into the
corresponding registry. SSAM devices can also be manually allocated via
<a class="reference internal" href="client-api.html#c.ssam_device_alloc" title="ssam_device_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_device_alloc()</span></code></a>, subsequently to which they have to be added via
<a class="reference internal" href="client-api.html#c.ssam_device_add" title="ssam_device_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_device_add()</span></code></a> and eventually removed via <a class="reference internal" href="client-api.html#c.ssam_device_remove" title="ssam_device_remove"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_device_remove()</span></code></a>. By
default, the parent of the device is set to the controller device provided
for allocation, however this may be changed before the device is added. Note
that, when changing the parent device, care must be taken to ensure that the
controller lifetime and suspend/resume ordering guarantees, in the default
setup provided through the parent-child relation, are preserved. If
necessary, by use of <a class="reference internal" href="client-api.html#c.ssam_client_link" title="ssam_client_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_client_link()</span></code></a> as is done for non-SSAM client
drivers and described in more detail above.</p>
<p>A client device must always be removed by the party which added the
respective device before the controller shuts down. Such removal can be
guaranteed by linking the driver providing the SSAM device to the controller
via <a class="reference internal" href="client-api.html#c.ssam_client_link" title="ssam_client_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_client_link()</span></code></a>, causing it to unbind before the controller driver
unbinds. Client devices registered with the controller as parent are
automatically removed when the controller shuts down, but this should not be
relied upon, especially as this does not extend to client devices with a
different parent.</p>
</section>
<section id="ssam-client-drivers">
<h2>SSAM Client Drivers<a class="headerlink" href="#ssam-client-drivers" title="Permalink to this headline">¶</a></h2>
<p>SSAM client device drivers are, in essence, no different than other device
driver types. They are represented via <a class="reference internal" href="client-api.html#c.ssam_device_driver" title="ssam_device_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ssam_device_driver</span></code></a> and bind to a
<a class="reference internal" href="client-api.html#c.ssam_device" title="ssam_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ssam_device</span></code></a> via its UID (<a class="reference internal" href="client-api.html#c.ssam_device" title="ssam_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ssam_device.uid</span></code></a>)
member and the match table
(<a class="reference internal" href="client-api.html#c.ssam_device_driver" title="ssam_device_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ssam_device_driver.match_table</span></code></a>),
which should be set when declaring the driver struct instance. Refer to the
<a class="reference internal" href="client-api.html#c.SSAM_DEVICE" title="SSAM_DEVICE"><code class="xref c c-func docutils literal notranslate"><span class="pre">SSAM_DEVICE()</span></code></a> macro documentation for more details on how to define members
of the driver’s match table.</p>
<p>The UID for SSAM client devices consists of a <code class="docutils literal notranslate"><span class="pre">domain</span></code>, a <code class="docutils literal notranslate"><span class="pre">category</span></code>,
a <code class="docutils literal notranslate"><span class="pre">target</span></code>, an <code class="docutils literal notranslate"><span class="pre">instance</span></code>, and a <code class="docutils literal notranslate"><span class="pre">function</span></code>. The <code class="docutils literal notranslate"><span class="pre">domain</span></code> is used
differentiate between physical SAM devices
(<a class="reference internal" href="client-api.html#c.ssam_device_domain" title="ssam_device_domain"><code class="xref c c-type docutils literal notranslate"><span class="pre">SSAM_DOMAIN_SERIALHUB</span></code></a>), i.e. devices that can
be accessed via the Surface Serial Hub, and virtual ones
(<a class="reference internal" href="client-api.html#c.ssam_device_domain" title="ssam_device_domain"><code class="xref c c-type docutils literal notranslate"><span class="pre">SSAM_DOMAIN_VIRTUAL</span></code></a>), such as client-device
hubs, that have no real representation on the SAM EC and are solely used on
the kernel/driver-side. For physical devices, <code class="docutils literal notranslate"><span class="pre">category</span></code> represents the
target category, <code class="docutils literal notranslate"><span class="pre">target</span></code> the target ID, and <code class="docutils literal notranslate"><span class="pre">instance</span></code> the instance ID
used to access the physical SAM device. In addition, <code class="docutils literal notranslate"><span class="pre">function</span></code> references
a specific device functionality, but has no meaning to the SAM EC. The
(default) name of a client device is generated based on its UID.</p>
<p>A driver instance can be registered via <a class="reference internal" href="client-api.html#c.ssam_device_driver_register" title="ssam_device_driver_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_device_driver_register()</span></code></a> and
unregistered via <a class="reference internal" href="client-api.html#c.ssam_device_driver_unregister" title="ssam_device_driver_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_device_driver_unregister()</span></code></a>. For convenience, the
<a class="reference internal" href="client-api.html#c.module_ssam_device_driver" title="module_ssam_device_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_ssam_device_driver()</span></code></a> macro may be used to define module init- and
exit-functions registering the driver.</p>
<p>The controller associated with a SSAM client device can be found in its
<a class="reference internal" href="client-api.html#c.ssam_device" title="ssam_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ssam_device.ctrl</span></code></a> member. This reference is
guaranteed to be valid for at least as long as the client driver is bound,
but should also be valid for as long as the client device exists. Note,
however, that access outside of the bound client driver must ensure that the
controller device is not suspended while making any requests or
(un-)registering event notifiers (and thus should generally be avoided). This
is guaranteed when the controller is accessed from inside the bound client
driver.</p>
</section>
<section id="making-synchronous-requests">
<h2>Making Synchronous Requests<a class="headerlink" href="#making-synchronous-requests" title="Permalink to this headline">¶</a></h2>
<p>Synchronous requests are (currently) the main form of host-initiated
communication with the EC. There are a couple of ways to define and execute
such requests, however, most of them boil down to something similar as shown
in the example below. This example defines a write-read request, meaning
that the caller provides an argument to the SAM EC and receives a response.
The caller needs to know the (maximum) length of the response payload and
provide a buffer for it.</p>
<p>Care must be taken to ensure that any command payload data passed to the SAM
EC is provided in little-endian format and, similarly, any response payload
data received from it is converted from little-endian to host endianness.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">perform_request</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ssam_controller</span><span class="w"> </span><span class="o">*</span><span class="n">ctrl</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">ssam_request</span><span class="w"> </span><span class="n">rqst</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">ssam_response</span><span class="w"> </span><span class="n">resp</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Convert request argument to little-endian. */</span><span class="w"></span>
<span class="w">        </span><span class="n">__le32</span><span class="w"> </span><span class="n">arg_le</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">__le32</span><span class="w"> </span><span class="n">ret_le</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Initialize request specification. Replace this with your values.</span>
<span class="cm">         * The rqst.payload field may be NULL if rqst.length is zero,</span>
<span class="cm">         * indicating that the request does not have any argument.</span>
<span class="cm">         *</span>
<span class="cm">         * Note: The request parameters used here are not valid, i.e.</span>
<span class="cm">         *       they do not correspond to an actual SAM/EC request.</span>
<span class="cm">         */</span><span class="w"></span>
<span class="w">        </span><span class="n">rqst</span><span class="p">.</span><span class="n">target_category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SSAM_SSH_TC_SAM</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rqst</span><span class="p">.</span><span class="n">target_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rqst</span><span class="p">.</span><span class="n">command_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x02</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rqst</span><span class="p">.</span><span class="n">instance_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x03</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rqst</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SSAM_REQUEST_HAS_RESPONSE</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rqst</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arg_le</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">rqst</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">arg_le</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Initialize request response. */</span><span class="w"></span>
<span class="w">        </span><span class="n">resp</span><span class="p">.</span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ret_le</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">resp</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">resp</span><span class="p">.</span><span class="n">pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ret_le</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Perform actual request. The response pointer may be null in case</span>
<span class="cm">         * the request does not have any response. This must be consistent</span>
<span class="cm">         * with the SSAM_REQUEST_HAS_RESPONSE flag set in the specification</span>
<span class="cm">         * above.</span>
<span class="cm">         */</span><span class="w"></span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ssam_request_sync</span><span class="p">(</span><span class="n">ctrl</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rqst</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resp</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Alternatively use</span>
<span class="cm">         *</span>
<span class="cm">         *   ssam_request_sync_onstack(ctrl, &amp;rqst, &amp;resp, sizeof(arg_le));</span>
<span class="cm">         *</span>
<span class="cm">         * to perform the request, allocating the message buffer directly</span>
<span class="cm">         * on the stack as opposed to allocation via kzalloc().</span>
<span class="cm">         */</span><span class="w"></span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Convert request response back to native format. Note that in the</span>
<span class="cm">         * error case, this value is not touched by the SSAM core, i.e.</span>
<span class="cm">         * &#39;ret_le&#39; will be zero as specified in its initialization.</span>
<span class="cm">         */</span><span class="w"></span>
<span class="w">        </span><span class="o">*</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ret_le</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="client-api.html#c.ssam_request_sync" title="ssam_request_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_request_sync()</span></code></a> in its essence is a wrapper over lower-level
request primitives, which may also be used to perform requests. Refer to its
implementation and documentation for more details.</p>
<p>An arguably more user-friendly way of defining such functions is by using
one of the generator macros, for example via:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SSAM_DEFINE_SYNC_REQUEST_W</span><span class="p">(</span><span class="n">__ssam_tmp_perf_mode_set</span><span class="p">,</span><span class="w"> </span><span class="n">__le32</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">target_category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SSAM_SSH_TC_TMP</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">target_id</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">command_id</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mh">0x03</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">instance_id</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>This example defines a function</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">__ssam_tmp_perf_mode_set</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ssam_controller</span><span class="w"> </span><span class="o">*</span><span class="n">ctrl</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">__le32</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>executing the specified request, with the controller passed in when calling
said function. In this example, the argument is provided via the <code class="docutils literal notranslate"><span class="pre">arg</span></code>
pointer. Note that the generated function allocates the message buffer on
the stack. Thus, if the argument provided via the request is large, these
kinds of macros should be avoided. Also note that, in contrast to the
previous non-macro example, this function does not do any endianness
conversion, which has to be handled by the caller. Apart from those
differences the function generated by the macro is similar to the one
provided in the non-macro example above.</p>
<p>The full list of such function-generating macros is</p>
<ul class="simple">
<li><p><a class="reference internal" href="client-api.html#c.SSAM_DEFINE_SYNC_REQUEST_N" title="SSAM_DEFINE_SYNC_REQUEST_N"><code class="xref c c-func docutils literal notranslate"><span class="pre">SSAM_DEFINE_SYNC_REQUEST_N()</span></code></a> for requests without return value and
without argument.</p></li>
<li><p><a class="reference internal" href="client-api.html#c.SSAM_DEFINE_SYNC_REQUEST_R" title="SSAM_DEFINE_SYNC_REQUEST_R"><code class="xref c c-func docutils literal notranslate"><span class="pre">SSAM_DEFINE_SYNC_REQUEST_R()</span></code></a> for requests with return value but no
argument.</p></li>
<li><p><a class="reference internal" href="client-api.html#c.SSAM_DEFINE_SYNC_REQUEST_W" title="SSAM_DEFINE_SYNC_REQUEST_W"><code class="xref c c-func docutils literal notranslate"><span class="pre">SSAM_DEFINE_SYNC_REQUEST_W()</span></code></a> for requests without return value but
with argument.</p></li>
</ul>
<p>Refer to their respective documentation for more details. For each one of
these macros, a special variant is provided, which targets request types
applicable to multiple instances of the same device type:</p>
<ul class="simple">
<li><p><a class="reference internal" href="client-api.html#c.SSAM_DEFINE_SYNC_REQUEST_MD_N" title="SSAM_DEFINE_SYNC_REQUEST_MD_N"><code class="xref c c-func docutils literal notranslate"><span class="pre">SSAM_DEFINE_SYNC_REQUEST_MD_N()</span></code></a></p></li>
<li><p><a class="reference internal" href="client-api.html#c.SSAM_DEFINE_SYNC_REQUEST_MD_R" title="SSAM_DEFINE_SYNC_REQUEST_MD_R"><code class="xref c c-func docutils literal notranslate"><span class="pre">SSAM_DEFINE_SYNC_REQUEST_MD_R()</span></code></a></p></li>
<li><p><a class="reference internal" href="client-api.html#c.SSAM_DEFINE_SYNC_REQUEST_MD_W" title="SSAM_DEFINE_SYNC_REQUEST_MD_W"><code class="xref c c-func docutils literal notranslate"><span class="pre">SSAM_DEFINE_SYNC_REQUEST_MD_W()</span></code></a></p></li>
</ul>
<p>The difference of those macros to the previously mentioned versions is, that
the device target and instance IDs are not fixed for the generated function,
but instead have to be provided by the caller of said function.</p>
<p>Additionally, variants for direct use with client devices, i.e.
<a class="reference internal" href="client-api.html#c.ssam_device" title="ssam_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ssam_device</span></code></a>, are also provided. These can, for example, be used as
follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SSAM_DEFINE_SYNC_REQUEST_CL_R</span><span class="p">(</span><span class="n">ssam_bat_get_sta</span><span class="p">,</span><span class="w"> </span><span class="n">__le32</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">target_category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SSAM_SSH_TC_BAT</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">command_id</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>This invocation of the macro defines a function</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ssam_bat_get_sta</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ssam_device</span><span class="w"> </span><span class="o">*</span><span class="n">sdev</span><span class="p">,</span><span class="w"> </span><span class="n">__le32</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>executing the specified request, using the device IDs and controller given
in the client device. The full list of such macros for client devices is:</p>
<ul class="simple">
<li><p><a class="reference internal" href="client-api.html#c.SSAM_DEFINE_SYNC_REQUEST_CL_N" title="SSAM_DEFINE_SYNC_REQUEST_CL_N"><code class="xref c c-func docutils literal notranslate"><span class="pre">SSAM_DEFINE_SYNC_REQUEST_CL_N()</span></code></a></p></li>
<li><p><a class="reference internal" href="client-api.html#c.SSAM_DEFINE_SYNC_REQUEST_CL_R" title="SSAM_DEFINE_SYNC_REQUEST_CL_R"><code class="xref c c-func docutils literal notranslate"><span class="pre">SSAM_DEFINE_SYNC_REQUEST_CL_R()</span></code></a></p></li>
<li><p><a class="reference internal" href="client-api.html#c.SSAM_DEFINE_SYNC_REQUEST_CL_W" title="SSAM_DEFINE_SYNC_REQUEST_CL_W"><code class="xref c c-func docutils literal notranslate"><span class="pre">SSAM_DEFINE_SYNC_REQUEST_CL_W()</span></code></a></p></li>
</ul>
</section>
<section id="handling-events">
<h2>Handling Events<a class="headerlink" href="#handling-events" title="Permalink to this headline">¶</a></h2>
<p>To receive events from the SAM EC, an event notifier must be registered for
the desired event via <a class="reference internal" href="client-api.html#c.ssam_notifier_register" title="ssam_notifier_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_notifier_register()</span></code></a>. The notifier must be
unregistered via <a class="reference internal" href="client-api.html#c.ssam_notifier_unregister" title="ssam_notifier_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_notifier_unregister()</span></code></a> once it is not required any
more. For <a class="reference internal" href="client-api.html#c.ssam_device" title="ssam_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ssam_device</span></code></a> type clients, the <a class="reference internal" href="client-api.html#c.ssam_device_notifier_register" title="ssam_device_notifier_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_device_notifier_register()</span></code></a> and
<a class="reference internal" href="client-api.html#c.ssam_device_notifier_unregister" title="ssam_device_notifier_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">ssam_device_notifier_unregister()</span></code></a> wrappers should be preferred as they properly
handle hot-removal of client devices.</p>
<p>Event notifiers are registered by providing (at minimum) a callback to call
in case an event has been received, the registry specifying how the event
should be enabled, an event ID specifying for which target category and,
optionally and depending on the registry used, for which instance ID events
should be enabled, and finally, flags describing how the EC will send these
events. If the specific registry does not enable events by instance ID, the
instance ID must be set to zero. Additionally, a priority for the respective
notifier may be specified, which determines its order in relation to any
other notifier registered for the same target category.</p>
<p>By default, event notifiers will receive all events for the specific target
category, regardless of the instance ID specified when registering the
notifier. The core may be instructed to only call a notifier if the target
ID or instance ID (or both) of the event match the ones implied by the
notifier IDs (in case of target ID, the target ID of the registry), by
providing an event mask (see <a class="reference internal" href="client-api.html#c.ssam_event_mask" title="ssam_event_mask"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ssam_event_mask</span></code></a>).</p>
<p>In general, the target ID of the registry is also the target ID of the
enabled event (with the notable exception being keyboard input events on the
Surface Laptop 1 and 2, which are enabled via a registry with target ID 1,
but provide events with target ID 2).</p>
<p>A full example for registering an event notifier and handling received
events is provided below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">u32</span><span class="w"> </span><span class="nf">notifier_callback</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ssam_event_notifier</span><span class="w"> </span><span class="o">*</span><span class="n">nf</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">ssam_event</span><span class="w"> </span><span class="o">*</span><span class="n">event</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Handle the event here ... */</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Convert return value and indicate that we handled the event. */</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ssam_notifier_from_errno</span><span class="p">(</span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SSAM_NOTIF_HANDLED</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">setup_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="nc">ssam_device</span><span class="w"> </span><span class="o">*</span><span class="n">sdev</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="k">struct</span> <span class="nc">ssam_event_notifier</span><span class="w"> </span><span class="o">*</span><span class="n">nf</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* Set priority wrt. other handlers of same target category. */</span><span class="w"></span>
<span class="w">        </span><span class="n">nf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Set event/notifier callback. */</span><span class="w"></span>
<span class="w">        </span><span class="n">nf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">notifier_callback</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Specify event registry, i.e. how events get enabled/disabled. */</span><span class="w"></span>
<span class="w">        </span><span class="n">nf</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SSAM_EVENT_REGISTRY_KIP</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Specify which event to enable/disable */</span><span class="w"></span>
<span class="w">        </span><span class="n">nf</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">target_category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">category</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">nf</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Specify for which events the notifier callback gets executed.</span>
<span class="cm">         * This essentially tells the core if it can skip notifiers that</span>
<span class="cm">         * don&#39;t have target or instance IDs matching those of the event.</span>
<span class="cm">         */</span><span class="w"></span>
<span class="w">        </span><span class="n">nf</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SSAM_EVENT_MASK_STRICT</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Specify event flags. */</span><span class="w"></span>
<span class="w">        </span><span class="n">nf</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SSAM_EVENT_SEQUENCED</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ssam_notifier_register</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">,</span><span class="w"> </span><span class="n">nf</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Multiple event notifiers can be registered for the same event. The event
handler core takes care of enabling and disabling events when notifiers are
registered and unregistered, by keeping track of how many notifiers for a
specific event (combination of registry, event target category, and event
instance ID) are currently registered. This means that a specific event will
be enabled when the first notifier for it is being registered and disabled
when the last notifier for it is being unregistered. Note that the event
flags are therefore only used on the first registered notifier, however, one
should take care that notifiers for a specific event are always registered
with the same flag and it is considered a bug to do otherwise.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Writing Client Drivers</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#non-ssam-client-drivers">Non-SSAM Client Drivers</a></li>
<li><a class="reference internal" href="#adding-ssam-devices">Adding SSAM Devices</a></li>
<li><a class="reference internal" href="#ssam-client-drivers">SSAM Client Drivers</a></li>
<li><a class="reference internal" href="#making-synchronous-requests">Making Synchronous Requests</a></li>
<li><a class="reference internal" href="#handling-events">Handling Events</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/surface_aggregator/client.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/surface_aggregator/client.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>