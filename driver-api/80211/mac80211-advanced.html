
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>mac80211 subsystem (advanced) &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="The Userspace I/O HOWTO" href="../uio-howto.html" />
    <link rel="prev" title="mac80211 subsystem (basics)" href="mac80211.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="mac80211-subsystem-advanced">
<h1>mac80211 subsystem (advanced)<a class="headerlink" href="#mac80211-subsystem-advanced" title="Permalink to this headline">¶</a></h1>
<p>Information contained within this part of the book is of interest only
for advanced interaction of mac80211 with drivers to exploit more
hardware capabilities and improve performance.</p>
<section id="led-support">
<h2>LED support<a class="headerlink" href="#led-support" title="Permalink to this headline">¶</a></h2>
<p>Mac80211 supports various ways of blinking LEDs. Wherever possible,
device LEDs should be exposed as LED class devices and hooked up to the
appropriate trigger, which will then be triggered appropriately by
mac80211.</p>
<dl class="type">
<dt id="c.ieee80211_tpt_blink">
struct <code class="sig-name descname">ieee80211_tpt_blink</code><a class="headerlink" href="#c.ieee80211_tpt_blink" title="Permalink to this definition">¶</a></dt>
<dd><p>throughput blink description</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_tpt_blink {
    int throughput;
    int blink_time;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">throughput</span></code></dt><dd><p>throughput in Kbit/sec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">blink_time</span></code></dt><dd><p>blink time in milliseconds
(full cycle, ie. one off + one on period)</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.ieee80211_tpt_led_trigger_flags">
enum <code class="sig-name descname">ieee80211_tpt_led_trigger_flags</code><a class="headerlink" href="#c.ieee80211_tpt_led_trigger_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>throughput trigger flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TPT_LEDTRIG_FL_RADIO</span></code></dt><dd><p>enable blinking with radio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TPT_LEDTRIG_FL_WORK</span></code></dt><dd><p>enable blinking when working</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_TPT_LEDTRIG_FL_CONNECTED</span></code></dt><dd><p>enable blinking when at least one
interface is connected in some way, including being an AP</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ieee80211_get_tx_led_name">
const char * <code class="sig-name descname">ieee80211_get_tx_led_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_tx_led_name" title="Permalink to this definition">¶</a></dt>
<dd><p>get name of TX LED</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware to get the LED trigger name for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>mac80211 creates a transmit LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not configured for LEDs)
of the trigger so you can automatically link the LED device.</p>
<p><strong>Return</strong></p>
<p>The name of the LED trigger. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not configured for LEDs.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_get_rx_led_name">
const char * <code class="sig-name descname">ieee80211_get_rx_led_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_rx_led_name" title="Permalink to this definition">¶</a></dt>
<dd><p>get name of RX LED</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware to get the LED trigger name for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>mac80211 creates a receive LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not configured for LEDs)
of the trigger so you can automatically link the LED device.</p>
<p><strong>Return</strong></p>
<p>The name of the LED trigger. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not configured for LEDs.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_get_assoc_led_name">
const char * <code class="sig-name descname">ieee80211_get_assoc_led_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_assoc_led_name" title="Permalink to this definition">¶</a></dt>
<dd><p>get name of association LED</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware to get the LED trigger name for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>mac80211 creates a association LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not configured for LEDs)
of the trigger so you can automatically link the LED device.</p>
<p><strong>Return</strong></p>
<p>The name of the LED trigger. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not configured for LEDs.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_get_radio_led_name">
const char * <code class="sig-name descname">ieee80211_get_radio_led_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_radio_led_name" title="Permalink to this definition">¶</a></dt>
<dd><p>get name of radio LED</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware to get the LED trigger name for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>mac80211 creates a radio change LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not configured for LEDs)
of the trigger so you can automatically link the LED device.</p>
<p><strong>Return</strong></p>
<p>The name of the LED trigger. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not configured for LEDs.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_create_tpt_led_trigger">
const char * <code class="sig-name descname">ieee80211_create_tpt_led_trigger</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em>, unsigned int<em> flags</em>, const struct <a class="reference internal" href="#c.ieee80211_tpt_blink" title="ieee80211_tpt_blink">ieee80211_tpt_blink</a><em> *blink_table</em>, unsigned int<em> blink_table_len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_create_tpt_led_trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>create throughput LED trigger</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware to create the trigger for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>trigger flags, see <a class="reference internal" href="#c.ieee80211_tpt_led_trigger_flags" title="ieee80211_tpt_led_trigger_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_tpt_led_trigger_flags</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ieee80211_tpt_blink</span> <span class="pre">*blink_table</span></code></dt><dd><p>the blink table – needs to be ordered by throughput</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">blink_table_len</span></code></dt><dd><p>size of the blink table</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> (in case of error, or if no LED triggers are
configured) or the name of the new trigger.</p>
<p><strong>Note</strong></p>
<p>This function must be called before <a class="reference internal" href="mac80211.html#c.ieee80211_register_hw" title="ieee80211_register_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_register_hw()</span></code></a>.</p>
</div>
</section>
<section id="hardware-crypto-acceleration">
<h2>Hardware crypto acceleration<a class="headerlink" href="#hardware-crypto-acceleration" title="Permalink to this headline">¶</a></h2>
<p>mac80211 is capable of taking advantage of many hardware
acceleration designs for encryption and decryption operations.</p>
<p>The set_key() callback in the <a class="reference internal" href="mac80211.html#c.ieee80211_ops" title="ieee80211_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_ops</span></code></a> for a given
device is called to enable hardware acceleration of encryption and
decryption. The callback takes a <strong>sta</strong> parameter that will be NULL
for default keys or keys used for transmission only, or point to
the station information for the peer for individual keys.
Multiple transmission keys with the same key index may be used when
VLANs are configured for an access point.</p>
<p>When transmitting, the TX control data will use the <strong>hw_key_idx</strong>
selected by the driver by modifying the <a class="reference internal" href="#c.ieee80211_key_conf" title="ieee80211_key_conf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_key_conf</span></code></a>
pointed to by the <strong>key</strong> parameter to the set_key() function.</p>
<p>The set_key() call for the <code class="docutils literal notranslate"><span class="pre">SET_KEY</span></code> command should return 0 if
the key is now in use, -<code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code> or -<code class="docutils literal notranslate"><span class="pre">ENOSPC</span></code> if it couldn’t be
added; if you return 0 then hw_key_idx must be assigned to the
hardware key index, you are free to use the full u8 range.</p>
<p>Note that in the case that the <strong>IEEE80211_HW_SW_CRYPTO_CONTROL</strong> flag is
set, mac80211 will not automatically fall back to software crypto if
enabling hardware crypto failed. The set_key() call may also return the
value 1 to permit this specific key/algorithm to be done in software.</p>
<p>When the cmd is <code class="docutils literal notranslate"><span class="pre">DISABLE_KEY</span></code> then it must succeed.</p>
<p>Note that it is permissible to not decrypt a frame even if a key
for it has been uploaded to hardware, the stack will not make any
decision based on whether a key has been uploaded or not but rather
based on the receive flags.</p>
<p>The <a class="reference internal" href="#c.ieee80211_key_conf" title="ieee80211_key_conf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_key_conf</span></code></a> structure pointed to by the <strong>key</strong>
parameter is guaranteed to be valid until another call to set_key()
removes it, but it can only be used as a cookie to differentiate
keys.</p>
<p>In TKIP some HW need to be provided a phase 1 key, for RX decryption
acceleration (i.e. iwlwifi). Those drivers should provide update_tkip_key
handler.
The update_tkip_key() call updates the driver with the new phase 1 key.
This happens every time the iv16 wraps around (every 65536 packets). The
set_key() call will happen only once for each key (unless the AP did
rekeying), it will not include a valid phase 1 key. The valid phase 1 key is
provided by update_tkip_key only. The trigger that makes mac80211 call this
handler is software decryption with wrap around of iv16.</p>
<p>The set_default_unicast_key() call updates the default WEP key index
configured to the hardware for WEP encryption type. This is required
for devices that support offload of data packets (e.g. ARP responses).</p>
<p>Mac80211 drivers should set the <strong>NL80211_EXT_FEATURE_CAN_REPLACE_PTK0</strong> flag
when they are able to replace in-use PTK keys according to the following
requirements:
1) They do not hand over frames decrypted with the old key to mac80211</p>
<dl class="type">
<dt id="c.ieee80211_key_flags">
enum <code class="sig-name descname">ieee80211_key_flags</code><a class="headerlink" href="#c.ieee80211_key_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>key flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_GENERATE_IV_MGMT</span></code></dt><dd><p>This flag should be set by the
driver for a CCMP/GCMP key to indicate that is requires IV generation
only for management frames (MFP).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_GENERATE_IV</span></code></dt><dd><p>This flag should be set by the
driver to indicate that it requires IV generation for this
particular key. Setting this flag does not necessarily mean that SKBs
will have sufficient tailroom for ICV or MIC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_GENERATE_MMIC</span></code></dt><dd><p>This flag should be set by
the driver for a TKIP key if it requires Michael MIC
generation in software.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_PAIRWISE</span></code></dt><dd><p>Set by mac80211, this flag indicates
that the key is pairwise rather then a shared key.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_SW_MGMT_TX</span></code></dt><dd><p>This flag should be set by the driver for a
CCMP/GCMP key if it requires CCMP/GCMP encryption of management frames
(MFP) to be done in software.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_PUT_IV_SPACE</span></code></dt><dd><p>This flag should be set by the driver
if space should be prepared for the IV, but the IV
itself should not be generated. Do not set together with
<strong>IEEE80211_KEY_FLAG_GENERATE_IV</strong> on the same key. Setting this flag does
not necessarily mean that SKBs will have sufficient tailroom for ICV or
MIC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_RX_MGMT</span></code></dt><dd><p>This key will be used to decrypt received
management frames. The flag can help drivers that have a hardware
crypto implementation that doesn’t deal with management frames
properly by allowing them to not upload the keys to hardware and
fall back to software crypto. Note that this flag deals only with
RX, if your crypto engine can’t deal with TX you can also set the
<code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_SW_MGMT_TX</span></code> flag to encrypt such frames in SW.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_RESERVE_TAILROOM</span></code></dt><dd><p>This flag should be set by the
driver for a key to indicate that sufficient tailroom must always
be reserved for ICV or MIC, even when HW encryption is enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_PUT_MIC_SPACE</span></code></dt><dd><p>This flag should be set by the driver for
a TKIP key if it only requires MIC space. Do not set together with
<strong>IEEE80211_KEY_FLAG_GENERATE_MMIC</strong> on the same key.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_NO_AUTO_TX</span></code></dt><dd><p>Key needs explicit Tx activation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_KEY_FLAG_GENERATE_MMIE</span></code></dt><dd><p>This flag should be set by the driver
for a AES_CMAC key to indicate that it requires sequence number
generation only</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These flags are used for communication about keys between the driver
and mac80211, with the <strong>flags</strong> parameter of <a class="reference internal" href="#c.ieee80211_key_conf" title="ieee80211_key_conf"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_key_conf</span></code></a>.</p>
<dl class="type">
<dt id="c.ieee80211_key_conf">
struct <code class="sig-name descname">ieee80211_key_conf</code><a class="headerlink" href="#c.ieee80211_key_conf" title="Permalink to this definition">¶</a></dt>
<dd><p>key information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_key_conf {
    atomic64_t tx_pn;
    u32 cipher;
    u8 icv_len;
    u8 iv_len;
    u8 hw_key_idx;
    s8 keyidx;
    u16 flags;
    s8 link_id;
    u8 keylen;
    u8 key[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tx_pn</span></code></dt><dd><p>PN used for TX keys, may be used by the driver as well if it
needs to do software PN assignment by itself (e.g. due to TSO)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cipher</span></code></dt><dd><p>The key’s cipher suite selector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">icv_len</span></code></dt><dd><p>The ICV length for this key type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">iv_len</span></code></dt><dd><p>The IV length for this key type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_key_idx</span></code></dt><dd><p>To be set by the driver, this is the key index the driver
wants to be given when a frame is transmitted and needs to be
encrypted in hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keyidx</span></code></dt><dd><p>the key index (0-3)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>key flags, see <a class="reference internal" href="#c.ieee80211_key_flags" title="ieee80211_key_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_key_flags</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_id</span></code></dt><dd><p>the link ID for MLO, or -1 for non-MLO or pairwise keys</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">keylen</span></code></dt><dd><p>key material length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>key material. For ALG_TKIP the key is encoded as a 256-bit (32 byte)
data block:
- Temporal Encryption Key (128 bits)
- Temporal Authenticator Tx MIC Key (64 bits)
- Temporal Authenticator Rx MIC Key (64 bits)</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This key information is given by mac80211 to the driver by
the set_key() callback in <a class="reference internal" href="mac80211.html#c.ieee80211_ops" title="ieee80211_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_ops</span></code></a>.</p>
<dl class="type">
<dt id="c.set_key_cmd">
enum <code class="sig-name descname">set_key_cmd</code><a class="headerlink" href="#c.set_key_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>key command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SET_KEY</span></code></dt><dd><p>a key is set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DISABLE_KEY</span></code></dt><dd><p>a key must be disabled</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Used with the set_key() callback in <a class="reference internal" href="mac80211.html#c.ieee80211_ops" title="ieee80211_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_ops</span></code></a>, this
indicates whether a key is being removed or added.</p>
<dl class="function">
<dt id="c.ieee80211_get_tkip_p1k_iv">
void <code class="sig-name descname">ieee80211_get_tkip_p1k_iv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ieee80211_key_conf" title="ieee80211_key_conf">ieee80211_key_conf</a><em> *keyconf</em>, u32<em> iv32</em>, u16<em> *p1k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_tkip_p1k_iv" title="Permalink to this definition">¶</a></dt>
<dd><p>get a TKIP phase 1 key for IV32</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_key_conf</span> <span class="pre">*keyconf</span></code></dt><dd><p>the parameter passed with the set key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">iv32</span></code></dt><dd><p>IV32 to get the P1K for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*p1k</span></code></dt><dd><p>a buffer to which the key will be written, as 5 u16 values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the TKIP phase 1 key for the given IV32.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_get_tkip_p1k">
void <code class="sig-name descname">ieee80211_get_tkip_p1k</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ieee80211_key_conf" title="ieee80211_key_conf">ieee80211_key_conf</a><em> *keyconf</em>, struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, u16<em> *p1k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_tkip_p1k" title="Permalink to this definition">¶</a></dt>
<dd><p>get a TKIP phase 1 key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_key_conf</span> <span class="pre">*keyconf</span></code></dt><dd><p>the parameter passed with the set key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the packet to take the IV32 value from that will be encrypted
with this P1K</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">*p1k</span></code></dt><dd><p>a buffer to which the key will be written, as 5 u16 values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the TKIP phase 1 key for the IV32 taken
from the given packet.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_get_tkip_p2k">
void <code class="sig-name descname">ieee80211_get_tkip_p2k</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ieee80211_key_conf" title="ieee80211_key_conf">ieee80211_key_conf</a><em> *keyconf</em>, struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, u8<em> *p2k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_tkip_p2k" title="Permalink to this definition">¶</a></dt>
<dd><p>get a TKIP phase 2 key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_key_conf</span> <span class="pre">*keyconf</span></code></dt><dd><p>the parameter passed with the set key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the packet to take the IV32/IV16 values from that will be
encrypted with this key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*p2k</span></code></dt><dd><p>a buffer to which the key will be written, 16 bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function computes the TKIP RC4 key for the IV values
in the packet.</p>
</div>
</section>
<section id="powersave-support">
<h2>Powersave support<a class="headerlink" href="#powersave-support" title="Permalink to this headline">¶</a></h2>
<p>mac80211 has support for various powersave implementations.</p>
<p>First, it can support hardware that handles all powersaving by itself,
such hardware should simply set the <code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_PS</span></code> hardware
flag. In that case, it will be told about the desired powersave mode
with the <code class="docutils literal notranslate"><span class="pre">IEEE80211_CONF_PS</span></code> flag depending on the association status.
The hardware must take care of sending nullfunc frames when necessary,
i.e. when entering and leaving powersave mode. The hardware is required
to look at the AID in beacons and signal to the AP that it woke up when
it finds traffic directed to it.</p>
<p><code class="docutils literal notranslate"><span class="pre">IEEE80211_CONF_PS</span></code> flag enabled means that the powersave mode defined in
IEEE 802.11-2007 section 11.2 is enabled. This is not to be confused
with hardware wakeup and sleep states. Driver is responsible for waking
up the hardware before issuing commands to the hardware and putting it
back to sleep at appropriate times.</p>
<p>When PS is enabled, hardware needs to wakeup for beacons and receive the
buffered multicast/broadcast frames after the beacon. Also it must be
possible to send frames and receive the acknowledment frame.</p>
<p>Other hardware designs cannot send nullfunc frames by themselves and also
need software support for parsing the TIM bitmap. This is also supported
by mac80211 by combining the <code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_PS</span></code> and
<code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_PS_NULLFUNC_STACK</span></code> flags. The hardware is of course still
required to pass up beacons. The hardware is still required to handle
waking up for multicast traffic; if it cannot the driver must handle that
as best as it can, mac80211 is too slow to do that.</p>
<p>Dynamic powersave is an extension to normal powersave in which the
hardware stays awake for a user-specified period of time after sending a
frame so that reply frames need not be buffered and therefore delayed to
the next wakeup. It’s compromise of getting good enough latency when
there’s data traffic and still saving significantly power in idle
periods.</p>
<p>Dynamic powersave is simply supported by mac80211 enabling and disabling
PS based on traffic. Driver needs to only set <code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_PS</span></code>
flag and mac80211 will handle everything automatically. Additionally,
hardware having support for the dynamic PS feature may set the
<code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_SUPPORTS_DYNAMIC_PS</span></code> flag to indicate that it can support
dynamic PS mode itself. The driver needs to look at the
<strong>dynamic_ps_timeout</strong> hardware configuration value and use it that value
whenever <code class="docutils literal notranslate"><span class="pre">IEEE80211_CONF_PS</span></code> is set. In this case mac80211 will disable
dynamic PS feature in stack and will just keep <code class="docutils literal notranslate"><span class="pre">IEEE80211_CONF_PS</span></code>
enabled whenever user has enabled powersave.</p>
<p>Driver informs U-APSD client support by enabling
<code class="docutils literal notranslate"><span class="pre">IEEE80211_VIF_SUPPORTS_UAPSD</span></code> flag. The mode is configured through the
uapsd parameter in conf_tx() operation. Hardware needs to send the QoS
Nullfunc frames and stay awake until the service period has ended. To
utilize U-APSD, dynamic powersave is disabled for voip AC and all frames
from that AC are transmitted with powersave enabled.</p>
<p>Note: U-APSD client mode is not yet supported with
<code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_PS_NULLFUNC_STACK</span></code>.</p>
</section>
<section id="beacon-filter-support">
<h2>Beacon filter support<a class="headerlink" href="#beacon-filter-support" title="Permalink to this headline">¶</a></h2>
<p>Some hardware have beacon filter support to reduce host cpu wakeups
which will reduce system power consumption. It usually works so that
the firmware creates a checksum of the beacon but omits all constantly
changing elements (TSF, TIM etc). Whenever the checksum changes the
beacon is forwarded to the host, otherwise it will be just dropped. That
way the host will only receive beacons where some relevant information
(for example ERP protection or WMM settings) have changed.</p>
<p>Beacon filter support is advertised with the <code class="docutils literal notranslate"><span class="pre">IEEE80211_VIF_BEACON_FILTER</span></code>
interface capability. The driver needs to enable beacon filter support
whenever power save is enabled, that is <code class="docutils literal notranslate"><span class="pre">IEEE80211_CONF_PS</span></code> is set. When
power save is enabled, the stack will not check for beacon loss and the
driver needs to notify about loss of beacons with <a class="reference internal" href="#c.ieee80211_beacon_loss" title="ieee80211_beacon_loss"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_beacon_loss()</span></code></a>.</p>
<p>The time (or number of beacons missed) until the firmware notifies the
driver of a beacon loss event (which in turn causes the driver to call
<a class="reference internal" href="#c.ieee80211_beacon_loss" title="ieee80211_beacon_loss"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_beacon_loss()</span></code></a>) should be configurable and will be controlled
by mac80211 and the roaming algorithm in the future.</p>
<p>Since there may be constantly changing information elements that nothing
in the software stack cares about, we will, in the future, have mac80211
tell the driver which information elements are interesting in the sense
that we want to see changes in them. This will include</p>
<blockquote>
<div><ul class="simple">
<li><p>a list of information element IDs</p></li>
<li><p>a list of OUIs for the vendor information element</p></li>
</ul>
</div></blockquote>
<p>Ideally, the hardware would filter out any beacons without changes in the
requested elements, but if it cannot support that it may, at the expense
of some efficiency, filter out only a subset. For example, if the device
doesn’t support checking for OUIs it should pass up all changes in all
vendor information elements.</p>
<p>Note that change, for the sake of simplification, also includes information
elements appearing or disappearing from the beacon.</p>
<p>Some hardware supports an “ignore list” instead, just make sure nothing
that was requested is on the ignore list, and include commonly changing
information element IDs in the ignore list, for example 11 (BSS load) and
the various vendor-assigned IEs with unknown contents (128, 129, 133-136,
149, 150, 155, 156, 173, 176, 178, 179, 219); for forward compatibility
it could also include some currently unused IDs.</p>
<p>In addition to these capabilities, hardware should support notifying the
host of changes in the beacon RSSI. This is relevant to implement roaming
when no traffic is flowing (when traffic is flowing we see the RSSI of
the received data packets). This can consist in notifying the host when
the RSSI changes significantly or when it drops below or rises above
configurable thresholds. In the future these thresholds will also be
configured by mac80211 (which gets them from userspace) to implement
them as the roaming algorithm requires.</p>
<p>If the hardware cannot implement this, the driver should ask it to
periodically pass beacon frames to the host so that software can do the
signal strength threshold checking.</p>
<dl class="function">
<dt id="c.ieee80211_beacon_loss">
void <code class="sig-name descname">ieee80211_beacon_loss</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a><em> *vif</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_beacon_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>inform hardware does not receive beacons</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p><a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a> pointer from the add_interface callback.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When beacon filtering is enabled with <code class="docutils literal notranslate"><span class="pre">IEEE80211_VIF_BEACON_FILTER</span></code> and
<code class="docutils literal notranslate"><span class="pre">IEEE80211_CONF_PS</span></code> is set, the driver needs to inform whenever the
hardware is not receiving beacons with this function.</p>
</div>
</section>
<section id="multiple-queues-and-qos-support">
<h2>Multiple queues and QoS support<a class="headerlink" href="#multiple-queues-and-qos-support" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
<dl class="type">
<dt id="c.ieee80211_tx_queue_params">
struct <code class="sig-name descname">ieee80211_tx_queue_params</code><a class="headerlink" href="#c.ieee80211_tx_queue_params" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit queue configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_tx_queue_params {
    u16 txop;
    u16 cw_min;
    u16 cw_max;
    u8 aifs;
    bool acm;
    bool uapsd;
    bool mu_edca;
    struct ieee80211_he_mu_edca_param_ac_rec mu_edca_param_rec;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">txop</span></code></dt><dd><p>maximum burst time in units of 32 usecs, 0 meaning disabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cw_min</span></code></dt><dd><p>minimum contention window [a value of the form
2^n-1 in the range 1..32767]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cw_max</span></code></dt><dd><p>maximum contention window [like <strong>cw_min</strong>]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aifs</span></code></dt><dd><p>arbitration interframe space [0..255]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">acm</span></code></dt><dd><p>is mandatory admission control required for the access category</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uapsd</span></code></dt><dd><p>is U-APSD mode enabled for the queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mu_edca</span></code></dt><dd><p>is the MU EDCA configured</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mu_edca_param_rec</span></code></dt><dd><p>MU EDCA Parameter Record for HE</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The information provided in this structure is required for QoS
transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.</p>
</section>
<section id="access-point-mode-support">
<h2>Access point mode support<a class="headerlink" href="#access-point-mode-support" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
<p>Some parts of the if_conf should be discussed here instead</p>
<p>Insert notes about VLAN interfaces with hw crypto here or in the hw
crypto chapter.</p>
<section id="support-for-powersaving-clients">
<h3>support for powersaving clients<a class="headerlink" href="#support-for-powersaving-clients" title="Permalink to this headline">¶</a></h3>
<p>In order to implement AP and P2P GO modes, mac80211 has support for
client powersaving, both “legacy” PS (PS-Poll/null data) and uAPSD.
There currently is no support for sAPSD.</p>
<p>There is one assumption that mac80211 makes, namely that a client
will not poll with PS-Poll and trigger with uAPSD at the same time.
Both are supported, and both can be used by the same client, but
they can’t be used concurrently by the same client. This simplifies
the driver code.</p>
<p>The first thing to keep in mind is that there is a flag for complete
driver implementation: <code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_AP_LINK_PS</span></code>. If this flag is set,
mac80211 expects the driver to handle most of the state machine for
powersaving clients and will ignore the PM bit in incoming frames.
Drivers then use <a class="reference internal" href="#c.ieee80211_sta_ps_transition" title="ieee80211_sta_ps_transition"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_sta_ps_transition()</span></code></a> to inform mac80211 of
stations’ powersave transitions. In this mode, mac80211 also doesn’t
handle PS-Poll/uAPSD.</p>
<p>In the mode without <code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_AP_LINK_PS</span></code>, mac80211 will check the
PM bit in incoming frames for client powersave transitions. When a
station goes to sleep, we will stop transmitting to it. There is,
however, a race condition: a station might go to sleep while there is
data buffered on hardware queues. If the device has support for this
it will reject frames, and the driver should give the frames back to
mac80211 with the <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STAT_TX_FILTERED</span></code> flag set which will
cause mac80211 to retry the frame when the station wakes up. The
driver is also notified of powersave transitions by calling its
<strong>sta_notify</strong> callback.</p>
<p>When the station is asleep, it has three choices: it can wake up,
it can PS-Poll, or it can possibly start a uAPSD service period.
Waking up is implemented by simply transmitting all buffered (and
filtered) frames to the station. This is the easiest case. When
the station sends a PS-Poll or a uAPSD trigger frame, mac80211
will inform the driver of this with the <strong>allow_buffered_frames</strong>
callback; this callback is optional. mac80211 will then transmit
the frames as usual and set the <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_NO_PS_BUFFER</span></code>
on each frame. The last frame in the service period (or the only
response to a PS-Poll) also has <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STATUS_EOSP</span></code> set to
indicate that it ends the service period; as this frame must have
TX status report it also sets <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_REQ_TX_STATUS</span></code>.
When TX status is reported for this frame, the service period is
marked has having ended and a new one can be started by the peer.</p>
<p>Additionally, non-bufferable MMPDUs can also be transmitted by
mac80211 with the <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_CTL_NO_PS_BUFFER</span></code> set in them.</p>
<p>Another race condition can happen on some devices like iwlwifi
when there are frames queued for the station and it wakes up
or polls; the frames that are already queued could end up being
transmitted first instead, causing reordering and/or wrong
processing of the EOSP. The cause is that allowing frames to be
transmitted to a certain station is out-of-band communication to
the device. To allow this problem to be solved, the driver can
call <a class="reference internal" href="#c.ieee80211_sta_block_awake" title="ieee80211_sta_block_awake"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_sta_block_awake()</span></code></a> if frames are buffered when it
is notified that the station went to sleep. When all these frames
have been filtered (see above), it must call the function again
to indicate that the station is no longer blocked.</p>
<p>If the driver buffers frames in the driver for aggregation in any
way, it must use the <a class="reference internal" href="#c.ieee80211_sta_set_buffered" title="ieee80211_sta_set_buffered"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_sta_set_buffered()</span></code></a> call when it is
notified of the station going to sleep to inform mac80211 of any
TIDs that have frames buffered. Note that when a station wakes up
this information is reset (hence the requirement to call it when
informed of the station going to sleep). Then, when a service
period starts for any reason, <strong>release_buffered_frames</strong> is called
with the number of frames to be released and which TIDs they are
to come from. In this case, the driver is responsible for setting
the EOSP (for uAPSD) and MORE_DATA bits in the released frames,
to help the <strong>more_data</strong> parameter is passed to tell the driver if
there is more data on other TIDs – the TIDs to release frames
from are ignored since mac80211 doesn’t know how many frames the
buffers for those TIDs contain.</p>
<p>If the driver also implement GO mode, where absence periods may
shorten service periods (or abort PS-Poll responses), it must
filter those response frames except in the case of frames that
are buffered in the driver – those must remain buffered to avoid
reordering. Because it is possible that no frames are released
in this case, the driver must call <a class="reference internal" href="#c.ieee80211_sta_eosp" title="ieee80211_sta_eosp"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_sta_eosp()</span></code></a>
to indicate to mac80211 that the service period ended anyway.</p>
<p>Finally, if frames from multiple TIDs are released from mac80211
but the driver might reorder them, it must clear &amp; set the flags
appropriately (only the last frame may have <code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STATUS_EOSP</span></code>)
and also take care of the EOSP and MORE_DATA bits in the frame.
The driver may also use <a class="reference internal" href="#c.ieee80211_sta_eosp" title="ieee80211_sta_eosp"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_sta_eosp()</span></code></a> in this case.</p>
<p>Note that if the driver ever buffers frames other than QoS-data
frames, it must take care to never send a non-QoS-data frame as
the last frame in a service period, adding a QoS-nulldata frame
after a non-QoS-data frame if needed.</p>
<dl class="type">
<dt id="c.ieee80211_frame_release_type">
enum <code class="sig-name descname">ieee80211_frame_release_type</code><a class="headerlink" href="#c.ieee80211_frame_release_type" title="Permalink to this definition">¶</a></dt>
<dd><p>frame release reason</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_FRAME_RELEASE_PSPOLL</span></code></dt><dd><p>frame released for PS-Poll</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_FRAME_RELEASE_UAPSD</span></code></dt><dd><p>frame(s) released due to
frame received on trigger-enabled AC</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ieee80211_sta_ps_transition">
int <code class="sig-name descname">ieee80211_sta_ps_transition</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ieee80211_sta" title="ieee80211_sta">ieee80211_sta</a><em> *sta</em>, bool<em> start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_sta_ps_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>PS transition for connected sta</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_sta</span> <span class="pre">*sta</span></code></dt><dd><p>currently connected sta</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">start</span></code></dt><dd><p>start or stop PS</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When operating in AP mode with the <code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_AP_LINK_PS</span></code>
flag set, use this function to inform mac80211 about a connected station
entering/leaving PS mode.</p>
<p>This function may not be called in IRQ context or with softirqs enabled.</p>
<p>Calls to this function for a single hardware must be synchronized against
each other.</p>
<p><strong>Return</strong></p>
<p>0 on success. -EINVAL when the requested PS mode is already set.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_sta_ps_transition_ni">
int <code class="sig-name descname">ieee80211_sta_ps_transition_ni</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ieee80211_sta" title="ieee80211_sta">ieee80211_sta</a><em> *sta</em>, bool<em> start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_sta_ps_transition_ni" title="Permalink to this definition">¶</a></dt>
<dd><p>PS transition for connected sta (in process context)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_sta</span> <span class="pre">*sta</span></code></dt><dd><p>currently connected sta</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">start</span></code></dt><dd><p>start or stop PS</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.ieee80211_sta_ps_transition" title="ieee80211_sta_ps_transition"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_sta_ps_transition()</span></code></a> but can be called in process context
(internally disables bottom halves). Concurrent call restriction still
applies.</p>
<p><strong>Return</strong></p>
<p>Like <a class="reference internal" href="#c.ieee80211_sta_ps_transition" title="ieee80211_sta_ps_transition"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_sta_ps_transition()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_sta_set_buffered">
void <code class="sig-name descname">ieee80211_sta_set_buffered</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ieee80211_sta" title="ieee80211_sta">ieee80211_sta</a><em> *sta</em>, u8<em> tid</em>, bool<em> buffered</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_sta_set_buffered" title="Permalink to this definition">¶</a></dt>
<dd><p>inform mac80211 about driver-buffered frames</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_sta</span> <span class="pre">*sta</span></code></dt><dd><p><a class="reference internal" href="#c.ieee80211_sta" title="ieee80211_sta"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_sta</span></code></a> pointer for the sleeping station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">tid</span></code></dt><dd><p>the TID that has buffered frames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">buffered</span></code></dt><dd><p>indicates whether or not frames are buffered for this TID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a driver buffers frames for a powersave station instead of passing
them back to mac80211 for retransmission, the station may still need
to be told that there are buffered frames via the TIM bit.</p>
<p>This function informs mac80211 whether or not there are frames that are
buffered in the driver for a given TID; mac80211 can then use this data
to set the TIM bit (NOTE: This may call back into the driver’s set_tim
call! Beware of the locking!)</p>
<p>If all frames are released to the station (due to PS-poll or uAPSD)
then the driver needs to inform mac80211 that there no longer are
frames buffered. However, when the station wakes up mac80211 assumes
that all buffered frames will be transmitted and clears this data,
drivers need to make sure they inform mac80211 about all buffered
frames on the sleep transition (sta_notify() with <code class="docutils literal notranslate"><span class="pre">STA_NOTIFY_SLEEP</span></code>).</p>
<p>Note that technically mac80211 only needs to know this per AC, not per
TID, but since driver buffering will inevitably happen per TID (since
it is related to aggregation) it is easier to make mac80211 map the
TID to the AC as required instead of keeping track in all drivers that
use this API.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_beacon_get">
struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">ieee80211_beacon_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em>, struct <a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a><em> *vif</em>, unsigned int<em> link_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_beacon_get" title="Permalink to this definition">¶</a></dt>
<dd><p>beacon generation function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer obtained from <a class="reference internal" href="mac80211.html#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p><a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a> pointer from the add_interface callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">link_id</span></code></dt><dd><p>the link id to which the beacon belongs (or 0 for a non-MLD AP)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See ieee80211_beacon_get_tim().</p>
<p><strong>Return</strong></p>
<p>See ieee80211_beacon_get_tim().</p>
</div>
<dl class="function">
<dt id="c.ieee80211_get_buffered_bc">
struct <a class="reference internal" href="../../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">ieee80211_get_buffered_bc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em>, struct <a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a><em> *vif</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_get_buffered_bc" title="Permalink to this definition">¶</a></dt>
<dd><p>accessing buffered broadcast and multicast frames</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer as obtained from <a class="reference internal" href="mac80211.html#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p><a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a> pointer from the add_interface callback.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function for accessing buffered broadcast and multicast frames. If
hardware/firmware does not implement buffering of broadcast/multicast
frames when power saving is used, 802.11 code buffers them in the host
memory. The low-level driver uses this function to fetch next buffered
frame. In most cases, this is used when generating beacon frame.</p>
<p><strong>Return</strong></p>
<p>A pointer to the next buffered skb or NULL if no more buffered
frames are available.</p>
<p><strong>Note</strong></p>
<p>buffered frames are returned only after DTIM beacon frame was
generated with <a class="reference internal" href="#c.ieee80211_beacon_get" title="ieee80211_beacon_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_beacon_get()</span></code></a> and the low-level driver must thus
call <a class="reference internal" href="#c.ieee80211_beacon_get" title="ieee80211_beacon_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_beacon_get()</span></code></a> first. <a class="reference internal" href="#c.ieee80211_get_buffered_bc" title="ieee80211_get_buffered_bc"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_get_buffered_bc()</span></code></a> returns
NULL if the previous generated beacon was not DTIM, so the low-level driver
does not need to check for DTIM beacons separately and should be able to
use common code for all beacons.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_sta_block_awake">
void <code class="sig-name descname">ieee80211_sta_block_awake</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em>, struct <a class="reference internal" href="#c.ieee80211_sta" title="ieee80211_sta">ieee80211_sta</a><em> *pubsta</em>, bool<em> block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_sta_block_awake" title="Permalink to this definition">¶</a></dt>
<dd><p>block station from waking up</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_sta</span> <span class="pre">*pubsta</span></code></dt><dd><p>the station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">block</span></code></dt><dd><p>whether to block or unblock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices require that all frames that are on the queues
for a specific station that went to sleep are flushed before
a poll response or frames after the station woke up can be
delivered to that it. Note that such frames must be rejected
by the driver as filtered, with the appropriate status flag.</p>
<p>This function allows implementing this mode in a race-free
manner.</p>
<p>To do this, a driver must keep track of the number of frames
still enqueued for a specific station. If this number is not
zero when the station goes to sleep, the driver must call
this function to force mac80211 to consider the station to
be asleep regardless of the station’s actual state. Once the
number of outstanding frames reaches zero, the driver must
call this function again to unblock the station. That will
cause mac80211 to be able to send ps-poll responses, and if
the station queried in the meantime then frames will also
be sent out as a result of this. Additionally, the driver
will be notified that the station woke up some time after
it is unblocked, regardless of whether the station actually
woke up while blocked or not.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_sta_eosp">
void <code class="sig-name descname">ieee80211_sta_eosp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ieee80211_sta" title="ieee80211_sta">ieee80211_sta</a><em> *pubsta</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_sta_eosp" title="Permalink to this definition">¶</a></dt>
<dd><p>notify mac80211 about end of SP</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_sta</span> <span class="pre">*pubsta</span></code></dt><dd><p>the station</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a device transmits frames in a way that it can’t tell
mac80211 in the TX status about the EOSP, it must clear the
<code class="docutils literal notranslate"><span class="pre">IEEE80211_TX_STATUS_EOSP</span></code> bit and call this function instead.
This applies for PS-Poll as well as uAPSD.</p>
<p>Note that just like with _tx_status() and _rx() drivers must
not mix calls to irqsafe/non-irqsafe versions, this function
must not be mixed with those either. Use the all irqsafe, or
all non-irqsafe, don’t mix!</p>
<dl class="simple">
<dt>NB: the _irqsafe version of this function doesn’t exist, no</dt><dd><p>driver needs it right now. Don’t call this function if
you’d need the _irqsafe version, look at the git history
and restore the _irqsafe version!</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="supporting-multiple-virtual-interfaces">
<h2>Supporting multiple virtual interfaces<a class="headerlink" href="#supporting-multiple-virtual-interfaces" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
<p>Note: WDS with identical MAC address should almost always be OK</p>
<p>Insert notes about having multiple virtual interfaces with different MAC
addresses here, note which configurations are supported by mac80211, add
notes about supporting hw crypto with it.</p>
<dl class="function">
<dt id="c.ieee80211_iterate_active_interfaces">
void <code class="sig-name descname">ieee80211_iterate_active_interfaces</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em>, u32<em> iter_flags</em>, void (<em>*iterator</em>)(void *data, u8 *mac, struct <a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a> *vif), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_iterate_active_interfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate active interfaces</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware struct of which the interfaces should be iterated over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">iter_flags</span></code></dt><dd><p>iteration flags, see <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_interface_iteration_flags</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*iterator)(void</span> <span class="pre">*data,</span> <span class="pre">u8</span> <span class="pre">*mac,</span> <span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif)</span></code></dt><dd><p>the iterator function to call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>first argument of the iterator function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function iterates over the interfaces associated with a given
hardware that are currently active and calls the callback for them.
This function allows the iterator function to sleep, when the iterator
function is atomic <strong>ieee80211_iterate_active_interfaces_atomic</strong> can
be used.
Does not iterate over a new interface during add_interface().</p>
</div>
<dl class="function">
<dt id="c.ieee80211_iterate_active_interfaces_atomic">
void <code class="sig-name descname">ieee80211_iterate_active_interfaces_atomic</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em>, u32<em> iter_flags</em>, void (<em>*iterator</em>)(void *data, u8 *mac, struct <a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a> *vif), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_iterate_active_interfaces_atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate active interfaces</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware struct of which the interfaces should be iterated over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">iter_flags</span></code></dt><dd><p>iteration flags, see <code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_interface_iteration_flags</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*iterator)(void</span> <span class="pre">*data,</span> <span class="pre">u8</span> <span class="pre">*mac,</span> <span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif)</span></code></dt><dd><p>the iterator function to call, cannot sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>first argument of the iterator function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function iterates over the interfaces associated with a given
hardware that are currently active and calls the callback for them.
This function requires the iterator callback function to be atomic,
if that is not desired, use <strong>ieee80211_iterate_active_interfaces</strong> instead.
Does not iterate over a new interface during add_interface().</p>
</div>
</section>
<section id="station-handling">
<h2>Station handling<a class="headerlink" href="#station-handling" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
<dl class="type">
<dt id="c.ieee80211_sta">
struct <code class="sig-name descname">ieee80211_sta</code><a class="headerlink" href="#c.ieee80211_sta" title="Permalink to this definition">¶</a></dt>
<dd><p>station table entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_sta {
    u8 addr[ETH_ALEN];
    u16 aid;
    u16 max_rx_aggregation_subframes;
    bool wme;
    u8 uapsd_queues;
    u8 max_sp;
    struct ieee80211_sta_rates __rcu *rates;
    bool tdls;
    bool tdls_initiator;
    bool mfp;
    bool mlo;
    u8 max_amsdu_subframes;
    struct ieee80211_sta_aggregates *cur;
    bool support_p2p_ps;
    struct ieee80211_txq *txq[IEEE80211_NUM_TIDS + 1];
    u16 valid_links;
    struct ieee80211_link_sta deflink;
    struct ieee80211_link_sta __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];
    u8 drv_priv[] ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>MAC address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aid</span></code></dt><dd><p>AID we assigned to the station if we’re an AP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_rx_aggregation_subframes</span></code></dt><dd><p>maximal amount of frames in a single AMPDU
that this station is allowed to transmit to us.
Can be modified by driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wme</span></code></dt><dd><p>indicates whether the STA supports QoS/WME (if local devices does,
otherwise always false)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uapsd_queues</span></code></dt><dd><p>bitmap of queues configured for uapsd. Only valid
if wme is supported. The bits order is like in
IEEE80211_WMM_IE_STA_QOSINFO_AC_*.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_sp</span></code></dt><dd><p>max Service Period. Only valid if wme is supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rates</span></code></dt><dd><p>rate control selection table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tdls</span></code></dt><dd><p>indicates whether the STA is a TDLS peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tdls_initiator</span></code></dt><dd><p>indicates the STA is an initiator of the TDLS link. Only
valid if the STA is a TDLS peer in the first place.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mfp</span></code></dt><dd><p>indicates whether the STA uses management frame protection or not.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mlo</span></code></dt><dd><p>indicates whether the STA is MLO station.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_amsdu_subframes</span></code></dt><dd><p>indicates the maximal number of MSDUs in a single
A-MSDU. Taken from the Extended Capabilities element. 0 means
unlimited.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur</span></code></dt><dd><p>currently valid data as aggregated from the active links
For non MLO STA it will point to the deflink data. For MLO STA
ieee80211_sta_recalc_aggregates() must be called to update it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">support_p2p_ps</span></code></dt><dd><p>indicates whether the STA supports P2P PS mechanism or not.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">txq</span></code></dt><dd><p>per-TID data TX queues; note that the last entry (<code class="docutils literal notranslate"><span class="pre">IEEE80211_NUM_TIDS</span></code>)
is used for non-data frames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid_links</span></code></dt><dd><p>bitmap of valid links, or 0 for non-MLO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deflink</span></code></dt><dd><p>This holds the default link STA information, for non MLO STA all link
specific STA information is accessed through <strong>deflink</strong> or through
link[0] which points to address of <strong>deflink</strong>. For MLO Link STA
the first added link STA will point to deflink.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link</span></code></dt><dd><p>reference to Link Sta entries. For Non MLO STA, except 1st link,
i.e link[0] all links would be assigned to NULL by default and
would access link information via <strong>deflink</strong> or link[0]. For MLO
STA, first link STA being added will point its link pointer to
<strong>deflink</strong> address and remaining would be allocated and the address
would be assigned to link[link_id] where link_id is the id assigned
by the AP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drv_priv</span></code></dt><dd><p>data area for driver use, will always be aligned to
sizeof(void *), size is determined in hw information.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A station table entry represents a station we are possibly
communicating with. Since stations are RCU-managed in
mac80211, any ieee80211_sta pointer you get access to must
either be protected by <a class="reference internal" href="../../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> explicitly or implicitly,
or you must take good care to not use such a pointer after a
call to your sta_remove callback that removed it.
This also represents the MLD STA in case of MLO association
and holds pointers to various link STA’s</p>
<dl class="type">
<dt id="c.sta_notify_cmd">
enum <code class="sig-name descname">sta_notify_cmd</code><a class="headerlink" href="#c.sta_notify_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>sta notify command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">STA_NOTIFY_SLEEP</span></code></dt><dd><p>a station is now sleeping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">STA_NOTIFY_AWAKE</span></code></dt><dd><p>a sleeping station woke up</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Used with the sta_notify() callback in <a class="reference internal" href="mac80211.html#c.ieee80211_ops" title="ieee80211_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_ops</span></code></a>, this
indicates if an associated station made a power state transition.</p>
<dl class="function">
<dt id="c.ieee80211_find_sta">
struct <a class="reference internal" href="#c.ieee80211_sta" title="ieee80211_sta">ieee80211_sta</a> * <code class="sig-name descname">ieee80211_find_sta</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a><em> *vif</em>, const u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_find_sta" title="Permalink to this definition">¶</a></dt>
<dd><p>find a station</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p>virtual interface to look for station on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>station’s address</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The station, if found. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<p><strong>Note</strong></p>
<p>This function must be called under RCU lock and the
resulting pointer is only valid under RCU lock as well.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_find_sta_by_ifaddr">
struct <a class="reference internal" href="#c.ieee80211_sta" title="ieee80211_sta">ieee80211_sta</a> * <code class="sig-name descname">ieee80211_find_sta_by_ifaddr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em>, const u8<em> *addr</em>, const u8<em> *localaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_find_sta_by_ifaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>find a station on hardware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>pointer as obtained from <a class="reference internal" href="mac80211.html#c.ieee80211_alloc_hw" title="ieee80211_alloc_hw"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_alloc_hw()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>remote station’s address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*localaddr</span></code></dt><dd><p>local address (vif-&gt;sdata-&gt;vif.addr). Use NULL for ‘any’.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The station, if found. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
<p><strong>Note</strong></p>
<p>This function must be called under RCU lock and the
resulting pointer is only valid under RCU lock as well.</p>
<p><strong>NOTE</strong></p>
<dl class="simple">
<dt>You may pass NULL for localaddr, but then you will just get</dt><dd><p>the first STA that matches the remote address ‘addr’.
We can have multiple STA associated with multiple
logical stations (e.g. consider a station connecting to another
BSSID on the same AP hardware without disconnecting first).
In this case, the result of this method with localaddr NULL
is not reliable.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.</p>
</div>
</section>
<section id="hardware-scan-offload">
<h2>Hardware scan offload<a class="headerlink" href="#hardware-scan-offload" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
<dl class="function">
<dt id="c.ieee80211_scan_completed">
void <code class="sig-name descname">ieee80211_scan_completed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_hw" title="ieee80211_hw">ieee80211_hw</a><em> *hw</em>, struct cfg80211_scan_info<em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_scan_completed" title="Permalink to this definition">¶</a></dt>
<dd><p>completed hardware scan</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_hw</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware that finished the scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cfg80211_scan_info</span> <span class="pre">*info</span></code></dt><dd><p>information about the completed scan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When hardware scan offload is used (i.e. the hw_scan() callback is
assigned) this function needs to be called by the driver to notify
mac80211 that the scan finished. This function can be called from
any context, including hardirq context.</p>
</div>
</section>
<section id="aggregation">
<h2>Aggregation<a class="headerlink" href="#aggregation" title="Permalink to this headline">¶</a></h2>
<section id="tx-a-mpdu-aggregation">
<h3>TX A-MPDU aggregation<a class="headerlink" href="#tx-a-mpdu-aggregation" title="Permalink to this headline">¶</a></h3>
<p>Aggregation on the TX side requires setting the hardware flag
<code class="docutils literal notranslate"><span class="pre">IEEE80211_HW_AMPDU_AGGREGATION</span></code>. The driver will then be handed
packets with a flag indicating A-MPDU aggregation. The driver
or device is responsible for actually aggregating the frames,
as well as deciding how many and which to aggregate.</p>
<p>When TX aggregation is started by some subsystem (usually the rate
control algorithm would be appropriate) by calling the
<a class="reference internal" href="#c.ieee80211_start_tx_ba_session" title="ieee80211_start_tx_ba_session"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_start_tx_ba_session()</span></code></a> function, the driver will be
notified via its <strong>ampdu_action</strong> function, with the
<code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_START</span></code> action.</p>
<p>In response to that, the driver is later required to call the
<a class="reference internal" href="#c.ieee80211_start_tx_ba_cb_irqsafe" title="ieee80211_start_tx_ba_cb_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_start_tx_ba_cb_irqsafe()</span></code></a> function, which will really
start the aggregation session after the peer has also responded.
If the peer responds negatively, the session will be stopped
again right away. Note that it is possible for the aggregation
session to be stopped before the driver has indicated that it
is done setting it up, in which case it must not indicate the
setup completion.</p>
<p>Also note that, since we also need to wait for a response from
the peer, the driver is notified of the completion of the
handshake by the <code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_OPERATIONAL</span></code> action to the
<strong>ampdu_action</strong> callback.</p>
<p>Similarly, when the aggregation session is stopped by the peer
or something calling <a class="reference internal" href="#c.ieee80211_stop_tx_ba_session" title="ieee80211_stop_tx_ba_session"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_stop_tx_ba_session()</span></code></a>, the driver’s
<strong>ampdu_action</strong> function will be called with the action
<code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_STOP</span></code>. In this case, the call must not fail,
and the driver must later call <a class="reference internal" href="#c.ieee80211_stop_tx_ba_cb_irqsafe" title="ieee80211_stop_tx_ba_cb_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_stop_tx_ba_cb_irqsafe()</span></code></a>.
Note that the sta can get destroyed before the BA tear down is
complete.</p>
</section>
<section id="rx-a-mpdu-aggregation">
<h3>RX A-MPDU aggregation<a class="headerlink" href="#rx-a-mpdu-aggregation" title="Permalink to this headline">¶</a></h3>
<p>Aggregation on the RX side requires only implementing the
<strong>ampdu_action</strong> callback that is invoked to start/stop any
block-ack sessions for RX aggregation.</p>
<p>When RX aggregation is started by the peer, the driver is
notified via <strong>ampdu_action</strong> function, with the
<code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_RX_START</span></code> action, and may reject the request
in which case a negative response is sent to the peer, if it
accepts it a positive response is sent.</p>
<p>While the session is active, the device/driver are required
to de-aggregate frames and pass them up one by one to mac80211,
which will handle the reorder buffer.</p>
<p>When the aggregation session is stopped again by the peer or
ourselves, the driver’s <strong>ampdu_action</strong> function will be called
with the action <code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_RX_STOP</span></code>. In this case, the
call must not fail.</p>
<dl class="type">
<dt id="c.ieee80211_ampdu_mlme_action">
enum <code class="sig-name descname">ieee80211_ampdu_mlme_action</code><a class="headerlink" href="#c.ieee80211_ampdu_mlme_action" title="Permalink to this definition">¶</a></dt>
<dd><p>A-MPDU actions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_RX_START</span></code></dt><dd><p>start RX aggregation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_RX_STOP</span></code></dt><dd><p>stop RX aggregation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_START</span></code></dt><dd><p>start TX aggregation, the driver must either
call <a class="reference internal" href="#c.ieee80211_start_tx_ba_cb_irqsafe" title="ieee80211_start_tx_ba_cb_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_start_tx_ba_cb_irqsafe()</span></code></a> or
call <a class="reference internal" href="#c.ieee80211_start_tx_ba_cb_irqsafe" title="ieee80211_start_tx_ba_cb_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_start_tx_ba_cb_irqsafe()</span></code></a> with status
<code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_START_DELAY_ADDBA</span></code> to delay addba after
ieee80211_start_tx_ba_cb_irqsafe is called, or just return the special
status <code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_START_IMMEDIATE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_STOP_CONT</span></code></dt><dd><p>stop TX aggregation but continue transmitting
queued packets, now unaggregated. After all packets are transmitted the
driver has to call <a class="reference internal" href="#c.ieee80211_stop_tx_ba_cb_irqsafe" title="ieee80211_stop_tx_ba_cb_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_stop_tx_ba_cb_irqsafe()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_STOP_FLUSH</span></code></dt><dd><p>stop TX aggregation and flush all packets,
called when the station is removed. There’s no need or reason to call
<a class="reference internal" href="#c.ieee80211_stop_tx_ba_cb_irqsafe" title="ieee80211_stop_tx_ba_cb_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_stop_tx_ba_cb_irqsafe()</span></code></a> in this case as mac80211 assumes the
session is gone and removes the station.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_STOP_FLUSH_CONT</span></code></dt><dd><p>called when TX aggregation is stopped
but the driver hasn’t called <a class="reference internal" href="#c.ieee80211_stop_tx_ba_cb_irqsafe" title="ieee80211_stop_tx_ba_cb_irqsafe"><code class="xref c c-func docutils literal notranslate"><span class="pre">ieee80211_stop_tx_ba_cb_irqsafe()</span></code></a> yet and
now the connection is dropped and the station will be removed. Drivers
should clean up and drop remaining packets when this is called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_AMPDU_TX_OPERATIONAL</span></code></dt><dd><p>TX aggregation has become operational</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These flags are used with the ampdu_action() callback in
<a class="reference internal" href="mac80211.html#c.ieee80211_ops" title="ieee80211_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_ops</span></code></a> to indicate which action is needed.</p>
<p>Note that drivers MUST be able to deal with a TX aggregation
session being stopped even before they OK’ed starting it by
calling ieee80211_start_tx_ba_cb_irqsafe, because the peer
might receive the addBA frame and send a delBA right away!</p>
</section>
</section>
<section id="spatial-multiplexing-powersave-smps">
<h2>Spatial Multiplexing Powersave (SMPS)<a class="headerlink" href="#spatial-multiplexing-powersave-smps" title="Permalink to this headline">¶</a></h2>
<p>SMPS (Spatial multiplexing power save) is a mechanism to conserve
power in an 802.11n implementation. For details on the mechanism
and rationale, please refer to 802.11 (as amended by 802.11n-2009)
“11.2.3 SM power save”.</p>
<p>The mac80211 implementation is capable of sending action frames
to update the AP about the station’s SMPS mode, and will instruct
the driver to enter the specific mode. It will also announce the
requested SMPS mode during the association handshake. Hardware
support for this feature is required, and can be indicated by
hardware flags.</p>
<p>The default mode will be “automatic”, which nl80211/cfg80211
defines to be dynamic SMPS in (regular) powersave, and SMPS
turned off otherwise.</p>
<p>To support this feature, the driver must set the appropriate
hardware support flags, and handle the SMPS flag to the config()
operation. It will then with this mechanism be instructed to
enter the requested SMPS mode while associated to an HT AP.</p>
<dl class="type">
<dt id="c.ieee80211_smps_mode">
enum <code class="sig-name descname">ieee80211_smps_mode</code><a class="headerlink" href="#c.ieee80211_smps_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>spatial multiplexing power save mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_SMPS_AUTOMATIC</span></code></dt><dd><p>automatic</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_SMPS_OFF</span></code></dt><dd><p>off</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_SMPS_STATIC</span></code></dt><dd><p>static</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_SMPS_DYNAMIC</span></code></dt><dd><p>dynamic</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_SMPS_NUM_MODES</span></code></dt><dd><p>internal, don’t use</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ieee80211_request_smps">
void <code class="sig-name descname">ieee80211_request_smps</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a><em> *vif</em>, unsigned int<em> link_id</em>, enum <a class="reference internal" href="#c.ieee80211_smps_mode" title="ieee80211_smps_mode">ieee80211_smps_mode</a><em> smps_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_request_smps" title="Permalink to this definition">¶</a></dt>
<dd><p>request SM PS transition</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p><a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a> pointer from the add_interface callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">link_id</span></code></dt><dd><p>link ID for MLO, or 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_smps_mode</span> <span class="pre">smps_mode</span></code></dt><dd><p>new SM PS mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allows the driver to request an SM PS transition in managed
mode. This is useful when the driver has more information than
the stack about possible interference, for example by bluetooth.</p>
</div>
<p>TBD</p>
<p>This part of the book describes the rate control algorithm interface and
how it relates to mac80211 and drivers.</p>
</section>
<section id="rate-control-api">
<h2>Rate Control API<a class="headerlink" href="#rate-control-api" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
<dl class="type">
<dt id="c.ieee80211_rate_control_changed">
enum <code class="sig-name descname">ieee80211_rate_control_changed</code><a class="headerlink" href="#c.ieee80211_rate_control_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>flags to indicate what changed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_RC_BW_CHANGED</span></code></dt><dd><p>The bandwidth that can be used to transmit
to this station changed. The actual bandwidth is in the station
information – for HT20/40 the IEEE80211_HT_CAP_SUP_WIDTH_20_40
flag changes, for HT and VHT the bandwidth field changes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_RC_SMPS_CHANGED</span></code></dt><dd><p>The SMPS state of the station changed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_RC_SUPP_RATES_CHANGED</span></code></dt><dd><p>The supported rate set of this peer
changed (in IBSS mode) due to discovering more information about
the peer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IEEE80211_RC_NSS_CHANGED</span></code></dt><dd><p>N_SS (number of spatial streams) was changed
by the peer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ieee80211_start_tx_ba_session">
int <code class="sig-name descname">ieee80211_start_tx_ba_session</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ieee80211_sta" title="ieee80211_sta">ieee80211_sta</a><em> *sta</em>, u16<em> tid</em>, u16<em> timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_start_tx_ba_session" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a tx Block Ack session.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_sta</span> <span class="pre">*sta</span></code></dt><dd><p>the station for which to start a BA session</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">tid</span></code></dt><dd><p>the TID to BA on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">timeout</span></code></dt><dd><p>session timeout value (in TUs)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>success if addBA request was sent, failure otherwise</p>
<p><strong>Description</strong></p>
<p>Although mac80211/low level driver/user space application can estimate
the need to start aggregation on a certain RA/TID, the session level
will be managed by the mac80211.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_start_tx_ba_cb_irqsafe">
void <code class="sig-name descname">ieee80211_start_tx_ba_cb_irqsafe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a><em> *vif</em>, const u8<em> *ra</em>, u16<em> tid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_start_tx_ba_cb_irqsafe" title="Permalink to this definition">¶</a></dt>
<dd><p>low level driver ready to aggregate.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p><a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a> pointer from the add_interface callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*ra</span></code></dt><dd><p>receiver address of the BA session recipient.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">tid</span></code></dt><dd><p>the TID to BA on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called by low level driver once it has
finished with preparations for the BA session. It can be called
from any context.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_stop_tx_ba_session">
int <code class="sig-name descname">ieee80211_stop_tx_ba_session</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.ieee80211_sta" title="ieee80211_sta">ieee80211_sta</a><em> *sta</em>, u16<em> tid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_stop_tx_ba_session" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop a Block Ack session.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_sta</span> <span class="pre">*sta</span></code></dt><dd><p>the station whose BA session to stop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">tid</span></code></dt><dd><p>the TID to stop BA.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>negative error if the TID is invalid, or no aggregation active</p>
<p><strong>Description</strong></p>
<p>Although mac80211/low level driver/user space application can estimate
the need to stop aggregation on a certain RA/TID, the session level
will be managed by the mac80211.</p>
</div>
<dl class="function">
<dt id="c.ieee80211_stop_tx_ba_cb_irqsafe">
void <code class="sig-name descname">ieee80211_stop_tx_ba_cb_irqsafe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif">ieee80211_vif</a><em> *vif</em>, const u8<em> *ra</em>, u16<em> tid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ieee80211_stop_tx_ba_cb_irqsafe" title="Permalink to this definition">¶</a></dt>
<dd><p>low level driver ready to stop aggregate.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span> <span class="pre">*vif</span></code></dt><dd><p><a class="reference internal" href="mac80211.html#c.ieee80211_vif" title="ieee80211_vif"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_vif</span></code></a> pointer from the add_interface callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*ra</span></code></dt><dd><p>receiver address of the BA session recipient.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">tid</span></code></dt><dd><p>the desired TID to BA on.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called by low level driver once it has
finished with preparations for the BA session tear down. It
can be called from any context.</p>
</div>
<dl class="type">
<dt id="c.ieee80211_tx_rate_control">
struct <code class="sig-name descname">ieee80211_tx_rate_control</code><a class="headerlink" href="#c.ieee80211_tx_rate_control" title="Permalink to this definition">¶</a></dt>
<dd><p>rate control information for/from RC algo</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ieee80211_tx_rate_control {
    struct ieee80211_hw *hw;
    struct ieee80211_supported_band *sband;
    struct ieee80211_bss_conf *bss_conf;
    struct sk_buff *skb;
    struct ieee80211_tx_rate reported_rate;
    bool rts, short_preamble;
    u32 rate_idx_mask;
    u8 *rate_idx_mcs_mask;
    bool bss;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">hw</span></code></dt><dd><p>The hardware the algorithm is invoked for.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sband</span></code></dt><dd><p>The band this frame is being transmitted on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bss_conf</span></code></dt><dd><p>the current BSS configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skb</span></code></dt><dd><p>the skb that will be transmitted, the control information in it needs
to be filled in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reported_rate</span></code></dt><dd><p>The rate control algorithm can fill this in to indicate
which rate should be reported to userspace as the current rate and
used for rate calculations in the mesh network.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rts</span></code></dt><dd><p>whether RTS will be used for this frame because it is longer than the
RTS threshold</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">short_preamble</span></code></dt><dd><p>whether mac80211 will request short-preamble transmission
if the selected rate supports it</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate_idx_mask</span></code></dt><dd><p>user-requested (legacy) rate mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate_idx_mcs_mask</span></code></dt><dd><p>user-requested MCS rate mask (NULL if not in use)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bss</span></code></dt><dd><p>whether this frame is sent out in AP or IBSS mode</p>
</dd>
</dl>
</div>
<p>TBD</p>
<p>This part of the book describes mac80211 internals.</p>
</section>
<section id="key-handling">
<h2>Key handling<a class="headerlink" href="#key-handling" title="Permalink to this headline">¶</a></h2>
<section id="key-handling-basics">
<h3>Key handling basics<a class="headerlink" href="#key-handling-basics" title="Permalink to this headline">¶</a></h3>
<p>Key handling in mac80211 is done based on per-interface (sub_if_data)
keys and per-station keys. Since each station belongs to an interface,
each station key also belongs to that interface.</p>
<p>Hardware acceleration is done on a best-effort basis for algorithms
that are implemented in software,  for each key the hardware is asked
to enable that key for offloading but if it cannot do that the key is
simply kept for software encryption (unless it is for an algorithm
that isn’t implemented in software).
There is currently no way of knowing whether a key is handled in SW
or HW except by looking into debugfs.</p>
<p>All key management is internally protected by a mutex. Within all
other parts of mac80211, key references are, just as STA structure
references, protected by RCU. Note, however, that some things are
unprotected, namely the key-&gt;sta dereferences within the hardware
acceleration functions. This means that sta_info_destroy() must
remove the key which waits for an RCU grace period.</p>
</section>
<section id="more-tbd">
<h3>MORE TBD<a class="headerlink" href="#more-tbd" title="Permalink to this headline">¶</a></h3>
<p>TBD</p>
</section>
</section>
<section id="receive-processing">
<h2>Receive processing<a class="headerlink" href="#receive-processing" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
</section>
<section id="transmit-processing">
<h2>Transmit processing<a class="headerlink" href="#transmit-processing" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
</section>
<section id="station-info-handling">
<h2>Station info handling<a class="headerlink" href="#station-info-handling" title="Permalink to this headline">¶</a></h2>
<section id="programming-information">
<h3>Programming information<a class="headerlink" href="#programming-information" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.ieee80211_sta_info_flags">
enum <code class="sig-name descname">ieee80211_sta_info_flags</code><a class="headerlink" href="#c.ieee80211_sta_info_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Stations flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_AUTH</span></code></dt><dd><p>Station is authenticated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_ASSOC</span></code></dt><dd><p>Station is associated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_PS_STA</span></code></dt><dd><p>Station is in power-save mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_AUTHORIZED</span></code></dt><dd><p>Station is authorized to send/receive traffic.
This bit is always checked so needs to be enabled for all stations
when virtual port control is not in use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_SHORT_PREAMBLE</span></code></dt><dd><p>Station is capable of receiving short-preamble
frames.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_WDS</span></code></dt><dd><p>Station is one of our WDS peers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_CLEAR_PS_FILT</span></code></dt><dd><p>Clear PS filter in hardware (using the
IEEE80211_TX_CTL_CLEAR_PS_FILT control flag) when the next
frame to this station is transmitted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_MFP</span></code></dt><dd><p>Management frame protection is used with this STA.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_BLOCK_BA</span></code></dt><dd><p>Used to deny ADDBA requests (both TX and RX)
during suspend/resume and station removal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_PS_DRIVER</span></code></dt><dd><p>driver requires keeping this station in
power-save mode logically to flush frames that might still
be in the queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_PSPOLL</span></code></dt><dd><p>Station sent PS-poll while driver was keeping
station in power-save mode, reply when the driver unblocks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_TDLS_PEER</span></code></dt><dd><p>Station is a TDLS peer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_TDLS_PEER_AUTH</span></code></dt><dd><p>This TDLS peer is authorized to send direct
packets. This means the link is enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_TDLS_INITIATOR</span></code></dt><dd><p>We are the initiator of the TDLS link with this
station.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_TDLS_CHAN_SWITCH</span></code></dt><dd><p>This TDLS peer supports TDLS channel-switching</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_TDLS_OFF_CHANNEL</span></code></dt><dd><p>The local STA is currently off-channel with this
TDLS peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_TDLS_WIDER_BW</span></code></dt><dd><p>This TDLS peer supports working on a wider bw on
the BSS base channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_UAPSD</span></code></dt><dd><p>Station requested unscheduled SP while driver was
keeping station in power-save mode, reply when the driver
unblocks the station.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_SP</span></code></dt><dd><p>Station is in a service period, so don’t try to
reply to other uAPSD trigger frames or PS-Poll.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_4ADDR_EVENT</span></code></dt><dd><p>4-addr event was already sent for this frame.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_INSERTED</span></code></dt><dd><p>This station is inserted into the hash table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_RATE_CONTROL</span></code></dt><dd><p>rate control was initialized for this station.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_TOFFSET_KNOWN</span></code></dt><dd><p>toffset calculated for this station is valid.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_MPSP_OWNER</span></code></dt><dd><p>local STA is owner of a mesh Peer Service Period.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_MPSP_RECIPIENT</span></code></dt><dd><p>local STA is recipient of a MPSP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_PS_DELIVER</span></code></dt><dd><p>station woke up, but we’re still blocking TX
until pending frames are delivered</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_USES_ENCRYPTION</span></code></dt><dd><p>This station was configured for encryption,
so drop all packets without a key later.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">WLAN_STA_DECAP_OFFLOAD</span></code></dt><dd><p>This station uses rx decap offload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NUM_WLAN_STA_FLAGS</span></code></dt><dd><p>number of defined flags</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These flags are used with <a class="reference internal" href="#c.sta_info" title="sta_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sta_info</span></code></a>’s <strong>flags</strong> member, but
only indirectly with set_sta_flag() and friends.</p>
<dl class="type">
<dt id="c.sta_info">
struct <code class="sig-name descname">sta_info</code><a class="headerlink" href="#c.sta_info" title="Permalink to this definition">¶</a></dt>
<dd><p>STA information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sta_info {
    struct list_head list, free_list;
    struct rcu_head rcu_head;
    struct rhlist_head hash_node;
    u8 addr[ETH_ALEN];
    struct ieee80211_local *local;
    struct ieee80211_sub_if_data *sdata;
    struct ieee80211_key __rcu *ptk[NUM_DEFAULT_KEYS];
    u8 ptk_idx;
    struct rate_control_ref *rate_ctrl;
    void *rate_ctrl_priv;
    spinlock_t rate_ctrl_lock;
    spinlock_t lock;
    struct ieee80211_fast_tx __rcu *fast_tx;
    struct ieee80211_fast_rx __rcu *fast_rx;
#ifdef CONFIG_MAC80211_MESH;
    struct mesh_sta *mesh;
#endif;
    struct work_struct drv_deliver_wk;
    u16 listen_interval;
    bool dead;
    bool removed;
    bool uploaded;
    enum ieee80211_sta_state sta_state;
    unsigned long _flags;
    spinlock_t ps_lock;
    struct sk_buff_head ps_tx_buf[IEEE80211_NUM_ACS];
    struct sk_buff_head tx_filtered[IEEE80211_NUM_ACS];
    unsigned long driver_buffered_tids;
    unsigned long txq_buffered_tids;
    u64 assoc_at;
    long last_connected;
    __le16 last_seq_ctrl[IEEE80211_NUM_TIDS + 1];
    u16 tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1];
    struct airtime_info airtime[IEEE80211_NUM_ACS];
    u16 airtime_weight;
    struct sta_ampdu_mlme ampdu_mlme;
#ifdef CONFIG_MAC80211_DEBUGFS;
    struct dentry *debugfs_dir;
#endif;
    struct codel_params cparams;
    u8 reserved_tid;
    struct cfg80211_chan_def tdls_chandef;
    struct ieee80211_fragment_cache frags;
    struct ieee80211_sta_aggregates cur;
    struct link_sta_info deflink;
    struct link_sta_info __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];
    struct ieee80211_sta sta;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>global linked list entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_list</span></code></dt><dd><p>list entry for keeping track of stations to free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rcu_head</span></code></dt><dd><p>RCU head used for freeing this station struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hash_node</span></code></dt><dd><p>hash node for rhashtable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>station’s MAC address - duplicated from public part to
let the hash table work with just a single cacheline</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">local</span></code></dt><dd><p>pointer to the global information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sdata</span></code></dt><dd><p>virtual interface this station belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptk</span></code></dt><dd><p>peer keys negotiated with this station, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptk_idx</span></code></dt><dd><p>last installed peer key index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate_ctrl</span></code></dt><dd><p>rate control algorithm reference</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate_ctrl_priv</span></code></dt><dd><p>rate control private per-STA pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate_ctrl_lock</span></code></dt><dd><p>spinlock used to protect rate control data
(data inside the algorithm, so serializes calls there)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>used for locking all fields that require locking, see comments
in the header file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fast_tx</span></code></dt><dd><p>TX fastpath information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fast_rx</span></code></dt><dd><p>RX fastpath information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mesh</span></code></dt><dd><p>mesh STA information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drv_deliver_wk</span></code></dt><dd><p>used for delivering frames after driver PS unblocking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">listen_interval</span></code></dt><dd><p>listen interval of this station, when we’re acting as AP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dead</span></code></dt><dd><p>set to true when sta is unlinked</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">removed</span></code></dt><dd><p>set to true when sta is being removed from sta_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uploaded</span></code></dt><dd><p>set to true when sta is uploaded to the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta_state</span></code></dt><dd><p>duplicates information about station state (for debug)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_flags</span></code></dt><dd><p>STA flags, see <a class="reference internal" href="#c.ieee80211_sta_info_flags" title="ieee80211_sta_info_flags"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ieee80211_sta_info_flags</span></code></a>, do not use directly</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ps_lock</span></code></dt><dd><p>used for powersave (when mac80211 is the AP) related locking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ps_tx_buf</span></code></dt><dd><p>buffers (per AC) of frames to transmit to this station
when it leaves power saving state or polls</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_filtered</span></code></dt><dd><p>buffers (per AC) of frames we already tried to
transmit but were filtered by hardware due to STA having
entered power saving state, these are also delivered to
the station when it leaves powersave or polls for frames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_buffered_tids</span></code></dt><dd><p>bitmap of TIDs the driver has data buffered on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">txq_buffered_tids</span></code></dt><dd><p>bitmap of TIDs that mac80211 has txq data buffered on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">assoc_at</span></code></dt><dd><p>clock boottime (in ns) of last association</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_connected</span></code></dt><dd><p>time (in seconds) when a station got connected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_seq_ctrl</span></code></dt><dd><p>last received seq/frag number from this STA (per TID
plus one for non-QoS frames)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_seq</span></code></dt><dd><p>per-TID sequence numbers for sending to this STA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">airtime</span></code></dt><dd><p>per-AC struct airtime_info describing airtime statistics for this
station</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">airtime_weight</span></code></dt><dd><p>station weight for airtime fairness calculation purposes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ampdu_mlme</span></code></dt><dd><p>A-MPDU state machine state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">debugfs_dir</span></code></dt><dd><p>debug filesystem directory dentry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cparams</span></code></dt><dd><p>CoDel parameters for this station.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved_tid</span></code></dt><dd><p>reserved TID (if any, otherwise IEEE80211_TID_UNRESERVED)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tdls_chandef</span></code></dt><dd><p>a TDLS peer can have a wider chandef that is compatible to
the BSS one.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">frags</span></code></dt><dd><p>fragment cache</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cur</span></code></dt><dd><p>storage for aggregation data
<a class="reference internal" href="#c.ieee80211_sta" title="ieee80211_sta"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ieee80211_sta</span></code></a> points either here or to deflink.agg.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">deflink</span></code></dt><dd><p>This is the default link STA information, for non MLO STA all link
specific STA information is accessed through <strong>deflink</strong> or through
link[0] which points to address of <strong>deflink</strong>. For MLO Link STA
the first added link STA will point to deflink.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link</span></code></dt><dd><p>reference to Link Sta entries. For Non MLO STA, except 1st link,
i.e link[0] all links would be assigned to NULL by default and
would access link information via <strong>deflink</strong> or link[0]. For MLO
STA, first link STA being added will point its link pointer to
<strong>deflink</strong> address and remaining would be allocated and the address
would be assigned to link[link_id] where link_id is the id assigned
by the AP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta</span></code></dt><dd><p>station information we share with the driver</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure collects information about a station that
mac80211 is communicating with.</p>
</section>
<section id="sta-information-lifetime-rules">
<h3>STA information lifetime rules<a class="headerlink" href="#sta-information-lifetime-rules" title="Permalink to this headline">¶</a></h3>
<p>STA info structures (<a class="reference internal" href="#c.sta_info" title="sta_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sta_info</span></code></a>) are managed in a hash table
for faster lookup and a list for iteration. They are managed using
RCU, i.e. access to the list and hash table is protected by RCU.</p>
<p>Upon allocating a STA info structure with sta_info_alloc(), the caller
owns that structure. It must then insert it into the hash table using
either sta_info_insert() or sta_info_insert_rcu(); only in the latter
case (which acquires an rcu read section but must not be called from
within one) will the pointer still be valid after the call. Note that
the caller may not do much with the STA info before inserting it, in
particular, it may not start any mesh peer link management or add
encryption keys.</p>
<p>When the insertion fails (sta_info_insert()) returns non-zero), the
structure will have been freed by sta_info_insert()!</p>
<p>Station entries are added by mac80211 when you establish a link with a
peer. This means different things for the different type of interfaces
we support. For a regular station this mean we add the AP sta when we
receive an association response from the AP. For IBSS this occurs when
get to know about a peer on the same IBSS. For WDS we add the sta for
the peer immediately upon device open. When using AP mode we add stations
for each respective station upon request from userspace through nl80211.</p>
<p>In order to remove a STA info structure, various sta_info_destroy_*()
calls are available.</p>
<p>There is no concept of ownership on a STA entry, each structure is
owned by the global hash table/list until it is removed. All users of
the structure need to be RCU protected so that the structure won’t be
freed before they are done using it.</p>
</section>
</section>
<section id="aggregation-functions">
<h2>Aggregation Functions<a class="headerlink" href="#aggregation-functions" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.tid_ampdu_tx">
struct <code class="sig-name descname">tid_ampdu_tx</code><a class="headerlink" href="#c.tid_ampdu_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>TID aggregation information (Tx).</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tid_ampdu_tx {
    struct rcu_head rcu_head;
    struct timer_list session_timer;
    struct timer_list addba_resp_timer;
    struct sk_buff_head pending;
    struct sta_info *sta;
    unsigned long state;
    unsigned long last_tx;
    u16 timeout;
    u8 dialog_token;
    u8 stop_initiator;
    bool tx_stop;
    u16 buf_size;
    u16 ssn;
    u16 failed_bar_ssn;
    bool bar_pending;
    bool amsdu;
    u8 tid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcu_head</span></code></dt><dd><p>rcu head for freeing structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">session_timer</span></code></dt><dd><p>check if we keep Tx-ing on the TID (by timeout value)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addba_resp_timer</span></code></dt><dd><p>timer for peer’s response to addba request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pending</span></code></dt><dd><p>pending frames queue – use sta’s spinlock to protect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta</span></code></dt><dd><p>station we are attached to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>session state (see above)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_tx</span></code></dt><dd><p>jiffies of last tx activity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>session timeout value to be filled in ADDBA requests</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dialog_token</span></code></dt><dd><p>dialog token for aggregation session</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop_initiator</span></code></dt><dd><p>initiator of a session stop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_stop</span></code></dt><dd><p>TX DelBA frame when stopping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_size</span></code></dt><dd><p>reorder buffer size at receiver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssn</span></code></dt><dd><p>starting sequence number of the session</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">failed_bar_ssn</span></code></dt><dd><p>ssn of the last failed BAR tx attempt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bar_pending</span></code></dt><dd><p>BAR needs to be re-sent</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">amsdu</span></code></dt><dd><p>support A-MSDU withing A-MDPU</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid</span></code></dt><dd><p>TID number</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure’s lifetime is managed by RCU, assignments to
the array holding it must hold the aggregation mutex.</p>
<p>The TX path can access it under RCU lock-free if, and
only if, the state has the flag <code class="docutils literal notranslate"><span class="pre">HT_AGG_STATE_OPERATIONAL</span></code>
set. Otherwise, the TX path must also acquire the spinlock
and re-check the state, see comments in the tx code
touching it.</p>
<dl class="type">
<dt id="c.tid_ampdu_rx">
struct <code class="sig-name descname">tid_ampdu_rx</code><a class="headerlink" href="#c.tid_ampdu_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>TID aggregation information (Rx).</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tid_ampdu_rx {
    struct rcu_head rcu_head;
    spinlock_t reorder_lock;
    u64 reorder_buf_filtered;
    struct sk_buff_head *reorder_buf;
    unsigned long *reorder_time;
    struct sta_info *sta;
    struct timer_list session_timer;
    struct timer_list reorder_timer;
    unsigned long last_rx;
    u16 head_seq_num;
    u16 stored_mpdu_num;
    u16 ssn;
    u16 buf_size;
    u16 timeout;
    u8 tid;
    u8 auto_seq:1,removed:1, started:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rcu_head</span></code></dt><dd><p>RCU head used for freeing this struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reorder_lock</span></code></dt><dd><p>serializes access to reorder buffer, see below.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reorder_buf_filtered</span></code></dt><dd><p>bitmap indicating where there are filtered frames in
the reorder buffer that should be ignored when releasing frames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reorder_buf</span></code></dt><dd><p>buffer to reorder incoming aggregated MPDUs. An MPDU may be an
A-MSDU with individually reported subframes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reorder_time</span></code></dt><dd><p>jiffies when skb was added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sta</span></code></dt><dd><p>station we are attached to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">session_timer</span></code></dt><dd><p>check if peer keeps Tx-ing on the TID (by timeout value)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reorder_timer</span></code></dt><dd><p>releases expired frames from the reorder buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_rx</span></code></dt><dd><p>jiffies of last rx activity</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_seq_num</span></code></dt><dd><p>head sequence number in reordering buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stored_mpdu_num</span></code></dt><dd><p>number of MPDUs in reordering buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssn</span></code></dt><dd><p>Starting Sequence Number expected to be aggregated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buf_size</span></code></dt><dd><p>buffer size for incoming A-MPDUs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout</span></code></dt><dd><p>reset timer value (in TUs).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid</span></code></dt><dd><p>TID number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">auto_seq</span></code></dt><dd><p>used for offloaded BA sessions to automatically pick head_seq_and
and ssn.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">removed</span></code></dt><dd><p>this session is removed (but might have been found due to RCU)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">started</span></code></dt><dd><p>this session has started (head ssn or higher was received)</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure’s lifetime is managed by RCU, assignments to
the array holding it must hold the aggregation mutex.</p>
<p>The <strong>reorder_lock</strong> is used to protect the members of this
struct, except for <strong>timeout</strong>, <strong>buf_size</strong> and <strong>dialog_token</strong>,
which are constant across the lifetime of the struct (the
dialog token being used only for debugging).</p>
<dl class="type">
<dt id="c.sta_ampdu_mlme">
struct <code class="sig-name descname">sta_ampdu_mlme</code><a class="headerlink" href="#c.sta_ampdu_mlme" title="Permalink to this definition">¶</a></dt>
<dd><p>STA aggregation information.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sta_ampdu_mlme {
    struct mutex mtx;
    struct tid_ampdu_rx __rcu *tid_rx[IEEE80211_NUM_TIDS];
    u8 tid_rx_token[IEEE80211_NUM_TIDS];
    unsigned long tid_rx_timer_expired[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];
    unsigned long tid_rx_stop_requested[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];
    unsigned long tid_rx_manage_offl[BITS_TO_LONGS(2 * IEEE80211_NUM_TIDS)];
    unsigned long agg_session_valid[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];
    unsigned long unexpected_agg[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];
    struct work_struct work;
    struct tid_ampdu_tx __rcu *tid_tx[IEEE80211_NUM_TIDS];
    struct tid_ampdu_tx *tid_start_tx[IEEE80211_NUM_TIDS];
    unsigned long last_addba_req_time[IEEE80211_NUM_TIDS];
    u8 addba_req_num[IEEE80211_NUM_TIDS];
    u8 dialog_token_allocator;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mtx</span></code></dt><dd><p>mutex to protect all TX data (except non-NULL assignments
to tid_tx[idx], which are protected by the sta spinlock)
tid_start_tx is also protected by sta-&gt;lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_rx</span></code></dt><dd><p>aggregation info for Rx per TID – RCU protected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_rx_token</span></code></dt><dd><p>dialog tokens for valid aggregation sessions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_rx_timer_expired</span></code></dt><dd><p>bitmap indicating on which TIDs the
RX timer expired until the work for it runs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_rx_stop_requested</span></code></dt><dd><p>bitmap indicating which BA sessions per TID the
driver requested to close until the work for it runs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_rx_manage_offl</span></code></dt><dd><p>bitmap indicating which BA sessions were requested
to be treated as started/stopped due to offloading</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">agg_session_valid</span></code></dt><dd><p>bitmap indicating which TID has a rx BA session open on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unexpected_agg</span></code></dt><dd><p>bitmap indicating which TID already sent a delBA due to
unexpected aggregation related frames outside a session</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>work struct for starting/stopping aggregation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_tx</span></code></dt><dd><p>aggregation info for Tx per TID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tid_start_tx</span></code></dt><dd><p>sessions where start was requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_addba_req_time</span></code></dt><dd><p>timestamp of the last addBA request.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addba_req_num</span></code></dt><dd><p>number of times addBA request has been sent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dialog_token_allocator</span></code></dt><dd><p>dialog token enumerator for each new session;</p>
</dd>
</dl>
</div>
</section>
<section id="synchronisation-functions">
<h2>Synchronisation Functions<a class="headerlink" href="#synchronisation-functions" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
<p>Locking, lots of RCU</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">mac80211 subsystem (advanced)</a><ul>
<li><a class="reference internal" href="#led-support">LED support</a></li>
<li><a class="reference internal" href="#hardware-crypto-acceleration">Hardware crypto acceleration</a></li>
<li><a class="reference internal" href="#powersave-support">Powersave support</a></li>
<li><a class="reference internal" href="#beacon-filter-support">Beacon filter support</a></li>
<li><a class="reference internal" href="#multiple-queues-and-qos-support">Multiple queues and QoS support</a></li>
<li><a class="reference internal" href="#access-point-mode-support">Access point mode support</a><ul>
<li><a class="reference internal" href="#support-for-powersaving-clients">support for powersaving clients</a></li>
</ul>
</li>
<li><a class="reference internal" href="#supporting-multiple-virtual-interfaces">Supporting multiple virtual interfaces</a></li>
<li><a class="reference internal" href="#station-handling">Station handling</a></li>
<li><a class="reference internal" href="#hardware-scan-offload">Hardware scan offload</a></li>
<li><a class="reference internal" href="#aggregation">Aggregation</a><ul>
<li><a class="reference internal" href="#tx-a-mpdu-aggregation">TX A-MPDU aggregation</a></li>
<li><a class="reference internal" href="#rx-a-mpdu-aggregation">RX A-MPDU aggregation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#spatial-multiplexing-powersave-smps">Spatial Multiplexing Powersave (SMPS)</a></li>
<li><a class="reference internal" href="#rate-control-api">Rate Control API</a></li>
<li><a class="reference internal" href="#key-handling">Key handling</a><ul>
<li><a class="reference internal" href="#key-handling-basics">Key handling basics</a></li>
<li><a class="reference internal" href="#more-tbd">MORE TBD</a></li>
</ul>
</li>
<li><a class="reference internal" href="#receive-processing">Receive processing</a></li>
<li><a class="reference internal" href="#transmit-processing">Transmit processing</a></li>
<li><a class="reference internal" href="#station-info-handling">Station info handling</a><ul>
<li><a class="reference internal" href="#programming-information">Programming information</a></li>
<li><a class="reference internal" href="#sta-information-lifetime-rules">STA information lifetime rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#aggregation-functions">Aggregation Functions</a></li>
<li><a class="reference internal" href="#synchronisation-functions">Synchronisation Functions</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/80211/mac80211-advanced.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/80211/mac80211-advanced.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>