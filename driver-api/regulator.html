
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Voltage and current regulator API &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Reset controller API" href="reset.html" />
    <link rel="prev" title="Frame Buffer Library" href="frame-buffer.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="voltage-and-current-regulator-api">
<h1>Voltage and current regulator API<a class="headerlink" href="#voltage-and-current-regulator-api" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Liam Girdwood</p>
</dd>
<dt class="field-even">Author</dt>
<dd class="field-even"><p>Mark Brown</p>
</dd>
</dl>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This framework is designed to provide a standard kernel interface to
control voltage and current regulators.</p>
<p>The intention is to allow systems to dynamically control regulator power
output in order to save power and prolong battery life. This applies to
both voltage regulators (where voltage output is controllable) and
current sinks (where current limit is controllable).</p>
<p>Note that additional (and currently more complete) documentation is
available in the Linux kernel source under
<code class="docutils literal notranslate"><span class="pre">Documentation/power/regulator</span></code>.</p>
<section id="glossary">
<h3>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h3>
<p>The regulator API uses a number of terms which may not be familiar:</p>
<p>Regulator</p>
<blockquote>
<div><p>Electronic device that supplies power to other devices. Most regulators
can enable and disable their output and some can also control their
output voltage or current.</p>
</div></blockquote>
<p>Consumer</p>
<blockquote>
<div><p>Electronic device which consumes power provided by a regulator. These
may either be static, requiring only a fixed supply, or dynamic,
requiring active management of the regulator at runtime.</p>
</div></blockquote>
<p>Power Domain</p>
<blockquote>
<div><p>The electronic circuit supplied by a given regulator, including the
regulator and all consumer devices. The configuration of the regulator
is shared between all the components in the circuit.</p>
</div></blockquote>
<p>Power Management Integrated Circuit (PMIC)</p>
<blockquote>
<div><p>An IC which contains numerous regulators and often also other
subsystems. In an embedded system the primary PMIC is often equivalent
to a combination of the PSU and southbridge in a desktop system.</p>
</div></blockquote>
</section>
</section>
<section id="consumer-driver-interface">
<h2>Consumer driver interface<a class="headerlink" href="#consumer-driver-interface" title="Permalink to this headline">¶</a></h2>
<p>This offers a similar API to the kernel clock framework. Consumer
drivers use <a class="reference external" href="#API-regulator-get">get</a> and
<a class="reference external" href="#API-regulator-put">put</a> operations to acquire and release
regulators. Functions are provided to <a class="reference external" href="#API-regulator-enable">enable</a>
and <a class="reference external" href="#API-regulator-disable">disable</a> the regulator and to get and
set the runtime parameters of the regulator.</p>
<p>When requesting regulators consumers use symbolic names for their
supplies, such as “Vcc”, which are mapped into actual regulator devices
by the machine interface.</p>
<p>A stub version of this API is provided when the regulator framework is
not in use in order to minimise the need to use ifdefs.</p>
<section id="enabling-and-disabling">
<h3>Enabling and disabling<a class="headerlink" href="#enabling-and-disabling" title="Permalink to this headline">¶</a></h3>
<p>The regulator API provides reference counted enabling and disabling of
regulators. Consumer devices use the <a class="reference internal" href="#c.regulator_enable" title="regulator_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_enable()</span></code></a> and
<a class="reference internal" href="#c.regulator_disable" title="regulator_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_disable()</span></code></a> functions to enable and disable
regulators. Calls to the two functions must be balanced.</p>
<p>Note that since multiple consumers may be using a regulator and machine
constraints may not allow the regulator to be disabled there is no
guarantee that calling <a class="reference internal" href="#c.regulator_disable" title="regulator_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_disable()</span></code></a> will actually
cause the supply provided by the regulator to be disabled. Consumer
drivers should assume that the regulator may be enabled at all times.</p>
</section>
<section id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h3>
<p>Some consumer devices may need to be able to dynamically configure their
supplies. For example, MMC drivers may need to select the correct
operating voltage for their cards. This may be done while the regulator
is enabled or disabled.</p>
<p>The <a class="reference internal" href="#c.regulator_set_voltage" title="regulator_set_voltage"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_set_voltage()</span></code></a> and
<a class="reference internal" href="#c.regulator_set_current_limit" title="regulator_set_current_limit"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_set_current_limit()</span></code></a> functions provide the primary
interface for this. Both take ranges of voltages and currents, supporting
drivers that do not require a specific value (eg, CPU frequency scaling
normally permits the CPU to use a wider range of supply voltages at lower
frequencies but does not require that the supply voltage be lowered). Where
an exact value is required both minimum and maximum values should be
identical.</p>
</section>
<section id="callbacks">
<h3>Callbacks<a class="headerlink" href="#callbacks" title="Permalink to this headline">¶</a></h3>
<p>Callbacks may also be registered for events such as regulation failures.</p>
</section>
</section>
<section id="regulator-driver-interface">
<h2>Regulator driver interface<a class="headerlink" href="#regulator-driver-interface" title="Permalink to this headline">¶</a></h2>
<p>Drivers for regulator chips register the regulators with the regulator
core, providing operations structures to the core. A notifier interface
allows error conditions to be reported to the core.</p>
<p>Registration should be triggered by explicit setup done by the platform,
supplying a <a class="reference internal" href="#c.regulator_init_data" title="regulator_init_data"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_init_data</span></code></a> for the regulator
containing constraint and supply information.</p>
</section>
<section id="machine-interface">
<h2>Machine interface<a class="headerlink" href="#machine-interface" title="Permalink to this headline">¶</a></h2>
<p>This interface provides a way to define how regulators are connected to
consumers on a given system and what the valid operating parameters are
for the system.</p>
<section id="supplies">
<h3>Supplies<a class="headerlink" href="#supplies" title="Permalink to this headline">¶</a></h3>
<p>Regulator supplies are specified using struct
<a class="reference internal" href="#c.regulator_consumer_supply" title="regulator_consumer_supply"><code class="xref c c-type docutils literal notranslate"><span class="pre">regulator_consumer_supply</span></code></a>. This is done at driver registration
time as part of the machine constraints.</p>
</section>
<section id="constraints">
<h3>Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h3>
<p>As well as defining the connections the machine interface also provides
constraints defining the operations that clients are allowed to perform
and the parameters that may be set. This is required since generally
regulator devices will offer more flexibility than it is safe to use on
a given system, for example supporting higher supply voltages than the
consumers are rated for.</p>
<p>This is done at driver registration time` by providing a
<a class="reference internal" href="#c.regulation_constraints" title="regulation_constraints"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulation_constraints</span></code></a>.</p>
<p>The constraints may also specify an initial configuration for the
regulator in the constraints, which is particularly useful for use with
static consumers.</p>
</section>
</section>
<section id="api-reference">
<h2>API reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<p>Due to limitations of the kernel documentation framework and the
existing layout of the source code the entire regulator API is
documented here.</p>
<dl class="type">
<dt id="c.pre_voltage_change_data">
struct <code class="sig-name descname">pre_voltage_change_data</code><a class="headerlink" href="#c.pre_voltage_change_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data sent with PRE_VOLTAGE_CHANGE event</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pre_voltage_change_data {
    unsigned long old_uV;
    unsigned long min_uV;
    unsigned long max_uV;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">old_uV</span></code></dt><dd><p>Current voltage before change.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_uV</span></code></dt><dd><p>Min voltage we’ll change to.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_uV</span></code></dt><dd><p>Max voltage we’ll change to.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.regulator_bulk_data">
struct <code class="sig-name descname">regulator_bulk_data</code><a class="headerlink" href="#c.regulator_bulk_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data used for bulk regulator operations.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_bulk_data {
    const char *supply;
    int init_load_uA;
    struct regulator *consumer;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">supply</span></code></dt><dd><p>The name of the supply.  Initialised by the user before
using the bulk regulator APIs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_load_uA</span></code></dt><dd><p>After getting the regulator, <a class="reference internal" href="#c.regulator_set_load" title="regulator_set_load"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_set_load()</span></code></a> will be
called with this load.  Initialised by the user before
using the bulk regulator APIs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">consumer</span></code></dt><dd><p>The regulator consumer for the supply.  This will be managed
by the bulk API.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The regulator APIs provide a series of regulator_bulk_() API calls as
a convenience to consumers which require multiple supplies.  This
structure is used to manage data for these calls.</p>
<dl class="type">
<dt id="c.regulator_state">
struct <code class="sig-name descname">regulator_state</code><a class="headerlink" href="#c.regulator_state" title="Permalink to this definition">¶</a></dt>
<dd><p>regulator state during low power system states</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_state {
    int uV;
    int min_uV;
    int max_uV;
    unsigned int mode;
    int enabled;
    bool changeable;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uV</span></code></dt><dd><p>Default operating voltage during suspend, it can be adjusted
among &lt;min_uV, max_uV&gt;.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_uV</span></code></dt><dd><p>Minimum suspend voltage may be set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_uV</span></code></dt><dd><p>Maximum suspend voltage may be set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>Operating mode during suspend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled</span></code></dt><dd><p>operations during suspend.
- DO_NOTHING_IN_SUSPEND
- DISABLE_IN_SUSPEND
- ENABLE_IN_SUSPEND</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">changeable</span></code></dt><dd><p>Is this state can be switched between enabled/disabled,</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This describes a regulators state during a system wide low power
state.  One of enabled or disabled must be set for the
configuration to be applied.</p>
<dl class="type">
<dt id="c.regulation_constraints">
struct <code class="sig-name descname">regulation_constraints</code><a class="headerlink" href="#c.regulation_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>regulator operating constraints.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulation_constraints {
    const char *name;
    int min_uV;
    int max_uV;
    int uV_offset;
    int min_uA;
    int max_uA;
    int ilim_uA;
    int system_load;
    u32 *max_spread;
    int max_uV_step;
    unsigned int valid_modes_mask;
    unsigned int valid_ops_mask;
    int input_uV;
    struct regulator_state state_disk;
    struct regulator_state state_mem;
    struct regulator_state state_standby;
    struct notification_limit over_curr_limits;
    struct notification_limit over_voltage_limits;
    struct notification_limit under_voltage_limits;
    struct notification_limit temp_limits;
    suspend_state_t initial_state;
    unsigned int initial_mode;
    unsigned int ramp_delay;
    unsigned int settling_time;
    unsigned int settling_time_up;
    unsigned int settling_time_down;
    unsigned int enable_time;
    unsigned int active_discharge;
    unsigned always_on:1;
    unsigned boot_on:1;
    unsigned apply_uV:1;
    unsigned ramp_disable:1;
    unsigned soft_start:1;
    unsigned pull_down:1;
    unsigned over_current_protection:1;
    unsigned over_current_detection:1;
    unsigned over_voltage_detection:1;
    unsigned under_voltage_detection:1;
    unsigned over_temp_detection:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Descriptive name for the constraints, used for display purposes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_uV</span></code></dt><dd><p>Smallest voltage consumers may set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_uV</span></code></dt><dd><p>Largest voltage consumers may set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uV_offset</span></code></dt><dd><p>Offset applied to voltages from consumer to compensate for
voltage drops.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_uA</span></code></dt><dd><p>Smallest current consumers may set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_uA</span></code></dt><dd><p>Largest current consumers may set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ilim_uA</span></code></dt><dd><p>Maximum input current.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">system_load</span></code></dt><dd><p>Load that isn’t captured by any consumer requests.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_spread</span></code></dt><dd><p>Max possible spread between coupled regulators</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_uV_step</span></code></dt><dd><p>Max possible step change in voltage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid_modes_mask</span></code></dt><dd><p>Mask of modes which may be configured by consumers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">valid_ops_mask</span></code></dt><dd><p>Operations which may be performed by consumers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">input_uV</span></code></dt><dd><p>Input voltage for regulator when supplied by another regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_disk</span></code></dt><dd><p>State for regulator when system is suspended in disk mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_mem</span></code></dt><dd><p>State for regulator when system is suspended in mem mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_standby</span></code></dt><dd><p>State for regulator when system is suspended in standby
mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">over_curr_limits</span></code></dt><dd><p>Limits for acting on over current.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">over_voltage_limits</span></code></dt><dd><p>Limits for acting on over voltage.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">under_voltage_limits</span></code></dt><dd><p>Limits for acting on under voltage.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">temp_limits</span></code></dt><dd><p>Limits for acting on over temperature.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_state</span></code></dt><dd><p>Suspend state to set by default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">initial_mode</span></code></dt><dd><p>Mode to set at startup.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ramp_delay</span></code></dt><dd><p>Time to settle down after voltage change (unit: uV/us)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">settling_time</span></code></dt><dd><p>Time to settle down after voltage change when voltage
change is non-linear (unit: microseconds).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">settling_time_up</span></code></dt><dd><p>Time to settle down after voltage increase when voltage
change is non-linear (unit: microseconds).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">settling_time_down</span></code></dt><dd><p>Time to settle down after voltage decrease when
voltage change is non-linear (unit: microseconds).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_time</span></code></dt><dd><p>Turn-on time of the rails (unit: microseconds)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_discharge</span></code></dt><dd><p>Enable/disable active discharge. The enum
regulator_active_discharge values are used for
initialisation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">always_on</span></code></dt><dd><p>Set if the regulator should never be disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">boot_on</span></code></dt><dd><p>Set if the regulator is enabled when the system is initially
started.  If the regulator is not enabled by the hardware or
bootloader then it will be enabled when the constraints are
applied.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">apply_uV</span></code></dt><dd><p>Apply the voltage constraint when initialising.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ramp_disable</span></code></dt><dd><p>Disable ramp delay when initialising or when setting voltage.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soft_start</span></code></dt><dd><p>Enable soft start so that voltage ramps slowly.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pull_down</span></code></dt><dd><p>Enable pull down when regulator is disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">over_current_protection</span></code></dt><dd><p>Auto disable on over current event.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">over_current_detection</span></code></dt><dd><p>Configure over current limits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">over_voltage_detection</span></code></dt><dd><p>Configure over voltage limits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">under_voltage_detection</span></code></dt><dd><p>Configure under voltage limits.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">over_temp_detection</span></code></dt><dd><p>Configure over temperature limits.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct describes regulator and board/machine specific constraints.</p>
<dl class="type">
<dt id="c.regulator_consumer_supply">
struct <code class="sig-name descname">regulator_consumer_supply</code><a class="headerlink" href="#c.regulator_consumer_supply" title="Permalink to this definition">¶</a></dt>
<dd><p>supply -&gt; device mapping</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_consumer_supply {
    const char *dev_name;
    const char *supply;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev_name</span></code></dt><dd><p>Result of dev_name() for the consumer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supply</span></code></dt><dd><p>Name for the supply.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This maps a supply name to a device. Use of dev_name allows support for
buses which make <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> available late such as I2C.</p>
<dl class="type">
<dt id="c.regulator_init_data">
struct <code class="sig-name descname">regulator_init_data</code><a class="headerlink" href="#c.regulator_init_data" title="Permalink to this definition">¶</a></dt>
<dd><p>regulator platform initialisation data.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_init_data {
    const char *supply_regulator;
    struct regulation_constraints constraints;
    int num_consumer_supplies;
    struct regulator_consumer_supply *consumer_supplies;
    int (*regulator_init)(void *driver_data);
    void *driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">supply_regulator</span></code></dt><dd><p>Parent regulator.  Specified using the regulator name
as it appears in the name field in sysfs, which can
be explicitly set using the constraints field ‘name’.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">constraints</span></code></dt><dd><p>Constraints.  These must be specified for the regulator to
be usable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_consumer_supplies</span></code></dt><dd><p>Number of consumer device supplies.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">consumer_supplies</span></code></dt><dd><p>Consumer device supply configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regulator_init</span></code></dt><dd><p>Callback invoked when the regulator has been registered.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>Data passed to regulator_init.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Initialisation constraints, our supply and consumers supplies.</p>
<dl class="type">
<dt id="c.regulator_ops">
struct <code class="sig-name descname">regulator_ops</code><a class="headerlink" href="#c.regulator_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>regulator operations.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_ops {
    int (*list_voltage) (struct regulator_dev *, unsigned selector);
    int (*set_voltage) (struct regulator_dev *, int min_uV, int max_uV, unsigned *selector);
    int (*map_voltage)(struct regulator_dev *, int min_uV, int max_uV);
    int (*set_voltage_sel) (struct regulator_dev *, unsigned selector);
    int (*get_voltage) (struct regulator_dev *);
    int (*get_voltage_sel) (struct regulator_dev *);
    int (*set_current_limit) (struct regulator_dev *, int min_uA, int max_uA);
    int (*get_current_limit) (struct regulator_dev *);
    int (*set_input_current_limit) (struct regulator_dev *, int lim_uA);
    int (*set_over_current_protection)(struct regulator_dev *, int lim_uA, int severity, bool enable);
    int (*set_over_voltage_protection)(struct regulator_dev *, int lim_uV, int severity, bool enable);
    int (*set_under_voltage_protection)(struct regulator_dev *, int lim_uV, int severity, bool enable);
    int (*set_thermal_protection)(struct regulator_dev *, int lim, int severity, bool enable);
    int (*set_active_discharge)(struct regulator_dev *, bool enable);
    int (*enable) (struct regulator_dev *);
    int (*disable) (struct regulator_dev *);
    int (*is_enabled) (struct regulator_dev *);
    int (*set_mode) (struct regulator_dev *, unsigned int mode);
    unsigned int (*get_mode) (struct regulator_dev *);
    int (*get_error_flags)(struct regulator_dev *, unsigned int *flags);
    int (*enable_time) (struct regulator_dev *);
    int (*set_ramp_delay) (struct regulator_dev *, int ramp_delay);
    int (*set_voltage_time) (struct regulator_dev *, int old_uV, int new_uV);
    int (*set_voltage_time_sel) (struct regulator_dev *,unsigned int old_selector, unsigned int new_selector);
    int (*set_soft_start) (struct regulator_dev *);
    int (*get_status)(struct regulator_dev *);
    unsigned int (*get_optimum_mode) (struct regulator_dev *, int input_uV, int output_uV, int load_uA);
    int (*set_load)(struct regulator_dev *, int load_uA);
    int (*set_bypass)(struct regulator_dev *dev, bool enable);
    int (*get_bypass)(struct regulator_dev *dev, bool *enable);
    int (*set_suspend_voltage) (struct regulator_dev *, int uV);
    int (*set_suspend_enable) (struct regulator_dev *);
    int (*set_suspend_disable) (struct regulator_dev *);
    int (*set_suspend_mode) (struct regulator_dev *, unsigned int mode);
    int (*resume)(struct regulator_dev *rdev);
    int (*set_pull_down) (struct regulator_dev *);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list_voltage</span></code></dt><dd><p>Return one of the supported voltages, in microvolts; zero
if the selector indicates a voltage that is unusable on this system;
or negative errno.  Selectors range from zero to one less than
regulator_desc.n_voltages.  Voltages may be reported in any order.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_voltage</span></code></dt><dd><p>Set the voltage for the regulator within the range specified.
The driver should select the voltage closest to min_uV.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map_voltage</span></code></dt><dd><p>Convert a voltage into a selector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_voltage_sel</span></code></dt><dd><p>Set the voltage for the regulator using the specified
selector.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_voltage</span></code></dt><dd><p>Return the currently configured voltage for the regulator;
return -ENOTRECOVERABLE if regulator can’t be read at
bootup and hasn’t been set yet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_voltage_sel</span></code></dt><dd><p>Return the currently configured voltage selector for the
regulator; return -ENOTRECOVERABLE if regulator can’t
be read at bootup and hasn’t been set yet.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_current_limit</span></code></dt><dd><p>Configure a limit for a current-limited regulator.
The driver should select the current closest to max_uA.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_current_limit</span></code></dt><dd><p>Get the configured limit for a current-limited regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_input_current_limit</span></code></dt><dd><p>Configure an input limit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_over_current_protection</span></code></dt><dd><p>Support enabling of and setting limits for over
current situation detection. Detection can be configured for three
levels of severity.</p>
<ul class="simple">
<li><p>REGULATOR_SEVERITY_PROT should automatically shut down the regulator(s).</p></li>
<li><dl class="simple">
<dt>REGULATOR_SEVERITY_ERR should indicate that over-current situation is</dt><dd><p>caused by an unrecoverable error but HW does not perform
automatic shut down.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>REGULATOR_SEVERITY_WARN should indicate situation where hardware is</dt><dd><p>still believed to not be damaged but that a board sepcific
recovery action is needed. If lim_uA is 0 the limit should not
be changed but the detection should just be enabled/disabled as
is requested.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_over_voltage_protection</span></code></dt><dd><p>Support enabling of and setting limits for over
voltage situation detection. Detection can be configured for same
severities as over current protection. Units of uV.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_under_voltage_protection</span></code></dt><dd><p>Support enabling of and setting limits for
under voltage situation detection. Detection can be configured for same
severities as over current protection. Units of uV.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_thermal_protection</span></code></dt><dd><p>Support enabling of and setting limits for over
temperature situation detection.Detection can be configured for same
severities as over current protection. Units of degree Kelvin.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_active_discharge</span></code></dt><dd><p>Set active discharge enable/disable of regulators.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable</span></code></dt><dd><p>Configure the regulator as enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable</span></code></dt><dd><p>Configure the regulator as disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_enabled</span></code></dt><dd><p>Return 1 if the regulator is enabled, 0 if not.
May also return negative errno.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_mode</span></code></dt><dd><p>Set the configured operating mode for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_mode</span></code></dt><dd><p>Get the configured operating mode for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_error_flags</span></code></dt><dd><p>Get the current error(s) for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_time</span></code></dt><dd><p>Time taken for the regulator voltage output voltage to
stabilise after being enabled, in microseconds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_ramp_delay</span></code></dt><dd><p>Set the ramp delay for the regulator. The driver should
select ramp delay equal to or less than(closest) ramp_delay.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_voltage_time</span></code></dt><dd><p>Time taken for the regulator voltage output voltage
to stabilise after being set to a new value, in microseconds.
The function receives the from and to voltage as input, it
should return the worst case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_voltage_time_sel</span></code></dt><dd><p>Time taken for the regulator voltage output voltage
to stabilise after being set to a new value, in microseconds.
The function receives the from and to voltage selector as
input, it should return the worst case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_soft_start</span></code></dt><dd><p>Enable soft start for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_status</span></code></dt><dd><p>Return actual (not as-configured) status of regulator, as a
REGULATOR_STATUS value (or negative errno)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_optimum_mode</span></code></dt><dd><p>Get the most efficient operating mode for the regulator
when running with the specified parameters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_load</span></code></dt><dd><p>Set the load for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_bypass</span></code></dt><dd><p>Set the regulator in bypass mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_bypass</span></code></dt><dd><p>Get the regulator bypass mode state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_suspend_voltage</span></code></dt><dd><p>Set the voltage for the regulator when the system
is suspended.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_suspend_enable</span></code></dt><dd><p>Mark the regulator as enabled when the system is
suspended.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_suspend_disable</span></code></dt><dd><p>Mark the regulator as disabled when the system is
suspended.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_suspend_mode</span></code></dt><dd><p>Set the operating mode for the regulator when the
system is suspended.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Resume operation of suspended regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_pull_down</span></code></dt><dd><p>Configure the regulator to pull down when the regulator
is disabled.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This struct describes regulator operations which can be implemented by
regulator chip drivers.</p>
<dl class="type">
<dt id="c.regulator_desc">
struct <code class="sig-name descname">regulator_desc</code><a class="headerlink" href="#c.regulator_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Static regulator descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_desc {
    const char *name;
    const char *supply_name;
    const char *of_match;
    bool of_match_full_name;
    const char *regulators_node;
    int (*of_parse_cb)(struct device_node *,const struct regulator_desc *, struct regulator_config *);
    int id;
    unsigned int continuous_voltage_range:1;
    unsigned n_voltages;
    unsigned int n_current_limits;
    const struct regulator_ops *ops;
    int irq;
    enum regulator_type type;
    struct module *owner;
    unsigned int min_uV;
    unsigned int uV_step;
    unsigned int linear_min_sel;
    int fixed_uV;
    unsigned int ramp_delay;
    int min_dropout_uV;
    const struct linear_range *linear_ranges;
    const unsigned int *linear_range_selectors;
    int n_linear_ranges;
    const unsigned int *volt_table;
    const unsigned int *curr_table;
    unsigned int vsel_range_reg;
    unsigned int vsel_range_mask;
    unsigned int vsel_reg;
    unsigned int vsel_mask;
    unsigned int vsel_step;
    unsigned int csel_reg;
    unsigned int csel_mask;
    unsigned int apply_reg;
    unsigned int apply_bit;
    unsigned int enable_reg;
    unsigned int enable_mask;
    unsigned int enable_val;
    unsigned int disable_val;
    bool enable_is_inverted;
    unsigned int bypass_reg;
    unsigned int bypass_mask;
    unsigned int bypass_val_on;
    unsigned int bypass_val_off;
    unsigned int active_discharge_on;
    unsigned int active_discharge_off;
    unsigned int active_discharge_mask;
    unsigned int active_discharge_reg;
    unsigned int soft_start_reg;
    unsigned int soft_start_mask;
    unsigned int soft_start_val_on;
    unsigned int pull_down_reg;
    unsigned int pull_down_mask;
    unsigned int pull_down_val_on;
    unsigned int ramp_reg;
    unsigned int ramp_mask;
    const unsigned int *ramp_delay_table;
    unsigned int n_ramp_values;
    unsigned int enable_time;
    unsigned int off_on_delay;
    unsigned int poll_enabled_time;
    unsigned int (*of_map_mode)(unsigned int mode);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Identifying name for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supply_name</span></code></dt><dd><p>Identifying the regulator supply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_match</span></code></dt><dd><p>Name used to identify regulator in DT.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_match_full_name</span></code></dt><dd><p>A flag to indicate that the of_match string, if
present, should be matched against the node full_name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regulators_node</span></code></dt><dd><p>Name of node containing regulator definitions in DT.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_parse_cb</span></code></dt><dd><p>Optional callback called only if of_match is present.
Will be called for each regulator parsed from DT, during
init_data parsing.
The regulator_config passed as argument to the callback will
be a copy of config passed to regulator_register, valid only
for this particular call. Callback may freely change the
config but it cannot store it for later usage.
Callback should return 0 on success or negative ERRNO
indicating failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Numerical identifier for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">continuous_voltage_range</span></code></dt><dd><p>Indicates if the regulator can set any
voltage within constrains range.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_voltages</span></code></dt><dd><p>Number of selectors available for ops.list_voltage().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_current_limits</span></code></dt><dd><p>Number of selectors available for current limits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Regulator operations table.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>Interrupt number for the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Indicates if the regulator is a voltage or current regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>Module providing the regulator, used for refcounting.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_uV</span></code></dt><dd><p>Voltage given by the lowest selector (if linear mapping)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uV_step</span></code></dt><dd><p>Voltage increase with each selector (if linear mapping)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">linear_min_sel</span></code></dt><dd><p>Minimal selector for starting linear mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fixed_uV</span></code></dt><dd><p>Fixed voltage of rails.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ramp_delay</span></code></dt><dd><p>Time to settle down after voltage change (unit: uV/us)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_dropout_uV</span></code></dt><dd><p>The minimum dropout voltage this regulator can handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">linear_ranges</span></code></dt><dd><p>A constant table of possible voltage ranges.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">linear_range_selectors</span></code></dt><dd><p>A constant table of voltage range selectors.
If pickable ranges are used each range must
have corresponding selector here.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_linear_ranges</span></code></dt><dd><p>Number of entries in the <strong>linear_ranges</strong> (and in
linear_range_selectors if used) table(s).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">volt_table</span></code></dt><dd><p>Voltage mapping table (if table based mapping)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">curr_table</span></code></dt><dd><p>Current limit mapping table (if table based mapping)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsel_range_reg</span></code></dt><dd><p>Register for range selector when using pickable ranges
and <code class="docutils literal notranslate"><span class="pre">regulator_map_*_voltage_*_pickable</span></code> functions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsel_range_mask</span></code></dt><dd><p>Mask for register bitfield used for range selector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsel_reg</span></code></dt><dd><p>Register for selector when using <code class="docutils literal notranslate"><span class="pre">regulator_map_*_voltage_*</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsel_mask</span></code></dt><dd><p>Mask for register bitfield used for selector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vsel_step</span></code></dt><dd><p>Specify the resolution of selector stepping when setting
voltage. If 0, then no stepping is done (requested selector is
set directly), if &gt;0 then the regulator API will ramp the
voltage up/down gradually each time increasing/decreasing the
selector by the specified step value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csel_reg</span></code></dt><dd><p>Register for current limit selector using regmap set_current_limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csel_mask</span></code></dt><dd><p>Mask for register bitfield used for current limit selector</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">apply_reg</span></code></dt><dd><p>Register for initiate voltage change on the output when
using regulator_set_voltage_sel_regmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">apply_bit</span></code></dt><dd><p>Register bitfield used for initiate voltage change on the
output when using regulator_set_voltage_sel_regmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_reg</span></code></dt><dd><p>Register for control when using regmap enable/disable ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_mask</span></code></dt><dd><p>Mask for control when using regmap enable/disable ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_val</span></code></dt><dd><p>Enabling value for control when using regmap enable/disable ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_val</span></code></dt><dd><p>Disabling value for control when using regmap enable/disable ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_is_inverted</span></code></dt><dd><p>A flag to indicate set enable_mask bits to disable
when using regulator_enable_regmap and friends APIs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bypass_reg</span></code></dt><dd><p>Register for control when using regmap set_bypass</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bypass_mask</span></code></dt><dd><p>Mask for control when using regmap set_bypass</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bypass_val_on</span></code></dt><dd><p>Enabling value for control when using regmap set_bypass</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bypass_val_off</span></code></dt><dd><p>Disabling value for control when using regmap set_bypass</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_discharge_on</span></code></dt><dd><p>Disabling value for control when using regmap
set_active_discharge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_discharge_off</span></code></dt><dd><p>Enabling value for control when using regmap
set_active_discharge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_discharge_mask</span></code></dt><dd><p>Mask for control when using regmap
set_active_discharge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_discharge_reg</span></code></dt><dd><p>Register for control when using regmap
set_active_discharge</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soft_start_reg</span></code></dt><dd><p>Register for control when using regmap set_soft_start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soft_start_mask</span></code></dt><dd><p>Mask for control when using regmap set_soft_start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soft_start_val_on</span></code></dt><dd><p>Enabling value for control when using regmap
set_soft_start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pull_down_reg</span></code></dt><dd><p>Register for control when using regmap set_pull_down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pull_down_mask</span></code></dt><dd><p>Mask for control when using regmap set_pull_down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pull_down_val_on</span></code></dt><dd><p>Enabling value for control when using regmap
set_pull_down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ramp_reg</span></code></dt><dd><p>Register for controlling the regulator ramp-rate.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ramp_mask</span></code></dt><dd><p>Bitmask for the ramp-rate control register.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ramp_delay_table</span></code></dt><dd><p>Table for mapping the regulator ramp-rate values. Values
should be given in units of V/S (uV/uS). See the
regulator_set_ramp_delay_regmap().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_ramp_values</span></code></dt><dd><p>number of elements at <strong>ramp_delay_table</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_time</span></code></dt><dd><p>Time taken for initial enable of regulator (in uS).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">off_on_delay</span></code></dt><dd><p>guard time (in uS), before re-enabling a regulator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_enabled_time</span></code></dt><dd><p>The polling interval (in uS) to use while checking that
the regulator was actually enabled. Max upto enable_time.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_map_mode</span></code></dt><dd><p>Maps a hardware mode defined in a DeviceTree to a standard mode</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Each regulator registered with the core is described with a
structure of this type and a <a class="reference internal" href="#c.regulator_config" title="regulator_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_config</span></code></a>.  This
structure contains the non-varying parts of the regulator
description.</p>
<dl class="type">
<dt id="c.regulator_config">
struct <code class="sig-name descname">regulator_config</code><a class="headerlink" href="#c.regulator_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic regulator descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_config {
    struct device *dev;
    const struct regulator_init_data *init_data;
    void *driver_data;
    struct device_node *of_node;
    struct regmap *regmap;
    struct gpio_desc *ena_gpiod;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p><a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> for the regulator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_data</span></code></dt><dd><p>platform provided init data, passed through by driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>private regulator data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt><dd><p>OpenFirmware node to parse for device tree bindings (may be
NULL).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regmap</span></code></dt><dd><p>regmap to use for core regmap helpers if dev_get_regmap() is
insufficient.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ena_gpiod</span></code></dt><dd><p>GPIO controlling regulator enable.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Each regulator registered with the core is described with a
structure of this type and a <a class="reference internal" href="#c.regulator_desc" title="regulator_desc"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_desc</span></code></a>.  This structure
contains the runtime variable parts of the regulator description.</p>
<dl class="type">
<dt id="c.regulator_err_state">
struct <code class="sig-name descname">regulator_err_state</code><a class="headerlink" href="#c.regulator_err_state" title="Permalink to this definition">¶</a></dt>
<dd><p>regulator error/notification status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_err_state {
    struct regulator_dev *rdev;
    unsigned long notifs;
    unsigned long errors;
    int possible_errs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rdev</span></code></dt><dd><p>Regulator which status the struct indicates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">notifs</span></code></dt><dd><p>Events which have occurred on the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">errors</span></code></dt><dd><p>Errors which are active on the regulator.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">possible_errs</span></code></dt><dd><p>Errors which can be signaled (by given IRQ).</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.regulator_irq_data">
struct <code class="sig-name descname">regulator_irq_data</code><a class="headerlink" href="#c.regulator_irq_data" title="Permalink to this definition">¶</a></dt>
<dd><p>regulator error/notification status data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_irq_data {
    struct regulator_err_state *states;
    int num_states;
    void *data;
    long opaque;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">states</span></code></dt><dd><p>Status structs for each of the associated regulators.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_states</span></code></dt><dd><p>Amount of associated regulators.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Driver data pointer given at regulator_irq_desc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">opaque</span></code></dt><dd><p>Value storage for IC driver. Core does not update this. ICs
may want to store status register value here at map_event and
compare contents at ‘renable’ callback to see if new problems
have been added to status. If that is the case it may be
desirable to return REGULATOR_ERROR_CLEARED and not
REGULATOR_ERROR_ON to allow IRQ fire again and to generate
notifications also for the new issues.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is passed to ‘map_event’ and ‘renable’ callbacks for
reporting regulator status to core.</p>
<dl class="type">
<dt id="c.regulator_irq_desc">
struct <code class="sig-name descname">regulator_irq_desc</code><a class="headerlink" href="#c.regulator_irq_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>notification sender for IRQ based events.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct regulator_irq_desc {
    const char *name;
    int fatal_cnt;
    int reread_ms;
    int irq_off_ms;
    bool skip_off;
    bool high_prio;
    void *data;
    int (*die)(struct regulator_irq_data *rid);
    int (*map_event)(int irq, struct regulator_irq_data *rid, unsigned long *dev_mask);
    int (*renable)(struct regulator_irq_data *rid);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>The visible name for the IRQ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fatal_cnt</span></code></dt><dd><p>If this IRQ is used to signal HW damaging condition it may be
best to shut-down regulator(s) or reboot the SOC if error
handling is repeatedly failing. If fatal_cnt is given the IRQ
handling is aborted if it fails for fatal_cnt times and die()
callback (if populated) is called. If die() is not populated
poweroff for the system is attempted in order to prevent any
further damage.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reread_ms</span></code></dt><dd><p>The time which is waited before attempting to re-read status
at the worker if IC reading fails. Immediate re-read is done
if time is not specified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_off_ms</span></code></dt><dd><p>The time which IRQ is kept disabled before re-evaluating the
status for devices which keep IRQ disabled for duration of the
error. If this is not given the IRQ is left enabled and renable
is not called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skip_off</span></code></dt><dd><p>If set to true the IRQ handler will attempt to check if any of
the associated regulators are enabled prior to taking other
actions. If no regulators are enabled and this is set to true
a spurious IRQ is assumed and IRQ_NONE is returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">high_prio</span></code></dt><dd><p>Boolean to indicate that high priority WQ should be used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Driver private data pointer which will be passed as such to
the renable, map_event and die callbacks in regulator_irq_data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">die</span></code></dt><dd><p>Protection callback. If IC status reading or recovery actions
fail fatal_cnt times this callback is called or system is
powered off. This callback should implement a final protection
attempt like disabling the regulator. If protection succeeded
die() may return 0. If anything else is returned the core
assumes final protection failed and attempts to perform a
poweroff as a last resort.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">map_event</span></code></dt><dd><p>Driver callback to map IRQ status into regulator devices with
events / errors. NOTE: callback MUST initialize both the
errors and notifs for all rdevs which it signals having
active events as core does not clean the map data.
REGULATOR_FAILED_RETRY can be returned to indicate that the
status reading from IC failed. If this is repeated for
fatal_cnt times the core will call die() callback or power-off
the system as a last resort to protect the HW.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">renable</span></code></dt><dd><p>Optional callback to check status (if HW supports that) before
re-enabling IRQ. If implemented this should clear the error
flags so that errors fetched by <a class="reference internal" href="#c.regulator_get_error_flags" title="regulator_get_error_flags"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_get_error_flags()</span></code></a>
are updated. If callback is not implemented then errors are
assumed to be cleared and IRQ is re-enabled.
REGULATOR_FAILED_RETRY can be returned to
indicate that the status reading from IC failed. If this is
repeated for ‘fatal_cnt’ times the core will call die()
callback or if die() is not populated then attempt to power-off
the system as a last resort to protect the HW.
Returning zero indicates that the problem in HW has been solved
and IRQ will be re-enabled. Returning REGULATOR_ERROR_ON
indicates the error condition is still active and keeps IRQ
disabled. Please note that returning REGULATOR_ERROR_ON does
not retrigger evaluating what events are active or resending
notifications. If this is needed you probably want to return
zero and allow IRQ to retrigger causing events to be
re-evaluated and re-sent.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is used for registering regulator IRQ notification helper.</p>
<dl class="function">
<dt id="c.regulator_get">
struct regulator * <code class="sig-name descname">regulator_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a reference to a regulator.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>Supply name or regulator ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct regulator corresponding to the regulator producer,
or IS_ERR() condition containing errno.</p>
<p>Use of supply names configured via set_consumer_device_supply() is
strongly encouraged.  It is recommended that the supply name used
should match the name used for the supply and/or the relevant
device pins in the datasheet.</p>
</div>
<dl class="function">
<dt id="c.regulator_get_exclusive">
struct regulator * <code class="sig-name descname">regulator_get_exclusive</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain exclusive access to a regulator.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>Supply name or regulator ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct regulator corresponding to the regulator producer,
or IS_ERR() condition containing errno.  Other consumers will be
unable to obtain this regulator while this reference is held and the
use count for the regulator will be initialised to reflect the current
state of the regulator.</p>
<p>This is intended for use by consumers which cannot tolerate shared
use of the regulator such as those which need to force the
regulator off for correct operation of the hardware they are
controlling.</p>
<p>Use of supply names configured via set_consumer_device_supply() is
strongly encouraged.  It is recommended that the supply name used
should match the name used for the supply and/or the relevant
device pins in the datasheet.</p>
</div>
<dl class="function">
<dt id="c.regulator_get_optional">
struct regulator * <code class="sig-name descname">regulator_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_optional" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain optional access to a regulator.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device for regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>Supply name or regulator ID.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct regulator corresponding to the regulator producer,
or IS_ERR() condition containing errno.</p>
<p>This is intended for use by consumers for devices which can have
some supplies unconnected in normal use, such as some MMC devices.
It can allow the regulator core to provide stub supplies for other
supplies requested using normal <a class="reference internal" href="#c.regulator_get" title="regulator_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_get()</span></code></a> calls without
disrupting the operation of drivers that can handle absent
supplies.</p>
<p>Use of supply names configured via set_consumer_device_supply() is
strongly encouraged.  It is recommended that the supply name used
should match the name used for the supply and/or the relevant
device pins in the datasheet.</p>
</div>
<dl class="function">
<dt id="c.regulator_put">
void <code class="sig-name descname">regulator_put</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_put" title="Permalink to this definition">¶</a></dt>
<dd><p>“free” the regulator source</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all regulator_enable calls made on this
regulator source are balanced by regulator_disable calls prior to calling
this function.</p>
</div>
<dl class="function">
<dt id="c.regulator_register_supply_alias">
int <code class="sig-name descname">regulator_register_supply_alias</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *id</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *alias_dev</em>, const char<em> *alias_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_register_supply_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide device alias for supply lookup</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device that will be given as the regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>Supply name or regulator ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*alias_dev</span></code></dt><dd><p>device that should be used to lookup the supply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*alias_id</span></code></dt><dd><p>Supply name or regulator ID that should be used to lookup the
supply</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>All lookups for id on dev will instead be conducted for alias_id on
alias_dev.</p>
</div>
<dl class="function">
<dt id="c.regulator_unregister_supply_alias">
void <code class="sig-name descname">regulator_unregister_supply_alias</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_unregister_supply_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove device alias</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device that will be given as the regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>Supply name or regulator ID</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a lookup alias if one exists for id on dev.</p>
</div>
<dl class="function">
<dt id="c.regulator_bulk_register_supply_alias">
int <code class="sig-name descname">regulator_bulk_register_supply_alias</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char *const<em> *id</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *alias_dev</em>, const char *const<em> *alias_id</em>, int<em> num_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_register_supply_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>register multiple aliases</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device that will be given as the regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*id</span></code></dt><dd><p>List of supply names or regulator IDs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*alias_dev</span></code></dt><dd><p>device that should be used to lookup the supply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*alias_id</span></code></dt><dd><p>List of supply names or regulator IDs that should be used to
lookup the supply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_id</span></code></dt><dd><p>Number of aliases to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>return</strong> 0 on success, an errno on failure.</p>
<p>This helper function allows drivers to register several supply
aliases in one operation.  If any of the aliases cannot be
registered any aliases that were registered will be removed
before returning to the caller.</p>
</div>
<dl class="function">
<dt id="c.regulator_bulk_unregister_supply_alias">
void <code class="sig-name descname">regulator_bulk_unregister_supply_alias</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const char *const<em> *id</em>, int<em> num_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_unregister_supply_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister multiple aliases</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device that will be given as the regulator “consumer”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*id</span></code></dt><dd><p>List of supply names or regulator IDs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_id</span></code></dt><dd><p>Number of aliases to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to unregister several supply
aliases in one operation.</p>
</div>
<dl class="function">
<dt id="c.regulator_enable">
int <code class="sig-name descname">regulator_enable</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable regulator output</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request that the regulator be enabled with the regulator output at
the predefined voltage or current value.  Calls to <a class="reference internal" href="#c.regulator_enable" title="regulator_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_enable()</span></code></a>
must be balanced with calls to <a class="reference internal" href="#c.regulator_disable" title="regulator_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_disable()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>the output value can be set by other drivers, boot loader or may be
hardwired in the regulator.</p>
</div>
<dl class="function">
<dt id="c.regulator_disable">
int <code class="sig-name descname">regulator_disable</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable regulator output</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable the regulator output voltage or current.  Calls to
<a class="reference internal" href="#c.regulator_enable" title="regulator_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_enable()</span></code></a> must be balanced with calls to
<a class="reference internal" href="#c.regulator_disable" title="regulator_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_disable()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>this will only disable the regulator output if no other consumer
devices have it enabled, the regulator device supports disabling and
machine constraints permit this operation.</p>
</div>
<dl class="function">
<dt id="c.regulator_force_disable">
int <code class="sig-name descname">regulator_force_disable</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_force_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>force disable regulator output</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forcibly disable the regulator output voltage or current.</p>
<p><strong>NOTE</strong></p>
<p>this <em>will</em> disable the regulator output even if other consumer
devices have it enabled. This should be used for situations when device
damage will likely occur if the regulator is not disabled (e.g. over temp).</p>
</div>
<dl class="function">
<dt id="c.regulator_disable_deferred">
int <code class="sig-name descname">regulator_disable_deferred</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, int<em> ms</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_disable_deferred" title="Permalink to this definition">¶</a></dt>
<dd><p>disable regulator output with delay</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ms</span></code></dt><dd><p>milliseconds until the regulator is disabled</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Execute <a class="reference internal" href="#c.regulator_disable" title="regulator_disable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_disable()</span></code></a> on the regulator after a delay.  This
is intended for use with devices that require some time to quiesce.</p>
<p><strong>NOTE</strong></p>
<p>this will only disable the regulator output if no other consumer
devices have it enabled, the regulator device supports disabling and
machine constraints permit this operation.</p>
</div>
<dl class="function">
<dt id="c.regulator_is_enabled">
int <code class="sig-name descname">regulator_is_enabled</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_is_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>is the regulator output enabled</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns positive if the regulator driver backing the source/client
has requested that the device be enabled, zero if it hasn’t, else a
negative errno code.</p>
<p>Note that the device backing this regulator handle can have multiple
users, so it might be enabled even if <a class="reference internal" href="#c.regulator_enable" title="regulator_enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_enable()</span></code></a> was never
called for this particular source.</p>
</div>
<dl class="function">
<dt id="c.regulator_count_voltages">
int <code class="sig-name descname">regulator_count_voltages</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_count_voltages" title="Permalink to this definition">¶</a></dt>
<dd><p>count <a class="reference internal" href="#c.regulator_list_voltage" title="regulator_list_voltage"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_list_voltage()</span></code></a> selectors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of selectors, or negative errno.  Selectors are
numbered starting at zero, and typically correspond to bitfields
in hardware registers.</p>
</div>
<dl class="function">
<dt id="c.regulator_list_voltage">
int <code class="sig-name descname">regulator_list_voltage</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, unsigned<em> selector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_list_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>enumerate supported voltages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">selector</span></code></dt><dd><p>identify voltage to list</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Returns a voltage that can be passed to <strong><a class="reference internal" href="#c.regulator_set_voltage" title="regulator_set_voltage"><code class="xref c c-func docutils literal notranslate"><span class="pre">regulator_set_voltage()</span></code></a></strong>,
zero if this selector code can’t be used on this system, or a
negative errno.</p>
</div>
<dl class="function">
<dt id="c.regulator_get_hardware_vsel_register">
int <code class="sig-name descname">regulator_get_hardware_vsel_register</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, unsigned<em> *vsel_reg</em>, unsigned<em> *vsel_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_hardware_vsel_register" title="Permalink to this definition">¶</a></dt>
<dd><p>get the HW voltage selector register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">*vsel_reg</span></code></dt><dd><p>voltage selector register, output parameter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">*vsel_mask</span></code></dt><dd><p>mask for voltage selector bitfield, output parameter</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the hardware register offset and bitmask used for setting the
regulator voltage. This might be useful when configuring voltage-scaling
hardware or firmware that can make I2C requests behind the kernel’s back,
for example.</p>
<p>On success, the output parameters <strong>vsel_reg</strong> and <strong>vsel_mask</strong> are filled in
and 0 is returned, otherwise a negative errno is returned.</p>
</div>
<dl class="function">
<dt id="c.regulator_list_hardware_vsel">
int <code class="sig-name descname">regulator_list_hardware_vsel</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, unsigned<em> selector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_list_hardware_vsel" title="Permalink to this definition">¶</a></dt>
<dd><p>get the HW-specific register value for a selector</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">selector</span></code></dt><dd><p>identify voltage to list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Converts the selector to a hardware-specific voltage selector that can be
directly written to the regulator registers. The address of the voltage
register can be determined by calling <strong>regulator_get_hardware_vsel_register</strong>.</p>
<p>On error a negative errno is returned.</p>
</div>
<dl class="function">
<dt id="c.regulator_get_linear_step">
unsigned int <code class="sig-name descname">regulator_get_linear_step</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_linear_step" title="Permalink to this definition">¶</a></dt>
<dd><p>return the voltage step size between VSEL values</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the voltage step size between VSEL values for linear
regulators, or return 0 if the regulator isn’t a linear regulator.</p>
</div>
<dl class="function">
<dt id="c.regulator_is_supported_voltage">
int <code class="sig-name descname">regulator_is_supported_voltage</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, int<em> min_uV</em>, int<em> max_uV</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_is_supported_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a voltage range can be supported</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>Regulator to check.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_uV</span></code></dt><dd><p>Minimum required voltage in uV.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_uV</span></code></dt><dd><p>Maximum required voltage in uV.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a boolean.</p>
</div>
<dl class="function">
<dt id="c.regulator_set_voltage">
int <code class="sig-name descname">regulator_set_voltage</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, int<em> min_uV</em>, int<em> max_uV</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>set regulator output voltage</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_uV</span></code></dt><dd><p>Minimum required voltage in uV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_uV</span></code></dt><dd><p>Maximum acceptable voltage in uV</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets a voltage regulator to the desired output voltage. This can be set
during any regulator state. IOW, regulator can be disabled or enabled.</p>
<p>If the regulator is enabled then the voltage will change to the new value
immediately otherwise if the regulator is disabled the regulator will
output at the new voltage when enabled.</p>
<p><strong>NOTE</strong></p>
<p>If the regulator is shared between several devices then the lowest
request voltage that meets the system constraints will be used.
Regulator system constraints must be set for this regulator before
calling this function otherwise this call will fail.</p>
</div>
<dl class="function">
<dt id="c.regulator_set_voltage_time">
int <code class="sig-name descname">regulator_set_voltage_time</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, int<em> old_uV</em>, int<em> new_uV</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_voltage_time" title="Permalink to this definition">¶</a></dt>
<dd><p>get raise/fall time</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">old_uV</span></code></dt><dd><p>starting voltage in microvolts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new_uV</span></code></dt><dd><p>target voltage in microvolts</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provided with the starting and ending voltage, this function attempts to
calculate the time in microseconds required to rise or fall to this new
voltage.</p>
</div>
<dl class="function">
<dt id="c.regulator_set_voltage_time_sel">
int <code class="sig-name descname">regulator_set_voltage_time_sel</code><span class="sig-paren">(</span>struct regulator_dev<em> *rdev</em>, unsigned int<em> old_selector</em>, unsigned int<em> new_selector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_voltage_time_sel" title="Permalink to this definition">¶</a></dt>
<dd><p>get raise/fall time</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*rdev</span></code></dt><dd><p>regulator source device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">old_selector</span></code></dt><dd><p>selector for starting voltage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">new_selector</span></code></dt><dd><p>selector for target voltage</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provided with the starting and target voltage selectors, this function
returns time in microseconds required to rise or fall to this new voltage</p>
<p>Drivers providing ramp_delay in regulation_constraints can use this as their
set_voltage_time_sel() operation.</p>
</div>
<dl class="function">
<dt id="c.regulator_sync_voltage">
int <code class="sig-name descname">regulator_sync_voltage</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_sync_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>re-apply last regulator output voltage</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Re-apply the last configured voltage.  This is intended to be used
where some external control source the consumer is cooperating with
has caused the configured voltage to change.</p>
</div>
<dl class="function">
<dt id="c.regulator_get_voltage">
int <code class="sig-name descname">regulator_get_voltage</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator output voltage</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the current regulator voltage in uV.</p>
<p><strong>NOTE</strong></p>
<p>If the regulator is disabled it will return the voltage value. This
function should not be used to determine regulator state.</p>
</div>
<dl class="function">
<dt id="c.regulator_set_current_limit">
int <code class="sig-name descname">regulator_set_current_limit</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, int<em> min_uA</em>, int<em> max_uA</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_current_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>set regulator output current limit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">min_uA</span></code></dt><dd><p>Minimum supported current in uA</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_uA</span></code></dt><dd><p>Maximum supported current in uA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets current sink to the desired output current. This can be set during
any regulator state. IOW, regulator can be disabled or enabled.</p>
<p>If the regulator is enabled then the current will change to the new value
immediately otherwise if the regulator is disabled the regulator will
output at the new current when enabled.</p>
<p><strong>NOTE</strong></p>
<p>Regulator system constraints must be set for this regulator before
calling this function otherwise this call will fail.</p>
</div>
<dl class="function">
<dt id="c.regulator_get_current_limit">
int <code class="sig-name descname">regulator_get_current_limit</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_current_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator output current</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the current supplied by the specified current sink in uA.</p>
<p><strong>NOTE</strong></p>
<p>If the regulator is disabled it will return the current value. This
function should not be used to determine regulator state.</p>
</div>
<dl class="function">
<dt id="c.regulator_set_mode">
int <code class="sig-name descname">regulator_set_mode</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, unsigned int<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>set regulator operating mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>operating mode - one of the REGULATOR_MODE constants</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set regulator operating mode to increase regulator efficiency or improve
regulation performance.</p>
<p><strong>NOTE</strong></p>
<p>Regulator system constraints must be set for this regulator before
calling this function otherwise this call will fail.</p>
</div>
<dl class="function">
<dt id="c.regulator_get_mode">
unsigned int <code class="sig-name descname">regulator_get_mode</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator operating mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the current regulator operating mode.</p>
</div>
<dl class="function">
<dt id="c.regulator_get_error_flags">
int <code class="sig-name descname">regulator_get_error_flags</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, unsigned int<em> *flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_error_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator error information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*flags</span></code></dt><dd><p>pointer to store error flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the current regulator error information.</p>
</div>
<dl class="function">
<dt id="c.regulator_set_load">
int <code class="sig-name descname">regulator_set_load</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, int<em> uA_load</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_load" title="Permalink to this definition">¶</a></dt>
<dd><p>set regulator load</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">uA_load</span></code></dt><dd><p>load current</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notifies the regulator core of a new device load. This is then used by
DRMS (if enabled by constraints) to set the most efficient regulator
operating mode for the new regulator loading.</p>
<p>Consumer devices notify their supply regulator of the maximum power
they will require (can be taken from device datasheet in the power
consumption tables) when they change operational status and hence power
state. Examples of operational state changes that can affect power
consumption are :-</p>
<blockquote>
<div><p>o Device is opened / closed.
o Device I/O is about to begin or has just finished.
o Device is idling in between work.</p>
</div></blockquote>
<p>This information is also exported via sysfs to userspace.</p>
<p>DRMS will sum the total requested load on the regulator and change
to the most efficient operating mode if platform constraints allow.</p>
<p>If a regulator is an always-on regulator then an individual consumer’s
load will still be removed if that consumer is fully disabled.</p>
<p>On error a negative errno is returned.</p>
<p><strong>NOTE</strong></p>
<p>when a regulator consumer requests to have a regulator
disabled then any load that consumer requested no longer counts
toward the total requested load.  If the regulator is re-enabled
then the previously requested load will start counting again.</p>
</div>
<dl class="function">
<dt id="c.regulator_allow_bypass">
int <code class="sig-name descname">regulator_allow_bypass</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_allow_bypass" title="Permalink to this definition">¶</a></dt>
<dd><p>allow the regulator to go into bypass mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>Regulator to configure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>enable or disable bypass mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow the regulator to go into bypass mode if all other consumers
for the regulator also enable bypass mode and the machine
constraints allow this.  Bypass mode means that the regulator is
simply passing the input directly to the output with no regulation.</p>
</div>
<dl class="function">
<dt id="c.regulator_register_notifier">
int <code class="sig-name descname">regulator_register_notifier</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, struct notifier_block<em> *nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_register_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>register regulator event notifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>notifier block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register notifier block to receive regulator events.</p>
</div>
<dl class="function">
<dt id="c.regulator_unregister_notifier">
int <code class="sig-name descname">regulator_unregister_notifier</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, struct notifier_block<em> *nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_unregister_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister regulator event notifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>notifier block</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister regulator event notifier block.</p>
</div>
<dl class="function">
<dt id="c.regulator_bulk_get">
int <code class="sig-name descname">regulator_bulk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, int<em> num_consumers</em>, struct <a class="reference internal" href="#c.regulator_bulk_data" title="regulator_bulk_data">regulator_bulk_data</a><em> *consumers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get multiple regulator consumers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to supply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_consumers</span></code></dt><dd><p>Number of consumers to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_bulk_data</span> <span class="pre">*consumers</span></code></dt><dd><p>Configuration of consumers; clients are stored here.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>return</strong> 0 on success, an errno on failure.</p>
<p>This helper function allows drivers to get several regulator
consumers in one operation.  If any of the regulators cannot be
acquired then any regulators that were allocated will be freed
before returning to the caller.</p>
</div>
<dl class="function">
<dt id="c.regulator_bulk_enable">
int <code class="sig-name descname">regulator_bulk_enable</code><span class="sig-paren">(</span>int<em> num_consumers</em>, struct <a class="reference internal" href="#c.regulator_bulk_data" title="regulator_bulk_data">regulator_bulk_data</a><em> *consumers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable multiple regulator consumers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_consumers</span></code></dt><dd><p>Number of consumers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_bulk_data</span> <span class="pre">*consumers</span></code></dt><dd><p>Consumer data; clients are stored here.
<strong>return</strong>         0 on success, an errno on failure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This convenience API allows consumers to enable multiple regulator
clients in a single API call.  If any consumers cannot be enabled
then any others that were enabled will be disabled again prior to
return.</p>
</div>
<dl class="function">
<dt id="c.regulator_bulk_disable">
int <code class="sig-name descname">regulator_bulk_disable</code><span class="sig-paren">(</span>int<em> num_consumers</em>, struct <a class="reference internal" href="#c.regulator_bulk_data" title="regulator_bulk_data">regulator_bulk_data</a><em> *consumers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable multiple regulator consumers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_consumers</span></code></dt><dd><p>Number of consumers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_bulk_data</span> <span class="pre">*consumers</span></code></dt><dd><p>Consumer data; clients are stored here.
<strong>return</strong>         0 on success, an errno on failure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This convenience API allows consumers to disable multiple regulator
clients in a single API call.  If any consumers cannot be disabled
then any others that were disabled will be enabled again prior to
return.</p>
</div>
<dl class="function">
<dt id="c.regulator_bulk_force_disable">
int <code class="sig-name descname">regulator_bulk_force_disable</code><span class="sig-paren">(</span>int<em> num_consumers</em>, struct <a class="reference internal" href="#c.regulator_bulk_data" title="regulator_bulk_data">regulator_bulk_data</a><em> *consumers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_force_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>force disable multiple regulator consumers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_consumers</span></code></dt><dd><p>Number of consumers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_bulk_data</span> <span class="pre">*consumers</span></code></dt><dd><p>Consumer data; clients are stored here.
<strong>return</strong>         0 on success, an errno on failure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This convenience API allows consumers to forcibly disable multiple regulator
clients in a single API call.</p>
<p><strong>NOTE</strong></p>
<p>This should be used for situations when device damage will
likely occur if the regulators are not disabled (e.g. over temp).
Although regulator_force_disable function call for some consumers can
return error numbers, the function is called for all consumers.</p>
</div>
<dl class="function">
<dt id="c.regulator_bulk_free">
void <code class="sig-name descname">regulator_bulk_free</code><span class="sig-paren">(</span>int<em> num_consumers</em>, struct <a class="reference internal" href="#c.regulator_bulk_data" title="regulator_bulk_data">regulator_bulk_data</a><em> *consumers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_bulk_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free multiple regulator consumers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_consumers</span></code></dt><dd><p>Number of consumers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_bulk_data</span> <span class="pre">*consumers</span></code></dt><dd><p>Consumer data; clients are stored here.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This convenience API allows consumers to free multiple regulator
clients in a single API call.</p>
</div>
<dl class="function">
<dt id="c.regulator_notifier_call_chain">
int <code class="sig-name descname">regulator_notifier_call_chain</code><span class="sig-paren">(</span>struct regulator_dev<em> *rdev</em>, unsigned long<em> event</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_notifier_call_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>call regulator event notifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*rdev</span></code></dt><dd><p>regulator source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">event</span></code></dt><dd><p>notifier block</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>callback-specific data.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by regulator drivers to notify clients a regulator event has
occurred.</p>
</div>
<dl class="function">
<dt id="c.regulator_mode_to_status">
int <code class="sig-name descname">regulator_mode_to_status</code><span class="sig-paren">(</span>unsigned int<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_mode_to_status" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a regulator mode into a status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>Mode to convert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convert a regulator mode into a status.</p>
</div>
<dl class="function">
<dt id="c.regulator_register">
struct regulator_dev * <code class="sig-name descname">regulator_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct <a class="reference internal" href="#c.regulator_desc" title="regulator_desc">regulator_desc</a><em> *regulator_desc</em>, const struct <a class="reference internal" href="#c.regulator_config" title="regulator_config">regulator_config</a><em> *cfg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register regulator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device that drive the regulator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">regulator_desc</span> <span class="pre">*regulator_desc</span></code></dt><dd><p>regulator to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">regulator_config</span> <span class="pre">*cfg</span></code></dt><dd><p>runtime configuration for regulator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by regulator drivers to register a regulator.
Returns a valid pointer to struct regulator_dev on success
or an ERR_PTR() on error.</p>
</div>
<dl class="function">
<dt id="c.regulator_unregister">
void <code class="sig-name descname">regulator_unregister</code><span class="sig-paren">(</span>struct regulator_dev<em> *rdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister regulator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*rdev</span></code></dt><dd><p>regulator to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by regulator drivers to unregister a regulator.</p>
</div>
<dl class="function">
<dt id="c.regulator_has_full_constraints">
void <code class="sig-name descname">regulator_has_full_constraints</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_has_full_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>the system has fully specified constraints</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will cause the regulator API to disable all
regulators which have a zero use count and don’t have an always_on
constraint in a late_initcall.</p>
<p>The intention is that this will become the default behaviour in a
future kernel release so users are encouraged to use this facility
now.</p>
</div>
<dl class="function">
<dt id="c.rdev_get_drvdata">
void * <code class="sig-name descname">rdev_get_drvdata</code><span class="sig-paren">(</span>struct regulator_dev<em> *rdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdev_get_drvdata" title="Permalink to this definition">¶</a></dt>
<dd><p>get rdev regulator driver data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*rdev</span></code></dt><dd><p>regulator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get rdev regulator driver private data. This call can be used in the
regulator driver context.</p>
</div>
<dl class="function">
<dt id="c.regulator_get_drvdata">
void * <code class="sig-name descname">regulator_get_drvdata</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_get_drvdata" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator driver data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get regulator driver private data. This call can be used in the consumer
driver context when non API regulator specific functions need to be called.</p>
</div>
<dl class="function">
<dt id="c.regulator_set_drvdata">
void <code class="sig-name descname">regulator_set_drvdata</code><span class="sig-paren">(</span>struct regulator<em> *regulator</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.regulator_set_drvdata" title="Permalink to this definition">¶</a></dt>
<dd><p>set regulator driver data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator</span> <span class="pre">*regulator</span></code></dt><dd><p>regulator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rdev_get_id">
int <code class="sig-name descname">rdev_get_id</code><span class="sig-paren">(</span>struct regulator_dev<em> *rdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rdev_get_id" title="Permalink to this definition">¶</a></dt>
<dd><p>get regulator ID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regulator_dev</span> <span class="pre">*rdev</span></code></dt><dd><p>regulator</p>
</dd>
</dl>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Voltage and current regulator API</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#glossary">Glossary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#consumer-driver-interface">Consumer driver interface</a><ul>
<li><a class="reference internal" href="#enabling-and-disabling">Enabling and disabling</a></li>
<li><a class="reference internal" href="#configuration">Configuration</a></li>
<li><a class="reference internal" href="#callbacks">Callbacks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regulator-driver-interface">Regulator driver interface</a></li>
<li><a class="reference internal" href="#machine-interface">Machine interface</a><ul>
<li><a class="reference internal" href="#supplies">Supplies</a></li>
<li><a class="reference internal" href="#constraints">Constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api-reference">API reference</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/regulator.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/regulator.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>