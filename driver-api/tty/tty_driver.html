
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>TTY Driver and TTY Operations &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="TTY Port" href="tty_port.html" />
    <link rel="prev" title="TTY" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="tty-driver-and-tty-operations">
<h1>TTY Driver and TTY Operations<a class="headerlink" href="#tty-driver-and-tty-operations" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#allocation" id="id1">Allocation</a></p>
<ul>
<li><p><a class="reference internal" href="#tty-driver-flags" id="id2">TTY Driver Flags</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#registration" id="id3">Registration</a></p>
<ul>
<li><p><a class="reference internal" href="#registering-devices" id="id4">Registering Devices</a></p></li>
<li><p><a class="reference internal" href="#linking-devices-to-ports" id="id5">Linking Devices to Ports</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tty-driver-reference" id="id6">TTY Driver Reference</a></p></li>
<li><p><a class="reference internal" href="#tty-operations-reference" id="id7">TTY Operations Reference</a></p></li>
</ul>
</div>
<section id="allocation">
<h2><a class="toc-backref" href="#id1">Allocation</a><a class="headerlink" href="#allocation" title="Permalink to this headline">¶</a></h2>
<p>The first thing a driver needs to do is to allocate a <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a>. This
is done by tty_alloc_driver() (or <a class="reference internal" href="#c.__tty_alloc_driver" title="__tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">__tty_alloc_driver()</span></code></a>). Next, the newly
allocated structure is filled with information. See <a class="reference internal" href="#tty-driver-reference">TTY Driver Reference</a> at
the end of this document on what actually shall be filled in.</p>
<p>The allocation routines expect a number of devices the driver can handle at
most and flags. Flags are those starting <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_</span></code> listed and described
in <a class="reference internal" href="#tty-driver-flags">TTY Driver Flags</a> below.</p>
<p>When the driver is about to be freed, <a class="reference internal" href="#c.tty_driver_kref_put" title="tty_driver_kref_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_driver_kref_put()</span></code></a> is called on that.
It will decrements the reference count and if it reaches zero, the driver is
freed.</p>
<p>For reference, both allocation and deallocation functions are explained here in
detail:</p>
<dl class="function">
<dt id="c.__tty_alloc_driver">
struct <a class="reference internal" href="#c.tty_driver" title="tty_driver">tty_driver</a> * <code class="sig-name descname">__tty_alloc_driver</code><span class="sig-paren">(</span>unsigned int<em> lines</em>, struct module<em> *owner</em>, unsigned long<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__tty_alloc_driver" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>allocate tty driver</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">lines</span></code></dt><dd><p>count of lines this driver can handle at most</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module which is responsible for this driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>some of <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_</span></code> flags, will be set in driver-&gt;flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should not be called directly, some of the provided macros should be
used instead. Use IS_ERR() and friends on <strong>retval</strong>.</p>
</div>
<dl class="function">
<dt id="c.tty_driver_kref_put">
void <code class="sig-name descname">tty_driver_kref_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tty_driver" title="tty_driver">tty_driver</a><em> *driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_driver_kref_put" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>drop a reference to a tty driver</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>driver of which to drop the reference</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The final put will destroy and free up the driver.</p>
</div>
<section id="tty-driver-flags">
<h3><a class="toc-backref" href="#id2">TTY Driver Flags</a><a class="headerlink" href="#tty-driver-flags" title="Permalink to this headline">¶</a></h3>
<p>Here comes the documentation of flags accepted by tty_alloc_driver() (or
<a class="reference internal" href="#c.__tty_alloc_driver" title="__tty_alloc_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">__tty_alloc_driver()</span></code></a>):</p>
<dl>
<dt>TTY_DRIVER_RESET_TERMIOS</dt><dd><p>Requests the tty layer to reset the termios setting when the last
process has closed the device. Used for PTYs, in particular.</p>
</dd>
<dt>TTY_DRIVER_REAL_RAW</dt><dd><p>Indicates that the driver will guarantee not to set any special
character handling flags if this is set for the tty:</p>
<p><code class="docutils literal notranslate"><span class="pre">(IGNBRK</span> <span class="pre">||</span> <span class="pre">(!BRKINT</span> <span class="pre">&amp;&amp;</span> <span class="pre">!PARMRK))</span> <span class="pre">&amp;&amp;</span> <span class="pre">(IGNPAR</span> <span class="pre">||</span> <span class="pre">!INPCK)</span></code></p>
<p>That is, if there is no reason for the driver to
send notifications of parity and break characters up to the line
driver, it won’t do so.  This allows the line driver to optimize for
this case if this flag is set.  (Note that there is also a promise, if
the above case is true, not to signal overruns, either.)</p>
</dd>
<dt>TTY_DRIVER_DYNAMIC_DEV</dt><dd><p>The individual tty devices need to be registered with a call to
<a class="reference internal" href="#c.tty_register_device" title="tty_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device()</span></code></a> when the device is found in the system and
unregistered with a call to <a class="reference internal" href="#c.tty_unregister_device" title="tty_unregister_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_unregister_device()</span></code></a> so the devices will
be show up properly in sysfs.  If not set, all <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">tty_driver.num</span></code></a> entries
will be created by the tty core in sysfs when <a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a> is
called.  This is to be used by drivers that have tty devices that can
appear and disappear while the main tty driver is registered with the
tty core.</p>
</dd>
<dt>TTY_DRIVER_DEVPTS_MEM</dt><dd><p>Don’t use the standard arrays (<a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">tty_driver.ttys</span></code></a> and
<a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">tty_driver.termios</span></code></a>), instead use dynamic memory keyed through the
devpts filesystem. This is only applicable to the PTY driver.</p>
</dd>
<dt>TTY_DRIVER_HARDWARE_BREAK</dt><dd><p>Hardware handles break signals. Pass the requested timeout to the
<a class="reference internal" href="#c.tty_operations" title="tty_operations"><code class="xref c c-type docutils literal notranslate"><span class="pre">tty_operations.break_ctl</span></code></a> instead of using a simple on/off interface.</p>
</dd>
<dt>TTY_DRIVER_DYNAMIC_ALLOC</dt><dd><p>Do not allocate structures which are needed per line for this driver
(<a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">tty_driver.ports</span></code></a>) as it would waste memory. The driver will take
care. This is only applicable to the PTY driver.</p>
</dd>
<dt>TTY_DRIVER_UNNUMBERED_NODE</dt><dd><p>Do not create numbered <code class="docutils literal notranslate"><span class="pre">/dev</span></code> nodes. For example, create
<code class="docutils literal notranslate"><span class="pre">/dev/ttyprintk</span></code> and not <code class="docutils literal notranslate"><span class="pre">/dev/ttyprintk0</span></code>. Applicable only when a
driver for a single tty device is being allocated.</p>
</dd>
</dl>
</section>
</section>
<hr class="docutils" />
<section id="registration">
<h2><a class="toc-backref" href="#id3">Registration</a><a class="headerlink" href="#registration" title="Permalink to this headline">¶</a></h2>
<p>When a <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a> is allocated and filled in, it can be registered using
<a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a>. It is recommended to pass <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_DYNAMIC_DEV</span></code> in
flags of tty_alloc_driver(). If it is not passed, <em>all</em> devices are also
registered during <a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a> and the following paragraph of
registering devices can be skipped for such drivers. However, the <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">tty_port</span></code></a> part in <a class="reference internal" href="#registering-devices">Registering Devices</a> is still relevant there.</p>
<dl class="function">
<dt id="c.tty_register_driver">
int <code class="sig-name descname">tty_register_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tty_driver" title="tty_driver">tty_driver</a><em> *driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>register a tty driver</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>driver to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a tty driver to register itself.</p>
</div>
<dl class="function">
<dt id="c.tty_unregister_driver">
void <code class="sig-name descname">tty_unregister_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tty_driver" title="tty_driver">tty_driver</a><em> *driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>unregister a tty driver</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>driver to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a tty driver to unregister itself.</p>
</div>
<section id="registering-devices">
<h3><a class="toc-backref" href="#id4">Registering Devices</a><a class="headerlink" href="#registering-devices" title="Permalink to this headline">¶</a></h3>
<p>Every TTY device shall be backed by a <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span></code></a>. Usually, TTY drivers
embed tty_port into device’s private structures. Further details about handling
tty_port can be found in <a class="reference internal" href="tty_port.html"><span class="doc">TTY Port</span></a>. The driver is also recommended to use
tty_port’s reference counting by tty_port_get() and <a class="reference internal" href="tty_port.html#c.tty_port_put" title="tty_port_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_put()</span></code></a>. The final
put is supposed to free the tty_port including the device’s private struct.</p>
<p>Unless <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_DYNAMIC_DEV</span></code> was passed as flags to tty_alloc_driver(),
TTY driver is supposed to register every device discovered in the system
(the latter is preferred). This is performed by <a class="reference internal" href="#c.tty_register_device" title="tty_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device()</span></code></a>. Or by
<a class="reference internal" href="#c.tty_register_device_attr" title="tty_register_device_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device_attr()</span></code></a> if the driver wants to expose some information
through struct attribute_group. Both of them register <code class="docutils literal notranslate"><span class="pre">index</span></code>’th device and
upon return, the device can be opened. There are also preferred tty_port
variants described in <a class="reference internal" href="#linking-devices-to-ports">Linking Devices to Ports</a> later. It is up to driver to
manage free indices and choosing the right one. The TTY layer only refuses to
register more devices than passed to tty_alloc_driver().</p>
<p>When the device is opened, the TTY layer allocates <a class="reference internal" href="tty_struct.html#c.tty_struct" title="tty_struct"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_struct</span></code></a> and starts
calling operations from <code class="xref c c-member docutils literal notranslate"><span class="pre">tty_driver.ops</span></code>, see <a class="reference internal" href="#tty-operations-reference">TTY Operations
Reference</a>.</p>
<p>The registration routines are documented as follows:</p>
<dl class="function">
<dt id="c.tty_register_device">
struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> * <code class="sig-name descname">tty_register_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tty_driver" title="tty_driver">tty_driver</a><em> *driver</em>, unsigned<em> index</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register a tty device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the tty driver that describes the tty device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>the index in the tty driver for this tty device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>a <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> that is associated with this tty device.
This field is optional, if there is no known <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>
for this tty device it can be set to NULL safely.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call is required to be made to register an individual tty device
if the tty driver’s flags have the <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_DYNAMIC_DEV</span></code> bit set.  If
that bit is not set, this function should not be called by a tty
driver.</p>
<p>Locking: ??</p>
<p><strong>Return</strong></p>
<p>A pointer to the <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> for this tty device (or
ERR_PTR(-EFOO) on error).</p>
</div>
<dl class="function">
<dt id="c.tty_register_device_attr">
struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> * <code class="sig-name descname">tty_register_device_attr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tty_driver" title="tty_driver">tty_driver</a><em> *driver</em>, unsigned<em> index</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *device</em>, void<em> *drvdata</em>, const struct attribute_group<em> **attr_grp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_register_device_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>register a tty device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the tty driver that describes the tty device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>the index in the tty driver for this tty device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>a <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> that is associated with this tty device.
This field is optional, if there is no known <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>
for this tty device it can be set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code> safely.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*drvdata</span></code></dt><dd><p>Driver data to be set to device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**attr_grp</span></code></dt><dd><p>Attribute group to be set on device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call is required to be made to register an individual tty device if the
tty driver’s flags have the <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_DYNAMIC_DEV</span></code> bit set. If that bit is
not set, this function should not be called by a tty driver.</p>
<p>Locking: ??</p>
<p><strong>Return</strong></p>
<p>A pointer to the <a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> for this tty device (or
ERR_PTR(-EFOO) on error).</p>
</div>
<dl class="function">
<dt id="c.tty_unregister_device">
void <code class="sig-name descname">tty_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.tty_driver" title="tty_driver">tty_driver</a><em> *driver</em>, unsigned<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a tty device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>the tty driver that describes the tty device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>the index in the tty driver for this tty device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a tty device is registered with a call to <a class="reference internal" href="#c.tty_register_device" title="tty_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device()</span></code></a> then
this function must be called when the tty device is gone.</p>
<p>Locking: ??</p>
</div>
</section>
<hr class="docutils" />
<section id="linking-devices-to-ports">
<h3><a class="toc-backref" href="#id5">Linking Devices to Ports</a><a class="headerlink" href="#linking-devices-to-ports" title="Permalink to this headline">¶</a></h3>
<p>As stated earlier, every TTY device shall have a <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span></code></a> assigned to
it. It must be known to the TTY layer at <code class="xref c c-member docutils literal notranslate"><span class="pre">tty_driver.ops.install()</span></code>
at latest.  There are few helpers to <em>link</em> the two. Ideally, the driver uses
<a class="reference internal" href="#c.tty_port_register_device" title="tty_port_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_register_device()</span></code></a> or <a class="reference internal" href="#c.tty_port_register_device_attr" title="tty_port_register_device_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_register_device_attr()</span></code></a> instead of
<a class="reference internal" href="#c.tty_register_device" title="tty_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device()</span></code></a> and <a class="reference internal" href="#c.tty_register_device_attr" title="tty_register_device_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device_attr()</span></code></a> at the registration time.
This way, the driver needs not care about linking later on.</p>
<p>If that is not possible, the driver still can link the tty_port to a specific
index <em>before</em> the actual registration by <a class="reference internal" href="#c.tty_port_link_device" title="tty_port_link_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_link_device()</span></code></a>. If it still
does not fit, <a class="reference internal" href="tty_port.html#c.tty_port_install" title="tty_port_install"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_install()</span></code></a> can be used from the
<code class="xref c c-member docutils literal notranslate"><span class="pre">tty_driver.ops.install</span></code> hook as a last resort. The last one is
dedicated mostly for in-memory devices like PTY where tty_ports are allocated
on demand.</p>
<p>The linking routines are documented here:</p>
<dl class="function">
<dt id="c.tty_port_link_device">
void <code class="sig-name descname">tty_port_link_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port">tty_port</a><em> *port</em>, struct <a class="reference internal" href="#c.tty_driver" title="tty_driver">tty_driver</a><em> *driver</em>, unsigned<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_port_link_device" title="Permalink to this definition">¶</a></dt>
<dd><p>link tty and tty_port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span> <span class="pre">*port</span></code></dt><dd><p>tty_port of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>tty_driver for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>index of the tty</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provide the tty layer with a link from a tty (specified by <strong>index</strong>) to a
tty_port (<strong>port</strong>). Use this only if neither <a class="reference internal" href="#c.tty_port_register_device" title="tty_port_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_register_device()</span></code></a> nor
<a class="reference internal" href="tty_port.html#c.tty_port_install" title="tty_port_install"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_install()</span></code></a> is used in the driver. If used, this has to be called
before <a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.tty_port_register_device">
struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> * <code class="sig-name descname">tty_port_register_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port">tty_port</a><em> *port</em>, struct <a class="reference internal" href="#c.tty_driver" title="tty_driver">tty_driver</a><em> *driver</em>, unsigned<em> index</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_port_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register tty device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span> <span class="pre">*port</span></code></dt><dd><p>tty_port of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>tty_driver for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>index of the tty</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>parent if exists, otherwise NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the same as <a class="reference internal" href="#c.tty_register_device" title="tty_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device()</span></code></a> except the provided <strong>port</strong> is linked
to a concrete tty specified by <strong>index</strong>. Use this or <a class="reference internal" href="tty_port.html#c.tty_port_install" title="tty_port_install"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_install()</span></code></a> (or
both). Call <a class="reference internal" href="#c.tty_port_link_device" title="tty_port_link_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_link_device()</span></code></a> as a last resort.</p>
</div>
<dl class="function">
<dt id="c.tty_port_register_device_attr">
struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> * <code class="sig-name descname">tty_port_register_device_attr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port">tty_port</a><em> *port</em>, struct <a class="reference internal" href="#c.tty_driver" title="tty_driver">tty_driver</a><em> *driver</em>, unsigned<em> index</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *device</em>, void<em> *drvdata</em>, const struct attribute_group<em> **attr_grp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tty_port_register_device_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>register tty device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span> <span class="pre">*port</span></code></dt><dd><p>tty_port of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver</span></code></dt><dd><p>tty_driver for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">index</span></code></dt><dd><p>index of the tty</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>parent if exists, otherwise NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*drvdata</span></code></dt><dd><p>Driver data to be set to device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**attr_grp</span></code></dt><dd><p>Attribute group to be set on device.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the same as <a class="reference internal" href="#c.tty_register_device_attr" title="tty_register_device_attr"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_device_attr()</span></code></a> except the provided <strong>port</strong> is
linked to a concrete tty specified by <strong>index</strong>. Use this or <a class="reference internal" href="tty_port.html#c.tty_port_install" title="tty_port_install"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_install()</span></code></a>
(or both). Call <a class="reference internal" href="#c.tty_port_link_device" title="tty_port_link_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_link_device()</span></code></a> as a last resort.</p>
</div>
</section>
</section>
<hr class="docutils" />
<section id="tty-driver-reference">
<h2><a class="toc-backref" href="#id6">TTY Driver Reference</a><a class="headerlink" href="#tty-driver-reference" title="Permalink to this headline">¶</a></h2>
<p>All members of <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a> are documented here. The required members are
noted at the end. <a class="reference internal" href="#c.tty_operations" title="tty_operations"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_operations</span></code></a> are documented next.</p>
<dl class="type">
<dt id="c.tty_driver">
struct <code class="sig-name descname">tty_driver</code><a class="headerlink" href="#c.tty_driver" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>driver for TTY devices</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tty_driver {
    struct kref kref;
    struct cdev **cdevs;
    struct module   *owner;
    const char      *driver_name;
    const char      *name;
    int name_base;
    int major;
    int minor_start;
    unsigned int    num;
    short type;
    short subtype;
    struct ktermios init_termios;
    unsigned long   flags;
    struct proc_dir_entry *proc_entry;
    struct tty_driver *other;
    struct tty_struct **ttys;
    struct tty_port **ports;
    struct ktermios **termios;
    void *driver_state;
    const struct tty_operations *ops;
    struct list_head tty_drivers;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">kref</span></code></dt><dd><p>reference counting. Reaching zero frees all the internals and the
driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cdevs</span></code></dt><dd><p>allocated/registered character /dev devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>modules owning this driver. Used drivers cannot be rmmod’ed.
Automatically set by tty_alloc_driver().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_name</span></code></dt><dd><p>name of the driver used in /proc/tty</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>used for constructing /dev node name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name_base</span></code></dt><dd><p>used as a number base for constructing /dev node name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">major</span></code></dt><dd><p>major /dev device number (zero for autoassignment)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minor_start</span></code></dt><dd><p>the first minor /dev device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num</span></code></dt><dd><p>number of devices allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>type of tty driver (<code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_TYPE_</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subtype</span></code></dt><dd><p>subtype of tty driver (<code class="docutils literal notranslate"><span class="pre">SYSTEM_TYPE_</span></code>, <code class="docutils literal notranslate"><span class="pre">PTY_TYPE_</span></code>, <code class="docutils literal notranslate"><span class="pre">SERIAL_TYPE_</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_termios</span></code></dt><dd><p>termios to set to each tty initially (e.g. <code class="docutils literal notranslate"><span class="pre">tty_std_termios</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>tty driver flags (<code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proc_entry</span></code></dt><dd><p>proc fs entry, used internally</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">other</span></code></dt><dd><p>driver of the linked tty; only used for the PTY driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ttys</span></code></dt><dd><p>array of active <a class="reference internal" href="tty_struct.html#c.tty_struct" title="tty_struct"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_struct</span></code></a>, set by <a class="reference internal" href="tty_struct.html#c.tty_standard_install" title="tty_standard_install"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_standard_install()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ports</span></code></dt><dd><p>array of <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_port</span></code></a>; can be set during initialization by
<a class="reference internal" href="#c.tty_port_link_device" title="tty_port_link_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_port_link_device()</span></code></a> and similar</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">termios</span></code></dt><dd><p>storage for termios at each TTY close for the next open</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_state</span></code></dt><dd><p>pointer to driver’s arbitrary data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>driver hooks for TTYs. Set them using tty_set_operations(). Use <a class="reference internal" href="tty_port.html#c.tty_port" title="tty_port"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">tty_port</span></code></a> helpers in them as much as possible.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tty_drivers</span></code></dt><dd><p>used internally to link tty_drivers together</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The usual handling of <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a> is to allocate it by
tty_alloc_driver(), set up all the necessary members, and register it by
<a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a>. At last, the driver is torn down by calling
<a class="reference internal" href="#c.tty_unregister_driver" title="tty_unregister_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_unregister_driver()</span></code></a> followed by <a class="reference internal" href="#c.tty_driver_kref_put" title="tty_driver_kref_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_driver_kref_put()</span></code></a>.</p>
<p>The fields required to be set before calling <a class="reference internal" href="#c.tty_register_driver" title="tty_register_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_register_driver()</span></code></a> include
<strong>driver_name</strong>, <strong>name</strong>, <strong>type</strong>, <strong>subtype</strong>, <strong>init_termios</strong>, and <strong>ops</strong>.</p>
</section>
<hr class="docutils" />
<section id="tty-operations-reference">
<h2><a class="toc-backref" href="#id7">TTY Operations Reference</a><a class="headerlink" href="#tty-operations-reference" title="Permalink to this headline">¶</a></h2>
<p>When a TTY is registered, these driver hooks can be invoked by the TTY layer:</p>
<dl class="type">
<dt id="c.tty_operations">
struct <code class="sig-name descname">tty_operations</code><a class="headerlink" href="#c.tty_operations" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li><p>interface between driver and tty</p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tty_operations {
    struct tty_struct * (*lookup)(struct tty_driver *driver, struct file *filp, int idx);
    int (*install)(struct tty_driver *driver, struct tty_struct *tty);
    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
    int (*open)(struct tty_struct * tty, struct file * filp);
    void (*close)(struct tty_struct * tty, struct file * filp);
    void (*shutdown)(struct tty_struct *tty);
    void (*cleanup)(struct tty_struct *tty);
    int (*write)(struct tty_struct * tty, const unsigned char *buf, int count);
    int (*put_char)(struct tty_struct *tty, unsigned char ch);
    void (*flush_chars)(struct tty_struct *tty);
    unsigned int (*write_room)(struct tty_struct *tty);
    unsigned int (*chars_in_buffer)(struct tty_struct *tty);
    int (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
    long (*compat_ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
    void (*set_termios)(struct tty_struct *tty, const struct ktermios *old);
    void (*throttle)(struct tty_struct * tty);
    void (*unthrottle)(struct tty_struct * tty);
    void (*stop)(struct tty_struct *tty);
    void (*start)(struct tty_struct *tty);
    void (*hangup)(struct tty_struct *tty);
    int (*break_ctl)(struct tty_struct *tty, int state);
    void (*flush_buffer)(struct tty_struct *tty);
    void (*set_ldisc)(struct tty_struct *tty);
    void (*wait_until_sent)(struct tty_struct *tty, int timeout);
    void (*send_xchar)(struct tty_struct *tty, char ch);
    int (*tiocmget)(struct tty_struct *tty);
    int (*tiocmset)(struct tty_struct *tty, unsigned int set, unsigned int clear);
    int (*resize)(struct tty_struct *tty, struct winsize *ws);
    int (*get_icount)(struct tty_struct *tty, struct serial_icounter_struct *icount);
    int (*get_serial)(struct tty_struct *tty, struct serial_struct *p);
    int (*set_serial)(struct tty_struct *tty, struct serial_struct *p);
    void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);
#ifdef CONFIG_CONSOLE_POLL;
    int (*poll_init)(struct tty_driver *driver, int line, char *options);
    int (*poll_get_char)(struct tty_driver *driver, int line);
    void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
#endif;
    int (*proc_show)(struct seq_file *m, void *driver);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">lookup</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_struct</span> <span class="pre">*()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*self,</span> <span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*,</span>
<span class="pre">int</span> <span class="pre">idx)</span></code></p>
<blockquote>
<div><p>Return the tty device corresponding to <strong>idx</strong>, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there is not
one currently in use and an <code class="docutils literal notranslate"><span class="pre">ERR_PTR</span></code> value on error. Called under
<code class="docutils literal notranslate"><span class="pre">tty_mutex</span></code> (for now!)</p>
<p>Optional method. Default behaviour is to use the <strong>self-&gt;ttys</strong> array.</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">install</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*self,</span> <span class="pre">struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>Install a new <strong>tty</strong> into the <strong>self</strong>’s internal tables. Used in
conjunction with <strong>lookup</strong> and <strong>remove</strong> methods.</p>
<p>Optional method. Default behaviour is to use the <strong>self-&gt;ttys</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*self,</span> <span class="pre">struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>Remove a closed <strong>tty</strong> from the <strong>self</strong>’s internal tables. Used in
conjunction with <strong>lookup</strong> and <strong>remove</strong> methods.</p>
<p>Optional method. Default behaviour is to use the <strong>self-&gt;ttys</strong> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*)</span></code></p>
<p>This routine is called when a particular <strong>tty</strong> device is opened. This
routine is mandatory; if this routine is not filled in, the attempted
open will fail with <code class="docutils literal notranslate"><span class="pre">ENODEV</span></code>.</p>
<p>Required method. Called with tty lock held. May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">close</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*)</span></code></p>
<p>This routine is called when a particular <strong>tty</strong> device is closed. At the
point of return from this call the driver must make no further ldisc
calls of any kind.</p>
<p>Remark: called even if the corresponding <strong>open()</strong> failed.</p>
<p>Required method. Called with tty lock held. May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shutdown</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine is called under the tty lock when a particular <strong>tty</strong> device
is closed for the last time. It executes before the <strong>tty</strong> resources
are freed so may execute while another function holds a <strong>tty</strong> kref.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cleanup</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine is called asynchronously when a particular <strong>tty</strong> device
is closed for the last time freeing up the resources. This is
actually the second part of shutdown for routines that might sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buf,</span>
<span class="pre">int</span> <span class="pre">count)</span></code></p>
<blockquote>
<div><p>This routine is called by the kernel to write a series (<strong>count</strong>) of
characters (<strong>buf</strong>) to the <strong>tty</strong> device. The characters may come from
user space or kernel space.  This routine will return the
number of characters actually accepted for writing.</p>
<p>May occur in parallel in special cases. Because this includes panic
paths drivers generally shouldn’t try and do clever locking here.</p>
<p>Optional: Required for writable devices. May not sleep.</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">put_char</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">ch)</span></code></p>
<p>This routine is called by the kernel to write a single character <strong>ch</strong> to
the <strong>tty</strong> device. If the kernel uses this routine, it must call the
<strong>flush_chars()</strong> routine (if defined) when it is done stuffing characters
into the driver. If there is no room in the queue, the character is
ignored.</p>
<p>Optional: Kernel will use the <strong>write</strong> method if not provided. Do not
call this function directly, call <a class="reference internal" href="tty_struct.html#c.tty_put_char" title="tty_put_char"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_put_char()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flush_chars</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine is called by the kernel after it has written a
series of characters to the tty device using <strong>put_char()</strong>.</p>
<p>Optional. Do not call this function directly, call
tty_driver_flush_chars().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_room</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine returns the numbers of characters the <strong>tty</strong> driver
will accept for queuing to be written.  This number is subject
to change as output buffers get emptied, or if the output flow
control is acted.</p>
<p>The ldisc is responsible for being intelligent about multi-threading of
write_room/write calls</p>
<p>Required if <strong>write</strong> method is provided else not needed. Do not call this
function directly, call tty_write_room()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chars_in_buffer</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine returns the number of characters in the device private
output queue. Used in tty_wait_until_sent() and for poll()
implementation.</p>
<p>Optional: if not provided, it is assumed there is no queue on the
device. Do not call this function directly, call tty_chars_in_buffer().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioctl</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd,</span>
<span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg)</span></code></p>
<blockquote>
<div><p>This routine allows the <strong>tty</strong> driver to implement device-specific
ioctls. If the ioctl number passed in <strong>cmd</strong> is not recognized by the
driver, it should return <code class="docutils literal notranslate"><span class="pre">ENOIOCTLCMD</span></code>.</p>
<p>Optional.</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_ioctl</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd,</span>
<span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg)</span></code></p>
<blockquote>
<div><p>Implement ioctl processing for 32 bit process on 64 bit system.</p>
<p>Optional.</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_termios</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ktermios</span> <span class="pre">*old)</span></code></p>
<p>This routine allows the <strong>tty</strong> driver to be notified when device’s
termios settings have changed. New settings are in <strong>tty-&gt;termios</strong>.
Previous settings are passed in the <strong>old</strong> argument.</p>
<p>The API is defined such that the driver should return the actual modes
selected. This means that the driver is responsible for modifying any
bits in <strong>tty-&gt;termios</strong> it cannot fulfill to indicate the actual modes
being used.</p>
<p>Optional. Called under the <strong>tty-&gt;termios_rwsem</strong>. May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">throttle</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine notifies the <strong>tty</strong> driver that input buffers for the line
discipline are close to full, and it should somehow signal that no more
characters should be sent to the <strong>tty</strong>.</p>
<p>Serialization including with <strong>unthrottle()</strong> is the job of the ldisc
layer.</p>
<p>Optional: Always invoke via tty_throttle_safe(). Called under the
<strong>tty-&gt;termios_rwsem</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unthrottle</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine notifies the <strong>tty</strong> driver that it should signal that
characters can now be sent to the <strong>tty</strong> without fear of overrunning the
input buffers of the line disciplines.</p>
<p>Optional. Always invoke via tty_unthrottle(). Called under the
<strong>tty-&gt;termios_rwsem</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stop</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine notifies the <strong>tty</strong> driver that it should stop outputting
characters to the tty device.</p>
<p>Called with <strong>tty-&gt;flow.lock</strong> held. Serialized with <strong><a class="reference internal" href="../../networking/ieee802154.html#c.start" title="start"><code class="xref c c-func docutils literal notranslate"><span class="pre">start()</span></code></a></strong> method.</p>
<p>Optional. Always invoke via <a class="reference internal" href="tty_struct.html#c.stop_tty" title="stop_tty"><code class="xref c c-func docutils literal notranslate"><span class="pre">stop_tty()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine notifies the <strong>tty</strong> driver that it resumed sending
characters to the <strong>tty</strong> device.</p>
<p>Called with <strong>tty-&gt;flow.lock</strong> held. Serialized with <a class="reference internal" href="../../networking/ieee802154.html#c.stop" title="stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">stop()</span></code></a> method.</p>
<p>Optional. Always invoke via <a class="reference internal" href="tty_struct.html#c.start_tty" title="start_tty"><code class="xref c c-func docutils literal notranslate"><span class="pre">start_tty()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hangup</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine notifies the <strong>tty</strong> driver that it should hang up the <strong>tty</strong>
device.</p>
<p>Optional. Called with tty lock held.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">break_ctl</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">int</span> <span class="pre">state)</span></code></p>
<p>This optional routine requests the <strong>tty</strong> driver to turn on or off BREAK
status on the RS-232 port. If <strong>state</strong> is -1, then the BREAK status
should be turned on; if <strong>state</strong> is 0, then BREAK should be turned off.</p>
<p>If this routine is implemented, the high-level tty driver will handle
the following ioctls: <code class="docutils literal notranslate"><span class="pre">TCSBRK</span></code>, <code class="docutils literal notranslate"><span class="pre">TCSBRKP</span></code>, <code class="docutils literal notranslate"><span class="pre">TIOCSBRK</span></code>, <code class="docutils literal notranslate"><span class="pre">TIOCCBRK</span></code>.</p>
<p>If the driver sets <code class="docutils literal notranslate"><span class="pre">TTY_DRIVER_HARDWARE_BREAK</span></code> in tty_alloc_driver(),
then the interface will also be called with actual times and the
hardware is expected to do the delay work itself. 0 and -1 are still
used for on/off.</p>
<p>Optional: Required for <code class="docutils literal notranslate"><span class="pre">TCSBRK</span></code>/<code class="docutils literal notranslate"><span class="pre">BRKP</span></code>/etc. handling. May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flush_buffer</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine discards device private output buffer. Invoked on close,
hangup, to implement <code class="docutils literal notranslate"><span class="pre">TCOFLUSH</span></code> ioctl and similar.</p>
<p>Optional: if not provided, it is assumed there is no queue on the
device. Do not call this function directly, call
tty_driver_flush_buffer().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_ldisc</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine allows the <strong>tty</strong> driver to be notified when the device’s
line discipline is being changed. At the point this is done the
discipline is not yet usable.</p>
<p>Optional. Called under the <strong>tty-&gt;ldisc_sem</strong> and <strong>tty-&gt;termios_rwsem</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wait_until_sent</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">int</span> <span class="pre">timeout)</span></code></p>
<p>This routine waits until the device has written out all of the
characters in its transmitter FIFO. Or until <strong>timeout</strong> (in jiffies) is
reached.</p>
<p>Optional: If not provided, the device is assumed to have no FIFO.
Usually correct to invoke via tty_wait_until_sent(). May sleep.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_xchar</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">char</span> <span class="pre">ch)</span></code></p>
<p>This routine is used to send a high-priority XON/XOFF character (<strong>ch</strong>)
to the <strong>tty</strong> device.</p>
<p>Optional: If not provided, then the <strong>write</strong> method is called under
the <strong>tty-&gt;atomic_write_lock</strong> to keep it serialized with the ldisc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tiocmget</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty)</span></code></p>
<p>This routine is used to obtain the modem status bits from the <strong>tty</strong>
driver.</p>
<p>Optional: If not provided, then <code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code> is returned from the <code class="docutils literal notranslate"><span class="pre">TIOCMGET</span></code>
ioctl. Do not call this function directly, call <a class="reference internal" href="tty_internals.html#c.tty_tiocmget" title="tty_tiocmget"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_tiocmget()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tiocmset</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span>
<span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">set,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">clear)</span></code></p>
<blockquote>
<div><p>This routine is used to set the modem status bits to the <strong>tty</strong> driver.
First, <strong>clear</strong> bits should be cleared, then <strong>set</strong> bits set.</p>
<p>Optional: If not provided, then <code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code> is returned from the <code class="docutils literal notranslate"><span class="pre">TIOCMSET</span></code>
ioctl. Do not call this function directly, call <a class="reference internal" href="tty_internals.html#c.tty_tiocmset" title="tty_tiocmset"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_tiocmset()</span></code></a>.</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resize</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">winsize</span> <span class="pre">*ws)</span></code></p>
<p>Called when a termios request is issued which changes the requested
terminal geometry to <strong>ws</strong>.</p>
<p>Optional: the default action is to update the termios structure
without error. This is usually the correct behaviour. Drivers should
not force errors here if they are not resizable objects (e.g. a serial
line). See <a class="reference internal" href="tty_struct.html#c.tty_do_resize" title="tty_do_resize"><code class="xref c c-func docutils literal notranslate"><span class="pre">tty_do_resize()</span></code></a> if you need to wrap the standard method
in your own logic – the usual case.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_icount</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span>
<span class="pre">struct</span> <span class="pre">serial_icounter</span> <span class="pre">*icount)</span></code></p>
<blockquote>
<div><p>Called when the <strong>tty</strong> device receives a <code class="docutils literal notranslate"><span class="pre">TIOCGICOUNT</span></code> ioctl. Passed a
kernel structure <strong>icount</strong> to complete.</p>
<p>Optional: called only if provided, otherwise <code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code> will be returned.</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_serial</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">serial_struct</span> <span class="pre">*p)</span></code></p>
<p>Called when the <strong>tty</strong> device receives a <code class="docutils literal notranslate"><span class="pre">TIOCGSERIAL</span></code> ioctl. Passed a
kernel structure <strong>p</strong> (<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">serial_struct</span></code>) to complete.</p>
<p>Optional: called only if provided, otherwise <code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code> will be returned.
Do not call this function directly, call tty_tiocgserial().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_serial</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">serial_struct</span> <span class="pre">*p)</span></code></p>
<p>Called when the <strong>tty</strong> device receives a <code class="docutils literal notranslate"><span class="pre">TIOCSSERIAL</span></code> ioctl. Passed a
kernel structure <strong>p</strong> (<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">serial_struct</span></code>) to set the values from.</p>
<p>Optional: called only if provided, otherwise <code class="docutils literal notranslate"><span class="pre">ENOTTY</span></code> will be returned.
Do not call this function directly, call tty_tiocsserial().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">show_fdinfo</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_struct</span> <span class="pre">*tty,</span> <span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*m)</span></code></p>
<p>Called when the <strong>tty</strong> device file descriptor receives a fdinfo request
from VFS (to show in /proc/&lt;pid&gt;/fdinfo/). <strong>m</strong> should be filled with
information.</p>
<p>Optional: called only if provided, otherwise nothing is written to <strong>m</strong>.
Do not call this function directly, call tty_show_fdinfo().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_init</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver,</span> <span class="pre">int</span> <span class="pre">line,</span> <span class="pre">char</span> <span class="pre">*options)</span></code></p>
<p>kgdboc support (<a class="reference internal" href="../../dev-tools/kgdb.html"><span class="doc">Using kgdb, kdb and the kernel debugger internals</span></a>). This routine is
called to initialize the HW for later use by calling <strong>poll_get_char</strong> or
<strong>poll_put_char</strong>.</p>
<p>Optional: called only if provided, otherwise skipped as a non-polling
driver.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_get_char</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver,</span> <span class="pre">int</span> <span class="pre">line)</span></code></p>
<p>kgdboc support (see <strong>poll_init</strong>). <strong>driver</strong> should read a character from a
tty identified by <strong>line</strong> and return it.</p>
<p>Optional: called only if <strong>poll_init</strong> provided.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_put_char</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">()(struct</span> <span class="pre">tty_driver</span> <span class="pre">*driver,</span> <span class="pre">int</span> <span class="pre">line,</span> <span class="pre">char</span> <span class="pre">ch)</span></code></p>
<p>kgdboc support (see <strong>poll_init</strong>). <strong>driver</strong> should write character <strong>ch</strong> to
a tty identified by <strong>line</strong>.</p>
<p>Optional: called only if <strong>poll_init</strong> provided.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proc_show</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">()(struct</span> <span class="pre">seq_file</span> <span class="pre">*m,</span> <span class="pre">void</span> <span class="pre">*driver)</span></code></p>
<p>Driver <strong>driver</strong> (cast to <a class="reference internal" href="#c.tty_driver" title="tty_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tty_driver</span></code></a>) can show additional info in
/proc/tty/driver/&lt;driver_name&gt;. It is enough to fill in the information
into <strong>m</strong>.</p>
<p>Optional: called only if provided, otherwise no /proc entry created.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure defines the interface between the low-level tty driver and
the tty routines. These routines can be defined. Unless noted otherwise,
they are optional, and can be filled in with a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">TTY Driver and TTY Operations</a><ul>
<li><a class="reference internal" href="#allocation">Allocation</a><ul>
<li><a class="reference internal" href="#tty-driver-flags">TTY Driver Flags</a></li>
</ul>
</li>
<li><a class="reference internal" href="#registration">Registration</a><ul>
<li><a class="reference internal" href="#registering-devices">Registering Devices</a></li>
<li><a class="reference internal" href="#linking-devices-to-ports">Linking Devices to Ports</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tty-driver-reference">TTY Driver Reference</a></li>
<li><a class="reference internal" href="#tty-operations-reference">TTY Operations Reference</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/tty/tty_driver.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/tty/tty_driver.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>