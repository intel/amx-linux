
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>CPU Idle Cooling &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Generic Thermal Sysfs driver How To" href="sysfs-api.html" />
    <link rel="prev" title="CPU cooling APIs How To" href="cpu-cooling-api.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="cpu-idle-cooling">
<h1>CPU Idle Cooling<a class="headerlink" href="#cpu-idle-cooling" title="Permalink to this headline">¶</a></h1>
<section id="situation">
<h2>Situation:<a class="headerlink" href="#situation" title="Permalink to this headline">¶</a></h2>
<p>Under certain circumstances a SoC can reach a critical temperature
limit and is unable to stabilize the temperature around a temperature
control. When the SoC has to stabilize the temperature, the kernel can
act on a cooling device to mitigate the dissipated power. When the
critical temperature is reached, a decision must be taken to reduce
the temperature, that, in turn impacts performance.</p>
<p>Another situation is when the silicon temperature continues to
increase even after the dynamic leakage is reduced to its minimum by
clock gating the component. This runaway phenomenon can continue due
to the static leakage. The only solution is to power down the
component, thus dropping the dynamic and static leakage that will
allow the component to cool down.</p>
<p>Last but not least, the system can ask for a specific power budget but
because of the OPP density, we can only choose an OPP with a power
budget lower than the requested one and under-utilize the CPU, thus
losing performance. In other words, one OPP under-utilizes the CPU
with a power less than the requested power budget and the next OPP
exceeds the power budget. An intermediate OPP could have been used if
it were present.</p>
</section>
<section id="solutions">
<h2>Solutions:<a class="headerlink" href="#solutions" title="Permalink to this headline">¶</a></h2>
<p>If we can remove the static and the dynamic leakage for a specific
duration in a controlled period, the SoC temperature will
decrease. Acting on the idle state duration or the idle cycle
injection period, we can mitigate the temperature by modulating the
power budget.</p>
<p>The Operating Performance Point (OPP) density has a great influence on
the control precision of cpufreq, however different vendors have a
plethora of OPP density, and some have large power gap between OPPs,
that will result in loss of performance during thermal control and
loss of power in other scenarios.</p>
<p>At a specific OPP, we can assume that injecting idle cycle on all CPUs
belong to the same cluster, with a duration greater than the cluster
idle state target residency, we lead to dropping the static and the
dynamic leakage for this period (modulo the energy needed to enter
this state). So the sustainable power with idle cycles has a linear
relation with the OPP’s sustainable power and can be computed with a
coefficient similar to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Power(IdleCycle) = Coef x Power(OPP)
</pre></div>
</div>
</section>
<section id="idle-injection">
<h2>Idle Injection:<a class="headerlink" href="#idle-injection" title="Permalink to this headline">¶</a></h2>
<p>The base concept of the idle injection is to force the CPU to go to an
idle state for a specified time each control cycle, it provides
another way to control CPU power and heat in addition to
cpufreq. Ideally, if all CPUs belonging to the same cluster, inject
their idle cycles synchronously, the cluster can reach its power down
state with a minimum power consumption and reduce the static leakage
to almost zero.  However, these idle cycles injection will add extra
latencies as the CPUs will have to wakeup from a deep sleep state.</p>
<p>We use a fixed duration of idle injection that gives an acceptable
performance penalty and a fixed latency. Mitigation can be increased
or decreased by modulating the duty cycle of the idle injection.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>^
|
|
|-------                         -------
|_______|_______________________|_______|___________

&lt;------&gt;
  idle  &lt;----------------------&gt;
               running

 &lt;-----------------------------&gt;
         duty cycle 25%
</pre></div>
</div>
<p>The implementation of the cooling device bases the number of states on
the duty cycle percentage. When no mitigation is happening the cooling
device state is zero, meaning the duty cycle is 0%.</p>
<p>When the mitigation begins, depending on the governor’s policy, a
starting state is selected. With a fixed idle duration and the duty
cycle (aka the cooling device state), the running duration can be
computed.</p>
<p>The governor will change the cooling device state thus the duty cycle
and this variation will modulate the cooling effect.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>^
|
|
|-------                 -------
|_______|_______________|_______|___________

&lt;------&gt;
  idle  &lt;--------------&gt;
           running

 &lt;---------------------&gt;
     duty cycle 33%


^
|
|
|-------         -------
|_______|_______|_______|___________

&lt;------&gt;
  idle  &lt;------&gt;
         running

 &lt;-------------&gt;
  duty cycle 50%
</pre></div>
</div>
<p>The idle injection duration value must comply with the constraints:</p>
<ul class="simple">
<li><p>It is less than or equal to the latency we tolerate when the
mitigation begins. It is platform dependent and will depend on the
user experience, reactivity vs performance trade off we want. This
value should be specified.</p></li>
<li><p>It is greater than the idle state’s target residency we want to go
for thermal mitigation, otherwise we end up consuming more energy.</p></li>
</ul>
</section>
<section id="power-considerations">
<h2>Power considerations<a class="headerlink" href="#power-considerations" title="Permalink to this headline">¶</a></h2>
<p>When we reach the thermal trip point, we have to sustain a specified
power for a specific temperature but at this time we consume:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Power = Capacitance x Voltage^2 x Frequency x Utilisation
</pre></div>
</div>
<p>… which is more than the sustainable power (or there is something
wrong in the system setup). The ‘Capacitance’ and ‘Utilisation’ are a
fixed value, ‘Voltage’ and the ‘Frequency’ are fixed artificially
because we don’t want to change the OPP. We can group the
‘Capacitance’ and the ‘Utilisation’ into a single term which is the
‘Dynamic Power Coefficient (Cdyn)’ Simplifying the above, we have:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Pdyn = Cdyn x Voltage^2 x Frequency
</pre></div>
</div>
<p>The power allocator governor will ask us somehow to reduce our power
in order to target the sustainable power defined in the device
tree. So with the idle injection mechanism, we want an average power
(Ptarget) resulting in an amount of time running at full power on a
specific OPP and idle another amount of time. That could be put in a
equation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>P(opp)target = ((Trunning x (P(opp)running) + (Tidle x P(opp)idle)) /
                       (Trunning + Tidle)

 ...

Tidle = Trunning x ((P(opp)running / P(opp)target) - 1)
</pre></div>
</div>
<p>At this point if we know the running period for the CPU, that gives us
the idle injection we need. Alternatively if we have the idle
injection duration, we can compute the running duration with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Trunning = Tidle / ((P(opp)running / P(opp)target) - 1)
</pre></div>
</div>
<p>Practically, if the running power is less than the targeted power, we
end up with a negative time value, so obviously the equation usage is
bound to a power reduction, hence a higher OPP is needed to have the
running power greater than the targeted power.</p>
<p>However, in this demonstration we ignore three aspects:</p>
<blockquote>
<div><ul class="simple">
<li><p>The static leakage is not defined here, we can introduce it in the
equation but assuming it will be zero most of the time as it is
difficult to get the values from the SoC vendors</p></li>
<li><p>The idle state wake up latency (or entry + exit latency) is not
taken into account, it must be added in the equation in order to
rigorously compute the idle injection</p></li>
<li><p>The injected idle duration must be greater than the idle state
target residency, otherwise we end up consuming more energy and
potentially invert the mitigation effect</p></li>
</ul>
</div></blockquote>
<p>So the final equation is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Trunning = (Tidle - Twakeup ) x
               (((P(opp)dyn + P(opp)static ) - P(opp)target) / P(opp)target )
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">CPU Idle Cooling</a><ul>
<li><a class="reference internal" href="#situation">Situation:</a></li>
<li><a class="reference internal" href="#solutions">Solutions:</a></li>
<li><a class="reference internal" href="#idle-injection">Idle Injection:</a></li>
<li><a class="reference internal" href="#power-considerations">Power considerations</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/thermal/cpu-idle-cooling.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/thermal/cpu-idle-cooling.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>