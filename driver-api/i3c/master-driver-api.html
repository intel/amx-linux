
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>I3C master controller driver API &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Generic System Interconnect Subsystem" href="../interconnect.html" />
    <link rel="prev" title="I3C device driver API" href="device-driver-api.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="i3c-master-controller-driver-api">
<h1>I3C master controller driver API<a class="headerlink" href="#i3c-master-controller-driver-api" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="c.i3c_bus_maintenance_lock">
void <code class="sig-name descname">i3c_bus_maintenance_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_bus" title="i3c_bus">i3c_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_bus_maintenance_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the bus for a maintenance operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_bus</span> <span class="pre">*bus</span></code></dt><dd><p>I3C bus to take the lock on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function takes the bus lock so that no other operations can occur on
the bus. This is needed for all kind of bus maintenance operation, like
- enabling/disabling slave events
- re-triggering DAA
- changing the dynamic address of a device
- relinquishing mastership
- …</p>
<p>The reason for this kind of locking is that we don’t want drivers and core
logic to rely on I3C device information that could be changed behind their
back.</p>
</div>
<dl class="function">
<dt id="c.i3c_bus_maintenance_unlock">
void <code class="sig-name descname">i3c_bus_maintenance_unlock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_bus" title="i3c_bus">i3c_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_bus_maintenance_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the bus lock after a maintenance operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_bus</span> <span class="pre">*bus</span></code></dt><dd><p>I3C bus to release the lock on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called when the bus maintenance operation is done. See
<a class="reference internal" href="#c.i3c_bus_maintenance_lock" title="i3c_bus_maintenance_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_bus_maintenance_lock()</span></code></a> for more details on what these maintenance
operations are.</p>
</div>
<dl class="function">
<dt id="c.i3c_bus_normaluse_lock">
void <code class="sig-name descname">i3c_bus_normaluse_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_bus" title="i3c_bus">i3c_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_bus_normaluse_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the bus for a normal operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_bus</span> <span class="pre">*bus</span></code></dt><dd><p>I3C bus to take the lock on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function takes the bus lock for any operation that is not a maintenance
operation (see <a class="reference internal" href="#c.i3c_bus_maintenance_lock" title="i3c_bus_maintenance_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_bus_maintenance_lock()</span></code></a> for a non-exhaustive list of
maintenance operations). Basically all communications with I3C devices are
normal operations (HDR, SDR transfers or CCC commands that do not change bus
state or I3C dynamic address).</p>
<p>Note that this lock is not guaranteeing serialization of normal operations.
In other words, transfer requests passed to the I3C master can be submitted
in parallel and I3C master drivers have to use their own locking to make
sure two different communications are not inter-mixed, or access to the
output/input queue is not done while the engine is busy.</p>
</div>
<dl class="function">
<dt id="c.i3c_bus_normaluse_unlock">
void <code class="sig-name descname">i3c_bus_normaluse_unlock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_bus" title="i3c_bus">i3c_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_bus_normaluse_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the bus lock after a normal operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_bus</span> <span class="pre">*bus</span></code></dt><dd><p>I3C bus to release the lock on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called when a normal operation is done. See
<a class="reference internal" href="#c.i3c_bus_normaluse_lock" title="i3c_bus_normaluse_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_bus_normaluse_lock()</span></code></a> for more details on what these normal operations
are.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_get_free_addr">
int <code class="sig-name descname">i3c_master_get_free_addr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em>, u8<em> start_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_get_free_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>get a free address on the bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>I3C master object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">start_addr</span></code></dt><dd><p>where to start searching</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called with the bus lock held in write mode.</p>
<p><strong>Return</strong></p>
<p>the first free address starting at <strong>start_addr</strong> (included) or -ENOMEM
if there’s no more address available.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_entdaa_locked">
int <code class="sig-name descname">i3c_master_entdaa_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_entdaa_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>start a DAA (Dynamic Address Assignment) procedure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>master used to send frames on the bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send a ENTDAA CCC command to start a DAA procedure.</p>
<p>Note that this function only sends the ENTDAA CCC command, all the logic
behind dynamic address assignment has to be handled in the I3C master
driver.</p>
<p>This function must be called with the bus lock held in write mode.</p>
<p><strong>Return</strong></p>
<p>0 in case of success, a positive I3C error code if the error is
one of the official Mx error codes, and a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_disec_locked">
int <code class="sig-name descname">i3c_master_disec_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em>, u8<em> addr</em>, u8<em> evts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_disec_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>send a DISEC CCC command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>master used to send frames on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">addr</span></code></dt><dd><p>a valid I3C slave address or <code class="docutils literal notranslate"><span class="pre">I3C_BROADCAST_ADDR</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">evts</span></code></dt><dd><p>events to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send a DISEC CCC command to disable some or all events coming from a
specific slave, or all devices if <strong>addr</strong> is <code class="docutils literal notranslate"><span class="pre">I3C_BROADCAST_ADDR</span></code>.</p>
<p>This function must be called with the bus lock held in write mode.</p>
<p><strong>Return</strong></p>
<p>0 in case of success, a positive I3C error code if the error is
one of the official Mx error codes, and a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_enec_locked">
int <code class="sig-name descname">i3c_master_enec_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em>, u8<em> addr</em>, u8<em> evts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_enec_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>send an ENEC CCC command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>master used to send frames on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">addr</span></code></dt><dd><p>a valid I3C slave address or <code class="docutils literal notranslate"><span class="pre">I3C_BROADCAST_ADDR</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">evts</span></code></dt><dd><p>events to disable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sends an ENEC CCC command to enable some or all events coming from a
specific slave, or all devices if <strong>addr</strong> is <code class="docutils literal notranslate"><span class="pre">I3C_BROADCAST_ADDR</span></code>.</p>
<p>This function must be called with the bus lock held in write mode.</p>
<p><strong>Return</strong></p>
<p>0 in case of success, a positive I3C error code if the error is
one of the official Mx error codes, and a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_defslvs_locked">
int <code class="sig-name descname">i3c_master_defslvs_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_defslvs_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>send a DEFSLVS CCC command</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>master used to send frames on the bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send a DEFSLVS CCC command containing all the devices known to the <strong>master</strong>.
This is useful when you have secondary masters on the bus to propagate
device information.</p>
<p>This should be called after all I3C devices have been discovered (in other
words, after the DAA procedure has finished) and instantiated in
<a class="reference internal" href="#c.i3c_master_controller_ops" title="i3c_master_controller_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">i3c_master_controller_ops-&gt;bus_init()</span></code></a>.
It should also be called if a master ACKed an Hot-Join request and assigned
a dynamic address to the device joining the bus.</p>
<p>This function must be called with the bus lock held in write mode.</p>
<p><strong>Return</strong></p>
<p>0 in case of success, a positive I3C error code if the error is
one of the official Mx error codes, and a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_do_daa">
int <code class="sig-name descname">i3c_master_do_daa</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_do_daa" title="Permalink to this definition">¶</a></dt>
<dd><p>do a DAA (Dynamic Address Assignment)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>master doing the DAA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is instantiating an I3C device object and adding it to the
I3C device list. All device information are automatically retrieved using
standard CCC commands.</p>
<p>The I3C device object is returned in case the master wants to attach
private data to it using <a class="reference internal" href="#c.i3c_dev_set_master_data" title="i3c_dev_set_master_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_dev_set_master_data()</span></code></a>.</p>
<p>This function must be called with the bus lock held in write mode.</p>
<p><strong>Return</strong></p>
<p>a 0 in case of success, an negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_set_info">
int <code class="sig-name descname">i3c_master_set_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em>, const struct <a class="reference internal" href="device-driver-api.html#c.i3c_device_info" title="i3c_device_info">i3c_device_info</a><em> *info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_set_info" title="Permalink to this definition">¶</a></dt>
<dd><p>set master device information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>master used to send frames on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i3c_device_info</span> <span class="pre">*info</span></code></dt><dd><p>I3C device information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set master device info. This should be called from
<a class="reference internal" href="#c.i3c_master_controller_ops" title="i3c_master_controller_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">i3c_master_controller_ops-&gt;bus_init()</span></code></a>.</p>
<p>Not all <a class="reference internal" href="device-driver-api.html#c.i3c_device_info" title="i3c_device_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">i3c_device_info</span></code></a> fields are meaningful for a master device.
Here is a list of fields that should be properly filled:</p>
<ul class="simple">
<li><p><a class="reference internal" href="device-driver-api.html#c.i3c_device_info" title="i3c_device_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">i3c_device_info-&gt;dyn_addr</span></code></a></p></li>
<li><p><a class="reference internal" href="device-driver-api.html#c.i3c_device_info" title="i3c_device_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">i3c_device_info-&gt;bcr</span></code></a></p></li>
<li><p><a class="reference internal" href="device-driver-api.html#c.i3c_device_info" title="i3c_device_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">i3c_device_info-&gt;dcr</span></code></a></p></li>
<li><p><a class="reference internal" href="device-driver-api.html#c.i3c_device_info" title="i3c_device_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">i3c_device_info-&gt;pid</span></code></a></p></li>
<li><p><a class="reference internal" href="device-driver-api.html#c.i3c_device_info" title="i3c_device_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">i3c_device_info-&gt;hdr_cap</span></code></a> if <code class="docutils literal notranslate"><span class="pre">I3C_BCR_HDR_CAP</span></code> bit is set in
<a class="reference internal" href="device-driver-api.html#c.i3c_device_info" title="i3c_device_info"><code class="xref c c-type docutils literal notranslate"><span class="pre">i3c_device_info-&gt;bcr</span></code></a></p></li>
</ul>
<p>This function must be called with the bus lock held in maintenance mode.</p>
<p><strong>Return</strong></p>
<p>0 if <strong>info</strong> contains valid information (not every piece of
information can be checked, but we can at least make sure <strong>info-&gt;dyn_addr</strong>
and <strong>info-&gt;bcr</strong> are correct), -EINVAL otherwise.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_bus_init">
int <code class="sig-name descname">i3c_master_bus_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_bus_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an I3C bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>main master initializing the bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is following all initialisation steps described in the I3C
specification:</p>
<ol class="arabic simple">
<li><p>Attach I2C devs to the master so that the master can fill its internal
device table appropriately</p></li>
<li><p>Call <a class="reference internal" href="#c.i3c_master_controller_ops" title="i3c_master_controller_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">i3c_master_controller_ops-&gt;bus_init()</span></code></a> method to initialize
the master controller. That’s usually where the bus mode is selected
(pure bus or mixed fast/slow bus)</p></li>
<li><p>Instruct all devices on the bus to drop their dynamic address. This is
particularly important when the bus was previously configured by someone
else (for example the bootloader)</p></li>
<li><p>Disable all slave events.</p></li>
<li><p>Reserve address slots for I3C devices with init_dyn_addr. And if devices
also have static_addr, try to pre-assign dynamic addresses requested by
the FW with SETDASA and attach corresponding statically defined I3C
devices to the master.</p></li>
<li><p>Do a DAA (Dynamic Address Assignment) to assign dynamic addresses to all
remaining I3C devices</p></li>
</ol>
<p>Once this is done, all I3C and I2C devices should be usable.</p>
<p><strong>Return</strong></p>
<p>a 0 in case of success, an negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_add_i3c_dev_locked">
int <code class="sig-name descname">i3c_master_add_i3c_dev_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em>, u8<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_add_i3c_dev_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>add an I3C slave to the bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>master used to send frames on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">addr</span></code></dt><dd><p>I3C slave dynamic address assigned to the device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is instantiating an I3C device object and adding it to the
I3C device list. All device information are automatically retrieved using
standard CCC commands.</p>
<p>The I3C device object is returned in case the master wants to attach
private data to it using <a class="reference internal" href="#c.i3c_dev_set_master_data" title="i3c_dev_set_master_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_dev_set_master_data()</span></code></a>.</p>
<p>This function must be called with the bus lock held in write mode.</p>
<p><strong>Return</strong></p>
<p>a 0 in case of success, an negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_queue_ibi">
void <code class="sig-name descname">i3c_master_queue_ibi</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_dev_desc" title="i3c_dev_desc">i3c_dev_desc</a><em> *dev</em>, struct <a class="reference internal" href="#c.i3c_ibi_slot" title="i3c_ibi_slot">i3c_ibi_slot</a><em> *slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_queue_ibi" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an IBI</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_dev_desc</span> <span class="pre">*dev</span></code></dt><dd><p>the device this IBI is coming from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_ibi_slot</span> <span class="pre">*slot</span></code></dt><dd><p>the IBI slot used to store the payload</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue an IBI to the controller workqueue. The IBI handler attached to
the dev will be called from a workqueue context.</p>
</div>
<dl class="function">
<dt id="c.i3c_generic_ibi_free_pool">
void <code class="sig-name descname">i3c_generic_ibi_free_pool</code><span class="sig-paren">(</span>struct i3c_generic_ibi_pool<em> *pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_generic_ibi_free_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a generic IBI pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_generic_ibi_pool</span> <span class="pre">*pool</span></code></dt><dd><p>the IBI pool to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all IBI slots allated by a generic IBI pool.</p>
</div>
<dl class="function">
<dt id="c.i3c_generic_ibi_alloc_pool">
struct i3c_generic_ibi_pool * <code class="sig-name descname">i3c_generic_ibi_alloc_pool</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_dev_desc" title="i3c_dev_desc">i3c_dev_desc</a><em> *dev</em>, const struct <a class="reference internal" href="device-driver-api.html#c.i3c_ibi_setup" title="i3c_ibi_setup">i3c_ibi_setup</a><em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_generic_ibi_alloc_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a generic IBI pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_dev_desc</span> <span class="pre">*dev</span></code></dt><dd><p>the device this pool will be used for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i3c_ibi_setup</span> <span class="pre">*req</span></code></dt><dd><p>IBI setup request describing what the device driver expects</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a generic IBI pool based on the information provided in <strong>req</strong>.</p>
<p><strong>Return</strong></p>
<p>a valid IBI pool in case of success, an ERR_PTR() otherwise.</p>
</div>
<dl class="function">
<dt id="c.i3c_generic_ibi_get_free_slot">
struct <a class="reference internal" href="#c.i3c_ibi_slot" title="i3c_ibi_slot">i3c_ibi_slot</a> * <code class="sig-name descname">i3c_generic_ibi_get_free_slot</code><span class="sig-paren">(</span>struct i3c_generic_ibi_pool<em> *pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_generic_ibi_get_free_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a free slot from a generic IBI pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_generic_ibi_pool</span> <span class="pre">*pool</span></code></dt><dd><p>the pool to query an IBI slot on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a free slot in a generic IBI pool.
The slot should be returned to the pool using <a class="reference internal" href="#c.i3c_generic_ibi_recycle_slot" title="i3c_generic_ibi_recycle_slot"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_generic_ibi_recycle_slot()</span></code></a>
when it’s no longer needed.</p>
<p><strong>Return</strong></p>
<p>a pointer to a free slot, or NULL if there’s no free slot available.</p>
</div>
<dl class="function">
<dt id="c.i3c_generic_ibi_recycle_slot">
void <code class="sig-name descname">i3c_generic_ibi_recycle_slot</code><span class="sig-paren">(</span>struct i3c_generic_ibi_pool<em> *pool</em>, struct <a class="reference internal" href="#c.i3c_ibi_slot" title="i3c_ibi_slot">i3c_ibi_slot</a><em> *s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_generic_ibi_recycle_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a slot to a generic IBI pool</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_generic_ibi_pool</span> <span class="pre">*pool</span></code></dt><dd><p>the pool to return the IBI slot to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_ibi_slot</span> <span class="pre">*s</span></code></dt><dd><p>IBI slot to recycle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an IBI slot back to its generic IBI pool. Should be called from the
master driver struct_master_controller_ops-&gt;recycle_ibi() method.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_register">
int <code class="sig-name descname">i3c_master_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a><em> *parent</em>, const struct <a class="reference internal" href="#c.i3c_master_controller_ops" title="i3c_master_controller_ops">i3c_master_controller_ops</a><em> *ops</em>, bool<em> secondary</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register an I3C master</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>master used to send frames on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>the parent device (the one that provides this I3C master
controller)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i3c_master_controller_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the master controller operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">secondary</span></code></dt><dd><p>true if you are registering a secondary master. Will return
-ENOTSUPP if set to true since secondary masters are not yet
supported</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function takes care of everything for you:</p>
<ul class="simple">
<li><p>creates and initializes the I3C bus</p></li>
<li><p>populates the bus with static I2C devs if <strong>parent-&gt;of_node</strong> is not
NULL</p></li>
<li><p>registers all I3C devices added by the controller during bus
initialization</p></li>
<li><p>registers the I2C adapter and all I2C devices</p></li>
</ul>
<p><strong>Return</strong></p>
<p>0 in case of success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.i3c_master_unregister">
int <code class="sig-name descname">i3c_master_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister an I3C master</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>master used to send frames on the bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Basically undo everything done in <a class="reference internal" href="#c.i3c_master_register" title="i3c_master_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_master_register()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 in case of success, a negative error code otherwise.</p>
</div>
<dl class="type">
<dt id="c.i3c_i2c_dev_desc">
struct <code class="sig-name descname">i3c_i2c_dev_desc</code><a class="headerlink" href="#c.i3c_i2c_dev_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Common part of the I3C/I2C device descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i3c_i2c_dev_desc {
    struct list_head node;
    struct i3c_master_controller *master;
    void *master_priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>node element used to insert the slot into the I2C or I3C device
list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master</span></code></dt><dd><p>I3C master that instantiated this device. Will be used to do
I2C/I3C transfers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master_priv</span></code></dt><dd><p>master private data assigned to the device. Can be used to
add master specific information</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is describing common I3C/I2C dev information.</p>
<dl class="type">
<dt id="c.i2c_dev_boardinfo">
struct <code class="sig-name descname">i2c_dev_boardinfo</code><a class="headerlink" href="#c.i2c_dev_boardinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C device board information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i2c_dev_boardinfo {
    struct list_head node;
    struct i2c_board_info base;
    u8 lvr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>used to insert the boardinfo object in the I2C boardinfo list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>regular I2C board information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lvr</span></code></dt><dd><p>LVR (Legacy Virtual Register) needed by the I3C core to know about
the I2C device limitations</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is used to attach board-level information to an I2C device.
Each I2C device connected on the I3C bus should have one.</p>
<dl class="type">
<dt id="c.i2c_dev_desc">
struct <code class="sig-name descname">i2c_dev_desc</code><a class="headerlink" href="#c.i2c_dev_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C device descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i2c_dev_desc {
    struct i3c_i2c_dev_desc common;
    struct i2c_client *dev;
    u16 addr;
    u8 lvr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">common</span></code></dt><dd><p>common part of the I2C device descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>I2C device object registered to the I2C framework</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>I2C device address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lvr</span></code></dt><dd><p>LVR (Legacy Virtual Register) needed by the I3C core to know about
the I2C device limitations</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Each I2C device connected on the bus will have an i2c_dev_desc.
This object is created by the core and later attached to the controller
using <code class="xref c c-type docutils literal notranslate"><span class="pre">struct_i3c_master_controller-&gt;ops</span></code>-&gt;attach_i2c_dev().</p>
<p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct_i2c_dev_desc</span></code> is the internal representation of an I2C device
connected on an I3C bus. This object is also passed to all
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct_i3c_master_controller_ops</span></code> hooks.</p>
<dl class="type">
<dt id="c.i3c_ibi_slot">
struct <code class="sig-name descname">i3c_ibi_slot</code><a class="headerlink" href="#c.i3c_ibi_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>I3C IBI (In-Band Interrupt) slot</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i3c_ibi_slot {
    struct work_struct work;
    struct i3c_dev_desc *dev;
    unsigned int len;
    void *data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">work</span></code></dt><dd><p>work associated to this slot. The IBI handler will be called from
there</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>the I3C device that has generated this IBI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>length of the payload associated to this IBI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>payload buffer</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>An IBI slot is an object pre-allocated by the controller and used when an
IBI comes in.
Every time an IBI comes in, the I3C master driver should find a free IBI
slot in its IBI slot pool, retrieve the IBI payload and queue the IBI using
<a class="reference internal" href="#c.i3c_master_queue_ibi" title="i3c_master_queue_ibi"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_master_queue_ibi()</span></code></a>.</p>
<p>How IBI slots are allocated is left to the I3C master driver, though, for
simple kmalloc-based allocation, the generic IBI slot pool can be used.</p>
<dl class="type">
<dt id="c.i3c_device_ibi_info">
struct <code class="sig-name descname">i3c_device_ibi_info</code><a class="headerlink" href="#c.i3c_device_ibi_info" title="Permalink to this definition">¶</a></dt>
<dd><p>IBI information attached to a specific device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i3c_device_ibi_info {
    struct completion all_ibis_handled;
    atomic_t pending_ibis;
    unsigned int max_payload_len;
    unsigned int num_slots;
    unsigned int enabled;
    void (*handler)(struct i3c_device *dev, const struct i3c_ibi_payload *payload);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">all_ibis_handled</span></code></dt><dd><p>used to be informed when no more IBIs are waiting to be
processed. Used by <a class="reference internal" href="device-driver-api.html#c.i3c_device_disable_ibi" title="i3c_device_disable_ibi"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_device_disable_ibi()</span></code></a> to wait for
all IBIs to be dequeued</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pending_ibis</span></code></dt><dd><p>count the number of pending IBIs. Each pending IBI has its
work element queued to the controller workqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_payload_len</span></code></dt><dd><p>maximum payload length for an IBI coming from this device.
this value is specified when calling
<a class="reference internal" href="device-driver-api.html#c.i3c_device_request_ibi" title="i3c_device_request_ibi"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_device_request_ibi()</span></code></a> and should not change at run
time. All messages IBIs exceeding this limit should be
rejected by the master</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_slots</span></code></dt><dd><p>number of IBI slots reserved for this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enabled</span></code></dt><dd><p>reflect the IBI status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt><dd><p>IBI handler specified at <a class="reference internal" href="device-driver-api.html#c.i3c_device_request_ibi" title="i3c_device_request_ibi"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_device_request_ibi()</span></code></a> call time. This
handler will be called from the controller workqueue, and as such
is allowed to sleep (though it is recommended to process the IBI
as fast as possible to not stall processing of other IBIs queued
on the same workqueue).
New I3C messages can be sent from the IBI handler</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The <code class="xref c c-type docutils literal notranslate"><span class="pre">struct_i3c_device_ibi_info</span></code> object is allocated when
<a class="reference internal" href="device-driver-api.html#c.i3c_device_request_ibi" title="i3c_device_request_ibi"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_device_request_ibi()</span></code></a> is called and attached to a specific device. This
object is here to manage IBIs coming from a specific I3C device.</p>
<p>Note that this structure is the generic view of the IBI management
infrastructure. I3C master drivers may have their own internal
representation which they can associate to the device using
controller-private data.</p>
<dl class="type">
<dt id="c.i3c_dev_boardinfo">
struct <code class="sig-name descname">i3c_dev_boardinfo</code><a class="headerlink" href="#c.i3c_dev_boardinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>I3C device board information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i3c_dev_boardinfo {
    struct list_head node;
    u8 init_dyn_addr;
    u8 static_addr;
    u64 pid;
    struct device_node *of_node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">node</span></code></dt><dd><p>used to insert the boardinfo object in the I3C boardinfo list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_dyn_addr</span></code></dt><dd><p>initial dynamic address requested by the FW. We provide no
guarantee that the device will end up using this address,
but try our best to assign this specific address to the
device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static_addr</span></code></dt><dd><p>static address the I3C device listen on before it’s been
assigned a dynamic address by the master. Will be used during
bus initialization to assign it a specific dynamic address
before starting DAA (Dynamic Address Assignment)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pid</span></code></dt><dd><p>I3C Provisional ID exposed by the device. This is a unique identifier
that may be used to attach boardinfo to i3c_dev_desc when the device
does not have a static address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">of_node</span></code></dt><dd><p>optional DT node in case the device has been described in the DT</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is used to attach board-level information to an I3C device.
Not all I3C devices connected on the bus will have a boardinfo. It’s only
needed if you want to attach extra resources to a device or assign it a
specific dynamic address.</p>
<dl class="type">
<dt id="c.i3c_dev_desc">
struct <code class="sig-name descname">i3c_dev_desc</code><a class="headerlink" href="#c.i3c_dev_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>I3C device descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i3c_dev_desc {
    struct i3c_i2c_dev_desc common;
    struct i3c_device_info info;
    struct mutex ibi_lock;
    struct i3c_device_ibi_info *ibi;
    struct i3c_device *dev;
    const struct i3c_dev_boardinfo *boardinfo;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">common</span></code></dt><dd><p>common part of the I3C device descriptor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>I3C device information. Will be automatically filled when you create
your device with <a class="reference internal" href="#c.i3c_master_add_i3c_dev_locked" title="i3c_master_add_i3c_dev_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_master_add_i3c_dev_locked()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ibi_lock</span></code></dt><dd><p>lock used to protect the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct_i3c_device-&gt;ibi</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ibi</span></code></dt><dd><p>IBI info attached to a device. Should be NULL until
<a class="reference internal" href="device-driver-api.html#c.i3c_device_request_ibi" title="i3c_device_request_ibi"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_device_request_ibi()</span></code></a> is called</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>pointer to the I3C device object exposed to I3C device drivers. This
should never be accessed from I3C master controller drivers. Only core
code should manipulate it in when updating the dev &lt;-&gt; desc link or
when propagating IBI events to the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">boardinfo</span></code></dt><dd><p>pointer to the boardinfo attached to this I3C device</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Internal representation of an I3C device. This object is only used by the
core and passed to I3C master controller drivers when they’re requested to
do some operations on the device.
The core maintains the link between the internal I3C dev descriptor and the
object exposed to the I3C device drivers (<code class="xref c c-type docutils literal notranslate"><span class="pre">struct_i3c_device</span></code>).</p>
<dl class="type">
<dt id="c.i3c_device">
struct <code class="sig-name descname">i3c_device</code><a class="headerlink" href="#c.i3c_device" title="Permalink to this definition">¶</a></dt>
<dd><p>I3C device object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i3c_device {
    struct device dev;
    struct i3c_dev_desc *desc;
    struct i3c_bus *bus;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device object to register the I3C dev to the device model</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">desc</span></code></dt><dd><p>pointer to an i3c device descriptor object. This link is updated
every time the I3C device is rediscovered with a different dynamic
address assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus</span></code></dt><dd><p>I3C bus this device is attached to</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>I3C device object exposed to I3C device drivers. The takes care of linking
this object to the relevant <code class="xref c c-type docutils literal notranslate"><span class="pre">struct_i3c_dev_desc</span></code> one.
All I3C devs on the I3C bus are represented, including I3C masters. For each
of them, we have an instance of <a class="reference internal" href="#c.i3c_device" title="i3c_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_device</span></code></a>.</p>
<dl class="type">
<dt id="c.i3c_bus_mode">
enum <code class="sig-name descname">i3c_bus_mode</code><a class="headerlink" href="#c.i3c_bus_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>I3C bus mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">I3C_BUS_MODE_PURE</span></code></dt><dd><p>only I3C devices are connected to the bus. No limitation
expected</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I3C_BUS_MODE_MIXED_FAST</span></code></dt><dd><p>I2C devices with 50ns spike filter are present on
the bus. The only impact in this mode is that the
high SCL pulse has to stay below 50ns to trick I2C
devices when transmitting I3C frames</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I3C_BUS_MODE_MIXED_LIMITED</span></code></dt><dd><p>I2C devices without 50ns spike filter are
present on the bus. However they allow
compliance up to the maximum SDR SCL clock
frequency.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I3C_BUS_MODE_MIXED_SLOW</span></code></dt><dd><p>I2C devices without 50ns spike filter are present
on the bus</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.i3c_addr_slot_status">
enum <code class="sig-name descname">i3c_addr_slot_status</code><a class="headerlink" href="#c.i3c_addr_slot_status" title="Permalink to this definition">¶</a></dt>
<dd><p>I3C address slot status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">I3C_ADDR_SLOT_FREE</span></code></dt><dd><p>address is free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I3C_ADDR_SLOT_RSVD</span></code></dt><dd><p>address is reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I3C_ADDR_SLOT_I2C_DEV</span></code></dt><dd><p>address is assigned to an I2C device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I3C_ADDR_SLOT_I3C_DEV</span></code></dt><dd><p>address is assigned to an I3C device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I3C_ADDR_SLOT_STATUS_MASK</span></code></dt><dd><p>address slot mask</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>On an I3C bus, addresses are assigned dynamically, and we need to know which
addresses are free to use and which ones are already assigned.</p>
<p>Addresses marked as reserved are those reserved by the I3C protocol
(broadcast address, …).</p>
<dl class="type">
<dt id="c.i3c_bus">
struct <code class="sig-name descname">i3c_bus</code><a class="headerlink" href="#c.i3c_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>I3C bus object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i3c_bus {
    struct i3c_dev_desc *cur_master;
    int id;
    unsigned long addrslots[((I2C_MAX_ADDR + 1) * 2) / BITS_PER_LONG];
    enum i3c_bus_mode mode;
    struct {
        unsigned long i3c;
        unsigned long i2c;
    } scl_rate;
    struct {
        struct list_head i3c;
        struct list_head i2c;
    } devs;
    struct rw_semaphore lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cur_master</span></code></dt><dd><p>I3C master currently driving the bus. Since I3C is multi-master
this can change over the time. Will be used to let a master
know whether it needs to request bus ownership before sending
a frame or not</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>bus ID. Assigned by the framework when register the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addrslots</span></code></dt><dd><p>a bitmap with 2-bits per-slot to encode the address status and
ease the DAA (Dynamic Address Assignment) procedure (see
<a class="reference internal" href="#c.i3c_addr_slot_status" title="i3c_addr_slot_status"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">i3c_addr_slot_status</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mode</span></code></dt><dd><p>bus mode (see <a class="reference internal" href="#c.i3c_bus_mode" title="i3c_bus_mode"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">i3c_bus_mode</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scl_rate</span></code></dt><dd><p>SCL signal rate for I3C and I2C mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scl_rate.i3c</span></code></dt><dd><p>maximum rate for the clock signal when doing I3C SDR/priv
transfers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scl_rate.i2c</span></code></dt><dd><p>maximum rate for the clock signal when doing I2C transfers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devs</span></code></dt><dd><p>2 lists containing all I3C/I2C devices connected to the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devs.i3c</span></code></dt><dd><p>contains a list of I3C device descriptors representing I3C
devices connected on the bus and successfully attached to the
I3C master</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devs.i2c</span></code></dt><dd><p>contains a list of I2C device descriptors representing I2C
devices connected on the bus and successfully attached to the
I3C master</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>read/write lock on the bus. This is needed to protect against
operations that have an impact on the whole bus and the devices
connected to it. For example, when asking slaves to drop their
dynamic address (RSTDAA CCC), we need to make sure no one is trying
to send I3C frames to these devices.
Note that this lock does not protect against concurrency between
devices: several drivers can send different I3C/I2C frames through
the same master in parallel. This is the responsibility of the
master to guarantee that frames are actually sent sequentially and
not interlaced</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The I3C bus is represented with its own object and not implicitly described
by the I3C master to cope with the multi-master functionality, where one bus
can be shared amongst several masters, each of them requesting bus ownership
when they need to.</p>
<dl class="type">
<dt id="c.i3c_master_controller_ops">
struct <code class="sig-name descname">i3c_master_controller_ops</code><a class="headerlink" href="#c.i3c_master_controller_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>I3C master methods</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i3c_master_controller_ops {
    int (*bus_init)(struct i3c_master_controller *master);
    void (*bus_cleanup)(struct i3c_master_controller *master);
    int (*attach_i3c_dev)(struct i3c_dev_desc *dev);
    int (*reattach_i3c_dev)(struct i3c_dev_desc *dev, u8 old_dyn_addr);
    void (*detach_i3c_dev)(struct i3c_dev_desc *dev);
    int (*do_daa)(struct i3c_master_controller *master);
    bool (*supports_ccc_cmd)(struct i3c_master_controller *master, const struct i3c_ccc_cmd *cmd);
    int (*send_ccc_cmd)(struct i3c_master_controller *master, struct i3c_ccc_cmd *cmd);
    int (*priv_xfers)(struct i3c_dev_desc *dev,struct i3c_priv_xfer *xfers, int nxfers);
    int (*attach_i2c_dev)(struct i2c_dev_desc *dev);
    void (*detach_i2c_dev)(struct i2c_dev_desc *dev);
    int (*i2c_xfers)(struct i2c_dev_desc *dev, const struct i2c_msg *xfers, int nxfers);
    int (*request_ibi)(struct i3c_dev_desc *dev, const struct i3c_ibi_setup *req);
    void (*free_ibi)(struct i3c_dev_desc *dev);
    int (*enable_ibi)(struct i3c_dev_desc *dev);
    int (*disable_ibi)(struct i3c_dev_desc *dev);
    void (*recycle_ibi_slot)(struct i3c_dev_desc *dev, struct i3c_ibi_slot *slot);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bus_init</span></code></dt><dd><p>hook responsible for the I3C bus initialization. You should at
least call master_set_info() from there and set the bus mode.
You can also put controller specific initialization in there.
This method is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus_cleanup</span></code></dt><dd><p>cleanup everything done in
<a class="reference internal" href="#c.i3c_master_controller_ops" title="i3c_master_controller_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">i3c_master_controller_ops-&gt;bus_init()</span></code></a>.
This method is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">attach_i3c_dev</span></code></dt><dd><p>called every time an I3C device is attached to the bus. It
can be after a DAA or when a device is statically declared
by the FW, in which case it will only have a static address
and the dynamic address will be 0.
When this function is called, device information have not
been retrieved yet.
This is a good place to attach master controller specific
data to I3C devices.
This method is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reattach_i3c_dev</span></code></dt><dd><p>called every time an I3C device has its addressed
changed. It can be because the device has been powered
down and has lost its address, or it can happen when a
device had a static address and has been assigned a
dynamic address with SETDASA.
This method is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach_i3c_dev</span></code></dt><dd><p>called when an I3C device is detached from the bus. Usually
happens when the master device is unregistered.
This method is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">do_daa</span></code></dt><dd><p>do a DAA (Dynamic Address Assignment) procedure. This is procedure
should send an ENTDAA CCC command and then add all devices
discovered sure the DAA using <a class="reference internal" href="#c.i3c_master_add_i3c_dev_locked" title="i3c_master_add_i3c_dev_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_master_add_i3c_dev_locked()</span></code></a>.
Add devices added with <a class="reference internal" href="#c.i3c_master_add_i3c_dev_locked" title="i3c_master_add_i3c_dev_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_master_add_i3c_dev_locked()</span></code></a> will then be
attached or re-attached to the controller.
This method is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supports_ccc_cmd</span></code></dt><dd><p>should return true if the CCC command is supported, false
otherwise.
This method is optional, if not provided the core assumes
all CCC commands are supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">send_ccc_cmd</span></code></dt><dd><p>send a CCC command
This method is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv_xfers</span></code></dt><dd><p>do one or several private I3C SDR transfers
This method is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">attach_i2c_dev</span></code></dt><dd><p>called every time an I2C device is attached to the bus.
This is a good place to attach master controller specific
data to I2C devices.
This method is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach_i2c_dev</span></code></dt><dd><p>called when an I2C device is detached from the bus. Usually
happens when the master device is unregistered.
This method is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i2c_xfers</span></code></dt><dd><p>do one or several I2C transfers. Note that, unlike i3c
transfers, the core does not guarantee that buffers attached to
the transfers are DMA-safe. If drivers want to have DMA-safe
buffers, they should use the <a class="reference internal" href="../i2c.html#c.i2c_get_dma_safe_msg_buf" title="i2c_get_dma_safe_msg_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_get_dma_safe_msg_buf()</span></code></a>
and <a class="reference internal" href="../i2c.html#c.i2c_put_dma_safe_msg_buf" title="i2c_put_dma_safe_msg_buf"><code class="xref c c-func docutils literal notranslate"><span class="pre">i2c_put_dma_safe_msg_buf()</span></code></a> helpers provided by the I2C
framework.
This method is mandatory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">request_ibi</span></code></dt><dd><p>attach an IBI handler to an I3C device. This implies defining
an IBI handler and the constraints of the IBI (maximum payload
length and number of pre-allocated slots).
Some controllers support less IBI-capable devices than regular
devices, so this method might return -<code class="docutils literal notranslate"><span class="pre">EBUSY</span></code> if there’s no
more space for an extra IBI registration
This method is optional.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free_ibi</span></code></dt><dd><p>free an IBI previously requested with -&gt;request_ibi(). The IBI
should have been disabled with -&gt;<a class="reference internal" href="../../core-api/genericirq.html#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a> prior to that
This method is mandatory only if -&gt;request_ibi is not NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enable_ibi</span></code></dt><dd><p>enable the IBI. Only valid if -&gt;request_ibi() has been called
prior to -&gt;enable_ibi(). The controller should first enable
the IBI on the controller end (for example, unmask the hardware
IRQ) and then send the ENEC CCC command (with the IBI flag set)
to the I3C device.
This method is mandatory only if -&gt;request_ibi is not NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disable_ibi</span></code></dt><dd><p>disable an IBI. First send the DISEC CCC command with the IBI
flag set and then deactivate the hardware IRQ on the
controller end.
This method is mandatory only if -&gt;request_ibi is not NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">recycle_ibi_slot</span></code></dt><dd><p>recycle an IBI slot. Called every time an IBI has been
processed by its handler. The IBI slot should be put back
in the IBI slot pool so that the controller can re-use it
for a future IBI
This method is mandatory only if -&gt;request_ibi is not
NULL.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.i3c_master_controller">
struct <code class="sig-name descname">i3c_master_controller</code><a class="headerlink" href="#c.i3c_master_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>I3C master controller object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct i3c_master_controller {
    struct device dev;
    struct i3c_dev_desc *this;
    struct i2c_adapter i2c;
    const struct i3c_master_controller_ops *ops;
    unsigned int secondary : 1;
    unsigned int init_done : 1;
    struct {
        struct list_head i3c;
        struct list_head i2c;
    } boardinfo;
    struct i3c_bus bus;
    struct workqueue_struct *wq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>device to be registered to the device-model</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">this</span></code></dt><dd><p>an I3C device object representing this master. This device will be
added to the list of I3C devs available on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i2c</span></code></dt><dd><p>I2C adapter used for backward compatibility. This adapter is
registered to the I2C subsystem to be as transparent as possible to
existing I2C drivers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>master operations. See <a class="reference internal" href="#c.i3c_master_controller_ops" title="i3c_master_controller_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller_ops</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secondary</span></code></dt><dd><p>true if the master is a secondary master</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init_done</span></code></dt><dd><p>true when the bus initialization is done</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">boardinfo</span></code></dt><dd><p>board-level information attached to devices connected on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">boardinfo.i3c</span></code></dt><dd><p>list of I3C  boardinfo objects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">boardinfo.i2c</span></code></dt><dd><p>list of I2C boardinfo objects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bus</span></code></dt><dd><p>I3C bus exposed by this master</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>workqueue used to execute IBI handlers. Can also be used by master
drivers if they need to postpone operations that need to take place
in a thread context. Typical examples are Hot Join processing which
requires taking the bus lock in maintenance, which in turn, can only
be done from a sleep-able context</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span></code></a> has to be registered to the I3C subsystem
through <a class="reference internal" href="#c.i3c_master_register" title="i3c_master_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_master_register()</span></code></a>. None of <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span></code></a> fields
should be set manually, just pass appropriate values to
<a class="reference internal" href="#c.i3c_master_register" title="i3c_master_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_master_register()</span></code></a>.</p>
<dl class="function">
<dt id="c.i3c_bus_for_each_i2cdev">
<code class="sig-name descname">i3c_bus_for_each_i2cdev</code><span class="sig-paren">(</span><em>bus</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_bus_for_each_i2cdev" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all I2C devices present on the bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bus</span></code></dt><dd><p>the I3C bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>an I2C device descriptor pointer updated to point to the current slot
at each iteration of the loop</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all I2C devs present on the bus.</p>
</div>
<dl class="function">
<dt id="c.i3c_bus_for_each_i3cdev">
<code class="sig-name descname">i3c_bus_for_each_i3cdev</code><span class="sig-paren">(</span><em>bus</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_bus_for_each_i3cdev" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all I3C devices present on the bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bus</span></code></dt><dd><p>the I3C bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>and I3C device descriptor pointer updated to point to the current slot
at each iteration of the loop</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all I3C devs present on the bus.</p>
</div>
<dl class="function">
<dt id="c.i3c_dev_get_master_data">
void * <code class="sig-name descname">i3c_dev_get_master_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i3c_dev_desc" title="i3c_dev_desc">i3c_dev_desc</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_dev_get_master_data" title="Permalink to this definition">¶</a></dt>
<dd><p>get master private data attached to an I3C device descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i3c_dev_desc</span> <span class="pre">*dev</span></code></dt><dd><p>the I3C device descriptor to get private data from</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>the private data previously attached with i3c_dev_set_master_data()</dt><dd><p>or NULL if no data has been attached to the device.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.i3c_dev_set_master_data">
void <code class="sig-name descname">i3c_dev_set_master_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_dev_desc" title="i3c_dev_desc">i3c_dev_desc</a><em> *dev</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_dev_set_master_data" title="Permalink to this definition">¶</a></dt>
<dd><p>attach master private data to an I3C device descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_dev_desc</span> <span class="pre">*dev</span></code></dt><dd><p>the I3C device descriptor to attach private data to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions allows a master controller to attach per-device private data
which can then be retrieved with <a class="reference internal" href="#c.i3c_dev_get_master_data" title="i3c_dev_get_master_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">i3c_dev_get_master_data()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.i2c_dev_get_master_data">
void * <code class="sig-name descname">i2c_dev_get_master_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_dev_desc" title="i2c_dev_desc">i2c_dev_desc</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_dev_get_master_data" title="Permalink to this definition">¶</a></dt>
<dd><p>get master private data attached to an I2C device descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_dev_desc</span> <span class="pre">*dev</span></code></dt><dd><p>the I2C device descriptor to get private data from</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>the private data previously attached with i2c_dev_set_master_data()</dt><dd><p>or NULL if no data has been attached to the device.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.i2c_dev_set_master_data">
void <code class="sig-name descname">i2c_dev_set_master_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i2c_dev_desc" title="i2c_dev_desc">i2c_dev_desc</a><em> *dev</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_dev_set_master_data" title="Permalink to this definition">¶</a></dt>
<dd><p>attach master private data to an I2C device descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_dev_desc</span> <span class="pre">*dev</span></code></dt><dd><p>the I2C device descriptor to attach private data to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions allows a master controller to attach per-device private data
which can then be retrieved with i2c_device_get_master_data().</p>
</div>
<dl class="function">
<dt id="c.i3c_dev_get_master">
struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a> * <code class="sig-name descname">i3c_dev_get_master</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_dev_desc" title="i3c_dev_desc">i3c_dev_desc</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_dev_get_master" title="Permalink to this definition">¶</a></dt>
<dd><p>get master used to communicate with a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_dev_desc</span> <span class="pre">*dev</span></code></dt><dd><p>I3C dev</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the master controller driving <strong>dev</strong></p>
</div>
<dl class="function">
<dt id="c.i2c_dev_get_master">
struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a> * <code class="sig-name descname">i2c_dev_get_master</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i2c_dev_desc" title="i2c_dev_desc">i2c_dev_desc</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_dev_get_master" title="Permalink to this definition">¶</a></dt>
<dd><p>get master used to communicate with a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i2c_dev_desc</span> <span class="pre">*dev</span></code></dt><dd><p>I2C dev</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the master controller driving <strong>dev</strong></p>
</div>
<dl class="function">
<dt id="c.i3c_master_get_bus">
struct <a class="reference internal" href="#c.i3c_bus" title="i3c_bus">i3c_bus</a> * <code class="sig-name descname">i3c_master_get_bus</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i3c_master_controller" title="i3c_master_controller">i3c_master_controller</a><em> *master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i3c_master_get_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>get the bus attached to a master</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">i3c_master_controller</span> <span class="pre">*master</span></code></dt><dd><p>master object</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the I3C bus <strong>master</strong> is connected to</p>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/i3c/master-driver-api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/i3c/master-driver-api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>