
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Managing Ownership of the Framebuffer Aperture &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Frame Buffer Library" href="frame-buffer.html" />
    <link rel="prev" title="InfiniBand and Remote DMA (RDMA) Interfaces" href="infiniband.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="managing-ownership-of-the-framebuffer-aperture">
<h1>Managing Ownership of the Framebuffer Aperture<a class="headerlink" href="#managing-ownership-of-the-framebuffer-aperture" title="Permalink to this headline">¶</a></h1>
<p>A graphics device might be supported by different drivers, but only one
driver can be active at any given time. Many systems load a generic
graphics drivers, such as EFI-GOP or VESA, early during the boot process.
During later boot stages, they replace the generic driver with a dedicated,
hardware-specific driver. To take over the device the dedicated driver
first has to remove the generic driver. Aperture functions manage
ownership of framebuffer memory and hand-over between drivers.</p>
<p>Graphics drivers should call <a class="reference internal" href="#c.aperture_remove_conflicting_devices" title="aperture_remove_conflicting_devices"><code class="xref c c-func docutils literal notranslate"><span class="pre">aperture_remove_conflicting_devices()</span></code></a>
at the top of their probe function. The function removes any generic
driver that is currently associated with the given framebuffer memory.
An example for a graphics device on the platform bus is shown below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">example_probe</span><span class="p">(</span><span class="k">struct</span> <span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">resource</span><span class="w"> </span><span class="o">*</span><span class="n">mem</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">resource_size_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="w"> </span><span class="n">IORESOURCE_MEM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mem</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resource_size</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aperture_remove_conflicting_devices</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;example&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Initialize the hardware</span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">platform_driver</span><span class="w"> </span><span class="n">example_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_probe</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The given example reads the platform device’s I/O-memory range from the
device instance. An active framebuffer will be located within this range.
The call to <a class="reference internal" href="#c.aperture_remove_conflicting_devices" title="aperture_remove_conflicting_devices"><code class="xref c c-func docutils literal notranslate"><span class="pre">aperture_remove_conflicting_devices()</span></code></a> releases drivers that
have previously claimed ownership of the range and are currently driving
output on the framebuffer. If successful, the new driver can take over
the device.</p>
<p>While the given example uses a platform device, the aperture helpers work
with every bus that has an addressable framebuffer. In the case of PCI,
device drivers can also call <a class="reference internal" href="#c.aperture_remove_conflicting_pci_devices" title="aperture_remove_conflicting_pci_devices"><code class="xref c c-func docutils literal notranslate"><span class="pre">aperture_remove_conflicting_pci_devices()</span></code></a> and
let the function detect the apertures automatically. Device drivers without
knowledge of the framebuffer’s location can call
<a class="reference internal" href="#c.aperture_remove_all_conflicting_devices" title="aperture_remove_all_conflicting_devices"><code class="xref c c-func docutils literal notranslate"><span class="pre">aperture_remove_all_conflicting_devices()</span></code></a>, which removes all known devices.</p>
<p>Drivers that are susceptible to being removed by other drivers, such as
generic EFI or VESA drivers, have to register themselves as owners of their
framebuffer apertures. Ownership of the framebuffer memory is achieved
by calling <a class="reference internal" href="#c.devm_aperture_acquire_for_platform_device" title="devm_aperture_acquire_for_platform_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_aperture_acquire_for_platform_device()</span></code></a>. If successful, the
driveris the owner of the framebuffer range. The function fails if the
framebuffer is already owned by another driver. See below for an example.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">generic_probe</span><span class="p">(</span><span class="k">struct</span> <span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span> <span class="nc">resource</span><span class="w"> </span><span class="o">*</span><span class="n">mem</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">resource_size_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="w"> </span><span class="n">IORESOURCE_MEM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mem</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resource_size</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_aperture_acquire_for_platform_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Initialize the hardware</span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">generic_remove</span><span class="p">(</span><span class="k">struct</span> <span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Hot-unplug the device</span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">platform_driver</span><span class="w"> </span><span class="n">generic_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generic_probe</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">generic_remove</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The similar to the previous example, the generic driver claims ownership
of the framebuffer memory from its probe function. This will fail if the
memory range, or parts of it, is already owned by another driver.</p>
<p>If successful, the generic driver is now subject to forced removal by
another driver. This only works for platform drivers that support hot
unplugging. When a driver calls <a class="reference internal" href="#c.aperture_remove_conflicting_devices" title="aperture_remove_conflicting_devices"><code class="xref c c-func docutils literal notranslate"><span class="pre">aperture_remove_conflicting_devices()</span></code></a>
et al for the registered framebuffer range, the aperture helpers call
<a class="reference internal" href="infrastructure.html#c.platform_device_unregister" title="platform_device_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">platform_device_unregister()</span></code></a> and the generic driver unloads itself. The
generic driver also has to provide a remove function to make this work.
Once hot unplugged fro mhardware, it may not access the device’s
registers, framebuffer memory, ROM, etc afterwards.</p>
<dl class="function">
<dt id="c.aperture_remove_all_conflicting_devices">
int <code class="sig-name descname">aperture_remove_all_conflicting_devices</code><span class="sig-paren">(</span>bool<em> primary</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.aperture_remove_all_conflicting_devices" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all existing framebuffers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">primary</span></code></dt><dd><p>also kick vga16fb if present; only relevant for VGA devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a descriptive name of the requesting driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes all graphics device drivers. Use this function on systems
that can have their framebuffer located anywhere in memory.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno code otherwise</p>
</div>
<dl class="function">
<dt id="c.devm_aperture_acquire_for_platform_device">
int <code class="sig-name descname">devm_aperture_acquire_for_platform_device</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em>, resource_size_t<em> base</em>, resource_size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_aperture_acquire_for_platform_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquires ownership of an aperture on behalf of a platform device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>the platform device to own the aperture</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">base</span></code></dt><dd><p>the aperture’s byte offset in physical memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>the aperture size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Installs the given device as the new owner of the aperture. The function
expects the aperture to be provided by a platform device. If another
driver takes over ownership of the aperture, aperture helpers will then
unregister the platform device automatically. All acquired apertures are
released automatically when the underlying device goes away.</p>
<p>The function fails if the aperture, or parts of it, is currently
owned by another device. To evict current owners, callers should use
remove_conflicting_devices() et al. before calling this function.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno value otherwise.</p>
</div>
<dl class="function">
<dt id="c.aperture_remove_conflicting_devices">
int <code class="sig-name descname">aperture_remove_conflicting_devices</code><span class="sig-paren">(</span>resource_size_t<em> base</em>, resource_size_t<em> size</em>, bool<em> primary</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.aperture_remove_conflicting_devices" title="Permalink to this definition">¶</a></dt>
<dd><p>remove devices in the given range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">base</span></code></dt><dd><p>the aperture’s base address in physical memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt><dd><p>aperture size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">primary</span></code></dt><dd><p>also kick vga16fb if present; only relevant for VGA devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a descriptive name of the requesting driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes devices that own apertures within <strong>base</strong> and <strong>size</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno code otherwise</p>
</div>
<dl class="function">
<dt id="c.aperture_remove_conflicting_pci_devices">
int <code class="sig-name descname">aperture_remove_conflicting_pci_devices</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.aperture_remove_conflicting_pci_devices" title="Permalink to this definition">¶</a></dt>
<dd><p>remove existing framebuffers for PCI devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>PCI device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>a descriptive name of the requesting driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes devices that own apertures within any of <strong>pdev</strong>’s
memory bars. The function assumes that PCI device with shadowed ROM
drives a primary display and therefore kicks out vga16fb as well.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno code otherwise</p>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/aperture.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/aperture.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>