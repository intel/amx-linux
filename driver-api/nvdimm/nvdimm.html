
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>LIBNVDIMM: Non-Volatile Devices &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="BTT - Block Translation Table" href="btt.html" />
    <link rel="prev" title="Non-Volatile Memory Device (NVDIMM)" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="libnvdimm-non-volatile-devices">
<h1>LIBNVDIMM: Non-Volatile Devices<a class="headerlink" href="#libnvdimm-non-volatile-devices" title="Permalink to this headline">¶</a></h1>
<p>libnvdimm - kernel / libndctl - userspace helper library</p>
<p><a class="reference external" href="mailto:nvdimm&#37;&#52;&#48;lists&#46;linux&#46;dev">nvdimm<span>&#64;</span>lists<span>&#46;</span>linux<span>&#46;</span>dev</a></p>
<p>Version 13</p>
<section id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>PMEM:</dt><dd><p>A system-physical-address range where writes are persistent.  A
block device composed of PMEM is capable of DAX.  A PMEM address range
may span an interleave of several DIMMs.</p>
</dd>
<dt>DPA:</dt><dd><p>DIMM Physical Address, is a DIMM-relative offset.  With one DIMM in
the system there would be a 1:1 system-physical-address:DPA association.
Once more DIMMs are added a memory controller interleave must be
decoded to determine the DPA associated with a given
system-physical-address.</p>
</dd>
<dt>DAX:</dt><dd><p>File system extensions to bypass the page cache and block layer to
mmap persistent memory, from a PMEM block device, directly into a
process address space.</p>
</dd>
<dt>DSM:</dt><dd><p>Device Specific Method: ACPI method to control specific
device - in this case the firmware.</p>
</dd>
<dt>DCR:</dt><dd><p>NVDIMM Control Region Structure defined in ACPI 6 Section 5.2.25.5.
It defines a vendor-id, device-id, and interface format for a given DIMM.</p>
</dd>
<dt>BTT:</dt><dd><p>Block Translation Table: Persistent memory is byte addressable.
Existing software may have an expectation that the power-fail-atomicity
of writes is at least one sector, 512 bytes.  The BTT is an indirection
table with atomic update semantics to front a PMEM block device
driver and present arbitrary atomic sector sizes.</p>
</dd>
<dt>LABEL:</dt><dd><p>Metadata stored on a DIMM device that partitions and identifies
(persistently names) capacity allocated to different PMEM namespaces. It
also indicates whether an address abstraction like a BTT is applied to
the namepsace.  Note that traditional partition tables, GPT/MBR, are
layered on top of a PMEM namespace, or an address abstraction like BTT
if present, but partition support is deprecated going forward.</p>
</dd>
</dl>
</section>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The LIBNVDIMM subsystem provides support for PMEM described by platform
firmware or a device driver. On ACPI based systems the platform firmware
conveys persistent memory resource via the ACPI NFIT “NVDIMM Firmware
Interface Table” in ACPI 6. While the LIBNVDIMM subsystem implementation
is generic and supports pre-NFIT platforms, it was guided by the
superset of capabilities need to support this ACPI 6 definition for
NVDIMM resources. The original implementation supported the
block-window-aperture capability described in the NFIT, but that support
has since been abandoned and never shipped in a product.</p>
<section id="supporting-documents">
<h3>Supporting Documents<a class="headerlink" href="#supporting-documents" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>ACPI 6:</dt><dd><p><a class="reference external" href="https://www.uefi.org/sites/default/files/resources/ACPI_6.0.pdf">https://www.uefi.org/sites/default/files/resources/ACPI_6.0.pdf</a></p>
</dd>
<dt>NVDIMM Namespace:</dt><dd><p><a class="reference external" href="https://pmem.io/documents/NVDIMM_Namespace_Spec.pdf">https://pmem.io/documents/NVDIMM_Namespace_Spec.pdf</a></p>
</dd>
<dt>DSM Interface Example:</dt><dd><p><a class="reference external" href="https://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf">https://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf</a></p>
</dd>
<dt>Driver Writer’s Guide:</dt><dd><p><a class="reference external" href="https://pmem.io/documents/NVDIMM_Driver_Writers_Guide.pdf">https://pmem.io/documents/NVDIMM_Driver_Writers_Guide.pdf</a></p>
</dd>
</dl>
</section>
<section id="git-trees">
<h3>Git Trees<a class="headerlink" href="#git-trees" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>LIBNVDIMM:</dt><dd><p><a class="reference external" href="https://git.kernel.org/cgit/linux/kernel/git/nvdimm/nvdimm.git">https://git.kernel.org/cgit/linux/kernel/git/nvdimm/nvdimm.git</a></p>
</dd>
<dt>LIBNDCTL:</dt><dd><p><a class="reference external" href="https://github.com/pmem/ndctl.git">https://github.com/pmem/ndctl.git</a></p>
</dd>
</dl>
</section>
</section>
<section id="libnvdimm-pmem">
<h2>LIBNVDIMM PMEM<a class="headerlink" href="#libnvdimm-pmem" title="Permalink to this headline">¶</a></h2>
<p>Prior to the arrival of the NFIT, non-volatile memory was described to a
system in various ad-hoc ways.  Usually only the bare minimum was
provided, namely, a single system-physical-address range where writes
are expected to be durable after a system power loss.  Now, the NFIT
specification standardizes not only the description of PMEM, but also
platform message-passing entry points for control and configuration.</p>
<p>PMEM (nd_pmem.ko): Drives a system-physical-address range.  This range is
contiguous in system memory and may be interleaved (hardware memory controller
striped) across multiple DIMMs.  When interleaved the platform may optionally
provide details of which DIMMs are participating in the interleave.</p>
<p>It is worth noting that when the labeling capability is detected (a EFI
namespace label index block is found), then no block device is created
by default as userspace needs to do at least one allocation of DPA to
the PMEM range.  In contrast ND_NAMESPACE_IO ranges, once registered,
can be immediately attached to nd_pmem. This latter mode is called
label-less or “legacy”.</p>
<section id="pmem-regions-atomic-sectors-and-dax">
<h3>PMEM-REGIONs, Atomic Sectors, and DAX<a class="headerlink" href="#pmem-regions-atomic-sectors-and-dax" title="Permalink to this headline">¶</a></h3>
<p>For the cases where an application or filesystem still needs atomic sector
update guarantees it can register a BTT on a PMEM device or partition.  See
LIBNVDIMM/NDCTL: Block Translation Table “btt”</p>
</section>
</section>
<section id="example-nvdimm-platform">
<h2>Example NVDIMM Platform<a class="headerlink" href="#example-nvdimm-platform" title="Permalink to this headline">¶</a></h2>
<p>For the remainder of this document the following diagram will be
referenced for any example sysfs layouts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                             (a)               (b)           DIMM
          +-------------------+--------+--------+--------+
+------+  |       pm0.0       |  free  | pm1.0  |  free  |    0
| imc0 +--+- - - region0- - - +--------+        +--------+
+--+---+  |       pm0.0       |  free  | pm1.0  |  free  |    1
   |      +-------------------+--------v        v--------+
+--+---+                               |                 |
| cpu0 |                                     region1
+--+---+                               |                 |
   |      +----------------------------^        ^--------+
+--+---+  |           free             | pm1.0  |  free  |    2
| imc1 +--+----------------------------|        +--------+
+------+  |           free             | pm1.0  |  free  |    3
          +----------------------------+--------+--------+
</pre></div>
</div>
<p>In this platform we have four DIMMs and two memory controllers in one
socket.  Each PMEM interleave set is identified by a region device with
a dynamically assigned id.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The first portion of DIMM0 and DIMM1 are interleaved as REGION0. A
single PMEM namespace is created in the REGION0-SPA-range that spans most
of DIMM0 and DIMM1 with a user-specified name of “pm0.0”. Some of that
interleaved system-physical-address range is left free for
another PMEM namespace to be defined.</p></li>
<li><p>In the last portion of DIMM0 and DIMM1 we have an interleaved
system-physical-address range, REGION1, that spans those two DIMMs as
well as DIMM2 and DIMM3.  Some of REGION1 is allocated to a PMEM namespace
named “pm1.0”.</p></li>
</ol>
<p>This bus is provided by the kernel under the device
/sys/devices/platform/nfit_test.0 when the nfit_test.ko module from
tools/testing/nvdimm is loaded. This module is a unit test for
LIBNVDIMM and the  acpi_nfit.ko driver.</p>
</div></blockquote>
</section>
<section id="libnvdimm-kernel-device-model-and-libndctl-userspace-api">
<h2>LIBNVDIMM Kernel Device Model and LIBNDCTL Userspace API<a class="headerlink" href="#libnvdimm-kernel-device-model-and-libndctl-userspace-api" title="Permalink to this headline">¶</a></h2>
<p>What follows is a description of the LIBNVDIMM sysfs layout and a
corresponding object hierarchy diagram as viewed through the LIBNDCTL
API.  The example sysfs paths and diagrams are relative to the Example
NVDIMM Platform which is also the LIBNVDIMM bus used in the LIBNDCTL unit
test.</p>
<section id="libndctl-context">
<h3>LIBNDCTL: Context<a class="headerlink" href="#libndctl-context" title="Permalink to this headline">¶</a></h3>
<p>Every API call in the LIBNDCTL library requires a context that holds the
logging parameters and other library instance state.  The library is
based on the libabc template:</p>
<blockquote>
<div><p><a class="reference external" href="https://git.kernel.org/cgit/linux/kernel/git/kay/libabc.git">https://git.kernel.org/cgit/linux/kernel/git/kay/libabc.git</a></p>
</div></blockquote>
<section id="libndctl-instantiate-a-new-library-context-example">
<h4>LIBNDCTL: instantiate a new library context example<a class="headerlink" href="#libndctl-instantiate-a-new-library-context-example" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ndctl_ctx *ctx;

if (ndctl_new(&amp;ctx) == 0)
        return ctx;
else
        return NULL;
</pre></div>
</div>
</section>
</section>
<section id="libnvdimm-libndctl-bus">
<h3>LIBNVDIMM/LIBNDCTL: Bus<a class="headerlink" href="#libnvdimm-libndctl-bus" title="Permalink to this headline">¶</a></h3>
<p>A bus has a 1:1 relationship with an NFIT.  The current expectation for
ACPI based systems is that there is only ever one platform-global NFIT.
That said, it is trivial to register multiple NFITs, the specification
does not preclude it.  The infrastructure supports multiple busses and
we use this capability to test multiple NFIT configurations in the unit
test.</p>
</section>
<section id="libnvdimm-control-class-device-in-sys-class">
<h3>LIBNVDIMM: control class device in /sys/class<a class="headerlink" href="#libnvdimm-control-class-device-in-sys-class" title="Permalink to this headline">¶</a></h3>
<p>This character device accepts DSM messages to be passed to DIMM
identified by its NFIT handle:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/class/nd/ndctl0
|-- dev
|-- device -&gt; ../../../ndbus0
|-- subsystem -&gt; ../../../../../../../class/nd
</pre></div>
</div>
</section>
<section id="libnvdimm-bus">
<h3>LIBNVDIMM: bus<a class="headerlink" href="#libnvdimm-bus" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nvdimm_bus *nvdimm_bus_register(struct device *parent,
       struct nvdimm_bus_descriptor *nfit_desc);
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/platform/nfit_test.0/ndbus0
|-- commands
|-- nd
|-- nfit
|-- nmem0
|-- nmem1
|-- nmem2
|-- nmem3
|-- power
|-- provider
|-- region0
|-- region1
|-- region2
|-- region3
|-- region4
|-- region5
|-- uevent
`-- wait_probe
</pre></div>
</div>
<section id="libndctl-bus-enumeration-example">
<h4>LIBNDCTL: bus enumeration example<a class="headerlink" href="#libndctl-bus-enumeration-example" title="Permalink to this headline">¶</a></h4>
<p>Find the bus handle that describes the bus from Example NVDIMM Platform:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct ndctl_bus *get_bus_by_provider(struct ndctl_ctx *ctx,
                const char *provider)
{
        struct ndctl_bus *bus;

        ndctl_bus_foreach(ctx, bus)
                if (strcmp(provider, ndctl_bus_get_provider(bus)) == 0)
                        return bus;

        return NULL;
}

bus = get_bus_by_provider(ctx, &quot;nfit_test.0&quot;);
</pre></div>
</div>
</section>
</section>
<section id="libnvdimm-libndctl-dimm-nmem">
<h3>LIBNVDIMM/LIBNDCTL: DIMM (NMEM)<a class="headerlink" href="#libnvdimm-libndctl-dimm-nmem" title="Permalink to this headline">¶</a></h3>
<p>The DIMM device provides a character device for sending commands to
hardware, and it is a container for LABELs.  If the DIMM is defined by
NFIT then an optional ‘nfit’ attribute sub-directory is available to add
NFIT-specifics.</p>
<p>Note that the kernel device name for “DIMMs” is “nmemX”.  The NFIT
describes these devices via “Memory Device to System Physical Address
Range Mapping Structure”, and there is no requirement that they actually
be physical DIMMs, so we use a more generic name.</p>
<section id="libnvdimm-dimm-nmem">
<h4>LIBNVDIMM: DIMM (NMEM)<a class="headerlink" href="#libnvdimm-dimm-nmem" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nvdimm *nvdimm_create(struct nvdimm_bus *nvdimm_bus, void *provider_data,
                const struct attribute_group **groups, unsigned long flags,
                unsigned long *dsm_mask);
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/platform/nfit_test.0/ndbus0
|-- nmem0
|   |-- available_slots
|   |-- commands
|   |-- dev
|   |-- devtype
|   |-- driver -&gt; ../../../../../bus/nd/drivers/nvdimm
|   |-- modalias
|   |-- nfit
|   |   |-- device
|   |   |-- format
|   |   |-- handle
|   |   |-- phys_id
|   |   |-- rev_id
|   |   |-- serial
|   |   `-- vendor
|   |-- state
|   |-- subsystem -&gt; ../../../../../bus/nd
|   `-- uevent
|-- nmem1
[..]
</pre></div>
</div>
</section>
<section id="libndctl-dimm-enumeration-example">
<h4>LIBNDCTL: DIMM enumeration example<a class="headerlink" href="#libndctl-dimm-enumeration-example" title="Permalink to this headline">¶</a></h4>
<p>Note, in this example we are assuming NFIT-defined DIMMs which are
identified by an “nfit_handle” a 32-bit value where:</p>
<blockquote>
<div><ul class="simple">
<li><p>Bit 3:0 DIMM number within the memory channel</p></li>
<li><p>Bit 7:4 memory channel number</p></li>
<li><p>Bit 11:8 memory controller ID</p></li>
<li><p>Bit 15:12 socket ID (within scope of a Node controller if node
controller is present)</p></li>
<li><p>Bit 27:16 Node Controller ID</p></li>
<li><p>Bit 31:28 Reserved</p></li>
</ul>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct ndctl_dimm *get_dimm_by_handle(struct ndctl_bus *bus,
       unsigned int handle)
{
        struct ndctl_dimm *dimm;

        ndctl_dimm_foreach(bus, dimm)
                if (ndctl_dimm_get_handle(dimm) == handle)
                        return dimm;

        return NULL;
}

#define DIMM_HANDLE(n, s, i, c, d) \
        (((n &amp; 0xfff) &lt;&lt; 16) | ((s &amp; 0xf) &lt;&lt; 12) | ((i &amp; 0xf) &lt;&lt; 8) \
         | ((c &amp; 0xf) &lt;&lt; 4) | (d &amp; 0xf))

dimm = get_dimm_by_handle(bus, DIMM_HANDLE(0, 0, 0, 0, 0));
</pre></div>
</div>
</section>
</section>
<section id="libnvdimm-libndctl-region">
<h3>LIBNVDIMM/LIBNDCTL: Region<a class="headerlink" href="#libnvdimm-libndctl-region" title="Permalink to this headline">¶</a></h3>
<p>A generic REGION device is registered for each PMEM interleave-set /
range. Per the example there are 2 PMEM regions on the “nfit_test.0”
bus. The primary role of regions are to be a container of “mappings”.  A
mapping is a tuple of &lt;DIMM, DPA-start-offset, length&gt;.</p>
<p>LIBNVDIMM provides a built-in driver for REGION devices.  This driver
is responsible for all parsing LABELs, if present, and then emitting NAMESPACE
devices for the nd_pmem driver to consume.</p>
<p>In addition to the generic attributes of “mapping”s, “interleave_ways”
and “size” the REGION device also exports some convenience attributes.
“nstype” indicates the integer type of namespace-device this region
emits, “devtype” duplicates the DEVTYPE variable stored by udev at the
‘add’ event, “modalias” duplicates the MODALIAS variable stored by udev
at the ‘add’ event, and finally, the optional “spa_index” is provided in
the case where the region is defined by a SPA.</p>
<p>LIBNVDIMM: region:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nd_region *nvdimm_pmem_region_create(struct nvdimm_bus *nvdimm_bus,
                struct nd_region_desc *ndr_desc);
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/platform/nfit_test.0/ndbus0
|-- region0
|   |-- available_size
|   |-- btt0
|   |-- btt_seed
|   |-- devtype
|   |-- driver -&gt; ../../../../../bus/nd/drivers/nd_region
|   |-- init_namespaces
|   |-- mapping0
|   |-- mapping1
|   |-- mappings
|   |-- modalias
|   |-- namespace0.0
|   |-- namespace_seed
|   |-- numa_node
|   |-- nfit
|   |   `-- spa_index
|   |-- nstype
|   |-- set_cookie
|   |-- size
|   |-- subsystem -&gt; ../../../../../bus/nd
|   `-- uevent
|-- region1
[..]
</pre></div>
</div>
<section id="libndctl-region-enumeration-example">
<h4>LIBNDCTL: region enumeration example<a class="headerlink" href="#libndctl-region-enumeration-example" title="Permalink to this headline">¶</a></h4>
<p>Sample region retrieval routines based on NFIT-unique data like
“spa_index” (interleave set id).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct ndctl_region *get_pmem_region_by_spa_index(struct ndctl_bus *bus,
                unsigned int spa_index)
{
        struct ndctl_region *region;

        ndctl_region_foreach(bus, region) {
                if (ndctl_region_get_type(region) != ND_DEVICE_REGION_PMEM)
                        continue;
                if (ndctl_region_get_spa_index(region) == spa_index)
                        return region;
        }
        return NULL;
}
</pre></div>
</div>
</section>
</section>
<section id="libnvdimm-libndctl-namespace">
<h3>LIBNVDIMM/LIBNDCTL: Namespace<a class="headerlink" href="#libnvdimm-libndctl-namespace" title="Permalink to this headline">¶</a></h3>
<p>A REGION, after resolving DPA aliasing and LABEL specified boundaries, surfaces
one or more “namespace” devices.  The arrival of a “namespace” device currently
triggers the nd_pmem driver to load and register a disk/block device.</p>
<section id="libnvdimm-namespace">
<h4>LIBNVDIMM: namespace<a class="headerlink" href="#libnvdimm-namespace" title="Permalink to this headline">¶</a></h4>
<p>Here is a sample layout from the 2 major types of NAMESPACE where namespace0.0
represents DIMM-info-backed PMEM (note that it has a ‘uuid’ attribute), and
namespace1.0 represents an anonymous PMEM namespace (note that has no ‘uuid’
attribute due to not support a LABEL)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/platform/nfit_test.0/ndbus0/region0/namespace0.0
|-- alt_name
|-- devtype
|-- dpa_extents
|-- force_raw
|-- modalias
|-- numa_node
|-- resource
|-- size
|-- subsystem -&gt; ../../../../../../bus/nd
|-- type
|-- uevent
`-- uuid
/sys/devices/platform/nfit_test.1/ndbus1/region1/namespace1.0
|-- block
|   `-- pmem0
|-- devtype
|-- driver -&gt; ../../../../../../bus/nd/drivers/pmem
|-- force_raw
|-- modalias
|-- numa_node
|-- resource
|-- size
|-- subsystem -&gt; ../../../../../../bus/nd
|-- type
`-- uevent
</pre></div>
</div>
</section>
<section id="libndctl-namespace-enumeration-example">
<h4>LIBNDCTL: namespace enumeration example<a class="headerlink" href="#libndctl-namespace-enumeration-example" title="Permalink to this headline">¶</a></h4>
<p>Namespaces are indexed relative to their parent region, example below.
These indexes are mostly static from boot to boot, but subsystem makes
no guarantees in this regard.  For a static namespace identifier use its
‘uuid’ attribute.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct ndctl_namespace
*get_namespace_by_id(struct ndctl_region *region, unsigned int id)
{
        struct ndctl_namespace *ndns;

        ndctl_namespace_foreach(region, ndns)
                if (ndctl_namespace_get_id(ndns) == id)
                        return ndns;

        return NULL;
}
</pre></div>
</div>
</section>
<section id="libndctl-namespace-creation-example">
<h4>LIBNDCTL: namespace creation example<a class="headerlink" href="#libndctl-namespace-creation-example" title="Permalink to this headline">¶</a></h4>
<p>Idle namespaces are automatically created by the kernel if a given
region has enough available capacity to create a new namespace.
Namespace instantiation involves finding an idle namespace and
configuring it.  For the most part the setting of namespace attributes
can occur in any order, the only constraint is that ‘uuid’ must be set
before ‘size’.  This enables the kernel to track DPA allocations
internally with a static identifier:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int configure_namespace(struct ndctl_region *region,
                struct ndctl_namespace *ndns,
                struct namespace_parameters *parameters)
{
        char devname[50];

        snprintf(devname, sizeof(devname), &quot;namespace%d.%d&quot;,
                        ndctl_region_get_id(region), paramaters-&gt;id);

        ndctl_namespace_set_alt_name(ndns, devname);
        /* &#39;uuid&#39; must be set prior to setting size! */
        ndctl_namespace_set_uuid(ndns, paramaters-&gt;uuid);
        ndctl_namespace_set_size(ndns, paramaters-&gt;size);
        /* unlike pmem namespaces, blk namespaces have a sector size */
        if (parameters-&gt;lbasize)
                ndctl_namespace_set_sector_size(ndns, parameters-&gt;lbasize);
        ndctl_namespace_enable(ndns);
}
</pre></div>
</div>
</section>
<section id="why-the-term-namespace">
<h4>Why the Term “namespace”?<a class="headerlink" href="#why-the-term-namespace" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ol class="arabic simple">
<li><p>Why not “volume” for instance?  “volume” ran the risk of confusing
ND (libnvdimm subsystem) to a volume manager like device-mapper.</p></li>
<li><p>The term originated to describe the sub-devices that can be created
within a NVME controller (see the nvme specification:
<a class="reference external" href="https://www.nvmexpress.org/specifications/">https://www.nvmexpress.org/specifications/</a>), and NFIT namespaces are
meant to parallel the capabilities and configurability of
NVME-namespaces.</p></li>
</ol>
</div></blockquote>
</section>
</section>
<section id="libnvdimm-libndctl-block-translation-table-btt">
<h3>LIBNVDIMM/LIBNDCTL: Block Translation Table “btt”<a class="headerlink" href="#libnvdimm-libndctl-block-translation-table-btt" title="Permalink to this headline">¶</a></h3>
<p>A BTT (design document: <a class="reference external" href="https://pmem.io/2014/09/23/btt.html">https://pmem.io/2014/09/23/btt.html</a>) is a
personality driver for a namespace that fronts entire namespace as an
‘address abstraction’.</p>
<section id="libnvdimm-btt-layout">
<h4>LIBNVDIMM: btt layout<a class="headerlink" href="#libnvdimm-btt-layout" title="Permalink to this headline">¶</a></h4>
<p>Every region will start out with at least one BTT device which is the
seed device.  To activate it set the “namespace”, “uuid”, and
“sector_size” attributes and then bind the device to the nd_pmem or
nd_blk driver depending on the region type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/sys/devices/platform/nfit_test.1/ndbus0/region0/btt0/
|-- namespace
|-- delete
|-- devtype
|-- modalias
|-- numa_node
|-- sector_size
|-- subsystem -&gt; ../../../../../bus/nd
|-- uevent
`-- uuid
</pre></div>
</div>
</section>
<section id="libndctl-btt-creation-example">
<h4>LIBNDCTL: btt creation example<a class="headerlink" href="#libndctl-btt-creation-example" title="Permalink to this headline">¶</a></h4>
<p>Similar to namespaces an idle BTT device is automatically created per
region.  Each time this “seed” btt device is configured and enabled a new
seed is created.  Creating a BTT configuration involves two steps of
finding and idle BTT and assigning it to consume a namespace.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct ndctl_btt *get_idle_btt(struct ndctl_region *region)
{
        struct ndctl_btt *btt;

        ndctl_btt_foreach(region, btt)
                if (!ndctl_btt_is_enabled(btt)
                                &amp;&amp; !ndctl_btt_is_configured(btt))
                        return btt;

        return NULL;
}

static int configure_btt(struct ndctl_region *region,
                struct btt_parameters *parameters)
{
        btt = get_idle_btt(region);

        ndctl_btt_set_uuid(btt, parameters-&gt;uuid);
        ndctl_btt_set_sector_size(btt, parameters-&gt;sector_size);
        ndctl_btt_set_namespace(btt, parameters-&gt;ndns);
        /* turn off raw mode device */
        ndctl_namespace_disable(parameters-&gt;ndns);
        /* turn on btt access */
        ndctl_btt_enable(btt);
}
</pre></div>
</div>
<p>Once instantiated a new inactive btt seed device will appear underneath
the region.</p>
<p>Once a “namespace” is removed from a BTT that instance of the BTT device
will be deleted or otherwise reset to default values.  This deletion is
only at the device model level.  In order to destroy a BTT the “info
block” needs to be destroyed.  Note, that to destroy a BTT the media
needs to be written in raw mode.  By default, the kernel will autodetect
the presence of a BTT and disable raw mode.  This autodetect behavior
can be suppressed by enabling raw mode for the namespace via the
ndctl_namespace_set_raw_mode() API.</p>
</section>
</section>
<section id="summary-libndctl-diagram">
<h3>Summary LIBNDCTL Diagram<a class="headerlink" href="#summary-libndctl-diagram" title="Permalink to this headline">¶</a></h3>
<p>For the given example above, here is the view of the objects as seen by the
LIBNDCTL API:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            +---+
            |CTX|
            +-+-+
              |
+-------+     |
| DIMM0 &lt;-+   |      +---------+   +--------------+  +---------------+
+-------+ |   |    +-&gt; REGION0 +---&gt; NAMESPACE0.0 +--&gt; PMEM8 &quot;pm0.0&quot; |
| DIMM1 &lt;-+ +-v--+ | +---------+   +--------------+  +---------------+
+-------+ +-+BUS0+-| +---------+   +--------------+  +----------------------+
| DIMM2 &lt;-+ +----+ +-&gt; REGION1 +---&gt; NAMESPACE1.0 +--&gt; PMEM6 &quot;pm1.0&quot; | BTT1 |
+-------+ |        | +---------+   +--------------+  +---------------+------+
| DIMM3 &lt;-+
+-------+
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">LIBNVDIMM: Non-Volatile Devices</a><ul>
<li><a class="reference internal" href="#glossary">Glossary</a></li>
<li><a class="reference internal" href="#overview">Overview</a><ul>
<li><a class="reference internal" href="#supporting-documents">Supporting Documents</a></li>
<li><a class="reference internal" href="#git-trees">Git Trees</a></li>
</ul>
</li>
<li><a class="reference internal" href="#libnvdimm-pmem">LIBNVDIMM PMEM</a><ul>
<li><a class="reference internal" href="#pmem-regions-atomic-sectors-and-dax">PMEM-REGIONs, Atomic Sectors, and DAX</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-nvdimm-platform">Example NVDIMM Platform</a></li>
<li><a class="reference internal" href="#libnvdimm-kernel-device-model-and-libndctl-userspace-api">LIBNVDIMM Kernel Device Model and LIBNDCTL Userspace API</a><ul>
<li><a class="reference internal" href="#libndctl-context">LIBNDCTL: Context</a><ul>
<li><a class="reference internal" href="#libndctl-instantiate-a-new-library-context-example">LIBNDCTL: instantiate a new library context example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#libnvdimm-libndctl-bus">LIBNVDIMM/LIBNDCTL: Bus</a></li>
<li><a class="reference internal" href="#libnvdimm-control-class-device-in-sys-class">LIBNVDIMM: control class device in /sys/class</a></li>
<li><a class="reference internal" href="#libnvdimm-bus">LIBNVDIMM: bus</a><ul>
<li><a class="reference internal" href="#libndctl-bus-enumeration-example">LIBNDCTL: bus enumeration example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#libnvdimm-libndctl-dimm-nmem">LIBNVDIMM/LIBNDCTL: DIMM (NMEM)</a><ul>
<li><a class="reference internal" href="#libnvdimm-dimm-nmem">LIBNVDIMM: DIMM (NMEM)</a></li>
<li><a class="reference internal" href="#libndctl-dimm-enumeration-example">LIBNDCTL: DIMM enumeration example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#libnvdimm-libndctl-region">LIBNVDIMM/LIBNDCTL: Region</a><ul>
<li><a class="reference internal" href="#libndctl-region-enumeration-example">LIBNDCTL: region enumeration example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#libnvdimm-libndctl-namespace">LIBNVDIMM/LIBNDCTL: Namespace</a><ul>
<li><a class="reference internal" href="#libnvdimm-namespace">LIBNVDIMM: namespace</a></li>
<li><a class="reference internal" href="#libndctl-namespace-enumeration-example">LIBNDCTL: namespace enumeration example</a></li>
<li><a class="reference internal" href="#libndctl-namespace-creation-example">LIBNDCTL: namespace creation example</a></li>
<li><a class="reference internal" href="#why-the-term-namespace">Why the Term “namespace”?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#libnvdimm-libndctl-block-translation-table-btt">LIBNVDIMM/LIBNDCTL: Block Translation Table “btt”</a><ul>
<li><a class="reference internal" href="#libnvdimm-btt-layout">LIBNVDIMM: btt layout</a></li>
<li><a class="reference internal" href="#libndctl-btt-creation-example">LIBNDCTL: btt creation example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-libndctl-diagram">Summary LIBNDCTL Diagram</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/driver-api/nvdimm/nvdimm.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/driver-api/nvdimm/nvdimm.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>