
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Generic Counter Interface &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory Controller drivers" href="memory-devices/index.html" />
    <link rel="prev" title="Ordering I/O writes to memory-mapped addresses" href="io_ordering.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="generic-counter-interface">
<h1>Generic Counter Interface<a class="headerlink" href="#generic-counter-interface" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Counter devices are prevalent among a diverse spectrum of industries.
The ubiquitous presence of these devices necessitates a common interface
and standard of interaction and exposure. This driver API attempts to
resolve the issue of duplicate code found among existing counter device
drivers by introducing a generic counter interface for consumption. The
Generic Counter interface enables drivers to support and expose a common
set of components and functionality present in counter devices.</p>
</section>
<section id="theory">
<h2>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h2>
<p>Counter devices can vary greatly in design, but regardless of whether
some devices are quadrature encoder counters or tally counters, all
counter devices consist of a core set of components. This core set of
components, shared by all counter devices, is what forms the essence of
the Generic Counter interface.</p>
<p>There are three core components to a counter:</p>
<ul class="simple">
<li><p>Signal:
Stream of data to be evaluated by the counter.</p></li>
<li><p>Synapse:
Association of a Signal, and evaluation trigger, with a Count.</p></li>
<li><p>Count:
Accumulation of the effects of connected Synapses.</p></li>
</ul>
<section id="signal">
<h3>SIGNAL<a class="headerlink" href="#signal" title="Permalink to this headline">¶</a></h3>
<p>A Signal represents a stream of data. This is the input data that is
evaluated by the counter to determine the count data; e.g. a quadrature
signal output line of a rotary encoder. Not all counter devices provide
user access to the Signal data, so exposure is optional for drivers.</p>
<p>When the Signal data is available for user access, the Generic Counter
interface provides the following available signal values:</p>
<ul class="simple">
<li><p>SIGNAL_LOW:
Signal line is in a low state.</p></li>
<li><p>SIGNAL_HIGH:
Signal line is in a high state.</p></li>
</ul>
<p>A Signal may be associated with one or more Counts.</p>
</section>
<section id="synapse">
<h3>SYNAPSE<a class="headerlink" href="#synapse" title="Permalink to this headline">¶</a></h3>
<p>A Synapse represents the association of a Signal with a Count. Signal
data affects respective Count data, and the Synapse represents this
relationship.</p>
<p>The Synapse action mode specifies the Signal data condition that
triggers the respective Count’s count function evaluation to update the
count data. The Generic Counter interface provides the following
available action modes:</p>
<ul class="simple">
<li><p>None:
Signal does not trigger the count function. In Pulse-Direction count
function mode, this Signal is evaluated as Direction.</p></li>
<li><p>Rising Edge:
Low state transitions to high state.</p></li>
<li><p>Falling Edge:
High state transitions to low state.</p></li>
<li><p>Both Edges:
Any state transition.</p></li>
</ul>
<p>A counter is defined as a set of input signals associated with count
data that are generated by the evaluation of the state of the associated
input signals as defined by the respective count functions. Within the
context of the Generic Counter interface, a counter consists of Counts
each associated with a set of Signals, whose respective Synapse
instances represent the count function update conditions for the
associated Counts.</p>
<p>A Synapse associates one Signal with one Count.</p>
</section>
<section id="count">
<h3>COUNT<a class="headerlink" href="#count" title="Permalink to this headline">¶</a></h3>
<p>A Count represents the accumulation of the effects of connected
Synapses; i.e. the count data for a set of Signals. The Generic
Counter interface represents the count data as a natural number.</p>
<p>A Count has a count function mode which represents the update behavior
for the count data. The Generic Counter interface provides the following
available count function modes:</p>
<ul class="simple">
<li><p>Increase:
Accumulated count is incremented.</p></li>
<li><p>Decrease:
Accumulated count is decremented.</p></li>
<li><p>Pulse-Direction:
Rising edges on signal A updates the respective count. The input level
of signal B determines direction.</p></li>
<li><p>Quadrature:
A pair of quadrature encoding signals are evaluated to determine
position and direction. The following Quadrature modes are available:</p>
<ul>
<li><p>x1 A:
If direction is forward, rising edges on quadrature pair signal A
updates the respective count; if the direction is backward, falling
edges on quadrature pair signal A updates the respective count.
Quadrature encoding determines the direction.</p></li>
<li><p>x1 B:
If direction is forward, rising edges on quadrature pair signal B
updates the respective count; if the direction is backward, falling
edges on quadrature pair signal B updates the respective count.
Quadrature encoding determines the direction.</p></li>
<li><p>x2 A:
Any state transition on quadrature pair signal A updates the
respective count. Quadrature encoding determines the direction.</p></li>
<li><p>x2 B:
Any state transition on quadrature pair signal B updates the
respective count. Quadrature encoding determines the direction.</p></li>
<li><p>x4:
Any state transition on either quadrature pair signals updates the
respective count. Quadrature encoding determines the direction.</p></li>
</ul>
</li>
</ul>
<p>A Count has a set of one or more associated Synapses.</p>
</section>
</section>
<section id="paradigm">
<h2>Paradigm<a class="headerlink" href="#paradigm" title="Permalink to this headline">¶</a></h2>
<p>The most basic counter device may be expressed as a single Count
associated with a single Signal via a single Synapse. Take for example
a counter device which simply accumulates a count of rising edges on a
source input line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        Count                Synapse        Signal
        -----                -------        ------
+---------------------+
| Data: Count         |    Rising Edge     ________
| Function: Increase  |  &lt;-------------   / Source \
|                     |                  ____________
+---------------------+
</pre></div>
</div>
<p>In this example, the Signal is a source input line with a pulsing
voltage, while the Count is a persistent count value which is repeatedly
incremented. The Signal is associated with the respective Count via a
Synapse. The increase function is triggered by the Signal data condition
specified by the Synapse – in this case a rising edge condition on the
voltage input line. In summary, the counter device existence and
behavior is aptly represented by respective Count, Signal, and Synapse
components: a rising edge condition triggers an increase function on an
accumulating count datum.</p>
<p>A counter device is not limited to a single Signal; in fact, in theory
many Signals may be associated with even a single Count. For example, a
quadrature encoder counter device can keep track of position based on
the states of two input lines:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           Count                 Synapse     Signal
           -----                 -------     ------
+-------------------------+
| Data: Position          |    Both Edges     ___
| Function: Quadrature x4 |  &lt;------------   / A \
|                         |                 _______
|                         |
|                         |    Both Edges     ___
|                         |  &lt;------------   / B \
|                         |                 _______
+-------------------------+
</pre></div>
</div>
<p>In this example, two Signals (quadrature encoder lines A and B) are
associated with a single Count: a rising or falling edge on either A or
B triggers the “Quadrature x4” function which determines the direction
of movement and updates the respective position data. The “Quadrature
x4” function is likely implemented in the hardware of the quadrature
encoder counter device; the Count, Signals, and Synapses simply
represent this hardware behavior and functionality.</p>
<p>Signals associated with the same Count can have differing Synapse action
mode conditions. For example, a quadrature encoder counter device
operating in a non-quadrature Pulse-Direction mode could have one input
line dedicated for movement and a second input line dedicated for
direction:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           Count                   Synapse      Signal
           -----                   -------      ------
+---------------------------+
| Data: Position            |    Rising Edge     ___
| Function: Pulse-Direction |  &lt;-------------   / A \ (Movement)
|                           |                  _______
|                           |
|                           |       None         ___
|                           |  &lt;-------------   / B \ (Direction)
|                           |                  _______
+---------------------------+
</pre></div>
</div>
<p>Only Signal A triggers the “Pulse-Direction” update function, but the
instantaneous state of Signal B is still required in order to know the
direction so that the position data may be properly updated. Ultimately,
both Signals are associated with the same Count via two respective
Synapses, but only one Synapse has an active action mode condition which
triggers the respective count function while the other is left with a
“None” condition action mode to indicate its respective Signal’s
availability for state evaluation despite its non-triggering mode.</p>
<p>Keep in mind that the Signal, Synapse, and Count are abstract
representations which do not need to be closely married to their
respective physical sources. This allows the user of a counter to
divorce themselves from the nuances of physical components (such as
whether an input line is differential or single-ended) and instead focus
on the core idea of what the data and process represent (e.g. position
as interpreted from quadrature encoding data).</p>
</section>
<section id="driver-api">
<h2>Driver API<a class="headerlink" href="#driver-api" title="Permalink to this headline">¶</a></h2>
<p>Driver authors may utilize the Generic Counter interface in their code
by including the include/linux/counter.h header file. This header file
provides several core data structures, function prototypes, and macros
for defining a counter device.</p>
<dl class="type">
<dt id="c.counter_comp">
struct <code class="sig-name descname">counter_comp</code><a class="headerlink" href="#c.counter_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>Counter component node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_comp {
    enum counter_comp_type type;
    const char *name;
    void *priv;
    union {
        int (*action_read)(struct counter_device *counter,struct counter_count *count,struct counter_synapse *synapse, enum counter_synapse_action *action);
        int (*device_u8_read)(struct counter_device *counter, u8 *val);
        int (*count_u8_read)(struct counter_device *counter, struct counter_count *count, u8 *val);
        int (*signal_u8_read)(struct counter_device *counter, struct counter_signal *signal, u8 *val);
        int (*device_u32_read)(struct counter_device *counter, u32 *val);
        int (*count_u32_read)(struct counter_device *counter, struct counter_count *count, u32 *val);
        int (*signal_u32_read)(struct counter_device *counter, struct counter_signal *signal, u32 *val);
        int (*device_u64_read)(struct counter_device *counter, u64 *val);
        int (*count_u64_read)(struct counter_device *counter, struct counter_count *count, u64 *val);
        int (*signal_u64_read)(struct counter_device *counter, struct counter_signal *signal, u64 *val);
        int (*signal_array_u32_read)(struct counter_device *counter,struct counter_signal *signal, size_t idx, u32 *val);
        int (*device_array_u64_read)(struct counter_device *counter, size_t idx, u64 *val);
        int (*count_array_u64_read)(struct counter_device *counter,struct counter_count *count, size_t idx, u64 *val);
        int (*signal_array_u64_read)(struct counter_device *counter,struct counter_signal *signal, size_t idx, u64 *val);
    };
    union {
        int (*action_write)(struct counter_device *counter,struct counter_count *count,struct counter_synapse *synapse, enum counter_synapse_action action);
        int (*device_u8_write)(struct counter_device *counter, u8 val);
        int (*count_u8_write)(struct counter_device *counter, struct counter_count *count, u8 val);
        int (*signal_u8_write)(struct counter_device *counter, struct counter_signal *signal, u8 val);
        int (*device_u32_write)(struct counter_device *counter, u32 val);
        int (*count_u32_write)(struct counter_device *counter, struct counter_count *count, u32 val);
        int (*signal_u32_write)(struct counter_device *counter, struct counter_signal *signal, u32 val);
        int (*device_u64_write)(struct counter_device *counter, u64 val);
        int (*count_u64_write)(struct counter_device *counter, struct counter_count *count, u64 val);
        int (*signal_u64_write)(struct counter_device *counter, struct counter_signal *signal, u64 val);
        int (*signal_array_u32_write)(struct counter_device *counter,struct counter_signal *signal, size_t idx, u32 val);
        int (*device_array_u64_write)(struct counter_device *counter, size_t idx, u64 val);
        int (*count_array_u64_write)(struct counter_device *counter,struct counter_count *count, size_t idx, u64 val);
        int (*signal_array_u64_write)(struct counter_device *counter,struct counter_signal *signal, size_t idx, u64 val);
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Counter component data type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>device-specific component name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>component-relevant data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">action_read</span></code></dt><dd><p>Synapse action mode read callback. The read value of the
respective Synapse action mode should be passed back via
the action parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_u8_read</span></code></dt><dd><p>Device u8 component read callback. The read value of the
respective Device u8 component should be passed back via
the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_u8_read</span></code></dt><dd><p>Count u8 component read callback. The read value of the
respective Count u8 component should be passed back via
the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_u8_read</span></code></dt><dd><p>Signal u8 component read callback. The read value of the
respective Signal u8 component should be passed back via
the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_u32_read</span></code></dt><dd><p>Device u32 component read callback. The read value of
the respective Device u32 component should be passed
back via the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_u32_read</span></code></dt><dd><p>Count u32 component read callback. The read value of the
respective Count u32 component should be passed back via
the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_u32_read</span></code></dt><dd><p>Signal u32 component read callback. The read value of
the respective Signal u32 component should be passed
back via the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_u64_read</span></code></dt><dd><p>Device u64 component read callback. The read value of
the respective Device u64 component should be passed
back via the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_u64_read</span></code></dt><dd><p>Count u64 component read callback. The read value of the
respective Count u64 component should be passed back via
the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_u64_read</span></code></dt><dd><p>Signal u64 component read callback. The read value of
the respective Signal u64 component should be passed
back via the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_array_u32_read</span></code></dt><dd><p>Signal u32 array component read callback. The
index of the respective Count u32 array
component element is passed via the idx
parameter. The read value of the respective
Count u32 array component element should be
passed back via the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_array_u64_read</span></code></dt><dd><p>Device u64 array component read callback. The
index of the respective Device u64 array
component element is passed via the idx
parameter. The read value of the respective
Device u64 array component element should be
passed back via the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_array_u64_read</span></code></dt><dd><p>Count u64 array component read callback. The
index of the respective Count u64 array
component element is passed via the idx
parameter. The read value of the respective
Count u64 array component element should be
passed back via the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_array_u64_read</span></code></dt><dd><p>Signal u64 array component read callback. The
index of the respective Count u64 array
component element is passed via the idx
parameter. The read value of the respective
Count u64 array component element should be
passed back via the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">action_write</span></code></dt><dd><p>Synapse action mode write callback. The write value of
the respective Synapse action mode is passed via the
action parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_u8_write</span></code></dt><dd><p>Device u8 component write callback. The write value of
the respective Device u8 component is passed via the val
parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_u8_write</span></code></dt><dd><p>Count u8 component write callback. The write value of
the respective Count u8 component is passed via the val
parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_u8_write</span></code></dt><dd><p>Signal u8 component write callback. The write value of
the respective Signal u8 component is passed via the val
parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_u32_write</span></code></dt><dd><p>Device u32 component write callback. The write value of
the respective Device u32 component is passed via the
val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_u32_write</span></code></dt><dd><p>Count u32 component write callback. The write value of
the respective Count u32 component is passed via the val
parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_u32_write</span></code></dt><dd><p>Signal u32 component write callback. The write value of
the respective Signal u32 component is passed via the
val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_u64_write</span></code></dt><dd><p>Device u64 component write callback. The write value of
the respective Device u64 component is passed via the
val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_u64_write</span></code></dt><dd><p>Count u64 component write callback. The write value of
the respective Count u64 component is passed via the val
parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_u64_write</span></code></dt><dd><p>Signal u64 component write callback. The write value of
the respective Signal u64 component is passed via the
val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_array_u32_write</span></code></dt><dd><p>Signal u32 array component write callback. The
index of the respective Signal u32 array
component element is passed via the idx
parameter. The write value of the respective
Signal u32 array component element is passed via
the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_array_u64_write</span></code></dt><dd><p>Device u64 array component write callback. The
index of the respective Device u64 array
component element is passed via the idx
parameter. The write value of the respective
Device u64 array component element is passed via
the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_array_u64_write</span></code></dt><dd><p>Count u64 array component write callback. The
index of the respective Count u64 array
component element is passed via the idx
parameter. The write value of the respective
Count u64 array component element is passed via
the val parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal_array_u64_write</span></code></dt><dd><p>Signal u64 array component write callback. The
index of the respective Signal u64 array
component element is passed via the idx
parameter. The write value of the respective
Signal u64 array component element is passed via
the val parameter.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.counter_signal">
struct <code class="sig-name descname">counter_signal</code><a class="headerlink" href="#c.counter_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Counter Signal node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_signal {
    int id;
    const char *name;
    struct counter_comp *ext;
    size_t num_ext;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>unique ID used to identify the Signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>device-specific Signal name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext</span></code></dt><dd><p>optional array of Signal extensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ext</span></code></dt><dd><p>number of Signal extensions specified in <strong>ext</strong></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.counter_synapse">
struct <code class="sig-name descname">counter_synapse</code><a class="headerlink" href="#c.counter_synapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Counter Synapse node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_synapse {
    const enum counter_synapse_action *actions_list;
    size_t num_actions;
    struct counter_signal *signal;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">actions_list</span></code></dt><dd><p>array of available action modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_actions</span></code></dt><dd><p>number of action modes specified in <strong>actions_list</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal</span></code></dt><dd><p>pointer to the associated Signal</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.counter_count">
struct <code class="sig-name descname">counter_count</code><a class="headerlink" href="#c.counter_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Counter Count node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_count {
    int id;
    const char *name;
    const enum counter_function *functions_list;
    size_t num_functions;
    struct counter_synapse *synapses;
    size_t num_synapses;
    struct counter_comp *ext;
    size_t num_ext;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>unique ID used to identify the Count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>device-specific Count name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">functions_list</span></code></dt><dd><p>array of available function modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_functions</span></code></dt><dd><p>number of function modes specified in <strong>functions_list</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">synapses</span></code></dt><dd><p>array of Synapses for initialization</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_synapses</span></code></dt><dd><p>number of Synapses specified in <strong>synapses</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext</span></code></dt><dd><p>optional array of Count extensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ext</span></code></dt><dd><p>number of Count extensions specified in <strong>ext</strong></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.counter_event_node">
struct <code class="sig-name descname">counter_event_node</code><a class="headerlink" href="#c.counter_event_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Counter Event node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_event_node {
    struct list_head l;
    u8 event;
    u8 channel;
    struct list_head comp_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">l</span></code></dt><dd><p>list of current watching Counter events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event</span></code></dt><dd><p>event that triggers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>event channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">comp_list</span></code></dt><dd><p>list of components to watch when event triggers</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.counter_ops">
struct <code class="sig-name descname">counter_ops</code><a class="headerlink" href="#c.counter_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Callbacks from driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_ops {
    int (*signal_read)(struct counter_device *counter,struct counter_signal *signal, enum counter_signal_level *level);
    int (*count_read)(struct counter_device *counter, struct counter_count *count, u64 *value);
    int (*count_write)(struct counter_device *counter, struct counter_count *count, u64 value);
    int (*function_read)(struct counter_device *counter,struct counter_count *count, enum counter_function *function);
    int (*function_write)(struct counter_device *counter,struct counter_count *count, enum counter_function function);
    int (*action_read)(struct counter_device *counter,struct counter_count *count,struct counter_synapse *synapse, enum counter_synapse_action *action);
    int (*action_write)(struct counter_device *counter,struct counter_count *count,struct counter_synapse *synapse, enum counter_synapse_action action);
    int (*events_configure)(struct counter_device *counter);
    int (*watch_validate)(struct counter_device *counter, const struct counter_watch *watch);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">signal_read</span></code></dt><dd><p>optional read callback for Signals. The read level of
the respective Signal should be passed back via the
level parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_read</span></code></dt><dd><p>read callback for Counts. The read value of the
respective Count should be passed back via the value
parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_write</span></code></dt><dd><p>optional write callback for Counts. The write value for
the respective Count is passed in via the value
parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function_read</span></code></dt><dd><p>read callback the Count function modes. The read
function mode of the respective Count should be passed
back via the function parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function_write</span></code></dt><dd><p>optional write callback for Count function modes. The
function mode to write for the respective Count is
passed in via the function parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">action_read</span></code></dt><dd><p>optional read callback the Synapse action modes. The
read action mode of the respective Synapse should be
passed back via the action parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">action_write</span></code></dt><dd><p>optional write callback for Synapse action modes. The
action mode to write for the respective Synapse is
passed in via the action parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_configure</span></code></dt><dd><p>optional write callback to configure events. The list of
<a class="reference internal" href="#c.counter_event_node" title="counter_event_node"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_event_node</span></code></a> may be accessed via the
events_list member of the counter parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">watch_validate</span></code></dt><dd><p>optional callback to validate a watch. The Counter
component watch configuration is passed in via the watch
parameter. A return value of 0 indicates a valid Counter
component watch configuration.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.counter_device">
struct <code class="sig-name descname">counter_device</code><a class="headerlink" href="#c.counter_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Counter data structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_device {
    const char *name;
    struct device *parent;
    const struct counter_ops *ops;
    struct counter_signal *signals;
    size_t num_signals;
    struct counter_count *counts;
    size_t num_counts;
    struct counter_comp *ext;
    size_t num_ext;
    struct device dev;
    struct cdev chrdev;
    struct list_head events_list;
    spinlock_t events_list_lock;
    struct list_head next_events_list;
    struct mutex n_events_list_lock;
    struct counter_event *events;
    wait_queue_head_t events_wait;
    spinlock_t events_in_lock;
    struct mutex events_out_lock;
    struct mutex ops_exist_lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>optional parent device providing the counters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>callbacks from driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signals</span></code></dt><dd><p>array of Signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_signals</span></code></dt><dd><p>number of Signals specified in <strong>signals</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">counts</span></code></dt><dd><p>array of Counts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_counts</span></code></dt><dd><p>number of Counts specified in <strong>counts</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext</span></code></dt><dd><p>optional array of Counter device extensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ext</span></code></dt><dd><p>number of Counter device extensions specified in <strong>ext</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>internal device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chrdev</span></code></dt><dd><p>internal character device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_list</span></code></dt><dd><p>list of current watching Counter events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_list_lock</span></code></dt><dd><p>lock to protect Counter events list operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next_events_list</span></code></dt><dd><p>list of next watching Counter events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_events_list_lock</span></code></dt><dd><p>lock to protect Counter next events list operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events</span></code></dt><dd><p>queue of detected Counter events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_wait</span></code></dt><dd><p>wait queue to allow blocking reads of Counter events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_in_lock</span></code></dt><dd><p>lock to protect Counter events queue in operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_out_lock</span></code></dt><dd><p>lock to protect Counter events queue out operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops_exist_lock</span></code></dt><dd><p>lock to prevent use during removal</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.counter_priv">
void * <code class="sig-name descname">counter_priv</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.counter_device" title="counter_device">counter_device</a> *const<em> counter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.counter_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>access counter device private data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>counter device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the counter device private data</p>
</div>
<dl class="function">
<dt id="c.counter_alloc">
struct <a class="reference internal" href="#c.counter_device" title="counter_device">counter_device</a> * <code class="sig-name descname">counter_alloc</code><span class="sig-paren">(</span>size_t<em> sizeof_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.counter_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a counter_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sizeof_priv</span></code></dt><dd><p>size of the driver private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is part one of counter registration. The structure is allocated
dynamically to ensure the right lifetime for the embedded <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>.</p>
<p>If this succeeds, call counter_put() to get rid of the counter_device again.</p>
</div>
<dl class="function">
<dt id="c.counter_add">
int <code class="sig-name descname">counter_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.counter_device" title="counter_device">counter_device</a><em> *counter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.counter_add" title="Permalink to this definition">¶</a></dt>
<dd><p>complete registration of a counter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*counter</span></code></dt><dd><p>the counter to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is part two of counter registration.</p>
<p>If this succeeds, call <a class="reference internal" href="#c.counter_unregister" title="counter_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">counter_unregister()</span></code></a> to get rid of the counter_device again.</p>
</div>
<dl class="function">
<dt id="c.counter_unregister">
void <code class="sig-name descname">counter_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.counter_device" title="counter_device">counter_device</a> *const<em> counter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.counter_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister Counter from the system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>pointer to Counter to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The Counter is unregistered from the system.</p>
</div>
<dl class="function">
<dt id="c.devm_counter_alloc">
struct <a class="reference internal" href="#c.counter_device" title="counter_device">counter_device</a> * <code class="sig-name descname">devm_counter_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, size_t<em> sizeof_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_counter_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a counter_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device to register the release callback for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">sizeof_priv</span></code></dt><dd><p>size of the driver private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the device managed version of <a class="reference internal" href="#c.counter_add" title="counter_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">counter_add()</span></code></a>. It registers a cleanup
callback to care for calling counter_put().</p>
</div>
<dl class="function">
<dt id="c.devm_counter_add">
int <code class="sig-name descname">devm_counter_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.counter_device" title="counter_device">counter_device</a> *const<em> counter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_counter_add" title="Permalink to this definition">¶</a></dt>
<dd><p>complete registration of a counter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device to register the release callback for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>the counter to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the device managed version of <a class="reference internal" href="#c.counter_add" title="counter_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">counter_add()</span></code></a>. It registers a cleanup
callback to care for calling <a class="reference internal" href="#c.counter_unregister" title="counter_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">counter_unregister()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.counter_push_event">
void <code class="sig-name descname">counter_push_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.counter_device" title="counter_device">counter_device</a> *const<em> counter</em>, const u8<em> event</em>, const u8<em> channel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.counter_push_event" title="Permalink to this definition">¶</a></dt>
<dd><p>queue event for userspace reading</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>pointer to Counter structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">event</span></code></dt><dd><p>triggered event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">channel</span></code></dt><dd><p>event channel</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>If no one is watching for the respective event, it is silently
discarded.</p>
</div>
</section>
<section id="driver-implementation">
<h2>Driver Implementation<a class="headerlink" href="#driver-implementation" title="Permalink to this headline">¶</a></h2>
<p>To support a counter device, a driver must first allocate the available
Counter Signals via counter_signal structures. These Signals should
be stored as an array and set to the signals array member of an
allocated counter_device structure before the Counter is registered to
the system.</p>
<p>Counter Counts may be allocated via counter_count structures, and
respective Counter Signal associations (Synapses) made via
counter_synapse structures. Associated counter_synapse structures are
stored as an array and set to the synapses array member of the
respective counter_count structure. These counter_count structures are
set to the counts array member of an allocated counter_device structure
before the Counter is registered to the system.</p>
<p>Driver callbacks must be provided to the counter_device structure in
order to communicate with the device: to read and write various Signals
and Counts, and to set and get the “action mode” and “function mode” for
various Synapses and Counts respectively.</p>
<p>A counter_device structure is allocated using <a class="reference internal" href="#c.counter_alloc" title="counter_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">counter_alloc()</span></code></a> and then
registered to the system by passing it to the <a class="reference internal" href="#c.counter_add" title="counter_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">counter_add()</span></code></a> function, and
unregistered by passing it to the counter_unregister function. There are
device managed variants of these functions: <a class="reference internal" href="#c.devm_counter_alloc" title="devm_counter_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_counter_alloc()</span></code></a> and
<a class="reference internal" href="#c.devm_counter_add" title="devm_counter_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_counter_add()</span></code></a>.</p>
<p>The <a class="reference internal" href="#c.counter_comp" title="counter_comp"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_comp</span></code></a> structure is used to define counter extensions
for Signals, Synapses, and Counts.</p>
<p>The “type” member specifies the type of high-level data (e.g. BOOL,
COUNT_DIRECTION, etc.) handled by this extension. The “<code class="docutils literal notranslate"><span class="pre">*_read</span></code>” and
“<code class="docutils literal notranslate"><span class="pre">*_write</span></code>” members can then be set by the counter device driver with
callbacks to handle that data using native C data types (i.e. u8, u64,
etc.).</p>
<p>Convenience macros such as <code class="docutils literal notranslate"><span class="pre">COUNTER_COMP_COUNT_U64</span></code> are provided for
use by driver authors. In particular, driver authors are expected to use
the provided macros for standard Counter subsystem attributes in order
to maintain a consistent interface for userspace. For example, a counter
device driver may define several standard attributes like so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_comp count_ext[] = {
        COUNTER_COMP_DIRECTION(count_direction_read),
        COUNTER_COMP_ENABLE(count_enable_read, count_enable_write),
        COUNTER_COMP_CEILING(count_ceiling_read, count_ceiling_write),
};
</pre></div>
</div>
<p>This makes it simple to see, add, and modify the attributes that are
supported by this driver (“direction”, “enable”, and “ceiling”) and to
maintain this code without getting lost in a web of struct braces.</p>
<p>Callbacks must match the function type expected for the respective
component or extension. These function types are defined in the <a class="reference internal" href="#c.counter_comp" title="counter_comp"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">counter_comp</span></code></a> structure as the “<code class="docutils literal notranslate"><span class="pre">*_read</span></code>” and “<code class="docutils literal notranslate"><span class="pre">*_write</span></code>” union
members.</p>
<p>The corresponding callback prototypes for the extensions mentioned in
the previous example above would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int count_direction_read(struct counter_device *counter,
                         struct counter_count *count,
                         enum counter_count_direction *direction);
int count_enable_read(struct counter_device *counter,
                      struct counter_count *count, u8 *enable);
int count_enable_write(struct counter_device *counter,
                       struct counter_count *count, u8 enable);
int count_ceiling_read(struct counter_device *counter,
                       struct counter_count *count, u64 *ceiling);
int count_ceiling_write(struct counter_device *counter,
                        struct counter_count *count, u64 ceiling);
</pre></div>
</div>
<p>Determining the type of extension to create is a matter of scope.</p>
<ul>
<li><p>Signal extensions are attributes that expose information/control
specific to a Signal. These types of attributes will exist under a
Signal’s directory in sysfs.</p>
<p>For example, if you have an invert feature for a Signal, you can have
a Signal extension called “invert” that toggles that feature:
/sys/bus/counter/devices/counterX/signalY/invert</p>
</li>
<li><p>Count extensions are attributes that expose information/control
specific to a Count. These type of attributes will exist under a
Count’s directory in sysfs.</p>
<p>For example, if you want to pause/unpause a Count from updating, you
can have a Count extension called “enable” that toggles such:
/sys/bus/counter/devices/counterX/countY/enable</p>
</li>
<li><p>Device extensions are attributes that expose information/control
non-specific to a particular Count or Signal. This is where you would
put your global features or other miscellaneous functionality.</p>
<p>For example, if your device has an overtemp sensor, you can report the
chip overheated via a device extension called “error_overtemp”:
/sys/bus/counter/devices/counterX/error_overtemp</p>
</li>
</ul>
</section>
<section id="subsystem-architecture">
<h2>Subsystem Architecture<a class="headerlink" href="#subsystem-architecture" title="Permalink to this headline">¶</a></h2>
<p>Counter drivers pass and take data natively (i.e. <code class="docutils literal notranslate"><span class="pre">u8</span></code>, <code class="docutils literal notranslate"><span class="pre">u64</span></code>, etc.)
and the shared counter module handles the translation between the sysfs
interface. This guarantees a standard userspace interface for all
counter drivers, and enables a Generic Counter chrdev interface via a
generalized device driver ABI.</p>
<p>A high-level view of how a count value is passed down from a counter
driver is exemplified by the following. The driver callbacks are first
registered to the Counter core component for use by the Counter
userspace interface components:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Driver callbacks registration:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                +----------------------------+
                | Counter device driver      |
                +----------------------------+
                | Processes data from device |
                +----------------------------+
                        |
                 -------------------
                / driver callbacks /
                -------------------
                        |
                        V
                +----------------------+
                | Counter core         |
                +----------------------+
                | Routes device driver |
                | callbacks to the     |
                | userspace interfaces |
                +----------------------+
                        |
                 -------------------
                / driver callbacks /
                -------------------
                        |
        +---------------+---------------+
        |                               |
        V                               V
+--------------------+          +---------------------+
| Counter sysfs      |          | Counter chrdev      |
+--------------------+          +---------------------+
| Translates to the  |          | Translates to the   |
| standard Counter   |          | standard Counter    |
| sysfs output       |          | character device    |
+--------------------+          +---------------------+
</pre></div>
</div>
<p>Thereafter, data can be transferred directly between the Counter device
driver and Counter userspace interface:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Count data request:
~~~~~~~~~~~~~~~~~~~
                 ----------------------
                / Counter device       \
                +----------------------+
                | Count register: 0x28 |
                +----------------------+
                        |
                 -----------------
                / raw count data /
                -----------------
                        |
                        V
                +----------------------------+
                | Counter device driver      |
                +----------------------------+
                | Processes data from device |
                |----------------------------|
                | Type: u64                  |
                | Value: 42                  |
                +----------------------------+
                        |
                 ----------
                / u64     /
                ----------
                        |
        +---------------+---------------+
        |                               |
        V                               V
+--------------------+          +---------------------+
| Counter sysfs      |          | Counter chrdev      |
+--------------------+          +---------------------+
| Translates to the  |          | Translates to the   |
| standard Counter   |          | standard Counter    |
| sysfs output       |          | character device    |
|--------------------|          |---------------------|
| Type: const char * |          | Type: u64           |
| Value: &quot;42&quot;        |          | Value: 42           |
+--------------------+          +---------------------+
        |                               |
 ---------------                 -----------------------
/ const char * /                / struct counter_event /
---------------                 -----------------------
        |                               |
        |                               V
        |                       +-----------+
        |                       | read      |
        |                       +-----------+
        |                       \ Count: 42 /
        |                        -----------
        |
        V
+--------------------------------------------------+
| `/sys/bus/counter/devices/counterX/countY/count` |
+--------------------------------------------------+
\ Count: &quot;42&quot;                                      /
 --------------------------------------------------
</pre></div>
</div>
<p>There are four primary components involved:</p>
<section id="counter-device-driver">
<h3>Counter device driver<a class="headerlink" href="#counter-device-driver" title="Permalink to this headline">¶</a></h3>
<p>Communicates with the hardware device to read/write data; e.g. counter
drivers for quadrature encoders, timers, etc.</p>
</section>
<section id="counter-core">
<h3>Counter core<a class="headerlink" href="#counter-core" title="Permalink to this headline">¶</a></h3>
<p>Registers the counter device driver to the system so that the respective
callbacks are called during userspace interaction.</p>
</section>
<section id="counter-sysfs">
<h3>Counter sysfs<a class="headerlink" href="#counter-sysfs" title="Permalink to this headline">¶</a></h3>
<p>Translates counter data to the standard Counter sysfs interface format
and vice versa.</p>
<p>Please refer to the <code class="docutils literal notranslate"><span class="pre">Documentation/ABI/testing/sysfs-bus-counter</span></code> file
for a detailed breakdown of the available Generic Counter interface
sysfs attributes.</p>
</section>
<section id="counter-chrdev">
<h3>Counter chrdev<a class="headerlink" href="#counter-chrdev" title="Permalink to this headline">¶</a></h3>
<p>Translates Counter events to the standard Counter character device; data
is transferred via standard character device read calls, while Counter
events are configured via ioctl calls.</p>
</section>
</section>
<section id="sysfs-interface">
<h2>Sysfs Interface<a class="headerlink" href="#sysfs-interface" title="Permalink to this headline">¶</a></h2>
<p>Several sysfs attributes are generated by the Generic Counter interface,
and reside under the <code class="docutils literal notranslate"><span class="pre">/sys/bus/counter/devices/counterX</span></code> directory,
where <code class="docutils literal notranslate"><span class="pre">X</span></code> is to the respective counter device id. Please see
<code class="docutils literal notranslate"><span class="pre">Documentation/ABI/testing/sysfs-bus-counter</span></code> for detailed information
on each Generic Counter interface sysfs attribute.</p>
<p>Through these sysfs attributes, programs and scripts may interact with
the Generic Counter paradigm Counts, Signals, and Synapses of respective
counter devices.</p>
</section>
<section id="counter-character-device">
<h2>Counter Character Device<a class="headerlink" href="#counter-character-device" title="Permalink to this headline">¶</a></h2>
<p>Counter character device nodes are created under the <code class="docutils literal notranslate"><span class="pre">/dev</span></code> directory
as <code class="docutils literal notranslate"><span class="pre">counterX</span></code>, where <code class="docutils literal notranslate"><span class="pre">X</span></code> is the respective counter device id.
Defines for the standard Counter data types are exposed via the
userspace <code class="docutils literal notranslate"><span class="pre">include/uapi/linux/counter.h</span></code> file.</p>
<section id="counter-events">
<h3>Counter events<a class="headerlink" href="#counter-events" title="Permalink to this headline">¶</a></h3>
<p>Counter device drivers can support Counter events by utilizing the
<code class="docutils literal notranslate"><span class="pre">counter_push_event</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void counter_push_event(struct counter_device *const counter, const u8 event,
                        const u8 channel);
</pre></div>
</div>
<p>The event id is specified by the <code class="docutils literal notranslate"><span class="pre">event</span></code> parameter; the event channel
id is specified by the <code class="docutils literal notranslate"><span class="pre">channel</span></code> parameter. When this function is
called, the Counter data associated with the respective event is
gathered, and a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_event</span></code> is generated for each datum and
pushed to userspace.</p>
<p>Counter events can be configured by users to report various Counter
data of interest. This can be conceptualized as a list of Counter
component read calls to perform. For example:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>COUNTER_EVENT_OVERFLOW</p></th>
<th class="head"><p>COUNTER_EVENT_INDEX</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Channel 0</p></td>
<td><p>Channel 0</p></td>
</tr>
<tr class="row-odd"><td rowspan="3"><ul class="simple">
<li><p>Count 0</p></li>
<li><p>Count 1</p></li>
<li><p>Signal 3</p></li>
<li><p>Count 4 Extension 2</p></li>
<li><p>Signal 5 Extension 0</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Signal 0</p></li>
<li><p>Signal 0 Extension 0</p></li>
<li><p>Extension 4</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>Channel 1</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li><p>Signal 4</p></li>
<li><p>Signal 4 Extension 0</p></li>
<li><p>Count 7</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>When <code class="docutils literal notranslate"><span class="pre">counter_push_event(counter,</span> <span class="pre">COUNTER_EVENT_INDEX,</span> <span class="pre">1)</span></code> is called
for example, it will go down the list for the <code class="docutils literal notranslate"><span class="pre">COUNTER_EVENT_INDEX</span></code>
event channel 1 and execute the read callbacks for Signal 4, Signal 4
Extension 0, and Count 7 – the data returned for each is pushed to a
kfifo as a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_event</span></code>, which userspace can retrieve via a
standard read operation on the respective character device node.</p>
</section>
<section id="userspace">
<h3>Userspace<a class="headerlink" href="#userspace" title="Permalink to this headline">¶</a></h3>
<p>Userspace applications can configure Counter events via ioctl operations
on the Counter character device node. There following ioctl codes are
supported and provided by the <code class="docutils literal notranslate"><span class="pre">linux/counter.h</span></code> userspace header file:</p>
<ul class="simple">
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">COUNTER_ADD_WATCH_IOCTL</span></code></p></li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">COUNTER_ENABLE_EVENTS_IOCTL</span></code></p></li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">COUNTER_DISABLE_EVENTS_IOCTL</span></code></p></li>
</ul>
<p>To configure events to gather Counter data, users first populate a
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_watch</span></code> with the relevant event id, event channel id,
and the information for the desired Counter component from which to
read, and then pass it via the <code class="docutils literal notranslate"><span class="pre">COUNTER_ADD_WATCH_IOCTL</span></code> ioctl
command.</p>
<p>Note that an event can be watched without gathering Counter data by
setting the <code class="docutils literal notranslate"><span class="pre">component.type</span></code> member equal to
<code class="docutils literal notranslate"><span class="pre">COUNTER_COMPONENT_NONE</span></code>. With this configuration the Counter
character device will simply populate the event timestamps for those
respective <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_event</span></code> elements and ignore the component
value.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">COUNTER_ADD_WATCH_IOCTL</span></code> command will buffer these Counter
watches. When ready, the <code class="docutils literal notranslate"><span class="pre">COUNTER_ENABLE_EVENTS_IOCTL</span></code> ioctl command
may be used to activate these Counter watches.</p>
<p>Userspace applications can then execute a <code class="docutils literal notranslate"><span class="pre">read</span></code> operation (optionally
calling <code class="docutils literal notranslate"><span class="pre">poll</span></code> first) on the Counter character device node to retrieve
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_event</span></code> elements with the desired data.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Generic Counter Interface</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#theory">Theory</a><ul>
<li><a class="reference internal" href="#signal">SIGNAL</a></li>
<li><a class="reference internal" href="#synapse">SYNAPSE</a></li>
<li><a class="reference internal" href="#count">COUNT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#paradigm">Paradigm</a></li>
<li><a class="reference internal" href="#driver-api">Driver API</a></li>
<li><a class="reference internal" href="#driver-implementation">Driver Implementation</a></li>
<li><a class="reference internal" href="#subsystem-architecture">Subsystem Architecture</a><ul>
<li><a class="reference internal" href="#counter-device-driver">Counter device driver</a></li>
<li><a class="reference internal" href="#counter-core">Counter core</a></li>
<li><a class="reference internal" href="#counter-sysfs">Counter sysfs</a></li>
<li><a class="reference internal" href="#counter-chrdev">Counter chrdev</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sysfs-interface">Sysfs Interface</a></li>
<li><a class="reference internal" href="#counter-character-device">Counter Character Device</a><ul>
<li><a class="reference internal" href="#counter-events">Counter events</a></li>
<li><a class="reference internal" href="#userspace">Userspace</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/generic-counter.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/driver-api/generic-counter.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>