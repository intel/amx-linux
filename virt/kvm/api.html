
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>The Definitive KVM (Kernel-based Virtual Machine) API Documentation &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Devices" href="devices/index.html" />
    <link rel="prev" title="KVM" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="the-definitive-kvm-kernel-based-virtual-machine-api-documentation">
<h1>The Definitive KVM (Kernel-based Virtual Machine) API Documentation<a class="headerlink" href="#the-definitive-kvm-kernel-based-virtual-machine-api-documentation" title="Permalink to this headline">¶</a></h1>
<section id="general-description">
<h2>1. General description<a class="headerlink" href="#general-description" title="Permalink to this headline">¶</a></h2>
<p>The kvm API is a set of ioctls that are issued to control various aspects
of a virtual machine.  The ioctls belong to the following classes:</p>
<blockquote>
<div><ul>
<li><p>System ioctls: These query and set global attributes which affect the
whole kvm subsystem.  In addition a system ioctl is used to create
virtual machines.</p></li>
<li><p>VM ioctls: These query and set attributes that affect an entire virtual
machine, for example memory layout.  In addition a VM ioctl is used to
create virtual cpus (vcpus) and devices.</p>
<p>VM ioctls must be issued from the same process (address space) that was
used to create the VM.</p>
</li>
<li><p>vcpu ioctls: These query and set attributes that control the operation
of a single virtual cpu.</p>
<p>vcpu ioctls should be issued from the same thread that was used to create
the vcpu, except for asynchronous vcpu ioctl that are marked as such in
the documentation.  Otherwise, the first ioctl after switching threads
could see a performance impact.</p>
</li>
<li><p>device ioctls: These query and set attributes that control the operation
of a single device.</p>
<p>device ioctls must be issued from the same process (address space) that
was used to create the VM.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="file-descriptors">
<h2>2. File descriptors<a class="headerlink" href="#file-descriptors" title="Permalink to this headline">¶</a></h2>
<p>The kvm API is centered around file descriptors.  An initial
open(“/dev/kvm”) obtains a handle to the kvm subsystem; this handle
can be used to issue system ioctls.  A KVM_CREATE_VM ioctl on this
handle will create a VM file descriptor which can be used to issue VM
ioctls.  A KVM_CREATE_VCPU or KVM_CREATE_DEVICE ioctl on a VM fd will
create a virtual cpu or device and return a file descriptor pointing to
the new resource.  Finally, ioctls on a vcpu or device fd can be used
to control the vcpu or device.  For vcpus, this includes the important
task of actually running guest code.</p>
<p>In general file descriptors can be migrated among processes by means
of fork() and the SCM_RIGHTS facility of unix domain socket.  These
kinds of tricks are explicitly not supported by kvm.  While they will
not cause harm to the host, their actual behavior is not guaranteed by
the API.  See “General description” for details on the ioctl usage
model that is supported by KVM.</p>
<p>It is important to note that although VM ioctls may only be issued from
the process that created the VM, a VM’s lifecycle is associated with its
file descriptor, not its creator (process).  In other words, the VM and
its resources, <em>including the associated address space</em>, are not freed
until the last reference to the VM’s file descriptor has been released.
For example, if fork() is issued after ioctl(KVM_CREATE_VM), the VM will
not be freed until both the parent (original) process and its child have
put their references to the VM’s file descriptor.</p>
<p>Because a VM’s resources are not freed until the last reference to its
file descriptor is released, creating additional references to a VM
via fork(), dup(), etc… without careful consideration is strongly
discouraged and may have unwanted side effects, e.g. memory allocated
by and on behalf of the VM’s process may not be freed/unaccounted when
the VM is shut down.</p>
</section>
<section id="extensions">
<h2>3. Extensions<a class="headerlink" href="#extensions" title="Permalink to this headline">¶</a></h2>
<p>As of Linux 2.6.22, the KVM ABI has been stabilized: no backward
incompatible change are allowed.  However, there is an extension
facility that allows backward-compatible extensions to the API to be
queried and used.</p>
<p>The extension mechanism is not based on the Linux version number.
Instead, kvm defines extension identifiers and a facility to query
whether a particular extension identifier is available.  If it is, a
set of ioctls is available for application use.</p>
</section>
<section id="api-description">
<h2>4. API description<a class="headerlink" href="#api-description" title="Permalink to this headline">¶</a></h2>
<p>This section describes ioctls that can be used to control kvm guests.
For each ioctl, the following information is provided along with a
description:</p>
<blockquote>
<div><dl class="simple">
<dt>Capability:</dt><dd><p>which KVM extension provides this ioctl.  Can be ‘basic’,
which means that is will be provided by any kernel that supports
API version 12 (see section 4.1), a KVM_CAP_xyz constant, which
means availability needs to be checked with KVM_CHECK_EXTENSION
(see section 4.4), or ‘none’ which means that while not all kernels
support this ioctl, there’s no capability bit to check its
availability: for kernels that don’t support the ioctl,
the ioctl returns -ENOTTY.</p>
</dd>
<dt>Architectures:</dt><dd><p>which instruction set architectures provide this ioctl.
x86 includes both i386 and x86_64.</p>
</dd>
<dt>Type:</dt><dd><p>system, vm, or vcpu.</p>
</dd>
<dt>Parameters:</dt><dd><p>what parameters are accepted by the ioctl.</p>
</dd>
<dt>Returns:</dt><dd><p>the return value.  General error numbers (EBADF, ENOMEM, EINVAL)
are not detailed, but errors with specific meanings are.</p>
</dd>
</dl>
</div></blockquote>
<section id="kvm-get-api-version">
<h3>4.1 KVM_GET_API_VERSION<a class="headerlink" href="#kvm-get-api-version" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the constant KVM_API_VERSION (=12)</p>
</dd>
</dl>
<p>This identifies the API version as the stable kvm API. It is not
expected that this number will change.  However, Linux 2.6.20 and
2.6.21 report earlier versions; these are not documented and not
supported.  Applications should refuse to run if KVM_GET_API_VERSION
returns a value other than 12.  If this check passes, all ioctls
described as ‘basic’ will be available.</p>
</section>
<section id="kvm-create-vm">
<h3>4.2 KVM_CREATE_VM<a class="headerlink" href="#kvm-create-vm" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>machine type identifier (KVM_VM_*)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a VM fd that can be used to control the new virtual machine.</p>
</dd>
</dl>
<p>The new VM has no virtual cpus and no memory.
You probably want to use 0 as machine type.</p>
<p>In order to create user controlled virtual machines on S390, check
KVM_CAP_S390_UCONTROL and use the flag KVM_VM_S390_UCONTROL as
privileged user (CAP_SYS_ADMIN).</p>
<p>On arm64, the physical address size for a VM (IPA Size limit) is limited
to 40bits by default. The limit can be configured if the host supports the
extension KVM_CAP_ARM_VM_IPA_SIZE. When supported, use
KVM_VM_TYPE_ARM_IPA_SIZE(IPA_Bits) to set the size in the machine type
identifier, where IPA_Bits is the maximum width of any physical
address used by the VM. The IPA_Bits is encoded in bits[7-0] of the
machine type identifier.</p>
<p>e.g, to configure a guest to use 48bit physical address size:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vm_fd = ioctl(dev_fd, KVM_CREATE_VM, KVM_VM_TYPE_ARM_IPA_SIZE(48));
</pre></div>
</div>
<p>The requested size (IPA_Bits) must be:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 3%" />
<col style="width: 97%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>Implies default size, 40bits (for backward compatibility)</p></td>
</tr>
<tr class="row-even"><td><p>N</p></td>
<td><p>Implies N bits, where N is a positive integer such that,
32 &lt;= N &lt;= Host_IPA_Limit</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Host_IPA_Limit is the maximum possible value for IPA_Bits on the host and
is dependent on the CPU capability and the kernel configuration. The limit can
be retrieved using KVM_CAP_ARM_VM_IPA_SIZE of the KVM_CHECK_EXTENSION
ioctl() at run-time.</p>
<p>Creation of the VM will fail if the requested IPA size (whether it is
implicit or explicit) is unsupported on the host.</p>
<p>Please note that configuring the IPA size does not affect the capability
exposed by the guest CPUs in ID_AA64MMFR0_EL1[PARange]. It only affects
size of the address translated by the stage2 level (guest physical to
host physical address translations).</p>
</section>
<section id="kvm-get-msr-index-list-kvm-get-msr-feature-index-list">
<h3>4.3 KVM_GET_MSR_INDEX_LIST, KVM_GET_MSR_FEATURE_INDEX_LIST<a class="headerlink" href="#kvm-get-msr-index-list-kvm-get-msr-feature-index-list" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic, KVM_CAP_GET_MSR_FEATURES for KVM_GET_MSR_FEATURE_INDEX_LIST</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_msr_list (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 91%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>EFAULT</p></td>
<td><p>the msr index list cannot be read from or written to</p></td>
</tr>
<tr class="row-even"><td><p>E2BIG</p></td>
<td><p>the msr index list is too big to fit in the array specified by
the user.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_msr_list {
      __u32 nmsrs; /* number of msrs in entries */
      __u32 indices[0];
};
</pre></div>
</div>
<p>The user fills in the size of the indices array in nmsrs, and in return
kvm adjusts nmsrs to reflect the actual number of msrs and fills in the
indices array with their numbers.</p>
<p>KVM_GET_MSR_INDEX_LIST returns the guest msrs that are supported.  The list
varies by kvm version and host processor, but does not change otherwise.</p>
<p>Note: if kvm indicates supports MCE (KVM_CAP_MCE), then the MCE bank MSRs are
not returned in the MSR list, as different vcpus can have a different number
of banks, as set via the KVM_X86_SETUP_MCE ioctl.</p>
<p>KVM_GET_MSR_FEATURE_INDEX_LIST returns the list of MSRs that can be passed
to the KVM_GET_MSRS system ioctl.  This lets userspace probe host capabilities
and processor features that are exposed via MSRs (e.g., VMX capabilities).
This list also varies by kvm version and host processor, but does not change
otherwise.</p>
</section>
<section id="kvm-check-extension">
<h3>4.4 KVM_CHECK_EXTENSION<a class="headerlink" href="#kvm-check-extension" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic, KVM_CAP_CHECK_EXTENSION_VM for vm ioctl</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl, vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>extension identifier (KVM_CAP_*)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 if unsupported; 1 (or some other positive integer) if supported</p>
</dd>
</dl>
<p>The API allows the application to query about extensions to the core
kvm API.  Userspace passes an extension identifier (an integer) and
receives an integer that describes the extension availability.
Generally 0 means no and 1 means yes, but some extensions may report
additional information in the integer return value.</p>
<p>Based on their initialization different VMs may have different capabilities.
It is thus encouraged to use the vm ioctl to query for capabilities (available
with KVM_CAP_CHECK_EXTENSION_VM on the vm fd)</p>
</section>
<section id="kvm-get-vcpu-mmap-size">
<h3>4.5 KVM_GET_VCPU_MMAP_SIZE<a class="headerlink" href="#kvm-get-vcpu-mmap-size" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>size of vcpu mmap area, in bytes</p>
</dd>
</dl>
<p>The KVM_RUN ioctl (cf.) communicates with userspace via a shared
memory region.  This ioctl returns the size of that region.  See the
KVM_RUN documentation for details.</p>
<p>Besides the size of the KVM_RUN communication region, other areas of
the VCPU file descriptor can be mmap-ed, including:</p>
<ul class="simple">
<li><p>if KVM_CAP_COALESCED_MMIO is available, a page at
KVM_COALESCED_MMIO_PAGE_OFFSET * PAGE_SIZE; for historical reasons,
this page is included in the result of KVM_GET_VCPU_MMAP_SIZE.
KVM_CAP_COALESCED_MMIO is not documented yet.</p></li>
<li><p>if KVM_CAP_DIRTY_LOG_RING is available, a number of pages at
KVM_DIRTY_LOG_PAGE_OFFSET * PAGE_SIZE.  For more information on
KVM_CAP_DIRTY_LOG_RING, see section 8.3.</p></li>
</ul>
</section>
<section id="kvm-create-vcpu">
<h3>4.7 KVM_CREATE_VCPU<a class="headerlink" href="#kvm-create-vcpu" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>vcpu id (apic id on x86)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>vcpu fd on success, -1 on error</p>
</dd>
</dl>
<p>This API adds a vcpu to a virtual machine. No more than max_vcpus may be added.
The vcpu id is an integer in the range [0, max_vcpu_id).</p>
<p>The recommended max_vcpus value can be retrieved using the KVM_CAP_NR_VCPUS of
the KVM_CHECK_EXTENSION ioctl() at run-time.
The maximum possible value for max_vcpus can be retrieved using the
KVM_CAP_MAX_VCPUS of the KVM_CHECK_EXTENSION ioctl() at run-time.</p>
<p>If the KVM_CAP_NR_VCPUS does not exist, you should assume that max_vcpus is 4
cpus max.
If the KVM_CAP_MAX_VCPUS does not exist, you should assume that max_vcpus is
same as the value returned from KVM_CAP_NR_VCPUS.</p>
<p>The maximum possible value for max_vcpu_id can be retrieved using the
KVM_CAP_MAX_VCPU_ID of the KVM_CHECK_EXTENSION ioctl() at run-time.</p>
<p>If the KVM_CAP_MAX_VCPU_ID does not exist, you should assume that max_vcpu_id
is the same as the value returned from KVM_CAP_MAX_VCPUS.</p>
<p>On powerpc using book3s_hv mode, the vcpus are mapped onto virtual
threads in one or more virtual CPU cores.  (This is because the
hardware requires all the hardware threads in a CPU core to be in the
same partition.)  The KVM_CAP_PPC_SMT capability indicates the number
of vcpus per virtual core (vcore).  The vcore id is obtained by
dividing the vcpu id by the number of vcpus per vcore.  The vcpus in a
given vcore will always be in the same physical core as each other
(though that might be a different physical core from time to time).
Userspace can control the threading (SMT) mode of the guest by its
allocation of vcpu ids.  For example, if userspace wants
single-threaded guest vcpus, it should make all vcpu ids be a multiple
of the number of vcpus per vcore.</p>
<p>For virtual cpus that have been created with S390 user controlled virtual
machines, the resulting vcpu fd can be memory mapped at page offset
KVM_S390_SIE_PAGE_OFFSET in order to obtain a memory map of the virtual
cpu’s hardware control block.</p>
</section>
<section id="kvm-get-dirty-log-vm-ioctl">
<h3>4.8 KVM_GET_DIRTY_LOG (vm ioctl)<a class="headerlink" href="#kvm-get-dirty-log-vm-ioctl" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_dirty_log (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* for KVM_GET_DIRTY_LOG */
struct kvm_dirty_log {
      __u32 slot;
      __u32 padding;
      union {
              void __user *dirty_bitmap; /* one bit per page */
              __u64 padding;
      };
};
</pre></div>
</div>
<p>Given a memory slot, return a bitmap containing any pages dirtied
since the last call to this ioctl.  Bit 0 is the first page in the
memory slot.  Ensure the entire structure is cleared to avoid padding
issues.</p>
<p>If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 of slot field specifies
the address space for which you want to return the dirty bitmap.  See
KVM_SET_USER_MEMORY_REGION for details on the usage of slot field.</p>
<p>The bits in the dirty bitmap are cleared before the ioctl returns, unless
KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 is enabled.  For more information,
see the description of the capability.</p>
<p>Note that the Xen shared info page, if configured, shall always be assumed
to be dirty. KVM will not explicitly mark it such.</p>
</section>
<section id="kvm-run">
<h3>4.10 KVM_RUN<a class="headerlink" href="#kvm-run" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>EINTR</p></td>
<td><p>an unmasked signal is pending</p></td>
</tr>
<tr class="row-even"><td><p>ENOEXEC</p></td>
<td><p>the vcpu hasn’t been initialized or the guest tried to execute
instructions from device memory (arm64)</p></td>
</tr>
<tr class="row-odd"><td><p>ENOSYS</p></td>
<td><p>data abort outside memslots with no syndrome info and
KVM_CAP_ARM_NISV_TO_USER not enabled (arm64)</p></td>
</tr>
<tr class="row-even"><td><p>EPERM</p></td>
<td><p>SVE feature set but not finalized (arm64)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>This ioctl is used to run a guest virtual cpu.  While there are no
explicit parameters, there is an implicit parameter block that can be
obtained by mmap()ing the vcpu fd at offset 0, with the size given by
KVM_GET_VCPU_MMAP_SIZE.  The parameter block is formatted as a ‘struct
kvm_run’ (see below).</p>
</section>
<section id="kvm-get-regs">
<h3>4.11 KVM_GET_REGS<a class="headerlink" href="#kvm-get-regs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all except arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_regs (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Reads the general purpose registers from the vcpu.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* x86 */
struct kvm_regs {
      /* out (KVM_GET_REGS) / in (KVM_SET_REGS) */
      __u64 rax, rbx, rcx, rdx;
      __u64 rsi, rdi, rsp, rbp;
      __u64 r8,  r9,  r10, r11;
      __u64 r12, r13, r14, r15;
      __u64 rip, rflags;
};

/* mips */
struct kvm_regs {
      /* out (KVM_GET_REGS) / in (KVM_SET_REGS) */
      __u64 gpr[32];
      __u64 hi;
      __u64 lo;
      __u64 pc;
};
</pre></div>
</div>
</section>
<section id="kvm-set-regs">
<h3>4.12 KVM_SET_REGS<a class="headerlink" href="#kvm-set-regs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all except arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_regs (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Writes the general purpose registers into the vcpu.</p>
<p>See KVM_GET_REGS for the data structure.</p>
</section>
<section id="kvm-get-sregs">
<h3>4.13 KVM_GET_SREGS<a class="headerlink" href="#kvm-get-sregs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_sregs (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Reads special registers from the vcpu.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* x86 */
struct kvm_sregs {
      struct kvm_segment cs, ds, es, fs, gs, ss;
      struct kvm_segment tr, ldt;
      struct kvm_dtable gdt, idt;
      __u64 cr0, cr2, cr3, cr4, cr8;
      __u64 efer;
      __u64 apic_base;
      __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];
};

/* ppc -- see arch/powerpc/include/uapi/asm/kvm.h */
</pre></div>
</div>
<p>interrupt_bitmap is a bitmap of pending external interrupts.  At most
one bit may be set.  This interrupt has been acknowledged by the APIC
but not yet injected into the cpu core.</p>
</section>
<section id="kvm-set-sregs">
<h3>4.14 KVM_SET_SREGS<a class="headerlink" href="#kvm-set-sregs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_sregs (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Writes special registers into the vcpu.  See KVM_GET_SREGS for the
data structures.</p>
</section>
<section id="kvm-translate">
<h3>4.15 KVM_TRANSLATE<a class="headerlink" href="#kvm-translate" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_translation (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Translates a virtual address according to the vcpu’s current address
translation mode.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_translation {
      /* in */
      __u64 linear_address;

      /* out */
      __u64 physical_address;
      __u8  valid;
      __u8  writeable;
      __u8  usermode;
      __u8  pad[5];
};
</pre></div>
</div>
</section>
<section id="kvm-interrupt">
<h3>4.16 KVM_INTERRUPT<a class="headerlink" href="#kvm-interrupt" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, ppc, mips, riscv</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_interrupt (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, negative on failure.</p>
</dd>
</dl>
<p>Queues a hardware interrupt vector to be injected.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* for KVM_INTERRUPT */
struct kvm_interrupt {
      /* in */
      __u32 irq;
};
</pre></div>
</div>
<section id="x86">
<h4>X86:<a class="headerlink" href="#x86" title="Permalink to this headline">¶</a></h4>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>on success,</p></td>
</tr>
<tr class="row-even"><td><p>-EEXIST</p></td>
<td><p>if an interrupt is already enqueued</p></td>
</tr>
<tr class="row-odd"><td><p>-EINVAL</p></td>
<td><p>the irq number is invalid</p></td>
</tr>
<tr class="row-even"><td><p>-ENXIO</p></td>
<td><p>if the PIC is in the kernel</p></td>
</tr>
<tr class="row-odd"><td><p>-EFAULT</p></td>
<td><p>if the pointer is invalid</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>Note ‘irq’ is an interrupt vector, not an interrupt pin or line. This
ioctl is useful if the in-kernel PIC is not used.</p>
</section>
<section id="ppc">
<h4>PPC:<a class="headerlink" href="#ppc" title="Permalink to this headline">¶</a></h4>
<p>Queues an external interrupt to be injected. This ioctl is overleaded
with 3 different irq values:</p>
<ol class="loweralpha">
<li><p>KVM_INTERRUPT_SET</p>
<p>This injects an edge type external interrupt into the guest once it’s ready
to receive interrupts. When injected, the interrupt is done.</p>
</li>
<li><p>KVM_INTERRUPT_UNSET</p>
<p>This unsets any pending interrupt.</p>
<p>Only available with KVM_CAP_PPC_UNSET_IRQ.</p>
</li>
<li><p>KVM_INTERRUPT_SET_LEVEL</p>
<p>This injects a level type external interrupt into the guest context. The
interrupt stays pending until a specific ioctl with KVM_INTERRUPT_UNSET
is triggered.</p>
<p>Only available with KVM_CAP_PPC_IRQ_LEVEL.</p>
</li>
</ol>
<p>Note that any value for ‘irq’ other than the ones stated above is invalid
and incurs unexpected behavior.</p>
<p>This is an asynchronous vcpu ioctl and can be invoked from any thread.</p>
</section>
<section id="mips">
<h4>MIPS:<a class="headerlink" href="#mips" title="Permalink to this headline">¶</a></h4>
<p>Queues an external interrupt to be injected into the virtual CPU. A negative
interrupt number dequeues the interrupt.</p>
<p>This is an asynchronous vcpu ioctl and can be invoked from any thread.</p>
</section>
<section id="risc-v">
<h4>RISC-V:<a class="headerlink" href="#risc-v" title="Permalink to this headline">¶</a></h4>
<p>Queues an external interrupt to be injected into the virutal CPU. This ioctl
is overloaded with 2 different irq values:</p>
<ol class="loweralpha">
<li><p>KVM_INTERRUPT_SET</p>
<p>This sets external interrupt for a virtual CPU and it will receive
once it is ready.</p>
</li>
<li><p>KVM_INTERRUPT_UNSET</p>
<p>This clears pending external interrupt for a virtual CPU.</p>
</li>
</ol>
<p>This is an asynchronous vcpu ioctl and can be invoked from any thread.</p>
</section>
</section>
<section id="kvm-debug-guest">
<h3>4.17 KVM_DEBUG_GUEST<a class="headerlink" href="#kvm-debug-guest" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>-1 on error</p>
</dd>
</dl>
<p>Support for this has been removed.  Use KVM_SET_GUEST_DEBUG instead.</p>
</section>
<section id="kvm-get-msrs">
<h3>4.18 KVM_GET_MSRS<a class="headerlink" href="#kvm-get-msrs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic (vcpu), KVM_CAP_GET_MSR_FEATURES (system)</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl, vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_msrs (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of msrs successfully returned;
-1 on error</p>
</dd>
</dl>
<p>When used as a system ioctl:
Reads the values of MSR-based features that are available for the VM.  This
is similar to KVM_GET_SUPPORTED_CPUID, but it returns MSR indices and values.
The list of msr-based features can be obtained using KVM_GET_MSR_FEATURE_INDEX_LIST
in a system ioctl.</p>
<p>When used as a vcpu ioctl:
Reads model-specific registers from the vcpu.  Supported msr indices can
be obtained using KVM_GET_MSR_INDEX_LIST in a system ioctl.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_msrs {
      __u32 nmsrs; /* number of msrs in entries */
      __u32 pad;

      struct kvm_msr_entry entries[0];
};

struct kvm_msr_entry {
      __u32 index;
      __u32 reserved;
      __u64 data;
};
</pre></div>
</div>
<p>Application code should set the ‘nmsrs’ member (which indicates the
size of the entries array) and the ‘index’ member of each array entry.
kvm will fill in the ‘data’ member.</p>
</section>
<section id="kvm-set-msrs">
<h3>4.19 KVM_SET_MSRS<a class="headerlink" href="#kvm-set-msrs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_msrs (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of msrs successfully set (see below), -1 on error</p>
</dd>
</dl>
<p>Writes model-specific registers to the vcpu.  See KVM_GET_MSRS for the
data structures.</p>
<p>Application code should set the ‘nmsrs’ member (which indicates the
size of the entries array), and the ‘index’ and ‘data’ members of each
array entry.</p>
<p>It tries to set the MSRs in array entries[] one by one. If setting an MSR
fails, e.g., due to setting reserved bits, the MSR isn’t supported/emulated
by KVM, etc…, it stops processing the MSR list and returns the number of
MSRs that have been set successfully.</p>
</section>
<section id="kvm-set-cpuid">
<h3>4.20 KVM_SET_CPUID<a class="headerlink" href="#kvm-set-cpuid" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_cpuid (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Defines the vcpu responses to the cpuid instruction.  Applications
should use the KVM_SET_CPUID2 ioctl if available.</p>
<dl class="simple">
<dt>Caveat emptor:</dt><dd><ul class="simple">
<li><p>If this IOCTL fails, KVM gives no guarantees that previous valid CPUID
configuration (if there is) is not corrupted. Userspace can get a copy
of the resulting CPUID configuration through KVM_GET_CPUID2 in case.</p></li>
<li><p>Using KVM_SET_CPUID{,2} after KVM_RUN, i.e. changing the guest vCPU model
after running the guest, may cause guest instability.</p></li>
<li><p>Using heterogeneous CPUID configurations, modulo APIC IDs, topology, etc…
may cause guest instability.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_cpuid_entry {
      __u32 function;
      __u32 eax;
      __u32 ebx;
      __u32 ecx;
      __u32 edx;
      __u32 padding;
};

/* for KVM_SET_CPUID */
struct kvm_cpuid {
      __u32 nent;
      __u32 padding;
      struct kvm_cpuid_entry entries[0];
};
</pre></div>
</div>
</section>
<section id="kvm-set-signal-mask">
<h3>4.21 KVM_SET_SIGNAL_MASK<a class="headerlink" href="#kvm-set-signal-mask" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_signal_mask (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Defines which signals are blocked during execution of KVM_RUN.  This
signal mask temporarily overrides the threads signal mask.  Any
unblocked signal received (except SIGKILL and SIGSTOP, which retain
their traditional behaviour) will cause KVM_RUN to return with -EINTR.</p>
<p>Note the signal will only be delivered if not blocked by the original
signal mask.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* for KVM_SET_SIGNAL_MASK */
struct kvm_signal_mask {
      __u32 len;
      __u8  sigset[0];
};
</pre></div>
</div>
</section>
<section id="kvm-get-fpu">
<h3>4.22 KVM_GET_FPU<a class="headerlink" href="#kvm-get-fpu" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_fpu (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Reads the floating point state from the vcpu.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* for KVM_GET_FPU and KVM_SET_FPU */
struct kvm_fpu {
      __u8  fpr[8][16];
      __u16 fcw;
      __u16 fsw;
      __u8  ftwx;  /* in fxsave format */
      __u8  pad1;
      __u16 last_opcode;
      __u64 last_ip;
      __u64 last_dp;
      __u8  xmm[16][16];
      __u32 mxcsr;
      __u32 pad2;
};
</pre></div>
</div>
</section>
<section id="kvm-set-fpu">
<h3>4.23 KVM_SET_FPU<a class="headerlink" href="#kvm-set-fpu" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_fpu (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Writes the floating point state to the vcpu.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* for KVM_GET_FPU and KVM_SET_FPU */
struct kvm_fpu {
      __u8  fpr[8][16];
      __u16 fcw;
      __u16 fsw;
      __u8  ftwx;  /* in fxsave format */
      __u8  pad1;
      __u16 last_opcode;
      __u64 last_ip;
      __u64 last_dp;
      __u8  xmm[16][16];
      __u32 mxcsr;
      __u32 pad2;
};
</pre></div>
</div>
</section>
<section id="kvm-create-irqchip">
<h3>4.24 KVM_CREATE_IRQCHIP<a class="headerlink" href="#kvm-create-irqchip" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_IRQCHIP, KVM_CAP_S390_IRQCHIP (s390)</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, arm64, s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Creates an interrupt controller model in the kernel.
On x86, creates a virtual ioapic, a virtual PIC (two PICs, nested), and sets up
future vcpus to have a local APIC.  IRQ routing for GSIs 0-15 is set to both
PIC and IOAPIC; GSI 16-23 only go to the IOAPIC.
On arm64, a GICv2 is created. Any other GIC versions require the usage of
KVM_CREATE_DEVICE, which also supports creating a GICv2.  Using
KVM_CREATE_DEVICE is preferred over KVM_CREATE_IRQCHIP for GICv2.
On s390, a dummy irq routing table is created.</p>
<p>Note that on s390 the KVM_CAP_S390_IRQCHIP vm capability needs to be enabled
before KVM_CREATE_IRQCHIP can be used.</p>
</section>
<section id="kvm-irq-line">
<h3>4.25 KVM_IRQ_LINE<a class="headerlink" href="#kvm-irq-line" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_IRQCHIP</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_irq_level</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Sets the level of a GSI input to the interrupt controller model in the kernel.
On some architectures it is required that an interrupt controller model has
been previously created with KVM_CREATE_IRQCHIP.  Note that edge-triggered
interrupts require the level to be set to 1 and then back to 0.</p>
<p>On real hardware, interrupt pins can be active-low or active-high.  This
does not matter for the level field of struct kvm_irq_level: 1 always
means active (asserted), 0 means inactive (deasserted).</p>
<p>x86 allows the operating system to program the interrupt polarity
(active-low/active-high) for level-triggered interrupts, and KVM used
to consider the polarity.  However, due to bitrot in the handling of
active-low interrupts, the above convention is now valid on x86 too.
This is signaled by KVM_CAP_X86_IOAPIC_POLARITY_IGNORED.  Userspace
should not present interrupts to the guest as active-low unless this
capability is present (or unless it is not using the in-kernel irqchip,
of course).</p>
<p>arm64 can signal an interrupt either at the CPU level, or at the
in-kernel irqchip (GIC), and for in-kernel irqchip can tell the GIC to
use PPIs designated for specific cpus.  The irq field is interpreted
like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bits:  |  31 ... 28  | 27 ... 24 | 23  ... 16 | 15 ... 0 |
field: | vcpu2_index | irq_type  | vcpu_index |  irq_id  |
</pre></div>
</div>
<p>The irq_type field has the following values:</p>
<ul class="simple">
<li><dl class="simple">
<dt>irq_type[0]:</dt><dd><p>out-of-kernel GIC: irq_id 0 is IRQ, irq_id 1 is FIQ</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>irq_type[1]:</dt><dd><p>in-kernel GIC: SPI, irq_id between 32 and 1019 (incl.)
(the vcpu_index field is ignored)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>irq_type[2]:</dt><dd><p>in-kernel GIC: PPI, irq_id between 16 and 31 (incl.)</p>
</dd>
</dl>
</li>
</ul>
<p>(The irq_id field thus corresponds nicely to the IRQ ID in the ARM GIC specs)</p>
<p>In both cases, level is used to assert/deassert the line.</p>
<p>When KVM_CAP_ARM_IRQ_LINE_LAYOUT_2 is supported, the target vcpu is
identified as (256 * vcpu2_index + vcpu_index). Otherwise, vcpu2_index
must be zero.</p>
<p>Note that on arm64, the KVM_CAP_IRQCHIP capability only conditions
injection of interrupts for the in-kernel irqchip. KVM_IRQ_LINE can always
be used for a userspace interrupt controller.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_irq_level {
      union {
              __u32 irq;     /* GSI */
              __s32 status;  /* not used for KVM_IRQ_LEVEL */
      };
      __u32 level;           /* 0 or 1 */
};
</pre></div>
</div>
</section>
<section id="kvm-get-irqchip">
<h3>4.26 KVM_GET_IRQCHIP<a class="headerlink" href="#kvm-get-irqchip" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_IRQCHIP</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_irqchip (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Reads the state of a kernel interrupt controller created with
KVM_CREATE_IRQCHIP into a buffer provided by the caller.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_irqchip {
      __u32 chip_id;  /* 0 = PIC1, 1 = PIC2, 2 = IOAPIC */
      __u32 pad;
      union {
              char dummy[512];  /* reserving space */
              struct kvm_pic_state pic;
              struct kvm_ioapic_state ioapic;
      } chip;
};
</pre></div>
</div>
</section>
<section id="kvm-set-irqchip">
<h3>4.27 KVM_SET_IRQCHIP<a class="headerlink" href="#kvm-set-irqchip" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_IRQCHIP</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_irqchip (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Sets the state of a kernel interrupt controller created with
KVM_CREATE_IRQCHIP from a buffer provided by the caller.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_irqchip {
      __u32 chip_id;  /* 0 = PIC1, 1 = PIC2, 2 = IOAPIC */
      __u32 pad;
      union {
              char dummy[512];  /* reserving space */
              struct kvm_pic_state pic;
              struct kvm_ioapic_state ioapic;
      } chip;
};
</pre></div>
</div>
</section>
<section id="kvm-xen-hvm-config">
<h3>4.28 KVM_XEN_HVM_CONFIG<a class="headerlink" href="#kvm-xen-hvm-config" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_XEN_HVM</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_xen_hvm_config (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Sets the MSR that the Xen HVM guest uses to initialize its hypercall
page, and provides the starting address and size of the hypercall
blobs in userspace.  When the guest writes the MSR, kvm copies one
page of a blob (32- or 64-bit, depending on the vcpu mode) to guest
memory.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_xen_hvm_config {
      __u32 flags;
      __u32 msr;
      __u64 blob_addr_32;
      __u64 blob_addr_64;
      __u8 blob_size_32;
      __u8 blob_size_64;
      __u8 pad2[30];
};
</pre></div>
</div>
<p>If certain flags are returned from the KVM_CAP_XEN_HVM check, they may
be set in the flags field of this ioctl:</p>
<p>The KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL flag requests KVM to generate
the contents of the hypercall page automatically; hypercalls will be
intercepted and passed to userspace through KVM_EXIT_XEN.  In this
ase, all of the blob size and address fields must be zero.</p>
<p>The KVM_XEN_HVM_CONFIG_EVTCHN_SEND flag indicates to KVM that userspace
will always use the KVM_XEN_HVM_EVTCHN_SEND ioctl to deliver event
channel interrupts rather than manipulating the guest’s shared_info
structures directly. This, in turn, may allow KVM to enable features
such as intercepting the SCHEDOP_poll hypercall to accelerate PV
spinlock operation for the guest. Userspace may still use the ioctl
to deliver events if it was advertised, even if userspace does not
send this indication that it will always do so</p>
<p>No other flags are currently valid in the struct kvm_xen_hvm_config.</p>
</section>
<section id="kvm-get-clock">
<h3>4.29 KVM_GET_CLOCK<a class="headerlink" href="#kvm-get-clock" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_ADJUST_CLOCK</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_clock_data (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Gets the current timestamp of kvmclock as seen by the current guest. In
conjunction with KVM_SET_CLOCK, it is used to ensure monotonicity on scenarios
such as migration.</p>
<p>When KVM_CAP_ADJUST_CLOCK is passed to KVM_CHECK_EXTENSION, it returns the
set of bits that KVM can return in struct kvm_clock_data’s flag member.</p>
<p>The following flags are defined:</p>
<dl class="simple">
<dt>KVM_CLOCK_TSC_STABLE</dt><dd><p>If set, the returned value is the exact kvmclock
value seen by all VCPUs at the instant when KVM_GET_CLOCK was called.
If clear, the returned value is simply CLOCK_MONOTONIC plus a constant
offset; the offset can be modified with KVM_SET_CLOCK.  KVM will try
to make all VCPUs follow this clock, but the exact value read by each
VCPU could differ, because the host TSC is not stable.</p>
</dd>
<dt>KVM_CLOCK_REALTIME</dt><dd><p>If set, the <cite>realtime</cite> field in the kvm_clock_data
structure is populated with the value of the host’s real time
clocksource at the instant when KVM_GET_CLOCK was called. If clear,
the <cite>realtime</cite> field does not contain a value.</p>
</dd>
<dt>KVM_CLOCK_HOST_TSC</dt><dd><p>If set, the <cite>host_tsc</cite> field in the kvm_clock_data
structure is populated with the value of the host’s timestamp counter (TSC)
at the instant when KVM_GET_CLOCK was called. If clear, the <cite>host_tsc</cite> field
does not contain a value.</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_clock_data {
      __u64 clock;  /* kvmclock current value */
      __u32 flags;
      __u32 pad0;
      __u64 realtime;
      __u64 host_tsc;
      __u32 pad[4];
};
</pre></div>
</div>
</section>
<section id="kvm-set-clock">
<h3>4.30 KVM_SET_CLOCK<a class="headerlink" href="#kvm-set-clock" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_ADJUST_CLOCK</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_clock_data (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Sets the current timestamp of kvmclock to the value specified in its parameter.
In conjunction with KVM_GET_CLOCK, it is used to ensure monotonicity on scenarios
such as migration.</p>
<p>The following flags can be passed:</p>
<dl class="simple">
<dt>KVM_CLOCK_REALTIME</dt><dd><p>If set, KVM will compare the value of the <cite>realtime</cite> field
with the value of the host’s real time clocksource at the instant when
KVM_SET_CLOCK was called. The difference in elapsed time is added to the final
kvmclock value that will be provided to guests.</p>
</dd>
</dl>
<p>Other flags returned by <code class="docutils literal notranslate"><span class="pre">KVM_GET_CLOCK</span></code> are accepted but ignored.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_clock_data {
      __u64 clock;  /* kvmclock current value */
      __u32 flags;
      __u32 pad0;
      __u64 realtime;
      __u64 host_tsc;
      __u32 pad[4];
};
</pre></div>
</div>
</section>
<section id="kvm-get-vcpu-events">
<h3>4.31 KVM_GET_VCPU_EVENTS<a class="headerlink" href="#kvm-get-vcpu-events" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_VCPU_EVENTS</p>
</dd>
<dt class="field-even">Extended by</dt>
<dd class="field-even"><p>KVM_CAP_INTR_SHADOW</p>
</dd>
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86, arm64</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>vcpu ioctl</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>struct kvm_vcpu_event (out)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success, -1 on error</p>
</dd>
</dl>
<section id="id1">
<h4>X86:<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Gets currently pending exceptions, interrupts, and NMIs as well as related
states of the vcpu.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_vcpu_events {
      struct {
              __u8 injected;
              __u8 nr;
              __u8 has_error_code;
              __u8 pending;
              __u32 error_code;
      } exception;
      struct {
              __u8 injected;
              __u8 nr;
              __u8 soft;
              __u8 shadow;
      } interrupt;
      struct {
              __u8 injected;
              __u8 pending;
              __u8 masked;
              __u8 pad;
      } nmi;
      __u32 sipi_vector;
      __u32 flags;
      struct {
              __u8 smm;
              __u8 pending;
              __u8 smm_inside_nmi;
              __u8 latched_init;
      } smi;
      __u8 reserved[27];
      __u8 exception_has_payload;
      __u64 exception_payload;
};
</pre></div>
</div>
<p>The following bits are defined in the flags field:</p>
<ul class="simple">
<li><p>KVM_VCPUEVENT_VALID_SHADOW may be set to signal that
interrupt.shadow contains a valid state.</p></li>
<li><p>KVM_VCPUEVENT_VALID_SMM may be set to signal that smi contains a
valid state.</p></li>
<li><p>KVM_VCPUEVENT_VALID_PAYLOAD may be set to signal that the
exception_has_payload, exception_payload, and exception.pending
fields contain a valid state. This bit will be set whenever
KVM_CAP_EXCEPTION_PAYLOAD is enabled.</p></li>
<li><p>KVM_VCPUEVENT_VALID_TRIPLE_FAULT may be set to signal that the
triple_fault_pending field contains a valid state. This bit will
be set whenever KVM_CAP_X86_TRIPLE_FAULT_EVENT is enabled.</p></li>
</ul>
</section>
<section id="arm64">
<h4>ARM64:<a class="headerlink" href="#arm64" title="Permalink to this headline">¶</a></h4>
<p>If the guest accesses a device that is being emulated by the host kernel in
such a way that a real device would generate a physical SError, KVM may make
a virtual SError pending for that VCPU. This system error interrupt remains
pending until the guest takes the exception by unmasking PSTATE.A.</p>
<p>Running the VCPU may cause it to take a pending SError, or make an access that
causes an SError to become pending. The event’s description is only valid while
the VPCU is not running.</p>
<p>This API provides a way to read and write the pending ‘event’ state that is not
visible to the guest. To save, restore or migrate a VCPU the struct representing
the state can be read then written using this GET/SET API, along with the other
guest-visible registers. It is not possible to ‘cancel’ an SError that has been
made pending.</p>
<p>A device being emulated in user-space may also wish to generate an SError. To do
this the events structure can be populated by user-space. The current state
should be read first, to ensure no existing SError is pending. If an existing
SError is pending, the architecture’s ‘Multiple SError interrupts’ rules should
be followed. (2.5.3 of DDI0587.a “ARM Reliability, Availability, and
Serviceability (RAS) Specification”).</p>
<p>SError exceptions always have an ESR value. Some CPUs have the ability to
specify what the virtual SError’s ESR value should be. These systems will
advertise KVM_CAP_ARM_INJECT_SERROR_ESR. In this case exception.has_esr will
always have a non-zero value when read, and the agent making an SError pending
should specify the ISS field in the lower 24 bits of exception.serror_esr. If
the system supports KVM_CAP_ARM_INJECT_SERROR_ESR, but user-space sets the events
with exception.has_esr as zero, KVM will choose an ESR.</p>
<p>Specifying exception.has_esr on a system that does not support it will return
-EINVAL. Setting anything other than the lower 24bits of exception.serror_esr
will return -EINVAL.</p>
<p>It is not possible to read back a pending external abort (injected via
KVM_SET_VCPU_EVENTS or otherwise) because such an exception is always delivered
directly to the virtual CPU).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_vcpu_events {
      struct {
              __u8 serror_pending;
              __u8 serror_has_esr;
              __u8 ext_dabt_pending;
              /* Align it to 8 bytes */
              __u8 pad[5];
              __u64 serror_esr;
      } exception;
      __u32 reserved[12];
};
</pre></div>
</div>
</section>
</section>
<section id="kvm-set-vcpu-events">
<h3>4.32 KVM_SET_VCPU_EVENTS<a class="headerlink" href="#kvm-set-vcpu-events" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_VCPU_EVENTS</p>
</dd>
<dt class="field-even">Extended by</dt>
<dd class="field-even"><p>KVM_CAP_INTR_SHADOW</p>
</dd>
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86, arm64</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>vcpu ioctl</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>struct kvm_vcpu_event (in)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success, -1 on error</p>
</dd>
</dl>
<section id="id2">
<h4>X86:<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Set pending exceptions, interrupts, and NMIs as well as related states of the
vcpu.</p>
<p>See KVM_GET_VCPU_EVENTS for the data structure.</p>
<p>Fields that may be modified asynchronously by running VCPUs can be excluded
from the update. These fields are nmi.pending, sipi_vector, smi.smm,
smi.pending. Keep the corresponding bits in the flags field cleared to
suppress overwriting the current in-kernel state. The bits are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 52%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>KVM_VCPUEVENT_VALID_NMI_PENDING</p></td>
<td><p>transfer nmi.pending to the kernel</p></td>
</tr>
<tr class="row-even"><td><p>KVM_VCPUEVENT_VALID_SIPI_VECTOR</p></td>
<td><p>transfer sipi_vector</p></td>
</tr>
<tr class="row-odd"><td><p>KVM_VCPUEVENT_VALID_SMM</p></td>
<td><p>transfer the smi sub-struct.</p></td>
</tr>
</tbody>
</table>
<p>If KVM_CAP_INTR_SHADOW is available, KVM_VCPUEVENT_VALID_SHADOW can be set in
the flags field to signal that interrupt.shadow contains a valid state and
shall be written into the VCPU.</p>
<p>KVM_VCPUEVENT_VALID_SMM can only be set if KVM_CAP_X86_SMM is available.</p>
<p>If KVM_CAP_EXCEPTION_PAYLOAD is enabled, KVM_VCPUEVENT_VALID_PAYLOAD
can be set in the flags field to signal that the
exception_has_payload, exception_payload, and exception.pending fields
contain a valid state and shall be written into the VCPU.</p>
<p>If KVM_CAP_X86_TRIPLE_FAULT_EVENT is enabled, KVM_VCPUEVENT_VALID_TRIPLE_FAULT
can be set in flags field to signal that the triple_fault field contains
a valid state and shall be written into the VCPU.</p>
</section>
<section id="id3">
<h4>ARM64:<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>User space may need to inject several types of events to the guest.</p>
<p>Set the pending SError exception state for this VCPU. It is not possible to
‘cancel’ an Serror that has been made pending.</p>
<p>If the guest performed an access to I/O memory which could not be handled by
userspace, for example because of missing instruction syndrome decode
information or because there is no device mapped at the accessed IPA, then
userspace can ask the kernel to inject an external abort using the address
from the exiting fault on the VCPU. It is a programming error to set
ext_dabt_pending after an exit which was not either KVM_EXIT_MMIO or
KVM_EXIT_ARM_NISV. This feature is only available if the system supports
KVM_CAP_ARM_INJECT_EXT_DABT. This is a helper which provides commonality in
how userspace reports accesses for the above cases to guests, across different
userspace implementations. Nevertheless, userspace can still emulate all Arm
exceptions by manipulating individual registers using the KVM_SET_ONE_REG API.</p>
<p>See KVM_GET_VCPU_EVENTS for the data structure.</p>
</section>
</section>
<section id="kvm-get-debugregs">
<h3>4.33 KVM_GET_DEBUGREGS<a class="headerlink" href="#kvm-get-debugregs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_DEBUGREGS</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_debugregs (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Reads debug registers from the vcpu.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_debugregs {
      __u64 db[4];
      __u64 dr6;
      __u64 dr7;
      __u64 flags;
      __u64 reserved[9];
};
</pre></div>
</div>
</section>
<section id="kvm-set-debugregs">
<h3>4.34 KVM_SET_DEBUGREGS<a class="headerlink" href="#kvm-set-debugregs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_DEBUGREGS</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_debugregs (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Writes debug registers into the vcpu.</p>
<p>See KVM_GET_DEBUGREGS for the data structure. The flags field is unused
yet and must be cleared on entry.</p>
</section>
<section id="kvm-set-user-memory-region">
<h3>4.35 KVM_SET_USER_MEMORY_REGION<a class="headerlink" href="#kvm-set-user-memory-region" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_USER_MEMORY</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_userspace_memory_region (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_userspace_memory_region {
      __u32 slot;
      __u32 flags;
      __u64 guest_phys_addr;
      __u64 memory_size; /* bytes */
      __u64 userspace_addr; /* start of the userspace allocated memory */
};

/* for kvm_userspace_memory_region::flags */
#define KVM_MEM_LOG_DIRTY_PAGES       (1UL &lt;&lt; 0)
#define KVM_MEM_READONLY      (1UL &lt;&lt; 1)
</pre></div>
</div>
<p>This ioctl allows the user to create, modify or delete a guest physical
memory slot.  Bits 0-15 of “slot” specify the slot id and this value
should be less than the maximum number of user memory slots supported per
VM.  The maximum allowed slots can be queried using KVM_CAP_NR_MEMSLOTS.
Slots may not overlap in guest physical address space.</p>
<p>If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 of “slot”
specifies the address space which is being modified.  They must be
less than the value that KVM_CHECK_EXTENSION returns for the
KVM_CAP_MULTI_ADDRESS_SPACE capability.  Slots in separate address spaces
are unrelated; the restriction on overlapping slots only applies within
each address space.</p>
<p>Deleting a slot is done by passing zero for memory_size.  When changing
an existing slot, it may be moved in the guest physical memory space,
or its flags may be modified, but it may not be resized.</p>
<p>Memory for the region is taken starting at the address denoted by the
field userspace_addr, which must point at user addressable memory for
the entire memory slot size.  Any object may back this memory, including
anonymous memory, ordinary files, and hugetlbfs.</p>
<p>On architectures that support a form of address tagging, userspace_addr must
be an untagged address.</p>
<p>It is recommended that the lower 21 bits of guest_phys_addr and userspace_addr
be identical.  This allows large pages in the guest to be backed by large
pages in the host.</p>
<p>The flags field supports two flags: KVM_MEM_LOG_DIRTY_PAGES and
KVM_MEM_READONLY.  The former can be set to instruct KVM to keep track of
writes to memory within the slot.  See KVM_GET_DIRTY_LOG ioctl to know how to
use it.  The latter can be set, if KVM_CAP_READONLY_MEM capability allows it,
to make a new slot read-only.  In this case, writes to this memory will be
posted to userspace as KVM_EXIT_MMIO exits.</p>
<p>When the KVM_CAP_SYNC_MMU capability is available, changes in the backing of
the memory region are automatically reflected into the guest.  For example, an
mmap() that affects the region will be made visible immediately.  Another
example is madvise(MADV_DROP).</p>
<p>Note: On arm64, a write generated by the page-table walker (to update
the Access and Dirty flags, for example) never results in a
KVM_EXIT_MMIO exit when the slot has the KVM_MEM_READONLY flag. This
is because KVM cannot provide the data that would be written by the
page-table walker, making it impossible to emulate the access.
Instead, an abort (data abort if the cause of the page-table update
was a load or a store, instruction abort if it was an instruction
fetch) is injected in the guest.</p>
</section>
<section id="kvm-set-tss-addr">
<h3>4.36 KVM_SET_TSS_ADDR<a class="headerlink" href="#kvm-set-tss-addr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SET_TSS_ADDR</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>unsigned long tss_address (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>This ioctl defines the physical address of a three-page region in the guest
physical address space.  The region must be within the first 4GB of the
guest physical address space and must not conflict with any memory slot
or any mmio address.  The guest may malfunction if it accesses this memory
region.</p>
<p>This ioctl is required on Intel-based hosts.  This is needed on Intel hardware
because of a quirk in the virtualization implementation (see the internals
documentation when it pops into existence).</p>
</section>
<section id="kvm-enable-cap">
<h3>4.37 KVM_ENABLE_CAP<a class="headerlink" href="#kvm-enable-cap" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_ENABLE_CAP</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>mips, ppc, s390, x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_enable_cap (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -1 on error</p>
</dd>
<dt class="field-even">Capability</dt>
<dd class="field-even"><p>KVM_CAP_ENABLE_CAP_VM</p>
</dd>
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>all</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>vm ioctl</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>struct kvm_enable_cap (in)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success; -1 on error</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not all extensions are enabled by default. Using this ioctl the application
can enable an extension, making it available to the guest.</p>
</div>
<p>On systems that do not support this ioctl, it always fails. On systems that
do support it, it only works for extensions that are supported for enablement.</p>
<p>To check if a capability can be enabled, the KVM_CHECK_EXTENSION ioctl should
be used.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_enable_cap {
     /* in */
     __u32 cap;
</pre></div>
</div>
<p>The capability that is supposed to get enabled.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u32 flags;
</pre></div>
</div>
<p>A bitfield indicating future enhancements. Has to be 0 for now.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u64 args[4];
</pre></div>
</div>
<p>Arguments for enabling a feature. If a feature needs initial values to
function properly, this is the place to put them.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     __u8  pad[64];
};
</pre></div>
</div>
<p>The vcpu ioctl should be used for vcpu-specific capabilities, the vm ioctl
for vm-wide capabilities.</p>
</section>
<section id="kvm-get-mp-state">
<h3>4.38 KVM_GET_MP_STATE<a class="headerlink" href="#kvm-get-mp-state" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_MP_STATE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, s390, arm64, riscv</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_mp_state (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_mp_state {
      __u32 mp_state;
};
</pre></div>
</div>
<p>Returns the vcpu’s current “multiprocessing state” (though also valid on
uniprocessor guests).</p>
<p>Possible values are:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 64%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>KVM_MP_STATE_RUNNABLE</p></td>
<td><p>the vcpu is currently running
[x86,arm64,riscv]</p></td>
</tr>
<tr class="row-even"><td><p>KVM_MP_STATE_UNINITIALIZED</p></td>
<td><p>the vcpu is an application processor (AP)
which has not yet received an INIT signal [x86]</p></td>
</tr>
<tr class="row-odd"><td><p>KVM_MP_STATE_INIT_RECEIVED</p></td>
<td><p>the vcpu has received an INIT signal, and is
now ready for a SIPI [x86]</p></td>
</tr>
<tr class="row-even"><td><p>KVM_MP_STATE_HALTED</p></td>
<td><p>the vcpu has executed a HLT instruction and
is waiting for an interrupt [x86]</p></td>
</tr>
<tr class="row-odd"><td><p>KVM_MP_STATE_SIPI_RECEIVED</p></td>
<td><p>the vcpu has just received a SIPI (vector
accessible via KVM_GET_VCPU_EVENTS) [x86]</p></td>
</tr>
<tr class="row-even"><td><p>KVM_MP_STATE_STOPPED</p></td>
<td><p>the vcpu is stopped [s390,arm64,riscv]</p></td>
</tr>
<tr class="row-odd"><td><p>KVM_MP_STATE_CHECK_STOP</p></td>
<td><p>the vcpu is in a special error state [s390]</p></td>
</tr>
<tr class="row-even"><td><p>KVM_MP_STATE_OPERATING</p></td>
<td><p>the vcpu is operating (running or halted)
[s390]</p></td>
</tr>
<tr class="row-odd"><td><p>KVM_MP_STATE_LOAD</p></td>
<td><p>the vcpu is in a special load/startup state
[s390]</p></td>
</tr>
<tr class="row-even"><td><p>KVM_MP_STATE_SUSPENDED</p></td>
<td><p>the vcpu is in a suspend state and is waiting
for a wakeup event [arm64]</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>On x86, this ioctl is only useful after KVM_CREATE_IRQCHIP. Without an
in-kernel irqchip, the multiprocessing state must be maintained by userspace on
these architectures.</p>
<section id="for-arm64">
<h4>For arm64:<a class="headerlink" href="#for-arm64" title="Permalink to this headline">¶</a></h4>
<p>If a vCPU is in the KVM_MP_STATE_SUSPENDED state, KVM will emulate the
architectural execution of a WFI instruction.</p>
<p>If a wakeup event is recognized, KVM will exit to userspace with a
KVM_SYSTEM_EVENT exit, where the event type is KVM_SYSTEM_EVENT_WAKEUP. If
userspace wants to honor the wakeup, it must set the vCPU’s MP state to
KVM_MP_STATE_RUNNABLE. If it does not, KVM will continue to await a wakeup
event in subsequent calls to KVM_RUN.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If userspace intends to keep the vCPU in a SUSPENDED state, it is
strongly recommended that userspace take action to suppress the
wakeup event (such as masking an interrupt). Otherwise, subsequent
calls to KVM_RUN will immediately exit with a KVM_SYSTEM_EVENT_WAKEUP
event and inadvertently waste CPU cycles.</p>
<p>Additionally, if userspace takes action to suppress a wakeup event,
it is strongly recommended that it also restores the vCPU to its
original state when the vCPU is made RUNNABLE again. For example,
if userspace masked a pending interrupt to suppress the wakeup,
the interrupt should be unmasked before returning control to the
guest.</p>
</div>
</section>
<section id="for-riscv">
<h4>For riscv:<a class="headerlink" href="#for-riscv" title="Permalink to this headline">¶</a></h4>
<p>The only states that are valid are KVM_MP_STATE_STOPPED and
KVM_MP_STATE_RUNNABLE which reflect if the vcpu is paused or not.</p>
</section>
</section>
<section id="kvm-set-mp-state">
<h3>4.39 KVM_SET_MP_STATE<a class="headerlink" href="#kvm-set-mp-state" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_MP_STATE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, s390, arm64, riscv</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_mp_state (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>Sets the vcpu’s current “multiprocessing state”; see KVM_GET_MP_STATE for
arguments.</p>
<p>On x86, this ioctl is only useful after KVM_CREATE_IRQCHIP. Without an
in-kernel irqchip, the multiprocessing state must be maintained by userspace on
these architectures.</p>
<section id="for-arm64-riscv">
<h4>For arm64/riscv:<a class="headerlink" href="#for-arm64-riscv" title="Permalink to this headline">¶</a></h4>
<p>The only states that are valid are KVM_MP_STATE_STOPPED and
KVM_MP_STATE_RUNNABLE which reflect if the vcpu should be paused or not.</p>
</section>
</section>
<section id="kvm-set-identity-map-addr">
<h3>4.40 KVM_SET_IDENTITY_MAP_ADDR<a class="headerlink" href="#kvm-set-identity-map-addr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SET_IDENTITY_MAP_ADDR</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>unsigned long identity (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>This ioctl defines the physical address of a one-page region in the guest
physical address space.  The region must be within the first 4GB of the
guest physical address space and must not conflict with any memory slot
or any mmio address.  The guest may malfunction if it accesses this memory
region.</p>
<p>Setting the address to 0 will result in resetting the address to its default
(0xfffbc000).</p>
<p>This ioctl is required on Intel-based hosts.  This is needed on Intel hardware
because of a quirk in the virtualization implementation (see the internals
documentation when it pops into existence).</p>
<p>Fails if any VCPU has already been created.</p>
</section>
<section id="kvm-set-boot-cpu-id">
<h3>4.41 KVM_SET_BOOT_CPU_ID<a class="headerlink" href="#kvm-set-boot-cpu-id" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SET_BOOT_CPU_ID</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>unsigned long vcpu_id</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Define which vcpu is the Bootstrap Processor (BSP).  Values are the same
as the vcpu id in KVM_CREATE_VCPU.  If this ioctl is not called, the default
is vcpu 0. This ioctl has to be called before vcpu creation,
otherwise it will return EBUSY error.</p>
</section>
<section id="kvm-get-xsave">
<h3>4.42 KVM_GET_XSAVE<a class="headerlink" href="#kvm-get-xsave" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_XSAVE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_xsave (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_xsave {
      __u32 region[1024];
      __u32 extra[0];
};
</pre></div>
</div>
<p>This ioctl would copy current vcpu’s xsave struct to the userspace.</p>
</section>
<section id="kvm-set-xsave">
<h3>4.43 KVM_SET_XSAVE<a class="headerlink" href="#kvm-set-xsave" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_XSAVE and KVM_CAP_XSAVE2</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_xsave (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_xsave {
      __u32 region[1024];
      __u32 extra[0];
};
</pre></div>
</div>
<p>This ioctl would copy userspace’s xsave struct to the kernel. It copies
as many bytes as are returned by KVM_CHECK_EXTENSION(KVM_CAP_XSAVE2),
when invoked on the vm file descriptor. The size value returned by
KVM_CHECK_EXTENSION(KVM_CAP_XSAVE2) will always be at least 4096.
Currently, it is only greater than 4096 if a dynamic feature has been
enabled with <code class="docutils literal notranslate"><span class="pre">arch_prctl()</span></code>, but this may change in the future.</p>
<p>The offsets of the state save areas in struct kvm_xsave follow the
contents of CPUID leaf 0xD on the host.</p>
</section>
<section id="kvm-get-xcrs">
<h3>4.44 KVM_GET_XCRS<a class="headerlink" href="#kvm-get-xcrs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_XCRS</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_xcrs (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_xcr {
      __u32 xcr;
      __u32 reserved;
      __u64 value;
};

struct kvm_xcrs {
      __u32 nr_xcrs;
      __u32 flags;
      struct kvm_xcr xcrs[KVM_MAX_XCRS];
      __u64 padding[16];
};
</pre></div>
</div>
<p>This ioctl would copy current vcpu’s xcrs to the userspace.</p>
</section>
<section id="kvm-set-xcrs">
<h3>4.45 KVM_SET_XCRS<a class="headerlink" href="#kvm-set-xcrs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_XCRS</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_xcrs (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_xcr {
      __u32 xcr;
      __u32 reserved;
      __u64 value;
};

struct kvm_xcrs {
      __u32 nr_xcrs;
      __u32 flags;
      struct kvm_xcr xcrs[KVM_MAX_XCRS];
      __u64 padding[16];
};
</pre></div>
</div>
<p>This ioctl would set vcpu’s xcr to the value userspace specified.</p>
</section>
<section id="kvm-get-supported-cpuid">
<h3>4.46 KVM_GET_SUPPORTED_CPUID<a class="headerlink" href="#kvm-get-supported-cpuid" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_EXT_CPUID</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_cpuid2 (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_cpuid2 {
      __u32 nent;
      __u32 padding;
      struct kvm_cpuid_entry2 entries[0];
};

#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX               BIT(0)
#define KVM_CPUID_FLAG_STATEFUL_FUNC          BIT(1) /* deprecated */
#define KVM_CPUID_FLAG_STATE_READ_NEXT                BIT(2) /* deprecated */

struct kvm_cpuid_entry2 {
      __u32 function;
      __u32 index;
      __u32 flags;
      __u32 eax;
      __u32 ebx;
      __u32 ecx;
      __u32 edx;
      __u32 padding[3];
};
</pre></div>
</div>
<p>This ioctl returns x86 cpuid features which are supported by both the
hardware and kvm in its default configuration.  Userspace can use the
information returned by this ioctl to construct cpuid information (for
KVM_SET_CPUID2) that is consistent with hardware, kernel, and
userspace capabilities, and with user requirements (for example, the
user may wish to constrain cpuid to emulate older hardware, or for
feature consistency across a cluster).</p>
<p>Dynamically-enabled feature bits need to be requested with
<code class="docutils literal notranslate"><span class="pre">arch_prctl()</span></code> before calling this ioctl. Feature bits that have not
been requested are excluded from the result.</p>
<p>Note that certain capabilities, such as KVM_CAP_X86_DISABLE_EXITS, may
expose cpuid features (e.g. MONITOR) which are not supported by kvm in
its default configuration. If userspace enables such capabilities, it
is responsible for modifying the results of this ioctl appropriately.</p>
<p>Userspace invokes KVM_GET_SUPPORTED_CPUID by passing a kvm_cpuid2 structure
with the ‘nent’ field indicating the number of entries in the variable-size
array ‘entries’.  If the number of entries is too low to describe the cpu
capabilities, an error (E2BIG) is returned.  If the number is too high,
the ‘nent’ field is adjusted and an error (ENOMEM) is returned.  If the
number is just right, the ‘nent’ field is adjusted to the number of valid
entries in the ‘entries’ array, which is then filled.</p>
<p>The entries returned are the host cpuid as returned by the cpuid instruction,
with unknown or unsupported features masked out.  Some features (for example,
x2apic), may not be present in the host cpu, but are exposed by kvm if it can
emulate them efficiently. The fields in each entry are defined as follows:</p>
<blockquote>
<div><dl>
<dt>function:</dt><dd><p>the eax value used to obtain the entry</p>
</dd>
<dt>index:</dt><dd><p>the ecx value used to obtain the entry (for entries that are
affected by ecx)</p>
</dd>
<dt>flags:</dt><dd><blockquote>
<div><p>an OR of zero or more of the following:</p>
<blockquote>
<div><dl class="simple">
<dt>KVM_CPUID_FLAG_SIGNIFCANT_INDEX:</dt><dd><p>if the index field is valid</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>eax, ebx, ecx, edx:</dt><dd><p>the values returned by the cpuid instruction for
this function/index combination</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>The TSC deadline timer feature (CPUID leaf 1, ecx[24]) is always returned
as false, since the feature depends on KVM_CREATE_IRQCHIP for local APIC
support.  Instead it is reported via:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ioctl(KVM_CHECK_EXTENSION, KVM_CAP_TSC_DEADLINE_TIMER)
</pre></div>
</div>
<p>if that returns true and you use KVM_CREATE_IRQCHIP, or if you emulate the
feature in userspace, then you can enable the feature for KVM_SET_CPUID2.</p>
</section>
<section id="kvm-ppc-get-pvinfo">
<h3>4.47 KVM_PPC_GET_PVINFO<a class="headerlink" href="#kvm-ppc-get-pvinfo" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_GET_PVINFO</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_ppc_pvinfo (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, !0 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_ppc_pvinfo {
      __u32 flags;
      __u32 hcall[4];
      __u8  pad[108];
};
</pre></div>
</div>
<p>This ioctl fetches PV specific information that need to be passed to the guest
using the device tree or other means from vm context.</p>
<p>The hcall array defines 4 instructions that make up a hypercall.</p>
<p>If any additional field gets added to this structure later on, a bit for that
additional piece of information will be set in the flags bitmap.</p>
<p>The flags bitmap is defined as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* the host supports the ePAPR idle hcall
#define KVM_PPC_PVINFO_FLAGS_EV_IDLE   (1&lt;&lt;0)
</pre></div>
</div>
</section>
<section id="kvm-set-gsi-routing">
<h3>4.52 KVM_SET_GSI_ROUTING<a class="headerlink" href="#kvm-set-gsi-routing" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_IRQ_ROUTING</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86 s390 arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_irq_routing (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Sets the GSI routing table entries, overwriting any previously set entries.</p>
<p>On arm64, GSI routing has the following limitation:</p>
<ul class="simple">
<li><p>GSI routing does not apply to KVM_IRQ_LINE but only to KVM_IRQFD.</p></li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_irq_routing {
      __u32 nr;
      __u32 flags;
      struct kvm_irq_routing_entry entries[0];
};
</pre></div>
</div>
<p>No flags are specified so far, the corresponding field must be set to zero.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_irq_routing_entry {
      __u32 gsi;
      __u32 type;
      __u32 flags;
      __u32 pad;
      union {
              struct kvm_irq_routing_irqchip irqchip;
              struct kvm_irq_routing_msi msi;
              struct kvm_irq_routing_s390_adapter adapter;
              struct kvm_irq_routing_hv_sint hv_sint;
              struct kvm_irq_routing_xen_evtchn xen_evtchn;
              __u32 pad[8];
      } u;
};

/* gsi routing entry types */
#define KVM_IRQ_ROUTING_IRQCHIP 1
#define KVM_IRQ_ROUTING_MSI 2
#define KVM_IRQ_ROUTING_S390_ADAPTER 3
#define KVM_IRQ_ROUTING_HV_SINT 4
#define KVM_IRQ_ROUTING_XEN_EVTCHN 5
</pre></div>
</div>
<p>flags:</p>
<ul class="simple">
<li><p>KVM_MSI_VALID_DEVID: used along with KVM_IRQ_ROUTING_MSI routing entry
type, specifies that the devid field contains a valid value.  The per-VM
KVM_CAP_MSI_DEVID capability advertises the requirement to provide
the device ID.  If this capability is not available, userspace should
never set the KVM_MSI_VALID_DEVID flag as the ioctl might fail.</p></li>
<li><p>zero otherwise</p></li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_irq_routing_irqchip {
      __u32 irqchip;
      __u32 pin;
};

struct kvm_irq_routing_msi {
      __u32 address_lo;
      __u32 address_hi;
      __u32 data;
      union {
              __u32 pad;
              __u32 devid;
      };
};
</pre></div>
</div>
<p>If KVM_MSI_VALID_DEVID is set, devid contains a unique device identifier
for the device that wrote the MSI message.  For PCI, this is usually a
BFD identifier in the lower 16 bits.</p>
<p>On x86, address_hi is ignored unless the KVM_X2APIC_API_USE_32BIT_IDS
feature of KVM_CAP_X2APIC_API capability is enabled.  If it is enabled,
address_hi bits 31-8 provide bits 31-8 of the destination id.  Bits 7-0 of
address_hi must be zero.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_irq_routing_s390_adapter {
      __u64 ind_addr;
      __u64 summary_addr;
      __u64 ind_offset;
      __u32 summary_offset;
      __u32 adapter_id;
};

struct kvm_irq_routing_hv_sint {
      __u32 vcpu;
      __u32 sint;
};

struct kvm_irq_routing_xen_evtchn {
      __u32 port;
      __u32 vcpu;
      __u32 priority;
};
</pre></div>
</div>
<p>When KVM_CAP_XEN_HVM includes the KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL bit
in its indication of supported features, routing to Xen event channels
is supported. Although the priority field is present, only the value
KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL is supported, which means delivery by
2 level event channels. FIFO event channel support may be added in
the future.</p>
</section>
<section id="kvm-set-tsc-khz">
<h3>4.55 KVM_SET_TSC_KHZ<a class="headerlink" href="#kvm-set-tsc-khz" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_TSC_CONTROL / KVM_CAP_VM_TSC_CONTROL</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl / vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>virtual tsc_khz</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Specifies the tsc frequency for the virtual machine. The unit of the
frequency is KHz.</p>
<p>If the KVM_CAP_VM_TSC_CONTROL capability is advertised, this can also
be used as a vm ioctl to set the initial tsc frequency of subsequently
created vCPUs.</p>
</section>
<section id="kvm-get-tsc-khz">
<h3>4.56 KVM_GET_TSC_KHZ<a class="headerlink" href="#kvm-get-tsc-khz" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_GET_TSC_KHZ / KVM_CAP_VM_TSC_CONTROL</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl / vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>virtual tsc-khz on success, negative value on error</p>
</dd>
</dl>
<p>Returns the tsc frequency of the guest. The unit of the return value is
KHz. If the host has unstable tsc this ioctl returns -EIO instead as an
error.</p>
</section>
<section id="kvm-get-lapic">
<h3>4.57 KVM_GET_LAPIC<a class="headerlink" href="#kvm-get-lapic" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_IRQCHIP</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_lapic_state (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_APIC_REG_SIZE 0x400
struct kvm_lapic_state {
      char regs[KVM_APIC_REG_SIZE];
};
</pre></div>
</div>
<p>Reads the Local APIC registers and copies them into the input argument.  The
data format and layout are the same as documented in the architecture manual.</p>
<p>If KVM_X2APIC_API_USE_32BIT_IDS feature of KVM_CAP_X2APIC_API is
enabled, then the format of APIC_ID register depends on the APIC mode
(reported by MSR_IA32_APICBASE) of its VCPU.  x2APIC stores APIC ID in
the APIC_ID register (bytes 32-35).  xAPIC only allows an 8-bit APIC ID
which is stored in bits 31-24 of the APIC register, or equivalently in
byte 35 of struct kvm_lapic_state’s regs field.  KVM_GET_LAPIC must then
be called after MSR_IA32_APICBASE has been set with KVM_SET_MSR.</p>
<p>If KVM_X2APIC_API_USE_32BIT_IDS feature is disabled, struct kvm_lapic_state
always uses xAPIC format.</p>
</section>
<section id="kvm-set-lapic">
<h3>4.58 KVM_SET_LAPIC<a class="headerlink" href="#kvm-set-lapic" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_IRQCHIP</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_lapic_state (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_APIC_REG_SIZE 0x400
struct kvm_lapic_state {
      char regs[KVM_APIC_REG_SIZE];
};
</pre></div>
</div>
<p>Copies the input argument into the Local APIC registers.  The data format
and layout are the same as documented in the architecture manual.</p>
<p>The format of the APIC ID register (bytes 32-35 of struct kvm_lapic_state’s
regs field) depends on the state of the KVM_CAP_X2APIC_API capability.
See the note in KVM_GET_LAPIC.</p>
</section>
<section id="kvm-ioeventfd">
<h3>4.59 KVM_IOEVENTFD<a class="headerlink" href="#kvm-ioeventfd" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_IOEVENTFD</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_ioeventfd (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, !0 on error</p>
</dd>
</dl>
<p>This ioctl attaches or detaches an ioeventfd to a legal pio/mmio address
within the guest.  A guest write in the registered address will signal the
provided event instead of triggering an exit.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_ioeventfd {
      __u64 datamatch;
      __u64 addr;        /* legal pio/mmio address */
      __u32 len;         /* 0, 1, 2, 4, or 8 bytes    */
      __s32 fd;
      __u32 flags;
      __u8  pad[36];
};
</pre></div>
</div>
<p>For the special case of virtio-ccw devices on s390, the ioevent is matched
to a subchannel/virtqueue tuple instead.</p>
<p>The following flags are defined:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_IOEVENTFD_FLAG_DATAMATCH (1 &lt;&lt; kvm_ioeventfd_flag_nr_datamatch)
#define KVM_IOEVENTFD_FLAG_PIO       (1 &lt;&lt; kvm_ioeventfd_flag_nr_pio)
#define KVM_IOEVENTFD_FLAG_DEASSIGN  (1 &lt;&lt; kvm_ioeventfd_flag_nr_deassign)
#define KVM_IOEVENTFD_FLAG_VIRTIO_CCW_NOTIFY \
      (1 &lt;&lt; kvm_ioeventfd_flag_nr_virtio_ccw_notify)
</pre></div>
</div>
<p>If datamatch flag is set, the event will be signaled only if the written value
to the registered address is equal to datamatch in struct kvm_ioeventfd.</p>
<p>For virtio-ccw devices, addr contains the subchannel id and datamatch the
virtqueue index.</p>
<p>With KVM_CAP_IOEVENTFD_ANY_LENGTH, a zero length ioeventfd is allowed, and
the kernel will ignore the length of guest write and may get a faster vmexit.
The speedup may only apply to specific architectures, but the ioeventfd will
work anyway.</p>
</section>
<section id="kvm-dirty-tlb">
<h3>4.60 KVM_DIRTY_TLB<a class="headerlink" href="#kvm-dirty-tlb" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SW_TLB</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_dirty_tlb (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_dirty_tlb {
      __u64 bitmap;
      __u32 num_dirty;
};
</pre></div>
</div>
<p>This must be called whenever userspace has changed an entry in the shared
TLB, prior to calling KVM_RUN on the associated vcpu.</p>
<p>The “bitmap” field is the userspace address of an array.  This array
consists of a number of bits, equal to the total number of TLB entries as
determined by the last successful call to KVM_CONFIG_TLB, rounded up to the
nearest multiple of 64.</p>
<p>Each bit corresponds to one TLB entry, ordered the same as in the shared TLB
array.</p>
<p>The array is little-endian: the bit 0 is the least significant bit of the
first byte, bit 8 is the least significant bit of the second byte, etc.
This avoids any complications with differing word sizes.</p>
<p>The “num_dirty” field is a performance hint for KVM to determine whether it
should skip processing the bitmap and just invalidate everything.  It must
be set to the number of set bits in the bitmap.</p>
</section>
<section id="kvm-create-spapr-tce">
<h3>4.62 KVM_CREATE_SPAPR_TCE<a class="headerlink" href="#kvm-create-spapr-tce" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SPAPR_TCE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>powerpc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_create_spapr_tce (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>file descriptor for manipulating the created TCE table</p>
</dd>
</dl>
<p>This creates a virtual TCE (translation control entry) table, which
is an IOMMU for PAPR-style virtual I/O.  It is used to translate
logical addresses used in virtual I/O into guest physical addresses,
and provides a scatter/gather capability for PAPR virtual I/O.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* for KVM_CAP_SPAPR_TCE */
struct kvm_create_spapr_tce {
      __u64 liobn;
      __u32 window_size;
};
</pre></div>
</div>
<p>The liobn field gives the logical IO bus number for which to create a
TCE table.  The window_size field specifies the size of the DMA window
which this TCE table will translate - the table will contain one 64
bit TCE entry for every 4kiB of the DMA window.</p>
<p>When the guest issues an H_PUT_TCE hcall on a liobn for which a TCE
table has been created using this ioctl(), the kernel will handle it
in real mode, updating the TCE table.  H_PUT_TCE calls for other
liobns will cause a vm exit and must be handled by userspace.</p>
<p>The return value is a file descriptor which can be passed to mmap(2)
to map the created TCE table into userspace.  This lets userspace read
the entries written by kernel-handled H_PUT_TCE calls, and also lets
userspace update the TCE table directly which is useful in some
circumstances.</p>
</section>
<section id="kvm-allocate-rma">
<h3>4.63 KVM_ALLOCATE_RMA<a class="headerlink" href="#kvm-allocate-rma" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_RMA</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>powerpc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_allocate_rma (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>file descriptor for mapping the allocated RMA</p>
</dd>
</dl>
<p>This allocates a Real Mode Area (RMA) from the pool allocated at boot
time by the kernel.  An RMA is a physically-contiguous, aligned region
of memory used on older POWER processors to provide the memory which
will be accessed by real-mode (MMU off) accesses in a KVM guest.
POWER processors support a set of sizes for the RMA that usually
includes 64MB, 128MB, 256MB and some larger powers of two.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* for KVM_ALLOCATE_RMA */
struct kvm_allocate_rma {
      __u64 rma_size;
};
</pre></div>
</div>
<p>The return value is a file descriptor which can be passed to mmap(2)
to map the allocated RMA into userspace.  The mapped area can then be
passed to the KVM_SET_USER_MEMORY_REGION ioctl to establish it as the
RMA for a virtual machine.  The size of the RMA in bytes (which is
fixed at host kernel boot time) is returned in the rma_size field of
the argument structure.</p>
<p>The KVM_CAP_PPC_RMA capability is 1 or 2 if the KVM_ALLOCATE_RMA ioctl
is supported; 2 if the processor requires all virtual machines to have
an RMA, or 1 if the processor can use an RMA but doesn’t require it,
because it supports the Virtual RMA (VRMA) facility.</p>
</section>
<section id="kvm-nmi">
<h3>4.64 KVM_NMI<a class="headerlink" href="#kvm-nmi" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_USER_NMI</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Queues an NMI on the thread’s vcpu.  Note this is well defined only
when KVM_CREATE_IRQCHIP has not been called, since this is an interface
between the virtual cpu core and virtual local APIC.  After KVM_CREATE_IRQCHIP
has been called, this interface is completely emulated within the kernel.</p>
<p>To use this to emulate the LINT1 input with KVM_CREATE_IRQCHIP, use the
following algorithm:</p>
<blockquote>
<div><ul class="simple">
<li><p>pause the vcpu</p></li>
<li><p>read the local APIC’s state (KVM_GET_LAPIC)</p></li>
<li><p>check whether changing LINT1 will queue an NMI (see the LVT entry for LINT1)</p></li>
<li><p>if so, issue KVM_NMI</p></li>
<li><p>resume the vcpu</p></li>
</ul>
</div></blockquote>
<p>Some guests configure the LINT1 NMI input to cause a panic, aiding in
debugging.</p>
</section>
<section id="kvm-s390-ucas-map">
<h3>4.65 KVM_S390_UCAS_MAP<a class="headerlink" href="#kvm-s390-ucas-map" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_UCONTROL</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_ucas_mapping (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 in case of success</p>
</dd>
</dl>
<p>The parameter is defined like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_ucas_mapping {
        __u64 user_addr;
        __u64 vcpu_addr;
        __u64 length;
};
</pre></div>
</div>
<p>This ioctl maps the memory at “user_addr” with the length “length” to
the vcpu’s address space starting at “vcpu_addr”. All parameters need to
be aligned by 1 megabyte.</p>
</section>
<section id="kvm-s390-ucas-unmap">
<h3>4.66 KVM_S390_UCAS_UNMAP<a class="headerlink" href="#kvm-s390-ucas-unmap" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_UCONTROL</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_ucas_mapping (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 in case of success</p>
</dd>
</dl>
<p>The parameter is defined like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_ucas_mapping {
        __u64 user_addr;
        __u64 vcpu_addr;
        __u64 length;
};
</pre></div>
</div>
<p>This ioctl unmaps the memory in the vcpu’s address space starting at
“vcpu_addr” with the length “length”. The field “user_addr” is ignored.
All parameters need to be aligned by 1 megabyte.</p>
</section>
<section id="kvm-s390-vcpu-fault">
<h3>4.67 KVM_S390_VCPU_FAULT<a class="headerlink" href="#kvm-s390-vcpu-fault" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_UCONTROL</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>vcpu absolute address (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 in case of success</p>
</dd>
</dl>
<p>This call creates a page table entry on the virtual cpu’s address space
(for user controlled virtual machines) or the virtual machine’s address
space (for regular virtual machines). This only works for minor faults,
thus it’s recommended to access subject memory page via the user page
table upfront. This is useful to handle validity intercepts for user
controlled virtual machines to fault in the virtual cpu’s lowcore pages
prior to calling the KVM_RUN ioctl.</p>
</section>
<section id="kvm-set-one-reg">
<h3>4.68 KVM_SET_ONE_REG<a class="headerlink" href="#kvm-set-one-reg" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_ONE_REG</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_one_reg (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, negative value on failure</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 91%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ENOENT</p></td>
<td><p>no such register</p></td>
</tr>
<tr class="row-even"><td><p>EINVAL</p></td>
<td><p>invalid register ID, or no such register or used with VMs in
protected virtualization mode on s390</p></td>
</tr>
<tr class="row-odd"><td><p>EPERM</p></td>
<td><p>(arm64) register access not allowed before vcpu finalization</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>(These error codes are indicative only: do not rely on a specific error
code being returned in a specific situation.)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> struct kvm_one_reg {
      __u64 id;
      __u64 addr;
};
</pre></div>
</div>
<p>Using this ioctl, a single vcpu register can be set to a specific value
defined by user space with the passed in struct kvm_one_reg, where id
refers to the register identifier as described below and addr is a pointer
to a variable with the respective size. There can be architecture agnostic
and architecture specific registers. Each have their own range of operation
and their own constants and width. To keep track of the implemented
registers, find a list below:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 62%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Arch</p></th>
<th class="head"><p>Register</p></th>
<th class="head"><p>Width (bits)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_HIOR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_IAC1</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_IAC2</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_IAC3</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_IAC4</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DAC1</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DAC2</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DABR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DSCR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PURR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_SPURR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DAR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DSISR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_AMR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_UAMOR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MMCR0</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MMCR1</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MMCRA</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MMCR2</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MMCRS</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MMCR3</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_SIAR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_SDAR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_SIER</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_SIER2</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_SIER3</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PMC1</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PMC2</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PMC3</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PMC4</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PMC5</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PMC6</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PMC7</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PMC8</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_FPR0</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_FPR31</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_VR0</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_VR31</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_VSR0</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_VSR31</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_FPSCR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_VSCR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_VPA_ADDR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_VPA_SLB</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_VPA_DTL</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_EPCR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_EPR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TCR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TSR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_OR_TSR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_CLEAR_TSR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MAS0</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MAS1</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MAS2</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MAS7_3</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MAS4</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MAS6</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_MMUCFG</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TLB0CFG</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TLB1CFG</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TLB2CFG</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TLB3CFG</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TLB0PS</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TLB1PS</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TLB2PS</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TLB3PS</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_EPTCFG</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_ICP_STATE</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_VP_STATE</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TB_OFFSET</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_SPMC1</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_SPMC2</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_IAMR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TFHAR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TFIAR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TEXASR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_FSCR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PSPB</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_EBBHR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_EBBRR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_BESCR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TAR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DPDES</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DAWR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DAWRX</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_CIABR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_IC</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_VTB</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_CSIGR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TACR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TCSCR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PID</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_ACOP</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_VRSAVE</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_LPCR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_LPCR_64</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PPR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_ARCH_COMPAT</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DABRX</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_WORT</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_SPRG9</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DBSR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TIDR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PSSCR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DEC_EXPIRY</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_PTCR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DAWR1</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_DAWRX1</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_GPR0</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_GPR31</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_VSR0</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_VSR63</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_CR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_LR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_CTR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_FPSCR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_AMR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_PPR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_VRSAVE</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_VSCR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_DSCR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_TAR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>PPC</p></td>
<td><p>KVM_REG_PPC_TM_XER</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_R0</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_R31</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_HI</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_LO</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_PC</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_INDEX</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_ENTRYLO0</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_ENTRYLO1</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_CONTEXT</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_CONTEXTCONFIG</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_USERLOCAL</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_XCONTEXTCONFIG</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_PAGEMASK</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_PAGEGRAIN</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_SEGCTL0</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_SEGCTL1</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_SEGCTL2</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_PWBASE</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_PWFIELD</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_PWSIZE</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_WIRED</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_PWCTL</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_HWRENA</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_BADVADDR</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_BADINSTR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_BADINSTRP</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_COUNT</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_ENTRYHI</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_COMPARE</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_STATUS</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_INTCTL</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_CAUSE</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_EPC</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_PRID</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_EBASE</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_CONFIG</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_CONFIG1</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_CONFIG2</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_CONFIG3</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_CONFIG4</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_CONFIG5</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_CONFIG7</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_XCONTEXT</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_ERROREPC</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_KSCRATCH1</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_KSCRATCH2</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_KSCRATCH3</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_KSCRATCH4</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_KSCRATCH5</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_KSCRATCH6</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_CP0_MAAR(0..63)</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_COUNT_CTL</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_COUNT_RESUME</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_COUNT_HZ</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_FPR_32(0..31)</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_FPR_64(0..31)</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_VEC_128(0..31)</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_FCR_IR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_FCR_CSR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_MSA_IR</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>MIPS</p></td>
<td><p>KVM_REG_MIPS_MSA_CSR</p></td>
<td><p>32</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>ARM registers are mapped using the lower 32 bits.  The upper 16 of that
is the register group type, or coprocessor number:</p>
<p>ARM core registers have the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x4020 0000 0010 &lt;index into the kvm_regs struct:16&gt;
</pre></div>
</div>
<p>ARM 32-bit CP15 registers have the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x4020 0000 000F &lt;zero:1&gt; &lt;crn:4&gt; &lt;crm:4&gt; &lt;opc1:4&gt; &lt;opc2:3&gt;
</pre></div>
</div>
<p>ARM 64-bit CP15 registers have the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x4030 0000 000F &lt;zero:1&gt; &lt;zero:4&gt; &lt;crm:4&gt; &lt;opc1:4&gt; &lt;zero:3&gt;
</pre></div>
</div>
<p>ARM CCSIDR registers are demultiplexed by CSSELR value:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x4020 0000 0011 00 &lt;csselr:8&gt;
</pre></div>
</div>
<p>ARM 32-bit VFP control registers have the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x4020 0000 0012 1 &lt;regno:12&gt;
</pre></div>
</div>
<p>ARM 64-bit FP registers have the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x4030 0000 0012 0 &lt;regno:12&gt;
</pre></div>
</div>
<p>ARM firmware pseudo-registers have the following bit pattern:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x4030 0000 0014 &lt;regno:16&gt;
</pre></div>
</div>
<p>arm64 registers are mapped using the lower 32 bits. The upper 16 of
that is the register group type, or coprocessor number:</p>
<p>arm64 core/FP-SIMD registers have the following id bit patterns. Note
that the size of the access is variable, as the kvm_regs structure
contains elements ranging from 32 to 128 bits. The index is a 32bit
value in the kvm_regs structure seen as a 32bit array:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x60x0 0000 0010 &lt;index into the kvm_regs struct:16&gt;
</pre></div>
</div>
<p>Specifically:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 12%" />
<col style="width: 7%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Encoding</p></th>
<th class="head"><p>Register</p></th>
<th class="head"><p>Bits</p></th>
<th class="head"><p>kvm_regs member</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x6030 0000 0010 0000</p></td>
<td><p>X0</p></td>
<td><p>64</p></td>
<td><p>regs.regs[0]</p></td>
</tr>
<tr class="row-odd"><td><p>0x6030 0000 0010 0002</p></td>
<td><p>X1</p></td>
<td><p>64</p></td>
<td><p>regs.regs[1]</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0x6030 0000 0010 003c</p></td>
<td><p>X30</p></td>
<td><p>64</p></td>
<td><p>regs.regs[30]</p></td>
</tr>
<tr class="row-even"><td><p>0x6030 0000 0010 003e</p></td>
<td><p>SP</p></td>
<td><p>64</p></td>
<td><p>regs.sp</p></td>
</tr>
<tr class="row-odd"><td><p>0x6030 0000 0010 0040</p></td>
<td><p>PC</p></td>
<td><p>64</p></td>
<td><p>regs.pc</p></td>
</tr>
<tr class="row-even"><td><p>0x6030 0000 0010 0042</p></td>
<td><p>PSTATE</p></td>
<td><p>64</p></td>
<td><p>regs.pstate</p></td>
</tr>
<tr class="row-odd"><td><p>0x6030 0000 0010 0044</p></td>
<td><p>SP_EL1</p></td>
<td><p>64</p></td>
<td><p>sp_el1</p></td>
</tr>
<tr class="row-even"><td><p>0x6030 0000 0010 0046</p></td>
<td><p>ELR_EL1</p></td>
<td><p>64</p></td>
<td><p>elr_el1</p></td>
</tr>
<tr class="row-odd"><td><p>0x6030 0000 0010 0048</p></td>
<td><p>SPSR_EL1</p></td>
<td><p>64</p></td>
<td><p>spsr[KVM_SPSR_EL1] (alias SPSR_SVC)</p></td>
</tr>
<tr class="row-even"><td><p>0x6030 0000 0010 004a</p></td>
<td><p>SPSR_ABT</p></td>
<td><p>64</p></td>
<td><p>spsr[KVM_SPSR_ABT]</p></td>
</tr>
<tr class="row-odd"><td><p>0x6030 0000 0010 004c</p></td>
<td><p>SPSR_UND</p></td>
<td><p>64</p></td>
<td><p>spsr[KVM_SPSR_UND]</p></td>
</tr>
<tr class="row-even"><td><p>0x6030 0000 0010 004e</p></td>
<td><p>SPSR_IRQ</p></td>
<td><p>64</p></td>
<td><p>spsr[KVM_SPSR_IRQ]</p></td>
</tr>
<tr class="row-odd"><td><p>0x6060 0000 0010 0050</p></td>
<td><p>SPSR_FIQ</p></td>
<td><p>64</p></td>
<td><p>spsr[KVM_SPSR_FIQ]</p></td>
</tr>
<tr class="row-even"><td><p>0x6040 0000 0010 0054</p></td>
<td><p>V0</p></td>
<td><p>128</p></td>
<td><p>fp_regs.vregs[0]    <a class="footnote-reference brackets" href="#id7" id="id4">1</a></p></td>
</tr>
<tr class="row-odd"><td><p>0x6040 0000 0010 0058</p></td>
<td><p>V1</p></td>
<td><p>128</p></td>
<td><p>fp_regs.vregs[1]    <a class="footnote-reference brackets" href="#id7" id="id5">1</a></p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0x6040 0000 0010 00d0</p></td>
<td><p>V31</p></td>
<td><p>128</p></td>
<td><p>fp_regs.vregs[31]   <a class="footnote-reference brackets" href="#id7" id="id6">1</a></p></td>
</tr>
<tr class="row-even"><td><p>0x6020 0000 0010 00d4</p></td>
<td><p>FPSR</p></td>
<td><p>32</p></td>
<td><p>fp_regs.fpsr</p></td>
</tr>
<tr class="row-odd"><td><p>0x6020 0000 0010 00d5</p></td>
<td><p>FPCR</p></td>
<td><p>32</p></td>
<td><p>fp_regs.fpcr</p></td>
</tr>
</tbody>
</table>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets">1</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id5">2</a>,<a href="#id6">3</a>)</span></dt>
<dd><p>These encodings are not accepted for SVE-enabled vcpus.  See
KVM_ARM_VCPU_INIT.</p>
<p>The equivalent register content can be accessed via bits [127:0] of
the corresponding SVE Zn registers instead for vcpus that have SVE
enabled (see below).</p>
</dd>
</dl>
<p>arm64 CCSIDR registers are demultiplexed by CSSELR value:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x6020 0000 0011 00 &lt;csselr:8&gt;
</pre></div>
</div>
<p>arm64 system registers have the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x6030 0000 0013 &lt;op0:2&gt; &lt;op1:3&gt; &lt;crn:4&gt; &lt;crm:4&gt; &lt;op2:3&gt;
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Two system register IDs do not follow the specified pattern.  These
are KVM_REG_ARM_TIMER_CVAL and KVM_REG_ARM_TIMER_CNT, which map to
system registers CNTV_CVAL_EL0 and CNTVCT_EL0 respectively.  These
two had their values accidentally swapped, which means TIMER_CVAL is
derived from the register encoding for CNTVCT_EL0 and TIMER_CNT is
derived from the register encoding for CNTV_CVAL_EL0.  As this is
API, it must remain this way.</p>
</div>
<p>arm64 firmware pseudo-registers have the following bit pattern:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x6030 0000 0014 &lt;regno:16&gt;
</pre></div>
</div>
<p>arm64 SVE registers have the following bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x6080 0000 0015 00 &lt;n:5&gt; &lt;slice:5&gt;   Zn bits[2048*slice + 2047 : 2048*slice]
0x6050 0000 0015 04 &lt;n:4&gt; &lt;slice:5&gt;   Pn bits[256*slice + 255 : 256*slice]
0x6050 0000 0015 060 &lt;slice:5&gt;        FFR bits[256*slice + 255 : 256*slice]
0x6060 0000 0015 ffff                 KVM_REG_ARM64_SVE_VLS pseudo-register
</pre></div>
</div>
<p>Access to register IDs where 2048 * slice &gt;= 128 * max_vq will fail with
ENOENT.  max_vq is the vcpu’s maximum supported vector length in 128-bit
quadwords: see <a class="footnote-reference brackets" href="#id9" id="id8">2</a> below.</p>
<p>These registers are only accessible on vcpus for which SVE is enabled.
See KVM_ARM_VCPU_INIT for details.</p>
<p>In addition, except for KVM_REG_ARM64_SVE_VLS, these registers are not
accessible until the vcpu’s SVE configuration has been finalized
using KVM_ARM_VCPU_FINALIZE(KVM_ARM_VCPU_SVE).  See KVM_ARM_VCPU_INIT
and KVM_ARM_VCPU_FINALIZE for more information about this procedure.</p>
<p>KVM_REG_ARM64_SVE_VLS is a pseudo-register that allows the set of vector
lengths supported by the vcpu to be discovered and configured by
userspace.  When transferred to or from user memory via KVM_GET_ONE_REG
or KVM_SET_ONE_REG, the value of this register is of type
__u64[KVM_ARM64_SVE_VLS_WORDS], and encodes the set of vector lengths as
follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u64 vector_lengths[KVM_ARM64_SVE_VLS_WORDS];

if (vq &gt;= SVE_VQ_MIN &amp;&amp; vq &lt;= SVE_VQ_MAX &amp;&amp;
    ((vector_lengths[(vq - KVM_ARM64_SVE_VQ_MIN) / 64] &gt;&gt;
              ((vq - KVM_ARM64_SVE_VQ_MIN) % 64)) &amp; 1))
      /* Vector length vq * 16 bytes supported */
else
      /* Vector length vq * 16 bytes not supported */
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id8">2</a></span></dt>
<dd><p>The maximum value vq for which the above condition is true is
max_vq.  This is the maximum vector length available to the guest on
this vcpu, and determines which register slices are visible through
this ioctl interface.</p>
</dd>
</dl>
<p>(See <a class="reference internal" href="../../arm64/sve.html"><span class="doc">Scalable Vector Extension support for AArch64 Linux</span></a> for an explanation of the “vq”
nomenclature.)</p>
<p>KVM_REG_ARM64_SVE_VLS is only accessible after KVM_ARM_VCPU_INIT.
KVM_ARM_VCPU_INIT initialises it to the best set of vector lengths that
the host supports.</p>
<p>Userspace may subsequently modify it if desired until the vcpu’s SVE
configuration is finalized using KVM_ARM_VCPU_FINALIZE(KVM_ARM_VCPU_SVE).</p>
<p>Apart from simply removing all vector lengths from the host set that
exceed some value, support for arbitrarily chosen sets of vector lengths
is hardware-dependent and may not be available.  Attempting to configure
an invalid set of vector lengths via KVM_SET_ONE_REG will fail with
EINVAL.</p>
<p>After the vcpu’s SVE configuration is finalized, further attempts to
write this register will fail with EPERM.</p>
<p>arm64 bitmap feature firmware pseudo-registers have the following bit pattern:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x6030 0000 0016 &lt;regno:16&gt;
</pre></div>
</div>
<p>The bitmap feature firmware registers exposes the hypercall services that
are available for userspace to configure. The set bits corresponds to the
services that are available for the guests to access. By default, KVM
sets all the supported bits during VM initialization. The userspace can
discover the available services via KVM_GET_ONE_REG, and write back the
bitmap corresponding to the features that it wishes guests to see via
KVM_SET_ONE_REG.</p>
<p>Note: These registers are immutable once any of the vCPUs of the VM has
run at least once. A KVM_SET_ONE_REG in such a scenario will return
a -EBUSY to userspace.</p>
<p>(See <a class="reference internal" href="arm/hypercalls.html"><span class="doc">ARM Hypercall Interface</span></a> for more details.)</p>
<p>MIPS registers are mapped using the lower 32 bits.  The upper 16 of that is
the register group type:</p>
<p>MIPS core registers (see above) have the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x7030 0000 0000 &lt;reg:16&gt;
</pre></div>
</div>
<p>MIPS CP0 registers (see KVM_REG_MIPS_CP0_* above) have the following id bit
patterns depending on whether they’re 32-bit or 64-bit registers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x7020 0000 0001 00 &lt;reg:5&gt; &lt;sel:3&gt;   (32-bit)
0x7030 0000 0001 00 &lt;reg:5&gt; &lt;sel:3&gt;   (64-bit)
</pre></div>
</div>
<p>Note: KVM_REG_MIPS_CP0_ENTRYLO0 and KVM_REG_MIPS_CP0_ENTRYLO1 are the MIPS64
versions of the EntryLo registers regardless of the word size of the host
hardware, host kernel, guest, and whether XPA is present in the guest, i.e.
with the RI and XI bits (if they exist) in bits 63 and 62 respectively, and
the PFNX field starting at bit 30.</p>
<p>MIPS MAARs (see KVM_REG_MIPS_CP0_MAAR(*) above) have the following id bit
patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x7030 0000 0001 01 &lt;reg:8&gt;
</pre></div>
</div>
<p>MIPS KVM control registers (see above) have the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x7030 0000 0002 &lt;reg:16&gt;
</pre></div>
</div>
<p>MIPS FPU registers (see KVM_REG_MIPS_FPR_{32,64}() above) have the following
id bit patterns depending on the size of the register being accessed. They are
always accessed according to the current guest FPU mode (Status.FR and
Config5.FRE), i.e. as the guest would see them, and they become unpredictable
if the guest FPU mode is changed. MIPS SIMD Architecture (MSA) vector
registers (see KVM_REG_MIPS_VEC_128() above) have similar patterns as they
overlap the FPU registers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x7020 0000 0003 00 &lt;0:3&gt; &lt;reg:5&gt; (32-bit FPU registers)
0x7030 0000 0003 00 &lt;0:3&gt; &lt;reg:5&gt; (64-bit FPU registers)
0x7040 0000 0003 00 &lt;0:3&gt; &lt;reg:5&gt; (128-bit MSA vector registers)
</pre></div>
</div>
<p>MIPS FPU control registers (see KVM_REG_MIPS_FCR_{IR,CSR} above) have the
following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x7020 0000 0003 01 &lt;0:3&gt; &lt;reg:5&gt;
</pre></div>
</div>
<p>MIPS MSA control registers (see KVM_REG_MIPS_MSA_{IR,CSR} above) have the
following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x7020 0000 0003 02 &lt;0:3&gt; &lt;reg:5&gt;
</pre></div>
</div>
<p>RISC-V registers are mapped using the lower 32 bits. The upper 8 bits of
that is the register group type.</p>
<p>RISC-V config registers are meant for configuring a Guest VCPU and it has
the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x8020 0000 01 &lt;index into the kvm_riscv_config struct:24&gt; (32bit Host)
0x8030 0000 01 &lt;index into the kvm_riscv_config struct:24&gt; (64bit Host)
</pre></div>
</div>
<p>Following are the RISC-V config registers:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 12%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Encoding</p></th>
<th class="head"><p>Register</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x80x0 0000 0100 0000</p></td>
<td><p>isa</p></td>
<td><p>ISA feature bitmap of Guest VCPU</p></td>
</tr>
</tbody>
</table>
<p>The isa config register can be read anytime but can only be written before
a Guest VCPU runs. It will have ISA feature bits matching underlying host
set by default.</p>
<p>RISC-V core registers represent the general excution state of a Guest VCPU
and it has the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x8020 0000 02 &lt;index into the kvm_riscv_core struct:24&gt; (32bit Host)
0x8030 0000 02 &lt;index into the kvm_riscv_core struct:24&gt; (64bit Host)
</pre></div>
</div>
<p>Following are the RISC-V core registers:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 12%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Encoding</p></th>
<th class="head"><p>Register</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x80x0 0000 0200 0000</p></td>
<td><p>regs.pc</p></td>
<td><p>Program counter</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 0001</p></td>
<td><p>regs.ra</p></td>
<td><p>Return address</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 0002</p></td>
<td><p>regs.sp</p></td>
<td><p>Stack pointer</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 0003</p></td>
<td><p>regs.gp</p></td>
<td><p>Global pointer</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 0004</p></td>
<td><p>regs.tp</p></td>
<td><p>Task pointer</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 0005</p></td>
<td><p>regs.t0</p></td>
<td><p>Caller saved register 0</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 0006</p></td>
<td><p>regs.t1</p></td>
<td><p>Caller saved register 1</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 0007</p></td>
<td><p>regs.t2</p></td>
<td><p>Caller saved register 2</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 0008</p></td>
<td><p>regs.s0</p></td>
<td><p>Callee saved register 0</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 0009</p></td>
<td><p>regs.s1</p></td>
<td><p>Callee saved register 1</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 000a</p></td>
<td><p>regs.a0</p></td>
<td><p>Function argument (or return value) 0</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 000b</p></td>
<td><p>regs.a1</p></td>
<td><p>Function argument (or return value) 1</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 000c</p></td>
<td><p>regs.a2</p></td>
<td><p>Function argument 2</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 000d</p></td>
<td><p>regs.a3</p></td>
<td><p>Function argument 3</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 000e</p></td>
<td><p>regs.a4</p></td>
<td><p>Function argument 4</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 000f</p></td>
<td><p>regs.a5</p></td>
<td><p>Function argument 5</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 0010</p></td>
<td><p>regs.a6</p></td>
<td><p>Function argument 6</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 0011</p></td>
<td><p>regs.a7</p></td>
<td><p>Function argument 7</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 0012</p></td>
<td><p>regs.s2</p></td>
<td><p>Callee saved register 2</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 0013</p></td>
<td><p>regs.s3</p></td>
<td><p>Callee saved register 3</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 0014</p></td>
<td><p>regs.s4</p></td>
<td><p>Callee saved register 4</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 0015</p></td>
<td><p>regs.s5</p></td>
<td><p>Callee saved register 5</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 0016</p></td>
<td><p>regs.s6</p></td>
<td><p>Callee saved register 6</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 0017</p></td>
<td><p>regs.s7</p></td>
<td><p>Callee saved register 7</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 0018</p></td>
<td><p>regs.s8</p></td>
<td><p>Callee saved register 8</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 0019</p></td>
<td><p>regs.s9</p></td>
<td><p>Callee saved register 9</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 001a</p></td>
<td><p>regs.s10</p></td>
<td><p>Callee saved register 10</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 001b</p></td>
<td><p>regs.s11</p></td>
<td><p>Callee saved register 11</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 001c</p></td>
<td><p>regs.t3</p></td>
<td><p>Caller saved register 3</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 001d</p></td>
<td><p>regs.t4</p></td>
<td><p>Caller saved register 4</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 001e</p></td>
<td><p>regs.t5</p></td>
<td><p>Caller saved register 5</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0200 001f</p></td>
<td><p>regs.t6</p></td>
<td><p>Caller saved register 6</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0200 0020</p></td>
<td><p>mode</p></td>
<td><p>Privilege mode (1 = S-mode or 0 = U-mode)</p></td>
</tr>
</tbody>
</table>
<p>RISC-V csr registers represent the supervisor mode control/status registers
of a Guest VCPU and it has the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x8020 0000 03 &lt;index into the kvm_riscv_csr struct:24&gt; (32bit Host)
0x8030 0000 03 &lt;index into the kvm_riscv_csr struct:24&gt; (64bit Host)
</pre></div>
</div>
<p>Following are the RISC-V csr registers:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 12%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Encoding</p></th>
<th class="head"><p>Register</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x80x0 0000 0300 0000</p></td>
<td><p>sstatus</p></td>
<td><p>Supervisor status</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0300 0001</p></td>
<td><p>sie</p></td>
<td><p>Supervisor interrupt enable</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0300 0002</p></td>
<td><p>stvec</p></td>
<td><p>Supervisor trap vector base</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0300 0003</p></td>
<td><p>sscratch</p></td>
<td><p>Supervisor scratch register</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0300 0004</p></td>
<td><p>sepc</p></td>
<td><p>Supervisor exception program counter</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0300 0005</p></td>
<td><p>scause</p></td>
<td><p>Supervisor trap cause</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0300 0006</p></td>
<td><p>stval</p></td>
<td><p>Supervisor bad address or instruction</p></td>
</tr>
<tr class="row-odd"><td><p>0x80x0 0000 0300 0007</p></td>
<td><p>sip</p></td>
<td><p>Supervisor interrupt pending</p></td>
</tr>
<tr class="row-even"><td><p>0x80x0 0000 0300 0008</p></td>
<td><p>satp</p></td>
<td><p>Supervisor address translation and protection</p></td>
</tr>
</tbody>
</table>
<p>RISC-V timer registers represent the timer state of a Guest VCPU and it has
the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x8030 0000 04 &lt;index into the kvm_riscv_timer struct:24&gt;
</pre></div>
</div>
<p>Following are the RISC-V timer registers:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 12%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Encoding</p></th>
<th class="head"><p>Register</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x8030 0000 0400 0000</p></td>
<td><p>frequency</p></td>
<td><p>Time base frequency (read-only)</p></td>
</tr>
<tr class="row-odd"><td><p>0x8030 0000 0400 0001</p></td>
<td><p>time</p></td>
<td><p>Time value visible to Guest</p></td>
</tr>
<tr class="row-even"><td><p>0x8030 0000 0400 0002</p></td>
<td><p>compare</p></td>
<td><p>Time compare programmed by Guest</p></td>
</tr>
<tr class="row-odd"><td><p>0x8030 0000 0400 0003</p></td>
<td><p>state</p></td>
<td><p>Time compare state (1 = ON or 0 = OFF)</p></td>
</tr>
</tbody>
</table>
<p>RISC-V F-extension registers represent the single precision floating point
state of a Guest VCPU and it has the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x8020 0000 05 &lt;index into the __riscv_f_ext_state struct:24&gt;
</pre></div>
</div>
<p>Following are the RISC-V F-extension registers:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 12%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Encoding</p></th>
<th class="head"><p>Register</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x8020 0000 0500 0000</p></td>
<td><p>f[0]</p></td>
<td><p>Floating point register 0</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0x8020 0000 0500 001f</p></td>
<td><p>f[31]</p></td>
<td><p>Floating point register 31</p></td>
</tr>
<tr class="row-odd"><td><p>0x8020 0000 0500 0020</p></td>
<td><p>fcsr</p></td>
<td><p>Floating point control and status register</p></td>
</tr>
</tbody>
</table>
<p>RISC-V D-extension registers represent the double precision floating point
state of a Guest VCPU and it has the following id bit patterns:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x8020 0000 06 &lt;index into the __riscv_d_ext_state struct:24&gt; (fcsr)
0x8030 0000 06 &lt;index into the __riscv_d_ext_state struct:24&gt; (non-fcsr)
</pre></div>
</div>
<p>Following are the RISC-V D-extension registers:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 12%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Encoding</p></th>
<th class="head"><p>Register</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x8030 0000 0600 0000</p></td>
<td><p>f[0]</p></td>
<td><p>Floating point register 0</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0x8030 0000 0600 001f</p></td>
<td><p>f[31]</p></td>
<td><p>Floating point register 31</p></td>
</tr>
<tr class="row-odd"><td><p>0x8020 0000 0600 0020</p></td>
<td><p>fcsr</p></td>
<td><p>Floating point control and status register</p></td>
</tr>
</tbody>
</table>
</section>
<section id="kvm-get-one-reg">
<h3>4.69 KVM_GET_ONE_REG<a class="headerlink" href="#kvm-get-one-reg" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_ONE_REG</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_one_reg (in and out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, negative value on failure</p>
</dd>
</dl>
<p>Errors include:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 88%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ENOENT</p></td>
<td><p>no such register</p></td>
</tr>
<tr class="row-even"><td><p>EINVAL</p></td>
<td><p>invalid register ID, or no such register or used with VMs in
protected virtualization mode on s390</p></td>
</tr>
<tr class="row-odd"><td><p>EPERM</p></td>
<td><p>(arm64) register access not allowed before vcpu finalization</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>(These error codes are indicative only: do not rely on a specific error
code being returned in a specific situation.)</p>
<p>This ioctl allows to receive the value of a single register implemented
in a vcpu. The register to read is indicated by the “id” field of the
kvm_one_reg struct passed in. On success, the register value can be found
at the memory location pointed to by “addr”.</p>
<p>The list of registers accessible using this interface is identical to the
list in 4.68.</p>
</section>
<section id="kvm-kvmclock-ctrl">
<h3>4.70 KVM_KVMCLOCK_CTRL<a class="headerlink" href="#kvm-kvmclock-ctrl" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_KVMCLOCK_CTRL</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>Any that implement pvclocks (currently x86 only)</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>This ioctl sets a flag accessible to the guest indicating that the specified
vCPU has been paused by the host userspace.</p>
<p>The host will set a flag in the pvclock structure that is checked from the
soft lockup watchdog.  The flag is part of the pvclock structure that is
shared between guest and host, specifically the second bit of the flags
field of the pvclock_vcpu_time_info structure.  It will be set exclusively by
the host and read/cleared exclusively by the guest.  The guest operation of
checking and clearing the flag must be an atomic operation so
load-link/store-conditional, or equivalent must be used.  There are two cases
where the guest will clear the flag: when the soft lockup watchdog timer resets
itself or when a soft lockup is detected.  This ioctl can be called any time
after pausing the vcpu, but before it is resumed.</p>
</section>
<section id="kvm-signal-msi">
<h3>4.71 KVM_SIGNAL_MSI<a class="headerlink" href="#kvm-signal-msi" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SIGNAL_MSI</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86 arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_msi (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>&gt;0 on delivery, 0 if guest blocked the MSI, and -1 on error</p>
</dd>
</dl>
<p>Directly inject a MSI message. Only valid with in-kernel irqchip that handles
MSI messages.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_msi {
      __u32 address_lo;
      __u32 address_hi;
      __u32 data;
      __u32 flags;
      __u32 devid;
      __u8  pad[12];
};
</pre></div>
</div>
<dl class="simple">
<dt>flags:</dt><dd><p>KVM_MSI_VALID_DEVID: devid contains a valid value.  The per-VM
KVM_CAP_MSI_DEVID capability advertises the requirement to provide
the device ID.  If this capability is not available, userspace
should never set the KVM_MSI_VALID_DEVID flag as the ioctl might fail.</p>
</dd>
</dl>
<p>If KVM_MSI_VALID_DEVID is set, devid contains a unique device identifier
for the device that wrote the MSI message.  For PCI, this is usually a
BFD identifier in the lower 16 bits.</p>
<p>On x86, address_hi is ignored unless the KVM_X2APIC_API_USE_32BIT_IDS
feature of KVM_CAP_X2APIC_API capability is enabled.  If it is enabled,
address_hi bits 31-8 provide bits 31-8 of the destination id.  Bits 7-0 of
address_hi must be zero.</p>
</section>
<section id="kvm-create-pit2">
<h3>4.71 KVM_CREATE_PIT2<a class="headerlink" href="#kvm-create-pit2" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PIT2</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_pit_config (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Creates an in-kernel device model for the i8254 PIT. This call is only valid
after enabling in-kernel irqchip support via KVM_CREATE_IRQCHIP. The following
parameters have to be passed:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_pit_config {
      __u32 flags;
      __u32 pad[15];
};
</pre></div>
</div>
<p>Valid flags are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_PIT_SPEAKER_DUMMY     1 /* emulate speaker port stub */
</pre></div>
</div>
<p>PIT timer interrupts may use a per-VM kernel thread for injection. If it
exists, this thread will have a name of the following pattern:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kvm-pit/&lt;owner-process-pid&gt;
</pre></div>
</div>
<p>When running a guest with elevated priorities, the scheduling parameters of
this thread may have to be adjusted accordingly.</p>
<p>This IOCTL replaces the obsolete KVM_CREATE_PIT.</p>
</section>
<section id="kvm-get-pit2">
<h3>4.72 KVM_GET_PIT2<a class="headerlink" href="#kvm-get-pit2" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PIT_STATE2</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_pit_state2 (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Retrieves the state of the in-kernel PIT model. Only valid after
KVM_CREATE_PIT2. The state is returned in the following structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_pit_state2 {
      struct kvm_pit_channel_state channels[3];
      __u32 flags;
      __u32 reserved[9];
};
</pre></div>
</div>
<p>Valid flags are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* disable PIT in HPET legacy mode */
#define KVM_PIT_FLAGS_HPET_LEGACY     0x00000001
/* speaker port data bit enabled */
#define KVM_PIT_FLAGS_SPEAKER_DATA_ON 0x00000002
</pre></div>
</div>
<p>This IOCTL replaces the obsolete KVM_GET_PIT.</p>
</section>
<section id="kvm-set-pit2">
<h3>4.73 KVM_SET_PIT2<a class="headerlink" href="#kvm-set-pit2" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PIT_STATE2</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_pit_state2 (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Sets the state of the in-kernel PIT model. Only valid after KVM_CREATE_PIT2.
See KVM_GET_PIT2 for details on struct kvm_pit_state2.</p>
<p>This IOCTL replaces the obsolete KVM_SET_PIT.</p>
</section>
<section id="kvm-ppc-get-smmu-info">
<h3>4.74 KVM_PPC_GET_SMMU_INFO<a class="headerlink" href="#kvm-ppc-get-smmu-info" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_GET_SMMU_INFO</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>powerpc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>This populates and returns a structure describing the features of
the “Server” class MMU emulation supported by KVM.
This can in turn be used by userspace to generate the appropriate
device-tree properties for the guest operating system.</p>
<p>The structure contains some global information, followed by an
array of supported segment page sizes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_ppc_smmu_info {
       __u64 flags;
       __u32 slb_size;
       __u32 pad;
       struct kvm_ppc_one_seg_page_size sps[KVM_PPC_PAGE_SIZES_MAX_SZ];
};
</pre></div>
</div>
<p>The supported flags are:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>KVM_PPC_PAGE_SIZES_REAL:</dt><dd><p>When that flag is set, guest page sizes must “fit” the backing
store page sizes. When not set, any page size in the list can
be used regardless of how they are backed by userspace.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>KVM_PPC_1T_SEGMENTS</dt><dd><p>The emulated MMU supports 1T segments in addition to the
standard 256M ones.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>KVM_PPC_NO_HASH</dt><dd><p>This flag indicates that HPT guests are not supported by KVM,
thus all guests must use radix MMU mode.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The “slb_size” field indicates how many SLB entries are supported</p>
<p>The “sps” array contains 8 entries indicating the supported base
page sizes for a segment in increasing order. Each entry is defined
as follow:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_ppc_one_seg_page_size {
     __u32 page_shift;       /* Base page shift of segment (or 0) */
     __u32 slb_enc;          /* SLB encoding for BookS */
     struct kvm_ppc_one_page_size enc[KVM_PPC_PAGE_SIZES_MAX_SZ];
};
</pre></div>
</div>
<p>An entry with a “page_shift” of 0 is unused. Because the array is
organized in increasing order, a lookup can stop when encoutering
such an entry.</p>
<p>The “slb_enc” field provides the encoding to use in the SLB for the
page size. The bits are in positions such as the value can directly
be OR’ed into the “vsid” argument of the slbmte instruction.</p>
<p>The “enc” array is a list which for each of those segment base page
size provides the list of supported actual page sizes (which can be
only larger or equal to the base page size), along with the
corresponding encoding in the hash PTE. Similarly, the array is
8 entries sorted by increasing sizes and an entry with a “0” shift
is an empty entry and a terminator:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_ppc_one_page_size {
     __u32 page_shift;       /* Page shift (or 0) */
     __u32 pte_enc;          /* Encoding in the HPTE (&gt;&gt;12) */
};
</pre></div>
</div>
<p>The “pte_enc” field provides a value that can OR’ed into the hash
PTE’s RPN field (ie, it needs to be shifted left by 12 to OR it
into the hash PTE second double word).</p>
</section>
<section id="kvm-irqfd">
<h3>4.75 KVM_IRQFD<a class="headerlink" href="#kvm-irqfd" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_IRQFD</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86 s390 arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_irqfd (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Allows setting an eventfd to directly trigger a guest interrupt.
kvm_irqfd.fd specifies the file descriptor to use as the eventfd and
kvm_irqfd.gsi specifies the irqchip pin toggled by this event.  When
an event is triggered on the eventfd, an interrupt is injected into
the guest using the specified gsi pin.  The irqfd is removed using
the KVM_IRQFD_FLAG_DEASSIGN flag, specifying both kvm_irqfd.fd
and kvm_irqfd.gsi.</p>
<p>With KVM_CAP_IRQFD_RESAMPLE, KVM_IRQFD supports a de-assert and notify
mechanism allowing emulation of level-triggered, irqfd-based
interrupts.  When KVM_IRQFD_FLAG_RESAMPLE is set the user must pass an
additional eventfd in the kvm_irqfd.resamplefd field.  When operating
in resample mode, posting of an interrupt through kvm_irq.fd asserts
the specified gsi in the irqchip.  When the irqchip is resampled, such
as from an EOI, the gsi is de-asserted and the user is notified via
kvm_irqfd.resamplefd.  It is the user’s responsibility to re-queue
the interrupt if the device making use of it still requires service.
Note that closing the resamplefd is not sufficient to disable the
irqfd.  The KVM_IRQFD_FLAG_RESAMPLE is only necessary on assignment
and need not be specified with KVM_IRQFD_FLAG_DEASSIGN.</p>
<p>On arm64, gsi routing being supported, the following can happen:</p>
<ul class="simple">
<li><p>in case no routing entry is associated to this gsi, injection fails</p></li>
<li><p>in case the gsi is associated to an irqchip routing entry,
irqchip.pin + 32 corresponds to the injected SPI ID.</p></li>
<li><p>in case the gsi is associated to an MSI routing entry, the MSI
message and device ID are translated into an LPI (support restricted
to GICv3 ITS in-kernel emulation).</p></li>
</ul>
</section>
<section id="kvm-ppc-allocate-htab">
<h3>4.76 KVM_PPC_ALLOCATE_HTAB<a class="headerlink" href="#kvm-ppc-allocate-htab" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_ALLOC_HTAB</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>powerpc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>Pointer to u32 containing hash table order (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>This requests the host kernel to allocate an MMU hash table for a
guest using the PAPR paravirtualization interface.  This only does
anything if the kernel is configured to use the Book 3S HV style of
virtualization.  Otherwise the capability doesn’t exist and the ioctl
returns an ENOTTY error.  The rest of this description assumes Book 3S
HV.</p>
<p>There must be no vcpus running when this ioctl is called; if there
are, it will do nothing and return an EBUSY error.</p>
<p>The parameter is a pointer to a 32-bit unsigned integer variable
containing the order (log base 2) of the desired size of the hash
table, which must be between 18 and 46.  On successful return from the
ioctl, the value will not be changed by the kernel.</p>
<p>If no hash table has been allocated when any vcpu is asked to run
(with the KVM_RUN ioctl), the host kernel will allocate a
default-sized hash table (16 MB).</p>
<p>If this ioctl is called when a hash table has already been allocated,
with a different order from the existing hash table, the existing hash
table will be freed and a new one allocated.  If this is ioctl is
called when a hash table has already been allocated of the same order
as specified, the kernel will clear out the existing hash table (zero
all HPTEs).  In either case, if the guest is using the virtualized
real-mode area (VRMA) facility, the kernel will re-create the VMRA
HPTEs on the next KVM_RUN of any vcpu.</p>
</section>
<section id="kvm-s390-interrupt">
<h3>4.77 KVM_S390_INTERRUPT<a class="headerlink" href="#kvm-s390-interrupt" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl, vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_interrupt (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Allows to inject an interrupt to the guest. Interrupts can be floating
(vm ioctl) or per cpu (vcpu ioctl), depending on the interrupt type.</p>
<p>Interrupt parameters are passed via kvm_s390_interrupt:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_interrupt {
      __u32 type;
      __u32 parm;
      __u64 parm64;
};
</pre></div>
</div>
<p>type can be one of the following:</p>
<dl class="simple">
<dt>KVM_S390_SIGP_STOP (vcpu)</dt><dd><ul class="simple">
<li><p>sigp stop; optional flags in parm</p></li>
</ul>
</dd>
<dt>KVM_S390_PROGRAM_INT (vcpu)</dt><dd><ul class="simple">
<li><p>program check; code in parm</p></li>
</ul>
</dd>
<dt>KVM_S390_SIGP_SET_PREFIX (vcpu)</dt><dd><ul class="simple">
<li><p>sigp set prefix; prefix address in parm</p></li>
</ul>
</dd>
<dt>KVM_S390_RESTART (vcpu)</dt><dd><ul class="simple">
<li><p>restart</p></li>
</ul>
</dd>
<dt>KVM_S390_INT_CLOCK_COMP (vcpu)</dt><dd><ul class="simple">
<li><p>clock comparator interrupt</p></li>
</ul>
</dd>
<dt>KVM_S390_INT_CPU_TIMER (vcpu)</dt><dd><ul class="simple">
<li><p>CPU timer interrupt</p></li>
</ul>
</dd>
<dt>KVM_S390_INT_VIRTIO (vm)</dt><dd><ul class="simple">
<li><p>virtio external interrupt; external interrupt
parameters in parm and parm64</p></li>
</ul>
</dd>
<dt>KVM_S390_INT_SERVICE (vm)</dt><dd><ul class="simple">
<li><p>sclp external interrupt; sclp parameter in parm</p></li>
</ul>
</dd>
<dt>KVM_S390_INT_EMERGENCY (vcpu)</dt><dd><ul class="simple">
<li><p>sigp emergency; source cpu in parm</p></li>
</ul>
</dd>
<dt>KVM_S390_INT_EXTERNAL_CALL (vcpu)</dt><dd><ul class="simple">
<li><p>sigp external call; source cpu in parm</p></li>
</ul>
</dd>
<dt>KVM_S390_INT_IO(ai,cssid,ssid,schid) (vm)</dt><dd><ul class="simple">
<li><p>compound value to indicate an
I/O interrupt (ai - adapter interrupt; cssid,ssid,schid - subchannel);
I/O interruption parameters in parm (subchannel) and parm64 (intparm,
interruption subclass)</p></li>
</ul>
</dd>
<dt>KVM_S390_MCHK (vm, vcpu)</dt><dd><ul class="simple">
<li><p>machine check interrupt; cr 14 bits in parm, machine check interrupt
code in parm64 (note that machine checks needing further payload are not
supported by this ioctl)</p></li>
</ul>
</dd>
</dl>
<p>This is an asynchronous vcpu ioctl and can be invoked from any thread.</p>
</section>
<section id="kvm-ppc-get-htab-fd">
<h3>4.78 KVM_PPC_GET_HTAB_FD<a class="headerlink" href="#kvm-ppc-get-htab-fd" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_HTAB_FD</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>powerpc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>Pointer to struct kvm_get_htab_fd (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>file descriptor number (&gt;= 0) on success, -1 on error</p>
</dd>
</dl>
<p>This returns a file descriptor that can be used either to read out the
entries in the guest’s hashed page table (HPT), or to write entries to
initialize the HPT.  The returned fd can only be written to if the
KVM_GET_HTAB_WRITE bit is set in the flags field of the argument, and
can only be read if that bit is clear.  The argument struct looks like
this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* For KVM_PPC_GET_HTAB_FD */
struct kvm_get_htab_fd {
      __u64   flags;
      __u64   start_index;
      __u64   reserved[2];
};

/* Values for kvm_get_htab_fd.flags */
#define KVM_GET_HTAB_BOLTED_ONLY      ((__u64)0x1)
#define KVM_GET_HTAB_WRITE            ((__u64)0x2)
</pre></div>
</div>
<p>The ‘start_index’ field gives the index in the HPT of the entry at
which to start reading.  It is ignored when writing.</p>
<p>Reads on the fd will initially supply information about all
“interesting” HPT entries.  Interesting entries are those with the
bolted bit set, if the KVM_GET_HTAB_BOLTED_ONLY bit is set, otherwise
all entries.  When the end of the HPT is reached, the read() will
return.  If read() is called again on the fd, it will start again from
the beginning of the HPT, but will only return HPT entries that have
changed since they were last read.</p>
<p>Data read or written is structured as a header (8 bytes) followed by a
series of valid HPT entries (16 bytes) each.  The header indicates how
many valid HPT entries there are and how many invalid entries follow
the valid entries.  The invalid entries are not represented explicitly
in the stream.  The header format is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_get_htab_header {
      __u32   index;
      __u16   n_valid;
      __u16   n_invalid;
};
</pre></div>
</div>
<p>Writes to the fd create HPT entries starting at the index given in the
header; first ‘n_valid’ valid entries with contents from the data
written, then ‘n_invalid’ invalid entries, invalidating any previously
valid entries found.</p>
</section>
<section id="kvm-create-device">
<h3>4.79 KVM_CREATE_DEVICE<a class="headerlink" href="#kvm-create-device" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_DEVICE_CTRL</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_create_device (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ENODEV</p></td>
<td><p>The device type is unknown or unsupported</p></td>
</tr>
<tr class="row-even"><td><p>EEXIST</p></td>
<td><p>Device already created, and this type of device may not
be instantiated multiple times</p></td>
</tr>
</tbody>
</table>
<p>Other error conditions may be defined by individual device types or
have their standard meanings.</p>
</div></blockquote>
<p>Creates an emulated device in the kernel.  The file descriptor returned
in fd can be used with KVM_SET/GET/HAS_DEVICE_ATTR.</p>
<p>If the KVM_CREATE_DEVICE_TEST flag is set, only test whether the
device type is supported (not necessarily whether it can be created
in the current vm).</p>
<p>Individual devices should not define flags.  Attributes should be used
for specifying any behavior that is not implied by the device type
number.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_create_device {
      __u32   type;   /* in: KVM_DEV_TYPE_xxx */
      __u32   fd;     /* out: device handle */
      __u32   flags;  /* in: KVM_CREATE_DEVICE_xxx */
};
</pre></div>
</div>
</section>
<section id="kvm-set-device-attr-kvm-get-device-attr">
<h3>4.80 KVM_SET_DEVICE_ATTR/KVM_GET_DEVICE_ATTR<a class="headerlink" href="#kvm-set-device-attr-kvm-get-device-attr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_DEVICE_CTRL, KVM_CAP_VM_ATTRIBUTES for vm device,
KVM_CAP_VCPU_ATTRIBUTES for vcpu device
KVM_CAP_SYS_ATTRIBUTES for system (/dev/kvm) device (no set)</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, arm64, s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>device ioctl, vm ioctl, vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_device_attr</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 92%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ENXIO</p></td>
<td><p>The group or attribute is unknown/unsupported for this device
or hardware support is missing.</p></td>
</tr>
<tr class="row-even"><td><p>EPERM</p></td>
<td><p>The attribute cannot (currently) be accessed this way
(e.g. read-only attribute, or attribute that only makes
sense when the device is in a different state)</p></td>
</tr>
</tbody>
</table>
<p>Other error conditions may be defined by individual device types.</p>
</div></blockquote>
<p>Gets/sets a specified piece of device configuration and/or state.  The
semantics are device-specific.  See individual device documentation in
the “devices” directory.  As with ONE_REG, the size of the data
transferred is defined by the particular attribute.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_device_attr {
      __u32   flags;          /* no flags currently defined */
      __u32   group;          /* device-defined */
      __u64   attr;           /* group-defined */
      __u64   addr;           /* userspace address of attr data */
};
</pre></div>
</div>
</section>
<section id="kvm-has-device-attr">
<h3>4.81 KVM_HAS_DEVICE_ATTR<a class="headerlink" href="#kvm-has-device-attr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_DEVICE_CTRL, KVM_CAP_VM_ATTRIBUTES for vm device,
KVM_CAP_VCPU_ATTRIBUTES for vcpu device
KVM_CAP_SYS_ATTRIBUTES for system (/dev/kvm) device</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>device ioctl, vm ioctl, vcpu ioctl</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>struct kvm_device_attr</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 92%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ENXIO</p></td>
<td><p>The group or attribute is unknown/unsupported for this device
or hardware support is missing.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Tests whether a device supports a particular attribute.  A successful
return indicates the attribute is implemented.  It does not necessarily
indicate that the attribute can be read or written in the device’s
current state.  “addr” is ignored.</p>
</section>
<section id="kvm-arm-vcpu-init">
<h3>4.82 KVM_ARM_VCPU_INIT<a class="headerlink" href="#kvm-arm-vcpu-init" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_vcpu_init (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 92%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>EINVAL</p></td>
<td><p>the target is unknown, or the combination of features is invalid.</p></td>
</tr>
<tr class="row-even"><td><p>ENOENT</p></td>
<td><p>a features bit specified is unknown.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>This tells KVM what type of CPU to present to the guest, and what
optional features it should have.  This will cause a reset of the cpu
registers to their initial values.  If this is not called, KVM_RUN will
return ENOEXEC for that vcpu.</p>
<dl class="simple">
<dt>The initial values are defined as:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>Processor state:</dt><dd><ul>
<li><p>AArch64: EL1h, D, A, I and F bits set. All other bits
are cleared.</p></li>
<li><p>AArch32: SVC, A, I and F bits set. All other bits are
cleared.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>General Purpose registers, including PC and SP: set to 0</p></li>
<li><p>FPSIMD/NEON registers: set to 0</p></li>
<li><p>SVE registers: set to 0</p></li>
<li><p>System registers: Reset to their architecturally defined
values as for a warm reset to EL1 (resp. SVC)</p></li>
</ul>
</dd>
</dl>
<p>Note that because some registers reflect machine topology, all vcpus
should be created before this ioctl is invoked.</p>
<p>Userspace can call this function multiple times for a given vcpu, including
after the vcpu has been run. This will reset the vcpu to its initial
state. All calls to this function after the initial call must use the same
target and same set of feature flags, otherwise EINVAL will be returned.</p>
<p>Possible features:</p>
<blockquote>
<div><ul>
<li><p>KVM_ARM_VCPU_POWER_OFF: Starts the CPU in a power-off state.
Depends on KVM_CAP_ARM_PSCI.  If not set, the CPU will be powered on
and execute guest code when KVM_RUN is called.</p></li>
<li><p>KVM_ARM_VCPU_EL1_32BIT: Starts the CPU in a 32bit mode.
Depends on KVM_CAP_ARM_EL1_32BIT (arm64 only).</p></li>
<li><p>KVM_ARM_VCPU_PSCI_0_2: Emulate PSCI v0.2 (or a future revision
backward compatible with v0.2) for the CPU.
Depends on KVM_CAP_ARM_PSCI_0_2.</p></li>
<li><p>KVM_ARM_VCPU_PMU_V3: Emulate PMUv3 for the CPU.
Depends on KVM_CAP_ARM_PMU_V3.</p></li>
<li><p>KVM_ARM_VCPU_PTRAUTH_ADDRESS: Enables Address Pointer authentication
for arm64 only.
Depends on KVM_CAP_ARM_PTRAUTH_ADDRESS.
If KVM_CAP_ARM_PTRAUTH_ADDRESS and KVM_CAP_ARM_PTRAUTH_GENERIC are
both present, then both KVM_ARM_VCPU_PTRAUTH_ADDRESS and
KVM_ARM_VCPU_PTRAUTH_GENERIC must be requested or neither must be
requested.</p></li>
<li><p>KVM_ARM_VCPU_PTRAUTH_GENERIC: Enables Generic Pointer authentication
for arm64 only.
Depends on KVM_CAP_ARM_PTRAUTH_GENERIC.
If KVM_CAP_ARM_PTRAUTH_ADDRESS and KVM_CAP_ARM_PTRAUTH_GENERIC are
both present, then both KVM_ARM_VCPU_PTRAUTH_ADDRESS and
KVM_ARM_VCPU_PTRAUTH_GENERIC must be requested or neither must be
requested.</p></li>
<li><p>KVM_ARM_VCPU_SVE: Enables SVE for the CPU (arm64 only).
Depends on KVM_CAP_ARM_SVE.
Requires KVM_ARM_VCPU_FINALIZE(KVM_ARM_VCPU_SVE):</p>
<blockquote>
<div><ul>
<li><p>After KVM_ARM_VCPU_INIT:</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_REG_ARM64_SVE_VLS may be read using KVM_GET_ONE_REG: the
initial value of this pseudo-register indicates the best set of
vector lengths possible for a vcpu on this host.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Before KVM_ARM_VCPU_FINALIZE(KVM_ARM_VCPU_SVE):</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_RUN and KVM_GET_REG_LIST are not available;</p></li>
<li><p>KVM_GET_ONE_REG and KVM_SET_ONE_REG cannot be used to access
the scalable archietctural SVE registers
KVM_REG_ARM64_SVE_ZREG(), KVM_REG_ARM64_SVE_PREG() or
KVM_REG_ARM64_SVE_FFR;</p></li>
<li><p>KVM_REG_ARM64_SVE_VLS may optionally be written using
KVM_SET_ONE_REG, to modify the set of vector lengths available
for the vcpu.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>After KVM_ARM_VCPU_FINALIZE(KVM_ARM_VCPU_SVE):</p>
<blockquote>
<div><ul class="simple">
<li><p>the KVM_REG_ARM64_SVE_VLS pseudo-register is immutable, and can
no longer be written using KVM_SET_ONE_REG.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</section>
<section id="kvm-arm-preferred-target">
<h3>4.83 KVM_ARM_PREFERRED_TARGET<a class="headerlink" href="#kvm-arm-preferred-target" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_vcpu_init (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 88%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ENODEV</p></td>
<td><p>no preferred target available for the host</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>This queries KVM for preferred CPU target type which can be emulated
by KVM on underlying host.</p>
<p>The ioctl returns struct kvm_vcpu_init instance containing information
about preferred CPU target type and recommended features for it.  The
kvm_vcpu_init-&gt;features bitmap returned will have feature bits set if
the preferred target recommends setting these features, but this is
not mandatory.</p>
<p>The information returned by this ioctl can be used to prepare an instance
of struct kvm_vcpu_init for KVM_ARM_VCPU_INIT ioctl which will result in
VCPU matching underlying host.</p>
</section>
<section id="kvm-get-reg-list">
<h3>4.84 KVM_GET_REG_LIST<a class="headerlink" href="#kvm-get-reg-list" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>arm64, mips</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_reg_list (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 7%" />
<col style="width: 93%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>E2BIG</p></td>
<td><p>the reg index list is too big to fit in the array specified by
the user (the number required will be written into n).</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_reg_list {
      __u64 n; /* number of registers in reg[] */
      __u64 reg[0];
};
</pre></div>
</div>
<p>This ioctl returns the guest registers that are supported for the
KVM_GET_ONE_REG/KVM_SET_ONE_REG calls.</p>
</section>
<section id="kvm-arm-set-device-addr-deprecated">
<h3>4.85 KVM_ARM_SET_DEVICE_ADDR (deprecated)<a class="headerlink" href="#kvm-arm-set-device-addr-deprecated" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_ARM_SET_DEVICE_ADDR</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_arm_device_address (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 88%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ENODEV</p></td>
<td><p>The device id is unknown</p></td>
</tr>
<tr class="row-even"><td><p>ENXIO</p></td>
<td><p>Device not supported on current system</p></td>
</tr>
<tr class="row-odd"><td><p>EEXIST</p></td>
<td><p>Address already set</p></td>
</tr>
<tr class="row-even"><td><p>E2BIG</p></td>
<td><p>Address outside guest physical address space</p></td>
</tr>
<tr class="row-odd"><td><p>EBUSY</p></td>
<td><p>Address overlaps with other device range</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_arm_device_addr {
      __u64 id;
      __u64 addr;
};
</pre></div>
</div>
<p>Specify a device address in the guest’s physical address space where guests
can access emulated or directly exposed devices, which the host kernel needs
to know about. The id field is an architecture specific identifier for a
specific device.</p>
<p>arm64 divides the id field into two parts, a device id and an
address type id specific to the individual device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bits:  | 63        ...       32 | 31    ...    16 | 15    ...    0 |
field: |        0x00000000      |     device id   |  addr type id  |
</pre></div>
</div>
<p>arm64 currently only require this when using the in-kernel GIC
support for the hardware VGIC features, using KVM_ARM_DEVICE_VGIC_V2
as the device id.  When setting the base address for the guest’s
mapping of the VGIC virtual CPU and distributor interface, the ioctl
must be called after calling KVM_CREATE_IRQCHIP, but before calling
KVM_RUN on any of the VCPUs.  Calling this ioctl twice for any of the
base addresses will return -EEXIST.</p>
<p>Note, this IOCTL is deprecated and the more flexible SET/GET_DEVICE_ATTR API
should be used instead.</p>
</section>
<section id="kvm-ppc-rtas-define-token">
<h3>4.86 KVM_PPC_RTAS_DEFINE_TOKEN<a class="headerlink" href="#kvm-ppc-rtas-define-token" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_RTAS</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_rtas_token_args</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Defines a token value for a RTAS (Run Time Abstraction Services)
service in order to allow it to be handled in the kernel.  The
argument struct gives the name of the service, which must be the name
of a service that has a kernel-side implementation.  If the token
value is non-zero, it will be associated with that service, and
subsequent RTAS calls by the guest specifying that token will be
handled by the kernel.  If the token value is 0, then any token
associated with the service will be forgotten, and subsequent RTAS
calls by the guest for that service will be passed to userspace to be
handled.</p>
</section>
<section id="kvm-set-guest-debug">
<h3>4.87 KVM_SET_GUEST_DEBUG<a class="headerlink" href="#kvm-set-guest-debug" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SET_GUEST_DEBUG</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, s390, ppc, arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_guest_debug (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_guest_debug {
     __u32 control;
     __u32 pad;
     struct kvm_guest_debug_arch arch;
};
</pre></div>
</div>
<p>Set up the processor specific debug registers and configure vcpu for
handling guest debug events. There are two parts to the structure, the
first a control bitfield indicates the type of debug events to handle
when running. Common control bits are:</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_GUESTDBG_ENABLE:        guest debugging is enabled</p></li>
<li><p>KVM_GUESTDBG_SINGLESTEP:    the next run should single-step</p></li>
</ul>
</div></blockquote>
<p>The top 16 bits of the control field are architecture specific control
flags which can include the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_GUESTDBG_USE_SW_BP:     using software breakpoints [x86, arm64]</p></li>
<li><p>KVM_GUESTDBG_USE_HW_BP:     using hardware breakpoints [x86, s390]</p></li>
<li><p>KVM_GUESTDBG_USE_HW:        using hardware debug events [arm64]</p></li>
<li><p>KVM_GUESTDBG_INJECT_DB:     inject DB type exception [x86]</p></li>
<li><p>KVM_GUESTDBG_INJECT_BP:     inject BP type exception [x86]</p></li>
<li><p>KVM_GUESTDBG_EXIT_PENDING:  trigger an immediate guest exit [s390]</p></li>
<li><p>KVM_GUESTDBG_BLOCKIRQ:      avoid injecting interrupts/NMI/SMI [x86]</p></li>
</ul>
</div></blockquote>
<p>For example KVM_GUESTDBG_USE_SW_BP indicates that software breakpoints
are enabled in memory so we need to ensure breakpoint exceptions are
correctly trapped and the KVM run loop exits at the breakpoint and not
running off into the normal guest vector. For KVM_GUESTDBG_USE_HW_BP
we need to ensure the guest vCPUs architecture specific registers are
updated to the correct (supplied) values.</p>
<p>The second part of the structure is architecture specific and
typically contains a set of debug registers.</p>
<p>For arm64 the number of debug registers is implementation defined and
can be determined by querying the KVM_CAP_GUEST_DEBUG_HW_BPS and
KVM_CAP_GUEST_DEBUG_HW_WPS capabilities which return a positive number
indicating the number of supported registers.</p>
<p>For ppc, the KVM_CAP_PPC_GUEST_DEBUG_SSTEP capability indicates whether
the single-step debug event (KVM_GUESTDBG_SINGLESTEP) is supported.</p>
<p>Also when supported, KVM_CAP_SET_GUEST_DEBUG2 capability indicates the
supported KVM_GUESTDBG_* bits in the control field.</p>
<p>When debug events exit the main run loop with the reason
KVM_EXIT_DEBUG with the kvm_debug_exit_arch part of the kvm_run
structure containing architecture specific debug information.</p>
</section>
<section id="kvm-get-emulated-cpuid">
<h3>4.88 KVM_GET_EMULATED_CPUID<a class="headerlink" href="#kvm-get-emulated-cpuid" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_EXT_EMUL_CPUID</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_cpuid2 (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_cpuid2 {
      __u32 nent;
      __u32 flags;
      struct kvm_cpuid_entry2 entries[0];
};
</pre></div>
</div>
<p>The member ‘flags’ is used for passing flags from userspace.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX               BIT(0)
#define KVM_CPUID_FLAG_STATEFUL_FUNC          BIT(1) /* deprecated */
#define KVM_CPUID_FLAG_STATE_READ_NEXT                BIT(2) /* deprecated */

struct kvm_cpuid_entry2 {
      __u32 function;
      __u32 index;
      __u32 flags;
      __u32 eax;
      __u32 ebx;
      __u32 ecx;
      __u32 edx;
      __u32 padding[3];
};
</pre></div>
</div>
<p>This ioctl returns x86 cpuid features which are emulated by
kvm.Userspace can use the information returned by this ioctl to query
which features are emulated by kvm instead of being present natively.</p>
<p>Userspace invokes KVM_GET_EMULATED_CPUID by passing a kvm_cpuid2
structure with the ‘nent’ field indicating the number of entries in
the variable-size array ‘entries’. If the number of entries is too low
to describe the cpu capabilities, an error (E2BIG) is returned. If the
number is too high, the ‘nent’ field is adjusted and an error (ENOMEM)
is returned. If the number is just right, the ‘nent’ field is adjusted
to the number of valid entries in the ‘entries’ array, which is then
filled.</p>
<p>The entries returned are the set CPUID bits of the respective features
which kvm emulates, as returned by the CPUID instruction, with unknown
or unsupported feature bits cleared.</p>
<p>Features like x2apic, for example, may not be present in the host cpu
but are exposed by kvm in KVM_GET_SUPPORTED_CPUID because they can be
emulated efficiently and thus not included here.</p>
<p>The fields in each entry are defined as follows:</p>
<blockquote>
<div><dl>
<dt>function:</dt><dd><p>the eax value used to obtain the entry</p>
</dd>
<dt>index:</dt><dd><p>the ecx value used to obtain the entry (for entries that are
affected by ecx)</p>
</dd>
<dt>flags:</dt><dd><blockquote>
<div><p>an OR of zero or more of the following:</p>
<blockquote>
<div><dl class="simple">
<dt>KVM_CPUID_FLAG_SIGNIFCANT_INDEX:</dt><dd><p>if the index field is valid</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>eax, ebx, ecx, edx:</p>
<blockquote>
<div><p>the values returned by the cpuid instruction for
this function/index combination</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</section>
<section id="kvm-s390-mem-op">
<h3>4.89 KVM_S390_MEM_OP<a class="headerlink" href="#kvm-s390-mem-op" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_MEM_OP, KVM_CAP_S390_PROTECTED, KVM_CAP_S390_MEM_OP_EXTENSION</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl, vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_mem_op (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>= 0 on success,
&lt; 0 on generic error (e.g. -EFAULT or -ENOMEM),
&gt; 0 if an exception occurred while walking the page tables</p>
</dd>
</dl>
<p>Read or write data from/to the VM’s memory.
The KVM_CAP_S390_MEM_OP_EXTENSION capability specifies what functionality is
supported.</p>
<p>Parameters are specified via the following structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_mem_op {
      __u64 gaddr;            /* the guest address */
      __u64 flags;            /* flags */
      __u32 size;             /* amount of bytes */
      __u32 op;               /* type of operation */
      __u64 buf;              /* buffer in userspace */
      union {
              struct {
                      __u8 ar;        /* the access register number */
                      __u8 key;       /* access key, ignored if flag unset */
              };
              __u32 sida_offset; /* offset into the sida */
              __u8 reserved[32]; /* ignored */
      };
};
</pre></div>
</div>
<p>The start address of the memory region has to be specified in the “gaddr”
field, and the length of the region in the “size” field (which must not
be 0). The maximum value for “size” can be obtained by checking the
KVM_CAP_S390_MEM_OP capability. “buf” is the buffer supplied by the
userspace application where the read data should be written to for
a read access, or where the data that should be written is stored for
a write access.  The “reserved” field is meant for future extensions.
Reserved and unused values are ignored. Future extension that add members must
introduce new flags.</p>
<p>The type of operation is specified in the “op” field. Flags modifying
their behavior can be set in the “flags” field. Undefined flag bits must
be set to 0.</p>
<dl class="simple">
<dt>Possible operations are:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_S390_MEMOP_LOGICAL_READ</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_S390_MEMOP_LOGICAL_WRITE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_S390_MEMOP_ABSOLUTE_READ</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_S390_MEMOP_ABSOLUTE_WRITE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_S390_MEMOP_SIDA_READ</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_S390_MEMOP_SIDA_WRITE</span></code></p></li>
</ul>
</dd>
</dl>
<section id="logical-read-write">
<h4>Logical read/write:<a class="headerlink" href="#logical-read-write" title="Permalink to this headline">¶</a></h4>
<p>Access logical memory, i.e. translate the given guest address to an absolute
address given the state of the VCPU and use the absolute address as target of
the access. “ar” designates the access register number to be used; the valid
range is 0..15.
Logical accesses are permitted for the VCPU ioctl only.
Logical accesses are permitted for non-protected guests only.</p>
<dl class="simple">
<dt>Supported flags:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_S390_MEMOP_F_CHECK_ONLY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_S390_MEMOP_F_INJECT_EXCEPTION</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_S390_MEMOP_F_SKEY_PROTECTION</span></code></p></li>
</ul>
</dd>
</dl>
<p>The KVM_S390_MEMOP_F_CHECK_ONLY flag can be set to check whether the
corresponding memory access would cause an access exception; however,
no actual access to the data in memory at the destination is performed.
In this case, “buf” is unused and can be NULL.</p>
<p>In case an access exception occurred during the access (or would occur
in case of KVM_S390_MEMOP_F_CHECK_ONLY), the ioctl returns a positive
error number indicating the type of exception. This exception is also
raised directly at the corresponding VCPU if the flag
KVM_S390_MEMOP_F_INJECT_EXCEPTION is set.
On protection exceptions, unless specified otherwise, the injected
translation-exception identifier (TEID) indicates suppression.</p>
<p>If the KVM_S390_MEMOP_F_SKEY_PROTECTION flag is set, storage key
protection is also in effect and may cause exceptions if accesses are
prohibited given the access key designated by “key”; the valid range is 0..15.
KVM_S390_MEMOP_F_SKEY_PROTECTION is available if KVM_CAP_S390_MEM_OP_EXTENSION
is &gt; 0.
Since the accessed memory may span multiple pages and those pages might have
different storage keys, it is possible that a protection exception occurs
after memory has been modified. In this case, if the exception is injected,
the TEID does not indicate suppression.</p>
</section>
<section id="absolute-read-write">
<h4>Absolute read/write:<a class="headerlink" href="#absolute-read-write" title="Permalink to this headline">¶</a></h4>
<p>Access absolute memory. This operation is intended to be used with the
KVM_S390_MEMOP_F_SKEY_PROTECTION flag, to allow accessing memory and performing
the checks required for storage key protection as one operation (as opposed to
user space getting the storage keys, performing the checks, and accessing
memory thereafter, which could lead to a delay between check and access).
Absolute accesses are permitted for the VM ioctl if KVM_CAP_S390_MEM_OP_EXTENSION
is &gt; 0.
Currently absolute accesses are not permitted for VCPU ioctls.
Absolute accesses are permitted for non-protected guests only.</p>
<dl class="simple">
<dt>Supported flags:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_S390_MEMOP_F_CHECK_ONLY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_S390_MEMOP_F_SKEY_PROTECTION</span></code></p></li>
</ul>
</dd>
</dl>
<p>The semantics of the flags are as for logical accesses.</p>
</section>
<section id="sida-read-write">
<h4>SIDA read/write:<a class="headerlink" href="#sida-read-write" title="Permalink to this headline">¶</a></h4>
<p>Access the secure instruction data area which contains memory operands necessary
for instruction emulation for protected guests.
SIDA accesses are available if the KVM_CAP_S390_PROTECTED capability is available.
SIDA accesses are permitted for the VCPU ioctl only.
SIDA accesses are permitted for protected guests only.</p>
<p>No flags are supported.</p>
</section>
</section>
<section id="kvm-s390-get-skeys">
<h3>4.90 KVM_S390_GET_SKEYS<a class="headerlink" href="#kvm-s390-get-skeys" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_SKEYS</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_skeys</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, KVM_S390_GET_SKEYS_NONE if guest is not using storage
keys, negative value on error</p>
</dd>
</dl>
<p>This ioctl is used to get guest storage key values on the s390
architecture. The ioctl takes parameters via the kvm_s390_skeys struct:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_skeys {
      __u64 start_gfn;
      __u64 count;
      __u64 skeydata_addr;
      __u32 flags;
      __u32 reserved[9];
};
</pre></div>
</div>
<p>The start_gfn field is the number of the first guest frame whose storage keys
you want to get.</p>
<p>The count field is the number of consecutive frames (starting from start_gfn)
whose storage keys to get. The count field must be at least 1 and the maximum
allowed value is defined as KVM_S390_SKEYS_MAX. Values outside this range
will cause the ioctl to return -EINVAL.</p>
<p>The skeydata_addr field is the address to a buffer large enough to hold count
bytes. This buffer will be filled with storage key data by the ioctl.</p>
</section>
<section id="kvm-s390-set-skeys">
<h3>4.91 KVM_S390_SET_SKEYS<a class="headerlink" href="#kvm-s390-set-skeys" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_SKEYS</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_skeys</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, negative value on error</p>
</dd>
</dl>
<p>This ioctl is used to set guest storage key values on the s390
architecture. The ioctl takes parameters via the kvm_s390_skeys struct.
See section on KVM_S390_GET_SKEYS for struct definition.</p>
<p>The start_gfn field is the number of the first guest frame whose storage keys
you want to set.</p>
<p>The count field is the number of consecutive frames (starting from start_gfn)
whose storage keys to get. The count field must be at least 1 and the maximum
allowed value is defined as KVM_S390_SKEYS_MAX. Values outside this range
will cause the ioctl to return -EINVAL.</p>
<p>The skeydata_addr field is the address to a buffer containing count bytes of
storage keys. Each byte in the buffer will be set as the storage key for a
single frame starting at start_gfn for count frames.</p>
<p>Note: If any architecturally invalid key value is found in the given data then
the ioctl will return -EINVAL.</p>
</section>
<section id="kvm-s390-irq">
<h3>4.92 KVM_S390_IRQ<a class="headerlink" href="#kvm-s390-irq" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_INJECT_IRQ</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_irq (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 92%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>EINVAL</p></td>
<td><p>interrupt type is invalid
type is KVM_S390_SIGP_STOP and flag parameter is invalid value,
type is KVM_S390_INT_EXTERNAL_CALL and code is bigger
than the maximum of VCPUs</p></td>
</tr>
<tr class="row-even"><td><p>EBUSY</p></td>
<td><p>type is KVM_S390_SIGP_SET_PREFIX and vcpu is not stopped,
type is KVM_S390_SIGP_STOP and a stop irq is already pending,
type is KVM_S390_INT_EXTERNAL_CALL and an external call interrupt
is already pending</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Allows to inject an interrupt to the guest.</p>
<p>Using struct kvm_s390_irq as a parameter allows
to inject additional payload which is not
possible via KVM_S390_INTERRUPT.</p>
<p>Interrupt parameters are passed via kvm_s390_irq:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_irq {
      __u64 type;
      union {
              struct kvm_s390_io_info io;
              struct kvm_s390_ext_info ext;
              struct kvm_s390_pgm_info pgm;
              struct kvm_s390_emerg_info emerg;
              struct kvm_s390_extcall_info extcall;
              struct kvm_s390_prefix_info prefix;
              struct kvm_s390_stop_info stop;
              struct kvm_s390_mchk_info mchk;
              char reserved[64];
      } u;
};
</pre></div>
</div>
<p>type can be one of the following:</p>
<ul class="simple">
<li><p>KVM_S390_SIGP_STOP - sigp stop; parameter in .stop</p></li>
<li><p>KVM_S390_PROGRAM_INT - program check; parameters in .pgm</p></li>
<li><p>KVM_S390_SIGP_SET_PREFIX - sigp set prefix; parameters in .prefix</p></li>
<li><p>KVM_S390_RESTART - restart; no parameters</p></li>
<li><p>KVM_S390_INT_CLOCK_COMP - clock comparator interrupt; no parameters</p></li>
<li><p>KVM_S390_INT_CPU_TIMER - CPU timer interrupt; no parameters</p></li>
<li><p>KVM_S390_INT_EMERGENCY - sigp emergency; parameters in .emerg</p></li>
<li><p>KVM_S390_INT_EXTERNAL_CALL - sigp external call; parameters in .extcall</p></li>
<li><p>KVM_S390_MCHK - machine check interrupt; parameters in .mchk</p></li>
</ul>
<p>This is an asynchronous vcpu ioctl and can be invoked from any thread.</p>
</section>
<section id="kvm-s390-get-irq-state">
<h3>4.94 KVM_S390_GET_IRQ_STATE<a class="headerlink" href="#kvm-s390-get-irq-state" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_IRQ_STATE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_irq_state (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>&gt;= number of bytes copied into buffer,
-EINVAL if buffer size is 0,
-ENOBUFS if buffer size is too small to fit all pending interrupts,
-EFAULT if the buffer address was invalid</p>
</dd>
</dl>
<p>This ioctl allows userspace to retrieve the complete state of all currently
pending interrupts in a single buffer. Use cases include migration
and introspection. The parameter structure contains the address of a
userspace buffer and its length:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_irq_state {
      __u64 buf;
      __u32 flags;        /* will stay unused for compatibility reasons */
      __u32 len;
      __u32 reserved[4];  /* will stay unused for compatibility reasons */
};
</pre></div>
</div>
<p>Userspace passes in the above struct and for each pending interrupt a
struct kvm_s390_irq is copied to the provided buffer.</p>
<p>The structure contains a flags and a reserved field for future extensions. As
the kernel never checked for flags == 0 and QEMU never pre-zeroed flags and
reserved, these fields can not be used in the future without breaking
compatibility.</p>
<p>If -ENOBUFS is returned the buffer provided was too small and userspace
may retry with a bigger buffer.</p>
</section>
<section id="kvm-s390-set-irq-state">
<h3>4.95 KVM_S390_SET_IRQ_STATE<a class="headerlink" href="#kvm-s390-set-irq-state" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_IRQ_STATE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_irq_state (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success,
-EFAULT if the buffer address was invalid,
-EINVAL for an invalid buffer length (see below),
-EBUSY if there were already interrupts pending,
errors occurring when actually injecting the
interrupt. See KVM_S390_IRQ.</p>
</dd>
</dl>
<p>This ioctl allows userspace to set the complete state of all cpu-local
interrupts currently pending for the vcpu. It is intended for restoring
interrupt state after a migration. The input parameter is a userspace buffer
containing a struct kvm_s390_irq_state:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_irq_state {
      __u64 buf;
      __u32 flags;        /* will stay unused for compatibility reasons */
      __u32 len;
      __u32 reserved[4];  /* will stay unused for compatibility reasons */
};
</pre></div>
</div>
<p>The restrictions for flags and reserved apply as well.
(see KVM_S390_GET_IRQ_STATE)</p>
<p>The userspace memory referenced by buf contains a struct kvm_s390_irq
for each interrupt to be injected into the guest.
If one of the interrupts could not be injected for some reason the
ioctl aborts.</p>
<p>len must be a multiple of sizeof(struct kvm_s390_irq). It must be &gt; 0
and it must not exceed (max_vcpus + 32) * sizeof(struct kvm_s390_irq),
which is the maximum number of possibly pending cpu-local interrupts.</p>
</section>
<section id="kvm-smi">
<h3>4.96 KVM_SMI<a class="headerlink" href="#kvm-smi" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_X86_SMM</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Queues an SMI on the thread’s vcpu.</p>
</section>
<section id="kvm-x86-set-msr-filter">
<h3>4.97 KVM_X86_SET_MSR_FILTER<a class="headerlink" href="#kvm-x86-set-msr-filter" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_X86_MSR_FILTER</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_msr_filter</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, &lt; 0 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_msr_filter_range {
#define KVM_MSR_FILTER_READ  (1 &lt;&lt; 0)
#define KVM_MSR_FILTER_WRITE (1 &lt;&lt; 1)
      __u32 flags;
      __u32 nmsrs; /* number of msrs in bitmap */
      __u32 base;  /* MSR index the bitmap starts at */
      __u8 *bitmap; /* a 1 bit allows the operations in flags, 0 denies */
};

#define KVM_MSR_FILTER_MAX_RANGES 16
struct kvm_msr_filter {
#define KVM_MSR_FILTER_DEFAULT_ALLOW (0 &lt;&lt; 0)
#define KVM_MSR_FILTER_DEFAULT_DENY  (1 &lt;&lt; 0)
      __u32 flags;
      struct kvm_msr_filter_range ranges[KVM_MSR_FILTER_MAX_RANGES];
};
</pre></div>
</div>
<p>flags values for <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvm_msr_filter_range</span></code>:</p>
<p><code class="docutils literal notranslate"><span class="pre">KVM_MSR_FILTER_READ</span></code></p>
<blockquote>
<div><p>Filter read accesses to MSRs using the given bitmap. A 0 in the bitmap
indicates that read accesses should be denied, while a 1 indicates that
a read for a particular MSR should be allowed regardless of the default
filter action.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">KVM_MSR_FILTER_WRITE</span></code></p>
<blockquote>
<div><p>Filter write accesses to MSRs using the given bitmap. A 0 in the bitmap
indicates that write accesses should be denied, while a 1 indicates that
a write for a particular MSR should be allowed regardless of the default
filter action.</p>
</div></blockquote>
<p>flags values for <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvm_msr_filter</span></code>:</p>
<p><code class="docutils literal notranslate"><span class="pre">KVM_MSR_FILTER_DEFAULT_ALLOW</span></code></p>
<blockquote>
<div><p>If no filter range matches an MSR index that is getting accessed, KVM will
allow accesses to all MSRs by default.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">KVM_MSR_FILTER_DEFAULT_DENY</span></code></p>
<blockquote>
<div><p>If no filter range matches an MSR index that is getting accessed, KVM will
deny accesses to all MSRs by default.</p>
</div></blockquote>
<p>This ioctl allows userspace to define up to 16 bitmaps of MSR ranges to deny
guest MSR accesses that would normally be allowed by KVM.  If an MSR is not
covered by a specific range, the “default” filtering behavior applies.  Each
bitmap range covers MSRs from [base .. base+nmsrs).</p>
<p>If an MSR access is denied by userspace, the resulting KVM behavior depends on
whether or not KVM_CAP_X86_USER_SPACE_MSR’s KVM_MSR_EXIT_REASON_FILTER is
enabled.  If KVM_MSR_EXIT_REASON_FILTER is enabled, KVM will exit to userspace
on denied accesses, i.e. userspace effectively intercepts the MSR access.  If
KVM_MSR_EXIT_REASON_FILTER is not enabled, KVM will inject a #GP into the guest
on denied accesses.</p>
<p>If an MSR access is allowed by userspace, KVM will emulate and/or virtualize
the access in accordance with the vCPU model.  Note, KVM may still ultimately
inject a #GP if an access is allowed by userspace, e.g. if KVM doesn’t support
the MSR, or to follow architectural behavior for the MSR.</p>
<p>By default, KVM operates in KVM_MSR_FILTER_DEFAULT_ALLOW mode with no MSR range
filters.</p>
<p>Calling this ioctl with an empty set of ranges (all nmsrs == 0) disables MSR
filtering. In that mode, <code class="docutils literal notranslate"><span class="pre">KVM_MSR_FILTER_DEFAULT_DENY</span></code> is invalid and causes
an error.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>MSR accesses as part of nested VM-Enter/VM-Exit are not filtered.
This includes both writes to individual VMCS fields and reads/writes
through the MSR lists pointed to by the VMCS.</p>
<p>x2APIC MSR accesses cannot be filtered (KVM silently ignores filters that
cover any x2APIC MSRs).</p>
</div>
<p>Note, invoking this ioctl while a vCPU is running is inherently racy.  However,
KVM does guarantee that vCPUs will see either the previous filter or the new
filter, e.g. MSRs with identical settings in both the old and new filter will
have deterministic behavior.</p>
<p>Similarly, if userspace wishes to intercept on denied accesses,
KVM_MSR_EXIT_REASON_FILTER must be enabled before activating any filters, and
left enabled until after all filters are deactivated.  Failure to do so may
result in KVM injecting a #GP instead of exiting to userspace.</p>
</section>
<section id="kvm-create-spapr-tce-64">
<h3>4.98 KVM_CREATE_SPAPR_TCE_64<a class="headerlink" href="#kvm-create-spapr-tce-64" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SPAPR_TCE_64</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>powerpc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_create_spapr_tce_64 (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>file descriptor for manipulating the created TCE table</p>
</dd>
</dl>
<p>This is an extension for KVM_CAP_SPAPR_TCE which only supports 32bit
windows, described in 4.62 KVM_CREATE_SPAPR_TCE</p>
<p>This capability uses extended struct in ioctl interface:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* for KVM_CAP_SPAPR_TCE_64 */
struct kvm_create_spapr_tce_64 {
      __u64 liobn;
      __u32 page_shift;
      __u32 flags;
      __u64 offset;   /* in pages */
      __u64 size;     /* in pages */
};
</pre></div>
</div>
<p>The aim of extension is to support an additional bigger DMA window with
a variable page size.
KVM_CREATE_SPAPR_TCE_64 receives a 64bit window size, an IOMMU page shift and
a bus offset of the corresponding DMA window, &#64;size and &#64;offset are numbers
of IOMMU pages.</p>
<p>&#64;flags are not used at the moment.</p>
<p>The rest of functionality is identical to KVM_CREATE_SPAPR_TCE.</p>
</section>
<section id="kvm-reinject-control">
<h3>4.99 KVM_REINJECT_CONTROL<a class="headerlink" href="#kvm-reinject-control" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_REINJECT_CONTROL</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_reinject_control (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success,
-EFAULT if struct kvm_reinject_control cannot be read,
-ENXIO if KVM_CREATE_PIT or KVM_CREATE_PIT2 didn’t succeed earlier.</p>
</dd>
</dl>
<p>i8254 (PIT) has two modes, reinject and !reinject.  The default is reinject,
where KVM queues elapsed i8254 ticks and monitors completion of interrupt from
vector(s) that i8254 injects.  Reinject mode dequeues a tick and injects its
interrupt whenever there isn’t a pending interrupt from i8254.
!reinject mode injects an interrupt as soon as a tick arrives.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_reinject_control {
      __u8 pit_reinject;
      __u8 reserved[31];
};
</pre></div>
</div>
<p>pit_reinject = 0 (!reinject mode) is recommended, unless running an old
operating system that uses the PIT for timing (e.g. Linux 2.4.x).</p>
</section>
<section id="kvm-ppc-configure-v3-mmu">
<h3>4.100 KVM_PPC_CONFIGURE_V3_MMU<a class="headerlink" href="#kvm-ppc-configure-v3-mmu" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_RADIX_MMU or KVM_CAP_PPC_HASH_MMU_V3</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_ppc_mmuv3_cfg (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success,
-EFAULT if struct kvm_ppc_mmuv3_cfg cannot be read,
-EINVAL if the configuration is invalid</p>
</dd>
</dl>
<p>This ioctl controls whether the guest will use radix or HPT (hashed
page table) translation, and sets the pointer to the process table for
the guest.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_ppc_mmuv3_cfg {
      __u64   flags;
      __u64   process_table;
};
</pre></div>
</div>
<p>There are two bits that can be set in flags; KVM_PPC_MMUV3_RADIX and
KVM_PPC_MMUV3_GTSE.  KVM_PPC_MMUV3_RADIX, if set, configures the guest
to use radix tree translation, and if clear, to use HPT translation.
KVM_PPC_MMUV3_GTSE, if set and if KVM permits it, configures the guest
to be able to use the global TLB and SLB invalidation instructions;
if clear, the guest may not use these instructions.</p>
<p>The process_table field specifies the address and size of the guest
process table, which is in the guest’s space.  This field is formatted
as the second doubleword of the partition table entry, as defined in
the Power ISA V3.00, Book III section 5.7.6.1.</p>
</section>
<section id="kvm-ppc-get-rmmu-info">
<h3>4.101 KVM_PPC_GET_RMMU_INFO<a class="headerlink" href="#kvm-ppc-get-rmmu-info" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_RADIX_MMU</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_ppc_rmmu_info (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success,
-EFAULT if struct kvm_ppc_rmmu_info cannot be written,
-EINVAL if no useful information can be returned</p>
</dd>
</dl>
<p>This ioctl returns a structure containing two things: (a) a list
containing supported radix tree geometries, and (b) a list that maps
page sizes to put in the “AP” (actual page size) field for the tlbie
(TLB invalidate entry) instruction.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_ppc_rmmu_info {
      struct kvm_ppc_radix_geom {
              __u8    page_shift;
              __u8    level_bits[4];
              __u8    pad[3];
      }       geometries[8];
      __u32   ap_encodings[8];
};
</pre></div>
</div>
<p>The geometries[] field gives up to 8 supported geometries for the
radix page table, in terms of the log base 2 of the smallest page
size, and the number of bits indexed at each level of the tree, from
the PTE level up to the PGD level in that order.  Any unused entries
will have 0 in the page_shift field.</p>
<p>The ap_encodings gives the supported page sizes and their AP field
encodings, encoded with the AP value in the top 3 bits and the log
base 2 of the page size in the bottom 6 bits.</p>
</section>
<section id="kvm-ppc-resize-hpt-prepare">
<h3>4.102 KVM_PPC_RESIZE_HPT_PREPARE<a class="headerlink" href="#kvm-ppc-resize-hpt-prepare" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SPAPR_RESIZE_HPT</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>powerpc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_ppc_resize_hpt (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on successful completion,
&gt;0 if a new HPT is being prepared, the value is an estimated
number of milliseconds until preparation is complete,
-EFAULT if struct kvm_reinject_control cannot be read,
-EINVAL if the supplied shift or flags are invalid,
-ENOMEM if unable to allocate the new HPT,</p>
</dd>
</dl>
<p>Used to implement the PAPR extension for runtime resizing of a guest’s
Hashed Page Table (HPT).  Specifically this starts, stops or monitors
the preparation of a new potential HPT for the guest, essentially
implementing the H_RESIZE_HPT_PREPARE hypercall.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_ppc_resize_hpt {
      __u64 flags;
      __u32 shift;
      __u32 pad;
};
</pre></div>
</div>
<p>If called with shift &gt; 0 when there is no pending HPT for the guest,
this begins preparation of a new pending HPT of size 2^(shift) bytes.
It then returns a positive integer with the estimated number of
milliseconds until preparation is complete.</p>
<p>If called when there is a pending HPT whose size does not match that
requested in the parameters, discards the existing pending HPT and
creates a new one as above.</p>
<p>If called when there is a pending HPT of the size requested, will:</p>
<blockquote>
<div><ul class="simple">
<li><p>If preparation of the pending HPT is already complete, return 0</p></li>
<li><p>If preparation of the pending HPT has failed, return an error
code, then discard the pending HPT.</p></li>
<li><p>If preparation of the pending HPT is still in progress, return an
estimated number of milliseconds until preparation is complete.</p></li>
</ul>
</div></blockquote>
<p>If called with shift == 0, discards any currently pending HPT and
returns 0 (i.e. cancels any in-progress preparation).</p>
<p>flags is reserved for future expansion, currently setting any bits in
flags will result in an -EINVAL.</p>
<p>Normally this will be called repeatedly with the same parameters until
it returns &lt;= 0.  The first call will initiate preparation, subsequent
ones will monitor preparation until it completes or fails.</p>
</section>
<section id="kvm-ppc-resize-hpt-commit">
<h3>4.103 KVM_PPC_RESIZE_HPT_COMMIT<a class="headerlink" href="#kvm-ppc-resize-hpt-commit" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SPAPR_RESIZE_HPT</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>powerpc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_ppc_resize_hpt (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on successful completion,
-EFAULT if struct kvm_reinject_control cannot be read,
-EINVAL if the supplied shift or flags are invalid,
-ENXIO is there is no pending HPT, or the pending HPT doesn’t
have the requested size,
-EBUSY if the pending HPT is not fully prepared,
-ENOSPC if there was a hash collision when moving existing
HPT entries to the new HPT,
-EIO on other error conditions</p>
</dd>
</dl>
<p>Used to implement the PAPR extension for runtime resizing of a guest’s
Hashed Page Table (HPT).  Specifically this requests that the guest be
transferred to working with the new HPT, essentially implementing the
H_RESIZE_HPT_COMMIT hypercall.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_ppc_resize_hpt {
      __u64 flags;
      __u32 shift;
      __u32 pad;
};
</pre></div>
</div>
<p>This should only be called after KVM_PPC_RESIZE_HPT_PREPARE has
returned 0 with the same parameters.  In other cases
KVM_PPC_RESIZE_HPT_COMMIT will return an error (usually -ENXIO or
-EBUSY, though others may be possible if the preparation was started,
but failed).</p>
<p>This will have undefined effects on the guest if it has not already
placed itself in a quiescent state where no vcpu will make MMU enabled
memory accesses.</p>
<p>On succsful completion, the pending HPT will become the guest’s active
HPT and the previous HPT will be discarded.</p>
<p>On failure, the guest will still be operating on its previous HPT.</p>
</section>
<section id="kvm-x86-get-mce-cap-supported">
<h3>4.104 KVM_X86_GET_MCE_CAP_SUPPORTED<a class="headerlink" href="#kvm-x86-get-mce-cap-supported" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_MCE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>u64 mce_cap (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Returns supported MCE capabilities. The u64 mce_cap parameter
has the same format as the MSR_IA32_MCG_CAP register. Supported
capabilities will have the corresponding bits set.</p>
</section>
<section id="kvm-x86-setup-mce">
<h3>4.105 KVM_X86_SETUP_MCE<a class="headerlink" href="#kvm-x86-setup-mce" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_MCE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>u64 mcg_cap (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success,
-EFAULT if u64 mcg_cap cannot be read,
-EINVAL if the requested number of banks is invalid,
-EINVAL if requested MCE capability is not supported.</p>
</dd>
</dl>
<p>Initializes MCE support for use. The u64 mcg_cap parameter
has the same format as the MSR_IA32_MCG_CAP register and
specifies which capabilities should be enabled. The maximum
supported number of error-reporting banks can be retrieved when
checking for KVM_CAP_MCE. The supported capabilities can be
retrieved with KVM_X86_GET_MCE_CAP_SUPPORTED.</p>
</section>
<section id="kvm-x86-set-mce">
<h3>4.106 KVM_X86_SET_MCE<a class="headerlink" href="#kvm-x86-set-mce" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_MCE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_x86_mce (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success,
-EFAULT if struct kvm_x86_mce cannot be read,
-EINVAL if the bank number is invalid,
-EINVAL if VAL bit is not set in status field.</p>
</dd>
</dl>
<p>Inject a machine check error (MCE) into the guest. The input
parameter is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_x86_mce {
      __u64 status;
      __u64 addr;
      __u64 misc;
      __u64 mcg_status;
      __u8 bank;
      __u8 pad1[7];
      __u64 pad2[3];
};
</pre></div>
</div>
<p>If the MCE being reported is an uncorrected error, KVM will
inject it as an MCE exception into the guest. If the guest
MCG_STATUS register reports that an MCE is in progress, KVM
causes an KVM_EXIT_SHUTDOWN vmexit.</p>
<p>Otherwise, if the MCE is a corrected error, KVM will just
store it in the corresponding bank (provided this bank is
not holding a previously reported uncorrected error).</p>
</section>
<section id="kvm-s390-get-cmma-bits">
<h3>4.107 KVM_S390_GET_CMMA_BITS<a class="headerlink" href="#kvm-s390-get-cmma-bits" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_CMMA_MIGRATION</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_cmma_log (in, out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, a negative value on error</p>
</dd>
</dl>
<p>This ioctl is used to get the values of the CMMA bits on the s390
architecture. It is meant to be used in two scenarios:</p>
<ul class="simple">
<li><p>During live migration to save the CMMA values. Live migration needs
to be enabled via the KVM_REQ_START_MIGRATION VM property.</p></li>
<li><p>To non-destructively peek at the CMMA values, with the flag
KVM_S390_CMMA_PEEK set.</p></li>
</ul>
<p>The ioctl takes parameters via the kvm_s390_cmma_log struct. The desired
values are written to a buffer whose location is indicated via the “values”
member in the kvm_s390_cmma_log struct.  The values in the input struct are
also updated as needed.</p>
<p>Each CMMA value takes up one byte.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_cmma_log {
      __u64 start_gfn;
      __u32 count;
      __u32 flags;
      union {
              __u64 remaining;
              __u64 mask;
      };
      __u64 values;
};
</pre></div>
</div>
<p>start_gfn is the number of the first guest frame whose CMMA values are
to be retrieved,</p>
<p>count is the length of the buffer in bytes,</p>
<p>values points to the buffer where the result will be written to.</p>
<p>If count is greater than KVM_S390_SKEYS_MAX, then it is considered to be
KVM_S390_SKEYS_MAX. KVM_S390_SKEYS_MAX is re-used for consistency with
other ioctls.</p>
<p>The result is written in the buffer pointed to by the field values, and
the values of the input parameter are updated as follows.</p>
<p>Depending on the flags, different actions are performed. The only
supported flag so far is KVM_S390_CMMA_PEEK.</p>
<p>The default behaviour if KVM_S390_CMMA_PEEK is not set is:
start_gfn will indicate the first page frame whose CMMA bits were dirty.
It is not necessarily the same as the one passed as input, as clean pages
are skipped.</p>
<p>count will indicate the number of bytes actually written in the buffer.
It can (and very often will) be smaller than the input value, since the
buffer is only filled until 16 bytes of clean values are found (which
are then not copied in the buffer). Since a CMMA migration block needs
the base address and the length, for a total of 16 bytes, we will send
back some clean data if there is some dirty data afterwards, as long as
the size of the clean data does not exceed the size of the header. This
allows to minimize the amount of data to be saved or transferred over
the network at the expense of more roundtrips to userspace. The next
invocation of the ioctl will skip over all the clean values, saving
potentially more than just the 16 bytes we found.</p>
<p>If KVM_S390_CMMA_PEEK is set:
the existing storage attributes are read even when not in migration
mode, and no other action is performed;</p>
<p>the output start_gfn will be equal to the input start_gfn,</p>
<p>the output count will be equal to the input count, except if the end of
memory has been reached.</p>
<p>In both cases:
the field “remaining” will indicate the total number of dirty CMMA values
still remaining, or 0 if KVM_S390_CMMA_PEEK is set and migration mode is
not enabled.</p>
<p>mask is unused.</p>
<p>values points to the userspace buffer where the result will be stored.</p>
<p>This ioctl can fail with -ENOMEM if not enough memory can be allocated to
complete the task, with -ENXIO if CMMA is not enabled, with -EINVAL if
KVM_S390_CMMA_PEEK is not set but migration mode was not enabled, with
-EFAULT if the userspace address is invalid or if no page table is
present for the addresses (e.g. when using hugepages).</p>
</section>
<section id="kvm-s390-set-cmma-bits">
<h3>4.108 KVM_S390_SET_CMMA_BITS<a class="headerlink" href="#kvm-s390-set-cmma-bits" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_CMMA_MIGRATION</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_cmma_log (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, a negative value on error</p>
</dd>
</dl>
<p>This ioctl is used to set the values of the CMMA bits on the s390
architecture. It is meant to be used during live migration to restore
the CMMA values, but there are no restrictions on its use.
The ioctl takes parameters via the kvm_s390_cmma_values struct.
Each CMMA value takes up one byte.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_cmma_log {
      __u64 start_gfn;
      __u32 count;
      __u32 flags;
      union {
              __u64 remaining;
              __u64 mask;
      };
      __u64 values;
};
</pre></div>
</div>
<p>start_gfn indicates the starting guest frame number,</p>
<p>count indicates how many values are to be considered in the buffer,</p>
<p>flags is not used and must be 0.</p>
<p>mask indicates which PGSTE bits are to be considered.</p>
<p>remaining is not used.</p>
<p>values points to the buffer in userspace where to store the values.</p>
<p>This ioctl can fail with -ENOMEM if not enough memory can be allocated to
complete the task, with -ENXIO if CMMA is not enabled, with -EINVAL if
the count field is too large (e.g. more than KVM_S390_CMMA_SIZE_MAX) or
if the flags field was not 0, with -EFAULT if the userspace address is
invalid, if invalid pages are written to (e.g. after the end of memory)
or if no page table is present for the addresses (e.g. when using
hugepages).</p>
</section>
<section id="kvm-ppc-get-cpu-char">
<h3>4.109 KVM_PPC_GET_CPU_CHAR<a class="headerlink" href="#kvm-ppc-get-cpu-char" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_GET_CPU_CHAR</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>powerpc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_ppc_cpu_char (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on successful completion,
-EFAULT if struct kvm_ppc_cpu_char cannot be written</p>
</dd>
</dl>
<p>This ioctl gives userspace information about certain characteristics
of the CPU relating to speculative execution of instructions and
possible information leakage resulting from speculative execution (see
CVE-2017-5715, CVE-2017-5753 and CVE-2017-5754).  The information is
returned in struct kvm_ppc_cpu_char, which looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_ppc_cpu_char {
      __u64   character;              /* characteristics of the CPU */
      __u64   behaviour;              /* recommended software behaviour */
      __u64   character_mask;         /* valid bits in character */
      __u64   behaviour_mask;         /* valid bits in behaviour */
};
</pre></div>
</div>
<p>For extensibility, the character_mask and behaviour_mask fields
indicate which bits of character and behaviour have been filled in by
the kernel.  If the set of defined bits is extended in future then
userspace will be able to tell whether it is running on a kernel that
knows about the new bits.</p>
<p>The character field describes attributes of the CPU which can help
with preventing inadvertent information disclosure - specifically,
whether there is an instruction to flash-invalidate the L1 data cache
(ori 30,30,0 or mtspr SPRN_TRIG2,rN), whether the L1 data cache is set
to a mode where entries can only be used by the thread that created
them, whether the bcctr[l] instruction prevents speculation, and
whether a speculation barrier instruction (ori 31,31,0) is provided.</p>
<p>The behaviour field describes actions that software should take to
prevent inadvertent information disclosure, and thus describes which
vulnerabilities the hardware is subject to; specifically whether the
L1 data cache should be flushed when returning to user mode from the
kernel, and whether a speculation barrier should be placed between an
array bounds check and the array access.</p>
<p>These fields use the same bit definitions as the new
H_GET_CPU_CHARACTERISTICS hypercall.</p>
</section>
<section id="kvm-memory-encrypt-op">
<h3>4.110 KVM_MEMORY_ENCRYPT_OP<a class="headerlink" href="#kvm-memory-encrypt-op" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>an opaque platform specific structure (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>If the platform supports creating encrypted VMs then this ioctl can be used
for issuing platform-specific memory encryption commands to manage those
encrypted VMs.</p>
<p>Currently, this ioctl is used for issuing Secure Encrypted Virtualization
(SEV) commands on AMD Processors. The SEV commands are defined in
<a class="reference internal" href="x86/amd-memory-encryption.html"><span class="doc">Secure Encrypted Virtualization (SEV)</span></a>.</p>
</section>
<section id="kvm-memory-encrypt-reg-region">
<h3>4.111 KVM_MEMORY_ENCRYPT_REG_REGION<a class="headerlink" href="#kvm-memory-encrypt-reg-region" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_enc_region (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>This ioctl can be used to register a guest memory region which may
contain encrypted data (e.g. guest RAM, SMRAM etc).</p>
<p>It is used in the SEV-enabled guest. When encryption is enabled, a guest
memory region may contain encrypted data. The SEV memory encryption
engine uses a tweak such that two identical plaintext pages, each at
different locations will have differing ciphertexts. So swapping or
moving ciphertext of those pages will not result in plaintext being
swapped. So relocating (or migrating) physical backing pages for the SEV
guest will require some additional steps.</p>
<p>Note: The current SEV key management spec does not provide commands to
swap or migrate (move) ciphertext pages. Hence, for now we pin the guest
memory region registered with the ioctl.</p>
</section>
<section id="kvm-memory-encrypt-unreg-region">
<h3>4.112 KVM_MEMORY_ENCRYPT_UNREG_REGION<a class="headerlink" href="#kvm-memory-encrypt-unreg-region" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_enc_region (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>This ioctl can be used to unregister the guest memory region registered
with KVM_MEMORY_ENCRYPT_REG_REGION ioctl above.</p>
</section>
<section id="kvm-hyperv-eventfd">
<h3>4.113 KVM_HYPERV_EVENTFD<a class="headerlink" href="#kvm-hyperv-eventfd" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_HYPERV_EVENTFD</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_hyperv_eventfd (in)</p>
</dd>
</dl>
<p>This ioctl (un)registers an eventfd to receive notifications from the guest on
the specified Hyper-V connection id through the SIGNAL_EVENT hypercall, without
causing a user exit.  SIGNAL_EVENT hypercall with non-zero event flag number
(bits 24-31) still triggers a KVM_EXIT_HYPERV_HCALL user exit.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_hyperv_eventfd {
      __u32 conn_id;
      __s32 fd;
      __u32 flags;
      __u32 padding[3];
};
</pre></div>
</div>
<p>The conn_id field should fit within 24 bits:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_HYPERV_CONN_ID_MASK               0x00ffffff
</pre></div>
</div>
<p>The acceptable values for the flags field are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_HYPERV_EVENTFD_DEASSIGN   (1 &lt;&lt; 0)
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success,
-EINVAL if conn_id or flags is outside the allowed range,
-ENOENT on deassign if the conn_id isn’t registered,
-EEXIST on assign if the conn_id is already registered</p>
</dd>
</dl>
</section>
<section id="kvm-get-nested-state">
<h3>4.114 KVM_GET_NESTED_STATE<a class="headerlink" href="#kvm-get-nested-state" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_NESTED_STATE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_nested_state (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 92%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>E2BIG</p></td>
<td><p>the total state size exceeds the value of ‘size’ specified by
the user; the size required will be written into size.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_nested_state {
      __u16 flags;
      __u16 format;
      __u32 size;

      union {
              struct kvm_vmx_nested_state_hdr vmx;
              struct kvm_svm_nested_state_hdr svm;

              /* Pad the header to 128 bytes.  */
              __u8 pad[120];
      } hdr;

      union {
              struct kvm_vmx_nested_state_data vmx[0];
              struct kvm_svm_nested_state_data svm[0];
      } data;
};

#define KVM_STATE_NESTED_GUEST_MODE           0x00000001
#define KVM_STATE_NESTED_RUN_PENDING          0x00000002
#define KVM_STATE_NESTED_EVMCS                0x00000004

#define KVM_STATE_NESTED_FORMAT_VMX           0
#define KVM_STATE_NESTED_FORMAT_SVM           1

#define KVM_STATE_NESTED_VMX_VMCS_SIZE        0x1000

#define KVM_STATE_NESTED_VMX_SMM_GUEST_MODE   0x00000001
#define KVM_STATE_NESTED_VMX_SMM_VMXON        0x00000002

#define KVM_STATE_VMX_PREEMPTION_TIMER_DEADLINE 0x00000001

struct kvm_vmx_nested_state_hdr {
      __u64 vmxon_pa;
      __u64 vmcs12_pa;

      struct {
              __u16 flags;
      } smm;

      __u32 flags;
      __u64 preemption_timer_deadline;
};

struct kvm_vmx_nested_state_data {
      __u8 vmcs12[KVM_STATE_NESTED_VMX_VMCS_SIZE];
      __u8 shadow_vmcs12[KVM_STATE_NESTED_VMX_VMCS_SIZE];
};
</pre></div>
</div>
<p>This ioctl copies the vcpu’s nested virtualization state from the kernel to
userspace.</p>
<p>The maximum size of the state can be retrieved by passing KVM_CAP_NESTED_STATE
to the KVM_CHECK_EXTENSION ioctl().</p>
</section>
<section id="kvm-set-nested-state">
<h3>4.115 KVM_SET_NESTED_STATE<a class="headerlink" href="#kvm-set-nested-state" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_NESTED_STATE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_nested_state (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>This copies the vcpu’s kvm_nested_state struct from userspace to the kernel.
For the definition of struct kvm_nested_state, see KVM_GET_NESTED_STATE.</p>
</section>
<section id="kvm-un-register-coalesced-mmio">
<h3>4.116 KVM_(UN)REGISTER_COALESCED_MMIO<a class="headerlink" href="#kvm-un-register-coalesced-mmio" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_COALESCED_MMIO (for coalesced mmio)
KVM_CAP_COALESCED_PIO (for coalesced pio)</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_coalesced_mmio_zone</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, &lt; 0 on error</p>
</dd>
</dl>
<p>Coalesced I/O is a performance optimization that defers hardware
register write emulation so that userspace exits are avoided.  It is
typically used to reduce the overhead of emulating frequently accessed
hardware registers.</p>
<p>When a hardware register is configured for coalesced I/O, write accesses
do not exit to userspace and their value is recorded in a ring buffer
that is shared between kernel and userspace.</p>
<p>Coalesced I/O is used if one or more write accesses to a hardware
register can be deferred until a read or a write to another hardware
register on the same device.  This last access will cause a vmexit and
userspace will process accesses from the ring buffer before emulating
it. That will avoid exiting to userspace on repeated writes.</p>
<p>Coalesced pio is based on coalesced mmio. There is little difference
between coalesced mmio and pio except that coalesced pio records accesses
to I/O ports.</p>
</section>
<section id="kvm-clear-dirty-log-vm-ioctl">
<h3>4.117 KVM_CLEAR_DIRTY_LOG (vm ioctl)<a class="headerlink" href="#kvm-clear-dirty-log-vm-ioctl" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86, arm64, mips</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_clear_dirty_log (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* for KVM_CLEAR_DIRTY_LOG */
struct kvm_clear_dirty_log {
      __u32 slot;
      __u32 num_pages;
      __u64 first_page;
      union {
              void __user *dirty_bitmap; /* one bit per page */
              __u64 padding;
      };
};
</pre></div>
</div>
<p>The ioctl clears the dirty status of pages in a memory slot, according to
the bitmap that is passed in struct kvm_clear_dirty_log’s dirty_bitmap
field.  Bit 0 of the bitmap corresponds to page “first_page” in the
memory slot, and num_pages is the size in bits of the input bitmap.
first_page must be a multiple of 64; num_pages must also be a multiple of
64 unless first_page + num_pages is the size of the memory slot.  For each
bit that is set in the input bitmap, the corresponding page is marked “clean”
in KVM’s dirty bitmap, and dirty tracking is re-enabled for that page
(for example via write-protection, or by clearing the dirty bit in
a page table entry).</p>
<p>If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 of slot field specifies
the address space for which you want to clear the dirty status.  See
KVM_SET_USER_MEMORY_REGION for details on the usage of slot field.</p>
<p>This ioctl is mostly useful when KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2
is enabled; for more information, see the description of the capability.
However, it can always be used as long as KVM_CHECK_EXTENSION confirms
that KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 is present.</p>
</section>
<section id="kvm-get-supported-hv-cpuid">
<h3>4.118 KVM_GET_SUPPORTED_HV_CPUID<a class="headerlink" href="#kvm-get-supported-hv-cpuid" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_HYPERV_CPUID (vcpu), KVM_CAP_SYS_HYPERV_CPUID (system)</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>system ioctl, vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_cpuid2 (in/out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_cpuid2 {
      __u32 nent;
      __u32 padding;
      struct kvm_cpuid_entry2 entries[0];
};

struct kvm_cpuid_entry2 {
      __u32 function;
      __u32 index;
      __u32 flags;
      __u32 eax;
      __u32 ebx;
      __u32 ecx;
      __u32 edx;
      __u32 padding[3];
};
</pre></div>
</div>
<p>This ioctl returns x86 cpuid features leaves related to Hyper-V emulation in
KVM.  Userspace can use the information returned by this ioctl to construct
cpuid information presented to guests consuming Hyper-V enlightenments (e.g.
Windows or Hyper-V guests).</p>
<p>CPUID feature leaves returned by this ioctl are defined by Hyper-V Top Level
Functional Specification (TLFS). These leaves can’t be obtained with
KVM_GET_SUPPORTED_CPUID ioctl because some of them intersect with KVM feature
leaves (0x40000000, 0x40000001).</p>
<p>Currently, the following list of CPUID leaves are returned:</p>
<blockquote>
<div><ul class="simple">
<li><p>HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS</p></li>
<li><p>HYPERV_CPUID_INTERFACE</p></li>
<li><p>HYPERV_CPUID_VERSION</p></li>
<li><p>HYPERV_CPUID_FEATURES</p></li>
<li><p>HYPERV_CPUID_ENLIGHTMENT_INFO</p></li>
<li><p>HYPERV_CPUID_IMPLEMENT_LIMITS</p></li>
<li><p>HYPERV_CPUID_NESTED_FEATURES</p></li>
<li><p>HYPERV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS</p></li>
<li><p>HYPERV_CPUID_SYNDBG_INTERFACE</p></li>
<li><p>HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES</p></li>
</ul>
</div></blockquote>
<p>Userspace invokes KVM_GET_SUPPORTED_HV_CPUID by passing a kvm_cpuid2 structure
with the ‘nent’ field indicating the number of entries in the variable-size
array ‘entries’.  If the number of entries is too low to describe all Hyper-V
feature leaves, an error (E2BIG) is returned. If the number is more or equal
to the number of Hyper-V feature leaves, the ‘nent’ field is adjusted to the
number of valid entries in the ‘entries’ array, which is then filled.</p>
<p>‘index’ and ‘flags’ fields in ‘struct kvm_cpuid_entry2’ are currently reserved,
userspace should not expect to get any particular value there.</p>
<p>Note, vcpu version of KVM_GET_SUPPORTED_HV_CPUID is currently deprecated. Unlike
system ioctl which exposes all supported feature bits unconditionally, vcpu
version has the following quirks:</p>
<ul class="simple">
<li><p>HYPERV_CPUID_NESTED_FEATURES leaf and HV_X64_ENLIGHTENED_VMCS_RECOMMENDED
feature bit are only exposed when Enlightened VMCS was previously enabled
on the corresponding vCPU (KVM_CAP_HYPERV_ENLIGHTENED_VMCS).</p></li>
<li><p>HV_STIMER_DIRECT_MODE_AVAILABLE bit is only exposed with in-kernel LAPIC.
(presumes KVM_CREATE_IRQCHIP has already been called).</p></li>
</ul>
</section>
<section id="kvm-arm-vcpu-finalize">
<h3>4.119 KVM_ARM_VCPU_FINALIZE<a class="headerlink" href="#kvm-arm-vcpu-finalize" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>arm64</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>vcpu ioctl</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>int feature (in)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 91%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>EPERM</p></td>
<td><p>feature not enabled, needs configuration, or already finalized</p></td>
</tr>
<tr class="row-even"><td><p>EINVAL</p></td>
<td><p>feature unknown or not present</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Recognised values for feature:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>arm64</p></td>
<td><p>KVM_ARM_VCPU_SVE (requires KVM_CAP_ARM_SVE)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Finalizes the configuration of the specified vcpu feature.</p>
<p>The vcpu must already have been initialised, enabling the affected feature, by
means of a successful KVM_ARM_VCPU_INIT call with the appropriate flag set in
features[].</p>
<p>For affected vcpu features, this is a mandatory step that must be performed
before the vcpu is fully usable.</p>
<p>Between KVM_ARM_VCPU_INIT and KVM_ARM_VCPU_FINALIZE, the feature may be
configured by use of ioctls such as KVM_SET_ONE_REG.  The exact configuration
that should be performaned and how to do it are feature-dependent.</p>
<p>Other calls that depend on a particular feature being finalized, such as
KVM_RUN, KVM_GET_REG_LIST, KVM_GET_ONE_REG and KVM_SET_ONE_REG, will fail with
-EPERM unless the feature has already been finalized by means of a
KVM_ARM_VCPU_FINALIZE call.</p>
<p>See KVM_ARM_VCPU_INIT for details of vcpu features that require finalization
using this ioctl.</p>
</section>
<section id="kvm-set-pmu-event-filter">
<h3>4.120 KVM_SET_PMU_EVENT_FILTER<a class="headerlink" href="#kvm-set-pmu-event-filter" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PMU_EVENT_FILTER</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_pmu_event_filter (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_pmu_event_filter {
      __u32 action;
      __u32 nevents;
      __u32 fixed_counter_bitmap;
      __u32 flags;
      __u32 pad[4];
      __u64 events[0];
};
</pre></div>
</div>
<p>This ioctl restricts the set of PMU events that the guest can program.
The argument holds a list of events which will be allowed or denied.
The eventsel+umask of each event the guest attempts to program is compared
against the events field to determine whether the guest should have access.
The events field only controls general purpose counters; fixed purpose
counters are controlled by the fixed_counter_bitmap.</p>
<p>No flags are defined yet, the field must be zero.</p>
<p>Valid values for ‘action’:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_PMU_EVENT_ALLOW 0
#define KVM_PMU_EVENT_DENY 1
</pre></div>
</div>
</section>
<section id="kvm-ppc-svm-off">
<h3>4.121 KVM_PPC_SVM_OFF<a class="headerlink" href="#kvm-ppc-svm-off" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>basic</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>powerpc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on successful completion,</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 91%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>EINVAL</p></td>
<td><p>if ultravisor failed to terminate the secure guest</p></td>
</tr>
<tr class="row-even"><td><p>ENOMEM</p></td>
<td><p>if hypervisor failed to allocate new radix page tables for guest</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>This ioctl is used to turn off the secure mode of the guest or transition
the guest from secure mode to normal mode. This is invoked when the guest
is reset. This has no effect if called for a normal guest.</p>
<p>This ioctl issues an ultravisor call to terminate the secure guest,
unpins the VPA pages and releases all the device pages that are used to
track the secure pages by hypervisor.</p>
</section>
<section id="kvm-s390-normal-reset">
<h3>4.122 KVM_S390_NORMAL_RESET<a class="headerlink" href="#kvm-s390-normal-reset" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_VCPU_RESETS</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0</p>
</dd>
</dl>
<p>This ioctl resets VCPU registers and control structures according to
the cpu reset definition in the POP (Principles Of Operation).</p>
</section>
<section id="kvm-s390-initial-reset">
<h3>4.123 KVM_S390_INITIAL_RESET<a class="headerlink" href="#kvm-s390-initial-reset" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>none</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0</p>
</dd>
</dl>
<p>This ioctl resets VCPU registers and control structures according to
the initial cpu reset definition in the POP. However, the cpu is not
put into ESA mode. This reset is a superset of the normal reset.</p>
</section>
<section id="kvm-s390-clear-reset">
<h3>4.124 KVM_S390_CLEAR_RESET<a class="headerlink" href="#kvm-s390-clear-reset" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_VCPU_RESETS</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0</p>
</dd>
</dl>
<p>This ioctl resets VCPU registers and control structures according to
the clear cpu reset definition in the POP. However, the cpu is not put
into ESA mode. This reset is a superset of the initial reset.</p>
</section>
<section id="kvm-s390-pv-command">
<h3>4.125 KVM_S390_PV_COMMAND<a class="headerlink" href="#kvm-s390-pv-command" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_PROTECTED</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_pv_cmd</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, &lt; 0 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_pv_cmd {
      __u32 cmd;      /* Command to be executed */
      __u16 rc;       /* Ultravisor return code */
      __u16 rrc;      /* Ultravisor return reason code */
      __u64 data;     /* Data or address */
      __u32 flags;    /* flags for future extensions. Must be 0 for now */
      __u32 reserved[3];
};
</pre></div>
</div>
<p><strong>Ultravisor return codes</strong>
The Ultravisor return (reason) codes are provided by the kernel if a
Ultravisor call has been executed to achieve the results expected by
the command. Therefore they are independent of the IOCTL return
code. If KVM changes <cite>rc</cite>, its value will always be greater than 0
hence setting it to 0 before issuing a PV command is advised to be
able to detect a change of <cite>rc</cite>.</p>
<p><strong>cmd values:</strong></p>
<dl>
<dt>KVM_PV_ENABLE</dt><dd><p>Allocate memory and register the VM with the Ultravisor, thereby
donating memory to the Ultravisor that will become inaccessible to
KVM. All existing CPUs are converted to protected ones. After this
command has succeeded, any CPU added via hotplug will become
protected during its creation as well.</p>
<p>Errors:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>EINTR</p></td>
<td><p>an unmasked signal is pending</p></td>
</tr>
</tbody>
</table>
</dd>
<dt>KVM_PV_DISABLE</dt><dd><p>Deregister the VM from the Ultravisor and reclaim the memory that had
been donated to the Ultravisor, making it usable by the kernel again.
All registered VCPUs are converted back to non-protected ones. If a
previous protected VM had been prepared for asynchonous teardown with
KVM_PV_ASYNC_CLEANUP_PREPARE and not subsequently torn down with
KVM_PV_ASYNC_CLEANUP_PERFORM, it will be torn down in this call
together with the current protected VM.</p>
</dd>
<dt>KVM_PV_VM_SET_SEC_PARMS</dt><dd><p>Pass the image header from VM memory to the Ultravisor in
preparation of image unpacking and verification.</p>
</dd>
<dt>KVM_PV_VM_UNPACK</dt><dd><p>Unpack (protect and decrypt) a page of the encrypted boot image.</p>
</dd>
<dt>KVM_PV_VM_VERIFY</dt><dd><p>Verify the integrity of the unpacked image. Only if this succeeds,
KVM is allowed to start protected VCPUs.</p>
</dd>
<dt>KVM_PV_INFO</dt><dd><dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_PROTECTED_DUMP</p>
</dd>
</dl>
<p>Presents an API that provides Ultravisor related data to userspace
via subcommands. len_max is the size of the user space buffer,
len_written is KVM’s indication of how much bytes of that buffer
were actually written to. len_written can be used to determine the
valid fields if more response fields are added in the future.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum pv_cmd_info_id {
   KVM_PV_INFO_VM,
   KVM_PV_INFO_DUMP,
};

struct kvm_s390_pv_info_header {
   __u32 id;
   __u32 len_max;
   __u32 len_written;
   __u32 reserved;
};

struct kvm_s390_pv_info {
   struct kvm_s390_pv_info_header header;
   struct kvm_s390_pv_info_dump dump;
   struct kvm_s390_pv_info_vm vm;
};
</pre></div>
</div>
</dd>
</dl>
<p><strong>subcommands:</strong></p>
<blockquote>
<div><dl>
<dt>KVM_PV_INFO_VM</dt><dd><p>This subcommand provides basic Ultravisor information for PV
hosts. These values are likely also exported as files in the sysfs
firmware UV query interface but they are more easily available to
programs in this API.</p>
<p>The installed calls and feature_indication members provide the
installed UV calls and the UV’s other feature indications.</p>
<p>The max_* members provide information about the maximum number of PV
vcpus, PV guests and PV guest memory size.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_pv_info_vm {
  __u64 inst_calls_list[4];
  __u64 max_cpus;
  __u64 max_guests;
  __u64 max_guest_addr;
  __u64 feature_indication;
};
</pre></div>
</div>
</dd>
<dt>KVM_PV_INFO_DUMP</dt><dd><p>This subcommand provides information related to dumping PV guests.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_pv_info_dump {
  __u64 dump_cpu_buffer_len;
  __u64 dump_config_mem_buffer_per_1m;
  __u64 dump_config_finalize_len;
};
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>KVM_PV_DUMP</dt><dd><dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_PROTECTED_DUMP</p>
</dd>
</dl>
<p>Presents an API that provides calls which facilitate dumping a
protected VM.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_pv_dmp {
  __u64 subcmd;
  __u64 buff_addr;
  __u64 buff_len;
  __u64 gaddr;              /* For dump storage state */
};
</pre></div>
</div>
<p><strong>subcommands:</strong></p>
<dl>
<dt>KVM_PV_DUMP_INIT</dt><dd><p>Initializes the dump process of a protected VM. If this call does
not succeed all other subcommands will fail with -EINVAL. This
subcommand will return -EINVAL if a dump process has not yet been
completed.</p>
<p>Not all PV vms can be dumped, the owner needs to set <cite>dump
allowed</cite> PCF bit 34 in the SE header to allow dumping.</p>
</dd>
<dt>KVM_PV_DUMP_CONFIG_STOR_STATE</dt><dd><p>Stores <cite>buff_len</cite> bytes of tweak component values starting with
the 1MB block specified by the absolute guest address
(<cite>gaddr</cite>). <cite>buff_len</cite> needs to be <cite>conf_dump_storage_state_len</cite>
aligned and at least &gt;= the <cite>conf_dump_storage_state_len</cite> value
provided by the dump uv_info data. buff_user might be written to
even if an error rc is returned. For instance if we encounter a
fault after writing the first page of data.</p>
</dd>
<dt>KVM_PV_DUMP_COMPLETE</dt><dd><p>If the subcommand succeeds it completes the dump process and lets
KVM_PV_DUMP_INIT be called again.</p>
<p>On success <cite>conf_dump_finalize_len</cite> bytes of completion data will be
stored to the <cite>buff_addr</cite>. The completion data contains a key
derivation seed, IV, tweak nonce and encryption keys as well as an
authentication tag all of which are needed to decrypt the dump at a
later time.</p>
</dd>
</dl>
</dd>
<dt>KVM_PV_ASYNC_CLEANUP_PREPARE</dt><dd><dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_PROTECTED_ASYNC_DISABLE</p>
</dd>
</dl>
<p>Prepare the current protected VM for asynchronous teardown. Most
resources used by the current protected VM will be set aside for a
subsequent asynchronous teardown. The current protected VM will then
resume execution immediately as non-protected. There can be at most
one protected VM prepared for asynchronous teardown at any time. If
a protected VM had already been prepared for teardown without
subsequently calling KVM_PV_ASYNC_CLEANUP_PERFORM, this call will
fail. In that case, the userspace process should issue a normal
KVM_PV_DISABLE. The resources set aside with this call will need to
be cleaned up with a subsequent call to KVM_PV_ASYNC_CLEANUP_PERFORM
or KVM_PV_DISABLE, otherwise they will be cleaned up when KVM
terminates. KVM_PV_ASYNC_CLEANUP_PREPARE can be called again as soon
as cleanup starts, i.e. before KVM_PV_ASYNC_CLEANUP_PERFORM finishes.</p>
</dd>
<dt>KVM_PV_ASYNC_CLEANUP_PERFORM</dt><dd><dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_PROTECTED_ASYNC_DISABLE</p>
</dd>
</dl>
<p>Tear down the protected VM previously prepared for teardown with
KVM_PV_ASYNC_CLEANUP_PREPARE. The resources that had been set aside
will be freed during the execution of this command. This PV command
should ideally be issued by userspace from a separate thread. If a
fatal signal is received (or the process terminates naturally), the
command will terminate immediately without completing, and the normal
KVM shutdown procedure will take care of cleaning up all remaining
protected VMs, including the ones whose teardown was interrupted by
process termination.</p>
</dd>
</dl>
</section>
<section id="kvm-xen-hvm-set-attr">
<h3>4.126 KVM_XEN_HVM_SET_ATTR<a class="headerlink" href="#kvm-xen-hvm-set-attr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_SHARED_INFO</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_xen_hvm_attr</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, &lt; 0 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_xen_hvm_attr {
      __u16 type;
      __u16 pad[3];
      union {
              __u8 long_mode;
              __u8 vector;
              __u8 runstate_update_flag;
              struct {
                      __u64 gfn;
              } shared_info;
              struct {
                      __u32 send_port;
                      __u32 type; /* EVTCHNSTAT_ipi / EVTCHNSTAT_interdomain */
                      __u32 flags;
                      union {
                              struct {
                                      __u32 port;
                                      __u32 vcpu;
                                      __u32 priority;
                              } port;
                              struct {
                                      __u32 port; /* Zero for eventfd */
                                      __s32 fd;
                              } eventfd;
                              __u32 padding[4];
                      } deliver;
              } evtchn;
              __u32 xen_version;
              __u64 pad[8];
      } u;
};
</pre></div>
</div>
<p>type values:</p>
<dl>
<dt>KVM_XEN_ATTR_TYPE_LONG_MODE</dt><dd><p>Sets the ABI mode of the VM to 32-bit or 64-bit (long mode). This
determines the layout of the shared info pages exposed to the VM.</p>
</dd>
<dt>KVM_XEN_ATTR_TYPE_SHARED_INFO</dt><dd><p>Sets the guest physical frame number at which the Xen “shared info”
page resides. Note that although Xen places vcpu_info for the first
32 vCPUs in the shared_info page, KVM does not automatically do so
and instead requires that KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO be used
explicitly even when the vcpu_info for a given vCPU resides at the
“default” location in the shared_info page. This is because KVM may
not be aware of the Xen CPU id which is used as the index into the
vcpu_info[] array, so may know the correct default location.</p>
<p>Note that the shared info page may be constantly written to by KVM;
it contains the event channel bitmap used to deliver interrupts to
a Xen guest, amongst other things. It is exempt from dirty tracking
mechanisms — KVM will not explicitly mark the page as dirty each
time an event channel interrupt is delivered to the guest! Thus,
userspace should always assume that the designated GFN is dirty if
any vCPU has been running or any event channel interrupts can be
routed to the guest.</p>
<p>Setting the gfn to KVM_XEN_INVALID_GFN will disable the shared info
page.</p>
</dd>
<dt>KVM_XEN_ATTR_TYPE_UPCALL_VECTOR</dt><dd><p>Sets the exception vector used to deliver Xen event channel upcalls.
This is the HVM-wide vector injected directly by the hypervisor
(not through the local APIC), typically configured by a guest via
HVM_PARAM_CALLBACK_IRQ. This can be disabled again (e.g. for guest
SHUTDOWN_soft_reset) by setting it to zero.</p>
</dd>
<dt>KVM_XEN_ATTR_TYPE_EVTCHN</dt><dd><p>This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates
support for KVM_XEN_HVM_CONFIG_EVTCHN_SEND features. It configures
an outbound port number for interception of EVTCHNOP_send requests
from the guest. A given sending port number may be directed back to
a specified vCPU (by APIC ID) / port / priority on the guest, or to
trigger events on an eventfd. The vCPU and priority can be changed
by setting KVM_XEN_EVTCHN_UPDATE in a subsequent call, but but other
fields cannot change for a given sending port. A port mapping is
removed by using KVM_XEN_EVTCHN_DEASSIGN in the flags field. Passing
KVM_XEN_EVTCHN_RESET in the flags field removes all interception of
outbound event channels. The values of the flags field are mutually
exclusive and cannot be combined as a bitmask.</p>
</dd>
<dt>KVM_XEN_ATTR_TYPE_XEN_VERSION</dt><dd><p>This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates
support for KVM_XEN_HVM_CONFIG_EVTCHN_SEND features. It configures
the 32-bit version code returned to the guest when it invokes the
XENVER_version call; typically (XEN_MAJOR &lt;&lt; 16 | XEN_MINOR). PV
Xen guests will often use this to as a dummy hypercall to trigger
event channel delivery, so responding within the kernel without
exiting to userspace is beneficial.</p>
</dd>
<dt>KVM_XEN_ATTR_TYPE_RUNSTATE_UPDATE_FLAG</dt><dd><p>This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates
support for KVM_XEN_HVM_CONFIG_RUNSTATE_UPDATE_FLAG. It enables the
XEN_RUNSTATE_UPDATE flag which allows guest vCPUs to safely read
other vCPUs’ vcpu_runstate_info. Xen guests enable this feature via
the VMASST_TYPE_runstate_update_flag of the HYPERVISOR_vm_assist
hypercall.</p>
</dd>
</dl>
</section>
<section id="kvm-xen-hvm-get-attr">
<h3>4.127 KVM_XEN_HVM_GET_ATTR<a class="headerlink" href="#kvm-xen-hvm-get-attr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_SHARED_INFO</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_xen_hvm_attr</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, &lt; 0 on error</p>
</dd>
</dl>
<p>Allows Xen VM attributes to be read. For the structure and types,
see KVM_XEN_HVM_SET_ATTR above. The KVM_XEN_ATTR_TYPE_EVTCHN
attribute cannot be read.</p>
</section>
<section id="kvm-xen-vcpu-set-attr">
<h3>4.128 KVM_XEN_VCPU_SET_ATTR<a class="headerlink" href="#kvm-xen-vcpu-set-attr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_SHARED_INFO</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_xen_vcpu_attr</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, &lt; 0 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_xen_vcpu_attr {
      __u16 type;
      __u16 pad[3];
      union {
              __u64 gpa;
              __u64 pad[4];
              struct {
                      __u64 state;
                      __u64 state_entry_time;
                      __u64 time_running;
                      __u64 time_runnable;
                      __u64 time_blocked;
                      __u64 time_offline;
              } runstate;
              __u32 vcpu_id;
              struct {
                      __u32 port;
                      __u32 priority;
                      __u64 expires_ns;
              } timer;
              __u8 vector;
      } u;
};
</pre></div>
</div>
<p>type values:</p>
<dl class="simple">
<dt>KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO</dt><dd><p>Sets the guest physical address of the vcpu_info for a given vCPU.
As with the shared_info page for the VM, the corresponding page may be
dirtied at any time if event channel interrupt delivery is enabled, so
userspace should always assume that the page is dirty without relying
on dirty logging. Setting the gpa to KVM_XEN_INVALID_GPA will disable
the vcpu_info.</p>
</dd>
<dt>KVM_XEN_VCPU_ATTR_TYPE_VCPU_TIME_INFO</dt><dd><p>Sets the guest physical address of an additional pvclock structure
for a given vCPU. This is typically used for guest vsyscall support.
Setting the gpa to KVM_XEN_INVALID_GPA will disable the structure.</p>
</dd>
<dt>KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADDR</dt><dd><p>Sets the guest physical address of the vcpu_runstate_info for a given
vCPU. This is how a Xen guest tracks CPU state such as steal time.
Setting the gpa to KVM_XEN_INVALID_GPA will disable the runstate area.</p>
</dd>
<dt>KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_CURRENT</dt><dd><p>Sets the runstate (RUNSTATE_running/_runnable/_blocked/_offline) of
the given vCPU from the .u.runstate.state member of the structure.
KVM automatically accounts running and runnable time but blocked
and offline states are only entered explicitly.</p>
</dd>
<dt>KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_DATA</dt><dd><p>Sets all fields of the vCPU runstate data from the .u.runstate member
of the structure, including the current runstate. The state_entry_time
must equal the sum of the other four times.</p>
</dd>
<dt>KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADJUST</dt><dd><p>This <em>adds</em> the contents of the .u.runstate members of the structure
to the corresponding members of the given vCPU’s runstate data, thus
permitting atomic adjustments to the runstate times. The adjustment
to the state_entry_time must equal the sum of the adjustments to the
other four times. The state field must be set to -1, or to a valid
runstate value (RUNSTATE_running, RUNSTATE_runnable, RUNSTATE_blocked
or RUNSTATE_offline) to set the current accounted state as of the
adjusted state_entry_time.</p>
</dd>
<dt>KVM_XEN_VCPU_ATTR_TYPE_VCPU_ID</dt><dd><p>This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates
support for KVM_XEN_HVM_CONFIG_EVTCHN_SEND features. It sets the Xen
vCPU ID of the given vCPU, to allow timer-related VCPU operations to
be intercepted by KVM.</p>
</dd>
<dt>KVM_XEN_VCPU_ATTR_TYPE_TIMER</dt><dd><p>This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates
support for KVM_XEN_HVM_CONFIG_EVTCHN_SEND features. It sets the
event channel port/priority for the VIRQ_TIMER of the vCPU, as well
as allowing a pending timer to be saved/restored. Setting the timer
port to zero disables kernel handling of the singleshot timer.</p>
</dd>
<dt>KVM_XEN_VCPU_ATTR_TYPE_UPCALL_VECTOR</dt><dd><p>This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates
support for KVM_XEN_HVM_CONFIG_EVTCHN_SEND features. It sets the
per-vCPU local APIC upcall vector, configured by a Xen guest with
the HVMOP_set_evtchn_upcall_vector hypercall. This is typically
used by Windows guests, and is distinct from the HVM-wide upcall
vector configured with HVM_PARAM_CALLBACK_IRQ. It is disabled by
setting the vector to zero.</p>
</dd>
</dl>
</section>
<section id="kvm-xen-vcpu-get-attr">
<h3>4.129 KVM_XEN_VCPU_GET_ATTR<a class="headerlink" href="#kvm-xen-vcpu-get-attr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_SHARED_INFO</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_xen_vcpu_attr</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, &lt; 0 on error</p>
</dd>
</dl>
<p>Allows Xen vCPU attributes to be read. For the structure and types,
see KVM_XEN_VCPU_SET_ATTR above.</p>
<p>The KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADJUST type may not be used
with the KVM_XEN_VCPU_GET_ATTR ioctl.</p>
</section>
<section id="kvm-arm-mte-copy-tags">
<h3>4.130 KVM_ARM_MTE_COPY_TAGS<a class="headerlink" href="#kvm-arm-mte-copy-tags" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_ARM_MTE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_arm_copy_mte_tags</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>number of bytes copied, &lt; 0 on error (-EINVAL for incorrect
arguments, -EFAULT if memory cannot be accessed).</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_arm_copy_mte_tags {
      __u64 guest_ipa;
      __u64 length;
      void __user *addr;
      __u64 flags;
      __u64 reserved[2];
};
</pre></div>
</div>
<p>Copies Memory Tagging Extension (MTE) tags to/from guest tag memory. The
<code class="docutils literal notranslate"><span class="pre">guest_ipa</span></code> and <code class="docutils literal notranslate"><span class="pre">length</span></code> fields must be <code class="docutils literal notranslate"><span class="pre">PAGE_SIZE</span></code> aligned. The <code class="docutils literal notranslate"><span class="pre">addr</span></code>
field must point to a buffer which the tags will be copied to or from.</p>
<p><code class="docutils literal notranslate"><span class="pre">flags</span></code> specifies the direction of copy, either <code class="docutils literal notranslate"><span class="pre">KVM_ARM_TAGS_TO_GUEST</span></code> or
<code class="docutils literal notranslate"><span class="pre">KVM_ARM_TAGS_FROM_GUEST</span></code>.</p>
<p>The size of the buffer to store the tags is <code class="docutils literal notranslate"><span class="pre">(length</span> <span class="pre">/</span> <span class="pre">16)</span></code> bytes
(granules in MTE are 16 bytes long). Each byte contains a single tag
value. This matches the format of <code class="docutils literal notranslate"><span class="pre">PTRACE_PEEKMTETAGS</span></code> and
<code class="docutils literal notranslate"><span class="pre">PTRACE_POKEMTETAGS</span></code>.</p>
<p>If an error occurs before any data is copied then a negative error code is
returned. If some tags have been copied before an error occurs then the number
of bytes successfully copied is returned. If the call completes successfully
then <code class="docutils literal notranslate"><span class="pre">length</span></code> is returned.</p>
</section>
<section id="kvm-get-sregs2">
<h3>4.131 KVM_GET_SREGS2<a class="headerlink" href="#kvm-get-sregs2" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SREGS2</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_sregs2 (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Reads special registers from the vcpu.
This ioctl (when supported) replaces the KVM_GET_SREGS.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_sregs2 {
        /* out (KVM_GET_SREGS2) / in (KVM_SET_SREGS2) */
        struct kvm_segment cs, ds, es, fs, gs, ss;
        struct kvm_segment tr, ldt;
        struct kvm_dtable gdt, idt;
        __u64 cr0, cr2, cr3, cr4, cr8;
        __u64 efer;
        __u64 apic_base;
        __u64 flags;
        __u64 pdptrs[4];
};
</pre></div>
</div>
<p>flags values for <code class="docutils literal notranslate"><span class="pre">kvm_sregs2</span></code>:</p>
<p><code class="docutils literal notranslate"><span class="pre">KVM_SREGS2_FLAGS_PDPTRS_VALID</span></code></p>
<blockquote>
<div><p>Indicates thats the struct contain valid PDPTR values.</p>
</div></blockquote>
</section>
<section id="kvm-set-sregs2">
<h3>4.132 KVM_SET_SREGS2<a class="headerlink" href="#kvm-set-sregs2" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_SREGS2</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_sregs2 (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Writes special registers into the vcpu.
See KVM_GET_SREGS2 for the data structures.
This ioctl (when supported) replaces the KVM_SET_SREGS.</p>
</section>
<section id="kvm-get-stats-fd">
<h3>4.133 KVM_GET_STATS_FD<a class="headerlink" href="#kvm-get-stats-fd" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_STATS_BINARY_FD</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>all</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl, vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>statistics file descriptor on success, &lt; 0 on error</p>
</dd>
</dl>
<p>Errors:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ENOMEM</p></td>
<td><p>if the fd could not be created due to lack of memory</p></td>
</tr>
<tr class="row-even"><td><p>EMFILE</p></td>
<td><p>if the number of opened files exceeds the limit</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The returned file descriptor can be used to read VM/vCPU statistics data in
binary format. The data in the file descriptor consists of four blocks
organized as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Header</p></td>
</tr>
<tr class="row-even"><td><p>id string</p></td>
</tr>
<tr class="row-odd"><td><p>Descriptors</p></td>
</tr>
<tr class="row-even"><td><p>Stats Data</p></td>
</tr>
</tbody>
</table>
<p>Apart from the header starting at offset 0, please be aware that it is
not guaranteed that the four blocks are adjacent or in the above order;
the offsets of the id, descriptors and data blocks are found in the
header.  However, all four blocks are aligned to 64 bit offsets in the
file and they do not overlap.</p>
<p>All blocks except the data block are immutable.  Userspace can read them
only one time after retrieving the file descriptor, and then use <code class="docutils literal notranslate"><span class="pre">pread</span></code> or
<code class="docutils literal notranslate"><span class="pre">lseek</span></code> to read the statistics repeatedly.</p>
<p>All data is in system endianness.</p>
<p>The format of the header is as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_stats_header {
        __u32 flags;
        __u32 name_size;
        __u32 num_desc;
        __u32 id_offset;
        __u32 desc_offset;
        __u32 data_offset;
};
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">flags</span></code> field is not used at the moment. It is always read as 0.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">name_size</span></code> field is the size (in byte) of the statistics name string
(including trailing ‘0’) which is contained in the “id string” block and
appended at the end of every descriptor.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">num_desc</span></code> field is the number of descriptors that are included in the
descriptor block.  (The actual number of values in the data block may be
larger, since each descriptor may comprise more than one value).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">id_offset</span></code> field is the offset of the id string from the start of the
file indicated by the file descriptor. It is a multiple of 8.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">desc_offset</span></code> field is the offset of the Descriptors block from the start
of the file indicated by the file descriptor. It is a multiple of 8.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">data_offset</span></code> field is the offset of the Stats Data block from the start
of the file indicated by the file descriptor. It is a multiple of 8.</p>
<p>The id string block contains a string which identifies the file descriptor on
which KVM_GET_STATS_FD was invoked.  The size of the block, including the
trailing <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>, is indicated by the <code class="docutils literal notranslate"><span class="pre">name_size</span></code> field in the header.</p>
<p>The descriptors block is only needed to be read once for the lifetime of the
file descriptor contains a sequence of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvm_stats_desc</span></code>, each followed
by a string of size <code class="docutils literal notranslate"><span class="pre">name_size</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_STATS_TYPE_SHIFT            0
#define KVM_STATS_TYPE_MASK             (0xF &lt;&lt; KVM_STATS_TYPE_SHIFT)
#define KVM_STATS_TYPE_CUMULATIVE       (0x0 &lt;&lt; KVM_STATS_TYPE_SHIFT)
#define KVM_STATS_TYPE_INSTANT          (0x1 &lt;&lt; KVM_STATS_TYPE_SHIFT)
#define KVM_STATS_TYPE_PEAK             (0x2 &lt;&lt; KVM_STATS_TYPE_SHIFT)
#define KVM_STATS_TYPE_LINEAR_HIST      (0x3 &lt;&lt; KVM_STATS_TYPE_SHIFT)
#define KVM_STATS_TYPE_LOG_HIST         (0x4 &lt;&lt; KVM_STATS_TYPE_SHIFT)
#define KVM_STATS_TYPE_MAX              KVM_STATS_TYPE_LOG_HIST

#define KVM_STATS_UNIT_SHIFT            4
#define KVM_STATS_UNIT_MASK             (0xF &lt;&lt; KVM_STATS_UNIT_SHIFT)
#define KVM_STATS_UNIT_NONE             (0x0 &lt;&lt; KVM_STATS_UNIT_SHIFT)
#define KVM_STATS_UNIT_BYTES            (0x1 &lt;&lt; KVM_STATS_UNIT_SHIFT)
#define KVM_STATS_UNIT_SECONDS          (0x2 &lt;&lt; KVM_STATS_UNIT_SHIFT)
#define KVM_STATS_UNIT_CYCLES           (0x3 &lt;&lt; KVM_STATS_UNIT_SHIFT)
#define KVM_STATS_UNIT_BOOLEAN          (0x4 &lt;&lt; KVM_STATS_UNIT_SHIFT)
#define KVM_STATS_UNIT_MAX              KVM_STATS_UNIT_BOOLEAN

#define KVM_STATS_BASE_SHIFT            8
#define KVM_STATS_BASE_MASK             (0xF &lt;&lt; KVM_STATS_BASE_SHIFT)
#define KVM_STATS_BASE_POW10            (0x0 &lt;&lt; KVM_STATS_BASE_SHIFT)
#define KVM_STATS_BASE_POW2             (0x1 &lt;&lt; KVM_STATS_BASE_SHIFT)
#define KVM_STATS_BASE_MAX              KVM_STATS_BASE_POW2

struct kvm_stats_desc {
        __u32 flags;
        __s16 exponent;
        __u16 size;
        __u32 offset;
        __u32 bucket_size;
        char name[];
};
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">flags</span></code> field contains the type and unit of the statistics data described
by this descriptor. Its endianness is CPU native.
The following flags are supported:</p>
<p>Bits 0-3 of <code class="docutils literal notranslate"><span class="pre">flags</span></code> encode the type:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_TYPE_CUMULATIVE</span></code>
The statistics reports a cumulative count. The value of data can only be increased.
Most of the counters used in KVM are of this type.
The corresponding <code class="docutils literal notranslate"><span class="pre">size</span></code> field for this type is always 1.
All cumulative statistics data are read/write.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_TYPE_INSTANT</span></code>
The statistics reports an instantaneous value. Its value can be increased or
decreased. This type is usually used as a measurement of some resources,
like the number of dirty pages, the number of large pages, etc.
All instant statistics are read only.
The corresponding <code class="docutils literal notranslate"><span class="pre">size</span></code> field for this type is always 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_TYPE_PEAK</span></code>
The statistics data reports a peak value, for example the maximum number
of items in a hash table bucket, the longest time waited and so on.
The value of data can only be increased.
The corresponding <code class="docutils literal notranslate"><span class="pre">size</span></code> field for this type is always 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_TYPE_LINEAR_HIST</span></code>
The statistic is reported as a linear histogram. The number of
buckets is specified by the <code class="docutils literal notranslate"><span class="pre">size</span></code> field. The size of buckets is specified
by the <code class="docutils literal notranslate"><span class="pre">hist_param</span></code> field. The range of the Nth bucket (1 &lt;= N &lt; <code class="docutils literal notranslate"><span class="pre">size</span></code>)
is [<code class="docutils literal notranslate"><span class="pre">hist_param``*(N-1),</span> <span class="pre">``hist_param``*N),</span> <span class="pre">while</span> <span class="pre">the</span> <span class="pre">range</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">last</span>
<span class="pre">bucket</span> <span class="pre">is</span> <span class="pre">[``hist_param``*(``size</span></code>-1), +INF). (+INF means positive infinity
value.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_TYPE_LOG_HIST</span></code>
The statistic is reported as a logarithmic histogram. The number of
buckets is specified by the <code class="docutils literal notranslate"><span class="pre">size</span></code> field. The range of the first bucket is
[0, 1), while the range of the last bucket is [pow(2, <code class="docutils literal notranslate"><span class="pre">size</span></code>-2), +INF).
Otherwise, The Nth bucket (1 &lt; N &lt; <code class="docutils literal notranslate"><span class="pre">size</span></code>) covers
[pow(2, N-2), pow(2, N-1)).</p></li>
</ul>
</div></blockquote>
<p>Bits 4-7 of <code class="docutils literal notranslate"><span class="pre">flags</span></code> encode the unit:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_UNIT_NONE</span></code>
There is no unit for the value of statistics data. This usually means that
the value is a simple counter of an event.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_UNIT_BYTES</span></code>
It indicates that the statistics data is used to measure memory size, in the
unit of Byte, KiByte, MiByte, GiByte, etc. The unit of the data is
determined by the <code class="docutils literal notranslate"><span class="pre">exponent</span></code> field in the descriptor.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_UNIT_SECONDS</span></code>
It indicates that the statistics data is used to measure time or latency.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_UNIT_CYCLES</span></code>
It indicates that the statistics data is used to measure CPU clock cycles.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_UNIT_BOOLEAN</span></code>
It indicates that the statistic will always be either 0 or 1.  Boolean
statistics of “peak” type will never go back from 1 to 0.  Boolean
statistics can be linear histograms (with two buckets) but not logarithmic
histograms.</p></li>
</ul>
</div></blockquote>
<p>Note that, in the case of histograms, the unit applies to the bucket
ranges, while the bucket value indicates how many samples fell in the
bucket’s range.</p>
<p>Bits 8-11 of <code class="docutils literal notranslate"><span class="pre">flags</span></code>, together with <code class="docutils literal notranslate"><span class="pre">exponent</span></code>, encode the scale of the
unit:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_BASE_POW10</span></code>
The scale is based on power of 10. It is used for measurement of time and
CPU clock cycles.  For example, an exponent of -9 can be used with
<code class="docutils literal notranslate"><span class="pre">KVM_STATS_UNIT_SECONDS</span></code> to express that the unit is nanoseconds.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">KVM_STATS_BASE_POW2</span></code>
The scale is based on power of 2. It is used for measurement of memory size.
For example, an exponent of 20 can be used with <code class="docutils literal notranslate"><span class="pre">KVM_STATS_UNIT_BYTES</span></code> to
express that the unit is MiB.</p></li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">size</span></code> field is the number of values of this statistics data. Its
value is usually 1 for most of simple statistics. 1 means it contains an
unsigned 64bit data.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">offset</span></code> field is the offset from the start of Data Block to the start of
the corresponding statistics data.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">bucket_size</span></code> field is used as a parameter for histogram statistics data.
It is only used by linear histogram statistics data, specifying the size of a
bucket in the unit expressed by bits 4-11 of <code class="docutils literal notranslate"><span class="pre">flags</span></code> together with <code class="docutils literal notranslate"><span class="pre">exponent</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">name</span></code> field is the name string of the statistics data. The name string
starts at the end of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvm_stats_desc</span></code>.  The maximum length including
the trailing <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>, is indicated by <code class="docutils literal notranslate"><span class="pre">name_size</span></code> in the header.</p>
<p>The Stats Data block contains an array of 64-bit values in the same order
as the descriptors in Descriptors block.</p>
</section>
<section id="kvm-get-xsave2">
<h3>4.134 KVM_GET_XSAVE2<a class="headerlink" href="#kvm-get-xsave2" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_XSAVE2</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_xsave (out)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_xsave {
      __u32 region[1024];
      __u32 extra[0];
};
</pre></div>
</div>
<p>This ioctl would copy current vcpu’s xsave struct to the userspace. It
copies as many bytes as are returned by KVM_CHECK_EXTENSION(KVM_CAP_XSAVE2)
when invoked on the vm file descriptor. The size value returned by
KVM_CHECK_EXTENSION(KVM_CAP_XSAVE2) will always be at least 4096.
Currently, it is only greater than 4096 if a dynamic feature has been
enabled with <code class="docutils literal notranslate"><span class="pre">arch_prctl()</span></code>, but this may change in the future.</p>
<p>The offsets of the state save areas in struct kvm_xsave follow the contents
of CPUID leaf 0xD on the host.</p>
</section>
<section id="kvm-xen-hvm-evtchn-send">
<h3>4.135 KVM_XEN_HVM_EVTCHN_SEND<a class="headerlink" href="#kvm-xen-hvm-evtchn-send" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_EVTCHN_SEND</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_irq_routing_xen_evtchn</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, &lt; 0 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_irq_routing_xen_evtchn {
     __u32 port;
     __u32 vcpu;
     __u32 priority;
};
</pre></div>
</div>
<p>This ioctl injects an event channel interrupt directly to the guest vCPU.</p>
</section>
<section id="kvm-s390-pv-cpu-command">
<h3>4.136 KVM_S390_PV_CPU_COMMAND<a class="headerlink" href="#kvm-s390-pv-cpu-command" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_PROTECTED_DUMP</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vcpu ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, &lt; 0 on error</p>
</dd>
</dl>
<p>This ioctl closely mirrors <cite>KVM_S390_PV_COMMAND</cite> but handles requests
for vcpus. It re-uses the kvm_s390_pv_dmp struct and hence also shares
the command ids.</p>
<p><strong>command:</strong></p>
<dl class="simple">
<dt>KVM_PV_DUMP</dt><dd><p>Presents an API that provides calls which facilitate dumping a vcpu
of a protected VM.</p>
</dd>
</dl>
<p><strong>subcommand:</strong></p>
<dl class="simple">
<dt>KVM_PV_DUMP_CPU</dt><dd><p>Provides encrypted dump data like register values.
The length of the returned data is provided by uv_info.guest_cpu_stor_len.</p>
</dd>
</dl>
</section>
<section id="kvm-s390-zpci-op">
<h3>4.137 KVM_S390_ZPCI_OP<a class="headerlink" href="#kvm-s390-zpci-op" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_ZPCI_OP</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm ioctl</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>struct kvm_s390_zpci_op (in)</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, &lt;0 on error</p>
</dd>
</dl>
<p>Used to manage hardware-assisted virtualization features for zPCI devices.</p>
<p>Parameters are specified via the following structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_s390_zpci_op {
      /* in */
      __u32 fh;               /* target device */
      __u8  op;               /* operation to perform */
      __u8  pad[3];
      union {
              /* for KVM_S390_ZPCIOP_REG_AEN */
              struct {
                      __u64 ibv;      /* Guest addr of interrupt bit vector */
                      __u64 sb;       /* Guest addr of summary bit */
                      __u32 flags;
                      __u32 noi;      /* Number of interrupts */
                      __u8 isc;       /* Guest interrupt subclass */
                      __u8 sbo;       /* Offset of guest summary bit vector */
                      __u16 pad;
              } reg_aen;
              __u64 reserved[8];
      } u;
};
</pre></div>
</div>
<p>The type of operation is specified in the “op” field.
KVM_S390_ZPCIOP_REG_AEN is used to register the VM for adapter event
notification interpretation, which will allow firmware delivery of adapter
events directly to the vm, with KVM providing a backup delivery mechanism;
KVM_S390_ZPCIOP_DEREG_AEN is used to subsequently disable interpretation of
adapter event notifications.</p>
<p>The target zPCI function must also be specified via the “fh” field.  For the
KVM_S390_ZPCIOP_REG_AEN operation, additional information to establish firmware
delivery must be provided via the “reg_aen” struct.</p>
<p>The “pad” and “reserved” fields may be used for future extensions and should be
set to 0s by userspace.</p>
</section>
</section>
<section id="the-kvm-run-structure">
<h2>5. The kvm_run structure<a class="headerlink" href="#the-kvm-run-structure" title="Permalink to this headline">¶</a></h2>
<p>Application code obtains a pointer to the kvm_run structure by
mmap()ing a vcpu fd.  From that point, application code can control
execution by changing fields in kvm_run prior to calling the KVM_RUN
ioctl, and obtain information about the reason KVM_RUN returned by
looking up structure members.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_run {
      /* in */
      __u8 request_interrupt_window;
</pre></div>
</div>
<p>Request that KVM_RUN return when it becomes possible to inject external
interrupts into the guest.  Useful in conjunction with KVM_INTERRUPT.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u8 immediate_exit;
</pre></div>
</div>
<p>This field is polled once when KVM_RUN starts; if non-zero, KVM_RUN
exits immediately, returning -EINTR.  In the common scenario where a
signal is used to “kick” a VCPU out of KVM_RUN, this field can be used
to avoid usage of KVM_SET_SIGNAL_MASK, which has worse scalability.
Rather than blocking the signal outside KVM_RUN, userspace can set up
a signal handler that sets run-&gt;immediate_exit to a non-zero value.</p>
<p>This field is ignored if KVM_CAP_IMMEDIATE_EXIT is not available.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u8 padding1[6];

/* out */
__u32 exit_reason;
</pre></div>
</div>
<p>When KVM_RUN has returned successfully (return value 0), this informs
application code why KVM_RUN has returned.  Allowable values for this
field are detailed below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u8 ready_for_interrupt_injection;
</pre></div>
</div>
<p>If request_interrupt_window has been specified, this field indicates
an interrupt can be injected now with KVM_INTERRUPT.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u8 if_flag;
</pre></div>
</div>
<p>The value of the current interrupt flag.  Only valid if in-kernel
local APIC is not used.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u16 flags;
</pre></div>
</div>
<p>More architecture-specific flags detailing state of the VCPU that may
affect the device’s behavior. Current defined flags:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* x86, set if the VCPU is in system management mode */
#define KVM_RUN_X86_SMM     (1 &lt;&lt; 0)
/* x86, set if bus lock detected in VM */
#define KVM_RUN_BUS_LOCK    (1 &lt;&lt; 1)
/* arm64, set for KVM_EXIT_DEBUG */
#define KVM_DEBUG_ARCH_HSR_HIGH_VALID  (1 &lt;&lt; 0)
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* in (pre_kvm_run), out (post_kvm_run) */
__u64 cr8;
</pre></div>
</div>
<p>The value of the cr8 register.  Only valid if in-kernel local APIC is
not used.  Both input and output.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u64 apic_base;
</pre></div>
</div>
<p>The value of the APIC BASE msr.  Only valid if in-kernel local
APIC is not used.  Both input and output.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>union {
        /* KVM_EXIT_UNKNOWN */
        struct {
                __u64 hardware_exit_reason;
        } hw;
</pre></div>
</div>
<p>If exit_reason is KVM_EXIT_UNKNOWN, the vcpu has exited due to unknown
reasons.  Further architecture-specific information is available in
hardware_exit_reason.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_FAIL_ENTRY */
struct {
        __u64 hardware_entry_failure_reason;
        __u32 cpu; /* if KVM_LAST_CPU */
} fail_entry;
</pre></div>
</div>
<p>If exit_reason is KVM_EXIT_FAIL_ENTRY, the vcpu could not be run due
to unknown reasons.  Further architecture-specific information is
available in hardware_entry_failure_reason.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_EXCEPTION */
struct {
        __u32 exception;
        __u32 error_code;
} ex;
</pre></div>
</div>
<p>Unused.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>              /* KVM_EXIT_IO */
              struct {
#define KVM_EXIT_IO_IN  0
#define KVM_EXIT_IO_OUT 1
                      __u8 direction;
                      __u8 size; /* bytes */
                      __u16 port;
                      __u32 count;
                      __u64 data_offset; /* relative to kvm_run start */
              } io;
</pre></div>
</div>
<p>If exit_reason is KVM_EXIT_IO, then the vcpu has
executed a port I/O instruction which could not be satisfied by kvm.
data_offset describes where the data is located (KVM_EXIT_IO_OUT) or
where kvm expects application code to place the data for the next
KVM_RUN invocation (KVM_EXIT_IO_IN).  Data format is a packed array.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_DEBUG */
struct {
        struct kvm_debug_exit_arch arch;
} debug;
</pre></div>
</div>
<p>If the exit_reason is KVM_EXIT_DEBUG, then a vcpu is processing a debug event
for which architecture specific information is returned.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_MMIO */
struct {
        __u64 phys_addr;
        __u8  data[8];
        __u32 len;
        __u8  is_write;
} mmio;
</pre></div>
</div>
<p>If exit_reason is KVM_EXIT_MMIO, then the vcpu has
executed a memory-mapped I/O instruction which could not be satisfied
by kvm.  The ‘data’ member contains the written data if ‘is_write’ is
true, and should be filled by application code otherwise.</p>
<p>The ‘data’ member contains, in its first ‘len’ bytes, the value as it would
appear if the VCPU performed a load or store of the appropriate width directly
to the byte array.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For KVM_EXIT_IO, KVM_EXIT_MMIO, KVM_EXIT_OSI, KVM_EXIT_PAPR, KVM_EXIT_XEN,
KVM_EXIT_EPR, KVM_EXIT_X86_RDMSR and KVM_EXIT_X86_WRMSR the corresponding
operations are complete (and guest state is consistent) only after userspace
has re-entered the kernel with KVM_RUN.  The kernel side will first finish
incomplete operations and then check for pending signals.</p>
<p>The pending state of the operation is not preserved in state which is
visible to userspace, thus userspace should ensure that the operation is
completed before performing a live migration.  Userspace can re-enter the
guest with an unmasked signal pending or with the immediate_exit field set
to complete pending operations without allowing any further instructions
to be executed.</p>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_HYPERCALL */
struct {
        __u64 nr;
        __u64 args[6];
        __u64 ret;
        __u32 longmode;
        __u32 pad;
} hypercall;
</pre></div>
</div>
<p>Unused.  This was once used for ‘hypercall to userspace’.  To implement
such functionality, use KVM_EXIT_IO (x86) or KVM_EXIT_MMIO (all except s390).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>KVM_EXIT_IO is significantly faster than KVM_EXIT_MMIO.</p>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_TPR_ACCESS */
struct {
        __u64 rip;
        __u32 is_write;
        __u32 pad;
} tpr_access;
</pre></div>
</div>
<p>To be documented (KVM_TPR_ACCESS_REPORTING).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_S390_SIEIC */
struct {
        __u8 icptcode;
        __u64 mask; /* psw upper half */
        __u64 addr; /* psw lower half */
        __u16 ipa;
        __u32 ipb;
} s390_sieic;
</pre></div>
</div>
<p>s390 specific.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>              /* KVM_EXIT_S390_RESET */
#define KVM_S390_RESET_POR       1
#define KVM_S390_RESET_CLEAR     2
#define KVM_S390_RESET_SUBSYSTEM 4
#define KVM_S390_RESET_CPU_INIT  8
#define KVM_S390_RESET_IPL       16
              __u64 s390_reset_flags;
</pre></div>
</div>
<p>s390 specific.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_S390_UCONTROL */
struct {
        __u64 trans_exc_code;
        __u32 pgm_code;
} s390_ucontrol;
</pre></div>
</div>
<p>s390 specific. A page fault has occurred for a user controlled virtual
machine (KVM_VM_S390_UNCONTROL) on it’s host page table that cannot be
resolved by the kernel.
The program code and the translation exception code that were placed
in the cpu’s lowcore are presented here as defined by the z Architecture
Principles of Operation Book in the Chapter for Dynamic Address Translation
(DAT)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_DCR */
struct {
        __u32 dcrn;
        __u32 data;
        __u8  is_write;
} dcr;
</pre></div>
</div>
<p>Deprecated - was used for 440 KVM.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_OSI */
struct {
        __u64 gprs[32];
} osi;
</pre></div>
</div>
<p>MOL uses a special hypercall interface it calls ‘OSI’. To enable it, we catch
hypercalls and exit with this exit struct that contains all the guest gprs.</p>
<p>If exit_reason is KVM_EXIT_OSI, then the vcpu has triggered such a hypercall.
Userspace can now handle the hypercall and when it’s done modify the gprs as
necessary. Upon guest entry all guest GPRs will then be replaced by the values
in this struct.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_PAPR_HCALL */
struct {
        __u64 nr;
        __u64 ret;
        __u64 args[9];
} papr_hcall;
</pre></div>
</div>
<p>This is used on 64-bit PowerPC when emulating a pSeries partition,
e.g. with the ‘pseries’ machine type in qemu.  It occurs when the
guest does a hypercall using the ‘sc 1’ instruction.  The ‘nr’ field
contains the hypercall number (from the guest R3), and ‘args’ contains
the arguments (from the guest R4 - R12).  Userspace should put the
return code in ‘ret’ and any extra returned values in args[].
The possible hypercalls are defined in the Power Architecture Platform
Requirements (PAPR) document available from www.power.org (free
developer registration required to access it).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_S390_TSCH */
struct {
        __u16 subchannel_id;
        __u16 subchannel_nr;
        __u32 io_int_parm;
        __u32 io_int_word;
        __u32 ipb;
        __u8 dequeued;
} s390_tsch;
</pre></div>
</div>
<p>s390 specific. This exit occurs when KVM_CAP_S390_CSS_SUPPORT has been enabled
and TEST SUBCHANNEL was intercepted. If dequeued is set, a pending I/O
interrupt for the target subchannel has been dequeued and subchannel_id,
subchannel_nr, io_int_parm and io_int_word contain the parameters for that
interrupt. ipb is needed for instruction parameter decoding.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_EPR */
struct {
        __u32 epr;
} epr;
</pre></div>
</div>
<p>On FSL BookE PowerPC chips, the interrupt controller has a fast patch
interrupt acknowledge path to the core. When the core successfully
delivers an interrupt, it automatically populates the EPR register with
the interrupt vector number and acknowledges the interrupt inside
the interrupt controller.</p>
<p>In case the interrupt controller lives in user space, we need to do
the interrupt acknowledge cycle through it to fetch the next to be
delivered interrupt vector using this exit.</p>
<p>It gets triggered whenever both KVM_CAP_PPC_EPR are enabled and an
external interrupt has just been delivered into the guest. User space
should put the acknowledged interrupt vector into the ‘epr’ field.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>              /* KVM_EXIT_SYSTEM_EVENT */
              struct {
#define KVM_SYSTEM_EVENT_SHUTDOWN       1
#define KVM_SYSTEM_EVENT_RESET          2
#define KVM_SYSTEM_EVENT_CRASH          3
#define KVM_SYSTEM_EVENT_WAKEUP         4
#define KVM_SYSTEM_EVENT_SUSPEND        5
#define KVM_SYSTEM_EVENT_SEV_TERM       6
                      __u32 type;
                      __u32 ndata;
                      __u64 data[16];
              } system_event;
</pre></div>
</div>
<p>If exit_reason is KVM_EXIT_SYSTEM_EVENT then the vcpu has triggered
a system-level event using some architecture specific mechanism (hypercall
or some special instruction). In case of ARM64, this is triggered using
HVC instruction based PSCI call from the vcpu.</p>
<p>The ‘type’ field describes the system-level event type.
Valid values for ‘type’ are:</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_SYSTEM_EVENT_SHUTDOWN – the guest has requested a shutdown of the
VM. Userspace is not obliged to honour this, and if it does honour
this does not need to destroy the VM synchronously (ie it may call
KVM_RUN again before shutdown finally occurs).</p></li>
<li><p>KVM_SYSTEM_EVENT_RESET – the guest has requested a reset of the VM.
As with SHUTDOWN, userspace can choose to ignore the request, or
to schedule the reset to occur in the future and may call KVM_RUN again.</p></li>
<li><p>KVM_SYSTEM_EVENT_CRASH – the guest crash occurred and the guest
has requested a crash condition maintenance. Userspace can choose
to ignore the request, or to gather VM memory core dump and/or
reset/shutdown of the VM.</p></li>
<li><p>KVM_SYSTEM_EVENT_SEV_TERM – an AMD SEV guest requested termination.
The guest physical address of the guest’s GHCB is stored in <cite>data[0]</cite>.</p></li>
<li><p>KVM_SYSTEM_EVENT_WAKEUP – the exiting vCPU is in a suspended state and
KVM has recognized a wakeup event. Userspace may honor this event by
marking the exiting vCPU as runnable, or deny it and call KVM_RUN again.</p></li>
<li><p>KVM_SYSTEM_EVENT_SUSPEND – the guest has requested a suspension of
the VM.</p></li>
</ul>
</div></blockquote>
<p>If KVM_CAP_SYSTEM_EVENT_DATA is present, the ‘data’ field can contain
architecture specific information for the system-level event.  Only
the first <cite>ndata</cite> items (possibly zero) of the data array are valid.</p>
<blockquote>
<div><ul class="simple">
<li><p>for arm64, data[0] is set to KVM_SYSTEM_EVENT_RESET_FLAG_PSCI_RESET2 if
the guest issued a SYSTEM_RESET2 call according to v1.1 of the PSCI
specification.</p></li>
<li><p>for RISC-V, data[0] is set to the value of the second argument of the
<code class="docutils literal notranslate"><span class="pre">sbi_system_reset</span></code> call.</p></li>
</ul>
</div></blockquote>
<p>Previous versions of Linux defined a <cite>flags</cite> member in this struct.  The
field is now aliased to <cite>data[0]</cite>.  Userspace can assume that it is only
written if ndata is greater than 0.</p>
<section id="for-arm-arm64">
<h3>For arm/arm64:<a class="headerlink" href="#for-arm-arm64" title="Permalink to this headline">¶</a></h3>
<p>KVM_SYSTEM_EVENT_SUSPEND exits are enabled with the
KVM_CAP_ARM_SYSTEM_SUSPEND VM capability. If a guest invokes the PSCI
SYSTEM_SUSPEND function, KVM will exit to userspace with this event
type.</p>
<p>It is the sole responsibility of userspace to implement the PSCI
SYSTEM_SUSPEND call according to ARM DEN0022D.b 5.19 “SYSTEM_SUSPEND”.
KVM does not change the vCPU’s state before exiting to userspace, so
the call parameters are left in-place in the vCPU registers.</p>
<p>Userspace is _required_ to take action for such an exit. It must
either:</p>
<blockquote>
<div><ul class="simple">
<li><p>Honor the guest request to suspend the VM. Userspace can request
in-kernel emulation of suspension by setting the calling vCPU’s
state to KVM_MP_STATE_SUSPENDED. Userspace must configure the vCPU’s
state according to the parameters passed to the PSCI function when
the calling vCPU is resumed. See ARM DEN0022D.b 5.19.1 “Intended use”
for details on the function parameters.</p></li>
<li><p>Deny the guest request to suspend the VM. See ARM DEN0022D.b 5.19.2
“Caller responsibilities” for possible return values.</p></li>
</ul>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_IOAPIC_EOI */
struct {
        __u8 vector;
} eoi;
</pre></div>
</div>
<p>Indicates that the VCPU’s in-kernel local APIC received an EOI for a
level-triggered IOAPIC interrupt.  This exit only triggers when the
IOAPIC is implemented in userspace (i.e. KVM_CAP_SPLIT_IRQCHIP is enabled);
the userspace IOAPIC should process the EOI and retrigger the interrupt if
it is still asserted.  Vector is the LAPIC interrupt vector for which the
EOI was received.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>              struct kvm_hyperv_exit {
#define KVM_EXIT_HYPERV_SYNIC          1
#define KVM_EXIT_HYPERV_HCALL          2
#define KVM_EXIT_HYPERV_SYNDBG         3
                      __u32 type;
                      __u32 pad1;
                      union {
                              struct {
                                      __u32 msr;
                                      __u32 pad2;
                                      __u64 control;
                                      __u64 evt_page;
                                      __u64 msg_page;
                              } synic;
                              struct {
                                      __u64 input;
                                      __u64 result;
                                      __u64 params[2];
                              } hcall;
                              struct {
                                      __u32 msr;
                                      __u32 pad2;
                                      __u64 control;
                                      __u64 status;
                                      __u64 send_page;
                                      __u64 recv_page;
                                      __u64 pending_page;
                              } syndbg;
                      } u;
              };
              /* KVM_EXIT_HYPERV */
              struct kvm_hyperv_exit hyperv;
</pre></div>
</div>
<p>Indicates that the VCPU exits into userspace to process some tasks
related to Hyper-V emulation.</p>
<p>Valid values for ‘type’ are:</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_EXIT_HYPERV_SYNIC – synchronously notify user-space about</p></li>
</ul>
</div></blockquote>
<p>Hyper-V SynIC state change. Notification is used to remap SynIC
event/message pages and to enable/disable SynIC messages/events processing
in userspace.</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_EXIT_HYPERV_SYNDBG – synchronously notify user-space about</p></li>
</ul>
</div></blockquote>
<p>Hyper-V Synthetic debugger state change. Notification is used to either update
the pending_page location or to send a control command (send the buffer located
in send_page or recv a buffer to recv_page).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_ARM_NISV */
struct {
        __u64 esr_iss;
        __u64 fault_ipa;
} arm_nisv;
</pre></div>
</div>
<p>Used on arm64 systems. If a guest accesses memory not in a memslot,
KVM will typically return to userspace and ask it to do MMIO emulation on its
behalf. However, for certain classes of instructions, no instruction decode
(direction, length of memory access) is provided, and fetching and decoding
the instruction from the VM is overly complicated to live in the kernel.</p>
<p>Historically, when this situation occurred, KVM would print a warning and kill
the VM. KVM assumed that if the guest accessed non-memslot memory, it was
trying to do I/O, which just couldn’t be emulated, and the warning message was
phrased accordingly. However, what happened more often was that a guest bug
caused access outside the guest memory areas which should lead to a more
meaningful warning message and an external abort in the guest, if the access
did not fall within an I/O window.</p>
<p>Userspace implementations can query for KVM_CAP_ARM_NISV_TO_USER, and enable
this capability at VM creation. Once this is done, these types of errors will
instead return to userspace with KVM_EXIT_ARM_NISV, with the valid bits from
the ESR_EL2 in the esr_iss field, and the faulting IPA in the fault_ipa field.
Userspace can either fix up the access if it’s actually an I/O access by
decoding the instruction from guest memory (if it’s very brave) and continue
executing the guest, or it can decide to suspend, dump, or restart the guest.</p>
<p>Note that KVM does not skip the faulting instruction as it does for
KVM_EXIT_MMIO, but userspace has to emulate any change to the processing state
if it decides to decode and emulate the instruction.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_X86_RDMSR / KVM_EXIT_X86_WRMSR */
struct {
        __u8 error; /* user -&gt; kernel */
        __u8 pad[7];
        __u32 reason; /* kernel -&gt; user */
        __u32 index; /* kernel -&gt; user */
        __u64 data; /* kernel &lt;-&gt; user */
} msr;
</pre></div>
</div>
<p>Used on x86 systems. When the VM capability KVM_CAP_X86_USER_SPACE_MSR is
enabled, MSR accesses to registers that would invoke a #GP by KVM kernel code
may instead trigger a KVM_EXIT_X86_RDMSR exit for reads and KVM_EXIT_X86_WRMSR
exit for writes.</p>
<p>The “reason” field specifies why the MSR interception occurred. Userspace will
only receive MSR exits when a particular reason was requested during through
ENABLE_CAP. Currently valid exit reasons are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>KVM_MSR_EXIT_REASON_UNKNOWN</p></td>
<td><p>access to MSR that is unknown to KVM</p></td>
</tr>
<tr class="row-even"><td><p>KVM_MSR_EXIT_REASON_INVAL</p></td>
<td><p>access to invalid MSRs or reserved bits</p></td>
</tr>
<tr class="row-odd"><td><p>KVM_MSR_EXIT_REASON_FILTER</p></td>
<td><p>access blocked by KVM_X86_SET_MSR_FILTER</p></td>
</tr>
</tbody>
</table>
<p>For KVM_EXIT_X86_RDMSR, the “index” field tells userspace which MSR the guest
wants to read. To respond to this request with a successful read, userspace
writes the respective data into the “data” field and must continue guest
execution to ensure the read data is transferred into guest register state.</p>
<p>If the RDMSR request was unsuccessful, userspace indicates that with a “1” in
the “error” field. This will inject a #GP into the guest when the VCPU is
executed again.</p>
<p>For KVM_EXIT_X86_WRMSR, the “index” field tells userspace which MSR the guest
wants to write. Once finished processing the event, userspace must continue
vCPU execution. If the MSR write was unsuccessful, userspace also sets the
“error” field to “1”.</p>
<p>See KVM_X86_SET_MSR_FILTER for details on the interaction with MSR filtering.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>              struct kvm_xen_exit {
#define KVM_EXIT_XEN_HCALL          1
                      __u32 type;
                      union {
                              struct {
                                      __u32 longmode;
                                      __u32 cpl;
                                      __u64 input;
                                      __u64 result;
                                      __u64 params[6];
                              } hcall;
                      } u;
              };
              /* KVM_EXIT_XEN */
              struct kvm_hyperv_exit xen;
</pre></div>
</div>
<p>Indicates that the VCPU exits into userspace to process some tasks
related to Xen emulation.</p>
<p>Valid values for ‘type’ are:</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_EXIT_XEN_HCALL – synchronously notify user-space about Xen hypercall.
Userspace is expected to place the hypercall result into the appropriate
field before invoking KVM_RUN again.</p></li>
</ul>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* KVM_EXIT_RISCV_SBI */
struct {
        unsigned long extension_id;
        unsigned long function_id;
        unsigned long args[6];
        unsigned long ret[2];
} riscv_sbi;
</pre></div>
</div>
<p>If exit reason is KVM_EXIT_RISCV_SBI then it indicates that the VCPU has
done a SBI call which is not handled by KVM RISC-V kernel module. The details
of the SBI call are available in ‘riscv_sbi’ member of kvm_run structure. The
‘extension_id’ field of ‘riscv_sbi’ represents SBI extension ID whereas the
‘function_id’ field represents function ID of given SBI extension. The ‘args’
array field of ‘riscv_sbi’ represents parameters for the SBI call and ‘ret’
array field represents return values. The userspace should update the return
values of SBI call before resuming the VCPU. For more details on RISC-V SBI
spec refer, <a class="reference external" href="https://github.com/riscv/riscv-sbi-doc">https://github.com/riscv/riscv-sbi-doc</a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  /* KVM_EXIT_NOTIFY */
  struct {
#define KVM_NOTIFY_CONTEXT_INVALID    (1 &lt;&lt; 0)
    __u32 flags;
  } notify;
</pre></div>
</div>
<p>Used on x86 systems. When the VM capability KVM_CAP_X86_NOTIFY_VMEXIT is
enabled, a VM exit generated if no event window occurs in VM non-root mode
for a specified amount of time. Once KVM_X86_NOTIFY_VMEXIT_USER is set when
enabling the cap, it would exit to userspace with the exit reason
KVM_EXIT_NOTIFY for further handling. The “flags” field contains more
detailed info.</p>
<p>The valid value for ‘flags’ is:</p>
<blockquote>
<div><ul class="simple">
<li><p>KVM_NOTIFY_CONTEXT_INVALID – the VM context is corrupted and not valid
in VMCS. It would run into unknown result if resume the target VM.</p></li>
</ul>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        /* Fix the size of the union. */
        char padding[256];
};

/*
 * shared registers between kvm and userspace.
 * kvm_valid_regs specifies the register classes set by the host
 * kvm_dirty_regs specified the register classes dirtied by userspace
 * struct kvm_sync_regs is architecture specific, as well as the
 * bits for kvm_valid_regs and kvm_dirty_regs
 */
__u64 kvm_valid_regs;
__u64 kvm_dirty_regs;
union {
        struct kvm_sync_regs regs;
        char padding[SYNC_REGS_SIZE_BYTES];
} s;
</pre></div>
</div>
<p>If KVM_CAP_SYNC_REGS is defined, these fields allow userspace to access
certain guest registers without having to call SET/GET_*REGS. Thus we can
avoid some system call overhead if userspace has to handle the exit.
Userspace can query the validity of the structure by checking
kvm_valid_regs for specific bits. These bits are architecture specific
and usually define the validity of a groups of registers. (e.g. one bit
for general purpose registers)</p>
<p>Please note that the kernel is allowed to use the kvm_run structure as the
primary storage for certain register types. Therefore, the kernel may use the
values in kvm_run even if the corresponding bit in kvm_dirty_regs is not set.</p>
</section>
</section>
<section id="capabilities-that-can-be-enabled-on-vcpus">
<h2>6. Capabilities that can be enabled on vCPUs<a class="headerlink" href="#capabilities-that-can-be-enabled-on-vcpus" title="Permalink to this headline">¶</a></h2>
<p>There are certain capabilities that change the behavior of the virtual CPU or
the virtual machine when enabled. To enable them, please see section 4.37.
Below you can find a list of capabilities and what their effect on the vCPU or
the virtual machine is when enabling them.</p>
<p>The following information is provided along with the description:</p>
<blockquote>
<div><dl class="simple">
<dt>Architectures:</dt><dd><p>which instruction set architectures provide this ioctl.
x86 includes both i386 and x86_64.</p>
</dd>
<dt>Target:</dt><dd><p>whether this is a per-vcpu or per-vm capability.</p>
</dd>
<dt>Parameters:</dt><dd><p>what parameters are accepted by the capability.</p>
</dd>
<dt>Returns:</dt><dd><p>the return value.  General error numbers (EBADF, ENOMEM, EINVAL)
are not detailed, but errors with specific meanings are.</p>
</dd>
</dl>
</div></blockquote>
<section id="kvm-cap-ppc-osi">
<h3>6.1 KVM_CAP_PPC_OSI<a class="headerlink" href="#kvm-cap-ppc-osi" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>vcpu</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>none</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>This capability enables interception of OSI hypercalls that otherwise would
be treated as normal system calls to be injected into the guest. OSI hypercalls
were invented by Mac-on-Linux to have a standardized communication mechanism
between the guest and the host.</p>
<p>When this capability is enabled, KVM_EXIT_OSI can occur.</p>
</section>
<section id="kvm-cap-ppc-papr">
<h3>6.2 KVM_CAP_PPC_PAPR<a class="headerlink" href="#kvm-cap-ppc-papr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>vcpu</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>none</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>This capability enables interception of PAPR hypercalls. PAPR hypercalls are
done using the hypercall instruction “sc 1”.</p>
<p>It also sets the guest privilege level to “supervisor” mode. Usually the guest
runs in “hypervisor” privilege mode with a few missing features.</p>
<p>In addition to the above, it changes the semantics of SDR1. In this mode, the
HTAB address part of SDR1 contains an HVA instead of a GPA, as PAPR keeps the
HTAB invisible to the guest.</p>
<p>When this capability is enabled, KVM_EXIT_PAPR_HCALL can occur.</p>
</section>
<section id="kvm-cap-sw-tlb">
<h3>6.3 KVM_CAP_SW_TLB<a class="headerlink" href="#kvm-cap-sw-tlb" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>vcpu</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] is the address of a struct kvm_config_tlb</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success; -1 on error</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_config_tlb {
      __u64 params;
      __u64 array;
      __u32 mmu_type;
      __u32 array_len;
};
</pre></div>
</div>
<p>Configures the virtual CPU’s TLB array, establishing a shared memory area
between userspace and KVM.  The “params” and “array” fields are userspace
addresses of mmu-type-specific data structures.  The “array_len” field is an
safety mechanism, and should be set to the size in bytes of the memory that
userspace has reserved for the array.  It must be at least the size dictated
by “mmu_type” and “params”.</p>
<p>While KVM_RUN is active, the shared region is under control of KVM.  Its
contents are undefined, and any modification by userspace results in
boundedly undefined behavior.</p>
<p>On return from KVM_RUN, the shared region will reflect the current state of
the guest’s TLB.  If userspace makes any changes, it must call KVM_DIRTY_TLB
to tell KVM which entries have been changed, prior to calling KVM_RUN again
on this vcpu.</p>
<p>For mmu types KVM_MMU_FSL_BOOKE_NOHV and KVM_MMU_FSL_BOOKE_HV:</p>
<blockquote>
<div><ul class="simple">
<li><p>The “params” field is of type “struct kvm_book3e_206_tlb_params”.</p></li>
<li><p>The “array” field points to an array of type “struct
kvm_book3e_206_tlb_entry”.</p></li>
<li><p>The array consists of all entries in the first TLB, followed by all
entries in the second TLB.</p></li>
<li><p>Within a TLB, entries are ordered first by increasing set number.  Within a
set, entries are ordered by way (increasing ESEL).</p></li>
<li><p>The hash for determining set number in TLB0 is: (MAS2 &gt;&gt; 12) &amp; (num_sets - 1)
where “num_sets” is the tlb_sizes[] value divided by the tlb_ways[] value.</p></li>
<li><p>The tsize field of mas1 shall be set to 4K on TLB0, even though the
hardware ignores this value for TLB0.</p></li>
</ul>
</div></blockquote>
</section>
<section id="kvm-cap-s390-css-support">
<h3>6.4 KVM_CAP_S390_CSS_SUPPORT<a class="headerlink" href="#kvm-cap-s390-css-support" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>vcpu</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>none</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>This capability enables support for handling of channel I/O instructions.</p>
<p>TEST PENDING INTERRUPTION and the interrupt portion of TEST SUBCHANNEL are
handled in-kernel, while the other I/O instructions are passed to userspace.</p>
<p>When this capability is enabled, KVM_EXIT_S390_TSCH will occur on TEST
SUBCHANNEL intercepts.</p>
<p>Note that even though this capability is enabled per-vcpu, the complete
virtual machine is affected.</p>
</section>
<section id="kvm-cap-ppc-epr">
<h3>6.5 KVM_CAP_PPC_EPR<a class="headerlink" href="#kvm-cap-ppc-epr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>vcpu</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] defines whether the proxy facility is active</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>This capability enables or disables the delivery of interrupts through the
external proxy facility.</p>
<p>When enabled (args[0] != 0), every time the guest gets an external interrupt
delivered, it automatically exits into user space with a KVM_EXIT_EPR exit
to receive the topmost interrupt vector.</p>
<p>When disabled (args[0] == 0), behavior is as if this facility is unsupported.</p>
<p>When this capability is enabled, KVM_EXIT_EPR can occur.</p>
</section>
<section id="kvm-cap-irq-mpic">
<h3>6.6 KVM_CAP_IRQ_MPIC<a class="headerlink" href="#kvm-cap-irq-mpic" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>args[0] is the MPIC device fd;
args[1] is the MPIC CPU number for this vcpu</p>
</dd>
</dl>
<p>This capability connects the vcpu to an in-kernel MPIC device.</p>
</section>
<section id="kvm-cap-irq-xics">
<h3>6.7 KVM_CAP_IRQ_XICS<a class="headerlink" href="#kvm-cap-irq-xics" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>vcpu</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] is the XICS device fd;
args[1] is the XICS CPU number (server ID) for this vcpu</p>
</dd>
</dl>
<p>This capability connects the vcpu to an in-kernel XICS device.</p>
</section>
<section id="kvm-cap-s390-irqchip">
<h3>6.8 KVM_CAP_S390_IRQCHIP<a class="headerlink" href="#kvm-cap-s390-irqchip" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>vm</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>none</p>
</dd>
</dl>
<p>This capability enables the in-kernel irqchip for s390. Please refer to
“4.24 KVM_CREATE_IRQCHIP” for details.</p>
</section>
<section id="kvm-cap-mips-fpu">
<h3>6.9 KVM_CAP_MIPS_FPU<a class="headerlink" href="#kvm-cap-mips-fpu" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>mips</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>vcpu</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] is reserved for future use (should be 0).</p>
</dd>
</dl>
<p>This capability allows the use of the host Floating Point Unit by the guest. It
allows the Config1.FP bit to be set to enable the FPU in the guest. Once this is
done the <code class="docutils literal notranslate"><span class="pre">KVM_REG_MIPS_FPR_*</span></code> and <code class="docutils literal notranslate"><span class="pre">KVM_REG_MIPS_FCR_*</span></code> registers can be
accessed (depending on the current guest FPU register mode), and the Status.FR,
Config5.FRE bits are accessible via the KVM API and also from the guest,
depending on them being supported by the FPU.</p>
</section>
<section id="kvm-cap-mips-msa">
<h3>6.10 KVM_CAP_MIPS_MSA<a class="headerlink" href="#kvm-cap-mips-msa" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>mips</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>vcpu</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] is reserved for future use (should be 0).</p>
</dd>
</dl>
<p>This capability allows the use of the MIPS SIMD Architecture (MSA) by the guest.
It allows the Config3.MSAP bit to be set to enable the use of MSA by the guest.
Once this is done the <code class="docutils literal notranslate"><span class="pre">KVM_REG_MIPS_VEC_*</span></code> and <code class="docutils literal notranslate"><span class="pre">KVM_REG_MIPS_MSA_*</span></code>
registers can be accessed, and the Config5.MSAEn bit is accessible via the
KVM API and also from the guest.</p>
</section>
<section id="kvm-cap-sync-regs">
<h3>6.74 KVM_CAP_SYNC_REGS<a class="headerlink" href="#kvm-cap-sync-regs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390, x86</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>s390: always enabled, x86: vcpu</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>none</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>x86: KVM_CHECK_EXTENSION returns a bit-array indicating which register
sets are supported
(bitfields defined in arch/x86/include/uapi/asm/kvm.h).</p>
</dd>
</dl>
<p>As described above in the kvm_sync_regs struct info in section 5 (kvm_run):
KVM_CAP_SYNC_REGS “allow[s] userspace to access certain guest registers
without having to call SET/GET_*REGS”. This reduces overhead by eliminating
repeated ioctl calls for setting and/or getting register values. This is
particularly important when userspace is making synchronous guest state
modifications, e.g. when emulating and/or intercepting instructions in
userspace.</p>
<p>For s390 specifics, please refer to the source code.</p>
<p>For x86:</p>
<ul class="simple">
<li><p>the register sets to be copied out to kvm_run are selectable
by userspace (rather that all sets being copied out for every exit).</p></li>
<li><p>vcpu_events are available in addition to regs and sregs.</p></li>
</ul>
<p>For x86, the ‘kvm_valid_regs’ field of struct kvm_run is overloaded to
function as an input bit-array field set by userspace to indicate the
specific register sets to be copied out on the next exit.</p>
<p>To indicate when userspace has modified values that should be copied into
the vCPU, the all architecture bitarray field, ‘kvm_dirty_regs’ must be set.
This is done using the same bitflags as for the ‘kvm_valid_regs’ field.
If the dirty bit is not set, then the register set values will not be copied
into the vCPU even if they’ve been modified.</p>
<p>Unused bitfields in the bitarrays must be set to zero.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_sync_regs {
      struct kvm_regs regs;
      struct kvm_sregs sregs;
      struct kvm_vcpu_events events;
};
</pre></div>
</div>
</section>
<section id="kvm-cap-ppc-irq-xive">
<h3>6.75 KVM_CAP_PPC_IRQ_XIVE<a class="headerlink" href="#kvm-cap-ppc-irq-xive" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>vcpu</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] is the XIVE device fd;
args[1] is the XIVE CPU number (server ID) for this vcpu</p>
</dd>
</dl>
<p>This capability connects the vcpu to an in-kernel XIVE device.</p>
</section>
</section>
<section id="capabilities-that-can-be-enabled-on-vms">
<h2>7. Capabilities that can be enabled on VMs<a class="headerlink" href="#capabilities-that-can-be-enabled-on-vms" title="Permalink to this headline">¶</a></h2>
<p>There are certain capabilities that change the behavior of the virtual
machine when enabled. To enable them, please see section 4.37. Below
you can find a list of capabilities and what their effect on the VM
is when enabling them.</p>
<p>The following information is provided along with the description:</p>
<blockquote>
<div><dl class="simple">
<dt>Architectures:</dt><dd><p>which instruction set architectures provide this ioctl.
x86 includes both i386 and x86_64.</p>
</dd>
<dt>Parameters:</dt><dd><p>what parameters are accepted by the capability.</p>
</dd>
<dt>Returns:</dt><dd><p>the return value.  General error numbers (EBADF, ENOMEM, EINVAL)
are not detailed, but errors with specific meanings are.</p>
</dd>
</dl>
</div></blockquote>
<section id="kvm-cap-ppc-enable-hcall">
<h3>7.1 KVM_CAP_PPC_ENABLE_HCALL<a class="headerlink" href="#kvm-cap-ppc-enable-hcall" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>args[0] is the sPAPR hcall number;
args[1] is 0 to disable, 1 to enable in-kernel handling</p>
</dd>
</dl>
<p>This capability controls whether individual sPAPR hypercalls (hcalls)
get handled by the kernel or not.  Enabling or disabling in-kernel
handling of an hcall is effective across the VM.  On creation, an
initial set of hcalls are enabled for in-kernel handling, which
consists of those hcalls for which in-kernel handlers were implemented
before this capability was implemented.  If disabled, the kernel will
not to attempt to handle the hcall, but will always exit to userspace
to handle it.  Note that it may not make sense to enable some and
disable others of a group of related hcalls, but KVM does not prevent
userspace from doing that.</p>
<p>If the hcall number specified is not one that has an in-kernel
implementation, the KVM_ENABLE_CAP ioctl will fail with an EINVAL
error.</p>
</section>
<section id="kvm-cap-s390-user-sigp">
<h3>7.2 KVM_CAP_S390_USER_SIGP<a class="headerlink" href="#kvm-cap-s390-user-sigp" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
</dl>
<p>This capability controls which SIGP orders will be handled completely in user
space. With this capability enabled, all fast orders will be handled completely
in the kernel:</p>
<ul class="simple">
<li><p>SENSE</p></li>
<li><p>SENSE RUNNING</p></li>
<li><p>EXTERNAL CALL</p></li>
<li><p>EMERGENCY SIGNAL</p></li>
<li><p>CONDITIONAL EMERGENCY SIGNAL</p></li>
</ul>
<p>All other orders will be handled completely in user space.</p>
<p>Only privileged operation exceptions will be checked for in the kernel (or even
in the hardware prior to interception). If this capability is not enabled, the
old way of handling SIGP orders is used (partially in kernel and user space).</p>
</section>
<section id="kvm-cap-s390-vector-registers">
<h3>7.3 KVM_CAP_S390_VECTOR_REGISTERS<a class="headerlink" href="#kvm-cap-s390-vector-registers" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, negative value on error</p>
</dd>
</dl>
<p>Allows use of the vector registers introduced with z13 processor, and
provides for the synchronization between host and user space.  Will
return -EINVAL if the machine does not support vectors.</p>
</section>
<section id="kvm-cap-s390-user-stsi">
<h3>7.4 KVM_CAP_S390_USER_STSI<a class="headerlink" href="#kvm-cap-s390-user-stsi" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
</dl>
<p>This capability allows post-handlers for the STSI instruction. After
initial handling in the kernel, KVM exits to user space with
KVM_EXIT_S390_STSI to allow user space to insert further data.</p>
<p>Before exiting to userspace, kvm handlers should fill in s390_stsi field of
vcpu-&gt;run:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct {
      __u64 addr;
      __u8 ar;
      __u8 reserved;
      __u8 fc;
      __u8 sel1;
      __u16 sel2;
} s390_stsi;

@addr - guest address of STSI SYSIB
@fc   - function code
@sel1 - selector 1
@sel2 - selector 2
@ar   - access register number
</pre></div>
</div>
<p>KVM handlers should exit to userspace with rc = -EREMOTE.</p>
</section>
<section id="kvm-cap-split-irqchip">
<h3>7.5 KVM_CAP_SPLIT_IRQCHIP<a class="headerlink" href="#kvm-cap-split-irqchip" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>args[0] - number of routes reserved for userspace IOAPICs</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -1 on error</p>
</dd>
</dl>
<p>Create a local apic for each processor in the kernel. This can be used
instead of KVM_CREATE_IRQCHIP if the userspace VMM wishes to emulate the
IOAPIC and PIC (and also the PIT, even though this has to be enabled
separately).</p>
<p>This capability also enables in kernel routing of interrupt requests;
when KVM_CAP_SPLIT_IRQCHIP only routes of KVM_IRQ_ROUTING_MSI type are
used in the IRQ routing table.  The first args[0] MSI routes are reserved
for the IOAPIC pins.  Whenever the LAPIC receives an EOI for these routes,
a KVM_EXIT_IOAPIC_EOI vmexit will be reported to userspace.</p>
<p>Fails if VCPU has already been created, or if the irqchip is already in the
kernel (i.e. KVM_CREATE_IRQCHIP has already been called).</p>
</section>
<section id="kvm-cap-s390-ri">
<h3>7.6 KVM_CAP_S390_RI<a class="headerlink" href="#kvm-cap-s390-ri" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
</dl>
<p>Allows use of runtime-instrumentation introduced with zEC12 processor.
Will return -EINVAL if the machine does not support runtime-instrumentation.
Will return -EBUSY if a VCPU has already been created.</p>
</section>
<section id="kvm-cap-x2apic-api">
<h3>7.7 KVM_CAP_X2APIC_API<a class="headerlink" href="#kvm-cap-x2apic-api" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>args[0] - features that should be enabled</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -EINVAL when args[0] contains invalid features</p>
</dd>
</dl>
<p>Valid feature flags in args[0] are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_X2APIC_API_USE_32BIT_IDS            (1ULL &lt;&lt; 0)
#define KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK  (1ULL &lt;&lt; 1)
</pre></div>
</div>
<p>Enabling KVM_X2APIC_API_USE_32BIT_IDS changes the behavior of
KVM_SET_GSI_ROUTING, KVM_SIGNAL_MSI, KVM_SET_LAPIC, and KVM_GET_LAPIC,
allowing the use of 32-bit APIC IDs.  See KVM_CAP_X2APIC_API in their
respective sections.</p>
<p>KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK must be enabled for x2APIC to work
in logical mode or with more than 255 VCPUs.  Otherwise, KVM treats 0xff
as a broadcast even in x2APIC mode in order to support physical x2APIC
without interrupt remapping.  This is undesirable in logical mode,
where 0xff represents CPUs 0-7 in cluster 0.</p>
</section>
<section id="kvm-cap-s390-user-instr0">
<h3>7.8 KVM_CAP_S390_USER_INSTR0<a class="headerlink" href="#kvm-cap-s390-user-instr0" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
</dl>
<p>With this capability enabled, all illegal instructions 0x0000 (2 bytes) will
be intercepted and forwarded to user space. User space can use this
mechanism e.g. to realize 2-byte software breakpoints. The kernel will
not inject an operating exception for these instructions, user space has
to take care of that.</p>
<p>This capability can be enabled dynamically even if VCPUs were already
created and are running.</p>
</section>
<section id="kvm-cap-s390-gs">
<h3>7.9 KVM_CAP_S390_GS<a class="headerlink" href="#kvm-cap-s390-gs" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success; -EINVAL if the machine does not support
guarded storage; -EBUSY if a VCPU has already been created.</p>
</dd>
</dl>
<p>Allows use of guarded storage for the KVM guest.</p>
</section>
<section id="kvm-cap-s390-ais">
<h3>7.10 KVM_CAP_S390_AIS<a class="headerlink" href="#kvm-cap-s390-ais" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
</dl>
<p>Allow use of adapter-interruption suppression.
:Returns: 0 on success; -EBUSY if a VCPU has already been created.</p>
</section>
<section id="kvm-cap-ppc-smt">
<h3>7.11 KVM_CAP_PPC_SMT<a class="headerlink" href="#kvm-cap-ppc-smt" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>vsmt_mode, flags</p>
</dd>
</dl>
<p>Enabling this capability on a VM provides userspace with a way to set
the desired virtual SMT mode (i.e. the number of virtual CPUs per
virtual core).  The virtual SMT mode, vsmt_mode, must be a power of 2
between 1 and 8.  On POWER8, vsmt_mode must also be no greater than
the number of threads per subcore for the host.  Currently flags must
be 0.  A successful call to enable this capability will result in
vsmt_mode being returned when the KVM_CAP_PPC_SMT capability is
subsequently queried for the VM.  This capability is only supported by
HV KVM, and can only be set before any VCPUs have been created.
The KVM_CAP_PPC_SMT_POSSIBLE capability indicates which virtual SMT
modes are available.</p>
</section>
<section id="kvm-cap-ppc-fwnmi">
<h3>7.12 KVM_CAP_PPC_FWNMI<a class="headerlink" href="#kvm-cap-ppc-fwnmi" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
</dl>
<p>With this capability a machine check exception in the guest address
space will cause KVM to exit the guest with NMI exit reason. This
enables QEMU to build error log and branch to guest kernel registered
machine check handling routine. Without this capability KVM will
branch to guests’ 0x200 interrupt vector.</p>
</section>
<section id="kvm-cap-x86-disable-exits">
<h3>7.13 KVM_CAP_X86_DISABLE_EXITS<a class="headerlink" href="#kvm-cap-x86-disable-exits" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>args[0] defines which exits are disabled</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -EINVAL when args[0] contains invalid exits</p>
</dd>
</dl>
<p>Valid bits in args[0] are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_X86_DISABLE_EXITS_MWAIT            (1 &lt;&lt; 0)
#define KVM_X86_DISABLE_EXITS_HLT              (1 &lt;&lt; 1)
#define KVM_X86_DISABLE_EXITS_PAUSE            (1 &lt;&lt; 2)
#define KVM_X86_DISABLE_EXITS_CSTATE           (1 &lt;&lt; 3)
</pre></div>
</div>
<p>Enabling this capability on a VM provides userspace with a way to no
longer intercept some instructions for improved latency in some
workloads, and is suggested when vCPUs are associated to dedicated
physical CPUs.  More bits can be added in the future; userspace can
just pass the KVM_CHECK_EXTENSION result to KVM_ENABLE_CAP to disable
all such vmexits.</p>
<p>Do not enable KVM_FEATURE_PV_UNHALT if you disable HLT exits.</p>
</section>
<section id="kvm-cap-s390-hpage-1m">
<h3>7.14 KVM_CAP_S390_HPAGE_1M<a class="headerlink" href="#kvm-cap-s390-hpage-1m" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -EINVAL if hpage module parameter was not set
or cmma is enabled, or the VM has the KVM_VM_S390_UCONTROL
flag set</p>
</dd>
</dl>
<p>With this capability the KVM support for memory backing with 1m pages
through hugetlbfs can be enabled for a VM. After the capability is
enabled, cmma can’t be enabled anymore and pfmfi and the storage key
interpretation are disabled. If cmma has already been enabled or the
hpage module parameter is not set to 1, -EINVAL is returned.</p>
<p>While it is generally possible to create a huge page backed VM without
this capability, the VM will not be able to run.</p>
</section>
<section id="kvm-cap-msr-platform-info">
<h3>7.15 KVM_CAP_MSR_PLATFORM_INFO<a class="headerlink" href="#kvm-cap-msr-platform-info" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>args[0] whether feature should be enabled or not</p>
</dd>
</dl>
<p>With this capability, a guest may read the MSR_PLATFORM_INFO MSR. Otherwise,
a #GP would be raised when the guest tries to access. Currently, this
capability does not enable write permissions of this MSR for the guest.</p>
</section>
<section id="kvm-cap-ppc-nested-hv">
<h3>7.16 KVM_CAP_PPC_NESTED_HV<a class="headerlink" href="#kvm-cap-ppc-nested-hv" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -EINVAL when the implementation doesn’t support
nested-HV virtualization.</p>
</dd>
</dl>
<p>HV-KVM on POWER9 and later systems allows for “nested-HV”
virtualization, which provides a way for a guest VM to run guests that
can run using the CPU’s supervisor mode (privileged non-hypervisor
state).  Enabling this capability on a VM depends on the CPU having
the necessary functionality and on the facility being enabled with a
kvm-hv module parameter.</p>
</section>
<section id="kvm-cap-exception-payload">
<h3>7.17 KVM_CAP_EXCEPTION_PAYLOAD<a class="headerlink" href="#kvm-cap-exception-payload" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>args[0] whether feature should be enabled or not</p>
</dd>
</dl>
<p>With this capability enabled, CR2 will not be modified prior to the
emulated VM-exit when L1 intercepts a #PF exception that occurs in
L2. Similarly, for kvm-intel only, DR6 will not be modified prior to
the emulated VM-exit when L1 intercepts a #DB exception that occurs in
L2. As a result, when KVM_GET_VCPU_EVENTS reports a pending #PF (or
#DB) exception for L2, exception.has_payload will be set and the
faulting address (or the new DR6 bits*) will be reported in the
exception_payload field. Similarly, when userspace injects a #PF (or
#DB) into L2 using KVM_SET_VCPU_EVENTS, it is expected to set
exception.has_payload and to put the faulting address - or the new DR6
bits<a class="footnote-reference brackets" href="#id11" id="id10">3</a> - in the exception_payload field.</p>
<p>This capability also enables exception.pending in struct
kvm_vcpu_events, which allows userspace to distinguish between pending
and injected exceptions.</p>
<dl class="footnote brackets">
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id10">3</a></span></dt>
<dd><p>For the new DR6 bits, note that bit 16 is set iff the #DB exception
will clear DR6.RTM.</p>
</dd>
</dl>
<p>7.18 KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2</p>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86, arm64, mips</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>args[0] whether feature should be enabled or not</p>
</dd>
</dl>
<p>Valid flags are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE   (1 &lt;&lt; 0)
#define KVM_DIRTY_LOG_INITIALLY_SET           (1 &lt;&lt; 1)
</pre></div>
</div>
<p>With KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE is set, KVM_GET_DIRTY_LOG will not
automatically clear and write-protect all pages that are returned as dirty.
Rather, userspace will have to do this operation separately using
KVM_CLEAR_DIRTY_LOG.</p>
<p>At the cost of a slightly more complicated operation, this provides better
scalability and responsiveness for two reasons.  First,
KVM_CLEAR_DIRTY_LOG ioctl can operate on a 64-page granularity rather
than requiring to sync a full memslot; this ensures that KVM does not
take spinlocks for an extended period of time.  Second, in some cases a
large amount of time can pass between a call to KVM_GET_DIRTY_LOG and
userspace actually using the data in the page.  Pages can be modified
during this time, which is inefficient for both the guest and userspace:
the guest will incur a higher penalty due to write protection faults,
while userspace can see false reports of dirty pages.  Manual reprotection
helps reducing this time, improving guest performance and reducing the
number of dirty log false positives.</p>
<p>With KVM_DIRTY_LOG_INITIALLY_SET set, all the bits of the dirty bitmap
will be initialized to 1 when created.  This also improves performance because
dirty logging can be enabled gradually in small chunks on the first call
to KVM_CLEAR_DIRTY_LOG.  KVM_DIRTY_LOG_INITIALLY_SET depends on
KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE (it is also only available on
x86 and arm64 for now).</p>
<p>KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 was previously available under the name
KVM_CAP_MANUAL_DIRTY_LOG_PROTECT, but the implementation had bugs that make
it hard or impossible to use it correctly.  The availability of
KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 signals that those bugs are fixed.
Userspace should not try to use KVM_CAP_MANUAL_DIRTY_LOG_PROTECT.</p>
</section>
<section id="kvm-cap-ppc-secure-guest">
<h3>7.19 KVM_CAP_PPC_SECURE_GUEST<a class="headerlink" href="#kvm-cap-ppc-secure-guest" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
</dl>
<p>This capability indicates that KVM is running on a host that has
ultravisor firmware and thus can support a secure guest.  On such a
system, a guest can ask the ultravisor to make it a secure guest,
one whose memory is inaccessible to the host except for pages which
are explicitly requested to be shared with the host.  The ultravisor
notifies KVM when a guest requests to become a secure guest, and KVM
has the opportunity to veto the transition.</p>
<p>If present, this capability can be enabled for a VM, meaning that KVM
will allow the transition to secure guest mode.  Otherwise KVM will
veto the transition.</p>
</section>
<section id="kvm-cap-halt-poll">
<h3>7.20 KVM_CAP_HALT_POLL<a class="headerlink" href="#kvm-cap-halt-poll" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>all</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>VM</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] is the maximum poll time in nanoseconds</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>KVM_CAP_HALT_POLL overrides the kvm.halt_poll_ns module parameter to set the
maximum halt-polling time for all vCPUs in the target VM. This capability can
be invoked at any time and any number of times to dynamically change the
maximum halt-polling time.</p>
<p>See <a class="reference internal" href="halt-polling.html"><span class="doc">The KVM halt polling system</span></a> for more information on halt
polling.</p>
</section>
<section id="kvm-cap-x86-user-space-msr">
<h3>7.21 KVM_CAP_X86_USER_SPACE_MSR<a class="headerlink" href="#kvm-cap-x86-user-space-msr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>VM</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] contains the mask of KVM_MSR_EXIT_REASON_* events to report</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success; -1 on error</p>
</dd>
</dl>
<p>This capability allows userspace to intercept RDMSR and WRMSR instructions if
access to an MSR is denied.  By default, KVM injects #GP on denied accesses.</p>
<p>When a guest requests to read or write an MSR, KVM may not implement all MSRs
that are relevant to a respective system. It also does not differentiate by
CPU type.</p>
<p>To allow more fine grained control over MSR handling, userspace may enable
this capability. With it enabled, MSR accesses that match the mask specified in
args[0] and would trigger a #GP inside the guest will instead trigger
KVM_EXIT_X86_RDMSR and KVM_EXIT_X86_WRMSR exit notifications.  Userspace
can then implement model specific MSR handling and/or user notifications
to inform a user that an MSR was not emulated/virtualized by KVM.</p>
<p>The valid mask flags are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 37%" />
<col style="width: 63%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>KVM_MSR_EXIT_REASON_UNKNOWN</p></td>
<td><p>intercept accesses to unknown (to KVM) MSRs</p></td>
</tr>
<tr class="row-even"><td><p>KVM_MSR_EXIT_REASON_INVAL</p></td>
<td><p>intercept accesses that are architecturally
invalid according to the vCPU model and/or mode</p></td>
</tr>
<tr class="row-odd"><td><p>KVM_MSR_EXIT_REASON_FILTER</p></td>
<td><p>intercept accesses that are denied by userspace
via KVM_X86_SET_MSR_FILTER</p></td>
</tr>
</tbody>
</table>
</section>
<section id="kvm-cap-x86-bus-lock-exit">
<h3>7.22 KVM_CAP_X86_BUS_LOCK_EXIT<a class="headerlink" href="#kvm-cap-x86-bus-lock-exit" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>VM</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] defines the policy used when bus locks detected in guest</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success, -EINVAL when args[0] contains invalid bits</p>
</dd>
</dl>
<p>Valid bits in args[0] are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_BUS_LOCK_DETECTION_OFF      (1 &lt;&lt; 0)
#define KVM_BUS_LOCK_DETECTION_EXIT     (1 &lt;&lt; 1)
</pre></div>
</div>
<p>Enabling this capability on a VM provides userspace with a way to select
a policy to handle the bus locks detected in guest. Userspace can obtain
the supported modes from the result of KVM_CHECK_EXTENSION and define it
through the KVM_ENABLE_CAP.</p>
<p>KVM_BUS_LOCK_DETECTION_OFF and KVM_BUS_LOCK_DETECTION_EXIT are supported
currently and mutually exclusive with each other. More bits can be added in
the future.</p>
<p>With KVM_BUS_LOCK_DETECTION_OFF set, bus locks in guest will not cause vm exits
so that no additional actions are needed. This is the default mode.</p>
<p>With KVM_BUS_LOCK_DETECTION_EXIT set, vm exits happen when bus lock detected
in VM. KVM just exits to userspace when handling them. Userspace can enforce
its own throttling or other policy based mitigations.</p>
<p>This capability is aimed to address the thread that VM can exploit bus locks to
degree the performance of the whole system. Once the userspace enable this
capability and select the KVM_BUS_LOCK_DETECTION_EXIT mode, KVM will set the
KVM_RUN_BUS_LOCK flag in vcpu-run-&gt;flags field and exit to userspace. Concerning
the bus lock vm exit can be preempted by a higher priority VM exit, the exit
notifications to userspace can be KVM_EXIT_BUS_LOCK or other reasons.
KVM_RUN_BUS_LOCK flag is used to distinguish between them.</p>
</section>
<section id="kvm-cap-ppc-dawr1">
<h3>7.23 KVM_CAP_PPC_DAWR1<a class="headerlink" href="#kvm-cap-ppc-dawr1" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -EINVAL when CPU doesn’t support 2nd DAWR</p>
</dd>
</dl>
<p>This capability can be used to check / enable 2nd DAWR feature provided
by POWER10 processor.</p>
</section>
<section id="kvm-cap-vm-copy-enc-context-from">
<h3>7.24 KVM_CAP_VM_COPY_ENC_CONTEXT_FROM<a class="headerlink" href="#kvm-cap-vm-copy-enc-context-from" title="Permalink to this headline">¶</a></h3>
<p>Architectures: x86 SEV enabled
Type: vm
Parameters: args[0] is the fd of the source vm
Returns: 0 on success; ENOTTY on error</p>
<p>This capability enables userspace to copy encryption context from the vm
indicated by the fd to the vm this is called on.</p>
<p>This is intended to support in-guest workloads scheduled by the host. This
allows the in-guest workload to maintain its own NPTs and keeps the two vms
from accidentally clobbering each other with interrupts and the like (separate
APIC/MSRs/etc).</p>
</section>
<section id="kvm-cap-sgx-attribute">
<h3>7.25 KVM_CAP_SGX_ATTRIBUTE<a class="headerlink" href="#kvm-cap-sgx-attribute" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>VM</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] is a file handle of a SGX attribute file in securityfs</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success, -EINVAL if the file handle is invalid or if a requested
attribute is not supported by KVM.</p>
</dd>
</dl>
<p>KVM_CAP_SGX_ATTRIBUTE enables a userspace VMM to grant a VM access to one or
more priveleged enclave attributes.  args[0] must hold a file handle to a valid
SGX attribute file corresponding to an attribute that is supported/restricted
by KVM (currently only PROVISIONKEY).</p>
<p>The SGX subsystem restricts access to a subset of enclave attributes to provide
additional security for an uncompromised kernel, e.g. use of the PROVISIONKEY
is restricted to deter malware from using the PROVISIONKEY to obtain a stable
system fingerprint.  To prevent userspace from circumventing such restrictions
by running an enclave in a VM, KVM prevents access to privileged attributes by
default.</p>
<p>See <a class="reference internal" href="../../x86/sgx.html"><span class="doc">Software Guard eXtensions (SGX)</span></a> for more details.</p>
</section>
<section id="kvm-cap-ppc-rpt-invalidate">
<h3>7.26 KVM_CAP_PPC_RPT_INVALIDATE<a class="headerlink" href="#kvm-cap-ppc-rpt-invalidate" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_RPT_INVALIDATE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm</p>
</dd>
</dl>
<p>This capability indicates that the kernel is capable of handling
H_RPT_INVALIDATE hcall.</p>
<p>In order to enable the use of H_RPT_INVALIDATE in the guest,
user space might have to advertise it for the guest. For example,
IBM pSeries (sPAPR) guest starts using it if “hcall-rpt-invalidate” is
present in the “ibm,hypertas-functions” device-tree property.</p>
<p>This capability is enabled for hypervisors on platforms like POWER9
that support radix MMU.</p>
</section>
<section id="kvm-cap-exit-on-emulation-failure">
<h3>7.27 KVM_CAP_EXIT_ON_EMULATION_FAILURE<a class="headerlink" href="#kvm-cap-exit-on-emulation-failure" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>args[0] whether the feature should be enabled or not</p>
</dd>
</dl>
<p>When this capability is enabled, an emulation failure will result in an exit
to userspace with KVM_INTERNAL_ERROR (except when the emulator was invoked
to handle a VMware backdoor instruction). Furthermore, KVM will now provide up
to 15 instruction bytes for any exit to userspace resulting from an emulation
failure.  When these exits to userspace occur use the emulation_failure struct
instead of the internal struct.  They both have the same layout, but the
emulation_failure struct matches the content better.  It also explicitly
defines the ‘flags’ field which is used to describe the fields in the struct
that are valid (ie: if KVM_INTERNAL_ERROR_EMULATION_FLAG_INSTRUCTION_BYTES is
set in the ‘flags’ field then both ‘insn_size’ and ‘insn_bytes’ have valid data
in them.)</p>
</section>
<section id="kvm-cap-arm-mte">
<h3>7.28 KVM_CAP_ARM_MTE<a class="headerlink" href="#kvm-cap-arm-mte" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>arm64</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
</dl>
<p>This capability indicates that KVM (and the hardware) supports exposing the
Memory Tagging Extensions (MTE) to the guest. It must also be enabled by the
VMM before creating any VCPUs to allow the guest access. Note that MTE is only
available to a guest running in AArch64 mode and enabling this capability will
cause attempts to create AArch32 VCPUs to fail.</p>
<p>When enabled the guest is able to access tags associated with any memory given
to the guest. KVM will ensure that the tags are maintained during swap or
hibernation of the host; however the VMM needs to manually save/restore the
tags as appropriate if the VM is migrated.</p>
<p>When this capability is enabled all memory in memslots must be mapped as
<code class="docutils literal notranslate"><span class="pre">MAP_ANONYMOUS</span></code> or with a RAM-based file mapping (<code class="docutils literal notranslate"><span class="pre">tmpfs</span></code>, <code class="docutils literal notranslate"><span class="pre">memfd</span></code>),
attempts to create a memslot with an invalid mmap will result in an
-EINVAL return.</p>
<p>When enabled the VMM may make use of the <code class="docutils literal notranslate"><span class="pre">KVM_ARM_MTE_COPY_TAGS</span></code> ioctl to
perform a bulk copy of tags to/from the guest.</p>
</section>
<section id="kvm-cap-vm-move-enc-context-from">
<h3>7.29 KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM<a class="headerlink" href="#kvm-cap-vm-move-enc-context-from" title="Permalink to this headline">¶</a></h3>
<p>Architectures: x86 SEV enabled
Type: vm
Parameters: args[0] is the fd of the source vm
Returns: 0 on success</p>
<p>This capability enables userspace to migrate the encryption context from the VM
indicated by the fd to the VM this is called on.</p>
<p>This is intended to support intra-host migration of VMs between userspace VMMs,
upgrading the VMM process without interrupting the guest.</p>
</section>
<section id="kvm-cap-ppc-ail-mode-3">
<h3>7.30 KVM_CAP_PPC_AIL_MODE_3<a class="headerlink" href="#kvm-cap-ppc-ail-mode-3" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_AIL_MODE_3</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm</p>
</dd>
</dl>
<p>This capability indicates that the kernel supports the mode 3 setting for the
“Address Translation Mode on Interrupt” aka “Alternate Interrupt Location”
resource that is controlled with the H_SET_MODE hypercall.</p>
<p>This capability allows a guest kernel to use a better-performance mode for
handling interrupts and system calls.</p>
</section>
<section id="kvm-cap-disable-quirks2">
<h3>7.31 KVM_CAP_DISABLE_QUIRKS2<a class="headerlink" href="#kvm-cap-disable-quirks2" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_DISABLE_QUIRKS2</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>args[0] - set of KVM quirks to disable</p>
</dd>
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Type</dt>
<dd class="field-even"><p>vm</p>
</dd>
</dl>
<p>This capability, if enabled, will cause KVM to disable some behavior
quirks.</p>
<p>Calling KVM_CHECK_EXTENSION for this capability returns a bitmask of
quirks that can be disabled in KVM.</p>
<p>The argument to KVM_ENABLE_CAP for this capability is a bitmask of
quirks to disable, and must be a subset of the bitmask returned by
KVM_CHECK_EXTENSION.</p>
<p>The valid bits in cap.args[0] are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>KVM_X86_QUIRK_LINT0_REENABLED</p></td>
<td><p>By default, the reset value for the LVT
LINT0 register is 0x700 (APIC_MODE_EXTINT).
When this quirk is disabled, the reset value
is 0x10000 (APIC_LVT_MASKED).</p></td>
</tr>
<tr class="row-even"><td><p>KVM_X86_QUIRK_CD_NW_CLEARED</p></td>
<td><p>By default, KVM clears CR0.CD and CR0.NW.
When this quirk is disabled, KVM does not
change the value of CR0.CD and CR0.NW.</p></td>
</tr>
<tr class="row-odd"><td><p>KVM_X86_QUIRK_LAPIC_MMIO_HOLE</p></td>
<td><p>By default, the MMIO LAPIC interface is
available even when configured for x2APIC
mode. When this quirk is disabled, KVM
disables the MMIO LAPIC interface if the
LAPIC is in x2APIC mode.</p></td>
</tr>
<tr class="row-even"><td><p>KVM_X86_QUIRK_OUT_7E_INC_RIP</p></td>
<td><p>By default, KVM pre-increments %rip before
exiting to userspace for an OUT instruction
to port 0x7e. When this quirk is disabled,
KVM does not pre-increment %rip before
exiting to userspace.</p></td>
</tr>
<tr class="row-odd"><td><p>KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT</p></td>
<td><p>When this quirk is disabled, KVM sets
CPUID.01H:ECX[bit 3] (MONITOR/MWAIT) if
IA32_MISC_ENABLE[bit 18] (MWAIT) is set.
Additionally, when this quirk is disabled,
KVM clears CPUID.01H:ECX[bit 3] if
IA32_MISC_ENABLE[bit 18] is cleared.</p></td>
</tr>
<tr class="row-even"><td><p>KVM_X86_QUIRK_FIX_HYPERCALL_INSN</p></td>
<td><p>By default, KVM rewrites guest
VMMCALL/VMCALL instructions to match the
vendor’s hypercall instruction for the
system. When this quirk is disabled, KVM
will no longer rewrite invalid guest
hypercall instructions. Executing the
incorrect hypercall instruction will
generate a #UD within the guest.</p></td>
</tr>
<tr class="row-odd"><td><p>KVM_X86_QUIRK_MWAIT_NEVER_UD_FAULTS</p></td>
<td><p>By default, KVM emulates MONITOR/MWAIT (if
they are intercepted) as NOPs regardless of
whether or not MONITOR/MWAIT are supported
according to guest CPUID.  When this quirk
is disabled and KVM_X86_DISABLE_EXITS_MWAIT
is not set (MONITOR/MWAIT are intercepted),
KVM will inject a #UD on MONITOR/MWAIT if
they’re unsupported per guest CPUID.  Note,
KVM will modify MONITOR/MWAIT support in
guest CPUID on writes to MISC_ENABLE if
KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT is
disabled.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="kvm-cap-max-vcpu-id">
<h3>7.32 KVM_CAP_MAX_VCPU_ID<a class="headerlink" href="#kvm-cap-max-vcpu-id" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>VM</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] - maximum APIC ID value set for current VM</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success, -EINVAL if args[0] is beyond KVM_MAX_VCPU_IDS
supported in KVM or if it has been set.</p>
</dd>
</dl>
<p>This capability allows userspace to specify maximum possible APIC ID
assigned for current VM session prior to the creation of vCPUs, saving
memory for data structures indexed by the APIC ID.  Userspace is able
to calculate the limit to APIC ID values from designated
CPU topology.</p>
<p>The value can be changed only until KVM_ENABLE_CAP is set to a nonzero
value or until a vCPU is created.  Upon creation of the first vCPU,
if the value was set to zero or KVM_ENABLE_CAP was not invoked, KVM
uses the return value of KVM_CHECK_EXTENSION(KVM_CAP_MAX_VCPU_ID) as
the maximum APIC ID.</p>
</section>
<section id="kvm-cap-x86-notify-vmexit">
<h3>7.33 KVM_CAP_X86_NOTIFY_VMEXIT<a class="headerlink" href="#kvm-cap-x86-notify-vmexit" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
<dt class="field-even">Target</dt>
<dd class="field-even"><p>VM</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p>args[0] is the value of notify window as well as some flags</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 on success, -EINVAL if args[0] contains invalid flags or notify
VM exit is unsupported.</p>
</dd>
</dl>
<p>Bits 63:32 of args[0] are used for notify window.
Bits 31:0 of args[0] are for some flags. Valid bits are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_X86_NOTIFY_VMEXIT_ENABLED    (1 &lt;&lt; 0)
#define KVM_X86_NOTIFY_VMEXIT_USER       (1 &lt;&lt; 1)
</pre></div>
</div>
<p>This capability allows userspace to configure the notify VM exit on/off
in per-VM scope during VM creation. Notify VM exit is disabled by default.
When userspace sets KVM_X86_NOTIFY_VMEXIT_ENABLED bit in args[0], VMM will
enable this feature with the notify window provided, which will generate
a VM exit if no event window occurs in VM non-root mode for a specified of
time (notify window).</p>
<p>If KVM_X86_NOTIFY_VMEXIT_USER is set in args[0], upon notify VM exits happen,
KVM would exit to userspace for handling.</p>
<p>This capability is aimed to mitigate the threat that malicious VMs can
cause CPU stuck (due to event windows don’t open up) and make the CPU
unavailable to host or other VMs.</p>
</section>
</section>
<section id="other-capabilities">
<h2>8. Other capabilities.<a class="headerlink" href="#other-capabilities" title="Permalink to this headline">¶</a></h2>
<p>This section lists capabilities that give information about other
features of the KVM implementation.</p>
<section id="kvm-cap-ppc-hwrng">
<h3>8.1 KVM_CAP_PPC_HWRNG<a class="headerlink" href="#kvm-cap-ppc-hwrng" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
</dl>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is
available, means that the kernel has an implementation of the
H_RANDOM hypercall backed by a hardware random-number generator.
If present, the kernel H_RANDOM handler can be enabled for guest use
with the KVM_CAP_PPC_ENABLE_HCALL capability.</p>
</section>
<section id="kvm-cap-hyperv-synic">
<h3>8.2 KVM_CAP_HYPERV_SYNIC<a class="headerlink" href="#kvm-cap-hyperv-synic" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
</dl>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is
available, means that the kernel has an implementation of the
Hyper-V Synthetic interrupt controller(SynIC). Hyper-V SynIC is
used to support Windows Hyper-V based guest paravirt drivers(VMBus).</p>
<p>In order to use SynIC, it has to be activated by setting this
capability via KVM_ENABLE_CAP ioctl on the vcpu fd. Note that this
will disable the use of APIC hardware virtualization even if supported
by the CPU, as it’s incompatible with SynIC auto-EOI behavior.</p>
</section>
<section id="kvm-cap-ppc-radix-mmu">
<h3>8.3 KVM_CAP_PPC_RADIX_MMU<a class="headerlink" href="#kvm-cap-ppc-radix-mmu" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
</dl>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is
available, means that the kernel can support guests using the
radix MMU defined in Power ISA V3.00 (as implemented in the POWER9
processor).</p>
</section>
<section id="kvm-cap-ppc-hash-mmu-v3">
<h3>8.4 KVM_CAP_PPC_HASH_MMU_V3<a class="headerlink" href="#kvm-cap-ppc-hash-mmu-v3" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
</dl>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is
available, means that the kernel can support guests using the
hashed page table MMU defined in Power ISA V3.00 (as implemented in
the POWER9 processor), including in-memory segment tables.</p>
</section>
<section id="kvm-cap-mips-vz">
<h3>8.5 KVM_CAP_MIPS_VZ<a class="headerlink" href="#kvm-cap-mips-vz" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>mips</p>
</dd>
</dl>
<p>This capability, if KVM_CHECK_EXTENSION on the main kvm handle indicates that
it is available, means that full hardware assisted virtualization capabilities
of the hardware are available for use through KVM. An appropriate
KVM_VM_MIPS_* type must be passed to KVM_CREATE_VM to create a VM which
utilises it.</p>
<p>If KVM_CHECK_EXTENSION on a kvm VM handle indicates that this capability is
available, it means that the VM is using full hardware assisted virtualization
capabilities of the hardware. This is useful to check after creating a VM with
KVM_VM_MIPS_DEFAULT.</p>
<p>The value returned by KVM_CHECK_EXTENSION should be compared against known
values (see below). All other values are reserved. This is to allow for the
possibility of other hardware assisted virtualization implementations which
may be incompatible with the MIPS VZ ASE.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 3%" />
<col style="width: 97%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>The trap &amp; emulate implementation is in use to run guest code in user
mode. Guest virtual memory segments are rearranged to fit the guest in the
user mode address space.</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>The MIPS VZ ASE is in use, providing full hardware assisted
virtualization, including standard guest virtual memory segments.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="kvm-cap-mips-te">
<h3>8.6 KVM_CAP_MIPS_TE<a class="headerlink" href="#kvm-cap-mips-te" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>mips</p>
</dd>
</dl>
<p>This capability, if KVM_CHECK_EXTENSION on the main kvm handle indicates that
it is available, means that the trap &amp; emulate implementation is available to
run guest code in user mode, even if KVM_CAP_MIPS_VZ indicates that hardware
assisted virtualisation is also available. KVM_VM_MIPS_TE (0) must be passed
to KVM_CREATE_VM to create a VM which utilises it.</p>
<p>If KVM_CHECK_EXTENSION on a kvm VM handle indicates that this capability is
available, it means that the VM is using trap &amp; emulate.</p>
</section>
<section id="kvm-cap-mips-64bit">
<h3>8.7 KVM_CAP_MIPS_64BIT<a class="headerlink" href="#kvm-cap-mips-64bit" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>mips</p>
</dd>
</dl>
<p>This capability indicates the supported architecture type of the guest, i.e. the
supported register and address width.</p>
<p>The values returned when this capability is checked by KVM_CHECK_EXTENSION on a
kvm VM handle correspond roughly to the CP0_Config.AT register field, and should
be checked specifically against known values (see below). All other values are
reserved.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 3%" />
<col style="width: 97%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>MIPS32 or microMIPS32.
Both registers and addresses are 32-bits wide.
It will only be possible to run 32-bit guest code.</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>MIPS64 or microMIPS64 with access only to 32-bit compatibility segments.
Registers are 64-bits wide, but addresses are 32-bits wide.
64-bit guest code may run but cannot access MIPS64 memory segments.
It will also be possible to run 32-bit guest code.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>MIPS64 or microMIPS64 with access to all address segments.
Both registers and addresses are 64-bits wide.
It will be possible to run 64-bit or 32-bit guest code.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="kvm-cap-arm-user-irq">
<h3>8.9 KVM_CAP_ARM_USER_IRQ<a class="headerlink" href="#kvm-cap-arm-user-irq" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>arm64</p>
</dd>
</dl>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is available, means
that if userspace creates a VM without an in-kernel interrupt controller, it
will be notified of changes to the output level of in-kernel emulated devices,
which can generate virtual interrupts, presented to the VM.
For such VMs, on every return to userspace, the kernel
updates the vcpu’s run-&gt;s.regs.device_irq_level field to represent the actual
output level of the device.</p>
<p>Whenever kvm detects a change in the device output level, kvm guarantees at
least one return to userspace before running the VM.  This exit could either
be a KVM_EXIT_INTR or any other exit event, like KVM_EXIT_MMIO. This way,
userspace can always sample the device output level and re-compute the state of
the userspace interrupt controller.  Userspace should always check the state
of run-&gt;s.regs.device_irq_level on every kvm exit.
The value in run-&gt;s.regs.device_irq_level can represent both level and edge
triggered interrupt signals, depending on the device.  Edge triggered interrupt
signals will exit to userspace with the bit in run-&gt;s.regs.device_irq_level
set exactly once per edge signal.</p>
<p>The field run-&gt;s.regs.device_irq_level is available independent of
run-&gt;kvm_valid_regs or run-&gt;kvm_dirty_regs bits.</p>
<p>If KVM_CAP_ARM_USER_IRQ is supported, the KVM_CHECK_EXTENSION ioctl returns a
number larger than 0 indicating the version of this capability is implemented
and thereby which bits in run-&gt;s.regs.device_irq_level can signal values.</p>
<p>Currently the following bits are defined for the device_irq_level bitmap:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>KVM_CAP_ARM_USER_IRQ &gt;= 1:

  KVM_ARM_DEV_EL1_VTIMER -  EL1 virtual timer
  KVM_ARM_DEV_EL1_PTIMER -  EL1 physical timer
  KVM_ARM_DEV_PMU        -  ARM PMU overflow interrupt signal
</pre></div>
</div>
<p>Future versions of kvm may implement additional events. These will get
indicated by returning a higher number from KVM_CHECK_EXTENSION and will be
listed above.</p>
</section>
<section id="kvm-cap-ppc-smt-possible">
<h3>8.10 KVM_CAP_PPC_SMT_POSSIBLE<a class="headerlink" href="#kvm-cap-ppc-smt-possible" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>ppc</p>
</dd>
</dl>
<p>Querying this capability returns a bitmap indicating the possible
virtual SMT modes that can be set using KVM_CAP_PPC_SMT.  If bit N
(counting from the right) is set, then a virtual SMT mode of 2^N is
available.</p>
</section>
<section id="kvm-cap-hyperv-synic2">
<h3>8.11 KVM_CAP_HYPERV_SYNIC2<a class="headerlink" href="#kvm-cap-hyperv-synic2" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
</dl>
<p>This capability enables a newer version of Hyper-V Synthetic interrupt
controller (SynIC).  The only difference with KVM_CAP_HYPERV_SYNIC is that KVM
doesn’t clear SynIC message and event flags pages when they are enabled by
writing to the respective MSRs.</p>
</section>
<section id="kvm-cap-hyperv-vp-index">
<h3>8.12 KVM_CAP_HYPERV_VP_INDEX<a class="headerlink" href="#kvm-cap-hyperv-vp-index" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
</dl>
<p>This capability indicates that userspace can load HV_X64_MSR_VP_INDEX msr.  Its
value is used to denote the target vcpu for a SynIC interrupt.  For
compatibilty, KVM initializes this msr to KVM’s internal vcpu index.  When this
capability is absent, userspace can still query this msr’s value.</p>
</section>
<section id="kvm-cap-s390-ais-migration">
<h3>8.13 KVM_CAP_S390_AIS_MIGRATION<a class="headerlink" href="#kvm-cap-s390-ais-migration" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>none</p>
</dd>
</dl>
<p>This capability indicates if the flic device will be able to get/set the
AIS states for migration via the KVM_DEV_FLIC_AISM_ALL attribute and allows
to discover this without having to create a flic device.</p>
</section>
<section id="kvm-cap-s390-psw">
<h3>8.14 KVM_CAP_S390_PSW<a class="headerlink" href="#kvm-cap-s390-psw" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
</dl>
<p>This capability indicates that the PSW is exposed via the kvm_run structure.</p>
</section>
<section id="kvm-cap-s390-gmap">
<h3>8.15 KVM_CAP_S390_GMAP<a class="headerlink" href="#kvm-cap-s390-gmap" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
</dl>
<p>This capability indicates that the user space memory used as guest mapping can
be anywhere in the user memory address space, as long as the memory slots are
aligned and sized to a segment (1MB) boundary.</p>
</section>
<section id="kvm-cap-s390-cow">
<h3>8.16 KVM_CAP_S390_COW<a class="headerlink" href="#kvm-cap-s390-cow" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
</dl>
<p>This capability indicates that the user space memory used as guest mapping can
use copy-on-write semantics as well as dirty pages tracking via read-only page
tables.</p>
</section>
<section id="kvm-cap-s390-bpb">
<h3>8.17 KVM_CAP_S390_BPB<a class="headerlink" href="#kvm-cap-s390-bpb" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
</dl>
<p>This capability indicates that kvm will implement the interfaces to handle
reset, migration and nested KVM for branch prediction blocking. The stfle
facility 82 should not be provided to the guest without this capability.</p>
</section>
<section id="kvm-cap-hyperv-tlbflush">
<h3>8.18 KVM_CAP_HYPERV_TLBFLUSH<a class="headerlink" href="#kvm-cap-hyperv-tlbflush" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
</dl>
<p>This capability indicates that KVM supports paravirtualized Hyper-V TLB Flush
hypercalls:
HvFlushVirtualAddressSpace, HvFlushVirtualAddressSpaceEx,
HvFlushVirtualAddressList, HvFlushVirtualAddressListEx.</p>
</section>
<section id="kvm-cap-arm-inject-serror-esr">
<h3>8.19 KVM_CAP_ARM_INJECT_SERROR_ESR<a class="headerlink" href="#kvm-cap-arm-inject-serror-esr" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>arm64</p>
</dd>
</dl>
<p>This capability indicates that userspace can specify (via the
KVM_SET_VCPU_EVENTS ioctl) the syndrome value reported to the guest when it
takes a virtual SError interrupt exception.
If KVM advertises this capability, userspace can only specify the ISS field for
the ESR syndrome. Other parts of the ESR, such as the EC are generated by the
CPU when the exception is taken. If this virtual SError is taken to EL1 using
AArch64, this value will be reported in the ISS field of ESR_ELx.</p>
<p>See KVM_CAP_VCPU_EVENTS for more details.</p>
</section>
<section id="kvm-cap-hyperv-send-ipi">
<h3>8.20 KVM_CAP_HYPERV_SEND_IPI<a class="headerlink" href="#kvm-cap-hyperv-send-ipi" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
</dl>
<p>This capability indicates that KVM supports paravirtualized Hyper-V IPI send
hypercalls:
HvCallSendSyntheticClusterIpi, HvCallSendSyntheticClusterIpiEx.</p>
</section>
<section id="kvm-cap-hyperv-direct-tlbflush">
<h3>8.21 KVM_CAP_HYPERV_DIRECT_TLBFLUSH<a class="headerlink" href="#kvm-cap-hyperv-direct-tlbflush" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
</dl>
<p>This capability indicates that KVM running on top of Hyper-V hypervisor
enables Direct TLB flush for its guests meaning that TLB flush
hypercalls are handled by Level 0 hypervisor (Hyper-V) bypassing KVM.
Due to the different ABI for hypercall parameters between Hyper-V and
KVM, enabling this capability effectively disables all hypercall
handling by KVM (as some KVM hypercall may be mistakenly treated as TLB
flush hypercalls by Hyper-V) so userspace should disable KVM identification
in CPUID and only exposes Hyper-V identification. In this case, guest
thinks it’s running on Hyper-V and only use Hyper-V hypercalls.</p>
</section>
<section id="kvm-cap-s390-vcpu-resets">
<h3>8.22 KVM_CAP_S390_VCPU_RESETS<a class="headerlink" href="#kvm-cap-s390-vcpu-resets" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
</dl>
<p>This capability indicates that the KVM_S390_NORMAL_RESET and
KVM_S390_CLEAR_RESET ioctls are available.</p>
</section>
<section id="kvm-cap-s390-protected">
<h3>8.23 KVM_CAP_S390_PROTECTED<a class="headerlink" href="#kvm-cap-s390-protected" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
</dl>
<p>This capability indicates that the Ultravisor has been initialized and
KVM can therefore start protected VMs.
This capability governs the KVM_S390_PV_COMMAND ioctl and the
KVM_MP_STATE_LOAD MP_STATE. KVM_SET_MP_STATE can fail for protected
guests when the state change is invalid.</p>
</section>
<section id="kvm-cap-steal-time">
<h3>8.24 KVM_CAP_STEAL_TIME<a class="headerlink" href="#kvm-cap-steal-time" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>arm64, x86</p>
</dd>
</dl>
<p>This capability indicates that KVM supports steal time accounting.
When steal time accounting is supported it may be enabled with
architecture-specific interfaces.  This capability and the architecture-
specific interfaces must be consistent, i.e. if one says the feature
is supported, than the other should as well and vice versa.  For arm64
see <a class="reference internal" href="devices/vcpu.html"><span class="doc">Generic vcpu interface</span></a> “KVM_ARM_VCPU_PVTIME_CTRL”.
For x86 see <a class="reference internal" href="x86/msr.html"><span class="doc">KVM-specific MSRs</span></a> “MSR_KVM_STEAL_TIME”.</p>
</section>
<section id="kvm-cap-s390-diag318">
<h3>8.25 KVM_CAP_S390_DIAG318<a class="headerlink" href="#kvm-cap-s390-diag318" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>s390</p>
</dd>
</dl>
<p>This capability enables a guest to set information about its control program
(i.e. guest kernel type and version). The information is helpful during
system/firmware service events, providing additional data about the guest
environments running on the machine.</p>
<p>The information is associated with the DIAGNOSE 0x318 instruction, which sets
an 8-byte value consisting of a one-byte Control Program Name Code (CPNC) and
a 7-byte Control Program Version Code (CPVC). The CPNC determines what
environment the control program is running in (e.g. Linux, z/VM…), and the
CPVC is used for information specific to OS (e.g. Linux version, Linux
distribution…)</p>
<p>If this capability is available, then the CPNC and CPVC can be synchronized
between KVM and userspace via the sync regs mechanism (KVM_SYNC_DIAG318).</p>
</section>
<section id="id12">
<h3>8.26 KVM_CAP_X86_USER_SPACE_MSR<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
</dl>
<p>This capability indicates that KVM supports deflection of MSR reads and
writes to user space. It can be enabled on a VM level. If enabled, MSR
accesses that would usually trigger a #GP by KVM into the guest will
instead get bounced to user space through the KVM_EXIT_X86_RDMSR and
KVM_EXIT_X86_WRMSR exit notifications.</p>
</section>
<section id="kvm-cap-x86-msr-filter">
<h3>8.27 KVM_CAP_X86_MSR_FILTER<a class="headerlink" href="#kvm-cap-x86-msr-filter" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
</dl>
<p>This capability indicates that KVM supports that accesses to user defined MSRs
may be rejected. With this capability exposed, KVM exports new VM ioctl
KVM_X86_SET_MSR_FILTER which user space can call to specify bitmaps of MSR
ranges that KVM should deny access to.</p>
<p>In combination with KVM_CAP_X86_USER_SPACE_MSR, this allows user space to
trap and emulate MSRs that are outside of the scope of KVM as well as
limit the attack surface on KVM’s MSR emulation code.</p>
</section>
<section id="kvm-cap-enforce-pv-feature-cpuid">
<h3>8.28 KVM_CAP_ENFORCE_PV_FEATURE_CPUID<a class="headerlink" href="#kvm-cap-enforce-pv-feature-cpuid" title="Permalink to this headline">¶</a></h3>
<p>Architectures: x86</p>
<p>When enabled, KVM will disable paravirtual features provided to the
guest according to the bits in the KVM_CPUID_FEATURES CPUID leaf
(0x40000001). Otherwise, a guest may use the paravirtual features
regardless of what has actually been exposed through the CPUID leaf.</p>
</section>
<section id="kvm-cap-dirty-log-ring-kvm-cap-dirty-log-ring-acq-rel">
<h3>8.29 KVM_CAP_DIRTY_LOG_RING/KVM_CAP_DIRTY_LOG_RING_ACQ_REL<a class="headerlink" href="#kvm-cap-dirty-log-ring-kvm-cap-dirty-log-ring-acq-rel" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86, arm64</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>args[0] - size of the dirty log ring</p>
</dd>
</dl>
<p>KVM is capable of tracking dirty memory using ring buffers that are
mmaped into userspace; there is one dirty ring per vcpu.</p>
<p>The dirty ring is available to userspace as an array of
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvm_dirty_gfn</span></code>.  Each dirty entry it’s defined as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kvm_dirty_gfn {
        __u32 flags;
        __u32 slot; /* as_id | slot_id */
        __u64 offset;
};
</pre></div>
</div>
<p>The following values are defined for the flags field to define the
current state of the entry:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_DIRTY_GFN_F_DIRTY           BIT(0)
#define KVM_DIRTY_GFN_F_RESET           BIT(1)
#define KVM_DIRTY_GFN_F_MASK            0x3
</pre></div>
</div>
<p>Userspace should call KVM_ENABLE_CAP ioctl right after KVM_CREATE_VM
ioctl to enable this capability for the new guest and set the size of
the rings.  Enabling the capability is only allowed before creating any
vCPU, and the size of the ring must be a power of two.  The larger the
ring buffer, the less likely the ring is full and the VM is forced to
exit to userspace. The optimal size depends on the workload, but it is
recommended that it be at least 64 KiB (4096 entries).</p>
<p>Just like for dirty page bitmaps, the buffer tracks writes to
all user memory regions for which the KVM_MEM_LOG_DIRTY_PAGES flag was
set in KVM_SET_USER_MEMORY_REGION.  Once a memory region is registered
with the flag set, userspace can start harvesting dirty pages from the
ring buffer.</p>
<p>An entry in the ring buffer can be unused (flag bits <code class="docutils literal notranslate"><span class="pre">00</span></code>),
dirty (flag bits <code class="docutils literal notranslate"><span class="pre">01</span></code>) or harvested (flag bits <code class="docutils literal notranslate"><span class="pre">1X</span></code>).  The
state machine for the entry is as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     dirtied         harvested        reset
00 -----------&gt; 01 -------------&gt; 1X -------+
 ^                                          |
 |                                          |
 +------------------------------------------+
</pre></div>
</div>
<p>To harvest the dirty pages, userspace accesses the mmaped ring buffer
to read the dirty GFNs.  If the flags has the DIRTY bit set (at this stage
the RESET bit must be cleared), then it means this GFN is a dirty GFN.
The userspace should harvest this GFN and mark the flags from state
<code class="docutils literal notranslate"><span class="pre">01b</span></code> to <code class="docutils literal notranslate"><span class="pre">1Xb</span></code> (bit 0 will be ignored by KVM, but bit 1 must be set
to show that this GFN is harvested and waiting for a reset), and move
on to the next GFN.  The userspace should continue to do this until the
flags of a GFN have the DIRTY bit cleared, meaning that it has harvested
all the dirty GFNs that were available.</p>
<p>Note that on weakly ordered architectures, userspace accesses to the
ring buffer (and more specifically the ‘flags’ field) must be ordered,
using load-acquire/store-release accessors when available, or any
other memory barrier that will ensure this ordering.</p>
<p>It’s not necessary for userspace to harvest the all dirty GFNs at once.
However it must collect the dirty GFNs in sequence, i.e., the userspace
program cannot skip one dirty GFN to collect the one next to it.</p>
<p>After processing one or more entries in the ring buffer, userspace
calls the VM ioctl KVM_RESET_DIRTY_RINGS to notify the kernel about
it, so that the kernel will reprotect those collected GFNs.
Therefore, the ioctl must be called <em>before</em> reading the content of
the dirty pages.</p>
<p>The dirty ring can get full.  When it happens, the KVM_RUN of the
vcpu will return with exit reason KVM_EXIT_DIRTY_LOG_FULL.</p>
<p>The dirty ring interface has a major difference comparing to the
KVM_GET_DIRTY_LOG interface in that, when reading the dirty ring from
userspace, it’s still possible that the kernel has not yet flushed the
processor’s dirty page buffers into the kernel buffer (with dirty bitmaps, the
flushing is done by the KVM_GET_DIRTY_LOG ioctl).  To achieve that, one
needs to kick the vcpu out of KVM_RUN using a signal.  The resulting
vmexit ensures that all dirty GFNs are flushed to the dirty rings.</p>
<p>NOTE: KVM_CAP_DIRTY_LOG_RING_ACQ_REL is the only capability that
should be exposed by weakly ordered architecture, in order to indicate
the additional memory ordering requirements imposed on userspace when
reading the state of an entry and mutating it from DIRTY to HARVESTED.
Architecture with TSO-like ordering (such as x86) are allowed to
expose both KVM_CAP_DIRTY_LOG_RING and KVM_CAP_DIRTY_LOG_RING_ACQ_REL
to userspace.</p>
<p>After enabling the dirty rings, the userspace needs to detect the
capability of KVM_CAP_DIRTY_LOG_RING_WITH_BITMAP to see whether the
ring structures can be backed by per-slot bitmaps. With this capability
advertised, it means the architecture can dirty guest pages without
vcpu/ring context, so that some of the dirty information will still be
maintained in the bitmap structure. KVM_CAP_DIRTY_LOG_RING_WITH_BITMAP
can’t be enabled if the capability of KVM_CAP_DIRTY_LOG_RING_ACQ_REL
hasn’t been enabled, or any memslot has been existing.</p>
<p>Note that the bitmap here is only a backup of the ring structure. The
use of the ring and bitmap combination is only beneficial if there is
only a very small amount of memory that is dirtied out of vcpu/ring
context. Otherwise, the stand-alone per-slot bitmap mechanism needs to
be considered.</p>
<p>To collect dirty bits in the backup bitmap, userspace can use the same
KVM_GET_DIRTY_LOG ioctl. KVM_CLEAR_DIRTY_LOG isn’t needed as long as all
the generation of the dirty bits is done in a single pass. Collecting
the dirty bitmap should be the very last thing that the VMM does before
considering the state as complete. VMM needs to ensure that the dirty
state is final and avoid missing dirty pages from another ioctl ordered
after the bitmap collection.</p>
<p>NOTE: One example of using the backup bitmap is saving arm64 vgic/its
tables through KVM_DEV_ARM_{VGIC_GRP_CTRL, ITS_SAVE_TABLES} command on
KVM device “kvm-arm-vgic-its” when dirty ring is enabled.</p>
</section>
<section id="kvm-cap-xen-hvm">
<h3>8.30 KVM_CAP_XEN_HVM<a class="headerlink" href="#kvm-cap-xen-hvm" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>x86</p>
</dd>
</dl>
<p>This capability indicates the features that Xen supports for hosting Xen
PVHVM guests. Valid flags are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define KVM_XEN_HVM_CONFIG_HYPERCALL_MSR              (1 &lt;&lt; 0)
#define KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL            (1 &lt;&lt; 1)
#define KVM_XEN_HVM_CONFIG_SHARED_INFO                (1 &lt;&lt; 2)
#define KVM_XEN_HVM_CONFIG_RUNSTATE                   (1 &lt;&lt; 3)
#define KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL              (1 &lt;&lt; 4)
#define KVM_XEN_HVM_CONFIG_EVTCHN_SEND                (1 &lt;&lt; 5)
#define KVM_XEN_HVM_CONFIG_RUNSTATE_UPDATE_FLAG       (1 &lt;&lt; 6)
</pre></div>
</div>
<p>The KVM_XEN_HVM_CONFIG_HYPERCALL_MSR flag indicates that the KVM_XEN_HVM_CONFIG
ioctl is available, for the guest to set its hypercall page.</p>
<p>If KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL is also set, the same flag may also be
provided in the flags to KVM_XEN_HVM_CONFIG, without providing hypercall page
contents, to request that KVM generate hypercall page content automatically
and also enable interception of guest hypercalls with KVM_EXIT_XEN.</p>
<p>The KVM_XEN_HVM_CONFIG_SHARED_INFO flag indicates the availability of the
KVM_XEN_HVM_SET_ATTR, KVM_XEN_HVM_GET_ATTR, KVM_XEN_VCPU_SET_ATTR and
KVM_XEN_VCPU_GET_ATTR ioctls, as well as the delivery of exception vectors
for event channel upcalls when the evtchn_upcall_pending field of a vcpu’s
vcpu_info is set.</p>
<p>The KVM_XEN_HVM_CONFIG_RUNSTATE flag indicates that the runstate-related
features KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADDR/_CURRENT/_DATA/_ADJUST are
supported by the KVM_XEN_VCPU_SET_ATTR/KVM_XEN_VCPU_GET_ATTR ioctls.</p>
<p>The KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL flag indicates that IRQ routing entries
of the type KVM_IRQ_ROUTING_XEN_EVTCHN are supported, with the priority
field set to indicate 2 level event channel delivery.</p>
<p>The KVM_XEN_HVM_CONFIG_EVTCHN_SEND flag indicates that KVM supports
injecting event channel events directly into the guest with the
KVM_XEN_HVM_EVTCHN_SEND ioctl. It also indicates support for the
KVM_XEN_ATTR_TYPE_EVTCHN/XEN_VERSION HVM attributes and the
KVM_XEN_VCPU_ATTR_TYPE_VCPU_ID/TIMER/UPCALL_VECTOR vCPU attributes.
related to event channel delivery, timers, and the XENVER_version
interception.</p>
<p>The KVM_XEN_HVM_CONFIG_RUNSTATE_UPDATE_FLAG flag indicates that KVM supports
the KVM_XEN_ATTR_TYPE_RUNSTATE_UPDATE_FLAG attribute in the KVM_XEN_SET_ATTR
and KVM_XEN_GET_ATTR ioctls. This controls whether KVM will set the
XEN_RUNSTATE_UPDATE flag in guest memory mapped vcpu_runstate_info during
updates of the runstate information. Note that versions of KVM which support
the RUNSTATE feature above, but not thie RUNSTATE_UPDATE_FLAG feature, will
always set the XEN_RUNSTATE_UPDATE flag when updating the guest structure,
which is perhaps counterintuitive. When this flag is advertised, KVM will
behave more correctly, not using the XEN_RUNSTATE_UPDATE flag until/unless
specifically enabled (by the guest making the hypercall, causing the VMM
to enable the KVM_XEN_ATTR_TYPE_RUNSTATE_UPDATE_FLAG attribute).</p>
</section>
<section id="kvm-cap-ppc-multitce">
<h3>8.31 KVM_CAP_PPC_MULTITCE<a class="headerlink" href="#kvm-cap-ppc-multitce" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_PPC_MULTITCE</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>ppc</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm</p>
</dd>
</dl>
<p>This capability means the kernel is capable of handling hypercalls
H_PUT_TCE_INDIRECT and H_STUFF_TCE without passing those into the user
space. This significantly accelerates DMA operations for PPC KVM guests.
User space should expect that its handlers for these hypercalls
are not going to be called if user space previously registered LIOBN
in KVM (via KVM_CREATE_SPAPR_TCE or similar calls).</p>
<p>In order to enable H_PUT_TCE_INDIRECT and H_STUFF_TCE use in the guest,
user space might have to advertise it for the guest. For example,
IBM pSeries (sPAPR) guest starts using them if “hcall-multi-tce” is
present in the “ibm,hypertas-functions” device-tree property.</p>
<p>The hypercalls mentioned above may or may not be processed successfully
in the kernel based fast path. If they can not be handled by the kernel,
they will get passed on to user space. So user space still has to have
an implementation for these despite the in kernel acceleration.</p>
<p>This capability is always enabled.</p>
</section>
<section id="kvm-cap-ptp-kvm">
<h3>8.32 KVM_CAP_PTP_KVM<a class="headerlink" href="#kvm-cap-ptp-kvm" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Architectures</dt>
<dd class="field-odd"><p>arm64</p>
</dd>
</dl>
<p>This capability indicates that the KVM virtual PTP service is
supported in the host. A VMM can check whether the service is
available to the guest on migration.</p>
</section>
<section id="kvm-cap-hyperv-enforce-cpuid">
<h3>8.33 KVM_CAP_HYPERV_ENFORCE_CPUID<a class="headerlink" href="#kvm-cap-hyperv-enforce-cpuid" title="Permalink to this headline">¶</a></h3>
<p>Architectures: x86</p>
<p>When enabled, KVM will disable emulated Hyper-V features provided to the
guest according to the bits Hyper-V CPUID feature leaves. Otherwise, all
currently implmented Hyper-V features are provided unconditionally when
Hyper-V identification is set in the HYPERV_CPUID_INTERFACE (0x40000001)
leaf.</p>
</section>
<section id="kvm-cap-exit-hypercall">
<h3>8.34 KVM_CAP_EXIT_HYPERCALL<a class="headerlink" href="#kvm-cap-exit-hypercall" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_EXIT_HYPERCALL</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm</p>
</dd>
</dl>
<p>This capability, if enabled, will cause KVM to exit to userspace
with KVM_EXIT_HYPERCALL exit reason to process some hypercalls.</p>
<p>Calling KVM_CHECK_EXTENSION for this capability will return a bitmask
of hypercalls that can be configured to exit to userspace.
Right now, the only such hypercall is KVM_HC_MAP_GPA_RANGE.</p>
<p>The argument to KVM_ENABLE_CAP is also a bitmask, and must be a subset
of the result of KVM_CHECK_EXTENSION.  KVM will forward to userspace
the hypercalls whose corresponding bit is in the argument, and return
ENOSYS for the others.</p>
</section>
<section id="kvm-cap-pmu-capability">
<h3>8.35 KVM_CAP_PMU_CAPABILITY<a class="headerlink" href="#kvm-cap-pmu-capability" title="Permalink to this headline">¶</a></h3>
<p>:Capability KVM_CAP_PMU_CAPABILITY
:Architectures: x86
:Type: vm
:Parameters: arg[0] is bitmask of PMU virtualization capabilities.
:Returns 0 on success, -EINVAL when arg[0] contains invalid bits</p>
<p>This capability alters PMU virtualization in KVM.</p>
<p>Calling KVM_CHECK_EXTENSION for this capability returns a bitmask of
PMU virtualization capabilities that can be adjusted on a VM.</p>
<p>The argument to KVM_ENABLE_CAP is also a bitmask and selects specific
PMU virtualization capabilities to be applied to the VM.  This can
only be invoked on a VM prior to the creation of VCPUs.</p>
<p>At this time, KVM_PMU_CAP_DISABLE is the only capability.  Setting
this capability will disable PMU virtualization for that VM.  Usermode
should adjust CPUID leaf 0xA to reflect that the PMU is disabled.</p>
</section>
<section id="kvm-cap-arm-system-suspend">
<h3>8.36 KVM_CAP_ARM_SYSTEM_SUSPEND<a class="headerlink" href="#kvm-cap-arm-system-suspend" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_ARM_SYSTEM_SUSPEND</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>arm64</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm</p>
</dd>
</dl>
<p>When enabled, KVM will exit to userspace with KVM_EXIT_SYSTEM_EVENT of
type KVM_SYSTEM_EVENT_SUSPEND to process the guest suspend request.</p>
</section>
<section id="kvm-cap-s390-protected-dump">
<h3>8.37 KVM_CAP_S390_PROTECTED_DUMP<a class="headerlink" href="#kvm-cap-s390-protected-dump" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_PROTECTED_DUMP</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm</p>
</dd>
</dl>
<p>This capability indicates that KVM and the Ultravisor support dumping
PV guests. The <cite>KVM_PV_DUMP</cite> command is available for the
<cite>KVM_S390_PV_COMMAND</cite> ioctl and the <cite>KVM_PV_INFO</cite> command provides
dump related UV data. Also the vcpu ioctl <cite>KVM_S390_PV_CPU_COMMAND</cite> is
available and supports the <cite>KVM_PV_DUMP_CPU</cite> subcommand.</p>
</section>
<section id="kvm-cap-vm-disable-nx-huge-pages">
<h3>8.38 KVM_CAP_VM_DISABLE_NX_HUGE_PAGES<a class="headerlink" href="#kvm-cap-vm-disable-nx-huge-pages" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_VM_DISABLE_NX_HUGE_PAGES</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>x86</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p>arg[0] must be 0.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 on success, -EPERM if the userspace process does not
have CAP_SYS_BOOT, -EINVAL if args[0] is not 0 or any vCPUs have been
created.</p>
</dd>
</dl>
<p>This capability disables the NX huge pages mitigation for iTLB MULTIHIT.</p>
<p>The capability has no effect if the nx_huge_pages module parameter is not set.</p>
<p>This capability may only be set before any vCPUs are created.</p>
</section>
<section id="kvm-cap-s390-cpu-topology">
<h3>8.39 KVM_CAP_S390_CPU_TOPOLOGY<a class="headerlink" href="#kvm-cap-s390-cpu-topology" title="Permalink to this headline">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Capability</dt>
<dd class="field-odd"><p>KVM_CAP_S390_CPU_TOPOLOGY</p>
</dd>
<dt class="field-even">Architectures</dt>
<dd class="field-even"><p>s390</p>
</dd>
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>vm</p>
</dd>
</dl>
<p>This capability indicates that KVM will provide the S390 CPU Topology
facility which consist of the interpretation of the PTF instruction for
the function code 2 along with interception and forwarding of both the
PTF instruction with function codes 0 or 1 and the STSI(15,1,x)
instruction to the userland hypervisor.</p>
<p>The stfle facility 11, CPU Topology facility, should not be indicated
to the guest without this capability.</p>
<p>When this capability is present, KVM provides a new attribute group
on vm fd, KVM_S390_VM_CPU_TOPOLOGY.
This new attribute allows to get, set or clear the Modified Change
Topology Report (MTCR) bit of the SCA through the kvm_device_attr
structure.</p>
<p>When getting the Modified Change Topology Report value, the attr-&gt;addr
must point to a byte where the value will be stored or retrieved from.</p>
</section>
</section>
<section id="known-kvm-api-problems">
<h2>9. Known KVM API problems<a class="headerlink" href="#known-kvm-api-problems" title="Permalink to this headline">¶</a></h2>
<p>In some cases, KVM’s API has some inconsistencies or common pitfalls
that userspace need to be aware of.  This section details some of
these issues.</p>
<p>Most of them are architecture specific, so the section is split by
architecture.</p>
<section id="id13">
<h3>9.1. x86<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<section id="kvm-get-supported-cpuid-issues">
<h4><code class="docutils literal notranslate"><span class="pre">KVM_GET_SUPPORTED_CPUID</span></code> issues<a class="headerlink" href="#kvm-get-supported-cpuid-issues" title="Permalink to this headline">¶</a></h4>
<p>In general, <code class="docutils literal notranslate"><span class="pre">KVM_GET_SUPPORTED_CPUID</span></code> is designed so that it is possible
to take its result and pass it directly to <code class="docutils literal notranslate"><span class="pre">KVM_SET_CPUID2</span></code>.  This section
documents some cases in which that requires some care.</p>
<section id="local-apic-features">
<h5>Local APIC features<a class="headerlink" href="#local-apic-features" title="Permalink to this headline">¶</a></h5>
<p>CPU[EAX=1]:ECX[21] (X2APIC) is reported by <code class="docutils literal notranslate"><span class="pre">KVM_GET_SUPPORTED_CPUID</span></code>,
but it can only be enabled if <code class="docutils literal notranslate"><span class="pre">KVM_CREATE_IRQCHIP</span></code> or
<code class="docutils literal notranslate"><span class="pre">KVM_ENABLE_CAP(KVM_CAP_IRQCHIP_SPLIT)</span></code> are used to enable in-kernel emulation of
the local APIC.</p>
<p>The same is true for the <code class="docutils literal notranslate"><span class="pre">KVM_FEATURE_PV_UNHALT</span></code> paravirtualized feature.</p>
<p>CPU[EAX=1]:ECX[24] (TSC_DEADLINE) is not reported by <code class="docutils literal notranslate"><span class="pre">KVM_GET_SUPPORTED_CPUID</span></code>.
It can be enabled if <code class="docutils literal notranslate"><span class="pre">KVM_CAP_TSC_DEADLINE_TIMER</span></code> is present and the kernel
has enabled in-kernel emulation of the local APIC.</p>
</section>
<section id="cpu-topology">
<h5>CPU topology<a class="headerlink" href="#cpu-topology" title="Permalink to this headline">¶</a></h5>
<p>Several CPUID values include topology information for the host CPU:
0x0b and 0x1f for Intel systems, 0x8000001e for AMD systems.  Different
versions of KVM return different values for this information and userspace
should not rely on it.  Currently they return all zeroes.</p>
<p>If userspace wishes to set up a guest topology, it should be careful that
the values of these three leaves differ for each CPU.  In particular,
the APIC ID is found in EDX for all subleaves of 0x0b and 0x1f, and in EAX
for 0x8000001e; the latter also encodes the core id and node id in bits
7:0 of EBX and ECX respectively.</p>
</section>
</section>
<section id="obsolete-ioctls-and-capabilities">
<h4>Obsolete ioctls and capabilities<a class="headerlink" href="#obsolete-ioctls-and-capabilities" title="Permalink to this headline">¶</a></h4>
<p>KVM_CAP_DISABLE_QUIRKS does not let userspace know which quirks are actually
available.  Use <code class="docutils literal notranslate"><span class="pre">KVM_CHECK_EXTENSION(KVM_CAP_DISABLE_QUIRKS2)</span></code> instead if
available.</p>
</section>
<section id="ordering-of-kvm-get-kvm-set-ioctls">
<h4>Ordering of KVM_GET_*/KVM_SET_* ioctls<a class="headerlink" href="#ordering-of-kvm-get-kvm-set-ioctls" title="Permalink to this headline">¶</a></h4>
<p>TBD</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The Definitive KVM (Kernel-based Virtual Machine) API Documentation</a><ul>
<li><a class="reference internal" href="#general-description">1. General description</a></li>
<li><a class="reference internal" href="#file-descriptors">2. File descriptors</a></li>
<li><a class="reference internal" href="#extensions">3. Extensions</a></li>
<li><a class="reference internal" href="#api-description">4. API description</a><ul>
<li><a class="reference internal" href="#kvm-get-api-version">4.1 KVM_GET_API_VERSION</a></li>
<li><a class="reference internal" href="#kvm-create-vm">4.2 KVM_CREATE_VM</a></li>
<li><a class="reference internal" href="#kvm-get-msr-index-list-kvm-get-msr-feature-index-list">4.3 KVM_GET_MSR_INDEX_LIST, KVM_GET_MSR_FEATURE_INDEX_LIST</a></li>
<li><a class="reference internal" href="#kvm-check-extension">4.4 KVM_CHECK_EXTENSION</a></li>
<li><a class="reference internal" href="#kvm-get-vcpu-mmap-size">4.5 KVM_GET_VCPU_MMAP_SIZE</a></li>
<li><a class="reference internal" href="#kvm-create-vcpu">4.7 KVM_CREATE_VCPU</a></li>
<li><a class="reference internal" href="#kvm-get-dirty-log-vm-ioctl">4.8 KVM_GET_DIRTY_LOG (vm ioctl)</a></li>
<li><a class="reference internal" href="#kvm-run">4.10 KVM_RUN</a></li>
<li><a class="reference internal" href="#kvm-get-regs">4.11 KVM_GET_REGS</a></li>
<li><a class="reference internal" href="#kvm-set-regs">4.12 KVM_SET_REGS</a></li>
<li><a class="reference internal" href="#kvm-get-sregs">4.13 KVM_GET_SREGS</a></li>
<li><a class="reference internal" href="#kvm-set-sregs">4.14 KVM_SET_SREGS</a></li>
<li><a class="reference internal" href="#kvm-translate">4.15 KVM_TRANSLATE</a></li>
<li><a class="reference internal" href="#kvm-interrupt">4.16 KVM_INTERRUPT</a><ul>
<li><a class="reference internal" href="#x86">X86:</a></li>
<li><a class="reference internal" href="#ppc">PPC:</a></li>
<li><a class="reference internal" href="#mips">MIPS:</a></li>
<li><a class="reference internal" href="#risc-v">RISC-V:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kvm-debug-guest">4.17 KVM_DEBUG_GUEST</a></li>
<li><a class="reference internal" href="#kvm-get-msrs">4.18 KVM_GET_MSRS</a></li>
<li><a class="reference internal" href="#kvm-set-msrs">4.19 KVM_SET_MSRS</a></li>
<li><a class="reference internal" href="#kvm-set-cpuid">4.20 KVM_SET_CPUID</a></li>
<li><a class="reference internal" href="#kvm-set-signal-mask">4.21 KVM_SET_SIGNAL_MASK</a></li>
<li><a class="reference internal" href="#kvm-get-fpu">4.22 KVM_GET_FPU</a></li>
<li><a class="reference internal" href="#kvm-set-fpu">4.23 KVM_SET_FPU</a></li>
<li><a class="reference internal" href="#kvm-create-irqchip">4.24 KVM_CREATE_IRQCHIP</a></li>
<li><a class="reference internal" href="#kvm-irq-line">4.25 KVM_IRQ_LINE</a></li>
<li><a class="reference internal" href="#kvm-get-irqchip">4.26 KVM_GET_IRQCHIP</a></li>
<li><a class="reference internal" href="#kvm-set-irqchip">4.27 KVM_SET_IRQCHIP</a></li>
<li><a class="reference internal" href="#kvm-xen-hvm-config">4.28 KVM_XEN_HVM_CONFIG</a></li>
<li><a class="reference internal" href="#kvm-get-clock">4.29 KVM_GET_CLOCK</a></li>
<li><a class="reference internal" href="#kvm-set-clock">4.30 KVM_SET_CLOCK</a></li>
<li><a class="reference internal" href="#kvm-get-vcpu-events">4.31 KVM_GET_VCPU_EVENTS</a><ul>
<li><a class="reference internal" href="#id1">X86:</a></li>
<li><a class="reference internal" href="#arm64">ARM64:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kvm-set-vcpu-events">4.32 KVM_SET_VCPU_EVENTS</a><ul>
<li><a class="reference internal" href="#id2">X86:</a></li>
<li><a class="reference internal" href="#id3">ARM64:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kvm-get-debugregs">4.33 KVM_GET_DEBUGREGS</a></li>
<li><a class="reference internal" href="#kvm-set-debugregs">4.34 KVM_SET_DEBUGREGS</a></li>
<li><a class="reference internal" href="#kvm-set-user-memory-region">4.35 KVM_SET_USER_MEMORY_REGION</a></li>
<li><a class="reference internal" href="#kvm-set-tss-addr">4.36 KVM_SET_TSS_ADDR</a></li>
<li><a class="reference internal" href="#kvm-enable-cap">4.37 KVM_ENABLE_CAP</a></li>
<li><a class="reference internal" href="#kvm-get-mp-state">4.38 KVM_GET_MP_STATE</a><ul>
<li><a class="reference internal" href="#for-arm64">For arm64:</a></li>
<li><a class="reference internal" href="#for-riscv">For riscv:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kvm-set-mp-state">4.39 KVM_SET_MP_STATE</a><ul>
<li><a class="reference internal" href="#for-arm64-riscv">For arm64/riscv:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kvm-set-identity-map-addr">4.40 KVM_SET_IDENTITY_MAP_ADDR</a></li>
<li><a class="reference internal" href="#kvm-set-boot-cpu-id">4.41 KVM_SET_BOOT_CPU_ID</a></li>
<li><a class="reference internal" href="#kvm-get-xsave">4.42 KVM_GET_XSAVE</a></li>
<li><a class="reference internal" href="#kvm-set-xsave">4.43 KVM_SET_XSAVE</a></li>
<li><a class="reference internal" href="#kvm-get-xcrs">4.44 KVM_GET_XCRS</a></li>
<li><a class="reference internal" href="#kvm-set-xcrs">4.45 KVM_SET_XCRS</a></li>
<li><a class="reference internal" href="#kvm-get-supported-cpuid">4.46 KVM_GET_SUPPORTED_CPUID</a></li>
<li><a class="reference internal" href="#kvm-ppc-get-pvinfo">4.47 KVM_PPC_GET_PVINFO</a></li>
<li><a class="reference internal" href="#kvm-set-gsi-routing">4.52 KVM_SET_GSI_ROUTING</a></li>
<li><a class="reference internal" href="#kvm-set-tsc-khz">4.55 KVM_SET_TSC_KHZ</a></li>
<li><a class="reference internal" href="#kvm-get-tsc-khz">4.56 KVM_GET_TSC_KHZ</a></li>
<li><a class="reference internal" href="#kvm-get-lapic">4.57 KVM_GET_LAPIC</a></li>
<li><a class="reference internal" href="#kvm-set-lapic">4.58 KVM_SET_LAPIC</a></li>
<li><a class="reference internal" href="#kvm-ioeventfd">4.59 KVM_IOEVENTFD</a></li>
<li><a class="reference internal" href="#kvm-dirty-tlb">4.60 KVM_DIRTY_TLB</a></li>
<li><a class="reference internal" href="#kvm-create-spapr-tce">4.62 KVM_CREATE_SPAPR_TCE</a></li>
<li><a class="reference internal" href="#kvm-allocate-rma">4.63 KVM_ALLOCATE_RMA</a></li>
<li><a class="reference internal" href="#kvm-nmi">4.64 KVM_NMI</a></li>
<li><a class="reference internal" href="#kvm-s390-ucas-map">4.65 KVM_S390_UCAS_MAP</a></li>
<li><a class="reference internal" href="#kvm-s390-ucas-unmap">4.66 KVM_S390_UCAS_UNMAP</a></li>
<li><a class="reference internal" href="#kvm-s390-vcpu-fault">4.67 KVM_S390_VCPU_FAULT</a></li>
<li><a class="reference internal" href="#kvm-set-one-reg">4.68 KVM_SET_ONE_REG</a></li>
<li><a class="reference internal" href="#kvm-get-one-reg">4.69 KVM_GET_ONE_REG</a></li>
<li><a class="reference internal" href="#kvm-kvmclock-ctrl">4.70 KVM_KVMCLOCK_CTRL</a></li>
<li><a class="reference internal" href="#kvm-signal-msi">4.71 KVM_SIGNAL_MSI</a></li>
<li><a class="reference internal" href="#kvm-create-pit2">4.71 KVM_CREATE_PIT2</a></li>
<li><a class="reference internal" href="#kvm-get-pit2">4.72 KVM_GET_PIT2</a></li>
<li><a class="reference internal" href="#kvm-set-pit2">4.73 KVM_SET_PIT2</a></li>
<li><a class="reference internal" href="#kvm-ppc-get-smmu-info">4.74 KVM_PPC_GET_SMMU_INFO</a></li>
<li><a class="reference internal" href="#kvm-irqfd">4.75 KVM_IRQFD</a></li>
<li><a class="reference internal" href="#kvm-ppc-allocate-htab">4.76 KVM_PPC_ALLOCATE_HTAB</a></li>
<li><a class="reference internal" href="#kvm-s390-interrupt">4.77 KVM_S390_INTERRUPT</a></li>
<li><a class="reference internal" href="#kvm-ppc-get-htab-fd">4.78 KVM_PPC_GET_HTAB_FD</a></li>
<li><a class="reference internal" href="#kvm-create-device">4.79 KVM_CREATE_DEVICE</a></li>
<li><a class="reference internal" href="#kvm-set-device-attr-kvm-get-device-attr">4.80 KVM_SET_DEVICE_ATTR/KVM_GET_DEVICE_ATTR</a></li>
<li><a class="reference internal" href="#kvm-has-device-attr">4.81 KVM_HAS_DEVICE_ATTR</a></li>
<li><a class="reference internal" href="#kvm-arm-vcpu-init">4.82 KVM_ARM_VCPU_INIT</a></li>
<li><a class="reference internal" href="#kvm-arm-preferred-target">4.83 KVM_ARM_PREFERRED_TARGET</a></li>
<li><a class="reference internal" href="#kvm-get-reg-list">4.84 KVM_GET_REG_LIST</a></li>
<li><a class="reference internal" href="#kvm-arm-set-device-addr-deprecated">4.85 KVM_ARM_SET_DEVICE_ADDR (deprecated)</a></li>
<li><a class="reference internal" href="#kvm-ppc-rtas-define-token">4.86 KVM_PPC_RTAS_DEFINE_TOKEN</a></li>
<li><a class="reference internal" href="#kvm-set-guest-debug">4.87 KVM_SET_GUEST_DEBUG</a></li>
<li><a class="reference internal" href="#kvm-get-emulated-cpuid">4.88 KVM_GET_EMULATED_CPUID</a></li>
<li><a class="reference internal" href="#kvm-s390-mem-op">4.89 KVM_S390_MEM_OP</a><ul>
<li><a class="reference internal" href="#logical-read-write">Logical read/write:</a></li>
<li><a class="reference internal" href="#absolute-read-write">Absolute read/write:</a></li>
<li><a class="reference internal" href="#sida-read-write">SIDA read/write:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#kvm-s390-get-skeys">4.90 KVM_S390_GET_SKEYS</a></li>
<li><a class="reference internal" href="#kvm-s390-set-skeys">4.91 KVM_S390_SET_SKEYS</a></li>
<li><a class="reference internal" href="#kvm-s390-irq">4.92 KVM_S390_IRQ</a></li>
<li><a class="reference internal" href="#kvm-s390-get-irq-state">4.94 KVM_S390_GET_IRQ_STATE</a></li>
<li><a class="reference internal" href="#kvm-s390-set-irq-state">4.95 KVM_S390_SET_IRQ_STATE</a></li>
<li><a class="reference internal" href="#kvm-smi">4.96 KVM_SMI</a></li>
<li><a class="reference internal" href="#kvm-x86-set-msr-filter">4.97 KVM_X86_SET_MSR_FILTER</a></li>
<li><a class="reference internal" href="#kvm-create-spapr-tce-64">4.98 KVM_CREATE_SPAPR_TCE_64</a></li>
<li><a class="reference internal" href="#kvm-reinject-control">4.99 KVM_REINJECT_CONTROL</a></li>
<li><a class="reference internal" href="#kvm-ppc-configure-v3-mmu">4.100 KVM_PPC_CONFIGURE_V3_MMU</a></li>
<li><a class="reference internal" href="#kvm-ppc-get-rmmu-info">4.101 KVM_PPC_GET_RMMU_INFO</a></li>
<li><a class="reference internal" href="#kvm-ppc-resize-hpt-prepare">4.102 KVM_PPC_RESIZE_HPT_PREPARE</a></li>
<li><a class="reference internal" href="#kvm-ppc-resize-hpt-commit">4.103 KVM_PPC_RESIZE_HPT_COMMIT</a></li>
<li><a class="reference internal" href="#kvm-x86-get-mce-cap-supported">4.104 KVM_X86_GET_MCE_CAP_SUPPORTED</a></li>
<li><a class="reference internal" href="#kvm-x86-setup-mce">4.105 KVM_X86_SETUP_MCE</a></li>
<li><a class="reference internal" href="#kvm-x86-set-mce">4.106 KVM_X86_SET_MCE</a></li>
<li><a class="reference internal" href="#kvm-s390-get-cmma-bits">4.107 KVM_S390_GET_CMMA_BITS</a></li>
<li><a class="reference internal" href="#kvm-s390-set-cmma-bits">4.108 KVM_S390_SET_CMMA_BITS</a></li>
<li><a class="reference internal" href="#kvm-ppc-get-cpu-char">4.109 KVM_PPC_GET_CPU_CHAR</a></li>
<li><a class="reference internal" href="#kvm-memory-encrypt-op">4.110 KVM_MEMORY_ENCRYPT_OP</a></li>
<li><a class="reference internal" href="#kvm-memory-encrypt-reg-region">4.111 KVM_MEMORY_ENCRYPT_REG_REGION</a></li>
<li><a class="reference internal" href="#kvm-memory-encrypt-unreg-region">4.112 KVM_MEMORY_ENCRYPT_UNREG_REGION</a></li>
<li><a class="reference internal" href="#kvm-hyperv-eventfd">4.113 KVM_HYPERV_EVENTFD</a></li>
<li><a class="reference internal" href="#kvm-get-nested-state">4.114 KVM_GET_NESTED_STATE</a></li>
<li><a class="reference internal" href="#kvm-set-nested-state">4.115 KVM_SET_NESTED_STATE</a></li>
<li><a class="reference internal" href="#kvm-un-register-coalesced-mmio">4.116 KVM_(UN)REGISTER_COALESCED_MMIO</a></li>
<li><a class="reference internal" href="#kvm-clear-dirty-log-vm-ioctl">4.117 KVM_CLEAR_DIRTY_LOG (vm ioctl)</a></li>
<li><a class="reference internal" href="#kvm-get-supported-hv-cpuid">4.118 KVM_GET_SUPPORTED_HV_CPUID</a></li>
<li><a class="reference internal" href="#kvm-arm-vcpu-finalize">4.119 KVM_ARM_VCPU_FINALIZE</a></li>
<li><a class="reference internal" href="#kvm-set-pmu-event-filter">4.120 KVM_SET_PMU_EVENT_FILTER</a></li>
<li><a class="reference internal" href="#kvm-ppc-svm-off">4.121 KVM_PPC_SVM_OFF</a></li>
<li><a class="reference internal" href="#kvm-s390-normal-reset">4.122 KVM_S390_NORMAL_RESET</a></li>
<li><a class="reference internal" href="#kvm-s390-initial-reset">4.123 KVM_S390_INITIAL_RESET</a></li>
<li><a class="reference internal" href="#kvm-s390-clear-reset">4.124 KVM_S390_CLEAR_RESET</a></li>
<li><a class="reference internal" href="#kvm-s390-pv-command">4.125 KVM_S390_PV_COMMAND</a></li>
<li><a class="reference internal" href="#kvm-xen-hvm-set-attr">4.126 KVM_XEN_HVM_SET_ATTR</a></li>
<li><a class="reference internal" href="#kvm-xen-hvm-get-attr">4.127 KVM_XEN_HVM_GET_ATTR</a></li>
<li><a class="reference internal" href="#kvm-xen-vcpu-set-attr">4.128 KVM_XEN_VCPU_SET_ATTR</a></li>
<li><a class="reference internal" href="#kvm-xen-vcpu-get-attr">4.129 KVM_XEN_VCPU_GET_ATTR</a></li>
<li><a class="reference internal" href="#kvm-arm-mte-copy-tags">4.130 KVM_ARM_MTE_COPY_TAGS</a></li>
<li><a class="reference internal" href="#kvm-get-sregs2">4.131 KVM_GET_SREGS2</a></li>
<li><a class="reference internal" href="#kvm-set-sregs2">4.132 KVM_SET_SREGS2</a></li>
<li><a class="reference internal" href="#kvm-get-stats-fd">4.133 KVM_GET_STATS_FD</a></li>
<li><a class="reference internal" href="#kvm-get-xsave2">4.134 KVM_GET_XSAVE2</a></li>
<li><a class="reference internal" href="#kvm-xen-hvm-evtchn-send">4.135 KVM_XEN_HVM_EVTCHN_SEND</a></li>
<li><a class="reference internal" href="#kvm-s390-pv-cpu-command">4.136 KVM_S390_PV_CPU_COMMAND</a></li>
<li><a class="reference internal" href="#kvm-s390-zpci-op">4.137 KVM_S390_ZPCI_OP</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-kvm-run-structure">5. The kvm_run structure</a><ul>
<li><a class="reference internal" href="#for-arm-arm64">For arm/arm64:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#capabilities-that-can-be-enabled-on-vcpus">6. Capabilities that can be enabled on vCPUs</a><ul>
<li><a class="reference internal" href="#kvm-cap-ppc-osi">6.1 KVM_CAP_PPC_OSI</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-papr">6.2 KVM_CAP_PPC_PAPR</a></li>
<li><a class="reference internal" href="#kvm-cap-sw-tlb">6.3 KVM_CAP_SW_TLB</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-css-support">6.4 KVM_CAP_S390_CSS_SUPPORT</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-epr">6.5 KVM_CAP_PPC_EPR</a></li>
<li><a class="reference internal" href="#kvm-cap-irq-mpic">6.6 KVM_CAP_IRQ_MPIC</a></li>
<li><a class="reference internal" href="#kvm-cap-irq-xics">6.7 KVM_CAP_IRQ_XICS</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-irqchip">6.8 KVM_CAP_S390_IRQCHIP</a></li>
<li><a class="reference internal" href="#kvm-cap-mips-fpu">6.9 KVM_CAP_MIPS_FPU</a></li>
<li><a class="reference internal" href="#kvm-cap-mips-msa">6.10 KVM_CAP_MIPS_MSA</a></li>
<li><a class="reference internal" href="#kvm-cap-sync-regs">6.74 KVM_CAP_SYNC_REGS</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-irq-xive">6.75 KVM_CAP_PPC_IRQ_XIVE</a></li>
</ul>
</li>
<li><a class="reference internal" href="#capabilities-that-can-be-enabled-on-vms">7. Capabilities that can be enabled on VMs</a><ul>
<li><a class="reference internal" href="#kvm-cap-ppc-enable-hcall">7.1 KVM_CAP_PPC_ENABLE_HCALL</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-user-sigp">7.2 KVM_CAP_S390_USER_SIGP</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-vector-registers">7.3 KVM_CAP_S390_VECTOR_REGISTERS</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-user-stsi">7.4 KVM_CAP_S390_USER_STSI</a></li>
<li><a class="reference internal" href="#kvm-cap-split-irqchip">7.5 KVM_CAP_SPLIT_IRQCHIP</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-ri">7.6 KVM_CAP_S390_RI</a></li>
<li><a class="reference internal" href="#kvm-cap-x2apic-api">7.7 KVM_CAP_X2APIC_API</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-user-instr0">7.8 KVM_CAP_S390_USER_INSTR0</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-gs">7.9 KVM_CAP_S390_GS</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-ais">7.10 KVM_CAP_S390_AIS</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-smt">7.11 KVM_CAP_PPC_SMT</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-fwnmi">7.12 KVM_CAP_PPC_FWNMI</a></li>
<li><a class="reference internal" href="#kvm-cap-x86-disable-exits">7.13 KVM_CAP_X86_DISABLE_EXITS</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-hpage-1m">7.14 KVM_CAP_S390_HPAGE_1M</a></li>
<li><a class="reference internal" href="#kvm-cap-msr-platform-info">7.15 KVM_CAP_MSR_PLATFORM_INFO</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-nested-hv">7.16 KVM_CAP_PPC_NESTED_HV</a></li>
<li><a class="reference internal" href="#kvm-cap-exception-payload">7.17 KVM_CAP_EXCEPTION_PAYLOAD</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-secure-guest">7.19 KVM_CAP_PPC_SECURE_GUEST</a></li>
<li><a class="reference internal" href="#kvm-cap-halt-poll">7.20 KVM_CAP_HALT_POLL</a></li>
<li><a class="reference internal" href="#kvm-cap-x86-user-space-msr">7.21 KVM_CAP_X86_USER_SPACE_MSR</a></li>
<li><a class="reference internal" href="#kvm-cap-x86-bus-lock-exit">7.22 KVM_CAP_X86_BUS_LOCK_EXIT</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-dawr1">7.23 KVM_CAP_PPC_DAWR1</a></li>
<li><a class="reference internal" href="#kvm-cap-vm-copy-enc-context-from">7.24 KVM_CAP_VM_COPY_ENC_CONTEXT_FROM</a></li>
<li><a class="reference internal" href="#kvm-cap-sgx-attribute">7.25 KVM_CAP_SGX_ATTRIBUTE</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-rpt-invalidate">7.26 KVM_CAP_PPC_RPT_INVALIDATE</a></li>
<li><a class="reference internal" href="#kvm-cap-exit-on-emulation-failure">7.27 KVM_CAP_EXIT_ON_EMULATION_FAILURE</a></li>
<li><a class="reference internal" href="#kvm-cap-arm-mte">7.28 KVM_CAP_ARM_MTE</a></li>
<li><a class="reference internal" href="#kvm-cap-vm-move-enc-context-from">7.29 KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-ail-mode-3">7.30 KVM_CAP_PPC_AIL_MODE_3</a></li>
<li><a class="reference internal" href="#kvm-cap-disable-quirks2">7.31 KVM_CAP_DISABLE_QUIRKS2</a></li>
<li><a class="reference internal" href="#kvm-cap-max-vcpu-id">7.32 KVM_CAP_MAX_VCPU_ID</a></li>
<li><a class="reference internal" href="#kvm-cap-x86-notify-vmexit">7.33 KVM_CAP_X86_NOTIFY_VMEXIT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-capabilities">8. Other capabilities.</a><ul>
<li><a class="reference internal" href="#kvm-cap-ppc-hwrng">8.1 KVM_CAP_PPC_HWRNG</a></li>
<li><a class="reference internal" href="#kvm-cap-hyperv-synic">8.2 KVM_CAP_HYPERV_SYNIC</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-radix-mmu">8.3 KVM_CAP_PPC_RADIX_MMU</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-hash-mmu-v3">8.4 KVM_CAP_PPC_HASH_MMU_V3</a></li>
<li><a class="reference internal" href="#kvm-cap-mips-vz">8.5 KVM_CAP_MIPS_VZ</a></li>
<li><a class="reference internal" href="#kvm-cap-mips-te">8.6 KVM_CAP_MIPS_TE</a></li>
<li><a class="reference internal" href="#kvm-cap-mips-64bit">8.7 KVM_CAP_MIPS_64BIT</a></li>
<li><a class="reference internal" href="#kvm-cap-arm-user-irq">8.9 KVM_CAP_ARM_USER_IRQ</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-smt-possible">8.10 KVM_CAP_PPC_SMT_POSSIBLE</a></li>
<li><a class="reference internal" href="#kvm-cap-hyperv-synic2">8.11 KVM_CAP_HYPERV_SYNIC2</a></li>
<li><a class="reference internal" href="#kvm-cap-hyperv-vp-index">8.12 KVM_CAP_HYPERV_VP_INDEX</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-ais-migration">8.13 KVM_CAP_S390_AIS_MIGRATION</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-psw">8.14 KVM_CAP_S390_PSW</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-gmap">8.15 KVM_CAP_S390_GMAP</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-cow">8.16 KVM_CAP_S390_COW</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-bpb">8.17 KVM_CAP_S390_BPB</a></li>
<li><a class="reference internal" href="#kvm-cap-hyperv-tlbflush">8.18 KVM_CAP_HYPERV_TLBFLUSH</a></li>
<li><a class="reference internal" href="#kvm-cap-arm-inject-serror-esr">8.19 KVM_CAP_ARM_INJECT_SERROR_ESR</a></li>
<li><a class="reference internal" href="#kvm-cap-hyperv-send-ipi">8.20 KVM_CAP_HYPERV_SEND_IPI</a></li>
<li><a class="reference internal" href="#kvm-cap-hyperv-direct-tlbflush">8.21 KVM_CAP_HYPERV_DIRECT_TLBFLUSH</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-vcpu-resets">8.22 KVM_CAP_S390_VCPU_RESETS</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-protected">8.23 KVM_CAP_S390_PROTECTED</a></li>
<li><a class="reference internal" href="#kvm-cap-steal-time">8.24 KVM_CAP_STEAL_TIME</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-diag318">8.25 KVM_CAP_S390_DIAG318</a></li>
<li><a class="reference internal" href="#id12">8.26 KVM_CAP_X86_USER_SPACE_MSR</a></li>
<li><a class="reference internal" href="#kvm-cap-x86-msr-filter">8.27 KVM_CAP_X86_MSR_FILTER</a></li>
<li><a class="reference internal" href="#kvm-cap-enforce-pv-feature-cpuid">8.28 KVM_CAP_ENFORCE_PV_FEATURE_CPUID</a></li>
<li><a class="reference internal" href="#kvm-cap-dirty-log-ring-kvm-cap-dirty-log-ring-acq-rel">8.29 KVM_CAP_DIRTY_LOG_RING/KVM_CAP_DIRTY_LOG_RING_ACQ_REL</a></li>
<li><a class="reference internal" href="#kvm-cap-xen-hvm">8.30 KVM_CAP_XEN_HVM</a></li>
<li><a class="reference internal" href="#kvm-cap-ppc-multitce">8.31 KVM_CAP_PPC_MULTITCE</a></li>
<li><a class="reference internal" href="#kvm-cap-ptp-kvm">8.32 KVM_CAP_PTP_KVM</a></li>
<li><a class="reference internal" href="#kvm-cap-hyperv-enforce-cpuid">8.33 KVM_CAP_HYPERV_ENFORCE_CPUID</a></li>
<li><a class="reference internal" href="#kvm-cap-exit-hypercall">8.34 KVM_CAP_EXIT_HYPERCALL</a></li>
<li><a class="reference internal" href="#kvm-cap-pmu-capability">8.35 KVM_CAP_PMU_CAPABILITY</a></li>
<li><a class="reference internal" href="#kvm-cap-arm-system-suspend">8.36 KVM_CAP_ARM_SYSTEM_SUSPEND</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-protected-dump">8.37 KVM_CAP_S390_PROTECTED_DUMP</a></li>
<li><a class="reference internal" href="#kvm-cap-vm-disable-nx-huge-pages">8.38 KVM_CAP_VM_DISABLE_NX_HUGE_PAGES</a></li>
<li><a class="reference internal" href="#kvm-cap-s390-cpu-topology">8.39 KVM_CAP_S390_CPU_TOPOLOGY</a></li>
</ul>
</li>
<li><a class="reference internal" href="#known-kvm-api-problems">9. Known KVM API problems</a><ul>
<li><a class="reference internal" href="#id13">9.1. x86</a><ul>
<li><a class="reference internal" href="#kvm-get-supported-cpuid-issues"><code class="docutils literal notranslate"><span class="pre">KVM_GET_SUPPORTED_CPUID</span></code> issues</a><ul>
<li><a class="reference internal" href="#local-apic-features">Local APIC features</a></li>
<li><a class="reference internal" href="#cpu-topology">CPU topology</a></li>
</ul>
</li>
<li><a class="reference internal" href="#obsolete-ioctls-and-capabilities">Obsolete ioctls and capabilities</a></li>
<li><a class="reference internal" href="#ordering-of-kvm-get-kvm-set-ioctls">Ordering of KVM_GET_*/KVM_SET_* ioctls</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/virt/kvm/api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/virt/kvm/api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>