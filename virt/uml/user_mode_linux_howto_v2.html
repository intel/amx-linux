
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>UML HowTo &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Paravirt_ops" href="../paravirt_ops.html" />
    <link rel="prev" title="Review checklist for kvm patches" href="../kvm/review-checklist.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="uml-howto">
<h1>UML HowTo<a class="headerlink" href="#uml-howto" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#how-is-uml-different-from-a-vm-using-virtualization-package-x" id="id2">How is UML Different from a VM using Virtualization package X?</a></p></li>
<li><p><a class="reference internal" href="#why-would-i-want-user-mode-linux" id="id3">Why Would I Want User Mode Linux?</a></p></li>
<li><p><a class="reference internal" href="#why-not-to-run-uml" id="id4">Why not to run UML</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#building-a-uml-instance" id="id5">Building a UML instance</a></p>
<ul>
<li><p><a class="reference internal" href="#creating-an-image" id="id6">Creating an image</a></p></li>
<li><p><a class="reference internal" href="#edit-key-system-files" id="id7">Edit key system files</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#setting-up-uml-networking" id="id8">Setting Up UML Networking</a></p>
<ul>
<li><p><a class="reference internal" href="#network-configuration-privileges" id="id9">Network configuration privileges</a></p></li>
<li><p><a class="reference internal" href="#configuring-vector-transports" id="id10">Configuring vector transports</a></p>
<ul>
<li><p><a class="reference internal" href="#common-options" id="id11">Common options</a></p></li>
<li><p><a class="reference internal" href="#shared-options" id="id12">Shared Options</a></p></li>
<li><p><a class="reference internal" href="#tap-transport" id="id13">tap transport</a></p></li>
<li><p><a class="reference internal" href="#hybrid-transport" id="id14">hybrid transport</a></p></li>
<li><p><a class="reference internal" href="#raw-socket-transport" id="id15">raw socket transport</a></p></li>
<li><p><a class="reference internal" href="#gre-socket-transport" id="id16">GRE socket transport</a></p></li>
<li><p><a class="reference internal" href="#l2tpv3-socket-transport" id="id17">l2tpv3 socket transport</a></p></li>
<li><p><a class="reference internal" href="#bess-socket-transport" id="id18">BESS socket transport</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#configuring-legacy-transports" id="id19">Configuring Legacy transports</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#running-uml" id="id20">Running UML</a></p>
<ul>
<li><p><a class="reference internal" href="#arguments" id="id21">Arguments</a></p>
<ul>
<li><p><a class="reference internal" href="#mandatory-arguments" id="id22">Mandatory Arguments:</a></p></li>
<li><p><a class="reference internal" href="#important-optional-arguments" id="id23">Important Optional Arguments</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#starting-uml" id="id24">Starting UML</a></p></li>
<li><p><a class="reference internal" href="#logging-in" id="id25">Logging in</a></p></li>
<li><p><a class="reference internal" href="#the-uml-management-console" id="id26">The UML Management Console</a></p>
<ul>
<li><p><a class="reference internal" href="#version" id="id27">version</a></p></li>
<li><p><a class="reference internal" href="#help" id="id28">help</a></p></li>
<li><p><a class="reference internal" href="#halt-and-reboot" id="id29">halt and reboot</a></p></li>
<li><p><a class="reference internal" href="#config" id="id30">config</a></p></li>
<li><p><a class="reference internal" href="#remove" id="id31">remove</a></p></li>
<li><p><a class="reference internal" href="#sysrq" id="id32">sysrq</a></p></li>
<li><p><a class="reference internal" href="#cad" id="id33">cad</a></p></li>
<li><p><a class="reference internal" href="#stop" id="id34">stop</a></p></li>
<li><p><a class="reference internal" href="#go" id="id35">go</a></p></li>
<li><p><a class="reference internal" href="#proc" id="id36">proc</a></p></li>
<li><p><a class="reference internal" href="#stack" id="id37">stack</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#advanced-uml-topics" id="id38">Advanced UML Topics</a></p>
<ul>
<li><p><a class="reference internal" href="#sharing-filesystems-between-virtual-machines" id="id39">Sharing Filesystems between Virtual Machines</a></p>
<ul>
<li><p><a class="reference internal" href="#using-layered-block-devices" id="id40">Using layered block devices</a></p></li>
<li><p><a class="reference internal" href="#disk-usage" id="id41">Disk Usage</a></p></li>
<li><p><a class="reference internal" href="#cow-validity" id="id42">COW validity.</a></p></li>
<li><p><a class="reference internal" href="#cows-can-moo-uml-moo-merging-a-cow-file-with-its-backing-file" id="id43">Cows can moo - uml_moo : Merging a COW file with its backing file</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#host-file-access" id="id44">Host file access</a></p>
<ul>
<li><p><a class="reference internal" href="#using-hostfs" id="id45">Using hostfs</a></p></li>
<li><p><a class="reference internal" href="#hostfs-as-the-root-filesystem" id="id46">hostfs as the root filesystem</a></p></li>
<li><p><a class="reference internal" href="#hostfs-caveats" id="id47">Hostfs Caveats</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tuning-uml" id="id48">Tuning UML</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#contributing-to-uml-and-developing-with-uml" id="id49">Contributing to UML and Developing with UML</a></p>
<ul>
<li><p><a class="reference internal" href="#tracing-uml" id="id50">Tracing UML</a></p></li>
<li><p><a class="reference internal" href="#kernel-debugging" id="id51">Kernel debugging</a></p></li>
<li><p><a class="reference internal" href="#developing-device-drivers" id="id52">Developing Device Drivers</a></p></li>
<li><p><a class="reference internal" href="#using-uml-as-a-test-platform" id="id53">Using UML as a Test Platform</a></p>
<ul>
<li><p><a class="reference internal" href="#security-considerations" id="id54">Security Considerations</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id1">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Welcome to User Mode Linux</p>
<p>User Mode Linux is the first Open Source virtualization platform (first
release date 1991) and second virtualization platform for an x86 PC.</p>
<section id="how-is-uml-different-from-a-vm-using-virtualization-package-x">
<h3><a class="toc-backref" href="#id2">How is UML Different from a VM using Virtualization package X?</a><a class="headerlink" href="#how-is-uml-different-from-a-vm-using-virtualization-package-x" title="Permalink to this headline">¶</a></h3>
<p>We have come to assume that virtualization also means some level of
hardware emulation. In fact, it does not. As long as a virtualization
package provides the OS with devices which the OS can recognize and
has a driver for, the devices do not need to emulate real hardware.
Most OSes today have built-in support for a number of “fake”
devices used only under virtualization.
User Mode Linux takes this concept to the ultimate extreme - there
is not a single real device in sight. It is 100% artificial or if
we use the correct term 100% paravirtual. All UML devices are abstract
concepts which map onto something provided by the host - files, sockets,
pipes, etc.</p>
<p>The other major difference between UML and various virtualization
packages is that there is a distinct difference between the way the UML
kernel and the UML programs operate.
The UML kernel is just a process running on Linux - same as any other
program. It can be run by an unprivileged user and it does not require
anything in terms of special CPU features.
The UML userspace, however, is a bit different. The Linux kernel on the
host machine assists UML in intercepting everything the program running
on a UML instance is trying to do and making the UML kernel handle all
of its requests.
This is different from other virtualization packages which do not make any
difference between the guest kernel and guest programs. This difference
results in a number of advantages and disadvantages of UML over let’s say
QEMU which we will cover later in this document.</p>
</section>
<section id="why-would-i-want-user-mode-linux">
<h3><a class="toc-backref" href="#id3">Why Would I Want User Mode Linux?</a><a class="headerlink" href="#why-would-i-want-user-mode-linux" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>If User Mode Linux kernel crashes, your host kernel is still fine. It
is not accelerated in any way (vhost, kvm, etc) and it is not trying to
access any devices directly.  It is, in fact, a process like any other.</p></li>
<li><p>You can run a usermode kernel as a non-root user (you may need to
arrange appropriate permissions for some devices).</p></li>
<li><p>You can run a very small VM with a minimal footprint for a specific
task (for example 32M or less).</p></li>
<li><p>You can get extremely high performance for anything which is a “kernel
specific task” such as forwarding, firewalling, etc while still being
isolated from the host kernel.</p></li>
<li><p>You can play with kernel concepts without breaking things.</p></li>
<li><p>You are not bound by “emulating” hardware, so you can try weird and
wonderful concepts which are very difficult to support when emulating
real hardware such as time travel and making your system clock
dependent on what UML does (very useful for things like tests).</p></li>
<li><p>It’s fun.</p></li>
</ul>
</section>
<section id="why-not-to-run-uml">
<h3><a class="toc-backref" href="#id4">Why not to run UML</a><a class="headerlink" href="#why-not-to-run-uml" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>The syscall interception technique used by UML makes it inherently
slower for any userspace applications. While it can do kernel tasks
on par with most other virtualization packages, its userspace is
<strong>slow</strong>. The root cause is that UML has a very high cost of creating
new processes and threads (something most Unix/Linux applications
take for granted).</p></li>
<li><p>UML is strictly uniprocessor at present. If you want to run an
application which needs many CPUs to function, it is clearly the
wrong choice.</p></li>
</ul>
</section>
</section>
<section id="building-a-uml-instance">
<h2><a class="toc-backref" href="#id5">Building a UML instance</a><a class="headerlink" href="#building-a-uml-instance" title="Permalink to this headline">¶</a></h2>
<p>There is no UML installer in any distribution. While you can use off
the shelf install media to install into a blank VM using a virtualization
package, there is no UML equivalent. You have to use appropriate tools on
your host to build a viable filesystem image.</p>
<p>This is extremely easy on Debian - you can do it using debootstrap. It is
also easy on OpenWRT - the build process can build UML images. All other
distros - YMMV.</p>
<section id="creating-an-image">
<h3><a class="toc-backref" href="#id6">Creating an image</a><a class="headerlink" href="#creating-an-image" title="Permalink to this headline">¶</a></h3>
<p>Create a sparse raw disk image:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># dd if=/dev/zero of=disk_image_name bs=1 count=1 seek=16G
</pre></div>
</div>
<p>This will create a 16G disk image. The OS will initially allocate only one
block and will allocate more as they are written by UML. As of kernel
version 4.19 UML fully supports TRIM (as usually used by flash drives).
Using TRIM inside the UML image by specifying discard as a mount option
or by running <code class="docutils literal notranslate"><span class="pre">tune2fs</span> <span class="pre">-o</span> <span class="pre">discard</span> <span class="pre">/dev/ubdXX</span></code> will request UML to
return any unused blocks to the OS.</p>
<p>Create a filesystem on the disk image and mount it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mkfs.ext4 ./disk_image_name &amp;&amp; mount ./disk_image_name /mnt
</pre></div>
</div>
<p>This example uses ext4, any other filesystem such as ext3, btrfs, xfs,
jfs, etc will work too.</p>
<p>Create a minimal OS installation on the mounted filesystem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># debootstrap buster /mnt http://deb.debian.org/debian
</pre></div>
</div>
<p>debootstrap does not set up the root password, fstab, hostname or
anything related to networking. It is up to the user to do that.</p>
<p>Set the root password - the easiest way to do that is to chroot into the
mounted image:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># chroot /mnt
# passwd
# exit
</pre></div>
</div>
</section>
<section id="edit-key-system-files">
<h3><a class="toc-backref" href="#id7">Edit key system files</a><a class="headerlink" href="#edit-key-system-files" title="Permalink to this headline">¶</a></h3>
<p>UML block devices are called ubds. The fstab created by debootstrap
will be empty and it needs an entry for the root file system:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/dev/ubd0   ext4    discard,errors=remount-ro  0       1
</pre></div>
</div>
<p>The image hostname will be set to the same as the host on which you
are creating its image. It is a good idea to change that to avoid
“Oh, bummer, I rebooted the wrong machine”.</p>
<p>UML supports two classes of network devices - the older uml_net ones
which are scheduled for obsoletion. These are called ethX. It also
supports the newer vector IO devices which are significantly faster
and have support for some standard virtual network encapsulations like
Ethernet over GRE and Ethernet over L2TPv3. These are called vec0.</p>
<p>Depending on which one is in use, <code class="docutils literal notranslate"><span class="pre">/etc/network/interfaces</span></code> will
need entries like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># legacy UML network devices
auto eth0
iface eth0 inet dhcp

# vector UML network devices
auto vec0
iface vec0 inet dhcp
</pre></div>
</div>
<p>We now have a UML image which is nearly ready to run, all we need is a
UML kernel and modules for it.</p>
<p>Most distributions have a UML package. Even if you intend to use your own
kernel, testing the image with a stock one is always a good start. These
packages come with a set of modules which should be copied to the target
filesystem. The location is distribution dependent. For Debian these
reside under /usr/lib/uml/modules. Copy recursively the content of this
directory to the mounted UML filesystem:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cp -rax /usr/lib/uml/modules /mnt/lib/modules
</pre></div>
</div>
<p>If you have compiled your own kernel, you need to use the usual “install
modules to a location” procedure by running:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># make INSTALL_MOD_PATH=/mnt/lib/modules modules_install
</pre></div>
</div>
<p>This will install modules into /mnt/lib/modules/$(KERNELRELEASE).
To specify the full module installation path, use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># make MODLIB=/mnt/lib/modules modules_install
</pre></div>
</div>
<p>At this point the image is ready to be brought up.</p>
</section>
</section>
<section id="setting-up-uml-networking">
<h2><a class="toc-backref" href="#id8">Setting Up UML Networking</a><a class="headerlink" href="#setting-up-uml-networking" title="Permalink to this headline">¶</a></h2>
<p>UML networking is designed to emulate an Ethernet connection. This
connection may be either point-to-point (similar to a connection
between machines using a back-to-back cable) or a connection to a
switch. UML supports a wide variety of means to build these
connections to all of: local machine, remote machine(s), local and
remote UML and other VM instances.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 12%" />
<col style="width: 54%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Transport</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Capabilities</p></th>
<th class="head"><p>Throughput</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tap</p></td>
<td><p>vector</p></td>
<td><p>checksum, tso</p></td>
<td><p>&gt; 8Gbit</p></td>
</tr>
<tr class="row-odd"><td><p>hybrid</p></td>
<td><p>vector</p></td>
<td><p>checksum, tso, multipacket rx</p></td>
<td><p>&gt; 6GBit</p></td>
</tr>
<tr class="row-even"><td><p>raw</p></td>
<td><p>vector</p></td>
<td><p>checksum, tso, multipacket rx, tx”</p></td>
<td><p>&gt; 6GBit</p></td>
</tr>
<tr class="row-odd"><td><p>EoGRE</p></td>
<td><p>vector</p></td>
<td><p>multipacket rx, tx</p></td>
<td><p>&gt; 3Gbit</p></td>
</tr>
<tr class="row-even"><td><p>Eol2tpv3</p></td>
<td><p>vector</p></td>
<td><p>multipacket rx, tx</p></td>
<td><p>&gt; 3Gbit</p></td>
</tr>
<tr class="row-odd"><td><p>bess</p></td>
<td><p>vector</p></td>
<td><p>multipacket rx, tx</p></td>
<td><p>&gt; 3Gbit</p></td>
</tr>
<tr class="row-even"><td><p>fd</p></td>
<td><p>vector</p></td>
<td><p>dependent on fd type</p></td>
<td><p>varies</p></td>
</tr>
<tr class="row-odd"><td><p>tuntap</p></td>
<td><p>legacy</p></td>
<td><p>none</p></td>
<td><p>~ 500Mbit</p></td>
</tr>
<tr class="row-even"><td><p>daemon</p></td>
<td><p>legacy</p></td>
<td><p>none</p></td>
<td><p>~ 450Mbit</p></td>
</tr>
<tr class="row-odd"><td><p>socket</p></td>
<td><p>legacy</p></td>
<td><p>none</p></td>
<td><p>~ 450Mbit</p></td>
</tr>
<tr class="row-even"><td><p>pcap</p></td>
<td><p>legacy</p></td>
<td><p>rx only</p></td>
<td><p>~ 450Mbit</p></td>
</tr>
<tr class="row-odd"><td><p>ethertap</p></td>
<td><p>legacy</p></td>
<td><p>obsolete</p></td>
<td><p>~ 500Mbit</p></td>
</tr>
<tr class="row-even"><td><p>vde</p></td>
<td><p>legacy</p></td>
<td><p>obsolete</p></td>
<td><p>~ 500Mbit</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>All transports which have tso and checksum offloads can deliver speeds
approaching 10G on TCP streams.</p></li>
<li><p>All transports which have multi-packet rx and/or tx can deliver pps
rates of up to 1Mps or more.</p></li>
<li><p>All legacy transports are generally limited to ~600-700MBit and 0.05Mps.</p></li>
<li><p>GRE and L2TPv3 allow connections to all of: local machine, remote
machines, remote network devices and remote UML instances.</p></li>
<li><p>Socket allows connections only between UML instances.</p></li>
<li><p>Daemon and bess require running a local switch. This switch may be
connected to the host as well.</p></li>
</ul>
<section id="network-configuration-privileges">
<h3><a class="toc-backref" href="#id9">Network configuration privileges</a><a class="headerlink" href="#network-configuration-privileges" title="Permalink to this headline">¶</a></h3>
<p>The majority of the supported networking modes need <code class="docutils literal notranslate"><span class="pre">root</span></code> privileges.
For example, in the legacy tuntap networking mode, users were required
to be part of the group associated with the tunnel device.</p>
<p>For newer network drivers like the vector transports, <code class="docutils literal notranslate"><span class="pre">root</span></code> privilege
is required to fire an ioctl to setup the tun interface and/or use
raw sockets where needed.</p>
<p>This can be achieved by granting the user a particular capability instead
of running UML as root.  In case of vector transport, a user can add the
capability <code class="docutils literal notranslate"><span class="pre">CAP_NET_ADMIN</span></code> or <code class="docutils literal notranslate"><span class="pre">CAP_NET_RAW</span></code> to the uml binary.
Thenceforth, UML can be run with normal user privilges, along with
full networking.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># sudo setcap cap_net_raw,cap_net_admin+ep linux
</pre></div>
</div>
</section>
<section id="configuring-vector-transports">
<h3><a class="toc-backref" href="#id10">Configuring vector transports</a><a class="headerlink" href="#configuring-vector-transports" title="Permalink to this headline">¶</a></h3>
<p>All vector transports support a similar syntax:</p>
<p>If X is the interface number as in vec0, vec1, vec2, etc, the general
syntax for options is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vecX:transport=&quot;Transport Name&quot;,option=value,option=value,...,option=value
</pre></div>
</div>
<section id="common-options">
<h4><a class="toc-backref" href="#id11">Common options</a><a class="headerlink" href="#common-options" title="Permalink to this headline">¶</a></h4>
<p>These options are common for all transports:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">depth=int</span></code> - sets the queue depth for vector IO. This is the
amount of packets UML will attempt to read or write in a single
system call. The default number is 64 and is generally sufficient
for most applications that need throughput in the 2-4 Gbit range.
Higher speeds may require larger values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mac=XX:XX:XX:XX:XX</span></code> - sets the interface MAC address value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gro=[0,1]</span></code> - sets GRO off or on. Enables receive/transmit offloads.
The effect of this option depends on the host side support in the transport
which is being configured. In most cases it will enable TCP segmentation and
RX/TX checksumming offloads. The setting must be identical on the host side
and the UML side. The UML kernel will produce warnings if it is not.
For example, GRO is enabled by default on local machine interfaces
(e.g. veth pairs, bridge, etc), so it should be enabled in UML in the
corresponding UML transports (raw, tap, hybrid) in order for networking to
operate correctly.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtu=int</span></code> - sets the interface MTU</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">headroom=int</span></code> - adjusts the default headroom (32 bytes) reserved
if a packet will need to be re-encapsulated into for instance VXLAN.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vec=0</span></code> - disable multipacket IO and fall back to packet at a
time mode</p></li>
</ul>
</section>
<section id="shared-options">
<h4><a class="toc-backref" href="#id12">Shared Options</a><a class="headerlink" href="#shared-options" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ifname=str</span></code> Transports which bind to a local network interface
have a shared option - the name of the interface to bind to.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src,</span> <span class="pre">dst,</span> <span class="pre">src_port,</span> <span class="pre">dst_port</span></code> - all transports which use sockets
which have the notion of source and destination and/or source port
and destination port use these to specify them.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v6=[0,1]</span></code> to specify if a v6 connection is desired for all
transports which operate over IP. Additionally, for transports that
have some differences in the way they operate over v4 and v6 (for example
EoL2TPv3), sets the correct mode of operation. In the absence of this
option, the socket type is determined based on what do the src and dst
arguments resolve/parse to.</p></li>
</ul>
</section>
<section id="tap-transport">
<h4><a class="toc-backref" href="#id13">tap transport</a><a class="headerlink" href="#tap-transport" title="Permalink to this headline">¶</a></h4>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vecX:transport=tap,ifname=tap0,depth=128,gro=1
</pre></div>
</div>
<p>This will connect vec0 to tap0 on the host. Tap0 must already exist (for example
created using tunctl) and UP.</p>
<p>tap0 can be configured as a point-to-point interface and given an IP
address so that UML can talk to the host. Alternatively, it is possible
to connect UML to a tap interface which is connected to a bridge.</p>
<p>While tap relies on the vector infrastructure, it is not a true vector
transport at this point, because Linux does not support multi-packet
IO on tap file descriptors for normal userspace apps like UML. This
is a privilege which is offered only to something which can hook up
to it at kernel level via specialized interfaces like vhost-net. A
vhost-net like helper for UML is planned at some point in the future.</p>
<p>Privileges required: tap transport requires either:</p>
<ul class="simple">
<li><p>tap interface to exist and be created persistent and owned by the
UML user using tunctl. Example <code class="docutils literal notranslate"><span class="pre">tunctl</span> <span class="pre">-u</span> <span class="pre">uml-user</span> <span class="pre">-t</span> <span class="pre">tap0</span></code></p></li>
<li><p>binary to have <code class="docutils literal notranslate"><span class="pre">CAP_NET_ADMIN</span></code> privilege</p></li>
</ul>
</section>
<section id="hybrid-transport">
<h4><a class="toc-backref" href="#id14">hybrid transport</a><a class="headerlink" href="#hybrid-transport" title="Permalink to this headline">¶</a></h4>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vecX:transport=hybrid,ifname=tap0,depth=128,gro=1
</pre></div>
</div>
<p>This is an experimental/demo transport which couples tap for transmit
and a raw socket for receive. The raw socket allows multi-packet
receive resulting in significantly higher packet rates than normal tap.</p>
<p>Privileges required: hybrid requires <code class="docutils literal notranslate"><span class="pre">CAP_NET_RAW</span></code> capability by
the UML user as well as the requirements for the tap transport.</p>
</section>
<section id="raw-socket-transport">
<h4><a class="toc-backref" href="#id15">raw socket transport</a><a class="headerlink" href="#raw-socket-transport" title="Permalink to this headline">¶</a></h4>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vecX:transport=raw,ifname=p-veth0,depth=128,gro=1
</pre></div>
</div>
<p>This transport uses vector IO on raw sockets. While you can bind to any
interface including a physical one, the most common use it to bind to
the “peer” side of a veth pair with the other side configured on the
host.</p>
<p>Example host configuration for Debian:</p>
<p><strong>/etc/network/interfaces</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto veth0
iface veth0 inet static
     address 192.168.4.1
     netmask 255.255.255.252
     broadcast 192.168.4.3
     pre-up ip link add veth0 type veth peer name p-veth0 &amp;&amp; \
       ifconfig p-veth0 up
</pre></div>
</div>
<p>UML can now bind to p-veth0 like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vec0:transport=raw,ifname=p-veth0,depth=128,gro=1
</pre></div>
</div>
<p>If the UML guest is configured with 192.168.4.2 and netmask 255.255.255.0
it can talk to the host on 192.168.4.1</p>
<p>The raw transport also provides some support for offloading some of the
filtering to the host. The two options to control it are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bpffile=str</span></code> filename of raw bpf code to be loaded as a socket filter</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bpfflash=int</span></code> 0/1 allow loading of bpf from inside User Mode Linux.
This option allows the use of the ethtool load firmware command to
load bpf code.</p></li>
</ul>
<p>In either case the bpf code is loaded into the host kernel. While this is
presently limited to legacy bpf syntax (not ebpf), it is still a security
risk. It is not recommended to allow this unless the User Mode Linux
instance is considered trusted.</p>
<p>Privileges required: raw socket transport requires <cite>CAP_NET_RAW</cite>
capability.</p>
</section>
<section id="gre-socket-transport">
<h4><a class="toc-backref" href="#id16">GRE socket transport</a><a class="headerlink" href="#gre-socket-transport" title="Permalink to this headline">¶</a></h4>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vecX:transport=gre,src=$src_host,dst=$dst_host
</pre></div>
</div>
<p>This will configure an Ethernet over <code class="docutils literal notranslate"><span class="pre">GRE</span></code> (aka <code class="docutils literal notranslate"><span class="pre">GRETAP</span></code> or
<code class="docutils literal notranslate"><span class="pre">GREIRB</span></code>) tunnel which will connect the UML instance to a <code class="docutils literal notranslate"><span class="pre">GRE</span></code>
endpoint at host dst_host. <code class="docutils literal notranslate"><span class="pre">GRE</span></code> supports the following additional
options:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rx_key=int</span></code> - GRE 32-bit integer key for rx packets, if set,
<code class="docutils literal notranslate"><span class="pre">txkey</span></code> must be set too</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx_key=int</span></code> - GRE 32-bit integer key for tx packets, if set
<code class="docutils literal notranslate"><span class="pre">rx_key</span></code> must be set too</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sequence=[0,1]</span></code> - enable GRE sequence</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pin_sequence=[0,1]</span></code> - pretend that the sequence is always reset
on each packet (needed to interoperate with some really broken
implementations)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v6=[0,1]</span></code> - force IPv4 or IPv6 sockets respectively</p></li>
<li><p>GRE checksum is not presently supported</p></li>
</ul>
<p>GRE has a number of caveats:</p>
<ul class="simple">
<li><p>You can use only one GRE connection per IP address. There is no way to
multiplex connections as each GRE tunnel is terminated directly on
the UML instance.</p></li>
<li><p>The key is not really a security feature. While it was intended as such
its “security” is laughable. It is, however, a useful feature to
ensure that the tunnel is not misconfigured.</p></li>
</ul>
<p>An example configuration for a Linux host with a local address of
192.168.128.1 to connect to a UML instance at 192.168.129.1</p>
<p><strong>/etc/network/interfaces</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto gt0
iface gt0 inet static
 address 10.0.0.1
 netmask 255.255.255.0
 broadcast 10.0.0.255
 mtu 1500
 pre-up ip link add gt0 type gretap local 192.168.128.1 \
        remote 192.168.129.1 || true
 down ip link del gt0 || true
</pre></div>
</div>
<p>Additionally, GRE has been tested versus a variety of network equipment.</p>
<p>Privileges required: GRE requires <code class="docutils literal notranslate"><span class="pre">CAP_NET_RAW</span></code></p>
</section>
<section id="l2tpv3-socket-transport">
<h4><a class="toc-backref" href="#id17">l2tpv3 socket transport</a><a class="headerlink" href="#l2tpv3-socket-transport" title="Permalink to this headline">¶</a></h4>
<p>_Warning_. L2TPv3 has a “bug”. It is the “bug” known as “has more
options than GNU ls”. While it has some advantages, there are usually
easier (and less verbose) ways to connect a UML instance to something.
For example, most devices which support L2TPv3 also support GRE.</p>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vec0:transport=l2tpv3,udp=1,src=$src_host,dst=$dst_host,srcport=$src_port,dstport=$dst_port,depth=128,rx_session=0xffffffff,tx_session=0xffff
</pre></div>
</div>
<p>This will configure an Ethernet over L2TPv3 fixed tunnel which will
connect the UML instance to a L2TPv3 endpoint at host $dst_host using
the L2TPv3 UDP flavour and UDP destination port $dst_port.</p>
<p>L2TPv3 always requires the following additional options:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rx_session=int</span></code> - l2tpv3 32-bit integer session for rx packets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx_session=int</span></code> - l2tpv3 32-bit integer session for tx packets</p></li>
</ul>
<p>As the tunnel is fixed these are not negotiated and they are
preconfigured on both ends.</p>
<p>Additionally, L2TPv3 supports the following optional parameters.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rx_cookie=int</span></code> - l2tpv3 32-bit integer cookie for rx packets - same
functionality as GRE key, more to prevent misconfiguration than provide
actual security</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx_cookie=int</span></code> - l2tpv3 32-bit integer cookie for tx packets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cookie64=[0,1]</span></code> - use 64-bit cookies instead of 32-bit.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">counter=[0,1]</span></code> - enable l2tpv3 counter</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pin_counter=[0,1]</span></code> - pretend that the counter is always reset on
each packet (needed to interoperate with some really broken
implementations)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v6=[0,1]</span></code> - force v6 sockets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">udp=[0,1]</span></code> - use raw sockets (0) or UDP (1) version of the protocol</p></li>
</ul>
<p>L2TPv3 has a number of caveats:</p>
<ul class="simple">
<li><p>you can use only one connection per IP address in raw mode. There is
no way to multiplex connections as each L2TPv3 tunnel is terminated
directly on the UML instance. UDP mode can use different ports for
this purpose.</p></li>
</ul>
<p>Here is an example of how to configure a Linux host to connect to UML
via L2TPv3:</p>
<p><strong>/etc/network/interfaces</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto l2tp1
iface l2tp1 inet static
 address 192.168.126.1
 netmask 255.255.255.0
 broadcast 192.168.126.255
 mtu 1500
 pre-up ip l2tp add tunnel remote 127.0.0.1 \
        local 127.0.0.1 encap udp tunnel_id 2 \
        peer_tunnel_id 2 udp_sport 1706 udp_dport 1707 &amp;&amp; \
        ip l2tp add session name l2tp1 tunnel_id 2 \
        session_id 0xffffffff peer_session_id 0xffffffff
 down ip l2tp del session tunnel_id 2 session_id 0xffffffff &amp;&amp; \
        ip l2tp del tunnel tunnel_id 2
</pre></div>
</div>
<p>Privileges required: L2TPv3 requires <code class="docutils literal notranslate"><span class="pre">CAP_NET_RAW</span></code> for raw IP mode and
no special privileges for the UDP mode.</p>
</section>
<section id="bess-socket-transport">
<h4><a class="toc-backref" href="#id18">BESS socket transport</a><a class="headerlink" href="#bess-socket-transport" title="Permalink to this headline">¶</a></h4>
<p>BESS is a high performance modular network switch.</p>
<p><a class="reference external" href="https://github.com/NetSys/bess">https://github.com/NetSys/bess</a></p>
<p>It has support for a simple sequential packet socket mode which in the
more recent versions is using vector IO for high performance.</p>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>vecX:transport=bess,src=$unix_src,dst=$unix_dst
</pre></div>
</div>
<p>This will configure a BESS transport using the unix_src Unix domain
socket address as source and unix_dst socket address as destination.</p>
<p>For BESS configuration and how to allocate a BESS Unix domain socket port
please see the BESS documentation.</p>
<p><a class="reference external" href="https://github.com/NetSys/bess/wiki/Built-In-Modules-and-Ports">https://github.com/NetSys/bess/wiki/Built-In-Modules-and-Ports</a></p>
<p>BESS transport does not require any special privileges.</p>
</section>
</section>
<section id="configuring-legacy-transports">
<h3><a class="toc-backref" href="#id19">Configuring Legacy transports</a><a class="headerlink" href="#configuring-legacy-transports" title="Permalink to this headline">¶</a></h3>
<p>Legacy transports are now considered obsolete. Please use the vector
versions.</p>
</section>
</section>
<section id="running-uml">
<h2><a class="toc-backref" href="#id20">Running UML</a><a class="headerlink" href="#running-uml" title="Permalink to this headline">¶</a></h2>
<p>This section assumes that either the user-mode-linux package from the
distribution or a custom built kernel has been installed on the host.</p>
<p>These add an executable called linux to the system. This is the UML
kernel. It can be run just like any other executable.
It will take most normal linux kernel arguments as command line
arguments.  Additionally, it will need some UML-specific arguments
in order to do something useful.</p>
<section id="arguments">
<h3><a class="toc-backref" href="#id21">Arguments</a><a class="headerlink" href="#arguments" title="Permalink to this headline">¶</a></h3>
<section id="mandatory-arguments">
<h4><a class="toc-backref" href="#id22">Mandatory Arguments:</a><a class="headerlink" href="#mandatory-arguments" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mem=int[K,M,G]</span></code> - amount of memory. By default in bytes. It will
also accept K, M or G qualifiers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ubdX[s,d,c,t]=</span></code> virtual disk specification. This is not really
mandatory, but it is likely to be needed in nearly all cases so we can
specify a root file system.
The simplest possible image specification is the name of the image
file for the filesystem (created using one of the methods described
in <a class="reference internal" href="#creating-an-image">Creating an image</a>).</p>
<ul>
<li><p>UBD devices support copy on write (COW). The changes are kept in
a separate file which can be discarded allowing a rollback to the
original pristine image.  If COW is desired, the UBD image is
specified as: <code class="docutils literal notranslate"><span class="pre">cow_file,master_image</span></code>.
Example:<code class="docutils literal notranslate"><span class="pre">ubd0=Filesystem.cow,Filesystem.img</span></code></p></li>
<li><p>UBD devices can be set to use synchronous IO. Any writes are
immediately flushed to disk. This is done by adding <code class="docutils literal notranslate"><span class="pre">s</span></code> after
the <code class="docutils literal notranslate"><span class="pre">ubdX</span></code> specification.</p></li>
<li><p>UBD performs some heuristics on devices specified as a single
filename to make sure that a COW file has not been specified as
the image. To turn them off, use the <code class="docutils literal notranslate"><span class="pre">d</span></code> flag after <code class="docutils literal notranslate"><span class="pre">ubdX</span></code>.</p></li>
<li><p>UBD supports TRIM - asking the Host OS to reclaim any unused
blocks in the image. To turn it off, specify the <code class="docutils literal notranslate"><span class="pre">t</span></code> flag after
<code class="docutils literal notranslate"><span class="pre">ubdX</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">root=</span></code> root device - most likely <code class="docutils literal notranslate"><span class="pre">/dev/ubd0</span></code> (this is a Linux
filesystem image)</p></li>
</ul>
</section>
<section id="important-optional-arguments">
<h4><a class="toc-backref" href="#id23">Important Optional Arguments</a><a class="headerlink" href="#important-optional-arguments" title="Permalink to this headline">¶</a></h4>
<p>If UML is run as “linux” with no extra arguments, it will try to start an
xterm for every console configured inside the image (up to 6 in most
Linux distributions). Each console is started inside an
xterm. This makes it nice and easy to use UML on a host with a GUI. It is,
however, the wrong approach if UML is to be used as a testing harness or run
in a text-only environment.</p>
<p>In order to change this behaviour we need to specify an alternative console
and wire it to one of the supported “line” channels. For this we need to map a
console to use something different from the default xterm.</p>
<p>Example which will divert console number 1 to stdin/stdout:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>con1=fd:0,fd:1
</pre></div>
</div>
<p>UML supports a wide variety of serial line channels which are specified using
the following syntax</p>
<blockquote>
<div><p>conX=channel_type:options[,channel_type:options]</p>
</div></blockquote>
<p>If the channel specification contains two parts separated by comma, the first
one is input, the second one output.</p>
<ul class="simple">
<li><p>The null channel - Discard all input or output. Example <code class="docutils literal notranslate"><span class="pre">con=null</span></code> will set
all consoles to null by default.</p></li>
<li><p>The fd channel - use file descriptor numbers for input/output. Example:
<code class="docutils literal notranslate"><span class="pre">con1=fd:0,fd:1.</span></code></p></li>
<li><p>The port channel - start a telnet server on TCP port number. Example:
<code class="docutils literal notranslate"><span class="pre">con1=port:4321</span></code>.  The host must have /usr/sbin/in.telnetd (usually part of
a telnetd package) and the port-helper from the UML utilities (see the
information for the xterm channel below).  UML will not boot until a client
connects.</p></li>
<li><p>The pty and pts channels - use system pty/pts.</p></li>
<li><p>The tty channel - bind to an existing system tty. Example: <code class="docutils literal notranslate"><span class="pre">con1=/dev/tty8</span></code>
will make UML use the host 8th console (usually unused).</p></li>
<li><p>The xterm channel - this is the default - bring up an xterm on this channel
and direct IO to it. Note that in order for xterm to work, the host must
have the UML distribution package installed. This usually contains the
port-helper and other utilities needed for UML to communicate with the xterm.
Alternatively, these need to be complied and installed from source. All
options applicable to consoles also apply to UML serial lines which are
presented as ttyS inside UML.</p></li>
</ul>
</section>
</section>
<section id="starting-uml">
<h3><a class="toc-backref" href="#id24">Starting UML</a><a class="headerlink" href="#starting-uml" title="Permalink to this headline">¶</a></h3>
<p>We can now run UML.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># linux mem=2048M umid=TEST \
 ubd0=Filesystem.img \
 vec0:transport=tap,ifname=tap0,depth=128,gro=1 \
 root=/dev/ubda con=null con0=null,fd:2 con1=fd:0,fd:1
</pre></div>
</div>
<p>This will run an instance with <code class="docutils literal notranslate"><span class="pre">2048M</span> <span class="pre">RAM</span></code> and try to use the image file
called <code class="docutils literal notranslate"><span class="pre">Filesystem.img</span></code> as root. It will connect to the host using tap0.
All consoles except <code class="docutils literal notranslate"><span class="pre">con1</span></code> will be disabled and console 1 will
use standard input/output making it appear in the same terminal it was started.</p>
</section>
<section id="logging-in">
<h3><a class="toc-backref" href="#id25">Logging in</a><a class="headerlink" href="#logging-in" title="Permalink to this headline">¶</a></h3>
<p>If you have not set up a password when generating the image, you will have to
shut down the UML instance, mount the image, chroot into it and set it - as
described in the Generating an Image section.  If the password is already set,
you can just log in.</p>
</section>
<section id="the-uml-management-console">
<h3><a class="toc-backref" href="#id26">The UML Management Console</a><a class="headerlink" href="#the-uml-management-console" title="Permalink to this headline">¶</a></h3>
<p>In addition to managing the image from “the inside” using normal sysadmin tools,
it is possible to perform a number of low-level operations using the UML
management console. The UML management console is a low-level interface to the
kernel on a running UML instance, somewhat like the i386 SysRq interface. Since
there is a full-blown operating system under UML, there is much greater
flexibility possible than with the SysRq mechanism.</p>
<p>There are a number of things you can do with the mconsole interface:</p>
<ul class="simple">
<li><p>get the kernel version</p></li>
<li><p>add and remove devices</p></li>
<li><p>halt or reboot the machine</p></li>
<li><p>Send SysRq commands</p></li>
<li><p>Pause and resume the UML</p></li>
<li><p>Inspect processes running inside UML</p></li>
<li><p>Inspect UML internal /proc state</p></li>
</ul>
<p>You need the mconsole client (uml_mconsole) which is a part of the UML
tools package available in most Linux distritions.</p>
<p>You also need <code class="docutils literal notranslate"><span class="pre">CONFIG_MCONSOLE</span></code> (under ‘General Setup’) enabled in the UML
kernel.  When you boot UML, you’ll see a line like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mconsole initialized on /home/jdike/.uml/umlNJ32yL/mconsole
</pre></div>
</div>
<p>If you specify a unique machine id on the UML command line, i.e.
<code class="docutils literal notranslate"><span class="pre">umid=debian</span></code>, you’ll see this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mconsole initialized on /home/jdike/.uml/debian/mconsole
</pre></div>
</div>
<p>That file is the socket that uml_mconsole will use to communicate with
UML.  Run it with either the umid or the full path as its argument:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># uml_mconsole debian
</pre></div>
</div>
<p>or</p>
<blockquote>
<div><p># uml_mconsole /home/jdike/.uml/debian/mconsole</p>
</div></blockquote>
<p>You’ll get a prompt, at which you can run one of these commands:</p>
<ul class="simple">
<li><p>version</p></li>
<li><p>help</p></li>
<li><p>halt</p></li>
<li><p>reboot</p></li>
<li><p>config</p></li>
<li><p>remove</p></li>
<li><p>sysrq</p></li>
<li><p>help</p></li>
<li><p>cad</p></li>
<li><p>stop</p></li>
<li><p>go</p></li>
<li><p>proc</p></li>
<li><p>stack</p></li>
</ul>
<section id="version">
<h4><a class="toc-backref" href="#id27">version</a><a class="headerlink" href="#version" title="Permalink to this headline">¶</a></h4>
<p>This command takes no arguments.  It prints the UML version:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(mconsole)  version
OK Linux OpenWrt 4.14.106 #0 Tue Mar 19 08:19:41 2019 x86_64
</pre></div>
</div>
<p>There are a couple actual uses for this.  It’s a simple no-op which
can be used to check that a UML is running.  It’s also a way of
sending a device interrupt to the UML. UML mconsole is treated internally as
a UML device.</p>
</section>
<section id="help">
<h4><a class="toc-backref" href="#id28">help</a><a class="headerlink" href="#help" title="Permalink to this headline">¶</a></h4>
<p>This command takes no arguments. It prints a short help screen with the
supported mconsole commands.</p>
</section>
<section id="halt-and-reboot">
<h4><a class="toc-backref" href="#id29">halt and reboot</a><a class="headerlink" href="#halt-and-reboot" title="Permalink to this headline">¶</a></h4>
<p>These commands take no arguments.  They shut the machine down immediately, with
no syncing of disks and no clean shutdown of userspace.  So, they are
pretty close to crashing the machine:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(mconsole)  halt
OK
</pre></div>
</div>
</section>
<section id="config">
<h4><a class="toc-backref" href="#id30">config</a><a class="headerlink" href="#config" title="Permalink to this headline">¶</a></h4>
<p>“config” adds a new device to the virtual machine. This is supported
by most UML device drivers. It takes one argument, which is the
device to add, with the same syntax as the kernel command line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(mconsole) config ubd3=/home/jdike/incoming/roots/root_fs_debian22
</pre></div>
</div>
</section>
<section id="remove">
<h4><a class="toc-backref" href="#id31">remove</a><a class="headerlink" href="#remove" title="Permalink to this headline">¶</a></h4>
<p>“remove” deletes a device from the system.  Its argument is just the
name of the device to be removed. The device must be idle in whatever
sense the driver considers necessary.  In the case of the ubd driver,
the removed block device must not be mounted, swapped on, or otherwise
open, and in the case of the network driver, the device must be down:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(mconsole)  remove ubd3
</pre></div>
</div>
</section>
<section id="sysrq">
<h4><a class="toc-backref" href="#id32">sysrq</a><a class="headerlink" href="#sysrq" title="Permalink to this headline">¶</a></h4>
<p>This command takes one argument, which is a single letter.  It calls the
generic kernel’s SysRq driver, which does whatever is called for by
that argument.  See the SysRq documentation in
<a class="reference internal" href="../../admin-guide/sysrq.html"><span class="doc">Linux Magic System Request Key Hacks</span></a> in your favorite kernel tree to
see what letters are valid and what they do.</p>
</section>
<section id="cad">
<h4><a class="toc-backref" href="#id33">cad</a><a class="headerlink" href="#cad" title="Permalink to this headline">¶</a></h4>
<p>This invokes the <code class="docutils literal notranslate"><span class="pre">Ctl-Alt-Del</span></code> action in the running image.  What exactly
this ends up doing is up to init, systemd, etc.  Normally, it reboots the
machine.</p>
</section>
<section id="stop">
<h4><a class="toc-backref" href="#id34">stop</a><a class="headerlink" href="#stop" title="Permalink to this headline">¶</a></h4>
<p>This puts the UML in a loop reading mconsole requests until a ‘go’
mconsole command is received. This is very useful as a
debugging/snapshotting tool.</p>
</section>
<section id="go">
<h4><a class="toc-backref" href="#id35">go</a><a class="headerlink" href="#go" title="Permalink to this headline">¶</a></h4>
<p>This resumes a UML after being paused by a ‘stop’ command. Note that
when the UML has resumed, TCP connections may have timed out and if
the UML is paused for a long period of time, crond might go a little
crazy, running all the jobs it didn’t do earlier.</p>
</section>
<section id="proc">
<h4><a class="toc-backref" href="#id36">proc</a><a class="headerlink" href="#proc" title="Permalink to this headline">¶</a></h4>
<p>This takes one argument - the name of a file in /proc which is printed
to the mconsole standard output</p>
</section>
<section id="stack">
<h4><a class="toc-backref" href="#id37">stack</a><a class="headerlink" href="#stack" title="Permalink to this headline">¶</a></h4>
<p>This takes one argument - the pid number of a process. Its stack is
printed to a standard output.</p>
</section>
</section>
</section>
<section id="advanced-uml-topics">
<h2><a class="toc-backref" href="#id38">Advanced UML Topics</a><a class="headerlink" href="#advanced-uml-topics" title="Permalink to this headline">¶</a></h2>
<section id="sharing-filesystems-between-virtual-machines">
<h3><a class="toc-backref" href="#id39">Sharing Filesystems between Virtual Machines</a><a class="headerlink" href="#sharing-filesystems-between-virtual-machines" title="Permalink to this headline">¶</a></h3>
<p>Don’t attempt to share filesystems simply by booting two UMLs from the
same file.  That’s the same thing as booting two physical machines
from a shared disk.  It will result in filesystem corruption.</p>
<section id="using-layered-block-devices">
<h4><a class="toc-backref" href="#id40">Using layered block devices</a><a class="headerlink" href="#using-layered-block-devices" title="Permalink to this headline">¶</a></h4>
<p>The way to share a filesystem between two virtual machines is to use
the copy-on-write (COW) layering capability of the ubd block driver.
Any changed blocks are stored in the private COW file, while reads come
from either device - the private one if the requested block is valid in
it, the shared one if not.  Using this scheme, the majority of data
which is unchanged is shared between an arbitrary number of virtual
machines, each of which has a much smaller file containing the changes
that it has made.  With a large number of UMLs booting from a large root
filesystem, this leads to a huge disk space saving.</p>
<p>Sharing file system data will also help performance, since the host will
be able to cache the shared data using a much smaller amount of memory,
so UML disk requests will be served from the host’s memory rather than
its disks.  There is a major caveat in doing this on multisocket NUMA
machines.  On such hardware, running many UML instances with a shared
master image and COW changes may cause issues like NMIs from excess of
inter-socket traffic.</p>
<p>If you are running UML on high-end hardware like this, make sure to
bind UML to a set of logical CPUs residing on the same socket using the
<code class="docutils literal notranslate"><span class="pre">taskset</span></code> command or have a look at the “tuning” section.</p>
<p>To add a copy-on-write layer to an existing block device file, simply
add the name of the COW file to the appropriate ubd switch:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ubd0=root_fs_cow,root_fs_debian_22
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">root_fs_cow</span></code> is the private COW file and <code class="docutils literal notranslate"><span class="pre">root_fs_debian_22</span></code> is
the existing shared filesystem.  The COW file need not exist.  If it
doesn’t, the driver will create and initialize it.</p>
</section>
<section id="disk-usage">
<h4><a class="toc-backref" href="#id41">Disk Usage</a><a class="headerlink" href="#disk-usage" title="Permalink to this headline">¶</a></h4>
<p>UML has TRIM support which will release any unused space in its disk
image files to the underlying OS. It is important to use either ls -ls
or du to verify the actual file size.</p>
</section>
<section id="cow-validity">
<h4><a class="toc-backref" href="#id42">COW validity.</a><a class="headerlink" href="#cow-validity" title="Permalink to this headline">¶</a></h4>
<p>Any changes to the master image will invalidate all COW files. If this
happens, UML will <em>NOT</em> automatically delete any of the COW files and
will refuse to boot. In this case the only solution is to either
restore the old image (including its last modified timestamp) or remove
all COW files which will result in their recreation. Any changes in
the COW files will be lost.</p>
</section>
<section id="cows-can-moo-uml-moo-merging-a-cow-file-with-its-backing-file">
<h4><a class="toc-backref" href="#id43">Cows can moo - uml_moo : Merging a COW file with its backing file</a><a class="headerlink" href="#cows-can-moo-uml-moo-merging-a-cow-file-with-its-backing-file" title="Permalink to this headline">¶</a></h4>
<p>Depending on how you use UML and COW devices, it may be advisable to
merge the changes in the COW file into the backing file every once in
a while.</p>
<p>The utility that does this is uml_moo.  Its usage is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>uml_moo COW_file new_backing_file
</pre></div>
</div>
<p>There’s no need to specify the backing file since that information is
already in the COW file header.  If you’re paranoid, boot the new
merged file, and if you’re happy with it, move it over the old backing
file.</p>
<p><code class="docutils literal notranslate"><span class="pre">uml_moo</span></code> creates a new backing file by default as a safety measure.
It also has a destructive merge option which will merge the COW file
directly into its current backing file.  This is really only usable
when the backing file only has one COW file associated with it.  If
there are multiple COWs associated with a backing file, a -d merge of
one of them will invalidate all of the others.  However, it is
convenient if you’re short of disk space, and it should also be
noticeably faster than a non-destructive merge.</p>
<p><code class="docutils literal notranslate"><span class="pre">uml_moo</span></code> is installed with the UML distribution packages and is
available as a part of UML utilities.</p>
</section>
</section>
<section id="host-file-access">
<h3><a class="toc-backref" href="#id44">Host file access</a><a class="headerlink" href="#host-file-access" title="Permalink to this headline">¶</a></h3>
<p>If you want to access files on the host machine from inside UML, you
can treat it as a separate machine and either nfs mount directories
from the host or copy files into the virtual machine with scp.
However, since UML is running on the host, it can access those
files just like any other process and make them available inside the
virtual machine without the need to use the network.
This is possible with the hostfs virtual filesystem.  With it, you
can mount a host directory into the UML filesystem and access the
files contained in it just as you would on the host.</p>
<p><em>SECURITY WARNING</em></p>
<p>Hostfs without any parameters to the UML Image will allow the image
to mount any part of the host filesystem and write to it. Always
confine hostfs to a specific “harmless” directory (for example <code class="docutils literal notranslate"><span class="pre">/var/tmp</span></code>)
if running UML. This is especially important if UML is being run as root.</p>
<section id="using-hostfs">
<h4><a class="toc-backref" href="#id45">Using hostfs</a><a class="headerlink" href="#using-hostfs" title="Permalink to this headline">¶</a></h4>
<p>To begin with, make sure that hostfs is available inside the virtual
machine with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /proc/filesystems
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">hostfs</span></code> should be listed.  If it’s not, either rebuild the kernel
with hostfs configured into it or make sure that hostfs is built as a
module and available inside the virtual machine, and insmod it.</p>
<p>Now all you need to do is run mount:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount none /mnt/host -t hostfs
</pre></div>
</div>
<p>will mount the host’s <code class="docutils literal notranslate"><span class="pre">/</span></code> on the virtual machine’s <code class="docutils literal notranslate"><span class="pre">/mnt/host</span></code>.
If you don’t want to mount the host root directory, then you can
specify a subdirectory to mount with the -o switch to mount:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount none /mnt/home -t hostfs -o /home
</pre></div>
</div>
<p>will mount the host’s /home on the virtual machine’s /mnt/home.</p>
</section>
<section id="hostfs-as-the-root-filesystem">
<h4><a class="toc-backref" href="#id46">hostfs as the root filesystem</a><a class="headerlink" href="#hostfs-as-the-root-filesystem" title="Permalink to this headline">¶</a></h4>
<p>It’s possible to boot from a directory hierarchy on the host using
hostfs rather than using the standard filesystem in a file.
To start, you need that hierarchy.  The easiest way is to loop mount
an existing root_fs file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#  mount root_fs uml_root_dir -o loop
</pre></div>
</div>
<p>You need to change the filesystem type of <code class="docutils literal notranslate"><span class="pre">/</span></code> in <code class="docutils literal notranslate"><span class="pre">etc/fstab</span></code> to be
‘hostfs’, so that line looks like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/dev/ubd/0       /        hostfs      defaults          1   1
</pre></div>
</div>
<p>Then you need to chown to yourself all the files in that directory
that are owned by root.  This worked for me:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#  find . -uid 0 -exec chown jdike {} \;
</pre></div>
</div>
<p>Next, make sure that your UML kernel has hostfs compiled in, not as a
module.  Then run UML with the boot device pointing at that directory:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ubd0=/path/to/uml/root/directory
</pre></div>
</div>
<p>UML should then boot as it does normally.</p>
</section>
<section id="hostfs-caveats">
<h4><a class="toc-backref" href="#id47">Hostfs Caveats</a><a class="headerlink" href="#hostfs-caveats" title="Permalink to this headline">¶</a></h4>
<p>Hostfs does not support keeping track of host filesystem changes on the
host (outside UML). As a result, if a file is changed without UML’s
knowledge, UML will not know about it and its own in-memory cache of
the file may be corrupt. While it is possible to fix this, it is not
something which is being worked on at present.</p>
</section>
</section>
<section id="tuning-uml">
<h3><a class="toc-backref" href="#id48">Tuning UML</a><a class="headerlink" href="#tuning-uml" title="Permalink to this headline">¶</a></h3>
<p>UML at present is strictly uniprocessor. It will, however spin up a
number of threads to handle various functions.</p>
<p>The UBD driver, SIGIO and the MMU emulation do that. If the system is
idle, these threads will be migrated to other processors on a SMP host.
This, unfortunately, will usually result in LOWER performance because of
all of the cache/memory synchronization traffic between cores. As a
result, UML will usually benefit from being pinned on a single CPU,
especially on a large system. This can result in performance differences
of 5 times or higher on some benchmarks.</p>
<p>Similarly, on large multi-node NUMA systems UML will benefit if all of
its memory is allocated from the same NUMA node it will run on. The
OS will <em>NOT</em> do that by default. In order to do that, the sysadmin
needs to create a suitable tmpfs ramdisk bound to a particular node
and use that as the source for UML RAM allocation by specifying it
in the TMP or TEMP environment variables. UML will look at the values
of <code class="docutils literal notranslate"><span class="pre">TMPDIR</span></code>, <code class="docutils literal notranslate"><span class="pre">TMP</span></code> or <code class="docutils literal notranslate"><span class="pre">TEMP</span></code> for that. If that fails, it will
look for shmfs mounted under <code class="docutils literal notranslate"><span class="pre">/dev/shm</span></code>. If everything else fails use
<code class="docutils literal notranslate"><span class="pre">/tmp/</span></code> regardless of the filesystem type used for it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mount -t tmpfs -ompol=bind:X none /mnt/tmpfs-nodeX
TEMP=/mnt/tmpfs-nodeX taskset -cX linux options options options..
</pre></div>
</div>
</section>
</section>
<section id="contributing-to-uml-and-developing-with-uml">
<h2><a class="toc-backref" href="#id49">Contributing to UML and Developing with UML</a><a class="headerlink" href="#contributing-to-uml-and-developing-with-uml" title="Permalink to this headline">¶</a></h2>
<p>UML is an excellent platform to develop new Linux kernel concepts -
filesystems, devices, virtualization, etc. It provides unrivalled
opportunities to create and test them without being constrained to
emulating specific hardware.</p>
<p>Example - want to try how Linux will work with 4096 “proper” network
devices?</p>
<p>Not an issue with UML. At the same time, this is something which
is difficult with other virtualization packages - they are
constrained by the number of devices allowed on the hardware bus
they are trying to emulate (for example 16 on a PCI bus in qemu).</p>
<p>If you have something to contribute such as a patch, a bugfix, a
new feature, please send it to <code class="docutils literal notranslate"><span class="pre">linux-um&#64;lists.infradead.org</span></code>.</p>
<p>Please follow all standard Linux patch guidelines such as cc-ing
relevant maintainers and run <code class="docutils literal notranslate"><span class="pre">./scripts/checkpatch.pl</span></code> on your patch.
For more details see <code class="docutils literal notranslate"><span class="pre">Documentation/process/submitting-patches.rst</span></code></p>
<p>Note - the list does not accept HTML or attachments, all emails must
be formatted as plain text.</p>
<p>Developing always goes hand in hand with debugging. First of all,
you can always run UML under gdb and there will be a whole section
later on on how to do that. That, however, is not the only way to
debug a Linux kernel. Quite often adding tracing statements and/or
using UML specific approaches such as ptracing the UML kernel process
are significantly more informative.</p>
<section id="tracing-uml">
<h3><a class="toc-backref" href="#id50">Tracing UML</a><a class="headerlink" href="#tracing-uml" title="Permalink to this headline">¶</a></h3>
<p>When running, UML consists of a main kernel thread and a number of
helper threads. The ones of interest for tracing are NOT the ones
that are already ptraced by UML as a part of its MMU emulation.</p>
<p>These are usually the first three threads visible in a ps display.
The one with the lowest PID number and using most CPU is usually the
kernel thread. The other threads are the disk
(ubd) device helper thread and the SIGIO helper thread.
Running ptrace on this thread usually results in the following picture:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>host$ strace -p 16566
--- SIGIO {si_signo=SIGIO, si_code=POLL_IN, si_band=65} ---
epoll_wait(4, [{EPOLLIN, {u32=3721159424, u64=3721159424}}], 64, 0) = 1
epoll_wait(4, [], 64, 0)                = 0
rt_sigreturn({mask=[PIPE]})             = 16967
ptrace(PTRACE_GETREGS, 16967, NULL, 0xd5f34f38) = 0
ptrace(PTRACE_GETREGSET, 16967, NT_X86_XSTATE, [{iov_base=0xd5f35010, iov_len=832}]) = 0
ptrace(PTRACE_GETSIGINFO, 16967, NULL, {si_signo=SIGTRAP, si_code=0x85, si_pid=16967, si_uid=0}) = 0
ptrace(PTRACE_SETREGS, 16967, NULL, 0xd5f34f38) = 0
ptrace(PTRACE_SETREGSET, 16967, NT_X86_XSTATE, [{iov_base=0xd5f35010, iov_len=2696}]) = 0
ptrace(PTRACE_SYSEMU, 16967, NULL, 0)   = 0
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=16967, si_uid=0, si_status=SIGTRAP, si_utime=65, si_stime=89} ---
wait4(16967, [{WIFSTOPPED(s) &amp;&amp; WSTOPSIG(s) == SIGTRAP | 0x80}], WSTOPPED|__WALL, NULL) = 16967
ptrace(PTRACE_GETREGS, 16967, NULL, 0xd5f34f38) = 0
ptrace(PTRACE_GETREGSET, 16967, NT_X86_XSTATE, [{iov_base=0xd5f35010, iov_len=832}]) = 0
ptrace(PTRACE_GETSIGINFO, 16967, NULL, {si_signo=SIGTRAP, si_code=0x85, si_pid=16967, si_uid=0}) = 0
timer_settime(0, 0, {it_interval={tv_sec=0, tv_nsec=0}, it_value={tv_sec=0, tv_nsec=2830912}}, NULL) = 0
getpid()                                = 16566
clock_nanosleep(CLOCK_MONOTONIC, 0, {tv_sec=1, tv_nsec=0}, NULL) = ? ERESTART_RESTARTBLOCK (Interrupted by signal)
--- SIGALRM {si_signo=SIGALRM, si_code=SI_TIMER, si_timerid=0, si_overrun=0, si_value={int=1631716592, ptr=0x614204f0}} ---
rt_sigreturn({mask=[PIPE]})             = -1 EINTR (Interrupted system call)
</pre></div>
</div>
<p>This is a typical picture from a mostly idle UML instance.</p>
<ul>
<li><p>UML interrupt controller uses epoll - this is UML waiting for IO
interrupts:</p>
<blockquote>
<div><p>epoll_wait(4, [{EPOLLIN, {u32=3721159424, u64=3721159424}}], 64, 0) = 1</p>
</div></blockquote>
</li>
<li><p>The sequence of ptrace calls is part of MMU emulation and running the
UML userspace.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">timer_settime</span></code> is part of the UML high res timer subsystem mapping
timer requests from inside UML onto the host high resolution timers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clock_nanosleep</span></code> is UML going into idle (similar to the way a PC
will execute an ACPI idle).</p></li>
</ul>
<p>As you can see UML will generate quite a bit of output even in idle. The output
can be very informative when observing IO. It shows the actual IO calls, their
arguments and returns values.</p>
</section>
<section id="kernel-debugging">
<h3><a class="toc-backref" href="#id51">Kernel debugging</a><a class="headerlink" href="#kernel-debugging" title="Permalink to this headline">¶</a></h3>
<p>You can run UML under gdb now, though it will not necessarily agree to
be started under it. If you are trying to track a runtime bug, it is
much better to attach gdb to a running UML instance and let UML run.</p>
<p>Assuming the same PID number as in the previous example, this would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># gdb -p 16566
</pre></div>
</div>
<p>This will STOP the UML instance, so you must enter <cite>cont</cite> at the GDB
command line to request it to continue. It may be a good idea to make
this into a gdb script and pass it to gdb as an argument.</p>
</section>
<section id="developing-device-drivers">
<h3><a class="toc-backref" href="#id52">Developing Device Drivers</a><a class="headerlink" href="#developing-device-drivers" title="Permalink to this headline">¶</a></h3>
<p>Nearly all UML drivers are monolithic. While it is possible to build a
UML driver as a kernel module, that limits the possible functionality
to in-kernel only and non-UML specific.  The reason for this is that
in order to really leverage UML, one needs to write a piece of
userspace code which maps driver concepts onto actual userspace host
calls.</p>
<p>This forms the so-called “user” portion of the driver. While it can
reuse a lot of kernel concepts, it is generally just another piece of
userspace code. This portion needs some matching “kernel” code which
resides inside the UML image and which implements the Linux kernel part.</p>
<p><em>Note: There are very few limitations in the way “kernel” and “user” interact</em>.</p>
<p>UML does not have a strictly defined kernel-to-host API. It does not
try to emulate a specific architecture or bus. UML’s “kernel” and
“user” can share memory, code and interact as needed to implement
whatever design the software developer has in mind. The only
limitations are purely technical. Due to a lot of functions and
variables having the same names, the developer should be careful
which includes and libraries they are trying to refer to.</p>
<p>As a result a lot of userspace code consists of simple wrappers.
E.g. <code class="docutils literal notranslate"><span class="pre">os_close_file()</span></code> is just a wrapper around <code class="docutils literal notranslate"><span class="pre">close()</span></code>
which ensures that the userspace function close does not clash
with similarly named function(s) in the kernel part.</p>
</section>
<section id="using-uml-as-a-test-platform">
<h3><a class="toc-backref" href="#id53">Using UML as a Test Platform</a><a class="headerlink" href="#using-uml-as-a-test-platform" title="Permalink to this headline">¶</a></h3>
<p>UML is an excellent test platform for device driver development. As
with most things UML, “some user assembly may be required”. It is
up to the user to build their emulation environment. UML at present
provides only the kernel infrastructure.</p>
<p>Part of this infrastructure is the ability to load and parse fdt
device tree blobs as used in Arm or Open Firmware platforms. These
are supplied as an optional extra argument to the kernel command
line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dtb=filename
</pre></div>
</div>
<p>The device tree is loaded and parsed at boottime and is accessible by
drivers which query it. At this moment in time this facility is
intended solely for development purposes. UML’s own devices do not
query the device tree.</p>
<section id="security-considerations">
<h4><a class="toc-backref" href="#id54">Security Considerations</a><a class="headerlink" href="#security-considerations" title="Permalink to this headline">¶</a></h4>
<p>Drivers or any new functionality should default to not
accepting arbitrary filename, bpf code or other parameters
which can affect the host from inside the UML instance.
For example, specifying the socket used for IPC communication
between a driver and the host at the UML command line is OK
security-wise. Allowing it as a loadable module parameter
isn’t.</p>
<p>If such functionality is desireable for a particular application
(e.g. loading BPF “firmware” for raw socket network transports),
it should be off by default and should be explicitly turned on
as a command line parameter at startup.</p>
<p>Even with this in mind, the level of isolation between UML
and the host is relatively weak. If the UML userspace is
allowed to load arbitrary kernel drivers, an attacker can
use this to break out of UML. Thus, if UML is used in
a production application, it is recommended that all modules
are loaded at boot and kernel module loading is disabled
afterwards.</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">UML HowTo</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#how-is-uml-different-from-a-vm-using-virtualization-package-x">How is UML Different from a VM using Virtualization package X?</a></li>
<li><a class="reference internal" href="#why-would-i-want-user-mode-linux">Why Would I Want User Mode Linux?</a></li>
<li><a class="reference internal" href="#why-not-to-run-uml">Why not to run UML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-a-uml-instance">Building a UML instance</a><ul>
<li><a class="reference internal" href="#creating-an-image">Creating an image</a></li>
<li><a class="reference internal" href="#edit-key-system-files">Edit key system files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#setting-up-uml-networking">Setting Up UML Networking</a><ul>
<li><a class="reference internal" href="#network-configuration-privileges">Network configuration privileges</a></li>
<li><a class="reference internal" href="#configuring-vector-transports">Configuring vector transports</a><ul>
<li><a class="reference internal" href="#common-options">Common options</a></li>
<li><a class="reference internal" href="#shared-options">Shared Options</a></li>
<li><a class="reference internal" href="#tap-transport">tap transport</a></li>
<li><a class="reference internal" href="#hybrid-transport">hybrid transport</a></li>
<li><a class="reference internal" href="#raw-socket-transport">raw socket transport</a></li>
<li><a class="reference internal" href="#gre-socket-transport">GRE socket transport</a></li>
<li><a class="reference internal" href="#l2tpv3-socket-transport">l2tpv3 socket transport</a></li>
<li><a class="reference internal" href="#bess-socket-transport">BESS socket transport</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuring-legacy-transports">Configuring Legacy transports</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-uml">Running UML</a><ul>
<li><a class="reference internal" href="#arguments">Arguments</a><ul>
<li><a class="reference internal" href="#mandatory-arguments">Mandatory Arguments:</a></li>
<li><a class="reference internal" href="#important-optional-arguments">Important Optional Arguments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#starting-uml">Starting UML</a></li>
<li><a class="reference internal" href="#logging-in">Logging in</a></li>
<li><a class="reference internal" href="#the-uml-management-console">The UML Management Console</a><ul>
<li><a class="reference internal" href="#version">version</a></li>
<li><a class="reference internal" href="#help">help</a></li>
<li><a class="reference internal" href="#halt-and-reboot">halt and reboot</a></li>
<li><a class="reference internal" href="#config">config</a></li>
<li><a class="reference internal" href="#remove">remove</a></li>
<li><a class="reference internal" href="#sysrq">sysrq</a></li>
<li><a class="reference internal" href="#cad">cad</a></li>
<li><a class="reference internal" href="#stop">stop</a></li>
<li><a class="reference internal" href="#go">go</a></li>
<li><a class="reference internal" href="#proc">proc</a></li>
<li><a class="reference internal" href="#stack">stack</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-uml-topics">Advanced UML Topics</a><ul>
<li><a class="reference internal" href="#sharing-filesystems-between-virtual-machines">Sharing Filesystems between Virtual Machines</a><ul>
<li><a class="reference internal" href="#using-layered-block-devices">Using layered block devices</a></li>
<li><a class="reference internal" href="#disk-usage">Disk Usage</a></li>
<li><a class="reference internal" href="#cow-validity">COW validity.</a></li>
<li><a class="reference internal" href="#cows-can-moo-uml-moo-merging-a-cow-file-with-its-backing-file">Cows can moo - uml_moo : Merging a COW file with its backing file</a></li>
</ul>
</li>
<li><a class="reference internal" href="#host-file-access">Host file access</a><ul>
<li><a class="reference internal" href="#using-hostfs">Using hostfs</a></li>
<li><a class="reference internal" href="#hostfs-as-the-root-filesystem">hostfs as the root filesystem</a></li>
<li><a class="reference internal" href="#hostfs-caveats">Hostfs Caveats</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tuning-uml">Tuning UML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#contributing-to-uml-and-developing-with-uml">Contributing to UML and Developing with UML</a><ul>
<li><a class="reference internal" href="#tracing-uml">Tracing UML</a></li>
<li><a class="reference internal" href="#kernel-debugging">Kernel debugging</a></li>
<li><a class="reference internal" href="#developing-device-drivers">Developing Device Drivers</a></li>
<li><a class="reference internal" href="#using-uml-as-a-test-platform">Using UML as a Test Platform</a><ul>
<li><a class="reference internal" href="#security-considerations">Security Considerations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/virt/uml/user_mode_linux_howto_v2.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/virt/uml/user_mode_linux_howto_v2.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>