
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Page migration &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Page fragments" href="page_frags.html" />
    <link rel="prev" title="Overcommit Accounting" href="overcommit-accounting.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="page-migration">
<span id="id1"></span><h1>Page migration<a class="headerlink" href="#page-migration" title="Permalink to this headline">¶</a></h1>
<p>Page migration allows moving the physical location of pages between
nodes in a NUMA system while the process is running. This means that the
virtual addresses that the process sees do not change. However, the
system rearranges the physical location of those pages.</p>
<p>Also see <a class="reference internal" href="hmm.html#hmm"><span class="std std-ref">Heterogeneous Memory Management (HMM)</span></a>
for migrating pages to or from device private memory.</p>
<p>The main intent of page migration is to reduce the latency of memory accesses
by moving pages near to the processor where the process accessing that memory
is running.</p>
<p>Page migration allows a process to manually relocate the node on which its
pages are located through the MF_MOVE and MF_MOVE_ALL options while setting
a new memory policy via mbind(). The pages of a process can also be relocated
from another process using the sys_migrate_pages() function call. The
migrate_pages() function call takes two sets of nodes and moves pages of a
process that are located on the from nodes to the destination nodes.
Page migration functions are provided by the numactl package by Andi Kleen
(a version later than 0.9.3 is required. Get it from
<a class="reference external" href="https://github.com/numactl/numactl.git">https://github.com/numactl/numactl.git</a>). numactl provides libnuma
which provides an interface similar to other NUMA functionality for page
migration.  cat <code class="docutils literal notranslate"><span class="pre">/proc/&lt;pid&gt;/numa_maps</span></code> allows an easy review of where the
pages of a process are located. See also the numa_maps documentation in the
proc(5) man page.</p>
<p>Manual migration is useful if for example the scheduler has relocated
a process to a processor on a distant node. A batch scheduler or an
administrator may detect the situation and move the pages of the process
nearer to the new processor. The kernel itself only provides
manual page migration support. Automatic page migration may be implemented
through user space processes that move pages. A special function call
“move_pages” allows the moving of individual pages within a process.
For example, A NUMA profiler may obtain a log showing frequent off-node
accesses and may use the result to move pages to more advantageous
locations.</p>
<p>Larger installations usually partition the system using cpusets into
sections of nodes. Paul Jackson has equipped cpusets with the ability to
move pages when a task is moved to another cpuset (See
<a class="reference internal" href="../admin-guide/cgroup-v1/cpusets.html#cpusets"><span class="std std-ref">CPUSETS</span></a>).
Cpusets allow the automation of process locality. If a task is moved to
a new cpuset then also all its pages are moved with it so that the
performance of the process does not sink dramatically. Also the pages
of processes in a cpuset are moved if the allowed memory nodes of a
cpuset are changed.</p>
<p>Page migration allows the preservation of the relative location of pages
within a group of nodes for all migration techniques which will preserve a
particular memory allocation pattern generated even after migrating a
process. This is necessary in order to preserve the memory latencies.
Processes will run with similar performance after migration.</p>
<p>Page migration occurs in several steps. First a high level
description for those trying to use migrate_pages() from the kernel
(for userspace usage see the Andi Kleen’s numactl package mentioned above)
and then a low level description of how the low level details work.</p>
<section id="in-kernel-use-of-migrate-pages">
<h2>In kernel use of migrate_pages()<a class="headerlink" href="#in-kernel-use-of-migrate-pages" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p>Remove pages from the LRU.</p>
<p>Lists of pages to be migrated are generated by scanning over
pages and moving them into lists. This is done by
calling isolate_lru_page().
Calling isolate_lru_page() increases the references to the page
so that it cannot vanish while the page migration occurs.
It also prevents the swapper or other scans from encountering
the page.</p>
</li>
<li><p>We need to have a function of type new_page_t that can be
passed to migrate_pages(). This function should figure out
how to allocate the correct new page given the old page.</p></li>
<li><p>The migrate_pages() function is called which attempts
to do the migration. It will call the function to allocate
the new page for each page that is considered for
moving.</p></li>
</ol>
</section>
<section id="how-migrate-pages-works">
<h2>How migrate_pages() works<a class="headerlink" href="#how-migrate-pages-works" title="Permalink to this headline">¶</a></h2>
<p>migrate_pages() does several passes over its list of pages. A page is moved
if all references to a page are removable at the time. The page has
already been removed from the LRU via isolate_lru_page() and the refcount
is increased so that the page cannot be freed while page migration occurs.</p>
<p>Steps:</p>
<ol class="arabic simple">
<li><p>Lock the page to be migrated.</p></li>
<li><p>Ensure that writeback is complete.</p></li>
<li><p>Lock the new page that we want to move to. It is locked so that accesses to
this (not yet up-to-date) page immediately block while the move is in progress.</p></li>
<li><p>All the page table references to the page are converted to migration
entries. This decreases the mapcount of a page. If the resulting
mapcount is not zero then we do not migrate the page. All user space
processes that attempt to access the page will now wait on the page lock
or wait for the migration page table entry to be removed.</p></li>
<li><p>The i_pages lock is taken. This will cause all processes trying
to access the page via the mapping to block on the spinlock.</p></li>
<li><p>The refcount of the page is examined and we back out if references remain.
Otherwise, we know that we are the only one referencing this page.</p></li>
<li><p>The radix tree is checked and if it does not contain the pointer to this
page then we back out because someone else modified the radix tree.</p></li>
<li><p>The new page is prepped with some settings from the old page so that
accesses to the new page will discover a page with the correct settings.</p></li>
<li><p>The radix tree is changed to point to the new page.</p></li>
<li><p>The reference count of the old page is dropped because the address space
reference is gone. A reference to the new page is established because
the new page is referenced by the address space.</p></li>
<li><p>The i_pages lock is dropped. With that lookups in the mapping
become possible again. Processes will move from spinning on the lock
to sleeping on the locked new page.</p></li>
<li><p>The page contents are copied to the new page.</p></li>
<li><p>The remaining page flags are copied to the new page.</p></li>
<li><p>The old page flags are cleared to indicate that the page does
not provide any information anymore.</p></li>
<li><p>Queued up writeback on the new page is triggered.</p></li>
<li><p>If migration entries were inserted into the page table, then replace them
with real ptes. Doing so will enable access for user space processes not
already waiting for the page lock.</p></li>
<li><p>The page locks are dropped from the old and new page.
Processes waiting on the page lock will redo their page faults
and will reach the new page.</p></li>
<li><p>The new page is moved to the LRU and can be scanned by the swapper,
etc. again.</p></li>
</ol>
</section>
<section id="non-lru-page-migration">
<h2>Non-LRU page migration<a class="headerlink" href="#non-lru-page-migration" title="Permalink to this headline">¶</a></h2>
<p>Although migration originally aimed for reducing the latency of memory
accesses for NUMA, compaction also uses migration to create high-order
pages.  For compaction purposes, it is also useful to be able to move
non-LRU pages, such as zsmalloc and virtio-balloon pages.</p>
<p>If a driver wants to make its pages movable, it should define a <a class="reference internal" href="#c.movable_operations" title="movable_operations"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">movable_operations</span></code></a>.  It then needs to call __SetPageMovable() on each
page that it may be able to move.  This uses the <code class="docutils literal notranslate"><span class="pre">page-&gt;mapping</span></code> field,
so this field is not available for the driver to use for other purposes.</p>
</section>
<section id="monitoring-migration">
<h2>Monitoring Migration<a class="headerlink" href="#monitoring-migration" title="Permalink to this headline">¶</a></h2>
<p>The following events (counters) can be used to monitor page migration.</p>
<ol class="arabic simple">
<li><p>PGMIGRATE_SUCCESS: Normal page migration success. Each count means that a
page was migrated. If the page was a non-THP and non-hugetlb page, then
this counter is increased by one. If the page was a THP or hugetlb, then
this counter is increased by the number of THP or hugetlb subpages.
For example, migration of a single 2MB THP that has 4KB-size base pages
(subpages) will cause this counter to increase by 512.</p></li>
<li><p>PGMIGRATE_FAIL: Normal page migration failure. Same counting rules as for
PGMIGRATE_SUCCESS, above: this will be increased by the number of subpages,
if it was a THP or hugetlb.</p></li>
<li><p>THP_MIGRATION_SUCCESS: A THP was migrated without being split.</p></li>
<li><p>THP_MIGRATION_FAIL: A THP could not be migrated nor it could be split.</p></li>
<li><p>THP_MIGRATION_SPLIT: A THP was migrated, but not as such: first, the THP had
to be split. After splitting, a migration retry was used for it’s sub-pages.</p></li>
</ol>
<p>THP_MIGRATION_* events also update the appropriate PGMIGRATE_SUCCESS or
PGMIGRATE_FAIL events. For example, a THP migration failure will cause both
THP_MIGRATION_FAIL and PGMIGRATE_FAIL to increase.</p>
<p>Christoph Lameter, May 8, 2006.
Minchan Kim, Mar 28, 2016.</p>
<dl class="type">
<dt id="c.movable_operations">
struct <code class="sig-name descname">movable_operations</code><a class="headerlink" href="#c.movable_operations" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver page migration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct movable_operations {
    bool (*isolate_page)(struct page *, isolate_mode_t);
    int (*migrate_page)(struct page *dst, struct page *src, enum migrate_mode);
    void (*putback_page)(struct page *);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">isolate_page</span></code></p>
<blockquote>
<div><p>The VM calls this function to prepare the page to be moved.  The page
is locked and the driver should not unlock it.  The driver should
return <code class="docutils literal notranslate"><span class="pre">true</span></code> if the page is movable and <code class="docutils literal notranslate"><span class="pre">false</span></code> if it is not
currently movable.  After this function returns, the VM uses the
page-&gt;lru field, so the driver must preserve any information which
is usually stored here.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">migrate_page</span></code></p>
<blockquote>
<div><p>After isolation, the VM calls this function with the isolated
<strong>src</strong> page.  The driver should copy the contents of the
<strong>src</strong> page to the <strong>dst</strong> page and set up the fields of <strong>dst</strong> page.
Both pages are locked.
If page migration is successful, the driver should call
__ClearPageMovable(<strong>src</strong>) and return MIGRATEPAGE_SUCCESS.
If the driver cannot migrate the page at the moment, it can return
-EAGAIN.  The VM interprets this as a temporary migration failure and
will retry it later.  Any other error value is a permanent migration
failure and migration will not be retried.
The driver shouldn’t touch the <strong>src-&gt;lru</strong> field while in the
migrate_page() function.  It may write to <strong>dst-&gt;lru</strong>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">putback_page</span></code></p>
<blockquote>
<div><p>If migration fails on the isolated page, the VM informs the driver
that the page is no longer a candidate for migration by calling
this function.  The driver should put the isolated page back into
its own data structure.</p>
</div></blockquote>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Page migration</a><ul>
<li><a class="reference internal" href="#in-kernel-use-of-migrate-pages">In kernel use of migrate_pages()</a></li>
<li><a class="reference internal" href="#how-migrate-pages-works">How migrate_pages() works</a></li>
<li><a class="reference internal" href="#non-lru-page-migration">Non-LRU page migration</a></li>
<li><a class="reference internal" href="#monitoring-migration">Monitoring Migration</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/mm/page_migration.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/mm/page_migration.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>