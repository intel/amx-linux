
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>BPF Type Format (BTF) &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Frequently asked questions (FAQ)" href="faq.html" />
    <link rel="prev" title="Building libbpf" href="libbpf/libbpf_build.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="bpf-type-format-btf">
<h1>BPF Type Format (BTF)<a class="headerlink" href="#bpf-type-format-btf" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>BTF (BPF Type Format) is the metadata format which encodes the debug info
related to BPF program/map. The name BTF was used initially to describe data
types. The BTF was later extended to include function info for defined
subroutines, and line info for source/line information.</p>
<p>The debug info is used for map pretty print, function signature, etc. The
function signature enables better bpf program/function kernel symbol. The line
info helps generate source annotated translated byte code, jited code and
verifier log.</p>
<dl class="simple">
<dt>The BTF specification contains two parts,</dt><dd><ul class="simple">
<li><p>BTF kernel API</p></li>
<li><p>BTF ELF file format</p></li>
</ul>
</dd>
</dl>
<p>The kernel API is the contract between user space and kernel. The kernel
verifies the BTF info before using it. The ELF file format is a user space
contract between ELF file and libbpf loader.</p>
<p>The type and string sections are part of the BTF kernel API, describing the
debug info (mostly types related) referenced by the bpf program. These two
sections are discussed in details in <a class="reference internal" href="#btf-type-string"><span class="std std-ref">2. BTF Type and String Encoding</span></a>.</p>
</section>
<section id="btf-type-and-string-encoding">
<span id="btf-type-string"></span><h2>2. BTF Type and String Encoding<a class="headerlink" href="#btf-type-and-string-encoding" title="Permalink to this headline">¶</a></h2>
<p>The file <code class="docutils literal notranslate"><span class="pre">include/uapi/linux/btf.h</span></code> provides high-level definition of how
types/strings are encoded.</p>
<p>The beginning of data blob must be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_header {
    __u16   magic;
    __u8    version;
    __u8    flags;
    __u32   hdr_len;

    /* All offsets are in bytes relative to the end of this header */
    __u32   type_off;       /* offset of type section       */
    __u32   type_len;       /* length of type section       */
    __u32   str_off;        /* offset of string section     */
    __u32   str_len;        /* length of string section     */
};
</pre></div>
</div>
<p>The magic is <code class="docutils literal notranslate"><span class="pre">0xeB9F</span></code>, which has different encoding for big and little
endian systems, and can be used to test whether BTF is generated for big- or
little-endian target. The <code class="docutils literal notranslate"><span class="pre">btf_header</span></code> is designed to be extensible with
<code class="docutils literal notranslate"><span class="pre">hdr_len</span></code> equal to <code class="docutils literal notranslate"><span class="pre">sizeof(struct</span> <span class="pre">btf_header)</span></code> when a data blob is
generated.</p>
<section id="string-encoding">
<h3>2.1 String Encoding<a class="headerlink" href="#string-encoding" title="Permalink to this headline">¶</a></h3>
<p>The first string in the string section must be a null string. The rest of
string table is a concatenation of other null-terminated strings.</p>
</section>
<section id="type-encoding">
<h3>2.2 Type Encoding<a class="headerlink" href="#type-encoding" title="Permalink to this headline">¶</a></h3>
<p>The type id <code class="docutils literal notranslate"><span class="pre">0</span></code> is reserved for <code class="docutils literal notranslate"><span class="pre">void</span></code> type. The type section is parsed
sequentially and type id is assigned to each recognized type starting from id
<code class="docutils literal notranslate"><span class="pre">1</span></code>. Currently, the following types are supported:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define BTF_KIND_INT            1       /* Integer      */
#define BTF_KIND_PTR            2       /* Pointer      */
#define BTF_KIND_ARRAY          3       /* Array        */
#define BTF_KIND_STRUCT         4       /* Struct       */
#define BTF_KIND_UNION          5       /* Union        */
#define BTF_KIND_ENUM           6       /* Enumeration up to 32-bit values */
#define BTF_KIND_FWD            7       /* Forward      */
#define BTF_KIND_TYPEDEF        8       /* Typedef      */
#define BTF_KIND_VOLATILE       9       /* Volatile     */
#define BTF_KIND_CONST          10      /* Const        */
#define BTF_KIND_RESTRICT       11      /* Restrict     */
#define BTF_KIND_FUNC           12      /* Function     */
#define BTF_KIND_FUNC_PROTO     13      /* Function Proto       */
#define BTF_KIND_VAR            14      /* Variable     */
#define BTF_KIND_DATASEC        15      /* Section      */
#define BTF_KIND_FLOAT          16      /* Floating point       */
#define BTF_KIND_DECL_TAG       17      /* Decl Tag     */
#define BTF_KIND_TYPE_TAG       18      /* Type Tag     */
#define BTF_KIND_ENUM64         19      /* Enumeration up to 64-bit values */
</pre></div>
</div>
<p>Note that the type section encodes debug info, not just pure types.
<code class="docutils literal notranslate"><span class="pre">BTF_KIND_FUNC</span></code> is not a type, and it represents a defined subprogram.</p>
<p>Each type contains the following common data:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_type {
    __u32 name_off;
    /* &quot;info&quot; bits arrangement
     * bits  0-15: vlen (e.g. # of struct&#39;s members)
     * bits 16-23: unused
     * bits 24-28: kind (e.g. int, ptr, array...etc)
     * bits 29-30: unused
     * bit     31: kind_flag, currently used by
     *             struct, union, fwd, enum and enum64.
     */
    __u32 info;
    /* &quot;size&quot; is used by INT, ENUM, STRUCT, UNION and ENUM64.
     * &quot;size&quot; tells the size of the type it is describing.
     *
     * &quot;type&quot; is used by PTR, TYPEDEF, VOLATILE, CONST, RESTRICT,
     * FUNC, FUNC_PROTO, DECL_TAG and TYPE_TAG.
     * &quot;type&quot; is a type_id referring to another type.
     */
    union {
            __u32 size;
            __u32 type;
    };
};
</pre></div>
</div>
<p>For certain kinds, the common data are followed by kind-specific data. The
<code class="docutils literal notranslate"><span class="pre">name_off</span></code> in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> specifies the offset in the string table.
The following sections detail encoding of each kind.</p>
<section id="btf-kind-int">
<h4>2.2.1 BTF_KIND_INT<a class="headerlink" href="#btf-kind-int" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: any valid offset</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_INT</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: the size of the int type in bytes.</p></li>
</ul>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">btf_type</span></code> is followed by a <code class="docutils literal notranslate"><span class="pre">u32</span></code> with the following bits arrangement:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define BTF_INT_ENCODING(VAL)   (((VAL) &amp; 0x0f000000) &gt;&gt; 24)
#define BTF_INT_OFFSET(VAL)     (((VAL) &amp; 0x00ff0000) &gt;&gt; 16)
#define BTF_INT_BITS(VAL)       ((VAL)  &amp; 0x000000ff)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">BTF_INT_ENCODING</span></code> has the following attributes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define BTF_INT_SIGNED  (1 &lt;&lt; 0)
#define BTF_INT_CHAR    (1 &lt;&lt; 1)
#define BTF_INT_BOOL    (1 &lt;&lt; 2)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">BTF_INT_ENCODING()</span></code> provides extra information: signedness, char, or
bool, for the int type. The char and bool encoding are mostly useful for
pretty print. At most one encoding can be specified for the int type.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">BTF_INT_BITS()</span></code> specifies the number of actual bits held by this int
type. For example, a 4-bit bitfield encodes <code class="docutils literal notranslate"><span class="pre">BTF_INT_BITS()</span></code> equals to 4.
The <code class="docutils literal notranslate"><span class="pre">btf_type.size</span> <span class="pre">*</span> <span class="pre">8</span></code> must be equal to or greater than <code class="docutils literal notranslate"><span class="pre">BTF_INT_BITS()</span></code>
for the type. The maximum value of <code class="docutils literal notranslate"><span class="pre">BTF_INT_BITS()</span></code> is 128.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">BTF_INT_OFFSET()</span></code> specifies the starting bit offset to calculate values
for this int. For example, a bitfield struct member has:</p>
<blockquote>
<div><ul class="simple">
<li><p>btf member bit offset 100 from the start of the structure,</p></li>
<li><p>btf member pointing to an int type,</p></li>
<li><p>the int type has <code class="docutils literal notranslate"><span class="pre">BTF_INT_OFFSET()</span> <span class="pre">=</span> <span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">BTF_INT_BITS()</span> <span class="pre">=</span> <span class="pre">4</span></code></p></li>
</ul>
</div></blockquote>
<p>Then in the struct memory layout, this member will occupy <code class="docutils literal notranslate"><span class="pre">4</span></code> bits starting
from bits <code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">102</span></code>.</p>
<p>Alternatively, the bitfield struct member can be the following to access the
same bits as the above:</p>
<blockquote>
<div><ul class="simple">
<li><p>btf member bit offset 102,</p></li>
<li><p>btf member pointing to an int type,</p></li>
<li><p>the int type has <code class="docutils literal notranslate"><span class="pre">BTF_INT_OFFSET()</span> <span class="pre">=</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">BTF_INT_BITS()</span> <span class="pre">=</span> <span class="pre">4</span></code></p></li>
</ul>
</div></blockquote>
<p>The original intention of <code class="docutils literal notranslate"><span class="pre">BTF_INT_OFFSET()</span></code> is to provide flexibility of
bitfield encoding. Currently, both llvm and pahole generate
<code class="docutils literal notranslate"><span class="pre">BTF_INT_OFFSET()</span> <span class="pre">=</span> <span class="pre">0</span></code> for all int types.</p>
</section>
<section id="btf-kind-ptr">
<h4>2.2.2 BTF_KIND_PTR<a class="headerlink" href="#btf-kind-ptr" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_PTR</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: the pointee type of the pointer</p></li>
</ul>
</dd>
</dl>
<p>No additional type data follow <code class="docutils literal notranslate"><span class="pre">btf_type</span></code>.</p>
</section>
<section id="btf-kind-array">
<h4>2.2.3 BTF_KIND_ARRAY<a class="headerlink" href="#btf-kind-array" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_ARRAY</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size/type</span></code>: 0, not used</p></li>
</ul>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">btf_type</span></code> is followed by one <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_array</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_array {
    __u32   type;
    __u32   index_type;
    __u32   nelems;
};
</pre></div>
</div>
<dl class="simple">
<dt>The <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_array</span></code> encoding:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: the element type</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">index_type</span></code>: the index type</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nelems</span></code>: the number of elements for this array (<code class="docutils literal notranslate"><span class="pre">0</span></code> is also allowed).</p></li>
</ul>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">index_type</span></code> can be any regular int type (<code class="docutils literal notranslate"><span class="pre">u8</span></code>, <code class="docutils literal notranslate"><span class="pre">u16</span></code>, <code class="docutils literal notranslate"><span class="pre">u32</span></code>,
<code class="docutils literal notranslate"><span class="pre">u64</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">__int128</span></code>). The original design of including
<code class="docutils literal notranslate"><span class="pre">index_type</span></code> follows DWARF, which has an <code class="docutils literal notranslate"><span class="pre">index_type</span></code> for its array type.
Currently in BTF, beyond type verification, the <code class="docutils literal notranslate"><span class="pre">index_type</span></code> is not used.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_array</span></code> allows chaining through element type to represent
multidimensional arrays. For example, for <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">a[5][6]</span></code>, the following type
information illustrates the chaining:</p>
<blockquote>
<div><ul class="simple">
<li><p>[1]: int</p></li>
<li><p>[2]: array, <code class="docutils literal notranslate"><span class="pre">btf_array.type</span> <span class="pre">=</span> <span class="pre">[1]</span></code>, <code class="docutils literal notranslate"><span class="pre">btf_array.nelems</span> <span class="pre">=</span> <span class="pre">6</span></code></p></li>
<li><p>[3]: array, <code class="docutils literal notranslate"><span class="pre">btf_array.type</span> <span class="pre">=</span> <span class="pre">[2]</span></code>, <code class="docutils literal notranslate"><span class="pre">btf_array.nelems</span> <span class="pre">=</span> <span class="pre">5</span></code></p></li>
</ul>
</div></blockquote>
<p>Currently, both pahole and llvm collapse multidimensional array into
one-dimensional array, e.g., for <code class="docutils literal notranslate"><span class="pre">a[5][6]</span></code>, the <code class="docutils literal notranslate"><span class="pre">btf_array.nelems</span></code> is
equal to <code class="docutils literal notranslate"><span class="pre">30</span></code>. This is because the original use case is map pretty print
where the whole array is dumped out so one-dimensional array is enough. As
more BTF usage is explored, pahole and llvm can be changed to generate proper
chained representation for multidimensional arrays.</p>
</section>
<section id="btf-kind-struct">
<h4>2.2.4 BTF_KIND_STRUCT<a class="headerlink" href="#btf-kind-struct" title="Permalink to this headline">¶</a></h4>
</section>
<section id="btf-kind-union">
<h4>2.2.5 BTF_KIND_UNION<a class="headerlink" href="#btf-kind-union" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: 0 or offset to a valid C identifier</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0 or 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_STRUCT or BTF_KIND_UNION</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: the number of struct/union members</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.size</span></code>: the size of the struct/union in bytes</p></li>
</ul>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">btf_type</span></code> is followed by <code class="docutils literal notranslate"><span class="pre">info.vlen</span></code> number of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_member</span></code>.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_member {
    __u32   name_off;
    __u32   type;
    __u32   offset;
};
</pre></div>
</div>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_member</span></code> encoding:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: offset to a valid C identifier</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: the member type</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">offset</span></code>: &lt;see below&gt;</p></li>
</ul>
</dd>
</dl>
<p>If the type info <code class="docutils literal notranslate"><span class="pre">kind_flag</span></code> is not set, the offset contains only bit offset
of the member. Note that the base type of the bitfield can only be int or enum
type. If the bitfield size is 32, the base type can be either int or enum
type. If the bitfield size is not 32, the base type must be int, and int type
<code class="docutils literal notranslate"><span class="pre">BTF_INT_BITS()</span></code> encodes the bitfield size.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">kind_flag</span></code> is set, the <code class="docutils literal notranslate"><span class="pre">btf_member.offset</span></code> contains both member
bitfield size and bit offset. The bitfield size and bit offset are calculated
as below.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define BTF_MEMBER_BITFIELD_SIZE(val)   ((val) &gt;&gt; 24)
#define BTF_MEMBER_BIT_OFFSET(val)      ((val) &amp; 0xffffff)
</pre></div>
</div>
<p>In this case, if the base type is an int type, it must be a regular int type:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BTF_INT_OFFSET()</span></code> must be 0.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BTF_INT_BITS()</span></code> must be equal to <code class="docutils literal notranslate"><span class="pre">{1,2,4,8,16}</span> <span class="pre">*</span> <span class="pre">8</span></code>.</p></li>
</ul>
</div></blockquote>
<p>The following kernel patch introduced <code class="docutils literal notranslate"><span class="pre">kind_flag</span></code> and explained why both
modes exist:</p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/torvalds/linux/commit/9d5f9f701b1891466fb3dbb1806ad97716f95cc3#diff-fa650a64fdd3968396883d2fe8215ff3">https://github.com/torvalds/linux/commit/9d5f9f701b1891466fb3dbb1806ad97716f95cc3#diff-fa650a64fdd3968396883d2fe8215ff3</a></p>
</div></blockquote>
</section>
<section id="btf-kind-enum">
<h4>2.2.6 BTF_KIND_ENUM<a class="headerlink" href="#btf-kind-enum" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: 0 or offset to a valid C identifier</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0 for unsigned, 1 for signed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_ENUM</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: number of enum values</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: 1/2/4/8</p></li>
</ul>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">btf_type</span></code> is followed by <code class="docutils literal notranslate"><span class="pre">info.vlen</span></code> number of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_enum</span></code>.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_enum {
    __u32   name_off;
    __s32   val;
};
</pre></div>
</div>
<dl class="simple">
<dt>The <code class="docutils literal notranslate"><span class="pre">btf_enum</span></code> encoding:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: offset to a valid C identifier</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">val</span></code>: any value</p></li>
</ul>
</dd>
</dl>
<p>If the original enum value is signed and the size is less than 4,
that value will be sign extended into 4 bytes. If the size is 8,
the value will be truncated into 4 bytes.</p>
</section>
<section id="btf-kind-fwd">
<h4>2.2.7 BTF_KIND_FWD<a class="headerlink" href="#btf-kind-fwd" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: offset to a valid C identifier</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0 for struct, 1 for union</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_FWD</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: 0</p></li>
</ul>
</dd>
</dl>
<p>No additional type data follow <code class="docutils literal notranslate"><span class="pre">btf_type</span></code>.</p>
</section>
<section id="btf-kind-typedef">
<h4>2.2.8 BTF_KIND_TYPEDEF<a class="headerlink" href="#btf-kind-typedef" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: offset to a valid C identifier</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_TYPEDEF</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: the type which can be referred by name at <code class="docutils literal notranslate"><span class="pre">name_off</span></code></p></li>
</ul>
</dd>
</dl>
<p>No additional type data follow <code class="docutils literal notranslate"><span class="pre">btf_type</span></code>.</p>
</section>
<section id="btf-kind-volatile">
<h4>2.2.9 BTF_KIND_VOLATILE<a class="headerlink" href="#btf-kind-volatile" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_VOLATILE</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: the type with <code class="docutils literal notranslate"><span class="pre">volatile</span></code> qualifier</p></li>
</ul>
</dd>
</dl>
<p>No additional type data follow <code class="docutils literal notranslate"><span class="pre">btf_type</span></code>.</p>
</section>
<section id="btf-kind-const">
<h4>2.2.10 BTF_KIND_CONST<a class="headerlink" href="#btf-kind-const" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_CONST</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: the type with <code class="docutils literal notranslate"><span class="pre">const</span></code> qualifier</p></li>
</ul>
</dd>
</dl>
<p>No additional type data follow <code class="docutils literal notranslate"><span class="pre">btf_type</span></code>.</p>
</section>
<section id="btf-kind-restrict">
<h4>2.2.11 BTF_KIND_RESTRICT<a class="headerlink" href="#btf-kind-restrict" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_RESTRICT</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: the type with <code class="docutils literal notranslate"><span class="pre">restrict</span></code> qualifier</p></li>
</ul>
</dd>
</dl>
<p>No additional type data follow <code class="docutils literal notranslate"><span class="pre">btf_type</span></code>.</p>
</section>
<section id="btf-kind-func">
<h4>2.2.12 BTF_KIND_FUNC<a class="headerlink" href="#btf-kind-func" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: offset to a valid C identifier</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_FUNC</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: linkage information (BTF_FUNC_STATIC, BTF_FUNC_GLOBAL</dt><dd><p>or BTF_FUNC_EXTERN)</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: a BTF_KIND_FUNC_PROTO type</p></li>
</ul>
</dd>
</dl>
<p>No additional type data follow <code class="docutils literal notranslate"><span class="pre">btf_type</span></code>.</p>
<p>A BTF_KIND_FUNC defines not a type, but a subprogram (function) whose
signature is defined by <code class="docutils literal notranslate"><span class="pre">type</span></code>. The subprogram is thus an instance of that
type. The BTF_KIND_FUNC may in turn be referenced by a func_info in the
<a class="reference internal" href="#btf-ext-section"><span class="std std-ref">4.2 .BTF.ext section</span></a> (ELF) or in the arguments to <a class="reference internal" href="#bpf-prog-load"><span class="std std-ref">3.3 BPF_PROG_LOAD</span></a>
(ABI).</p>
<p>Currently, only linkage values of BTF_FUNC_STATIC and BTF_FUNC_GLOBAL are
supported in the kernel.</p>
</section>
<section id="btf-kind-func-proto">
<h4>2.2.13 BTF_KIND_FUNC_PROTO<a class="headerlink" href="#btf-kind-func-proto" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_FUNC_PROTO</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: # of parameters</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: the return type</p></li>
</ul>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">btf_type</span></code> is followed by <code class="docutils literal notranslate"><span class="pre">info.vlen</span></code> number of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_param</span></code>.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_param {
    __u32   name_off;
    __u32   type;
};
</pre></div>
</div>
<p>If a BTF_KIND_FUNC_PROTO type is referred by a BTF_KIND_FUNC type, then
<code class="docutils literal notranslate"><span class="pre">btf_param.name_off</span></code> must point to a valid C identifier except for the
possible last argument representing the variable argument. The btf_param.type
refers to parameter type.</p>
<p>If the function has variable arguments, the last parameter is encoded with
<code class="docutils literal notranslate"><span class="pre">name_off</span> <span class="pre">=</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
</section>
<section id="btf-kind-var">
<h4>2.2.14 BTF_KIND_VAR<a class="headerlink" href="#btf-kind-var" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: offset to a valid C identifier</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_VAR</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: the type of the variable</p></li>
</ul>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">btf_type</span></code> is followed by a single <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_variable</span></code> with the
following data:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_var {
    __u32   linkage;
};
</pre></div>
</div>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_var</span></code> encoding:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">linkage</span></code>: currently only static variable 0, or globally allocated</dt><dd><p>variable in ELF sections 1</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Not all type of global variables are supported by LLVM at this point.
The following is currently available:</p>
<blockquote>
<div><ul class="simple">
<li><p>static variables with or without section attributes</p></li>
<li><p>global variables with section attributes</p></li>
</ul>
</div></blockquote>
<p>The latter is for future extraction of map key/value type id’s from a
map definition.</p>
</section>
<section id="btf-kind-datasec">
<h4>2.2.15 BTF_KIND_DATASEC<a class="headerlink" href="#btf-kind-datasec" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: offset to a valid name associated with a variable or</dt><dd><p>one of .data/.bss/.rodata</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_DATASEC</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: # of variables</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code>: total section size in bytes (0 at compilation time, patched</dt><dd><p>to actual size by BPF loaders such as libbpf)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">btf_type</span></code> is followed by <code class="docutils literal notranslate"><span class="pre">info.vlen</span></code> number of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_var_secinfo</span></code>.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_var_secinfo {
    __u32   type;
    __u32   offset;
    __u32   size;
};
</pre></div>
</div>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_var_secinfo</span></code> encoding:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: the type of the BTF_KIND_VAR variable</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">offset</span></code>: the in-section offset of the variable</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: the size of the variable in bytes</p></li>
</ul>
</dd>
</dl>
</section>
<section id="btf-kind-float">
<h4>2.2.16 BTF_KIND_FLOAT<a class="headerlink" href="#btf-kind-float" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: any valid offset</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_FLOAT</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: the size of the float type in bytes: 2, 4, 8, 12 or 16.</p></li>
</ul>
</dd>
</dl>
<p>No additional type data follow <code class="docutils literal notranslate"><span class="pre">btf_type</span></code>.</p>
</section>
<section id="btf-kind-decl-tag">
<h4>2.2.17 BTF_KIND_DECL_TAG<a class="headerlink" href="#btf-kind-decl-tag" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: offset to a non-empty string</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_DECL_TAG</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: <code class="docutils literal notranslate"><span class="pre">struct</span></code>, <code class="docutils literal notranslate"><span class="pre">union</span></code>, <code class="docutils literal notranslate"><span class="pre">func</span></code>, <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">typedef</span></code></p></li>
</ul>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">btf_type</span></code> is followed by <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_decl_tag</span></code>.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_decl_tag {
    __u32   component_idx;
};
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">name_off</span></code> encodes btf_decl_tag attribute string.
The <code class="docutils literal notranslate"><span class="pre">type</span></code> should be <code class="docutils literal notranslate"><span class="pre">struct</span></code>, <code class="docutils literal notranslate"><span class="pre">union</span></code>, <code class="docutils literal notranslate"><span class="pre">func</span></code>, <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">typedef</span></code>.
For <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">typedef</span></code> type, <code class="docutils literal notranslate"><span class="pre">btf_decl_tag.component_idx</span></code> must be <code class="docutils literal notranslate"><span class="pre">-1</span></code>.
For the other three types, if the btf_decl_tag attribute is
applied to the <code class="docutils literal notranslate"><span class="pre">struct</span></code>, <code class="docutils literal notranslate"><span class="pre">union</span></code> or <code class="docutils literal notranslate"><span class="pre">func</span></code> itself,
<code class="docutils literal notranslate"><span class="pre">btf_decl_tag.component_idx</span></code> must be <code class="docutils literal notranslate"><span class="pre">-1</span></code>. Otherwise,
the attribute is applied to a <code class="docutils literal notranslate"><span class="pre">struct</span></code>/<code class="docutils literal notranslate"><span class="pre">union</span></code> member or
a <code class="docutils literal notranslate"><span class="pre">func</span></code> argument, and <code class="docutils literal notranslate"><span class="pre">btf_decl_tag.component_idx</span></code> should be a
valid index (starting from 0) pointing to a member or an argument.</p>
</section>
<section id="btf-kind-type-tag">
<h4>2.2.18 BTF_KIND_TYPE_TAG<a class="headerlink" href="#btf-kind-type-tag" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: offset to a non-empty string</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_TYPE_TAG</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: the type with <code class="docutils literal notranslate"><span class="pre">btf_type_tag</span></code> attribute</p></li>
</ul>
</dd>
</dl>
<p>Currently, <code class="docutils literal notranslate"><span class="pre">BTF_KIND_TYPE_TAG</span></code> is only emitted for pointer types.
It has the following btf type chain:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ptr -&gt; [type_tag]*
    -&gt; [const | volatile | restrict | typedef]*
    -&gt; base_type
</pre></div>
</div>
<p>Basically, a pointer type points to zero or more
type_tag, then zero or more const/volatile/restrict/typedef
and finally the base type. The base type is one of
int, ptr, array, struct, union, enum, func_proto and float types.</p>
</section>
<section id="btf-kind-enum64">
<h4>2.2.19 BTF_KIND_ENUM64<a class="headerlink" href="#btf-kind-enum64" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_type</span></code> encoding requirement:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: 0 or offset to a valid C identifier</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind_flag</span></code>: 0 for unsigned, 1 for signed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.kind</span></code>: BTF_KIND_ENUM64</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">info.vlen</span></code>: number of enum values</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: 1/2/4/8</p></li>
</ul>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">btf_type</span></code> is followed by <code class="docutils literal notranslate"><span class="pre">info.vlen</span></code> number of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_enum64</span></code>.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_enum64 {
    __u32   name_off;
    __u32   val_lo32;
    __u32   val_hi32;
};
</pre></div>
</div>
<dl class="simple">
<dt>The <code class="docutils literal notranslate"><span class="pre">btf_enum64</span></code> encoding:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name_off</span></code>: offset to a valid C identifier</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">val_lo32</span></code>: lower 32-bit value for a 64-bit value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">val_hi32</span></code>: high 32-bit value for a 64-bit value</p></li>
</ul>
</dd>
</dl>
<p>If the original enum value is signed and the size is less than 8,
that value will be sign extended into 8 bytes.</p>
</section>
</section>
</section>
<section id="btf-kernel-api">
<h2>3. BTF Kernel API<a class="headerlink" href="#btf-kernel-api" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>The following bpf syscall command involves BTF:</dt><dd><ul class="simple">
<li><p>BPF_BTF_LOAD: load a blob of BTF data into kernel</p></li>
<li><p>BPF_MAP_CREATE: map creation with btf key and value type info.</p></li>
<li><p>BPF_PROG_LOAD: prog load with btf function and line info.</p></li>
<li><p>BPF_BTF_GET_FD_BY_ID: get a btf fd</p></li>
<li><p>BPF_OBJ_GET_INFO_BY_FD: btf, func_info, line_info
and other btf related info are returned.</p></li>
</ul>
</dd>
</dl>
<p>The workflow typically looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Application:
    BPF_BTF_LOAD
        |
        v
    BPF_MAP_CREATE and BPF_PROG_LOAD
        |
        V
    ......

Introspection tool:
    ......
    BPF_{PROG,MAP}_GET_NEXT_ID (get prog/map id&#39;s)
        |
        V
    BPF_{PROG,MAP}_GET_FD_BY_ID (get a prog/map fd)
        |
        V
    BPF_OBJ_GET_INFO_BY_FD (get bpf_prog_info/bpf_map_info with btf_id)
        |                                     |
        V                                     |
    BPF_BTF_GET_FD_BY_ID (get btf_fd)         |
        |                                     |
        V                                     |
    BPF_OBJ_GET_INFO_BY_FD (get btf)          |
        |                                     |
        V                                     V
    pretty print types, dump func signatures and line info, etc.
</pre></div>
</div>
<section id="bpf-btf-load">
<h3>3.1 BPF_BTF_LOAD<a class="headerlink" href="#bpf-btf-load" title="Permalink to this headline">¶</a></h3>
<p>Load a blob of BTF data into kernel. A blob of data, described in
<a class="reference internal" href="#btf-type-string"><span class="std std-ref">2. BTF Type and String Encoding</span></a>, can be directly loaded into the kernel. A <code class="docutils literal notranslate"><span class="pre">btf_fd</span></code>
is returned to a userspace.</p>
</section>
<section id="bpf-map-create">
<h3>3.2 BPF_MAP_CREATE<a class="headerlink" href="#bpf-map-create" title="Permalink to this headline">¶</a></h3>
<p>A map can be created with <code class="docutils literal notranslate"><span class="pre">btf_fd</span></code> and specified key/value type id.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u32   btf_fd;         /* fd pointing to a BTF type data */
__u32   btf_key_type_id;        /* BTF type_id of the key */
__u32   btf_value_type_id;      /* BTF type_id of the value */
</pre></div>
</div>
<p>In libbpf, the map can be defined with extra annotation like below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __type(key, int);
    __type(value, struct ipv_counts);
    __uint(max_entries, 4);
} btf_map SEC(&quot;.maps&quot;);
</pre></div>
</div>
<p>During ELF parsing, libbpf is able to extract key/value type_id’s and assign
them to BPF_MAP_CREATE attributes automatically.</p>
</section>
<section id="bpf-prog-load">
<span id="id1"></span><h3>3.3 BPF_PROG_LOAD<a class="headerlink" href="#bpf-prog-load" title="Permalink to this headline">¶</a></h3>
<p>During prog_load, func_info and line_info can be passed to kernel with proper
values for the following attributes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__u32           insn_cnt;
__aligned_u64   insns;
......
__u32           prog_btf_fd;    /* fd pointing to BTF type data */
__u32           func_info_rec_size;     /* userspace bpf_func_info size */
__aligned_u64   func_info;      /* func info */
__u32           func_info_cnt;  /* number of bpf_func_info records */
__u32           line_info_rec_size;     /* userspace bpf_line_info size */
__aligned_u64   line_info;      /* line info */
__u32           line_info_cnt;  /* number of bpf_line_info records */
</pre></div>
</div>
<p>The func_info and line_info are an array of below, respectively.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct bpf_func_info {
    __u32   insn_off; /* [0, insn_cnt - 1] */
    __u32   type_id;  /* pointing to a BTF_KIND_FUNC type */
};
struct bpf_line_info {
    __u32   insn_off; /* [0, insn_cnt - 1] */
    __u32   file_name_off; /* offset to string table for the filename */
    __u32   line_off; /* offset to string table for the source line */
    __u32   line_col; /* line number and column number */
};
</pre></div>
</div>
<p>func_info_rec_size is the size of each func_info record, and
line_info_rec_size is the size of each line_info record. Passing the record
size to kernel make it possible to extend the record itself in the future.</p>
<dl class="simple">
<dt>Below are requirements for func_info:</dt><dd><ul class="simple">
<li><p>func_info[0].insn_off must be 0.</p></li>
<li><p>the func_info insn_off is in strictly increasing order and matches
bpf func boundaries.</p></li>
</ul>
</dd>
<dt>Below are requirements for line_info:</dt><dd><ul class="simple">
<li><p>the first insn in each func must have a line_info record pointing to it.</p></li>
<li><p>the line_info insn_off is in strictly increasing order.</p></li>
</ul>
</dd>
</dl>
<p>For line_info, the line number and column number are defined as below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define BPF_LINE_INFO_LINE_NUM(line_col)        ((line_col) &gt;&gt; 10)
#define BPF_LINE_INFO_LINE_COL(line_col)        ((line_col) &amp; 0x3ff)
</pre></div>
</div>
</section>
<section id="bpf-prog-map-get-next-id">
<h3>3.4 BPF_{PROG,MAP}_GET_NEXT_ID<a class="headerlink" href="#bpf-prog-map-get-next-id" title="Permalink to this headline">¶</a></h3>
<p>In kernel, every loaded program, map or btf has a unique id. The id won’t
change during the lifetime of a program, map, or btf.</p>
<p>The bpf syscall command BPF_{PROG,MAP}_GET_NEXT_ID returns all id’s, one for
each command, to user space, for bpf program or maps, respectively, so an
inspection tool can inspect all programs and maps.</p>
</section>
<section id="bpf-prog-map-get-fd-by-id">
<h3>3.5 BPF_{PROG,MAP}_GET_FD_BY_ID<a class="headerlink" href="#bpf-prog-map-get-fd-by-id" title="Permalink to this headline">¶</a></h3>
<p>An introspection tool cannot use id to get details about program or maps.
A file descriptor needs to be obtained first for reference-counting purpose.</p>
</section>
<section id="bpf-obj-get-info-by-fd">
<h3>3.6 BPF_OBJ_GET_INFO_BY_FD<a class="headerlink" href="#bpf-obj-get-info-by-fd" title="Permalink to this headline">¶</a></h3>
<p>Once a program/map fd is acquired, an introspection tool can get the detailed
information from kernel about this fd, some of which are BTF-related. For
example, <code class="docutils literal notranslate"><span class="pre">bpf_map_info</span></code> returns <code class="docutils literal notranslate"><span class="pre">btf_id</span></code> and key/value type ids.
<code class="docutils literal notranslate"><span class="pre">bpf_prog_info</span></code> returns <code class="docutils literal notranslate"><span class="pre">btf_id</span></code>, func_info, and line info for translated
bpf byte codes, and jited_line_info.</p>
</section>
<section id="bpf-btf-get-fd-by-id">
<h3>3.7 BPF_BTF_GET_FD_BY_ID<a class="headerlink" href="#bpf-btf-get-fd-by-id" title="Permalink to this headline">¶</a></h3>
<p>With <code class="docutils literal notranslate"><span class="pre">btf_id</span></code> obtained in <code class="docutils literal notranslate"><span class="pre">bpf_map_info</span></code> and <code class="docutils literal notranslate"><span class="pre">bpf_prog_info</span></code>, bpf
syscall command BPF_BTF_GET_FD_BY_ID can retrieve a btf fd. Then, with
command BPF_OBJ_GET_INFO_BY_FD, the btf blob, originally loaded into the
kernel with BPF_BTF_LOAD, can be retrieved.</p>
<p>With the btf blob, <code class="docutils literal notranslate"><span class="pre">bpf_map_info</span></code>, and <code class="docutils literal notranslate"><span class="pre">bpf_prog_info</span></code>, an introspection
tool has full btf knowledge and is able to pretty print map key/values, dump
func signatures and line info, along with byte/jit codes.</p>
</section>
</section>
<section id="elf-file-format-interface">
<h2>4. ELF File Format Interface<a class="headerlink" href="#elf-file-format-interface" title="Permalink to this headline">¶</a></h2>
<section id="btf-section">
<h3>4.1 .BTF section<a class="headerlink" href="#btf-section" title="Permalink to this headline">¶</a></h3>
<p>The .BTF section contains type and string data. The format of this section is
same as the one describe in <a class="reference internal" href="#btf-type-string"><span class="std std-ref">2. BTF Type and String Encoding</span></a>.</p>
</section>
<section id="btf-ext-section">
<span id="id2"></span><h3>4.2 .BTF.ext section<a class="headerlink" href="#btf-ext-section" title="Permalink to this headline">¶</a></h3>
<p>The .BTF.ext section encodes func_info and line_info which needs loader
manipulation before loading into the kernel.</p>
<p>The specification for .BTF.ext section is defined at <code class="docutils literal notranslate"><span class="pre">tools/lib/bpf/btf.h</span></code>
and <code class="docutils literal notranslate"><span class="pre">tools/lib/bpf/btf.c</span></code>.</p>
<p>The current header of .BTF.ext section:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_ext_header {
    __u16   magic;
    __u8    version;
    __u8    flags;
    __u32   hdr_len;

    /* All offsets are in bytes relative to the end of this header */
    __u32   func_info_off;
    __u32   func_info_len;
    __u32   line_info_off;
    __u32   line_info_len;
};
</pre></div>
</div>
<p>It is very similar to .BTF section. Instead of type/string section, it
contains func_info and line_info section. See <a class="reference internal" href="#bpf-prog-load"><span class="std std-ref">3.3 BPF_PROG_LOAD</span></a> for details
about func_info and line_info record format.</p>
<p>The func_info is organized as below.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>func_info_rec_size
btf_ext_info_sec for section #1 /* func_info for section #1 */
btf_ext_info_sec for section #2 /* func_info for section #2 */
...
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">func_info_rec_size</span></code> specifies the size of <code class="docutils literal notranslate"><span class="pre">bpf_func_info</span></code> structure when
.BTF.ext is generated. <code class="docutils literal notranslate"><span class="pre">btf_ext_info_sec</span></code>, defined below, is a collection of
func_info for each specific ELF section.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct btf_ext_info_sec {
   __u32   sec_name_off; /* offset to section name */
   __u32   num_info;
   /* Followed by num_info * record_size number of bytes */
   __u8    data[0];
};
</pre></div>
</div>
<p>Here, num_info must be greater than 0.</p>
<p>The line_info is organized as below.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>line_info_rec_size
btf_ext_info_sec for section #1 /* line_info for section #1 */
btf_ext_info_sec for section #2 /* line_info for section #2 */
...
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">line_info_rec_size</span></code> specifies the size of <code class="docutils literal notranslate"><span class="pre">bpf_line_info</span></code> structure when
.BTF.ext is generated.</p>
<p>The interpretation of <code class="docutils literal notranslate"><span class="pre">bpf_func_info-&gt;insn_off</span></code> and
<code class="docutils literal notranslate"><span class="pre">bpf_line_info-&gt;insn_off</span></code> is different between kernel API and ELF API. For
kernel API, the <code class="docutils literal notranslate"><span class="pre">insn_off</span></code> is the instruction offset in the unit of <code class="docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">bpf_insn</span></code>. For ELF API, the <code class="docutils literal notranslate"><span class="pre">insn_off</span></code> is the byte offset from the
beginning of section (<code class="docutils literal notranslate"><span class="pre">btf_ext_info_sec-&gt;sec_name_off</span></code>).</p>
</section>
<section id="btf-ids-section">
<h3>4.2 .BTF_ids section<a class="headerlink" href="#btf-ids-section" title="Permalink to this headline">¶</a></h3>
<p>The .BTF_ids section encodes BTF ID values that are used within the kernel.</p>
<p>This section is created during the kernel compilation with the help of
macros defined in <code class="docutils literal notranslate"><span class="pre">include/linux/btf_ids.h</span></code> header file. Kernel code can
use them to create lists and sets (sorted lists) of BTF ID values.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">BTF_ID_LIST</span></code> and <code class="docutils literal notranslate"><span class="pre">BTF_ID</span></code> macros define unsorted list of BTF ID values,
with following syntax:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BTF_ID_LIST(list)
BTF_ID(type1, name1)
BTF_ID(type2, name2)
</pre></div>
</div>
<p>resulting in following layout in .BTF_ids section:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__BTF_ID__type1__name1__1:
.zero 4
__BTF_ID__type2__name2__2:
.zero 4
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">list[];</span></code> variable is defined to access the list.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">BTF_ID_UNUSED</span></code> macro defines 4 zero bytes. It’s used when we
want to define unused entry in BTF_ID_LIST, like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BTF_ID_LIST(bpf_skb_output_btf_ids)
BTF_ID(struct, sk_buff)
BTF_ID_UNUSED
BTF_ID(struct, task_struct)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">BTF_SET_START/END</span></code> macros pair defines sorted list of BTF ID values
and their count, with following syntax:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BTF_SET_START(set)
BTF_ID(type1, name1)
BTF_ID(type2, name2)
BTF_SET_END(set)
</pre></div>
</div>
<p>resulting in following layout in .BTF_ids section:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__BTF_ID__set__set:
.zero 4
__BTF_ID__type1__name1__3:
.zero 4
__BTF_ID__type2__name2__4:
.zero 4
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">btf_id_set</span> <span class="pre">set;</span></code> variable is defined to access the list.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">typeX</span></code> name can be one of following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct, union, typedef, func
</pre></div>
</div>
<p>and is used as a filter when resolving the BTF ID value.</p>
<p>All the BTF ID lists and sets are compiled in the .BTF_ids section and
resolved during the linking phase of kernel build by <code class="docutils literal notranslate"><span class="pre">resolve_btfids</span></code> tool.</p>
</section>
</section>
<section id="using-btf">
<h2>5. Using BTF<a class="headerlink" href="#using-btf" title="Permalink to this headline">¶</a></h2>
<section id="bpftool-map-pretty-print">
<h3>5.1 bpftool map pretty print<a class="headerlink" href="#bpftool-map-pretty-print" title="Permalink to this headline">¶</a></h3>
<p>With BTF, the map key/value can be printed based on fields rather than simply
raw bytes. This is especially valuable for large structure or if your data
structure has bitfields. For example, for the following map,:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum A { A1, A2, A3, A4, A5 };
typedef enum A ___A;
struct tmp_t {
     char a1:4;
     int  a2:4;
     int  :4;
     __u32 a3:4;
     int b;
     ___A b1:4;
     enum A b2:4;
};
struct {
     __uint(type, BPF_MAP_TYPE_ARRAY);
     __type(key, int);
     __type(value, struct tmp_t);
     __uint(max_entries, 1);
} tmpmap SEC(&quot;.maps&quot;);
</pre></div>
</div>
<p>bpftool is able to pretty print like below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[{
      &quot;key&quot;: 0,
      &quot;value&quot;: {
          &quot;a1&quot;: 0x2,
          &quot;a2&quot;: 0x4,
          &quot;a3&quot;: 0x6,
          &quot;b&quot;: 7,
          &quot;b1&quot;: 0x8,
          &quot;b2&quot;: 0xa
      }
  }
]
</pre></div>
</div>
</section>
<section id="bpftool-prog-dump">
<h3>5.2 bpftool prog dump<a class="headerlink" href="#bpftool-prog-dump" title="Permalink to this headline">¶</a></h3>
<p>The following is an example showing how func_info and line_info can help prog
dump with better kernel symbol names, function prototypes and line
information.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ bpftool prog dump jited pinned /sys/fs/bpf/test_btf_haskv
[...]
int test_long_fname_2(struct dummy_tracepoint_args * arg):
bpf_prog_44a040bf25481309_test_long_fname_2:
; static int test_long_fname_2(struct dummy_tracepoint_args *arg)
   0:   push   %rbp
   1:   mov    %rsp,%rbp
   4:   sub    $0x30,%rsp
   b:   sub    $0x28,%rbp
   f:   mov    %rbx,0x0(%rbp)
  13:   mov    %r13,0x8(%rbp)
  17:   mov    %r14,0x10(%rbp)
  1b:   mov    %r15,0x18(%rbp)
  1f:   xor    %eax,%eax
  21:   mov    %rax,0x20(%rbp)
  25:   xor    %esi,%esi
; int key = 0;
  27:   mov    %esi,-0x4(%rbp)
; if (!arg-&gt;sock)
  2a:   mov    0x8(%rdi),%rdi
; if (!arg-&gt;sock)
  2e:   cmp    $0x0,%rdi
  32:   je     0x0000000000000070
  34:   mov    %rbp,%rsi
; counts = bpf_map_lookup_elem(&amp;btf_map, &amp;key);
[...]
</pre></div>
</div>
</section>
<section id="verifier-log">
<h3>5.3 Verifier Log<a class="headerlink" href="#verifier-log" title="Permalink to this headline">¶</a></h3>
<p>The following is an example of how line_info can help debugging verification
failure.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   /* The code at tools/testing/selftests/bpf/test_xdp_noinline.c
    * is modified as below.
    */
   data = (void *)(long)xdp-&gt;data;
   data_end = (void *)(long)xdp-&gt;data_end;
   /*
   if (data + 4 &gt; data_end)
           return XDP_DROP;
   */
   *(u32 *)data = dst-&gt;dst;

$ bpftool prog load ./test_xdp_noinline.o /sys/fs/bpf/test_xdp_noinline type xdp
    ; data = (void *)(long)xdp-&gt;data;
    224: (79) r2 = *(u64 *)(r10 -112)
    225: (61) r2 = *(u32 *)(r2 +0)
    ; *(u32 *)data = dst-&gt;dst;
    226: (63) *(u32 *)(r2 +0) = r1
    invalid access to packet, off=0 size=4, R2(id=0,off=0,r=0)
    R2 offset is outside of the packet
</pre></div>
</div>
</section>
</section>
<section id="btf-generation">
<h2>6. BTF Generation<a class="headerlink" href="#btf-generation" title="Permalink to this headline">¶</a></h2>
<p>You need latest pahole</p>
<blockquote>
<div><p><a class="reference external" href="https://git.kernel.org/pub/scm/devel/pahole/pahole.git/">https://git.kernel.org/pub/scm/devel/pahole/pahole.git/</a></p>
</div></blockquote>
<p>or llvm (8.0 or later). The pahole acts as a dwarf2btf converter. It doesn’t
support .BTF.ext and btf BTF_KIND_FUNC type yet. For example,:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-bash-4.4$ cat t.c
struct t {
  int a:2;
  int b:3;
  int c:2;
} g;
-bash-4.4$ gcc -c -O2 -g t.c
-bash-4.4$ pahole -JV t.o
File t.o:
[1] STRUCT t kind_flag=1 size=4 vlen=3
        a type_id=2 bitfield_size=2 bits_offset=0
        b type_id=2 bitfield_size=3 bits_offset=2
        c type_id=2 bitfield_size=2 bits_offset=5
[2] INT int size=4 bit_offset=0 nr_bits=32 encoding=SIGNED
</pre></div>
</div>
<p>The llvm is able to generate .BTF and .BTF.ext directly with -g for bpf target
only. The assembly code (-S) is able to show the BTF encoding in assembly
format.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-bash-4.4$ cat t2.c
typedef int __int32;
struct t2 {
  int a2;
  int (*f2)(char q1, __int32 q2, ...);
  int (*f3)();
} g2;
int main() { return 0; }
int test() { return 0; }
-bash-4.4$ clang -c -g -O2 -target bpf t2.c
-bash-4.4$ readelf -S t2.o
  ......
  [ 8] .BTF              PROGBITS         0000000000000000  00000247
       000000000000016e  0000000000000000           0     0     1
  [ 9] .BTF.ext          PROGBITS         0000000000000000  000003b5
       0000000000000060  0000000000000000           0     0     1
  [10] .rel.BTF.ext      REL              0000000000000000  000007e0
       0000000000000040  0000000000000010          16     9     8
  ......
-bash-4.4$ clang -S -g -O2 -target bpf t2.c
-bash-4.4$ cat t2.s
  ......
        .section        .BTF,&quot;&quot;,@progbits
        .short  60319                   # 0xeb9f
        .byte   1
        .byte   0
        .long   24
        .long   0
        .long   220
        .long   220
        .long   122
        .long   0                       # BTF_KIND_FUNC_PROTO(id = 1)
        .long   218103808               # 0xd000000
        .long   2
        .long   83                      # BTF_KIND_INT(id = 2)
        .long   16777216                # 0x1000000
        .long   4
        .long   16777248                # 0x1000020
  ......
        .byte   0                       # string offset=0
        .ascii  &quot;.text&quot;                 # string offset=1
        .byte   0
        .ascii  &quot;/home/yhs/tmp-pahole/t2.c&quot; # string offset=7
        .byte   0
        .ascii  &quot;int main() { return 0; }&quot; # string offset=33
        .byte   0
        .ascii  &quot;int test() { return 0; }&quot; # string offset=58
        .byte   0
        .ascii  &quot;int&quot;                   # string offset=83
  ......
        .section        .BTF.ext,&quot;&quot;,@progbits
        .short  60319                   # 0xeb9f
        .byte   1
        .byte   0
        .long   24
        .long   0
        .long   28
        .long   28
        .long   44
        .long   8                       # FuncInfo
        .long   1                       # FuncInfo section string offset=1
        .long   2
        .long   .Lfunc_begin0
        .long   3
        .long   .Lfunc_begin1
        .long   5
        .long   16                      # LineInfo
        .long   1                       # LineInfo section string offset=1
        .long   2
        .long   .Ltmp0
        .long   7
        .long   33
        .long   7182                    # Line 7 Col 14
        .long   .Ltmp3
        .long   7
        .long   58
        .long   8206                    # Line 8 Col 14
</pre></div>
</div>
</section>
<section id="testing">
<h2>7. Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h2>
<p>The kernel BPF selftest <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/prog_tests/btf.c">tools/testing/selftests/bpf/prog_tests/btf.c</a>
provides an extensive set of BTF-related tests.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">BPF Type Format (BTF)</a><ul>
<li><a class="reference internal" href="#introduction">1. Introduction</a></li>
<li><a class="reference internal" href="#btf-type-and-string-encoding">2. BTF Type and String Encoding</a><ul>
<li><a class="reference internal" href="#string-encoding">2.1 String Encoding</a></li>
<li><a class="reference internal" href="#type-encoding">2.2 Type Encoding</a><ul>
<li><a class="reference internal" href="#btf-kind-int">2.2.1 BTF_KIND_INT</a></li>
<li><a class="reference internal" href="#btf-kind-ptr">2.2.2 BTF_KIND_PTR</a></li>
<li><a class="reference internal" href="#btf-kind-array">2.2.3 BTF_KIND_ARRAY</a></li>
<li><a class="reference internal" href="#btf-kind-struct">2.2.4 BTF_KIND_STRUCT</a></li>
<li><a class="reference internal" href="#btf-kind-union">2.2.5 BTF_KIND_UNION</a></li>
<li><a class="reference internal" href="#btf-kind-enum">2.2.6 BTF_KIND_ENUM</a></li>
<li><a class="reference internal" href="#btf-kind-fwd">2.2.7 BTF_KIND_FWD</a></li>
<li><a class="reference internal" href="#btf-kind-typedef">2.2.8 BTF_KIND_TYPEDEF</a></li>
<li><a class="reference internal" href="#btf-kind-volatile">2.2.9 BTF_KIND_VOLATILE</a></li>
<li><a class="reference internal" href="#btf-kind-const">2.2.10 BTF_KIND_CONST</a></li>
<li><a class="reference internal" href="#btf-kind-restrict">2.2.11 BTF_KIND_RESTRICT</a></li>
<li><a class="reference internal" href="#btf-kind-func">2.2.12 BTF_KIND_FUNC</a></li>
<li><a class="reference internal" href="#btf-kind-func-proto">2.2.13 BTF_KIND_FUNC_PROTO</a></li>
<li><a class="reference internal" href="#btf-kind-var">2.2.14 BTF_KIND_VAR</a></li>
<li><a class="reference internal" href="#btf-kind-datasec">2.2.15 BTF_KIND_DATASEC</a></li>
<li><a class="reference internal" href="#btf-kind-float">2.2.16 BTF_KIND_FLOAT</a></li>
<li><a class="reference internal" href="#btf-kind-decl-tag">2.2.17 BTF_KIND_DECL_TAG</a></li>
<li><a class="reference internal" href="#btf-kind-type-tag">2.2.18 BTF_KIND_TYPE_TAG</a></li>
<li><a class="reference internal" href="#btf-kind-enum64">2.2.19 BTF_KIND_ENUM64</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#btf-kernel-api">3. BTF Kernel API</a><ul>
<li><a class="reference internal" href="#bpf-btf-load">3.1 BPF_BTF_LOAD</a></li>
<li><a class="reference internal" href="#bpf-map-create">3.2 BPF_MAP_CREATE</a></li>
<li><a class="reference internal" href="#bpf-prog-load">3.3 BPF_PROG_LOAD</a></li>
<li><a class="reference internal" href="#bpf-prog-map-get-next-id">3.4 BPF_{PROG,MAP}_GET_NEXT_ID</a></li>
<li><a class="reference internal" href="#bpf-prog-map-get-fd-by-id">3.5 BPF_{PROG,MAP}_GET_FD_BY_ID</a></li>
<li><a class="reference internal" href="#bpf-obj-get-info-by-fd">3.6 BPF_OBJ_GET_INFO_BY_FD</a></li>
<li><a class="reference internal" href="#bpf-btf-get-fd-by-id">3.7 BPF_BTF_GET_FD_BY_ID</a></li>
</ul>
</li>
<li><a class="reference internal" href="#elf-file-format-interface">4. ELF File Format Interface</a><ul>
<li><a class="reference internal" href="#btf-section">4.1 .BTF section</a></li>
<li><a class="reference internal" href="#btf-ext-section">4.2 .BTF.ext section</a></li>
<li><a class="reference internal" href="#btf-ids-section">4.2 .BTF_ids section</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-btf">5. Using BTF</a><ul>
<li><a class="reference internal" href="#bpftool-map-pretty-print">5.1 bpftool map pretty print</a></li>
<li><a class="reference internal" href="#bpftool-prog-dump">5.2 bpftool prog dump</a></li>
<li><a class="reference internal" href="#verifier-log">5.3 Verifier Log</a></li>
</ul>
</li>
<li><a class="reference internal" href="#btf-generation">6. BTF Generation</a></li>
<li><a class="reference internal" href="#testing">7. Testing</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/bpf/btf.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/bpf/btf.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>