
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>BPF_MAP_TYPE_CGROUP_STORAGE &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="BPF_MAP_TYPE_CGRP_STORAGE" href="map_cgrp_storage.html" />
    <link rel="prev" title="BPF_MAP_TYPE_BLOOM_FILTER" href="map_bloom_filter.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="bpf-map-type-cgroup-storage">
<h1>BPF_MAP_TYPE_CGROUP_STORAGE<a class="headerlink" href="#bpf-map-type-cgroup-storage" title="Permalink to this headline">¶</a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">BPF_MAP_TYPE_CGROUP_STORAGE</span></code> map type represents a local fix-sized
storage. It is only available with <code class="docutils literal notranslate"><span class="pre">CONFIG_CGROUP_BPF</span></code>, and to programs that
attach to cgroups; the programs are made available by the same Kconfig. The
storage is identified by the cgroup the program is attached to.</p>
<p>The map provide a local storage at the cgroup that the BPF program is attached
to. It provides a faster and simpler access than the general purpose hash
table, which performs a hash table lookups, and requires user to track live
cgroups on their own.</p>
<p>This document describes the usage and semantics of the
<code class="docutils literal notranslate"><span class="pre">BPF_MAP_TYPE_CGROUP_STORAGE</span></code> map type. Some of its behaviors was changed in
Linux 5.9 and this document will describe the differences.</p>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>The map uses key of type of either <code class="docutils literal notranslate"><span class="pre">__u64</span> <span class="pre">cgroup_inode_id</span></code> or
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_cgroup_storage_key</span></code>, declared in <code class="docutils literal notranslate"><span class="pre">linux/bpf.h</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct bpf_cgroup_storage_key {
        __u64 cgroup_inode_id;
        __u32 attach_type;
};
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cgroup_inode_id</span></code> is the inode id of the cgroup directory.
<code class="docutils literal notranslate"><span class="pre">attach_type</span></code> is the program’s attach type.</p>
<p>Linux 5.9 added support for type <code class="docutils literal notranslate"><span class="pre">__u64</span> <span class="pre">cgroup_inode_id</span></code> as the key type.
When this key type is used, then all attach types of the particular cgroup and
map will share the same storage. Otherwise, if the type is
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_cgroup_storage_key</span></code>, then programs of different attach types
be isolated and see different storages.</p>
<p>To access the storage in a program, use <code class="docutils literal notranslate"><span class="pre">bpf_get_local_storage</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void *bpf_get_local_storage(void *map, u64 flags)
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">flags</span></code> is reserved for future use and must be 0.</p>
<p>There is no implicit synchronization. Storages of <code class="docutils literal notranslate"><span class="pre">BPF_MAP_TYPE_CGROUP_STORAGE</span></code>
can be accessed by multiple programs across different CPUs, and user should
take care of synchronization by themselves. The bpf infrastructure provides
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_spin_lock</span></code> to synchronize the storage. See
<code class="docutils literal notranslate"><span class="pre">tools/testing/selftests/bpf/progs/test_spin_lock.c</span></code>.</p>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Usage with key type as <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_cgroup_storage_key</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;bpf/bpf.h&gt;

struct {
        __uint(type, BPF_MAP_TYPE_CGROUP_STORAGE);
        __type(key, struct bpf_cgroup_storage_key);
        __type(value, __u32);
} cgroup_storage SEC(&quot;.maps&quot;);

int program(struct __sk_buff *skb)
{
        __u32 *ptr = bpf_get_local_storage(&amp;cgroup_storage, 0);
        __sync_fetch_and_add(ptr, 1);

        return 0;
}
</pre></div>
</div>
<p>Userspace accessing map declared above:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/bpf.h&gt;
#include &lt;linux/libbpf.h&gt;

__u32 map_lookup(struct bpf_map *map, __u64 cgrp, enum bpf_attach_type type)
{
        struct bpf_cgroup_storage_key = {
                .cgroup_inode_id = cgrp,
                .attach_type = type,
        };
        __u32 value;
        bpf_map_lookup_elem(bpf_map__fd(map), &amp;key, &amp;value);
        // error checking omitted
        return value;
}
</pre></div>
</div>
<p>Alternatively, using just <code class="docutils literal notranslate"><span class="pre">__u64</span> <span class="pre">cgroup_inode_id</span></code> as key type:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;bpf/bpf.h&gt;

struct {
        __uint(type, BPF_MAP_TYPE_CGROUP_STORAGE);
        __type(key, __u64);
        __type(value, __u32);
} cgroup_storage SEC(&quot;.maps&quot;);

int program(struct __sk_buff *skb)
{
        __u32 *ptr = bpf_get_local_storage(&amp;cgroup_storage, 0);
        __sync_fetch_and_add(ptr, 1);

        return 0;
}
</pre></div>
</div>
<p>And userspace:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/bpf.h&gt;
#include &lt;linux/libbpf.h&gt;

__u32 map_lookup(struct bpf_map *map, __u64 cgrp, enum bpf_attach_type type)
{
        __u32 value;
        bpf_map_lookup_elem(bpf_map__fd(map), &amp;cgrp, &amp;value);
        // error checking omitted
        return value;
}
</pre></div>
</div>
</section>
<section id="semantics">
<h2>Semantics<a class="headerlink" href="#semantics" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</span></code> is a variant of this map type. This
per-CPU variant will have different memory regions for each CPU for each
storage. The non-per-CPU will have the same memory region for each storage.</p>
<p>Prior to Linux 5.9, the lifetime of a storage is precisely per-attachment, and
for a single <code class="docutils literal notranslate"><span class="pre">CGROUP_STORAGE</span></code> map, there can be at most one program loaded
that uses the map. A program may be attached to multiple cgroups or have
multiple attach types, and each attach creates a fresh zeroed storage. The
storage is freed upon detach.</p>
<p>There is a one-to-one association between the map of each type (per-CPU and
non-per-CPU) and the BPF program during load verification time. As a result,
each map can only be used by one BPF program and each BPF program can only use
one storage map of each type. Because of map can only be used by one BPF
program, sharing of this cgroup’s storage with other BPF programs were
impossible.</p>
<p>Since Linux 5.9, storage can be shared by multiple programs. When a program is
attached to a cgroup, the kernel would create a new storage only if the map
does not already contain an entry for the cgroup and attach type pair, or else
the old storage is reused for the new attachment. If the map is attach type
shared, then attach type is simply ignored during comparison. Storage is freed
only when either the map or the cgroup attached to is being freed. Detaching
will not directly free the storage, but it may cause the reference to the map
to reach zero and indirectly freeing all storage in the map.</p>
<p>The map is not associated with any BPF program, thus making sharing possible.
However, the BPF program can still only associate with one map of each type
(per-CPU and non-per-CPU). A BPF program cannot use more than one
<code class="docutils literal notranslate"><span class="pre">BPF_MAP_TYPE_CGROUP_STORAGE</span></code> or more than one
<code class="docutils literal notranslate"><span class="pre">BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</span></code>.</p>
<p>In all versions, userspace may use the attach parameters of cgroup and
attach type pair in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_cgroup_storage_key</span></code> as the key to the BPF map
APIs to read or update the storage for a given attachment. For Linux 5.9
attach type shared storages, only the first value in the struct, cgroup inode
id, is used during comparison, so userspace may just specify a <code class="docutils literal notranslate"><span class="pre">__u64</span></code>
directly.</p>
<p>The storage is bound at attach time. Even if the program is attached to parent
and triggers in child, the storage still belongs to the parent.</p>
<p>Userspace cannot create a new entry in the map or delete an existing entry.
Program test runs always use a temporary storage.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">BPF_MAP_TYPE_CGROUP_STORAGE</a><ul>
<li><a class="reference internal" href="#usage">Usage</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#semantics">Semantics</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/bpf/map_cgroup_storage.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/bpf/map_cgroup_storage.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>