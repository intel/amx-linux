
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>4. MSI驱动指南 &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>此文件的目的是为让中文读者更容易阅读和理解，而不是作为一个分支。 因此，
如果您对此文件有任何意见或更新，请先尝试更新原始英文文件。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果您发现本文档与原始文件有任何不同或者有翻译问题，请联系该文件的译者，
或者请求时奎亮的帮助：&lt;<a class="reference external" href="mailto:alexs&#37;&#52;&#48;kernel&#46;org">alexs<span>&#64;</span>kernel<span>&#46;</span>org</a>&gt;。</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Original</dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../PCI/msi-howto.html"><span class="doc">The MSI Driver Guide HOWTO</span></a></p>
</dd>
<dt class="field-even">翻译</dt>
<dd class="field-even"><p>司延腾 Yanteng Si &lt;<a class="reference external" href="mailto:siyanteng&#37;&#52;&#48;loongson&#46;cn">siyanteng<span>&#64;</span>loongson<span>&#46;</span>cn</a>&gt;</p>
</dd>
<dt class="field-odd">校译</dt>
<dd class="field-odd"><p></p></dd>
</dl>
<section id="msi">
<h1><span class="section-number">4. </span>MSI驱动指南<a class="headerlink" href="#msi" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">作者</dt>
<dd class="field-odd"><p>Tom L Nguyen; Martine Silbermann; Matthew Wilcox</p>
</dd>
<dt class="field-even">版权</dt>
<dd class="field-even"><p>2003, 2008 Intel Corporation</p>
</dd>
</dl>
<section id="id1">
<h2><span class="section-number">4.1. </span>关于本指南<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>本指南介绍了消息标记中断（MSI）的基本知识，使用MSI相对于传统中断机制的优势，如何
改变你的驱动程序以使用MSI或MSI-X，以及在设备不支持MSI时可以尝试的一些基本诊断方法。</p>
</section>
<section id="id2">
<h2><span class="section-number">4.2. </span>什么是MSI?<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>信息信号中断是指从设备写到一个特殊的地址，导致CPU接收到一个中断。</p>
<p>MSI能力首次在PCI 2.2中规定，后来在PCI 3.0中得到增强，允许对每个中断进行单独屏蔽。
MSI-X功能也随着PCI 3.0被引入。它比MSI支持每个设备更多的中断，并允许独立配置中断。</p>
<p>设备可以同时支持MSI和MSI-X，但一次只能启用一个。</p>
</section>
<section id="id3">
<h2><span class="section-number">4.3. </span>为什么用MSI?<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>有三个原因可以说明为什么使用MSI比传统的基于针脚的中断有优势。</p>
<p>基于针脚的PCI中断通常在几个设备之间共享。为了支持这一点，内核必须调用每个与中断相
关的中断处理程序，这导致了整个系统性能的降低。MSI从不共享，所以这个问题不会出现。</p>
<p>当一个设备将数据写入内存，然后引发一个基于引脚的中断时，有可能在所有的数据到达内存
之前，中断就已经到达了（这在PCI-PCI桥后面的设备中变得更有可能）。为了确保所有的数
据已经到达内存中，中断处理程序必须在引发中断的设备上读取一个寄存器。PCI事务排序规
则要求所有的数据在返回寄存器的值之前到达内存。使用MSI可以避免这个问题，因为中断产
生的写入不能通过数据写入，所以当中断发生时，驱动程序知道所有的数据已经到达内存中。</p>
<p>PCI设备每个功能只能支持一个基于引脚的中断。通常情况下，驱动程序必须查询设备以找出
发生了什么事件，这就减慢了对常见情况的中断处理。有了MSI，设备可以支持更多的中断，
允许每个中断被专门用于不同的目的。一种可能的设计是给不经常发生的情况（如错误）提供
自己的中断，这使得驱动程序可以更有效地处理正常的中断处理路径。其他可能的设计包括给
网卡的每个数据包队列或存储控制器的每个端口提供一个中断。</p>
</section>
<section id="id4">
<h2><span class="section-number">4.4. </span>如何使用MSI<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>PCI设备被初始化为使用基于引脚的中断。设备驱动程序必须将设备设置为使用MSI或MSI-X。
并非所有的机器都能正确地支持MSI，对于这些机器，下面描述的API将简单地失败，设备将
继续使用基于引脚的中断。</p>
<section id="id5">
<h3><span class="section-number">4.4.1. </span>加入内核对MSI的支持<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>为了支持MSI或MSI-X，内核在构建时必须启用CONFIG_PCI_MSI选项。这个选项只在某些架
构上可用，而且它可能取决于其他一些选项的设置。例如，在x86上，你必须同时启用X86_UP_APIC
或SMP，才能看到CONFIG_PCI_MSI选项。</p>
</section>
<section id="id6">
<h3><span class="section-number">4.4.2. </span>使用MSI<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>大部分沉重的工作是在PCI层为驱动程序完成的。驱动程序只需要请求PCI层为这个设备设置
MSI功能。</p>
<p>要自动使用MSI或MSI-X中断向量，请使用以下函数:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pci_alloc_irq_vectors(struct pci_dev *dev, unsigned int min_vecs,
              unsigned int max_vecs, unsigned int flags);
</pre></div>
</div>
<p>它为一个PCI设备分配最多至max_vecs的中断向量。它返回分配的向量数量或一个负的错误。
如果设备对最小数量的向量有要求，驱动程序可以传递一个min_vecs参数，设置为这个限制，
如果PCI核不能满足最小数量的向量，将返回-ENOSPC。</p>
<p>flags参数用来指定设备和驱动程序可以使用哪种类型的中断（PCI_IRQ_LEGACY, PCI_IRQ_MSI,
PCI_IRQ_MSIX）。一个方便的短语（PCI_IRQ_ALL_TYPES）也可以用来要求任何可能的中断类型。
如果PCI_IRQ_AFFINITY标志被设置，<a class="reference internal" href="../../../PCI/msi-howto.html#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a>将把中断分散到可用的CPU上。</p>
<p>要获得传递给require_irq()和<a class="reference internal" href="../../../core-api/genericirq.html#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_irq()</span></code></a>的Linux IRQ号码和向量，请使用以下函数:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int pci_irq_vector(struct pci_dev *dev, unsigned int nr);
</pre></div>
</div>
<p>在删除设备之前，应使用以下功能释放任何已分配的资源:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void pci_free_irq_vectors(struct pci_dev *dev);
</pre></div>
</div>
<p>如果一个设备同时支持MSI-X和MSI功能，这个API将优先使用MSI-X，而不是MSI。MSI-X支
持1到2048之间的任何数量的中断。相比之下，MSI被限制为最多32个中断（而且必须是2的幂）。
此外，MSI中断向量必须连续分配，所以系统可能无法为MSI分配像MSI-X那样多的向量。在一
些平台上，MSI中断必须全部针对同一组CPU，而MSI-X中断可以全部针对不同的CPU。</p>
<p>如果一个设备既不支持MSI-X，也不支持MSI，它就会退回到一个传统的IRQ向量。</p>
<p>MSI或MSI-X中断的典型用法是分配尽可能多的向量，可能达到设备支持的极限。如果nvec大于
设备支持的数量，它将自动被限制在支持的限度内，所以没有必要事先查询支持的向量的数量。:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nvec = pci_alloc_irq_vectors(pdev, 1, nvec, PCI_IRQ_ALL_TYPES)
if (nvec &lt; 0)
        goto out_err;
</pre></div>
</div>
<p>如果一个驱动程序不能或不愿意处理可变数量的MSI中断，它可以要求一个特定数量的中断，将该
数量作为“min_vecs“和“max_vecs“参数传递给<a class="reference internal" href="../../../PCI/msi-howto.html#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a>函数。:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ret = pci_alloc_irq_vectors(pdev, nvec, nvec, PCI_IRQ_ALL_TYPES);
if (ret &lt; 0)
        goto out_err;
</pre></div>
</div>
<p>上述请求类型的最臭名昭著的例子是为一个设备启用单一的MSI模式。它可以通过传递两个1作为
‘min_vecs’和’max_vecs’来实现:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);
if (ret &lt; 0)
        goto out_err;
</pre></div>
</div>
<p>一些设备可能不支持使用传统的线路中断，在这种情况下，驱动程序可以指定只接受MSI或MSI-X。:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nvec = pci_alloc_irq_vectors(pdev, 1, nvec, PCI_IRQ_MSI | PCI_IRQ_MSIX);
if (nvec &lt; 0)
        goto out_err;
</pre></div>
</div>
</section>
<section id="api">
<h3><span class="section-number">4.4.3. </span>传统API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h3>
<p>以下用于启用和禁用MSI或MSI-X中断的旧API不应该在新代码中使用:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pci_enable_msi()              /* deprecated */
pci_disable_msi()             /* deprecated */
pci_enable_msix_range()       /* deprecated */
pci_enable_msix_exact()       /* deprecated */
pci_disable_msix()            /* deprecated */
</pre></div>
</div>
<p>此外，还有一些API来提供支持的MSI或MSI-X向量的数量：<a class="reference internal" href="../../../driver-api/pci/pci.html#c.pci_msi_vec_count" title="pci_msi_vec_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_msi_vec_count()</span></code></a>和
<a class="reference internal" href="../../../PCI/msi-howto.html#c.pci_msix_vec_count" title="pci_msix_vec_count"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_msix_vec_count()</span></code></a>。一般来说，应该避免使用这些方法，而是让<a class="reference internal" href="../../../PCI/msi-howto.html#c.pci_alloc_irq_vectors" title="pci_alloc_irq_vectors"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_alloc_irq_vectors()</span></code></a>
来限制向量的数量。如果你对向量的数量有合法的特殊用例，我们可能要重新审视这个决定，
并增加一个pci_nr_irq_vectors()助手，透明地处理MSI和MSI-X。</p>
</section>
<section id="id7">
<h3><span class="section-number">4.4.4. </span>使用MSI时需要考虑的因素<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<section id="id8">
<h4><span class="section-number">4.4.4.1. </span>自旋锁<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>大多数设备驱动程序都有一个每的自旋锁，在中断处理程序中被占用。对于基于引脚的中断
或单一的MSI，没有必要禁用中断（Linux保证同一中断不会被重新输入）。如果一个设备
使用多个中断，驱动程序必须在锁被持有的时候禁用中断。如果设备发出一个不同的中断，
驱动程序将死锁，试图递归地获取自旋锁。这种死锁可以通过使用spin_lock_irqsave()
或spin_lock_irq()来避免，它们可以禁用本地中断并获取锁（见《不可靠的锁定指南》）。</p>
</section>
</section>
<section id="msi-msi-x">
<h3><span class="section-number">4.4.5. </span>如何判断一个设备上是否启用了MSI/MSI-X<a class="headerlink" href="#msi-msi-x" title="Permalink to this headline">¶</a></h3>
<p>使用“lspci -v“（以root身份）可能会显示一些具有“MSI“、“Message Signalled Interrupts“
或“MSI-X“功能的设备。这些功能中的每一个都有一个“启用“标志，后面是“+“（启用）
或“-“（禁用）。</p>
</section>
</section>
<section id="id9">
<h2><span class="section-number">4.5. </span>MSI特性<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>众所周知，一些PCI芯片组或设备不支持MSI。PCI协议栈提供了三种禁用MSI的方法:</p>
<ol class="arabic simple">
<li><p>全局的</p></li>
<li><p>在一个特定的桥后面的所有设备上</p></li>
<li><p>在单一设备上</p></li>
</ol>
<section id="id10">
<h3><span class="section-number">4.5.1. </span>全局禁用MSI<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>一些主控芯片组根本无法正确支持MSI。如果我们幸运的话，制造商知道这一点，并在
ACPI FADT表中指明了它。在这种情况下，Linux会自动禁用MSI。有些板卡在表中没
有包括这一信息，因此我们必须自己检测它们。完整的列表可以在drivers/pci/quirks.c
中的quirk_disable_all_msi()函数附近找到。</p>
<p>如果你有一块有MSI问题的板子，你可以在内核命令行中传递pci=nomsi来禁用所有设
备上的MSI。你最好把问题报告给linux-<a class="reference external" href="mailto:pci&#37;&#52;&#48;vger&#46;kernel&#46;org">pci<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a>，包括完整的
“lspci -v“，这样我们就可以把这些怪癖添加到内核中。</p>
</section>
<section id="id11">
<h3><span class="section-number">4.5.2. </span>禁用桥下的MSI<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>一些PCI桥接器不能在总线之间正确地路由MSI。在这种情况下，必须在桥接器后面的所
有设备上禁用MSI。</p>
<p>一些桥接器允许你通过改变PCI配置空间的一些位来启用MSI（特别是Hypertransport
芯片组，如nVidia nForce和Serverworks HT2000）。与主机芯片组一样，Linux大
多知道它们，如果可以的话，会自动启用MSI。如果你有一个Linux不知道的网桥，你可以
用你知道的任何方法在配置空间中启用MSI，然后通过以下方式在该网桥上启用MSI:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo 1 &gt; /sys/bus/pci/devices/$bridge/msi_bus
</pre></div>
</div>
<p>其中$bridge是你所启用的桥的PCI地址（例如0000:00:0e.0）。</p>
<p>要禁用MSI，请回显0而不是1。改变这个值应该谨慎进行，因为它可能会破坏这个桥下面所
有设备的中断处理。</p>
<p>同样，请通知 <a class="reference external" href="mailto:linux-pci&#37;&#52;&#48;vger&#46;kernel&#46;org">linux-pci<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a> 任何需要特殊处理的桥。</p>
</section>
<section id="msis">
<h3><span class="section-number">4.5.3. </span>在单一设备上关闭MSIs<a class="headerlink" href="#msis" title="Permalink to this headline">¶</a></h3>
<p>众所周知，有些设备的MSI实现是有问题的。通常情况下，这是在单个设备驱动程序中处理的，
但偶尔也有必要用一个古怪的方法来处理。一些驱动程序有一个选项可以禁用MSI的使用。虽然
这对驱动程序的作者来说是一个方便的变通办法，但这不是一个好的做法，不应该被模仿。</p>
</section>
<section id="id12">
<h3><span class="section-number">4.5.4. </span>寻找设备上MSI被禁用的原因<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>从以上三个部分，你可以看到有许多原因导致MSI没有在某个设备上被启用。你的第一步应该是
仔细检查你的dmesg以确定你的机器是否启用了MSI。你还应该检查你的.config以确定你已经
启用了CONFIG_PCI_MSI。</p>
<p>然后，“lspci -t“给出一个设备上面的网列表。读取 <code class="docutils literal notranslate"><span class="pre">/sys/bus/pci/devices/*/msi_bus</span></code>
将告诉你MSI是否被启用（1）或禁用（0）。如果在任何属于PCI根和设备之间的桥的msi_bus
文件中发现0，说明MSI被禁用。</p>
<p>也需要检查设备驱动程序，看它是否支持MSI。例如，它可能包含对带有PCI_IRQ_MSI或
PCI_IRQ_MSIX标志的pci_alloc_irq_vectors（）的调用。</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4. MSI驱动指南</a><ul>
<li><a class="reference internal" href="#id1">4.1. 关于本指南</a></li>
<li><a class="reference internal" href="#id2">4.2. 什么是MSI?</a></li>
<li><a class="reference internal" href="#id3">4.3. 为什么用MSI?</a></li>
<li><a class="reference internal" href="#id4">4.4. 如何使用MSI</a><ul>
<li><a class="reference internal" href="#id5">4.4.1. 加入内核对MSI的支持</a></li>
<li><a class="reference internal" href="#id6">4.4.2. 使用MSI</a></li>
<li><a class="reference internal" href="#api">4.4.3. 传统API</a></li>
<li><a class="reference internal" href="#id7">4.4.4. 使用MSI时需要考虑的因素</a><ul>
<li><a class="reference internal" href="#id8">4.4.4.1. 自旋锁</a></li>
</ul>
</li>
<li><a class="reference internal" href="#msi-msi-x">4.4.5. 如何判断一个设备上是否启用了MSI/MSI-X</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">4.5. MSI特性</a><ul>
<li><a class="reference internal" href="#id10">4.5.1. 全局禁用MSI</a></li>
<li><a class="reference internal" href="#id11">4.5.2. 禁用桥下的MSI</a></li>
<li><a class="reference internal" href="#msis">4.5.3. 在单一设备上关闭MSIs</a></li>
<li><a class="reference internal" href="#id12">4.5.4. 寻找设备上MSI被禁用的原因</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/translations/zh_CN/PCI/msi-howto.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/translations/zh_CN/PCI/msi-howto.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>