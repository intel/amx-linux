
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>追蹤缺陷 &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="二分（bisect）缺陷" href="bug-bisect.html" />
    <link rel="prev" title="安全缺陷" href="security-bugs.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>此文件的目的是爲讓中文讀者更容易閱讀和理解，而不是作爲一個分支。因此，
如果您對此文件有任何意見或改動，請先嘗試更新原始英文文件。如果要更改或
修正某處翻譯文件，請將意見或補丁發送給維護者（聯繫方式見下）。</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果您發現本文檔與原始文件有任何不同或者有翻譯問題，請聯繫該文件的譯者，
或者發送電子郵件給胡皓文以獲取幫助：&lt;<a class="reference external" href="mailto:src&#46;res&#37;&#52;&#48;email&#46;cn">src<span>&#46;</span>res<span>&#64;</span>email<span>&#46;</span>cn</a>&gt;。</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Original</dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../admin-guide/bug-hunting.html"><span class="doc">Bug hunting</span></a></p>
</dd>
<dt class="field-even">譯者</dt>
<dd class="field-even"><p>吳想成 Wu XiangCheng &lt;<a class="reference external" href="mailto:bobwxc&#37;&#52;&#48;email&#46;cn">bobwxc<span>&#64;</span>email<span>&#46;</span>cn</a>&gt;
胡皓文 Hu Haowen &lt;<a class="reference external" href="mailto:src&#46;res&#37;&#52;&#48;email&#46;cn">src<span>&#46;</span>res<span>&#64;</span>email<span>&#46;</span>cn</a>&gt;</p>
</dd>
</dl>
<section id="id1">
<h1>追蹤缺陷<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>內核錯誤報告通常附帶如下堆棧轉儲:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>------------[ cut here ]------------
WARNING: CPU: 1 PID: 28102 at kernel/module.c:1108 module_put+0x57/0x70
Modules linked in: dvb_usb_gp8psk(-) dvb_usb dvb_core nvidia_drm(PO) nvidia_modeset(PO) snd_hda_codec_hdmi snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_pcm snd_timer snd soundcore nvidia(PO) [last unloaded: rc_core]
CPU: 1 PID: 28102 Comm: rmmod Tainted: P        WC O 4.8.4-build.1 #1
Hardware name: MSI MS-7309/MS-7309, BIOS V1.12 02/23/2009
 00000000 c12ba080 00000000 00000000 c103ed6a c1616014 00000001 00006dc6
 c1615862 00000454 c109e8a7 c109e8a7 00000009 ffffffff 00000000 f13f6a10
 f5f5a600 c103ee33 00000009 00000000 00000000 c109e8a7 f80ca4d0 c109f617
Call Trace:
 [&lt;c12ba080&gt;] ? dump_stack+0x44/0x64
 [&lt;c103ed6a&gt;] ? __warn+0xfa/0x120
 [&lt;c109e8a7&gt;] ? module_put+0x57/0x70
 [&lt;c109e8a7&gt;] ? module_put+0x57/0x70
 [&lt;c103ee33&gt;] ? warn_slowpath_null+0x23/0x30
 [&lt;c109e8a7&gt;] ? module_put+0x57/0x70
 [&lt;f80ca4d0&gt;] ? gp8psk_fe_set_frontend+0x460/0x460 [dvb_usb_gp8psk]
 [&lt;c109f617&gt;] ? symbol_put_addr+0x27/0x50
 [&lt;f80bc9ca&gt;] ? dvb_usb_adapter_frontend_exit+0x3a/0x70 [dvb_usb]
 [&lt;f80bb3bf&gt;] ? dvb_usb_exit+0x2f/0xd0 [dvb_usb]
 [&lt;c13d03bc&gt;] ? usb_disable_endpoint+0x7c/0xb0
 [&lt;f80bb48a&gt;] ? dvb_usb_device_exit+0x2a/0x50 [dvb_usb]
 [&lt;c13d2882&gt;] ? usb_unbind_interface+0x62/0x250
 [&lt;c136b514&gt;] ? __pm_runtime_idle+0x44/0x70
 [&lt;c13620d8&gt;] ? __device_release_driver+0x78/0x120
 [&lt;c1362907&gt;] ? driver_detach+0x87/0x90
 [&lt;c1361c48&gt;] ? bus_remove_driver+0x38/0x90
 [&lt;c13d1c18&gt;] ? usb_deregister+0x58/0xb0
 [&lt;c109fbb0&gt;] ? SyS_delete_module+0x130/0x1f0
 [&lt;c1055654&gt;] ? task_work_run+0x64/0x80
 [&lt;c1000fa5&gt;] ? exit_to_usermode_loop+0x85/0x90
 [&lt;c10013f0&gt;] ? do_fast_syscall_32+0x80/0x130
 [&lt;c1549f43&gt;] ? sysenter_past_esp+0x40/0x6a
---[ end trace 6ebc60ef3981792f ]---
</pre></div>
</div>
<p>這樣的堆棧跟蹤提供了足夠的信息來識別內核原始碼中發生錯誤的那一行。根據問題的
嚴重性，它還可能包含 <strong>「Oops」</strong> 一詞，比如:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BUG: unable to handle kernel NULL pointer dereference at   (null)
IP: [&lt;c06969d4&gt;] iret_exc+0x7d0/0xa59
*pdpt = 000000002258a001 *pde = 0000000000000000
Oops: 0002 [#1] PREEMPT SMP
...
</pre></div>
</div>
<p>儘管有 <strong>Oops</strong> 或其他類型的堆棧跟蹤，但通常需要找到出問題的行來識別和處理缺
陷。在本章中，我們將參考「Oops」來了解需要分析的各種堆棧跟蹤。</p>
<p>如果內核是用 <code class="docutils literal notranslate"><span class="pre">CONFIG_DEBUG_INFO</span></code> 編譯的，那麼可以使用文件：
<cite>scripts/decode_stacktrace.sh</cite> 。</p>
<section id="id2">
<h2>連結的模塊<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>受到汙染或正在加載/卸載的模塊用「（…）」標記，汙染標誌在
<cite><a class="reference internal" href="../../../admin-guide/tainted-kernels.html"><span class="doc">Tainted kernels</span></a></cite> 文件中進行了描述，「正在被加
載」用「+」標註，「正在被卸載」用「-」標註。</p>
</section>
<section id="oops">
<h2>Oops消息在哪？<a class="headerlink" href="#oops" title="Permalink to this headline">¶</a></h2>
<p>通常，Oops文本由klogd從內核緩衝區讀取，然後交給 <code class="docutils literal notranslate"><span class="pre">syslogd</span></code> ，後者將其寫入
syslog文件，通常是 <code class="docutils literal notranslate"><span class="pre">/var/log/messages</span></code> （取決於 <code class="docutils literal notranslate"><span class="pre">/etc/syslog.conf</span></code> ）。
在使用systemd的系統上，它也可以由 <code class="docutils literal notranslate"><span class="pre">journald</span></code> 守護進程存儲，並通過運行
<code class="docutils literal notranslate"><span class="pre">journalctl</span></code> 命令進行訪問。</p>
<p>有時 <code class="docutils literal notranslate"><span class="pre">klogd</span></code> 會掛掉，這種情況下您可以運行 <code class="docutils literal notranslate"><span class="pre">dmesg</span> <span class="pre">&gt;</span> <span class="pre">file</span></code> 從內核緩衝區
讀取數據並保存它。或者您可以 <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">/proc/kmsg</span> <span class="pre">&gt;</span> <span class="pre">file</span></code> ，但是您必須適時
中斷以停止傳輸，因爲 <code class="docutils literal notranslate"><span class="pre">kmsg</span></code> 是一個「永無止境的文件」。</p>
<p>如果機器嚴重崩潰，無法輸入命令或磁碟不可用，那還有三個選項：</p>
<ol class="arabic simple">
<li><p>手動複製屏幕上的文本，並在機器重新啓動後輸入。很難受，但這是突然崩潰下
唯一的選擇。或者你可以用數位相機拍下屏幕——雖然不那麼好，但總比什麼都沒
有好。如果消息滾動超出控制台頂部，使用更高解析度（例如 <code class="docutils literal notranslate"><span class="pre">vga=791</span></code> ）
引導啓動將允許您閱讀更多文本。（警告：這需要 <code class="docutils literal notranslate"><span class="pre">vesafb</span></code> ，因此對「早期」
的Oppses沒有幫助）</p></li>
<li><p>從串口終端啓動（參見
<a class="reference internal" href="../../../admin-guide/serial-console.html#serial-console"><span class="std std-ref">Documentation/admin-guide/serial-console.rst</span></a> ），
在另一台機器上運行數據機然後用你喜歡的通信程序捕獲輸出。
Minicom運行良好。</p></li>
<li><p>使用Kdump（參閱 <a class="reference internal" href="../../../admin-guide/kdump/kdump.html"><span class="doc">Documentation for Kdump - The kexec-based Crash Dumping Solution</span></a> ），使用
Documentation/admin-guide/kdump/gdbmacros.txt 中的dmesg gdbmacro從舊內存
中提取內核環形緩衝區。</p></li>
</ol>
</section>
<section id="id3">
<h2>找到缺陷位置<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>如果你能指出缺陷在內核原始碼中的位置，則報告缺陷的效果會非常好。這有兩種方法。
通常來說使用 <code class="docutils literal notranslate"><span class="pre">gdb</span></code> 會比較容易，不過內核需要用調試信息來預編譯。</p>
<section id="gdb">
<h3>gdb<a class="headerlink" href="#gdb" title="Permalink to this headline">¶</a></h3>
<p>GNU 調試器（GNU debugger， <code class="docutils literal notranslate"><span class="pre">gdb</span></code> ）是從 <code class="docutils literal notranslate"><span class="pre">vmlinux</span></code> 文件中找出OOPS的確切
文件和行號的最佳方法。</p>
<p>在使用 <code class="docutils literal notranslate"><span class="pre">CONFIG_DEBUG_INFO</span></code> 編譯的內核上使用gdb效果最好。可通過運行以下命令
進行設置:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./scripts/config -d COMPILE_TEST -e DEBUG_KERNEL -e DEBUG_INFO
</pre></div>
</div>
<p>在用 <code class="docutils literal notranslate"><span class="pre">CONFIG_DEBUG_INFO</span></code> 編譯的內核上，你可以直接從OOPS複製EIP值:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>EIP:    0060:[&lt;c021e50e&gt;]    Not tainted VLI
</pre></div>
</div>
<p>並使用GDB來將其翻譯成可讀形式:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gdb vmlinux
(gdb) l *0xc021e50e
</pre></div>
</div>
<p>如果沒有啓用 <code class="docutils literal notranslate"><span class="pre">CONFIG_DEBUG_INFO</span></code> ，則使用OOPS的函數偏移:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>EIP is at vt_ioctl+0xda8/0x1482
</pre></div>
</div>
<p>並在啓用 <code class="docutils literal notranslate"><span class="pre">CONFIG_DEBUG_INFO</span></code> 的情況下重新編譯內核:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./scripts/config -d COMPILE_TEST -e DEBUG_KERNEL -e DEBUG_INFO
$ make vmlinux
$ gdb vmlinux
(gdb) l *vt_ioctl+0xda8
0x1888 is in vt_ioctl (drivers/tty/vt/vt_ioctl.c:293).
288   {
289           struct vc_data *vc = NULL;
290           int ret = 0;
291
292           console_lock();
293           if (VT_BUSY(vc_num))
294                   ret = -EBUSY;
295           else if (vc_num)
296                   vc = vc_deallocate(vc_num);
297           console_unlock();
</pre></div>
</div>
<p>或者若您想要更詳細的顯示:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(gdb) p vt_ioctl
$1 = {int (struct tty_struct *, unsigned int, unsigned long)} 0xae0 &lt;vt_ioctl&gt;
(gdb) l *0xae0+0xda8
</pre></div>
</div>
<p>您也可以使用對象文件作爲替代:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ make drivers/tty/
$ gdb drivers/tty/vt/vt_ioctl.o
(gdb) l *vt_ioctl+0xda8
</pre></div>
</div>
<p>如果你有調用跟蹤，類似:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Call Trace:
 [&lt;ffffffff8802c8e9&gt;] :jbd:log_wait_commit+0xa3/0xf5
 [&lt;ffffffff810482d9&gt;] autoremove_wake_function+0x0/0x2e
 [&lt;ffffffff8802770b&gt;] :jbd:journal_stop+0x1be/0x1ee
 ...
</pre></div>
</div>
<p>這表明問題可能在 :jbd: 模塊中。您可以在gdb中加載該模塊並列出相關代碼:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gdb fs/jbd/jbd.ko
(gdb) l *log_wait_commit+0xa3
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>您還可以對堆棧跟蹤處的任何函數調用執行相同的操作，例如:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[&lt;f80bc9ca&gt;] ? dvb_usb_adapter_frontend_exit+0x3a/0x70 [dvb_usb]
</pre></div>
</div>
<p>上述調用發生的位置可以通過以下方式看到:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gdb drivers/media/usb/dvb-usb/dvb-usb.o
(gdb) l *dvb_usb_adapter_frontend_exit+0x3a
</pre></div>
</div>
</div>
</section>
<section id="objdump">
<h3>objdump<a class="headerlink" href="#objdump" title="Permalink to this headline">¶</a></h3>
<p>要調試內核，請使用objdump並從崩潰輸出中查找十六進位偏移，以找到有效的代碼/匯
編行。如果沒有調試符號，您將看到所示例程的彙編程序代碼，但是如果內核有調試
符號，C代碼也將可見（調試符號可以在內核配置菜單的hacking項中啓用）。例如:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ objdump -r -S -l --disassemble net/dccp/ipv4.o
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>您需要處於內核樹的頂層以便此獲得您的C文件。</p>
</div>
<p>如果您無法訪問原始碼，仍然可以使用以下方法調試一些崩潰轉儲（如Dave Miller的
示例崩潰轉儲輸出所示）:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>EIP is at  +0x14/0x4c0
 ...
Code: 44 24 04 e8 6f 05 00 00 e9 e8 fe ff ff 8d 76 00 8d bc 27 00 00
00 00 55 57  56 53 81 ec bc 00 00 00 8b ac 24 d0 00 00 00 8b 5d 08
&lt;8b&gt; 83 3c 01 00 00 89 44  24 14 8b 45 28 85 c0 89 44 24 18 0f 85

Put the bytes into a &quot;foo.s&quot; file like this:

       .text
       .globl foo
foo:
       .byte  .... /* bytes from Code: part of OOPS dump */

Compile it with &quot;gcc -c -o foo.o foo.s&quot; then look at the output of
&quot;objdump --disassemble foo.o&quot;.

Output:

ip_queue_xmit:
    push       %ebp
    push       %edi
    push       %esi
    push       %ebx
    sub        $0xbc, %esp
    mov        0xd0(%esp), %ebp        ! %ebp = arg0 (skb)
    mov        0x8(%ebp), %ebx         ! %ebx = skb-&gt;sk
    mov        0x13c(%ebx), %eax       ! %eax = inet_sk(sk)-&gt;opt
</pre></div>
</div>
<p><cite>scripts/decodecode</cite> 文件可以用來自動完成大部分工作，這取決於正在調試的CPU
體系結構。</p>
</section>
</section>
<section id="id4">
<h2>報告缺陷<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>一旦你通過定位缺陷找到了其發生的地方，你可以嘗試自己修復它或者向上游報告它。</p>
<p>爲了向上游報告，您應該找出用於開發受影響代碼的郵件列表。這可以使用 <code class="docutils literal notranslate"><span class="pre">get_maintainer.pl</span></code> 。</p>
<p>例如，您在gspca的sonixj.c文件中發現一個缺陷，則可以通過以下方法找到它的維護者:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./scripts/get_maintainer.pl -f drivers/media/usb/gspca/sonixj.c
Hans Verkuil &lt;hverkuil@xs4all.nl&gt; (odd fixer:GSPCA USB WEBCAM DRIVER,commit_signer:1/1=100%)
Mauro Carvalho Chehab &lt;mchehab@kernel.org&gt; (maintainer:MEDIA INPUT INFRASTRUCTURE (V4L/DVB),commit_signer:1/1=100%)
Tejun Heo &lt;tj@kernel.org&gt; (commit_signer:1/1=100%)
Bhaktipriya Shridhar &lt;bhaktipriya96@gmail.com&gt; (commit_signer:1/1=100%,authored:1/1=100%,added_lines:4/4=100%,removed_lines:9/9=100%)
linux-media@vger.kernel.org (open list:GSPCA USB WEBCAM DRIVER)
linux-kernel@vger.kernel.org (open list)
</pre></div>
</div>
<p>請注意它將指出：</p>
<ul class="simple">
<li><p>最後接觸原始碼的開發人員（如果這是在git樹中完成的）。在上面的例子中是Tejun
和Bhaktipriya（在這個特定的案例中，沒有人真正參與這個文件的開發）；</p></li>
<li><p>驅動維護人員（Hans Verkuil）；</p></li>
<li><p>子系統維護人員（Mauro Carvalho Chehab）；</p></li>
<li><p>驅動程序和/或子系統郵件列表（<a class="reference external" href="mailto:linux-media&#37;&#52;&#48;vger&#46;kernel&#46;org">linux-media<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a>）；</p></li>
<li><p>Linux內核郵件列表（<a class="reference external" href="mailto:linux-kernel&#37;&#52;&#48;vger&#46;kernel&#46;org">linux-kernel<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a>）。</p></li>
</ul>
<p>通常，修復缺陷的最快方法是將它報告給用於開發相關代碼的郵件列表（linux-media
ML），抄送驅動程序維護者（Hans）。</p>
<p>如果你完全不知道該把報告寄給誰，且 <code class="docutils literal notranslate"><span class="pre">get_maintainer.pl</span></code> 也沒有提供任何有用
的信息，請發送到linux-<a class="reference external" href="mailto:kernel&#37;&#52;&#48;vger&#46;kernel&#46;org">kernel<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a>。</p>
<p>感謝您的幫助，這使Linux儘可能穩定:-)</p>
</section>
<section id="id5">
<h2>修復缺陷<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>如果你懂得編程，你不僅可以通過報告錯誤來幫助我們，還可以提供一個解決方案。
畢竟，開源就是分享你的工作，你不想因爲你的天才而被認可嗎？</p>
<p>如果你決定這樣做，請在制定解決方案後將其提交到上游。</p>
<p>請務必閱讀
<a class="reference internal" href="../../../process/submitting-patches.html#submittingpatches"><span class="std std-ref">Documentation/process/submitting-patches.rst</span></a> ，
以幫助您的代碼被接受。</p>
</section>
<hr class="docutils" />
<section id="klogd-oops">
<h2>用 <code class="docutils literal notranslate"><span class="pre">klogd</span></code> 進行Oops跟蹤的注意事項<a class="headerlink" href="#klogd-oops" title="Permalink to this headline">¶</a></h2>
<p>爲了幫助Linus和其他內核開發人員， <code class="docutils literal notranslate"><span class="pre">klogd</span></code> 對保護故障的處理提供了大量支持。
爲了完整支持地址解析，至少應該使用 <code class="docutils literal notranslate"><span class="pre">sysklogd</span></code> 包的1.3-pl3版本。</p>
<p>當發生保護故障時， <code class="docutils literal notranslate"><span class="pre">klogd</span></code> 守護進程會自動將內核日誌消息中的重要地址轉換爲
它們的等效符號。然後通過 <code class="docutils literal notranslate"><span class="pre">klogd</span></code> 使用的任何報告機制來轉發這個已翻譯的內核
消息。保護錯誤消息可以直接從消息文件中剪切出來並轉發給內核開發人員。</p>
<p><code class="docutils literal notranslate"><span class="pre">klogd</span></code> 執行兩種類型的地址解析，靜態翻譯和動態翻譯。靜態翻譯使用System.map
文件。爲了進行靜態轉換， <code class="docutils literal notranslate"><span class="pre">klogd</span></code> 守護進程必須能夠在守護進程初始化時找到系
統映射文件。有關 <code class="docutils literal notranslate"><span class="pre">klogd</span></code> 如何搜索映射文件的信息，請參見klogd手冊頁。</p>
<p>當使用內核可加載模塊時，動態地址轉換非常重要。由於內核模塊的內存是從內核的
動態內存池中分配的，因此無論是模塊的開頭還是模塊中的函數和符號都沒有固定的
位置。</p>
<p>內核支持系統調用，允許程序確定加載哪些模塊及其在內存中的位置。klogd守護進程
使用這些系統調用構建了一個符號表，可用於調試可加載內核模塊中發生的保護錯誤。</p>
<p>klogd至少會提供產生保護故障的模塊的名稱。如果可加載模塊的開發人員選擇從模塊
導出符號信息，則可能會有其他可用的符號信息。</p>
<p>由於內核模塊環境可以是動態的，因此當模塊環境發生變化時，必須有一種通知
<code class="docutils literal notranslate"><span class="pre">klogd</span></code> 守護進程的機制。有一些可用的命令行選項允許klogd向當前正在執行的守
護進程發出信號示意應該刷新符號信息。有關更多信息，請參閱 <code class="docutils literal notranslate"><span class="pre">klogd</span></code> 手冊頁。</p>
<p>sysklogd發行版附帶了一個補丁，它修改了 <code class="docutils literal notranslate"><span class="pre">modules-2.0.0</span></code> 包，以便在加載或
卸載模塊時自動向klogd發送信號。應用此補丁基本上可無縫支持調試內核可加載模塊
發生的保護故障。</p>
<p>以下是 <code class="docutils literal notranslate"><span class="pre">klogd</span></code> 處理的可加載模塊中的保護故障示例:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Aug 29 09:51:01 blizard kernel: Unable to handle kernel paging request at virtual address f15e97cc
Aug 29 09:51:01 blizard kernel: current-&gt;tss.cr3 = 0062d000, %cr3 = 0062d000
Aug 29 09:51:01 blizard kernel: *pde = 00000000
Aug 29 09:51:01 blizard kernel: Oops: 0002
Aug 29 09:51:01 blizard kernel: CPU:    0
Aug 29 09:51:01 blizard kernel: EIP:    0010:[oops:_oops+16/3868]
Aug 29 09:51:01 blizard kernel: EFLAGS: 00010212
Aug 29 09:51:01 blizard kernel: eax: 315e97cc   ebx: 003a6f80   ecx: 001be77b   edx: 00237c0c
Aug 29 09:51:01 blizard kernel: esi: 00000000   edi: bffffdb3   ebp: 00589f90   esp: 00589f8c
Aug 29 09:51:01 blizard kernel: ds: 0018   es: 0018   fs: 002b   gs: 002b   ss: 0018
Aug 29 09:51:01 blizard kernel: Process oops_test (pid: 3374, process nr: 21, stackpage=00589000)
Aug 29 09:51:01 blizard kernel: Stack: 315e97cc 00589f98 0100b0b4 bffffed4 0012e38e 00240c64 003a6f80 00000001
Aug 29 09:51:01 blizard kernel:        00000000 00237810 bfffff00 0010a7fa 00000003 00000001 00000000 bfffff00
Aug 29 09:51:01 blizard kernel:        bffffdb3 bffffed4 ffffffda 0000002b 0007002b 0000002b 0000002b 00000036
Aug 29 09:51:01 blizard kernel: Call Trace: [oops:_oops_ioctl+48/80] [_sys_ioctl+254/272] [_system_call+82/128]
Aug 29 09:51:01 blizard kernel: Code: c7 00 05 00 00 00 eb 08 90 90 90 90 90 90 90 90 89 ec 5d c3
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Dr. G.W. Wettstein           Oncology Research Div. Computing Facility
Roger Maris Cancer Center    INTERNET: greg@wind.rmcc.com
820 4th St. N.
Fargo, ND  58122
Phone: 701-234-7556
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">追蹤缺陷</a><ul>
<li><a class="reference internal" href="#id2">連結的模塊</a></li>
<li><a class="reference internal" href="#oops">Oops消息在哪？</a></li>
<li><a class="reference internal" href="#id3">找到缺陷位置</a><ul>
<li><a class="reference internal" href="#gdb">gdb</a></li>
<li><a class="reference internal" href="#objdump">objdump</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">報告缺陷</a></li>
<li><a class="reference internal" href="#id5">修復缺陷</a></li>
<li><a class="reference internal" href="#klogd-oops">用 <code class="docutils literal notranslate"><span class="pre">klogd</span></code> 進行Oops跟蹤的注意事項</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/translations/zh_TW/admin-guide/bug-hunting.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/translations/zh_TW/admin-guide/bug-hunting.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>