
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>La guida a PGP per manutentori del kernel &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Informazioni sui programmi di posta elettronica per Linux" href="email-clients.html" />
    <link rel="prev" title="Stile del codice per il kernel Linux" href="coding-style.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In caso di dubbi sulla correttezza del contenuto di questa traduzione,
l’unico riferimento valido è la documentazione ufficiale in inglese.
Per maggiori informazioni consultate le <a class="reference internal" href="../index.html#it-disclaimer"><span class="std std-ref">avvertenze</span></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Original</dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../process/maintainer-pgp-guide.html#pgpguide"><span class="std std-ref">Documentation/process/maintainer-pgp-guide.rst</span></a></p>
</dd>
<dt class="field-even">Translator</dt>
<dd class="field-even"><p>Alessia Mantegazza &lt;<a class="reference external" href="mailto:amantegazza&#37;&#52;&#48;vaga&#46;pv&#46;it">amantegazza<span>&#64;</span>vaga<span>&#46;</span>pv<span>&#46;</span>it</a>&gt;</p>
</dd>
</dl>
<section id="la-guida-a-pgp-per-manutentori-del-kernel">
<span id="it-pgpguide"></span><h1>La guida a PGP per manutentori del kernel<a class="headerlink" href="#la-guida-a-pgp-per-manutentori-del-kernel" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Konstantin Ryabitsev &lt;<a class="reference external" href="mailto:konstantin&#37;&#52;&#48;linuxfoundation&#46;org">konstantin<span>&#64;</span>linuxfoundation<span>&#46;</span>org</a>&gt;</p>
</dd>
</dl>
<p>Questo documento è destinato agli sviluppatori del kernel Linux, in particolar
modo ai manutentori. Contiene degli approfondimenti riguardo informazioni che
sono state affrontate in maniera più generale nella sezione
“<a class="reference external" href="https://github.com/lfit/itpol/blob/master/protecting-code-integrity.md">Protecting Code Integrity</a>” pubblicata dalla Linux Foundation.
Per approfondire alcuni argomenti trattati in questo documento è consigliato
leggere il documento sopraindicato</p>
<section id="il-ruolo-di-pgp-nello-sviluppo-del-kernel-linux">
<h2>Il ruolo di PGP nello sviluppo del kernel Linux<a class="headerlink" href="#il-ruolo-di-pgp-nello-sviluppo-del-kernel-linux" title="Permalink to this headline">¶</a></h2>
<p>PGP aiuta ad assicurare l’integrità del codice prodotto dalla comunità
di sviluppo del kernel e, in secondo luogo, stabilisce canali di comunicazione
affidabili tra sviluppatori attraverso lo scambio di email firmate con PGP.</p>
<p>Il codice sorgente del kernel Linux è disponibile principalmente in due
formati:</p>
<ul class="simple">
<li><p>repositori distribuiti di sorgenti (git)</p></li>
<li><p>rilasci periodici di istantanee (archivi tar)</p></li>
</ul>
<p>Sia i repositori git che gli archivi tar portano le firme PGP degli
sviluppatori che hanno creato i rilasci ufficiali del kernel. Queste firme
offrono una garanzia crittografica che le versioni scaricabili rese disponibili
via kernel.org, o altri portali, siano identiche a quelle che gli sviluppatori
hanno sul loro posto di lavoro. A tal scopo:</p>
<ul class="simple">
<li><p>i repositori git forniscono firme PGP per ogni tag</p></li>
<li><p>gli archivi tar hanno firme separate per ogni archivio</p></li>
</ul>
<section id="fidatevi-degli-sviluppatori-e-non-dell-infrastruttura">
<span id="it-devs-not-infra"></span><h3>Fidatevi degli sviluppatori e non dell’infrastruttura<a class="headerlink" href="#fidatevi-degli-sviluppatori-e-non-dell-infrastruttura" title="Permalink to this headline">¶</a></h3>
<p>Fin dal 2011, quando i sistemi di kernel.org furono compromessi, il principio
generale del progetto Kernel Archives è stato quello di assumere che qualsiasi
parte dell’infrastruttura possa essere compromessa in ogni momento. Per questa
ragione, gli amministratori hanno intrapreso deliberatemene dei passi per
enfatizzare che la fiducia debba risiedere sempre negli sviluppatori e mai nel
codice che gestisce l’infrastruttura, indipendentemente da quali che siano le
pratiche di sicurezza messe in atto.</p>
<p>Il principio sopra indicato è la ragione per la quale è necessaria questa
guida. Vogliamo essere sicuri che il riporre la fiducia negli sviluppatori
non sia fatto semplicemente per incolpare qualcun’altro per future falle di
sicurezza. L’obiettivo è quello di fornire una serie di linee guida che gli
sviluppatori possano seguire per creare un ambiente di lavoro sicuro e
salvaguardare le chiavi PGP usate nello stabilire l’integrità del kernel Linux
stesso.</p>
</section>
</section>
<section id="strumenti-pgp">
<span id="it-pgp-tools"></span><h2>Strumenti PGP<a class="headerlink" href="#strumenti-pgp" title="Permalink to this headline">¶</a></h2>
<section id="usare-gnupg-v2">
<h3>Usare GnuPG v2<a class="headerlink" href="#usare-gnupg-v2" title="Permalink to this headline">¶</a></h3>
<p>La vostra distribuzione potrebbe avere già installato GnuPG, dovete solo
verificare che stia utilizzando la versione 2.x e non la serie 1.4 –
molte distribuzioni forniscono entrambe, di base il comando ‘’gpg’’
invoca GnuPG v.1. Per controllate usate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --version | head -n1
</pre></div>
</div>
<p>Se visualizzate <code class="docutils literal notranslate"><span class="pre">gpg</span> <span class="pre">(GnuPG)</span> <span class="pre">1.4.x</span></code>, allora state usando GnuPG v.1.
Provate il comando <code class="docutils literal notranslate"><span class="pre">gpg2</span></code> (se non lo avete, potreste aver bisogno
di installare il pacchetto gnupg2):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg2 --version | head -n1
</pre></div>
</div>
<p>Se visualizzate  <code class="docutils literal notranslate"><span class="pre">gpg</span> <span class="pre">(GnuPG)</span> <span class="pre">2.x.x</span></code>, allora siete pronti a partire.
Questa guida assume che abbiate la versione 2.2.(o successiva) di GnuPG.
Se state usando la versione 2.0, alcuni dei comandi indicati qui non
funzioneranno, in questo caso considerate un aggiornamento all’ultima versione,
la 2.2. Versioni di gnupg-2.1.11 e successive dovrebbero essere compatibili
per gli obiettivi di questa guida.</p>
<p>Se avete entrambi i comandi: <code class="docutils literal notranslate"><span class="pre">gpg</span></code> e <code class="docutils literal notranslate"><span class="pre">gpg2</span></code>, assicuratevi di utilizzare
sempre la versione V2, e non quella vecchia. Per evitare errori potreste creare
un alias:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ alias gpg=gpg2
</pre></div>
</div>
<p>Potete mettere questa opzione nel vostro  <code class="docutils literal notranslate"><span class="pre">.bashrc</span></code> in modo da essere sicuri.</p>
<section id="configurare-le-opzioni-di-gpg-agent">
<h4>Configurare le opzioni di gpg-agent<a class="headerlink" href="#configurare-le-opzioni-di-gpg-agent" title="Permalink to this headline">¶</a></h4>
<p>L’agente GnuPG è uno strumento di aiuto che partirà automaticamente ogni volta
che userete il comando <code class="docutils literal notranslate"><span class="pre">gpg</span></code> e funzionerà in background con l’obiettivo di
individuare la passphrase. Ci sono due opzioni che dovreste conoscere
per personalizzare la scadenza della passphrase nella cache:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">default-cache-ttl</span></code> (secondi): Se usate ancora la stessa chiave prima
che il time-to-live termini, il conto alla rovescia si resetterà per un
altro periodo. Di base è di 600 (10 minuti).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max-cache-ttl</span></code> (secondi): indipendentemente da quanto sia recente l’ultimo
uso della chiave da quando avete inserito la passphrase, se il massimo
time-to-live è scaduto, dovrete reinserire nuovamente la passphrase.
Di base è di 30 minuti.</p></li>
</ul>
<p>Se ritenete entrambe questi valori di base troppo corti (o troppo lunghi),
potete creare il vostro file <code class="docutils literal notranslate"><span class="pre">~/.gnupg/gpg-agent.conf</span></code> ed impostare i vostri
valori:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># set to 30 minutes for regular ttl, and 2 hours for max ttl
default-cache-ttl 1800
max-cache-ttl 7200
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Non è più necessario far partire l’agente gpg manualmente all’inizio della
vostra sessione. Dovreste controllare i file rc per rimuovere tutto ciò che
riguarda vecchie le versioni di GnuPG, poiché potrebbero non svolgere più
bene il loro compito.</p>
</div>
</section>
<section id="impostare-un-refresh-con-cronjob">
<h4>Impostare un <em>refresh</em> con cronjob<a class="headerlink" href="#impostare-un-refresh-con-cronjob" title="Permalink to this headline">¶</a></h4>
<p>Potreste aver bisogno di rinfrescare regolarmente il vostro portachiavi in
modo aggiornare le chiavi pubbliche di altre persone, lavoro che è svolto
al meglio con un cronjob giornaliero:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@daily /usr/bin/gpg2 --refresh &gt;/dev/null 2&gt;&amp;1
</pre></div>
</div>
<p>Controllate il percorso assoluto del vostro comando <code class="docutils literal notranslate"><span class="pre">gpg</span></code> o <code class="docutils literal notranslate"><span class="pre">gpg2</span></code> e usate
il comando <code class="docutils literal notranslate"><span class="pre">gpg2</span></code> se per voi <code class="docutils literal notranslate"><span class="pre">gpg</span></code> corrisponde alla versione GnuPG v.1.</p>
</section>
</section>
</section>
<section id="proteggere-la-vostra-chiave-pgp-primaria">
<span id="it-master-key"></span><h2>Proteggere la vostra chiave PGP primaria<a class="headerlink" href="#proteggere-la-vostra-chiave-pgp-primaria" title="Permalink to this headline">¶</a></h2>
<p>Questa guida parte dal presupposto che abbiate già una chiave PGP che usate
per lo sviluppo del kernel Linux. Se non ne avete ancora una, date uno sguardo
al documento “<a class="reference external" href="https://github.com/lfit/itpol/blob/master/protecting-code-integrity.md">Protecting Code Integrity</a>” che abbiamo menzionato prima.</p>
<p>Dovreste inoltre creare una nuova chiave se quella attuale è inferiore a 2048
bit (RSA).</p>
<section id="chiave-principale-o-sottochiavi">
<h3>Chiave principale o sottochiavi<a class="headerlink" href="#chiave-principale-o-sottochiavi" title="Permalink to this headline">¶</a></h3>
<p>Le sottochiavi sono chiavi PGP totalmente indipendenti, e sono collegate alla
chiave principale attraverso firme certificate. È quindi importante
comprendere i seguenti punti:</p>
<ol class="arabic simple">
<li><p>Non ci sono differenze tecniche tra la chiave principale e la sottochiave.</p></li>
<li><p>In fesa di creazione, assegniamo limitazioni funzionali ad ogni chiave
assegnando capacità specifiche.</p></li>
<li><p>Una chiave PGP può avere 4 capacità:</p>
<ul class="simple">
<li><p><strong>[S]</strong> può essere usata per firmare</p></li>
<li><p><strong>[E]</strong> può essere usata per criptare</p></li>
<li><p><strong>[A]</strong> può essere usata per autenticare</p></li>
<li><p><strong>[C]</strong> può essere usata per certificare altre chiavi</p></li>
</ul>
</li>
<li><p>Una singola chiave può avere più capacità</p></li>
<li><p>Una sottochiave è completamente indipendente dalla chiave principale.
Un messaggio criptato con la sottochiave non può essere decrittato con
quella principale. Se perdete la vostra sottochiave privata, non può
essere rigenerata in nessun modo da quella principale.</p></li>
</ol>
<p>La chiave con capacità <strong>[C]</strong> (certify) è identificata come la chiave
principale perché è l’unica che può essere usata per indicare la relazione
con altre chiavi. Solo la chiave <strong>[C]</strong> può essere usata per:</p>
<ul class="simple">
<li><p>Aggiungere o revocare altre chiavi (sottochiavi) che hanno capacità S/E/A</p></li>
<li><p>Aggiungere, modificare o eliminare le identità (unids) associate alla chiave</p></li>
<li><p>Aggiungere o modificare la data di termine di sé stessa o di ogni sottochiave</p></li>
<li><p>Firmare le chiavi di altre persone a scopo di creare una rete di fiducia</p></li>
</ul>
<p>Di base, alla creazione di nuove chiavi, GnuPG genera quanto segue:</p>
<ul class="simple">
<li><p>Una chiave madre che porta sia la capacità di certificazione che quella
di firma (<strong>[SC]</strong>)</p></li>
<li><p>Una sottochiave separata con capacità di criptaggio (<strong>[E]</strong>)</p></li>
</ul>
<p>Se avete usato i parametri di base per generare la vostra chiave, quello
sarà il risultato. Potete verificarlo utilizzando <code class="docutils literal notranslate"><span class="pre">gpg</span> <span class="pre">--list-secret-keys</span></code>,
per esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sec   rsa2048 2018-01-23 [SC] [expires: 2020-01-23]
      000000000000000000000000AAAABBBBCCCCDDDD
uid           [ultimate] Alice Dev &lt;adev@kernel.org&gt;
ssb   rsa2048 2018-01-23 [E] [expires: 2020-01-23]
</pre></div>
</div>
<p>Qualsiasi chiave che abbia la capacità <strong>[C]</strong> è la vostra chiave madre,
indipendentemente da quali altre capacità potreste averle assegnato.</p>
<p>La lunga riga sotto la voce <code class="docutils literal notranslate"><span class="pre">sec</span></code> è la vostra impronta digitale –
negli esempi che seguono, quando vedere <code class="docutils literal notranslate"><span class="pre">[fpr]</span></code> ci si riferisce a questa
stringa di 40 caratteri.</p>
</section>
<section id="assicuratevi-che-la-vostra-passphrase-sia-forte">
<h3>Assicuratevi che la vostra passphrase sia forte<a class="headerlink" href="#assicuratevi-che-la-vostra-passphrase-sia-forte" title="Permalink to this headline">¶</a></h3>
<p>GnuPG utilizza le passphrases per criptare la vostra chiave privata prima
di salvarla sul disco. In questo modo, anche se il contenuto della vostra
cartella <code class="docutils literal notranslate"><span class="pre">.gnupg</span></code> venisse letto o trafugato nella sia interezza, gli
attaccanti non potrebbero comunque utilizzare le vostre chiavi private senza
aver prima ottenuto la passphrase per decriptarle.</p>
<p>È assolutamente essenziale che le vostre chiavi private siano protette da
una passphrase forte. Per impostarla o cambiarla, usate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --change-passphrase [fpr]
</pre></div>
</div>
</section>
<section id="create-una-sottochiave-di-firma-separata">
<h3>Create una sottochiave di firma separata<a class="headerlink" href="#create-una-sottochiave-di-firma-separata" title="Permalink to this headline">¶</a></h3>
<p>Il nostro obiettivo è di proteggere la chiave primaria spostandola su un
dispositivo sconnesso dalla rete, dunque se avete solo una chiave combinata
<strong>[SC]</strong> allora dovreste creare una sottochiave di firma separata:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --quick-add-key [fpr] ed25519 sign
</pre></div>
</div>
<p>Ricordate di informare il keyserver del vostro cambiamento, cosicché altri
possano ricevere la vostra nuova sottochiave:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --send-key [fpr]
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Supporto ECC in GnuPG
GnuPG 2.1 e successivi supportano pienamente <em>Elliptic Curve Cryptography</em>,
con la possibilità di combinare sottochiavi ECC con le tradizionali chiavi
primarie RSA. Il principale vantaggio della crittografia ECC è che è molto
più veloce da calcolare e crea firme più piccole se confrontate byte per
byte con le chiavi RSA a più di 2048 bit. A meno che non pensiate di
utilizzare un dispositivo smartcard che non supporta le operazioni ECC, vi
raccomandiamo ti creare sottochiavi di firma ECC per il vostro lavoro col
kernel.</p>
<p>Se per qualche ragione preferite rimanere con sottochiavi RSA, nel comando
precedente, sostituite “ed25519” con “rsa2048”. In aggiunta, se avete
intenzione di usare un dispositivo hardware che non supporta le chiavi
ED25519 ECC, come la Nitrokey Pro o la Yubikey, allora dovreste usare
“nistp256” al posto di “ed25519”.</p>
</div>
</section>
<section id="copia-di-riserva-della-chiave-primaria-per-gestire-il-recupero-da-disastro">
<h3>Copia di riserva della chiave primaria per gestire il recupero da disastro<a class="headerlink" href="#copia-di-riserva-della-chiave-primaria-per-gestire-il-recupero-da-disastro" title="Permalink to this headline">¶</a></h3>
<p>Maggiori sono le firme di altri sviluppatori che vengono applicate alla vostra,
maggiori saranno i motivi per avere una copia di riserva che non sia digitale,
al fine di effettuare un recupero da disastro.</p>
<p>Il modo migliore per creare una copia fisica della vostra chiave privata è
l’uso del programma <code class="docutils literal notranslate"><span class="pre">paperkey</span></code>. Consultate <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">paperkey</span></code> per maggiori
dettagli sul formato dell’output ed i suoi punti di forza rispetto ad altre
soluzioni. Paperkey dovrebbe essere già pacchettizzato per la maggior parte
delle distribuzioni.</p>
<p>Eseguite il seguente comando per creare una copia fisica di riserva della
vostra chiave privata:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --export-secret-key [fpr] | paperkey -o /tmp/key-backup.txt
</pre></div>
</div>
<p>Stampate il file (o fate un pipe direttamente verso lpr), poi prendete
una penna e scrivete la passphare sul margine del foglio.  <strong>Questo è
caldamente consigliato</strong> perché la copia cartacea è comunque criptata con
la passphrase, e se mai doveste cambiarla non vi ricorderete qual’era al
momento della creazione di quella copia – <em>garantito</em>.</p>
<p>Mettete la copia cartacea e la passphrase scritta a mano in una busta e
mettetela in un posto sicuro e ben protetto, preferibilmente fuori casa,
magari in una cassetta di sicurezza in banca.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Probabilmente la vostra stampante non è più quello stupido dispositivo
connesso alla porta parallela, ma dato che il suo output è comunque
criptato con la passphrase, eseguire la stampa in un sistema “cloud”
moderno dovrebbe essere comunque relativamente sicuro. Un’opzione potrebbe
essere quella di cambiare la passphrase della vostra chiave primaria
subito dopo aver finito con paperkey.</p>
</div>
</section>
<section id="copia-di-riserva-di-tutta-la-cartella-gnupg">
<h3>Copia di riserva di tutta la cartella GnuPG<a class="headerlink" href="#copia-di-riserva-di-tutta-la-cartella-gnupg" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>!!!Non saltate questo passo!!!</strong></p>
</div>
<p>Quando avete bisogno di recuperare le vostre chiavi PGP è importante avere
una copia di riserva pronta all’uso. Questo sta su un diverso piano di
prontezza rispetto al recupero da disastro che abbiamo risolto con
<code class="docutils literal notranslate"><span class="pre">paperkey</span></code>. Vi affiderete a queste copie esterne quando dovreste usare la
vostra chiave Certify – ovvero quando fate modifiche alle vostre chiavi o
firmate le chiavi di altre persone ad una conferenza o ad un gruppo d’incontro.</p>
<p>Incominciate con una piccola chiavetta di memoria USB (preferibilmente due)
che userete per le copie di riserva. Dovrete criptarle usando LUKS – fate
riferimento alla documentazione della vostra distribuzione per capire come
fare.</p>
<p>Per la passphrase di criptazione, potete usare la stessa della vostra chiave
primaria.</p>
<p>Una volta che il processo di criptazione è finito, reinserite il disco USB ed
assicurativi che venga montato correttamente. Copiate interamente la cartella
<code class="docutils literal notranslate"><span class="pre">.gnugp</span></code> nel disco criptato:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cp -a ~/.gnupg /media/disk/foo/gnupg-backup
</pre></div>
</div>
<p>Ora dovreste verificare che tutto continui a funzionare:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --homedir=/media/disk/foo/gnupg-backup --list-key [fpr]
</pre></div>
</div>
<p>Se non vedete errori, allora dovreste avere fatto tutto con successo.
Smontate il disco USB, etichettatelo per bene di modo da evitare di
distruggerne il contenuto non appena vi serve una chiavetta USB a caso, ed
infine mettetelo in un posto sicuro – ma non troppo lontano, perché vi servirà
di tanto in tanto per modificare le identità, aggiungere o revocare
sottochiavi, o firmare le chiavi di altre persone.</p>
</section>
<section id="togliete-la-chiave-primaria-dalla-vostra-home">
<h3>Togliete la chiave primaria dalla vostra home<a class="headerlink" href="#togliete-la-chiave-primaria-dalla-vostra-home" title="Permalink to this headline">¶</a></h3>
<p>I file che si trovano nella vostra cartella home non sono poi così ben protetti
come potreste pensare. Potrebbero essere letti o trafugati in diversi modi:</p>
<ul class="simple">
<li><p>accidentalmente quando fate una rapida copia della cartella home per
configurare una nuova postazione</p></li>
<li><p>da un amministratore di sistema negligente o malintenzionato</p></li>
<li><p>attraverso copie di riserva insicure</p></li>
<li><p>attraverso malware installato in alcune applicazioni (browser, lettori PDF,
eccetera)</p></li>
<li><p>attraverso coercizione quando attraversate confini internazionali</p></li>
</ul>
<p>Proteggere la vostra chiave con una buona passphare aiuta notevolmente a
ridurre i rischi elencati qui sopra, ma le passphrase possono essere scoperte
attraverso i keylogger, il shoulder-surfing, o altri modi. Per questi motivi,
nella configurazione si raccomanda di rimuove la chiave primaria dalla vostra
cartella home e la si archivia su un dispositivo disconnesso.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Per favore, fate riferimento alla sezione precedente e assicuratevi
di aver fatto una copia di riserva totale della cartella GnuPG. Quello
che stiamo per fare renderà la vostra chiave inutile se non avete delle
copie di riserva utilizzabili!</p>
</div>
<p>Per prima cosa, identificate il keygrip della vostra chiave primaria:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --with-keygrip --list-key [fpr]
</pre></div>
</div>
<p>L’output assomiglierà a questo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pub   rsa2048 2018-01-24 [SC] [expires: 2020-01-24]
      000000000000000000000000AAAABBBBCCCCDDDD
      Keygrip = 1111000000000000000000000000000000000000
uid           [ultimate] Alice Dev &lt;adev@kernel.org&gt;
sub   rsa2048 2018-01-24 [E] [expires: 2020-01-24]
      Keygrip = 2222000000000000000000000000000000000000
sub   ed25519 2018-01-24 [S]
      Keygrip = 3333000000000000000000000000000000000000
</pre></div>
</div>
<p>Trovate la voce keygrid che si trova sotto alla riga <code class="docutils literal notranslate"><span class="pre">pub</span></code> (appena sotto
all’impronta digitale della chiave primaria). Questo corrisponderà direttamente
ad un file nella cartella <code class="docutils literal notranslate"><span class="pre">~/.gnupg</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cd ~/.gnupg/private-keys-v1.d
$ ls
1111000000000000000000000000000000000000.key
2222000000000000000000000000000000000000.key
3333000000000000000000000000000000000000.key
</pre></div>
</div>
<p>Quello che dovrete fare è rimuovere il file .key che corrisponde al keygrip
della chiave primaria:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cd ~/.gnupg/private-keys-v1.d
$ rm 1111000000000000000000000000000000000000.key
</pre></div>
</div>
<p>Ora, se eseguite il comando <code class="docutils literal notranslate"><span class="pre">--list-secret-keys</span></code>, vedrete che la chiave
primaria non compare più (il simbolo <code class="docutils literal notranslate"><span class="pre">#</span></code> indica che non è disponibile):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --list-secret-keys
sec#  rsa2048 2018-01-24 [SC] [expires: 2020-01-24]
      000000000000000000000000AAAABBBBCCCCDDDD
uid           [ultimate] Alice Dev &lt;adev@kernel.org&gt;
ssb   rsa2048 2018-01-24 [E] [expires: 2020-01-24]
ssb   ed25519 2018-01-24 [S]
</pre></div>
</div>
<p>Dovreste rimuovere anche i file <code class="docutils literal notranslate"><span class="pre">secring.gpg</span></code> che si trovano nella cartella
<code class="docutils literal notranslate"><span class="pre">~/.gnupg</span></code>, in quanto rimasugli delle versioni precedenti di GnuPG.</p>
<section id="se-non-avete-la-cartella-private-keys-v1-d">
<h4>Se non avete la cartella “private-keys-v1.d”<a class="headerlink" href="#se-non-avete-la-cartella-private-keys-v1-d" title="Permalink to this headline">¶</a></h4>
<p>Se non avete la cartella <code class="docutils literal notranslate"><span class="pre">~/.gnupg/private-keys-v1.d</span></code>, allora le vostre
chiavi segrete sono ancora salvate nel vecchio file <code class="docutils literal notranslate"><span class="pre">secring.gpg</span></code> usato
da GnuPG v1. Effettuare una qualsiasi modifica alla vostra chiave, come
cambiare la passphare o aggiungere una sottochiave, dovrebbe convertire
automaticamente il vecchio formato <code class="docutils literal notranslate"><span class="pre">secring.gpg``nel</span> <span class="pre">nuovo</span>
<span class="pre">``private-keys-v1.d</span></code>.</p>
<p>Una volta che l’avete fatto, assicuratevi di rimuovere il file <code class="docutils literal notranslate"><span class="pre">secring.gpg</span></code>,
che continua a contenere la vostra chiave privata.</p>
</section>
</section>
</section>
<section id="spostare-le-sottochiavi-in-un-apposito-dispositivo-criptato">
<span id="it-smartcards"></span><h2>Spostare le sottochiavi in un apposito dispositivo criptato<a class="headerlink" href="#spostare-le-sottochiavi-in-un-apposito-dispositivo-criptato" title="Permalink to this headline">¶</a></h2>
<p>Nonostante la chiave primaria sia ora al riparo da occhi e mani indiscrete,
le sottochiavi si trovano ancora nella vostra cartella home. Chiunque riesca
a mettere le sue mani su quelle chiavi riuscirà a decriptare le vostre
comunicazioni o a falsificare le vostre firme (se conoscono la passphrase).
Inoltre, ogni volta che viene fatta un’operazione con GnuPG, le chiavi vengono
caricate nella memoria di sistema e potrebbero essere rubate con l’uso di
malware sofisticati (pensate a Meltdown e a Spectre).</p>
<p>Il miglior modo per proteggere le proprie chiave è di spostarle su un
dispositivo specializzato in grado di effettuare operazioni smartcard.</p>
<section id="i-benefici-di-una-smartcard">
<h3>I benefici di una smartcard<a class="headerlink" href="#i-benefici-di-una-smartcard" title="Permalink to this headline">¶</a></h3>
<p>Una smartcard contiene un chip crittografico che è capace di immagazzinare
le chiavi private ed effettuare operazioni crittografiche direttamente sulla
carta stessa. Dato che la chiave non lascia mai la smartcard, il sistema
operativo usato sul computer non sarà in grado di accedere alle chiavi.
Questo è molto diverso dai dischi USB criptati che abbiamo usato allo scopo di
avere una copia di riserva sicura – quando il dispositivo USB è connesso e
montato, il sistema operativo potrà accedere al contenuto delle chiavi private.</p>
<p>L’uso di un disco USB criptato non può sostituire le funzioni di un dispositivo
capace di operazioni di tipo smartcard.</p>
</section>
<section id="dispositivi-smartcard-disponibili">
<h3>Dispositivi smartcard disponibili<a class="headerlink" href="#dispositivi-smartcard-disponibili" title="Permalink to this headline">¶</a></h3>
<p>A meno che tutti i vostri computer dispongano di lettori smartcard, il modo
più semplice è equipaggiarsi di un dispositivo USB specializzato che
implementi le funzionalità delle smartcard.  Sul mercato ci sono diverse
soluzioni disponibili:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://shop.nitrokey.com/shop/product/nitrokey-start-6">Nitrokey Start</a>: è Open hardware e Free Software, è basata sul progetto
<a class="reference external" href="http://www.fsij.org/doc-gnuk/">GnuK</a> della FSIJ. Questo è uno dei pochi dispositivi a supportare le chiavi
ECC ED25519, ma offre meno funzionalità di sicurezza (come la resistenza
alla manomissione o alcuni attacchi ad un canale laterale).</p></li>
<li><p><a class="reference external" href="https://shop.nitrokey.com/shop/product/nitrokey-pro-2-3">Nitrokey Pro 2</a>: è simile alla Nitrokey Start, ma è più resistente alla
manomissione e offre più funzionalità di sicurezza. La Pro 2 supporta la
crittografia ECC (NISTP).</p></li>
<li><p><a class="reference external" href="https://www.yubico.com/product/yubikey-5-overview/">Yubikey 5</a>: l’hardware e il software sono proprietari, ma è più economica
della  Nitrokey Pro ed è venduta anche con porta USB-C il che è utile con i
computer portatili più recenti. In aggiunta, offre altre funzionalità di
sicurezza come FIDO, U2F, e ora supporta anche le chiavi ECC (NISTP)</p></li>
</ul>
<p><a class="reference external" href="https://lwn.net/Articles/736231/">Su LWN c’è una buona recensione</a> dei modelli elencati qui sopra e altri.
La scelta dipenderà dal costo, dalla disponibilità nella vostra area
geografica e vostre considerazioni sull’hardware aperto/proprietario.</p>
<p>Se volete usare chiavi ECC, la vostra migliore scelta sul mercato è la
Nitrokey Start.</p>
</section>
<section id="configurare-il-vostro-dispositivo-smartcard">
<h3>Configurare il vostro dispositivo smartcard<a class="headerlink" href="#configurare-il-vostro-dispositivo-smartcard" title="Permalink to this headline">¶</a></h3>
<p>Il vostro dispositivo smartcard dovrebbe iniziare a funzionare non appena
lo collegate ad un qualsiasi computer Linux moderno. Potete verificarlo
eseguendo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --card-status
</pre></div>
</div>
<p>Se vedete tutti i dettagli della smartcard, allora ci siamo. Sfortunatamente,
affrontare tutti i possibili motivi per cui le cose potrebbero non funzionare
non è lo scopo di questa guida. Se avete problemi nel far funzionare la carta
con GnuPG, cercate aiuto attraverso i soliti canali di supporto.</p>
<p>Per configurare la vostra smartcard, dato che non c’è una via facile dalla
riga di comando, dovrete usate il menu di GnuPG:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --card-edit
[...omitted...]
gpg/card&gt; admin
Admin commands are allowed
gpg/card&gt; passwd
</pre></div>
</div>
<p>Dovreste impostare il PIN dell’utente (1), quello dell’amministratore (3) e il
codice di reset (4). Assicuratevi di annotare e salvare questi codici in un
posto sicuro – specialmente il PIN dell’amministratore e il codice di reset
(che vi permetterà di azzerare completamente la smartcard).  Il PIN
dell’amministratore viene usato così raramente che è inevitabile dimenticarselo
se non lo si annota.</p>
<p>Tornando al nostro menu, potete impostare anche altri valori (come il nome,
il sesso, informazioni d’accesso, eccetera), ma non sono necessari e aggiunge
altre informazioni sulla carta che potrebbero trapelare in caso di smarrimento.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A dispetto del nome “PIN”, né il PIN utente né quello dell’amministratore
devono essere esclusivamente numerici.</p>
</div>
</section>
<section id="spostare-le-sottochiavi-sulla-smartcard">
<h3>Spostare le sottochiavi sulla smartcard<a class="headerlink" href="#spostare-le-sottochiavi-sulla-smartcard" title="Permalink to this headline">¶</a></h3>
<p>Uscite dal menu (usando “q”) e salverete tutte le modifiche. Poi, spostiamo
tutte le sottochiavi sulla smartcard. Per la maggior parte delle operazioni
vi serviranno sia la passphrase della chiave PGP che il PIN
dell’amministratore:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --edit-key [fpr]

Secret subkeys are available.

pub  rsa2048/AAAABBBBCCCCDDDD
     created: 2018-01-23  expires: 2020-01-23  usage: SC
     trust: ultimate      validity: ultimate
ssb  rsa2048/1111222233334444
     created: 2018-01-23  expires: never       usage: E
ssb  ed25519/5555666677778888
     created: 2017-12-07  expires: never       usage: S
[ultimate] (1). Alice Dev &lt;adev@kernel.org&gt;

gpg&gt;
</pre></div>
</div>
<p>Usando <code class="docutils literal notranslate"><span class="pre">--edit-key</span></code> si tornerà alla modalità menu e noterete che
la lista delle chiavi è leggermente diversa. Da questo momento in poi,
tutti i comandi saranno eseguiti nella modalità menu, come indicato
da <code class="docutils literal notranslate"><span class="pre">gpg&gt;</span></code>.</p>
<p>Per prima cosa, selezioniamo la chiave che verrà messa sulla carta –
potete farlo digitando <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">1</span></code> (è la prima della lista, la sottochiave
<strong>[E]</strong>):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gpg&gt; key 1
</pre></div>
</div>
<p>Nel’output dovreste vedere <code class="docutils literal notranslate"><span class="pre">ssb*</span></code> associato alla chiave <strong>[E]</strong>. Il simbolo
<code class="docutils literal notranslate"><span class="pre">*</span></code> indica che la chiave è stata “selezionata”. Funziona come un
interruttore, ovvero se scrivete nuovamente <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">1</span></code>, il simbolo <code class="docutils literal notranslate"><span class="pre">*</span></code> sparirà
e la chiave non sarà più selezionata.</p>
<p>Ora, spostiamo la chiave sulla smartcard:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gpg&gt; keytocard
Please select where to store the key:
   (2) Encryption key
Your selection? 2
</pre></div>
</div>
<p>Dato che è la nostra chiave  <strong>[E]</strong>, ha senso metterla nella sezione criptata.
Quando confermerete la selezione, vi verrà chiesta la passphrase della vostra
chiave PGP, e poi il PIN dell’amministratore. Se il comando ritorna senza
errori, allora la vostra chiave è stata spostata con successo.</p>
<p><strong>Importante</strong>: digitate nuovamente <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">1</span></code> per deselezionare la prima chiave
e selezionate la seconda chiave <strong>[S]</strong> con <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">2</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gpg&gt; key 1
gpg&gt; key 2
gpg&gt; keytocard
Please select where to store the key:
   (1) Signature key
   (3) Authentication key
Your selection? 1
</pre></div>
</div>
<p>Potete usare la chiave <strong>[S]</strong> sia per firmare che per autenticare, ma vogliamo
che sia nella sezione di firma, quindi scegliete (1). Ancora una volta, se il
comando ritorna senza errori, allora l’operazione è avvenuta con successo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gpg&gt; q
Save changes? (y/N) y
</pre></div>
</div>
<p>Salvando le modifiche cancellerete dalla vostra cartella home tutte le chiavi
che avete spostato sulla carta (ma questo non è un problema, perché abbiamo
fatto delle copie di sicurezza nel caso in cui dovessimo configurare una
nuova smartcard).</p>
<section id="verificare-che-le-chiavi-siano-state-spostate">
<h4>Verificare che le chiavi siano state spostate<a class="headerlink" href="#verificare-che-le-chiavi-siano-state-spostate" title="Permalink to this headline">¶</a></h4>
<p>Ora, se doveste usare l’opzione <code class="docutils literal notranslate"><span class="pre">--list-secret-keys</span></code>, vedrete una
sottile differenza nell’output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --list-secret-keys
sec#  rsa2048 2018-01-24 [SC] [expires: 2020-01-24]
      000000000000000000000000AAAABBBBCCCCDDDD
uid           [ultimate] Alice Dev &lt;adev@kernel.org&gt;
ssb&gt;  rsa2048 2018-01-24 [E] [expires: 2020-01-24]
ssb&gt;  ed25519 2018-01-24 [S]
</pre></div>
</div>
<p>Il simbolo <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> in <code class="docutils literal notranslate"><span class="pre">ssb&gt;</span></code> indica che la sottochiave è disponibile solo
nella smartcard. Se tornate nella vostra cartella delle chiavi segrete e
guardate al suo contenuto, noterete che i file <code class="docutils literal notranslate"><span class="pre">.key</span></code> sono stati sostituiti
con degli stub:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cd ~/.gnupg/private-keys-v1.d
$ strings *.key | grep &#39;private-key&#39;
</pre></div>
</div>
<p>Per indicare che i file sono solo degli stub e che in realtà il contenuto è
sulla smartcard, l’output dovrebbe mostrarvi <code class="docutils literal notranslate"><span class="pre">shadowed-private-key</span></code>.</p>
</section>
<section id="verificare-che-la-smartcard-funzioni">
<h4>Verificare che la smartcard funzioni<a class="headerlink" href="#verificare-che-la-smartcard-funzioni" title="Permalink to this headline">¶</a></h4>
<p>Per verificare che la smartcard funzioni come dovuto, potete creare
una firma:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo &quot;Hello world&quot; | gpg --clearsign &gt; /tmp/test.asc
$ gpg --verify /tmp/test.asc
</pre></div>
</div>
<p>Col primo comando dovrebbe chiedervi il PIN della smartcard, e poi dovrebbe
mostrare “Good signature” dopo l’esecuzione di <code class="docutils literal notranslate"><span class="pre">gpg</span> <span class="pre">--verify</span></code>.</p>
<p>Complimenti, siete riusciti a rendere estremamente difficile il furto della
vostra identità digitale di sviluppatore.</p>
</section>
</section>
<section id="altre-operazioni-possibili-con-gnupg">
<h3>Altre operazioni possibili con GnuPG<a class="headerlink" href="#altre-operazioni-possibili-con-gnupg" title="Permalink to this headline">¶</a></h3>
<p>Segue un breve accenno ad alcune delle operazioni più comuni che dovrete
fare con le vostre chiavi PGP.</p>
<section id="montare-il-disco-con-la-chiave-primaria">
<h4>Montare il disco con la chiave primaria<a class="headerlink" href="#montare-il-disco-con-la-chiave-primaria" title="Permalink to this headline">¶</a></h4>
<p>Vi servirà la vostra chiave principale per tutte le operazioni che seguiranno,
per cui per prima cosa dovrete accedere ai vostri backup e dire a GnuPG di
usarli:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ export GNUPGHOME=/media/disk/foo/gnupg-backup
$ gpg --list-secret-keys
</pre></div>
</div>
<p>Dovete assicurarvi di vedere <code class="docutils literal notranslate"><span class="pre">sec</span></code> e non <code class="docutils literal notranslate"><span class="pre">sec#</span></code> nell’output del programma
(il simbolo <code class="docutils literal notranslate"><span class="pre">#</span></code> significa che la chiave non è disponibile e che state ancora
utilizzando la vostra solita cartella di lavoro).</p>
</section>
<section id="estendere-la-data-di-scadenza-di-una-chiave">
<h4>Estendere la data di scadenza di una chiave<a class="headerlink" href="#estendere-la-data-di-scadenza-di-una-chiave" title="Permalink to this headline">¶</a></h4>
<p>La chiave principale ha una data di scadenza di 2 anni dal momento della sua
creazione. Questo per motivi di sicurezza e per rendere obsolete le chiavi
che, eventualmente, dovessero sparire dai keyserver.</p>
<p>Per estendere di un anno, dalla data odierna, la scadenza di una vostra chiave,
eseguite:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --quick-set-expire [fpr] 1y
</pre></div>
</div>
<p>Se per voi è più facile da memorizzare, potete anche utilizzare una data
specifica (per esempio, il vostro compleanno o capodanno):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --quick-set-expire [fpr] 2020-07-01
</pre></div>
</div>
<p>Ricordatevi di inviare l’aggiornamento ai keyserver:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --send-key [fpr]
</pre></div>
</div>
</section>
<section id="aggiornare-la-vostra-cartella-di-lavoro-dopo-ogni-modifica">
<h4>Aggiornare la vostra cartella di lavoro dopo ogni modifica<a class="headerlink" href="#aggiornare-la-vostra-cartella-di-lavoro-dopo-ogni-modifica" title="Permalink to this headline">¶</a></h4>
<p>Dopo aver fatto delle modifiche alle vostre chiavi usando uno spazio a parte,
dovreste importarle nella vostra cartella di lavoro abituale:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --export | gpg --homedir ~/.gnupg --import
$ unset GNUPGHOME
</pre></div>
</div>
</section>
</section>
</section>
<section id="usare-pgp-con-git">
<h2>Usare PGP con Git<a class="headerlink" href="#usare-pgp-con-git" title="Permalink to this headline">¶</a></h2>
<p>Una delle caratteristiche fondanti di Git è la sua natura decentralizzata –
una volta che il repositorio è stato clonato sul vostro sistema, avete la
storia completa del progetto, inclusi i suoi tag, i commit ed i rami. Tuttavia,
con i centinaia di repositori clonati che ci sono in giro, come si fa a
verificare che la loro copia di linux.git non è stata manomessa da qualcuno?</p>
<p>Oppure, cosa succede se viene scoperta una backdoor nel codice e la riga
“Autore” dice che sei stato tu, mentre tu sei abbastanza sicuro di
<a class="reference external" href="https://github.com/jayphelps/git-blame-someone-else">non averci niente a che fare</a>?</p>
<p>Per risolvere entrambi i problemi, Git ha introdotto l’integrazione con PGP.
I tag firmati dimostrano che il repositorio è integro assicurando che il suo
contenuto è lo stesso che si trova sulle macchine degli sviluppatori che hanno
creato il tag; mentre i commit firmati rendono praticamente impossibile
ad un malintenzionato di impersonarvi senza avere accesso alle vostre chiavi
PGP.</p>
<section id="configurare-git-per-usare-la-vostra-chiave-pgp">
<h3>Configurare git per usare la vostra chiave PGP<a class="headerlink" href="#configurare-git-per-usare-la-vostra-chiave-pgp" title="Permalink to this headline">¶</a></h3>
<p>Se avete solo una chiave segreta nel vostro portachiavi, allora non avete nulla
da fare in più dato che sarà la vostra chiave di base. Tuttavia, se doveste
avere più chiavi segrete, potete dire a git quale dovrebbe usare (<code class="docutils literal notranslate"><span class="pre">[fpg]</span></code>
è la vostra impronta digitale):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ git config --global user.signingKey [fpr]
</pre></div>
</div>
<p><strong>IMPORTANTE</strong>: se avete una comando dedicato per <code class="docutils literal notranslate"><span class="pre">gpg2</span></code>, allora dovreste
dire a git di usare sempre quello piuttosto che il vecchio comando <code class="docutils literal notranslate"><span class="pre">gpg</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ git config --global gpg.program gpg2
</pre></div>
</div>
</section>
<section id="come-firmare-i-tag">
<h3>Come firmare i tag<a class="headerlink" href="#come-firmare-i-tag" title="Permalink to this headline">¶</a></h3>
<p>Per creare un tag firmato, passate l’opzione <code class="docutils literal notranslate"><span class="pre">-s</span></code> al comando tag:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ git tag -s [tagname]
</pre></div>
</div>
<p>La nostra raccomandazione è quella di firmare sempre i tag git, perché
questo permette agli altri sviluppatori di verificare che il repositorio
git dal quale stanno prendendo il codice non è stato alterato intenzionalmente.</p>
<section id="come-verificare-i-tag-firmati">
<h4>Come verificare i tag firmati<a class="headerlink" href="#come-verificare-i-tag-firmati" title="Permalink to this headline">¶</a></h4>
<p>Per verificare un tag firmato, potete usare il comando <code class="docutils literal notranslate"><span class="pre">verify-tag</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ git verify-tag [tagname]
</pre></div>
</div>
<p>Se state prendendo un tag da un fork del repositorio del progetto, git
dovrebbe verificare automaticamente la firma di quello che state prendendo
e vi mostrerà il risultato durante l’operazione di merge:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ git pull [url] tags/sometag
</pre></div>
</div>
<p>Il merge conterrà qualcosa di simile:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Merge tag &#39;sometag&#39; of [url]

[Tag message]

# gpg: Signature made [...]
# gpg: Good signature from [...]
</pre></div>
</div>
<p>Se state verificando il tag di qualcun altro, allora dovrete importare
la loro chiave PGP. Fate riferimento alla sezione “<a class="reference internal" href="#it-verify-identities"><span class="std std-ref">Come verificare l’identità degli sviluppatori del kernel</span></a>”
che troverete più avanti.</p>
</section>
<section id="configurare-git-per-firmare-sempre-i-tag-con-annotazione">
<h4>Configurare git per firmare sempre i tag con annotazione<a class="headerlink" href="#configurare-git-per-firmare-sempre-i-tag-con-annotazione" title="Permalink to this headline">¶</a></h4>
<p>Se state creando un tag con annotazione è molto probabile che vogliate
firmarlo. Per imporre a git di firmare sempre un tag con annotazione,
dovete impostare la seguente opzione globale:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ git config --global tag.forceSignAnnotated true
</pre></div>
</div>
</section>
</section>
<section id="come-usare-commit-firmati">
<h3>Come usare commit firmati<a class="headerlink" href="#come-usare-commit-firmati" title="Permalink to this headline">¶</a></h3>
<p>Creare dei commit firmati è facile, ma è molto più difficile utilizzarli
nello sviluppo del kernel linux per via del fatto che ci si affida alle
liste di discussione e questo modo di procedere non mantiene le firme PGP
nei commit. In aggiunta, quando si usa <em>rebase</em> nel proprio repositorio
locale per allinearsi al kernel anche le proprie firme PGP verranno scartate.
Per questo motivo, la maggior parte degli sviluppatori del kernel non si
preoccupano troppo di firmare i propri commit ed ignoreranno quelli firmati
che si trovano in altri repositori usati per il proprio lavoro.</p>
<p>Tuttavia, se avete il vostro repositorio di lavoro disponibile al pubblico
su un qualche servizio di hosting git (kernel.org, infradead.org, ozlabs.org,
o altri), allora la raccomandazione è di firmare tutti i vostri commit
anche se gli sviluppatori non ne beneficeranno direttamente.</p>
<p>Vi raccomandiamo di farlo per i seguenti motivi:</p>
<ol class="arabic simple">
<li><p>Se dovesse mai esserci la necessità di fare delle analisi forensi o
tracciare la provenienza di un codice, anche sorgenti mantenuti
esternamente che hanno firme PGP sui commit avranno un certo valore a
questo scopo.</p></li>
<li><p>Se dovesse mai capitarvi di clonare il vostro repositorio locale (per
esempio dopo un danneggiamento del disco), la firma vi permetterà di
verificare l’integrità del repositorio prima di riprendere il lavoro.</p></li>
<li><p>Se qualcuno volesse usare <em>cherry-pick</em> sui vostri commit, allora la firma
permetterà di verificare l’integrità dei commit prima di applicarli.</p></li>
</ol>
<section id="creare-commit-firmati">
<h4>Creare commit firmati<a class="headerlink" href="#creare-commit-firmati" title="Permalink to this headline">¶</a></h4>
<p>Per creare un commit firmato, dovete solamente aggiungere l’opzione <code class="docutils literal notranslate"><span class="pre">-S</span></code>
al comando <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">commit</span></code> (si usa la lettera maiuscola per evitare
conflitti con un’altra opzione):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ git commit -S
</pre></div>
</div>
</section>
<section id="configurare-git-per-firmare-sempre-i-commit">
<h4>Configurare git per firmare sempre i commit<a class="headerlink" href="#configurare-git-per-firmare-sempre-i-commit" title="Permalink to this headline">¶</a></h4>
<p>Potete dire a git di firmare sempre i commit:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>git config --global commit.gpgSign true
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Assicuratevi di aver configurato <code class="docutils literal notranslate"><span class="pre">gpg-agent</span></code> prima di abilitare
questa opzione.</p>
</div>
</section>
</section>
</section>
<section id="come-verificare-l-identita-degli-sviluppatori-del-kernel">
<span id="it-verify-identities"></span><h2>Come verificare l’identità degli sviluppatori del kernel<a class="headerlink" href="#come-verificare-l-identita-degli-sviluppatori-del-kernel" title="Permalink to this headline">¶</a></h2>
<p>Firmare i tag e i commit è facile, ma come si fa a verificare che la chiave
usata per firmare qualcosa appartenga davvero allo sviluppatore e non ad un
impostore?</p>
<section id="configurare-l-auto-key-retrieval-usando-wkd-e-dane">
<h3>Configurare l’auto-key-retrieval usando WKD e DANE<a class="headerlink" href="#configurare-l-auto-key-retrieval-usando-wkd-e-dane" title="Permalink to this headline">¶</a></h3>
<p>Se non siete ancora in possesso di una vasta collezione di chiavi pubbliche
di altri sviluppatori, allora potreste iniziare il vostro portachiavi
affidandovi ai servizi di auto-scoperta e auto-recupero. GnuPG può affidarsi
ad altre tecnologie di delega della fiducia, come DNSSEC e TLS, per sostenervi
nel caso in cui iniziare una propria rete di fiducia da zero sia troppo
scoraggiante.</p>
<p>Aggiungete il seguente testo al vostro file <code class="docutils literal notranslate"><span class="pre">~/.gnupg/gpg.conf</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>auto-key-locate wkd,dane,local
auto-key-retrieve
</pre></div>
</div>
<p>La <em>DNS-Based Authentication of Named Entities</em> (“DANE”) è un metodo
per la pubblicazione di chiavi pubbliche su DNS e per renderle sicure usando
zone firmate con DNSSEC. Il <em>Web Key Directory</em> (“WKD”) è un metodo
alternativo che usa https a scopo di ricerca. Quando si usano DANE o WKD
per la ricerca di chiavi pubbliche, GnuPG validerà i certificati DNSSEC o TLS
prima di aggiungere al vostro portachiavi locale le eventuali chiavi trovate.</p>
<p>Kernel.org pubblica la WKD per tutti gli sviluppatori che hanno un account
kernel.org. Una volta che avete applicato le modifiche al file <code class="docutils literal notranslate"><span class="pre">gpg.conf</span></code>,
potrete auto-recuperare le chiavi di Linus Torvalds e Greg Kroah-Hartman
(se non le avete già):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --locate-keys torvalds@kernel.org gregkh@kernel.org
</pre></div>
</div>
<p>Se avete un account kernel.org, al fine di rendere più utile l’uso di WKD
da parte di altri sviluppatori del kernel, dovreste <a class="reference external" href="https://korg.wiki.kernel.org/userdoc/mail#adding_a_kernelorg_uid_to_your_pgp_key">aggiungere alla vostra
chiave lo UID di kernel.org</a>.</p>
</section>
<section id="web-of-trust-wot-o-trust-on-first-use-tofu">
<h3>Web of Trust (WOT) o Trust on First Use (TOFU)<a class="headerlink" href="#web-of-trust-wot-o-trust-on-first-use-tofu" title="Permalink to this headline">¶</a></h3>
<p>PGP incorpora un meccanismo di delega della fiducia conosciuto come
“Web of Trust”. Di base, questo è un tentativo di sostituire la necessità
di un’autorità certificativa centralizzata tipica del mondo HTTPS/TLS.
Invece di avere svariati produttori software che decidono chi dovrebbero
essere le entità di certificazione di cui dovreste fidarvi, PGP lascia
la responsabilità ad ogni singolo utente.</p>
<p>Sfortunatamente, solo poche persone capiscono come funziona la rete di fiducia.
Nonostante sia un importante aspetto della specifica OpenPGP, recentemente
le versioni di GnuPG (2.2 e successive) hanno implementato un meccanisco
alternativo chiamato “Trust on First Use” (TOFU). Potete pensare a TOFU come
“ad un approccio all fidicia simile ad SSH”. In SSH, la prima volta che vi
connettete ad un sistema remoto, l’impronta digitale della chiave viene
registrata e ricordata. Se la chiave dovesse cambiare in futuro, il programma
SSH vi avviserà e si rifiuterà di connettersi, obbligandovi a prendere una
decisione circa la fiducia che riponete nella nuova chiave. In modo simile,
la prima volta che importate la chiave PGP di qualcuno, si assume sia valida.
Se ad un certo punto GnuPG trova un’altra chiave con la stessa identità,
entrambe, la vecchia e la nuova, verranno segnate come invalide e dovrete
verificare manualmente quale tenere.</p>
<p>Vi raccomandiamo di usare il meccanisco TOFU+PGP (che è la nuova configurazione
di base di GnuPG v2). Per farlo, aggiungete (o modificate) l’impostazione
<code class="docutils literal notranslate"><span class="pre">trust-model</span></code> in <code class="docutils literal notranslate"><span class="pre">~/.gnupg/gpg.conf</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>trust-model tofu+pgp
</pre></div>
</div>
</section>
<section id="come-usare-i-keyserver-in-sicurezza">
<h3>Come usare i keyserver in sicurezza<a class="headerlink" href="#come-usare-i-keyserver-in-sicurezza" title="Permalink to this headline">¶</a></h3>
<p>Se ottenete l’errore “No public key” quando cercate di validate il tag di
qualcuno, allora dovreste cercare quella chiave usando un keyserver. È
importante tenere bene a mente che non c’è alcuna garanzia che la chiave
che avete recuperato da un keyserver PGP appartenga davvero alla persona
reale – è progettato così. Dovreste usare il Web of Trust per assicurarvi
che la chiave sia valida.</p>
<p>Come mantenere il Web of Trust va oltre gli scopi di questo documento,
semplicemente perché farlo come si deve richiede sia sforzi che perseveranza
che tendono ad andare oltre al livello di interesse della maggior parte degli
esseri umani. Qui di seguito alcuni rapidi suggerimenti per aiutarvi a ridurre
il rischio di importare chiavi maligne.</p>
<p>Primo, diciamo che avete provato ad eseguire <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">verify-tag</span></code> ma restituisce
un errore dicendo che la chiave non è stata trovata:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ git verify-tag sunxi-fixes-for-4.15-2
gpg: Signature made Sun 07 Jan 2018 10:51:55 PM EST
gpg:                using RSA key DA73759BF8619E484E5A3B47389A54219C0F2430
gpg:                issuer &quot;wens@...org&quot;
gpg: Can&#39;t check signature: No public key
</pre></div>
</div>
<p>Cerchiamo nel keyserver per maggiori informazioni sull’impronta digitale
della chiave (l’impronta digitale, probabilmente, appartiene ad una
sottochiave, dunque non possiamo usarla direttamente senza trovare prima
l’ID della chiave primaria associata ad essa):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --search DA73759BF8619E484E5A3B47389A54219C0F2430
gpg: data source: hkp://keys.gnupg.net
(1) Chen-Yu Tsai &lt;wens@...org&gt;
      4096 bit RSA key C94035C21B4F2AEB, created: 2017-03-14, expires: 2019-03-15
Keys 1-1 of 1 for &quot;DA73759BF8619E484E5A3B47389A54219C0F2430&quot;.  Enter number(s), N)ext, or Q)uit &gt; q
</pre></div>
</div>
<p>Localizzate l’ID della chiave primaria, nel nostro esempio
<code class="docutils literal notranslate"><span class="pre">C94035C21B4F2AEB</span></code>. Ora visualizzate le chiavi di Linus Torvalds
che avete nel vostro portachiavi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --list-key torvalds@kernel.org
pub   rsa2048 2011-09-20 [SC]
      ABAF11C65A2970B130ABE3C479BE3E4300411886
uid           [ unknown] Linus Torvalds &lt;torvalds@kernel.org&gt;
sub   rsa2048 2011-09-20 [E]
</pre></div>
</div>
<p>Poi, cercate un percorso affidabile da Linux Torvalds alla chiave che avete
trovato con <code class="docutils literal notranslate"><span class="pre">gpg</span> <span class="pre">--search</span></code> usando la chiave sconosciuta.Per farlo potete usare
diversi strumenti come <a class="reference external" href="https://github.com/mricon/wotmate">https://github.com/mricon/wotmate</a>,
<a class="reference external" href="https://git.kernel.org/pub/scm/docs/kernel/pgpkeys.git/tree/graphs">https://git.kernel.org/pub/scm/docs/kernel/pgpkeys.git/tree/graphs</a>, e
<a class="reference external" href="https://the.earth.li/~noodles/pathfind.html">https://the.earth.li/~noodles/pathfind.html</a>.</p>
<p>Se trovate un paio di percorsi affidabili è un buon segno circa la validità
della chiave. Ora, potete aggiungerla al vostro portachiavi dal keyserver:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gpg --recv-key C94035C21B4F2AEB
</pre></div>
</div>
<p>Questa procedura non è perfetta, e ovviamente state riponendo la vostra
fiducia nell’amministratore del servizio <em>PGP Pathfinder</em> sperando che non
sia malintenzionato (infatti, questo va contro <a class="reference internal" href="#it-devs-not-infra"><span class="std std-ref">Fidatevi degli sviluppatori e non dell’infrastruttura</span></a>).
Tuttavia, se mantenete con cura la vostra rete di fiducia sarà un deciso
miglioramento rispetto alla cieca fiducia nei keyserver.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">La guida a PGP per manutentori del kernel</a><ul>
<li><a class="reference internal" href="#il-ruolo-di-pgp-nello-sviluppo-del-kernel-linux">Il ruolo di PGP nello sviluppo del kernel Linux</a><ul>
<li><a class="reference internal" href="#fidatevi-degli-sviluppatori-e-non-dell-infrastruttura">Fidatevi degli sviluppatori e non dell’infrastruttura</a></li>
</ul>
</li>
<li><a class="reference internal" href="#strumenti-pgp">Strumenti PGP</a><ul>
<li><a class="reference internal" href="#usare-gnupg-v2">Usare GnuPG v2</a><ul>
<li><a class="reference internal" href="#configurare-le-opzioni-di-gpg-agent">Configurare le opzioni di gpg-agent</a></li>
<li><a class="reference internal" href="#impostare-un-refresh-con-cronjob">Impostare un <em>refresh</em> con cronjob</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#proteggere-la-vostra-chiave-pgp-primaria">Proteggere la vostra chiave PGP primaria</a><ul>
<li><a class="reference internal" href="#chiave-principale-o-sottochiavi">Chiave principale o sottochiavi</a></li>
<li><a class="reference internal" href="#assicuratevi-che-la-vostra-passphrase-sia-forte">Assicuratevi che la vostra passphrase sia forte</a></li>
<li><a class="reference internal" href="#create-una-sottochiave-di-firma-separata">Create una sottochiave di firma separata</a></li>
<li><a class="reference internal" href="#copia-di-riserva-della-chiave-primaria-per-gestire-il-recupero-da-disastro">Copia di riserva della chiave primaria per gestire il recupero da disastro</a></li>
<li><a class="reference internal" href="#copia-di-riserva-di-tutta-la-cartella-gnupg">Copia di riserva di tutta la cartella GnuPG</a></li>
<li><a class="reference internal" href="#togliete-la-chiave-primaria-dalla-vostra-home">Togliete la chiave primaria dalla vostra home</a><ul>
<li><a class="reference internal" href="#se-non-avete-la-cartella-private-keys-v1-d">Se non avete la cartella “private-keys-v1.d”</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#spostare-le-sottochiavi-in-un-apposito-dispositivo-criptato">Spostare le sottochiavi in un apposito dispositivo criptato</a><ul>
<li><a class="reference internal" href="#i-benefici-di-una-smartcard">I benefici di una smartcard</a></li>
<li><a class="reference internal" href="#dispositivi-smartcard-disponibili">Dispositivi smartcard disponibili</a></li>
<li><a class="reference internal" href="#configurare-il-vostro-dispositivo-smartcard">Configurare il vostro dispositivo smartcard</a></li>
<li><a class="reference internal" href="#spostare-le-sottochiavi-sulla-smartcard">Spostare le sottochiavi sulla smartcard</a><ul>
<li><a class="reference internal" href="#verificare-che-le-chiavi-siano-state-spostate">Verificare che le chiavi siano state spostate</a></li>
<li><a class="reference internal" href="#verificare-che-la-smartcard-funzioni">Verificare che la smartcard funzioni</a></li>
</ul>
</li>
<li><a class="reference internal" href="#altre-operazioni-possibili-con-gnupg">Altre operazioni possibili con GnuPG</a><ul>
<li><a class="reference internal" href="#montare-il-disco-con-la-chiave-primaria">Montare il disco con la chiave primaria</a></li>
<li><a class="reference internal" href="#estendere-la-data-di-scadenza-di-una-chiave">Estendere la data di scadenza di una chiave</a></li>
<li><a class="reference internal" href="#aggiornare-la-vostra-cartella-di-lavoro-dopo-ogni-modifica">Aggiornare la vostra cartella di lavoro dopo ogni modifica</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#usare-pgp-con-git">Usare PGP con Git</a><ul>
<li><a class="reference internal" href="#configurare-git-per-usare-la-vostra-chiave-pgp">Configurare git per usare la vostra chiave PGP</a></li>
<li><a class="reference internal" href="#come-firmare-i-tag">Come firmare i tag</a><ul>
<li><a class="reference internal" href="#come-verificare-i-tag-firmati">Come verificare i tag firmati</a></li>
<li><a class="reference internal" href="#configurare-git-per-firmare-sempre-i-tag-con-annotazione">Configurare git per firmare sempre i tag con annotazione</a></li>
</ul>
</li>
<li><a class="reference internal" href="#come-usare-commit-firmati">Come usare commit firmati</a><ul>
<li><a class="reference internal" href="#creare-commit-firmati">Creare commit firmati</a></li>
<li><a class="reference internal" href="#configurare-git-per-firmare-sempre-i-commit">Configurare git per firmare sempre i commit</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#come-verificare-l-identita-degli-sviluppatori-del-kernel">Come verificare l’identità degli sviluppatori del kernel</a><ul>
<li><a class="reference internal" href="#configurare-l-auto-key-retrieval-usando-wkd-e-dane">Configurare l’auto-key-retrieval usando WKD e DANE</a></li>
<li><a class="reference internal" href="#web-of-trust-wot-o-trust-on-first-use-tofu">Web of Trust (WOT) o Trust on First Use (TOFU)</a></li>
<li><a class="reference internal" href="#come-usare-i-keyserver-in-sicurezza">Come usare i keyserver in sicurezza</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/translations/it_IT/process/maintainer-pgp-guide.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/translations/it_IT/process/maintainer-pgp-guide.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>