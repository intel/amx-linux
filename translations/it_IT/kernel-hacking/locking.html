
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>L’inaffidabile guida alla sincronizzazione &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Documentazione dell’API di base" href="../core-api/index.html" />
    <link rel="prev" title="L’inaffidabile guida all’hacking del kernel Linux" href="hacking.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In caso di dubbi sulla correttezza del contenuto di questa traduzione,
l’unico riferimento valido è la documentazione ufficiale in inglese.
Per maggiori informazioni consultate le <a class="reference internal" href="../index.html#it-disclaimer"><span class="std std-ref">avvertenze</span></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Original</dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../kernel-hacking/locking.html#kernel-hacking-lock"><span class="std std-ref">Documentation/kernel-hacking/locking.rst</span></a></p>
</dd>
<dt class="field-even">Translator</dt>
<dd class="field-even"><p>Federico Vaga &lt;<a class="reference external" href="mailto:federico&#46;vaga&#37;&#52;&#48;vaga&#46;pv&#46;it">federico<span>&#46;</span>vaga<span>&#64;</span>vaga<span>&#46;</span>pv<span>&#46;</span>it</a>&gt;</p>
</dd>
</dl>
<section id="l-inaffidabile-guida-alla-sincronizzazione">
<span id="it-kernel-hacking-lock"></span><h1>L’inaffidabile guida alla sincronizzazione<a class="headerlink" href="#l-inaffidabile-guida-alla-sincronizzazione" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Rusty Russell</p>
</dd>
</dl>
<section id="introduzione">
<h2>Introduzione<a class="headerlink" href="#introduzione" title="Permalink to this headline">¶</a></h2>
<p>Benvenuto, alla notevole ed inaffidabile guida ai problemi di sincronizzazione
(locking) nel kernel. Questo documento descrive il sistema di sincronizzazione
nel kernel Linux 2.6.</p>
<p>Dato il largo utilizzo del multi-threading e della prelazione nel kernel
Linux, chiunque voglia dilettarsi col kernel deve conoscere i concetti
fondamentali della concorrenza e della sincronizzazione nei sistemi
multi-processore.</p>
</section>
<section id="il-problema-con-la-concorrenza">
<h2>Il problema con la concorrenza<a class="headerlink" href="#il-problema-con-la-concorrenza" title="Permalink to this headline">¶</a></h2>
<p>(Saltatelo se sapete già cos’è una corsa critica).</p>
<p>In un normale programma, potete incrementare un contatore nel seguente modo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>contatore++;
</pre></div>
</div>
<p>Questo è quello che vi aspettereste che accada sempre:</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Risultati attesi</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Istanza 1</p></th>
<th class="head"><p>Istanza 2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>leggi contatore (5)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>aggiungi 1 (6)</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>scrivi contatore (6)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>leggi contatore (6)</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>aggiungi 1 (7)</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>scrivi contatore (7)</p></td>
</tr>
</tbody>
</table>
<p>Questo è quello che potrebbe succedere in realtà:</p>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">Possibile risultato</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Istanza 1</p></th>
<th class="head"><p>Istanza 2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>leggi contatore (5)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>leggi contatore (5)</p></td>
</tr>
<tr class="row-even"><td><p>aggiungi 1 (6)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>aggiungi 1 (6)</p></td>
</tr>
<tr class="row-even"><td><p>scrivi contatore (6)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>scrivi contatore (6)</p></td>
</tr>
</tbody>
</table>
<section id="corse-critiche-e-sezioni-critiche">
<h3>Corse critiche e sezioni critiche<a class="headerlink" href="#corse-critiche-e-sezioni-critiche" title="Permalink to this headline">¶</a></h3>
<p>Questa sovrapposizione, ovvero quando un risultato dipende dal tempo che
intercorre fra processi diversi, è chiamata corsa critica. La porzione
di codice che contiene questo problema è chiamata sezione critica.
In particolar modo da quando Linux ha incominciato a girare su
macchine multi-processore, le sezioni critiche sono diventate uno dei
maggiori problemi di progettazione ed implementazione del kernel.</p>
<p>La prelazione può sortire gli stessi effetti, anche se c’è una sola CPU:
interrompendo un processo nella sua sezione critica otterremo comunque
la stessa corsa critica. In questo caso, il thread che si avvicenda
nell’esecuzione potrebbe eseguire anch’esso la sezione critica.</p>
<p>La soluzione è quella di riconoscere quando avvengono questi accessi
simultanei, ed utilizzare i <em>lock</em> per accertarsi che solo un’istanza
per volta possa entrare nella sezione critica. Il kernel offre delle buone
funzioni a questo scopo. E poi ci sono quelle meno buone, ma farò finta
che non esistano.</p>
</section>
</section>
<section id="sincronizzazione-nel-kernel-linux">
<h2>Sincronizzazione nel kernel Linux<a class="headerlink" href="#sincronizzazione-nel-kernel-linux" title="Permalink to this headline">¶</a></h2>
<p>Se dovessi darvi un suggerimento sulla sincronizzazione: <strong>mantenetela
semplice</strong>.</p>
<p>Siate riluttanti nell’introduzione di nuovi <em>lock</em>.</p>
<section id="i-due-principali-tipi-di-lock-nel-kernel-spinlock-e-mutex">
<h3>I due principali tipi di <em>lock</em> nel kernel: spinlock e mutex<a class="headerlink" href="#i-due-principali-tipi-di-lock-nel-kernel-spinlock-e-mutex" title="Permalink to this headline">¶</a></h3>
<p>Ci sono due tipi principali di <em>lock</em> nel kernel. Il tipo fondamentale è lo
spinlock (<code class="docutils literal notranslate"><span class="pre">include/asm/spinlock.h</span></code>), un semplice <em>lock</em> che può essere
trattenuto solo da un processo: se non si può trattenere lo spinlock, allora
rimane in attesa attiva (in inglese <em>spinning</em>) finché non ci riesce.
Gli spinlock sono molto piccoli e rapidi, possono essere utilizzati ovunque.</p>
<p>Il secondo tipo è il mutex (<code class="docutils literal notranslate"><span class="pre">include/linux/mutex.h</span></code>): è come uno spinlock,
ma potreste bloccarvi trattenendolo. Se non potete trattenere un mutex
il vostro processo si auto-sospenderà; verrà riattivato quando il mutex
verrà rilasciato. Questo significa che il processore potrà occuparsi d’altro
mentre il vostro processo è in attesa. Esistono molti casi in cui non potete
permettervi di sospendere un processo (vedere
<a class="reference internal" href="#quali-funzioni-possono-essere-chiamate-in-modo-sicuro-dalle-interruzioni">Quali funzioni possono essere chiamate in modo sicuro dalle interruzioni?</a>)
e quindi dovrete utilizzare gli spinlock.</p>
<p>Nessuno di questi <em>lock</em> è ricorsivo: vedere
<a class="reference internal" href="#stallo-semplice-ed-avanzato">Stallo: semplice ed avanzato</a></p>
</section>
<section id="i-lock-e-i-kernel-per-sistemi-monoprocessore">
<h3>I <em>lock</em> e i kernel per sistemi monoprocessore<a class="headerlink" href="#i-lock-e-i-kernel-per-sistemi-monoprocessore" title="Permalink to this headline">¶</a></h3>
<p>Per i kernel compilati senza <code class="docutils literal notranslate"><span class="pre">CONFIG_SMP</span></code> e senza <code class="docutils literal notranslate"><span class="pre">CONFIG_PREEMPT</span></code>
gli spinlock non esistono. Questa è un’ottima scelta di progettazione:
quando nessun altro processo può essere eseguito in simultanea, allora
non c’è la necessità di avere un <em>lock</em>.</p>
<p>Se il kernel è compilato senza <code class="docutils literal notranslate"><span class="pre">CONFIG_SMP</span></code> ma con <code class="docutils literal notranslate"><span class="pre">CONFIG_PREEMPT</span></code>,
allora gli spinlock disabilitano la prelazione; questo è sufficiente a
prevenire le corse critiche. Nella maggior parte dei casi, possiamo considerare
la prelazione equivalente ad un sistema multi-processore senza preoccuparci
di trattarla indipendentemente.</p>
<p>Dovreste verificare sempre la sincronizzazione con le opzioni <code class="docutils literal notranslate"><span class="pre">CONFIG_SMP</span></code> e
<code class="docutils literal notranslate"><span class="pre">CONFIG_PREEMPT</span></code> abilitate, anche quando non avete un sistema
multi-processore, questo vi permetterà di identificare alcuni problemi
di sincronizzazione.</p>
<p>Come vedremo di seguito, i mutex continuano ad esistere perché sono necessari
per la sincronizzazione fra processi in contesto utente.</p>
</section>
<section id="sincronizzazione-in-contesto-utente">
<h3>Sincronizzazione in contesto utente<a class="headerlink" href="#sincronizzazione-in-contesto-utente" title="Permalink to this headline">¶</a></h3>
<p>Se avete una struttura dati che verrà utilizzata solo dal contesto utente,
allora, per proteggerla, potete utilizzare un semplice mutex
(<code class="docutils literal notranslate"><span class="pre">include/linux/mutex.h</span></code>). Questo è il caso più semplice: inizializzate il
mutex; invocate <a class="reference internal" href="#c.it_IT.mutex_lock_interruptible" title="it_IT.mutex_lock_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock_interruptible()</span></code></a> per trattenerlo e
<a class="reference internal" href="#c.it_IT.mutex_unlock" title="it_IT.mutex_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_unlock()</span></code></a> per rilasciarlo. C’è anche <a class="reference internal" href="#c.it_IT.mutex_lock" title="it_IT.mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a>
ma questa dovrebbe essere evitata perché non ritorna in caso di segnali.</p>
<p>Per esempio: <code class="docutils literal notranslate"><span class="pre">net/netfilter/nf_sockopt.c</span></code> permette la registrazione
di nuove chiamate per setsockopt() e getsockopt()
usando la funzione nf_register_sockopt(). La registrazione e
la rimozione vengono eseguite solamente quando il modulo viene caricato
o scaricato (e durante l’avvio del sistema, qui non abbiamo concorrenza),
e la lista delle funzioni registrate viene consultata solamente quando
setsockopt() o getsockopt() sono sconosciute al sistema.
In questo caso <code class="docutils literal notranslate"><span class="pre">nf_sockopt_mutex</span></code> è perfetto allo scopo, in particolar modo
visto che setsockopt e getsockopt potrebbero dormire.</p>
</section>
<section id="sincronizzazione-fra-il-contesto-utente-e-i-softirq">
<h3>Sincronizzazione fra il contesto utente e i softirq<a class="headerlink" href="#sincronizzazione-fra-il-contesto-utente-e-i-softirq" title="Permalink to this headline">¶</a></h3>
<p>Se un softirq condivide dati col contesto utente, avete due problemi.
Primo, il contesto utente corrente potrebbe essere interroto da un softirq,
e secondo, la sezione critica potrebbe essere eseguita da un altro
processore. Questo è quando spin_lock_bh()
(<code class="docutils literal notranslate"><span class="pre">include/linux/spinlock.h</span></code>) viene utilizzato. Questo disabilita i softirq
sul processore e trattiene il <em>lock</em>. Invece, spin_unlock_bh() fa
l’opposto. (Il suffisso ‘_bh’ è un residuo storico che fa riferimento al
“Bottom Halves”, il vecchio nome delle interruzioni software. In un mondo
perfetto questa funzione si chiamerebbe ‘spin_lock_softirq()’).</p>
<p>Da notare che in questo caso potete utilizzare anche spin_lock_irq()
o spin_lock_irqsave(), queste fermano anche le interruzioni hardware:
vedere <a class="reference internal" href="#contesto-di-interruzione-hardware">Contesto di interruzione hardware</a>.</p>
<p>Questo funziona alla perfezione anche sui sistemi monoprocessore: gli spinlock
svaniscono e questa macro diventa semplicemente local_bh_disable()
(<code class="docutils literal notranslate"><span class="pre">include/linux/interrupt.h</span></code>), la quale impedisce ai softirq d’essere
eseguiti.</p>
</section>
<section id="sincronizzazione-fra-contesto-utente-e-i-tasklet">
<h3>Sincronizzazione fra contesto utente e i tasklet<a class="headerlink" href="#sincronizzazione-fra-contesto-utente-e-i-tasklet" title="Permalink to this headline">¶</a></h3>
<p>Questo caso è uguale al precedente, un tasklet viene eseguito da un softirq.</p>
</section>
<section id="sincronizzazione-fra-contesto-utente-e-i-timer">
<h3>Sincronizzazione fra contesto utente e i timer<a class="headerlink" href="#sincronizzazione-fra-contesto-utente-e-i-timer" title="Permalink to this headline">¶</a></h3>
<p>Anche questo caso è uguale al precedente, un timer viene eseguito da un
softirq.
Dal punto di vista della sincronizzazione, tasklet e timer sono identici.</p>
</section>
<section id="sincronizzazione-fra-tasklet-e-timer">
<h3>Sincronizzazione fra tasklet e timer<a class="headerlink" href="#sincronizzazione-fra-tasklet-e-timer" title="Permalink to this headline">¶</a></h3>
<p>Qualche volta un tasklet od un timer potrebbero condividere i dati con
un altro tasklet o timer</p>
<section id="lo-stesso-tasklet-timer">
<h4>Lo stesso tasklet/timer<a class="headerlink" href="#lo-stesso-tasklet-timer" title="Permalink to this headline">¶</a></h4>
<p>Dato che un tasklet non viene mai eseguito contemporaneamente su due
processori, non dovete preoccuparvi che sia rientrante (ovvero eseguito
più volte in contemporanea), perfino su sistemi multi-processore.</p>
</section>
<section id="differenti-tasklet-timer">
<h4>Differenti tasklet/timer<a class="headerlink" href="#differenti-tasklet-timer" title="Permalink to this headline">¶</a></h4>
<p>Se un altro tasklet/timer vuole condividere dati col vostro tasklet o timer,
allora avrete bisogno entrambe di spin_lock() e
spin_unlock(). Qui spin_lock_bh() è inutile, siete già
in un tasklet ed avete la garanzia che nessun altro verrà eseguito sullo
stesso processore.</p>
</section>
</section>
<section id="sincronizzazione-fra-softirq">
<h3>Sincronizzazione fra softirq<a class="headerlink" href="#sincronizzazione-fra-softirq" title="Permalink to this headline">¶</a></h3>
<p>Spesso un softirq potrebbe condividere dati con se stesso o un tasklet/timer.</p>
<section id="lo-stesso-softirq">
<h4>Lo stesso softirq<a class="headerlink" href="#lo-stesso-softirq" title="Permalink to this headline">¶</a></h4>
<p>Lo stesso softirq può essere eseguito su un diverso processore: allo scopo
di migliorare le prestazioni potete utilizzare dati riservati ad ogni
processore (vedere <a class="reference internal" href="#dati-per-processore">Dati per processore</a>). Se siete arrivati
fino a questo punto nell’uso dei softirq, probabilmente tenete alla scalabilità
delle prestazioni abbastanza da giustificarne la complessità aggiuntiva.</p>
<p>Dovete utilizzare spin_lock() e spin_unlock() per
proteggere i dati condivisi.</p>
</section>
<section id="diversi-softirqs">
<h4>Diversi Softirqs<a class="headerlink" href="#diversi-softirqs" title="Permalink to this headline">¶</a></h4>
<p>Dovete utilizzare spin_lock() e spin_unlock() per
proteggere i dati condivisi, che siano timer, tasklet, diversi softirq o
lo stesso o altri softirq: uno qualsiasi di essi potrebbe essere in esecuzione
su un diverso processore.</p>
</section>
</section>
</section>
<section id="contesto-di-interruzione-hardware">
<span id="it-hardirq-context"></span><h2>Contesto di interruzione hardware<a class="headerlink" href="#contesto-di-interruzione-hardware" title="Permalink to this headline">¶</a></h2>
<p>Solitamente le interruzioni hardware comunicano con un tasklet o un softirq.
Spesso questo si traduce nel mettere in coda qualcosa da fare che verrà
preso in carico da un softirq.</p>
<section id="sincronizzazione-fra-interruzioni-hardware-e-softirq-tasklet">
<h3>Sincronizzazione fra interruzioni hardware e softirq/tasklet<a class="headerlink" href="#sincronizzazione-fra-interruzioni-hardware-e-softirq-tasklet" title="Permalink to this headline">¶</a></h3>
<p>Se un gestore di interruzioni hardware condivide dati con un softirq, allora
avrete due preoccupazioni. Primo, il softirq può essere interrotto da
un’interruzione hardware, e secondo, la sezione critica potrebbe essere
eseguita da un’interruzione hardware su un processore diverso. Questo è il caso
dove spin_lock_irq() viene utilizzato. Disabilita le interruzioni
sul processore che l’esegue, poi trattiene il lock. spin_unlock_irq()
fa l’opposto.</p>
<p>Il gestore d’interruzione hardware non ha bisogno di usare spin_lock_irq()
perché i softirq non possono essere eseguiti quando il gestore d’interruzione
hardware è in esecuzione: per questo si può usare spin_lock(), che è un po’
più veloce. L’unica eccezione è quando un altro gestore d’interruzioni
hardware utilizza lo stesso <em>lock</em>: spin_lock_irq() impedirà a questo
secondo gestore di interrompere quello in esecuzione.</p>
<p>Questo funziona alla perfezione anche sui sistemi monoprocessore: gli spinlock
svaniscono e questa macro diventa semplicemente local_irq_disable()
(<code class="docutils literal notranslate"><span class="pre">include/asm/smp.h</span></code>), la quale impedisce a softirq/tasklet/BH d’essere
eseguiti.</p>
<p>spin_lock_irqsave() (<code class="docutils literal notranslate"><span class="pre">include/linux/spinlock.h</span></code>) è una variante che
salva lo stato delle interruzioni in una variabile, questa verrà poi passata
a spin_unlock_irqrestore(). Questo significa che lo stesso codice
potrà essere utilizzato in un’interruzione hardware (dove le interruzioni sono
già disabilitate) e in un softirq (dove la disabilitazione delle interruzioni
è richiesta).</p>
<p>Da notare che i softirq (e quindi tasklet e timer) sono eseguiti al ritorno
da un’interruzione hardware, quindi spin_lock_irq() interrompe
anche questi. Tenuto conto di questo si può dire che
spin_lock_irqsave() è la funzione di sincronizzazione più generica
e potente.</p>
</section>
<section id="sincronizzazione-fra-due-gestori-d-interruzioni-hardware">
<h3>Sincronizzazione fra due gestori d’interruzioni hardware<a class="headerlink" href="#sincronizzazione-fra-due-gestori-d-interruzioni-hardware" title="Permalink to this headline">¶</a></h3>
<p>Condividere dati fra due gestori di interruzione hardware è molto raro, ma se
succede, dovreste usare spin_lock_irqsave(): è una specificità
dell’architettura il fatto che tutte le interruzioni vengano interrotte
quando si eseguono di gestori di interruzioni.</p>
</section>
</section>
<section id="bigino-della-sincronizzazione">
<h2>Bigino della sincronizzazione<a class="headerlink" href="#bigino-della-sincronizzazione" title="Permalink to this headline">¶</a></h2>
<p>Pete Zaitcev ci offre il seguente riassunto:</p>
<ul class="simple">
<li><p>Se siete in un contesto utente (una qualsiasi chiamata di sistema)
e volete sincronizzarvi con altri processi, usate i mutex. Potete trattenere
il mutex e dormire (<code class="docutils literal notranslate"><span class="pre">copy_from_user(</span></code> o <code class="docutils literal notranslate"><span class="pre">kmalloc(x,GFP_KERNEL)</span></code>).</p></li>
<li><p>Altrimenti (== i dati possono essere manipolati da un’interruzione) usate
spin_lock_irqsave() e spin_unlock_irqrestore().</p></li>
<li><p>Evitate di trattenere uno spinlock per più di 5 righe di codice incluse
le chiamate a funzione (ad eccezione di quell per l’accesso come
readb()).</p></li>
</ul>
<section id="tabella-dei-requisiti-minimi">
<h3>Tabella dei requisiti minimi<a class="headerlink" href="#tabella-dei-requisiti-minimi" title="Permalink to this headline">¶</a></h3>
<p>La tabella seguente illustra i requisiti <strong>minimi</strong> per la sincronizzazione fra
diversi contesti. In alcuni casi, lo stesso contesto può essere eseguito solo
da un processore per volta, quindi non ci sono requisiti per la
sincronizzazione (per esempio, un thread può essere eseguito solo su un
processore alla volta, ma se deve condividere dati con un altro thread, allora
la sincronizzazione è necessaria).</p>
<p>Ricordatevi il suggerimento qui sopra: potete sempre usare
spin_lock_irqsave(), che è un sovrainsieme di tutte le altre funzioni
per spinlock.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>.</p></th>
<th class="head"><p>IRQ Handler A</p></th>
<th class="head"><p>IRQ Handler B</p></th>
<th class="head"><p>Softirq A</p></th>
<th class="head"><p>Softirq B</p></th>
<th class="head"><p>Tasklet A</p></th>
<th class="head"><p>Tasklet B</p></th>
<th class="head"><p>Timer A</p></th>
<th class="head"><p>Timer B</p></th>
<th class="head"><p>User Context A</p></th>
<th class="head"><p>User Context B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IRQ Handler A</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>IRQ Handler B</p></td>
<td><p>SLIS</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Softirq A</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Softirq B</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Tasklet A</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Tasklet B</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Timer A</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Timer B</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>SL</p></td>
<td><p>None</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>User Context A</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>None</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>User Context B</p></td>
<td><p>SLI</p></td>
<td><p>SLI</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>SLBH</p></td>
<td><p>MLI</p></td>
<td><p>None</p></td>
</tr>
</tbody>
</table>
<p>Table: Tabella dei requisiti per la sincronizzazione</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 78%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>SLIS</p></td>
<td><p>spin_lock_irqsave</p></td>
</tr>
<tr class="row-even"><td><p>SLI</p></td>
<td><p>spin_lock_irq</p></td>
</tr>
<tr class="row-odd"><td><p>SL</p></td>
<td><p>spin_lock</p></td>
</tr>
<tr class="row-even"><td><p>SLBH</p></td>
<td><p>spin_lock_bh</p></td>
</tr>
<tr class="row-odd"><td><p>MLI</p></td>
<td><p>mutex_lock_interruptible</p></td>
</tr>
</tbody>
</table>
<p>Table: Legenda per la tabella dei requisiti per la sincronizzazione</p>
</section>
</section>
<section id="le-funzioni-trylock">
<h2>Le funzioni <em>trylock</em><a class="headerlink" href="#le-funzioni-trylock" title="Permalink to this headline">¶</a></h2>
<p>Ci sono funzioni che provano a trattenere un <em>lock</em> solo una volta e
ritornano immediatamente comunicato il successo od il fallimento
dell’operazione. Posso essere usate quando non serve accedere ai dati
protetti dal <em>lock</em> quando qualche altro thread lo sta già facendo
trattenendo il <em>lock</em>. Potrete acquisire il <em>lock</em> più tardi se vi
serve accedere ai dati protetti da questo <em>lock</em>.</p>
<p>La funzione spin_trylock() non ritenta di acquisire il <em>lock</em>,
se ci riesce al primo colpo ritorna un valore diverso da zero, altrimenti
se fallisce ritorna 0. Questa funzione può essere utilizzata in un qualunque
contesto, ma come spin_lock(): dovete disabilitare i contesti che
potrebbero interrompervi e quindi trattenere lo spinlock.</p>
<p>La funzione <a class="reference internal" href="#c.it_IT.mutex_trylock" title="it_IT.mutex_trylock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_trylock()</span></code></a> invece di sospendere il vostro processo
ritorna un valore diverso da zero se è possibile trattenere il lock al primo
colpo, altrimenti se fallisce ritorna 0. Nonostante non dorma, questa funzione
non può essere usata in modo sicuro in contesti di interruzione hardware o
software.</p>
</section>
<section id="esempi-piu-comuni">
<h2>Esempi più comuni<a class="headerlink" href="#esempi-piu-comuni" title="Permalink to this headline">¶</a></h2>
<p>Guardiamo un semplice esempio: una memoria che associa nomi a numeri.
La memoria tiene traccia di quanto spesso viene utilizzato ogni oggetto;
quando è piena, l’oggetto meno usato viene eliminato.</p>
<section id="tutto-in-contesto-utente">
<h3>Tutto in contesto utente<a class="headerlink" href="#tutto-in-contesto-utente" title="Permalink to this headline">¶</a></h3>
<p>Nel primo esempio, supponiamo che tutte le operazioni avvengano in contesto
utente (in soldoni, da una chiamata di sistema), quindi possiamo dormire.
Questo significa che possiamo usare i mutex per proteggere la nostra memoria
e tutti gli oggetti che contiene. Ecco il codice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/list.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;asm/errno.h&gt;

struct object
{
        struct list_head list;
        int id;
        char name[32];
        int popularity;
};

/* Protects the cache, cache_num, and the objects within it */
static DEFINE_MUTEX(cache_lock);
static LIST_HEAD(cache);
static unsigned int cache_num = 0;
#define MAX_CACHE_SIZE 10

/* Must be holding cache_lock */
static struct object *__cache_find(int id)
{
        struct object *i;

        list_for_each_entry(i, &amp;cache, list)
                if (i-&gt;id == id) {
                        i-&gt;popularity++;
                        return i;
                }
        return NULL;
}

/* Must be holding cache_lock */
static void __cache_delete(struct object *obj)
{
        BUG_ON(!obj);
        list_del(&amp;obj-&gt;list);
        kfree(obj);
        cache_num--;
}

/* Must be holding cache_lock */
static void __cache_add(struct object *obj)
{
        list_add(&amp;obj-&gt;list, &amp;cache);
        if (++cache_num &gt; MAX_CACHE_SIZE) {
                struct object *i, *outcast = NULL;
                list_for_each_entry(i, &amp;cache, list) {
                        if (!outcast || i-&gt;popularity &lt; outcast-&gt;popularity)
                                outcast = i;
                }
                __cache_delete(outcast);
        }
}

int cache_add(int id, const char *name)
{
        struct object *obj;

        if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)
                return -ENOMEM;

        strscpy(obj-&gt;name, name, sizeof(obj-&gt;name));
        obj-&gt;id = id;
        obj-&gt;popularity = 0;

        mutex_lock(&amp;cache_lock);
        __cache_add(obj);
        mutex_unlock(&amp;cache_lock);
        return 0;
}

void cache_delete(int id)
{
        mutex_lock(&amp;cache_lock);
        __cache_delete(__cache_find(id));
        mutex_unlock(&amp;cache_lock);
}

int cache_find(int id, char *name)
{
        struct object *obj;
        int ret = -ENOENT;

        mutex_lock(&amp;cache_lock);
        obj = __cache_find(id);
        if (obj) {
                ret = 0;
                strcpy(name, obj-&gt;name);
        }
        mutex_unlock(&amp;cache_lock);
        return ret;
}
</pre></div>
</div>
<p>Da notare che ci assicuriamo sempre di trattenere cache_lock quando
aggiungiamo, rimuoviamo od ispezioniamo la memoria: sia la struttura
della memoria che il suo contenuto sono protetti dal <em>lock</em>. Questo
caso è semplice dato che copiamo i dati dall’utente e non permettiamo
mai loro di accedere direttamente agli oggetti.</p>
<p>C’è una piccola ottimizzazione qui: nella funzione cache_add()
impostiamo i campi dell’oggetto prima di acquisire il <em>lock</em>. Questo è
sicuro perché nessun altro potrà accedervi finché non lo inseriremo
nella memoria.</p>
</section>
<section id="accesso-dal-contesto-utente">
<h3>Accesso dal contesto utente<a class="headerlink" href="#accesso-dal-contesto-utente" title="Permalink to this headline">¶</a></h3>
<p>Ora consideriamo il caso in cui cache_find() può essere invocata
dal contesto d’interruzione: sia hardware che software. Un esempio potrebbe
essere un timer che elimina oggetti dalla memoria.</p>
<p>Qui di seguito troverete la modifica nel formato <em>patch</em>: le righe <code class="docutils literal notranslate"><span class="pre">-</span></code>
sono quelle rimosse, mentre quelle <code class="docutils literal notranslate"><span class="pre">+</span></code> sono quelle aggiunte.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--- cache.c.usercontext 2003-12-09 13:58:54.000000000 +1100
+++ cache.c.interrupt   2003-12-09 14:07:49.000000000 +1100
@@ -12,7 +12,7 @@
         int popularity;
 };

-static DEFINE_MUTEX(cache_lock);
+static DEFINE_SPINLOCK(cache_lock);
 static LIST_HEAD(cache);
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10
@@ -55,6 +55,7 @@
 int cache_add(int id, const char *name)
 {
         struct object *obj;
+        unsigned long flags;

         if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)
                 return -ENOMEM;
@@ -63,30 +64,33 @@
         obj-&gt;id = id;
         obj-&gt;popularity = 0;

-        mutex_lock(&amp;cache_lock);
+        spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
         return 0;
 }

 void cache_delete(int id)
 {
-        mutex_lock(&amp;cache_lock);
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_delete(__cache_find(id));
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
 }

 int cache_find(int id, char *name)
 {
         struct object *obj;
         int ret = -ENOENT;
+        unsigned long flags;

-        mutex_lock(&amp;cache_lock);
+        spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
         if (obj) {
                 ret = 0;
                 strcpy(name, obj-&gt;name);
         }
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
         return ret;
 }
</pre></div>
</div>
<p>Da notare che spin_lock_irqsave() disabiliterà le interruzioni
se erano attive, altrimenti non farà niente (quando siamo già in un contesto
d’interruzione); dunque queste funzioni possono essere chiamante in
sicurezza da qualsiasi contesto.</p>
<p>Sfortunatamente, cache_add() invoca <a class="reference internal" href="../../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> con
l’opzione <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code> che è permessa solo in contesto utente. Ho supposto
che cache_add() venga chiamata dal contesto utente, altrimenti
questa opzione deve diventare un parametro di cache_add().</p>
</section>
<section id="esporre-gli-oggetti-al-di-fuori-del-file">
<h3>Esporre gli oggetti al di fuori del file<a class="headerlink" href="#esporre-gli-oggetti-al-di-fuori-del-file" title="Permalink to this headline">¶</a></h3>
<p>Se i vostri oggetti contengono più informazioni, potrebbe non essere
sufficiente copiare i dati avanti e indietro: per esempio, altre parti del
codice potrebbero avere un puntatore a questi oggetti piuttosto che cercarli
ogni volta. Questo introduce due problemi.</p>
<p>Il primo problema è che utilizziamo <code class="docutils literal notranslate"><span class="pre">cache_lock</span></code> per proteggere gli oggetti:
dobbiamo renderlo dinamico così che il resto del codice possa usarlo. Questo
rende la sincronizzazione più complicata dato che non avviene più in un unico
posto.</p>
<p>Il secondo problema è il problema del ciclo di vita: se un’altra struttura
mantiene un puntatore ad un oggetto, presumibilmente si aspetta che questo
puntatore rimanga valido. Sfortunatamente, questo è garantito solo mentre
si trattiene il <em>lock</em>, altrimenti qualcuno potrebbe chiamare
cache_delete() o peggio, aggiungere un oggetto che riutilizza lo
stesso indirizzo.</p>
<p>Dato che c’è un solo <em>lock</em>, non potete trattenerlo a vita: altrimenti
nessun altro potrà eseguire il proprio lavoro.</p>
<p>La soluzione a questo problema è l’uso di un contatore di riferimenti:
chiunque punti ad un oggetto deve incrementare il contatore, e decrementarlo
quando il puntatore non viene più usato. Quando il contatore raggiunge lo zero
significa che non è più usato e l’oggetto può essere rimosso.</p>
<p>Ecco il codice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--- cache.c.interrupt   2003-12-09 14:25:43.000000000 +1100
+++ cache.c.refcnt  2003-12-09 14:33:05.000000000 +1100
@@ -7,6 +7,7 @@
 struct object
 {
         struct list_head list;
+        unsigned int refcnt;
         int id;
         char name[32];
         int popularity;
@@ -17,6 +18,35 @@
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10

+static void __object_put(struct object *obj)
+{
+        if (--obj-&gt;refcnt == 0)
+                kfree(obj);
+}
+
+static void __object_get(struct object *obj)
+{
+        obj-&gt;refcnt++;
+}
+
+void object_put(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
+        __object_put(obj);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
+}
+
+void object_get(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
+        __object_get(obj);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
+}
+
 /* Must be holding cache_lock */
 static struct object *__cache_find(int id)
 {
@@ -35,6 +65,7 @@
 {
         BUG_ON(!obj);
         list_del(&amp;obj-&gt;list);
+        __object_put(obj);
         cache_num--;
 }

@@ -63,6 +94,7 @@
         strscpy(obj-&gt;name, name, sizeof(obj-&gt;name));
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
+        obj-&gt;refcnt = 1; /* The cache holds a reference */

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
@@ -79,18 +111,15 @@
         spin_unlock_irqrestore(&amp;cache_lock, flags);
 }

-int cache_find(int id, char *name)
+struct object *cache_find(int id)
 {
         struct object *obj;
-        int ret = -ENOENT;
         unsigned long flags;

         spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
-        if (obj) {
-                ret = 0;
-                strcpy(name, obj-&gt;name);
-        }
+        if (obj)
+                __object_get(obj);
         spin_unlock_irqrestore(&amp;cache_lock, flags);
-        return ret;
+        return obj;
 }
</pre></div>
</div>
<p>Abbiamo incapsulato il contatore di riferimenti nelle tipiche funzioni
di ‘get’ e ‘put’. Ora possiamo ritornare l’oggetto da cache_find()
col vantaggio che l’utente può dormire trattenendo l’oggetto (per esempio,
copy_to_user() per copiare il nome verso lo spazio utente).</p>
<p>Un altro punto da notare è che ho detto che il contatore dovrebbe incrementarsi
per ogni puntatore ad un oggetto: quindi il contatore di riferimenti è 1
quando l’oggetto viene inserito nella memoria. In altre versione il framework
non trattiene un riferimento per se, ma diventa più complicato.</p>
<section id="usare-operazioni-atomiche-per-il-contatore-di-riferimenti">
<h4>Usare operazioni atomiche per il contatore di riferimenti<a class="headerlink" href="#usare-operazioni-atomiche-per-il-contatore-di-riferimenti" title="Permalink to this headline">¶</a></h4>
<p>In sostanza, <code class="xref c c-type docutils literal notranslate"><span class="pre">atomic_t</span></code> viene usato come contatore di riferimenti.
Ci sono un certo numbero di operazioni atomiche definite
in <code class="docutils literal notranslate"><span class="pre">include/asm/atomic.h</span></code>: queste sono garantite come atomiche su qualsiasi
processore del sistema, quindi non sono necessari i <em>lock</em>. In questo caso è
più semplice rispetto all’uso degli spinlock, benché l’uso degli spinlock
sia più elegante per casi non banali. Le funzioni atomic_inc() e
atomic_dec_and_test() vengono usate al posto dei tipici operatori di
incremento e decremento, e i <em>lock</em> non sono più necessari per proteggere il
contatore stesso.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--- cache.c.refcnt  2003-12-09 15:00:35.000000000 +1100
+++ cache.c.refcnt-atomic   2003-12-11 15:49:42.000000000 +1100
@@ -7,7 +7,7 @@
 struct object
 {
         struct list_head list;
-        unsigned int refcnt;
+        atomic_t refcnt;
         int id;
         char name[32];
         int popularity;
@@ -18,33 +18,15 @@
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10

-static void __object_put(struct object *obj)
-{
-        if (--obj-&gt;refcnt == 0)
-                kfree(obj);
-}
-
-static void __object_get(struct object *obj)
-{
-        obj-&gt;refcnt++;
-}
-
 void object_put(struct object *obj)
 {
-        unsigned long flags;
-
-        spin_lock_irqsave(&amp;cache_lock, flags);
-        __object_put(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        if (atomic_dec_and_test(&amp;obj-&gt;refcnt))
+                kfree(obj);
 }

 void object_get(struct object *obj)
 {
-        unsigned long flags;
-
-        spin_lock_irqsave(&amp;cache_lock, flags);
-        __object_get(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        atomic_inc(&amp;obj-&gt;refcnt);
 }

 /* Must be holding cache_lock */
@@ -65,7 +47,7 @@
 {
         BUG_ON(!obj);
         list_del(&amp;obj-&gt;list);
-        __object_put(obj);
+        object_put(obj);
         cache_num--;
 }

@@ -94,7 +76,7 @@
         strscpy(obj-&gt;name, name, sizeof(obj-&gt;name));
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
-        obj-&gt;refcnt = 1; /* The cache holds a reference */
+        atomic_set(&amp;obj-&gt;refcnt, 1); /* The cache holds a reference */

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
@@ -119,7 +101,7 @@
         spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
         if (obj)
-                __object_get(obj);
+                object_get(obj);
         spin_unlock_irqrestore(&amp;cache_lock, flags);
         return obj;
 }
</pre></div>
</div>
</section>
</section>
<section id="proteggere-l-oggetto-stesso">
<h3>Proteggere l’oggetto stesso<a class="headerlink" href="#proteggere-l-oggetto-stesso" title="Permalink to this headline">¶</a></h3>
<p>In questo esempio, assumiamo che gli oggetti (ad eccezione del contatore
di riferimenti) non cambino mai dopo la loro creazione. Se vogliamo permettere
al nome di cambiare abbiamo tre possibilità:</p>
<ul class="simple">
<li><p>Si può togliere static da <code class="docutils literal notranslate"><span class="pre">cache_lock</span></code> e dire agli utenti che devono
trattenere il <em>lock</em> prima di modificare il nome di un oggetto.</p></li>
<li><p>Si può fornire una funzione cache_obj_rename() che prende il
<em>lock</em> e cambia il nome per conto del chiamante; si dirà poi agli utenti
di usare questa funzione.</p></li>
<li><p>Si può decidere che <code class="docutils literal notranslate"><span class="pre">cache_lock</span></code> protegge solo la memoria stessa, ed
un altro <em>lock</em> è necessario per la protezione del nome.</p></li>
</ul>
<p>Teoricamente, possiamo avere un <em>lock</em> per ogni campo e per ogni oggetto.
In pratica, le varianti più comuni sono:</p>
<ul class="simple">
<li><p>un <em>lock</em> che protegge l’infrastruttura (la lista <code class="docutils literal notranslate"><span class="pre">cache</span></code> di questo
esempio) e gli oggetti. Questo è quello che abbiamo fatto finora.</p></li>
<li><p>un <em>lock</em> che protegge l’infrastruttura (inclusi i puntatori alla lista
negli oggetti), e un <em>lock</em> nell’oggetto per proteggere il resto
dell’oggetto stesso.</p></li>
<li><p><em>lock</em> multipli per proteggere l’infrastruttura (per esempio un <em>lock</em>
per ogni lista), possibilmente con un <em>lock</em> per oggetto.</p></li>
</ul>
<p>Qui di seguito un’implementazione con “un lock per oggetto”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--- cache.c.refcnt-atomic   2003-12-11 15:50:54.000000000 +1100
+++ cache.c.perobjectlock   2003-12-11 17:15:03.000000000 +1100
@@ -6,11 +6,17 @@

 struct object
 {
+        /* These two protected by cache_lock. */
         struct list_head list;
+        int popularity;
+
         atomic_t refcnt;
+
+        /* Doesn&#39;t change once created. */
         int id;
+
+        spinlock_t lock; /* Protects the name */
         char name[32];
-        int popularity;
 };

 static DEFINE_SPINLOCK(cache_lock);
@@ -77,6 +84,7 @@
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
         atomic_set(&amp;obj-&gt;refcnt, 1); /* The cache holds a reference */
+        spin_lock_init(&amp;obj-&gt;lock);

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
</pre></div>
</div>
<p>Da notare che ho deciso che il contatore di popolarità dovesse essere
protetto da <code class="docutils literal notranslate"><span class="pre">cache_lock</span></code> piuttosto che dal <em>lock</em> dell’oggetto; questo
perché è logicamente parte dell’infrastruttura (come
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> nell’oggetto). In questo modo,
in __cache_add(), non ho bisogno di trattenere il <em>lock</em> di ogni
oggetto mentre si cerca il meno popolare.</p>
<p>Ho anche deciso che il campo id è immutabile, quindi non ho bisogno di
trattenere il lock dell’oggetto quando si usa __cache_find()
per leggere questo campo; il <em>lock</em> dell’oggetto è usato solo dal chiamante
che vuole leggere o scrivere il campo name.</p>
<p>Inoltre, da notare che ho aggiunto un commento che descrive i dati che sono
protetti dal <em>lock</em>. Questo è estremamente importante in quanto descrive il
comportamento del codice, che altrimenti sarebbe di difficile comprensione
leggendo solamente il codice. E come dice Alan Cox: “Lock data, not code”.</p>
</section>
</section>
<section id="problemi-comuni">
<h2>Problemi comuni<a class="headerlink" href="#problemi-comuni" title="Permalink to this headline">¶</a></h2>
<section id="stallo-semplice-ed-avanzato">
<h3>Stallo: semplice ed avanzato<a class="headerlink" href="#stallo-semplice-ed-avanzato" title="Permalink to this headline">¶</a></h3>
<p>Esiste un tipo di  baco dove un pezzo di codice tenta di trattenere uno
spinlock due volte: questo rimarrà in attesa attiva per sempre aspettando che
il <em>lock</em> venga rilasciato (in Linux spinlocks, rwlocks e mutex non sono
ricorsivi).
Questo è facile da diagnosticare: non è uno di quei problemi che ti tengono
sveglio 5 notti a parlare da solo.</p>
<p>Un caso un pochino più complesso; immaginate d’avere una spazio condiviso
fra un softirq ed il contesto utente. Se usate spin_lock() per
proteggerlo, il contesto utente potrebbe essere interrotto da un softirq
mentre trattiene il lock, da qui il softirq rimarrà in attesa attiva provando
ad acquisire il <em>lock</em> già trattenuto nel contesto utente.</p>
<p>Questi casi sono chiamati stalli (<em>deadlock</em>), e come mostrato qui sopra,
può succedere anche con un solo processore (Ma non sui sistemi
monoprocessore perché gli spinlock spariscano quando il kernel è compilato
con <code class="docutils literal notranslate"><span class="pre">CONFIG_SMP</span></code>=n. Nonostante ciò, nel secondo caso avrete comunque
una corruzione dei dati).</p>
<p>Questi casi sono facili da diagnosticare; sui sistemi multi-processore
il supervisione (<em>watchdog</em>) o l’opzione di compilazione <code class="docutils literal notranslate"><span class="pre">DEBUG_SPINLOCK</span></code>
(<code class="docutils literal notranslate"><span class="pre">include/linux/spinlock.h</span></code>) permettono di scovare immediatamente quando
succedono.</p>
<p>Esiste un caso più complesso che è conosciuto come l’abbraccio della morte;
questo coinvolge due o più <em>lock</em>. Diciamo che avete un vettore di hash in cui
ogni elemento è uno spinlock a cui è associata una lista di elementi con lo
stesso hash. In un gestore di interruzioni software, dovete modificare un
oggetto e spostarlo su un altro hash; quindi dovrete trattenete lo spinlock
del vecchio hash e di quello nuovo, quindi rimuovere l’oggetto dal vecchio ed
inserirlo nel nuovo.</p>
<p>Qui abbiamo due problemi. Primo, se il vostro codice prova a spostare un
oggetto all’interno della stessa lista, otterrete uno stallo visto che
tenterà di trattenere lo stesso <em>lock</em> due volte. Secondo, se la stessa
interruzione software su un altro processore sta tentando di spostare
un altro oggetto nella direzione opposta, potrebbe accadere quanto segue:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>CPU 1</p></th>
<th class="head"><p>CPU 2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Trattiene <em>lock</em> A -&gt; OK</p></td>
<td><p>Trattiene <em>lock</em> B -&gt; OK</p></td>
</tr>
<tr class="row-odd"><td><p>Trattiene <em>lock</em> B -&gt; attesa</p></td>
<td><p>Trattiene <em>lock</em> A -&gt; attesa</p></td>
</tr>
</tbody>
</table>
<p>Table: Conseguenze</p>
<p>Entrambe i processori rimarranno in attesa attiva sul <em>lock</em> per sempre,
aspettando che l’altro lo rilasci. Sembra e puzza come un blocco totale.</p>
</section>
<section id="prevenire-gli-stalli">
<h3>Prevenire gli stalli<a class="headerlink" href="#prevenire-gli-stalli" title="Permalink to this headline">¶</a></h3>
<p>I libri di testo vi diranno che se trattenete i <em>lock</em> sempre nello stesso
ordine non avrete mai un simile stallo. La pratica vi dirà che questo
approccio non funziona all’ingrandirsi del sistema: quando creo un nuovo
<em>lock</em> non ne capisco abbastanza del kernel per dire in quale dei 5000 <em>lock</em>
si incastrerà.</p>
<p>I <em>lock</em> migliori sono quelli incapsulati: non vengono esposti nei file di
intestazione, e non vengono mai trattenuti fuori dallo stesso file. Potete
rileggere questo codice e vedere che non ci sarà mai uno stallo perché
non tenterà mai di trattenere un altro <em>lock</em> quando lo ha già.
Le persone che usano il vostro codice non devono nemmeno sapere che voi
state usando dei <em>lock</em>.</p>
<p>Un classico problema deriva dall’uso di <em>callback</em> e di <em>hook</em>: se li
chiamate mentre trattenete un <em>lock</em>, rischiate uno stallo o un abbraccio
della morte (chi lo sa cosa farà una <em>callback</em>?).</p>
<section id="ossessiva-prevenzione-degli-stalli">
<h4>Ossessiva prevenzione degli stalli<a class="headerlink" href="#ossessiva-prevenzione-degli-stalli" title="Permalink to this headline">¶</a></h4>
<p>Gli stalli sono un problema, ma non così terribile come la corruzione dei dati.
Un pezzo di codice trattiene un <em>lock</em> di lettura, cerca in una lista,
fallisce nel trovare quello che vuole, quindi rilascia il <em>lock</em> di lettura,
trattiene un <em>lock</em> di scrittura ed inserisce un oggetto; questo genere di
codice presenta una corsa critica.</p>
</section>
</section>
<section id="corsa-fra-temporizzatori-un-passatempo-del-kernel">
<h3>corsa fra temporizzatori: un passatempo del kernel<a class="headerlink" href="#corsa-fra-temporizzatori-un-passatempo-del-kernel" title="Permalink to this headline">¶</a></h3>
<p>I temporizzatori potrebbero avere dei problemi con le corse critiche.
Considerate una collezione di oggetti (liste, hash, eccetera) dove ogni oggetto
ha un temporizzatore che sta per distruggerlo.</p>
<p>Se volete eliminare l’intera collezione (diciamo quando rimuovete un modulo),
potreste fare come segue:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* THIS CODE BAD BAD BAD BAD: IF IT WAS ANY WORSE IT WOULD USE
   HUNGARIAN NOTATION */
spin_lock_bh(&amp;list_lock);

while (list) {
        struct foo *next = list-&gt;next;
        timer_delete(&amp;list-&gt;timer);
        kfree(list);
        list = next;
}

spin_unlock_bh(&amp;list_lock);
</pre></div>
</div>
<p>Primo o poi, questo esploderà su un sistema multiprocessore perché un
temporizzatore potrebbe essere già partiro prima di spin_lock_bh(),
e prenderà il <em>lock</em> solo dopo spin_unlock_bh(), e cercherà
di eliminare il suo oggetto (che però è già stato eliminato).</p>
<p>Questo può essere evitato controllando il valore di ritorno di
<a class="reference internal" href="../../../driver-api/basics.html#c.timer_delete" title="timer_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete()</span></code></a>: se ritorna 1, il temporizzatore è stato già
rimosso. Se 0, significa (in questo caso) che il temporizzatore è in
esecuzione, quindi possiamo fare come segue:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>retry:
        spin_lock_bh(&amp;list_lock);

        while (list) {
                struct foo *next = list-&gt;next;
                if (!timer_delete(&amp;list-&gt;timer)) {
                        /* Give timer a chance to delete this */
                        spin_unlock_bh(&amp;list_lock);
                        goto retry;
                }
                kfree(list);
                list = next;
        }

        spin_unlock_bh(&amp;list_lock);
</pre></div>
</div>
<p>Un altro problema è l’eliminazione dei temporizzatori che si riavviano
da soli (chiamando <a class="reference internal" href="../../../driver-api/basics.html#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> alla fine della loro esecuzione).
Dato che questo è un problema abbastanza comune con una propensione
alle corse critiche, dovreste usare <a class="reference internal" href="../../../driver-api/basics.html#c.timer_delete_sync" title="timer_delete_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete_sync()</span></code></a>
(<code class="docutils literal notranslate"><span class="pre">include/linux/timer.h</span></code>) per gestire questo caso.</p>
</section>
</section>
<section id="velocita-della-sincronizzazione">
<h2>Velocità della sincronizzazione<a class="headerlink" href="#velocita-della-sincronizzazione" title="Permalink to this headline">¶</a></h2>
<p>Ci sono tre cose importanti da tenere in considerazione quando si valuta
la velocità d’esecuzione di un pezzo di codice che necessita di
sincronizzazione. La prima è la concorrenza: quante cose rimangono in attesa
mentre qualcuno trattiene un <em>lock</em>. La seconda è il tempo necessario per
acquisire (senza contese) e rilasciare un <em>lock</em>. La terza è di usare meno
<em>lock</em> o di più furbi. Immagino che i <em>lock</em> vengano usati regolarmente,
altrimenti, non sareste interessati all’efficienza.</p>
<p>La concorrenza dipende da quanto a lungo un <em>lock</em> è trattenuto: dovreste
trattenere un <em>lock</em> solo il tempo minimo necessario ma non un istante in più.
Nella memoria dell’esempio precedente, creiamo gli oggetti senza trattenere
il <em>lock</em>, poi acquisiamo il <em>lock</em> quando siamo pronti per inserirlo nella
lista.</p>
<p>Il tempo di acquisizione di un <em>lock</em> dipende da quanto danno fa
l’operazione sulla <em>pipeline</em> (ovvero stalli della <em>pipeline</em>) e quant’è
probabile che il processore corrente sia stato anche l’ultimo ad acquisire
il <em>lock</em> (in pratica, il <em>lock</em> è nella memoria cache del processore
corrente?): su sistemi multi-processore questa probabilità precipita
rapidamente. Consideriamo un processore Intel Pentium III a 700Mhz: questo
esegue un’istruzione in 0.7ns, un incremento atomico richiede 58ns, acquisire
un <em>lock</em> che è nella memoria cache del processore richiede 160ns, e un
trasferimento dalla memoria cache di un altro processore richiede altri
170/360ns (Leggetevi l’articolo di Paul McKenney’s <a class="reference external" href="http://www.linuxjournal.com/article.php?sid=6993">Linux Journal RCU
article</a>).</p>
<p>Questi due obiettivi sono in conflitto: trattenere un <em>lock</em> per il minor
tempo possibile potrebbe richiedere la divisione in più <em>lock</em> per diverse
parti (come nel nostro ultimo esempio con un <em>lock</em> per ogni oggetto),
ma questo aumenta il numero di acquisizioni di <em>lock</em>, ed il risultato
spesso è che tutto è più lento che con un singolo <em>lock</em>. Questo è un altro
argomento in favore della semplicità quando si parla di sincronizzazione.</p>
<p>Il terzo punto è discusso di seguito: ci sono alcune tecniche per ridurre
il numero di sincronizzazioni che devono essere fatte.</p>
<section id="read-write-lock-variants">
<h3>Read/Write Lock Variants<a class="headerlink" href="#read-write-lock-variants" title="Permalink to this headline">¶</a></h3>
<p>Sia gli spinlock che i mutex hanno una variante per la lettura/scrittura
(read/write): <code class="docutils literal notranslate"><span class="pre">rwlock_t</span></code> e <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rw_semaphore</span></code>.
Queste dividono gli utenti in due categorie: i lettori e gli scrittori.
Se state solo leggendo i dati, potete acquisire il <em>lock</em> di lettura, ma
per scrivere avrete bisogno del <em>lock</em> di scrittura. Molti possono trattenere
il <em>lock</em> di lettura, ma solo uno scrittore alla volta può trattenere
quello di scrittura.</p>
<p>Se il vostro codice si divide chiaramente in codice per lettori e codice
per scrittori (come nel nostro esempio), e il <em>lock</em> dei lettori viene
trattenuto per molto tempo, allora l’uso di questo tipo di <em>lock</em> può aiutare.
Questi sono leggermente più lenti rispetto alla loro versione normale, quindi
nella pratica l’uso di <code class="docutils literal notranslate"><span class="pre">rwlock_t</span></code> non ne vale la pena.</p>
</section>
<section id="evitare-i-lock-read-copy-update">
<h3>Evitare i <em>lock</em>: Read Copy Update<a class="headerlink" href="#evitare-i-lock-read-copy-update" title="Permalink to this headline">¶</a></h3>
<p>Esiste un metodo di sincronizzazione per letture e scritture detto
Read Copy Update. Con l’uso della tecnica RCU, i lettori possono scordarsi
completamente di trattenere i <em>lock</em>; dato che nel nostro esempio ci
aspettiamo d’avere più lettore che scrittori (altrimenti questa memoria
sarebbe uno spreco) possiamo dire che questo meccanismo permette
un’ottimizzazione.</p>
<p>Come facciamo a sbarazzarci dei <em>lock</em> di lettura? Sbarazzarsi dei <em>lock</em> di
lettura significa che uno scrittore potrebbe cambiare la lista sotto al naso
dei lettori. Questo è abbastanza semplice: possiamo leggere una lista
concatenata se lo scrittore aggiunge elementi alla fine e con certe
precauzioni. Per esempio, aggiungendo <code class="docutils literal notranslate"><span class="pre">new</span></code> ad una lista concatenata
chiamata <code class="docutils literal notranslate"><span class="pre">list</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>new-&gt;next = list-&gt;next;
wmb();
list-&gt;next = new;
</pre></div>
</div>
<p>La funzione wmb() è una barriera di sincronizzazione delle
scritture. Questa garantisce che la prima operazione (impostare l’elemento
<code class="docutils literal notranslate"><span class="pre">next</span></code> del nuovo elemento) venga completata e vista da tutti i processori
prima che venga eseguita la seconda operazione (che sarebbe quella di mettere
il nuovo elemento nella lista). Questo è importante perché i moderni
compilatori ed i moderni processori possono, entrambe, riordinare le istruzioni
se non vengono istruiti altrimenti: vogliamo che i lettori non vedano
completamente il nuovo elemento; oppure che lo vedano correttamente e quindi
il puntatore <code class="docutils literal notranslate"><span class="pre">next</span></code> deve puntare al resto della lista.</p>
<p>Fortunatamente, c’è una funzione che fa questa operazione sulle liste
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code>: <a class="reference internal" href="../../../core-api/kernel-api.html#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a>
(<code class="docutils literal notranslate"><span class="pre">include/linux/list.h</span></code>).</p>
<p>Rimuovere un elemento dalla lista è anche più facile: sostituiamo il puntatore
al vecchio elemento con quello del suo successore, e i lettori vedranno
l’elemento o lo salteranno.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>list-&gt;next = old-&gt;next;
</pre></div>
</div>
<p>La funzione <a class="reference internal" href="../../../core-api/kernel-api.html#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">include/linux/list.h</span></code>) fa esattamente
questo (la versione normale corrompe il vecchio oggetto, e non vogliamo che
accada).</p>
<p>Anche i lettori devono stare attenti: alcuni processori potrebbero leggere
attraverso il puntatore <code class="docutils literal notranslate"><span class="pre">next</span></code> il contenuto dell’elemento successivo
troppo presto, ma non accorgersi che il contenuto caricato è sbagliato quando
il puntatore <code class="docutils literal notranslate"><span class="pre">next</span></code> viene modificato alla loro spalle. Ancora una volta
c’è una funzione che viene in vostro aiuto <a class="reference internal" href="../../../core-api/kernel-api.html#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_rcu()</span></code></a>
(<code class="docutils literal notranslate"><span class="pre">include/linux/list.h</span></code>). Ovviamente, gli scrittori possono usare
<a class="reference internal" href="../../../core-api/kernel-api.html#c.list_for_each_entry" title="list_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry()</span></code></a> dato che non ci possono essere due scrittori
in contemporanea.</p>
<p>Il nostro ultimo dilemma è il seguente: quando possiamo realmente distruggere
l’elemento rimosso? Ricordate, un lettore potrebbe aver avuto accesso a questo
elemento proprio ora: se eliminiamo questo elemento ed il puntatore <code class="docutils literal notranslate"><span class="pre">next</span></code>
cambia, il lettore salterà direttamente nella spazzatura e scoppierà. Dobbiamo
aspettare finché tutti i lettori che stanno attraversando la lista abbiano
finito. Utilizziamo <a class="reference internal" href="../../../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> per registrare una funzione di
richiamo che distrugga l’oggetto quando tutti i lettori correnti hanno
terminato. In alternative, potrebbe essere usata la funzione
<a class="reference internal" href="../../../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> che blocca l’esecuzione finché tutti i lettori
non terminano di ispezionare la lista.</p>
<p>Ma come fa l’RCU a sapere quando i lettori sono finiti? Il meccanismo è
il seguente: innanzi tutto i lettori accedono alla lista solo fra la coppia
<a class="reference internal" href="../../../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>/<a class="reference internal" href="../../../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> che disabilita la
prelazione così che i lettori non vengano sospesi mentre stanno leggendo
la lista.</p>
<p>Poi, l’RCU aspetta finché tutti i processori non abbiano dormito almeno
una volta; a questo punto, dato che i lettori non possono dormire, possiamo
dedurre che un qualsiasi lettore che abbia consultato la lista durante la
rimozione abbia già terminato, quindi la <em>callback</em> viene eseguita. Il vero
codice RCU è un po’ più ottimizzato di così, ma questa è l’idea di fondo.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--- cache.c.perobjectlock   2003-12-11 17:15:03.000000000 +1100
+++ cache.c.rcupdate    2003-12-11 17:55:14.000000000 +1100
@@ -1,15 +1,18 @@
 #include &lt;linux/list.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/string.h&gt;
+#include &lt;linux/rcupdate.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;asm/errno.h&gt;

 struct object
 {
-        /* These two protected by cache_lock. */
+        /* This is protected by RCU */
         struct list_head list;
         int popularity;

+        struct rcu_head rcu;
+
         atomic_t refcnt;

         /* Doesn&#39;t change once created. */
@@ -40,7 +43,7 @@
 {
         struct object *i;

-        list_for_each_entry(i, &amp;cache, list) {
+        list_for_each_entry_rcu(i, &amp;cache, list) {
                 if (i-&gt;id == id) {
                         i-&gt;popularity++;
                         return i;
@@ -49,19 +52,25 @@
         return NULL;
 }

+/* Final discard done once we know no readers are looking. */
+static void cache_delete_rcu(void *arg)
+{
+        object_put(arg);
+}
+
 /* Must be holding cache_lock */
 static void __cache_delete(struct object *obj)
 {
         BUG_ON(!obj);
-        list_del(&amp;obj-&gt;list);
-        object_put(obj);
+        list_del_rcu(&amp;obj-&gt;list);
         cache_num--;
+        call_rcu(&amp;obj-&gt;rcu, cache_delete_rcu);
 }

 /* Must be holding cache_lock */
 static void __cache_add(struct object *obj)
 {
-        list_add(&amp;obj-&gt;list, &amp;cache);
+        list_add_rcu(&amp;obj-&gt;list, &amp;cache);
         if (++cache_num &gt; MAX_CACHE_SIZE) {
                 struct object *i, *outcast = NULL;
                 list_for_each_entry(i, &amp;cache, list) {
@@ -104,12 +114,11 @@
 struct object *cache_find(int id)
 {
         struct object *obj;
-        unsigned long flags;

-        spin_lock_irqsave(&amp;cache_lock, flags);
+        rcu_read_lock();
         obj = __cache_find(id);
         if (obj)
                 object_get(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        rcu_read_unlock();
         return obj;
 }
</pre></div>
</div>
<p>Da notare che i lettori modificano il campo popularity nella funzione
__cache_find(), e ora non trattiene alcun <em>lock</em>. Una soluzione
potrebbe essere quella di rendere la variabile <code class="docutils literal notranslate"><span class="pre">atomic_t</span></code>, ma per l’uso
che ne abbiamo fatto qui, non ci interessano queste corse critiche perché un
risultato approssimativo è comunque accettabile, quindi non l’ho cambiato.</p>
<p>Il risultato è che la funzione cache_find() non ha bisogno di alcuna
sincronizzazione con le altre funzioni, quindi è veloce su un sistema
multi-processore tanto quanto lo sarebbe su un sistema mono-processore.</p>
<p>Esiste un’ulteriore ottimizzazione possibile: vi ricordate il codice originale
della nostra memoria dove non c’erano contatori di riferimenti e il chiamante
semplicemente tratteneva il <em>lock</em> prima di accedere ad un oggetto? Questo è
ancora possibile: se trattenete un <em>lock</em> nessuno potrà cancellare l’oggetto,
quindi non avete bisogno di incrementare e decrementare il contatore di
riferimenti.</p>
<p>Ora, dato che il ‘<em>lock</em> di lettura’ di un RCU non fa altro che disabilitare
la prelazione, un chiamante che ha sempre la prelazione disabilitata fra le
chiamate cache_find() e object_put() non necessita
di incrementare e decrementare il contatore di riferimenti. Potremmo
esporre la funzione __cache_find() dichiarandola non-static,
e quel chiamante potrebbe usare direttamente questa funzione.</p>
<p>Il beneficio qui sta nel fatto che il contatore di riferimenti no
viene scritto: l’oggetto non viene alterato in alcun modo e quindi diventa
molto più veloce su sistemi molti-processore grazie alla loro memoria cache.</p>
</section>
<section id="dati-per-processore">
<h3>Dati per processore<a class="headerlink" href="#dati-per-processore" title="Permalink to this headline">¶</a></h3>
<p>Un’altra tecnica comunemente usata per evitare la sincronizzazione è quella
di duplicare le informazioni per ogni processore. Per esempio, se volete
avere un contatore di qualcosa, potreste utilizzare uno spinlock ed un
singolo contatore. Facile e pulito.</p>
<p>Se questo dovesse essere troppo lento (solitamente non lo è, ma se avete
dimostrato che lo è devvero), potreste usare un contatore per ogni processore
e quindi non sarebbe più necessaria la mutua esclusione. Vedere
DEFINE_PER_CPU(), get_cpu_var() e put_cpu_var()
(<code class="docutils literal notranslate"><span class="pre">include/linux/percpu.h</span></code>).</p>
<p>Il tipo di dato <code class="docutils literal notranslate"><span class="pre">local_t</span></code>, la funzione cpu_local_inc() e tutte
le altre funzioni associate, sono di particolare utilità per semplici contatori
per-processore; su alcune architetture sono anche più efficienti
(<code class="docutils literal notranslate"><span class="pre">include/asm/local.h</span></code>).</p>
<p>Da notare che non esiste un modo facile ed affidabile per ottenere il valore
di un simile contatore senza introdurre altri <em>lock</em>. In alcuni casi questo
non è un problema.</p>
</section>
<section id="dati-che-sono-usati-prevalentemente-dai-gestori-d-interruzioni">
<h3>Dati che sono usati prevalentemente dai gestori d’interruzioni<a class="headerlink" href="#dati-che-sono-usati-prevalentemente-dai-gestori-d-interruzioni" title="Permalink to this headline">¶</a></h3>
<p>Se i dati vengono utilizzati sempre dallo stesso gestore d’interruzioni,
allora i <em>lock</em> non vi servono per niente: il kernel già vi garantisce che
il gestore d’interruzione non verrà eseguito in contemporanea su diversi
processori.</p>
<p>Manfred Spraul fa notare che potreste comunque comportarvi così anche
se i dati vengono occasionalmente utilizzati da un contesto utente o
da un’interruzione software. Il gestore d’interruzione non utilizza alcun
<em>lock</em>, e tutti gli altri accessi verranno fatti così:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mutex_lock(&amp;lock);
disable_irq(irq);
...
enable_irq(irq);
mutex_unlock(&amp;lock);
</pre></div>
</div>
<p>La funzione <a class="reference internal" href="../../../core-api/genericirq.html#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a> impedisce al gestore d’interruzioni
d’essere eseguito (e aspetta che finisca nel caso fosse in esecuzione su
un altro processore). Lo spinlock, invece, previene accessi simultanei.
Naturalmente, questo è più lento della semplice chiamata
spin_lock_irq(), quindi ha senso solo se questo genere di accesso
è estremamente raro.</p>
</section>
</section>
<section id="quali-funzioni-possono-essere-chiamate-in-modo-sicuro-dalle-interruzioni">
<h2>Quali funzioni possono essere chiamate in modo sicuro dalle interruzioni?<a class="headerlink" href="#quali-funzioni-possono-essere-chiamate-in-modo-sicuro-dalle-interruzioni" title="Permalink to this headline">¶</a></h2>
<p>Molte funzioni del kernel dormono (in sostanza, chiamano schedule())
direttamente od indirettamente: non potete chiamarle se trattenere uno
spinlock o avete la prelazione disabilitata, mai. Questo significa che
dovete necessariamente essere nel contesto utente: chiamarle da un
contesto d’interruzione è illegale.</p>
<section id="alcune-funzioni-che-dormono">
<h3>Alcune funzioni che dormono<a class="headerlink" href="#alcune-funzioni-che-dormono" title="Permalink to this headline">¶</a></h3>
<p>Le più comuni sono elencate qui di seguito, ma solitamente dovete leggere
il codice per scoprire se altre chiamate sono sicure. Se chiunque altro
le chiami dorme, allora dovreste poter dormire anche voi. In particolar
modo, le funzioni di registrazione e deregistrazione solitamente si
aspettano d’essere chiamante da un contesto utente e quindi che possono
dormire.</p>
<ul>
<li><p>Accessi allo spazio utente:</p>
<ul class="simple">
<li><p>copy_from_user()</p></li>
<li><p>copy_to_user()</p></li>
<li><p><a class="reference internal" href="../../../core-api/mm-api.html#c.get_user" title="get_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_user()</span></code></a></p></li>
<li><p><a class="reference internal" href="../../../core-api/mm-api.html#c.put_user" title="put_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_user()</span></code></a></p></li>
</ul>
</li>
<li><p>kmalloc(GFP_KERNEL) &lt;kmalloc&gt;`</p></li>
<li><p><a class="reference internal" href="#c.it_IT.mutex_lock_interruptible" title="it_IT.mutex_lock_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock_interruptible()</span></code></a> and
<a class="reference internal" href="#c.it_IT.mutex_lock" title="it_IT.mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a></p>
<p>C’è anche <a class="reference internal" href="#c.it_IT.mutex_trylock" title="it_IT.mutex_trylock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_trylock()</span></code></a> che però non dorme.
Comunque, non deve essere usata in un contesto d’interruzione dato
che la sua implementazione non è sicura in quel contesto.
Anche <a class="reference internal" href="#c.it_IT.mutex_unlock" title="it_IT.mutex_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_unlock()</span></code></a> non dorme mai. Non può comunque essere
usata in un contesto d’interruzione perché un mutex deve essere rilasciato
dallo stesso processo che l’ha acquisito.</p>
</li>
</ul>
</section>
<section id="alcune-funzioni-che-non-dormono">
<h3>Alcune funzioni che non dormono<a class="headerlink" href="#alcune-funzioni-che-non-dormono" title="Permalink to this headline">¶</a></h3>
<p>Alcune funzioni possono essere chiamate tranquillamente da qualsiasi
contesto, o trattenendo un qualsiasi <em>lock</em>.</p>
<ul class="simple">
<li><p><a class="reference internal" href="../../../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a></p></li>
<li><p><a class="reference internal" href="../../../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a></p></li>
<li><p><a class="reference internal" href="../../../driver-api/basics.html#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal notranslate"><span class="pre">add_timer()</span></code></a> e <a class="reference internal" href="../../../driver-api/basics.html#c.timer_delete" title="timer_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete()</span></code></a></p></li>
</ul>
</section>
</section>
<section id="riferimento-per-l-api-dei-mutex">
<h2>Riferimento per l’API dei Mutex<a class="headerlink" href="#riferimento-per-l-api-dei-mutex" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.it_IT.it_IT.mutex_init">
<code class="sig-name descname">mutex_init</code><span class="sig-paren">(</span><em>mutex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.it_IT.mutex_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the mutex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>the mutex to be initialized</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the mutex to unlocked state.</p>
<p>It is not allowed to initialize an already locked mutex.</p>
</div>
<dl class="function">
<dt id="c.it_IT.mutex_is_locked">
bool <code class="sig-name descname">mutex_is_locked</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.mutex_is_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>is the mutex locked</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be queried</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the mutex is locked, false if unlocked.</p>
</div>
<dl class="function">
<dt id="c.it_IT.mutex_lock">
void <code class="sig-name descname">mutex_lock</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire the mutex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be acquired</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex exclusively for this task. If the mutex is not
available right now, it will sleep until it can get it.</p>
<p>The mutex must later on be released by the same task that
acquired it. Recursive locking is not allowed. The task
may not exit without first unlocking the mutex. Also, kernel
memory where the mutex resides must not be freed with
the mutex still locked. The mutex must first be initialized
(or statically defined) before it can be locked. <a class="reference internal" href="../../../core-api/kernel-api.html#c.memset" title="memset"><code class="xref c c-func docutils literal notranslate"><span class="pre">memset()</span></code></a>-ing
the mutex to 0 is not allowed.</p>
<p>(The CONFIG_DEBUG_MUTEXES .config option turns on debugging
checks that will enforce the restrictions and will also do
deadlock debugging)</p>
<p>This function is similar to (but not equivalent to) down().</p>
</div>
<dl class="function">
<dt id="c.it_IT.mutex_unlock">
void <code class="sig-name descname">mutex_unlock</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>release the mutex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlock a mutex that has been locked by this task previously.</p>
<p>This function must not be used in interrupt context. Unlocking
of a not locked mutex is not allowed.</p>
<p>This function is similar to (but not equivalent to) up().</p>
</div>
<dl class="function">
<dt id="c.it_IT.ww_mutex_unlock">
void <code class="sig-name descname">ww_mutex_unlock</code><span class="sig-paren">(</span>struct ww_mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.ww_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>release the w/w mutex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be released</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlock a mutex that has been locked by this task previously with any of the
ww_mutex_lock* functions (with or without an acquire context). It is
forbidden to release the locks after releasing the acquire context.</p>
<p>This function must not be used in interrupt context. Unlocking
of a unlocked mutex is not allowed.</p>
</div>
<dl class="function">
<dt id="c.it_IT.ww_mutex_trylock">
int <code class="sig-name descname">ww_mutex_trylock</code><span class="sig-paren">(</span>struct ww_mutex<em> *ww</em>, struct ww_acquire_ctx<em> *ww_ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.ww_mutex_trylock" title="Permalink to this definition">¶</a></dt>
<dd><p>tries to acquire the w/w mutex with optional acquire context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_mutex</span> <span class="pre">*ww</span></code></dt><dd><p>mutex to lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*ww_ctx</span></code></dt><dd><p>optional w/w acquire context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Trylocks a mutex with the optional acquire context; no deadlock detection is
possible. Returns 1 if the mutex has been acquired successfully, 0 otherwise.</p>
<p>Unlike ww_mutex_lock, no deadlock handling is performed. However, if a <strong>ctx</strong> is
specified, -EALREADY handling may happen in calls to ww_mutex_trylock.</p>
<p>A mutex acquired with this function must be released with ww_mutex_unlock.</p>
</div>
<dl class="function">
<dt id="c.it_IT.mutex_lock_interruptible">
int <code class="sig-name descname">mutex_lock_interruptible</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.mutex_lock_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the mutex, interruptible by signals.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>The mutex to be acquired.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex like <a class="reference internal" href="#c.it_IT.mutex_lock" title="it_IT.mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a>.  If a signal is delivered while the
process is sleeping, this function will return without acquiring the
mutex.</p>
<p><strong>Context</strong></p>
<p>Process context.</p>
<p><strong>Return</strong></p>
<p>0 if the lock was successfully acquired or <code class="docutils literal notranslate"><span class="pre">-EINTR</span></code> if a
signal arrived.</p>
</div>
<dl class="function">
<dt id="c.it_IT.mutex_lock_killable">
int <code class="sig-name descname">mutex_lock_killable</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.mutex_lock_killable" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the mutex, interruptible by fatal signals.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>The mutex to be acquired.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex like <a class="reference internal" href="#c.it_IT.mutex_lock" title="it_IT.mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a>.  If a signal which will be fatal to
the current process is delivered while the process is sleeping, this
function will return without acquiring the mutex.</p>
<p><strong>Context</strong></p>
<p>Process context.</p>
<p><strong>Return</strong></p>
<p>0 if the lock was successfully acquired or <code class="docutils literal notranslate"><span class="pre">-EINTR</span></code> if a
fatal signal arrived.</p>
</div>
<dl class="function">
<dt id="c.it_IT.mutex_lock_io">
void <code class="sig-name descname">mutex_lock_io</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.mutex_lock_io" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the mutex and mark the process as waiting for I/O</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>The mutex to be acquired.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex like <a class="reference internal" href="#c.it_IT.mutex_lock" title="it_IT.mutex_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">mutex_lock()</span></code></a>.  While the task is waiting for this
mutex, it will be accounted as being in the IO wait state by the
scheduler.</p>
<p><strong>Context</strong></p>
<p>Process context.</p>
</div>
<dl class="function">
<dt id="c.it_IT.mutex_trylock">
int <code class="sig-name descname">mutex_trylock</code><span class="sig-paren">(</span>struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.mutex_trylock" title="Permalink to this definition">¶</a></dt>
<dd><p>try to acquire the mutex, without waiting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to be acquired</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to acquire the mutex atomically. Returns 1 if the mutex
has been acquired successfully, and 0 on contention.</p>
<p>This function must not be used in interrupt context. The
mutex must be released by the same task that acquired it.</p>
<p><strong>NOTE</strong></p>
<p>this function follows the spin_trylock() convention, so
it is negated from the down_trylock() return values! Be careful
about this when converting semaphore users to mutexes.</p>
</div>
<dl class="function">
<dt id="c.it_IT.atomic_dec_and_mutex_lock">
int <code class="sig-name descname">atomic_dec_and_mutex_lock</code><span class="sig-paren">(</span>atomic_t<em> *cnt</em>, struct mutex<em> *lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.atomic_dec_and_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>return holding mutex if we dec to 0</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">atomic_t</span> <span class="pre">*cnt</span></code></dt><dd><p>the atomic which we are to dec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*lock</span></code></dt><dd><p>the mutex to return holding if we dec to 0</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>return true and hold lock if we dec to 0, return false otherwise</p>
</div>
</section>
<section id="riferimento-per-l-api-dei-futex">
<h2>Riferimento per l’API dei Futex<a class="headerlink" href="#riferimento-per-l-api-dei-futex" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.it_IT.futex_hash">
struct futex_hash_bucket * <code class="sig-name descname">futex_hash</code><span class="sig-paren">(</span>union futex_key<em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the hash bucket in the global hash</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key</span></code></dt><dd><p>Pointer to the futex key for which the hash is calculated</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We hash on the keys returned from get_futex_key (see below) and return the
corresponding hash bucket in the global hash.</p>
</div>
<dl class="function">
<dt id="c.it_IT.futex_setup_timer">
struct <a class="reference internal" href="../../../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a> * <code class="sig-name descname">futex_setup_timer</code><span class="sig-paren">(</span>ktime_t<em> *time</em>, struct <a class="reference internal" href="../../../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *timeout</em>, int<em> flags</em>, u64<em> range_ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_setup_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>set up the sleeping hrtimer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*time</span></code></dt><dd><p>ptr to the given timeout value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*timeout</span></code></dt><dd><p>the hrtimer_sleeper structure to be set up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>futex flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">range_ns</span></code></dt><dd><p>optional range in ns</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>Initialized hrtimer_sleeper structure or NULL if no timeout</dt><dd><p>value given</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.it_IT.get_futex_key">
int <code class="sig-name descname">get_futex_key</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em>, bool<em> fshared</em>, union futex_key<em> *key</em>, enum futex_access<em> rw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.get_futex_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters which are the keys for a futex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>virtual address of the futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">fshared</span></code></dt><dd><p>false for a PROCESS_PRIVATE futex, true for PROCESS_SHARED</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key</span></code></dt><dd><p>address where result is stored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">futex_access</span> <span class="pre">rw</span></code></dt><dd><p>mapping needs to be read/write (values: FUTEX_READ,
FUTEX_WRITE)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>a negative error code or 0</p>
<p><strong>Description</strong></p>
<p>The key words are stored in <strong>key</strong> on success.</p>
<p>For shared mappings (when <strong>fshared</strong>), the key is:</p>
<blockquote>
<div><p>( inode-&gt;i_sequence, page-&gt;index, offset_within_page )</p>
</div></blockquote>
<p>[ also see get_inode_sequence_number() ]</p>
<p>For private mappings (or when <strong>!fshared</strong>), the key is:</p>
<blockquote>
<div><p>( current-&gt;mm, address, 0 )</p>
</div></blockquote>
<p>This allows (cross process, where applicable) identification of the futex
without keeping the page pinned for the duration of the FUTEX_WAIT.</p>
<p><a class="reference internal" href="../../../core-api/mm-api.html#c.lock_page" title="lock_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">lock_page()</span></code></a> might sleep, the caller should not hold a spinlock.</p>
</div>
<dl class="function">
<dt id="c.it_IT.fault_in_user_writeable">
int <code class="sig-name descname">fault_in_user_writeable</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.fault_in_user_writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>Fault in user address and verify RW access</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>pointer to faulting user space address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Slow path to fixup the fault we just took in the atomic write
access to <strong>uaddr</strong>.</p>
<p>We have no generic implementation of a non-destructive write to the
user address. We know that we faulted in the atomic pagefault
disabled section so we can as well avoid the #PF overhead by
calling get_user_pages() right away.</p>
</div>
<dl class="function">
<dt id="c.it_IT.futex_top_waiter">
struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_q" title="futex_q">futex_q</a> * <code class="sig-name descname">futex_top_waiter</code><span class="sig-paren">(</span>struct futex_hash_bucket<em> *hb</em>, union futex_key<em> *key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_top_waiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the highest priority waiter on a futex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>the hash bucket the futex_q’s reside in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key</span></code></dt><dd><p>the futex key (to distinguish it from other futex futex_q’s)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called with the hb lock held.</p>
</div>
<dl class="function">
<dt id="c.it_IT.wait_for_owner_exiting">
void <code class="sig-name descname">wait_for_owner_exiting</code><span class="sig-paren">(</span>int<em> ret</em>, struct task_struct<em> *exiting</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.wait_for_owner_exiting" title="Permalink to this definition">¶</a></dt>
<dd><p>Block until the owner has exited</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ret</span></code></dt><dd><p>owner’s current futex lock status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*exiting</span></code></dt><dd><p>Pointer to the exiting task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must hold a refcount on <strong>exiting</strong>.</p>
</div>
<dl class="function">
<dt id="c.it_IT.__futex_unqueue">
void <code class="sig-name descname">__futex_unqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_q" title="futex_q">futex_q</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.__futex_unqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the futex_q from its futex_hash_bucket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>The futex_q to unqueue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The q-&gt;lock_ptr must not be NULL and must be held by the caller.</p>
</div>
<dl class="function">
<dt id="c.it_IT.futex_unqueue">
int <code class="sig-name descname">futex_unqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_q" title="futex_q">futex_q</a><em> *q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_unqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the futex_q from its futex_hash_bucket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>The futex_q to unqueue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The q-&gt;lock_ptr must not be held by the caller. A call to <a class="reference internal" href="#c.it_IT.futex_unqueue" title="it_IT.futex_unqueue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_unqueue()</span></code></a> must
be paired with exactly one earlier call to <a class="reference internal" href="#c.it_IT.futex_queue" title="it_IT.futex_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_queue()</span></code></a>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>1 - if the futex_q was still queued (and we removed unqueued it);</p></li>
<li><p>0 - if the futex_q was already removed by the waking thread</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.it_IT.futex_exit_recursive">
void <code class="sig-name descname">futex_exit_recursive</code><span class="sig-paren">(</span>struct task_struct<em> *tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_exit_recursive" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the tasks futex state to FUTEX_STATE_DEAD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*tsk</span></code></dt><dd><p>task to set the state on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the futex exit state of the task lockless. The futex waiter code
observes that state when a task is exiting and loops until the task has
actually finished the futex cleanup. The worst case for this is that the
waiter runs through the wait loop until the state becomes visible.</p>
<p>This is called from the recursive fault handling path in make_task_dead().</p>
<p>This is best effort. Either the futex exit code has run already or
not. If the OWNER_DIED bit has been set on the futex then the waiter can
take it over. If not, the problem is pushed back to user space. If the
futex exit code did not run yet, then an already queued waiter might
block forever, but there is nothing which can be done about that.</p>
</div>
<dl class="type">
<dt id="c.it_IT.futex_q">
struct <code class="sig-name descname">futex_q</code><a class="headerlink" href="#c.it_IT.futex_q" title="Permalink to this definition">¶</a></dt>
<dd><p>The hashed futex queue entry, one per waiting task</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct futex_q {
    struct plist_node list;
    struct task_struct *task;
    spinlock_t *lock_ptr;
    union futex_key key;
    struct futex_pi_state *pi_state;
    struct rt_mutex_waiter *rt_waiter;
    union futex_key *requeue_pi_key;
    u32 bitset;
    atomic_t requeue_state;
#ifdef CONFIG_PREEMPT_RT;
    struct rcuwait requeue_wait;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>priority-sorted list of tasks waiting on this futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">task</span></code></dt><dd><p>the task waiting on the futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock_ptr</span></code></dt><dd><p>the hash bucket lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>the key the futex is hashed on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pi_state</span></code></dt><dd><p>optional priority inheritance state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rt_waiter</span></code></dt><dd><p>rt_waiter storage for use with requeue_pi</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">requeue_pi_key</span></code></dt><dd><p>the requeue_pi target futex key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitset</span></code></dt><dd><p>bitset for the optional bitmasked wakeup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">requeue_state</span></code></dt><dd><p>State field for futex_requeue_pi()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">requeue_wait</span></code></dt><dd><p>RCU wait for futex_requeue_pi() (RT only)</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>We use this hashed waitqueue, instead of a normal wait_queue_entry_t, so
we can wake only the relevant ones (hashed queues may be shared).</p>
<p>A futex_q has a woken state, just like tasks have TASK_RUNNING.
It is considered woken when plist_node_empty(<code class="xref c c-type docutils literal notranslate"><span class="pre">q-&gt;list</span></code>) || q-&gt;lock_ptr == 0.
The order of wakeup is always to make the first condition true, then
the second.</p>
<p>PI futexes are typically woken before they are removed from the hash list via
the rt_mutex code. See futex_unqueue_pi().</p>
<dl class="function">
<dt id="c.it_IT.futex_match">
int <code class="sig-name descname">futex_match</code><span class="sig-paren">(</span>union futex_key<em> *key1</em>, union futex_key<em> *key2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether two futex keys are equal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key1</span></code></dt><dd><p>Pointer to key1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key2</span></code></dt><dd><p>Pointer to key2</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 1 if two futex_keys are equal, 0 otherwise.</p>
</div>
<dl class="function">
<dt id="c.it_IT.futex_queue">
void <code class="sig-name descname">futex_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, struct futex_hash_bucket<em> *hb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Enqueue the futex_q on the futex_hash_bucket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>The futex_q to enqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>The destination hash bucket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The hb-&gt;lock must be held by the caller, and is released here. A call to
<a class="reference internal" href="#c.it_IT.futex_queue" title="it_IT.futex_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_queue()</span></code></a> is typically paired with exactly one call to <a class="reference internal" href="#c.it_IT.futex_unqueue" title="it_IT.futex_unqueue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_unqueue()</span></code></a>.  The
exceptions involve the PI related operations, which may use futex_unqueue_pi()
or nothing if the unqueue is done as part of the wake process and the unqueue
state is implicit in the state of woken task (see <a class="reference internal" href="#c.it_IT.futex_wait_requeue_pi" title="it_IT.futex_wait_requeue_pi"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_wait_requeue_pi()</span></code></a> for
an example).</p>
</div>
<dl class="type">
<dt id="c.it_IT.futex_vector">
struct <code class="sig-name descname">futex_vector</code><a class="headerlink" href="#c.it_IT.futex_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Auxiliary struct for futex_waitv()</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct futex_vector {
    struct futex_waitv w;
    struct futex_q q;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">w</span></code></dt><dd><p>Userspace provided data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">q</span></code></dt><dd><p>Kernel side data</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Struct used to build an array with all data need for futex_waitv()</p>
<dl class="function">
<dt id="c.it_IT.futex_lock_pi_atomic">
int <code class="sig-name descname">futex_lock_pi_atomic</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em>, struct futex_hash_bucket<em> *hb</em>, union futex_key<em> *key</em>, struct futex_pi_state<em> **ps</em>, struct task_struct<em> *task</em>, struct task_struct<em> **exiting</em>, int<em> set_waiters</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_lock_pi_atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic work required to acquire a pi aware futex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>the pi futex user address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>the pi futex hash bucket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key</span></code></dt><dd><p>the futex key associated with uaddr and hb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_pi_state</span> <span class="pre">**ps</span></code></dt><dd><p>the pi_state pointer where we store the result of the
lookup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*task</span></code></dt><dd><p>the task to perform the atomic lock work for.  This will
be “current” except in the case of requeue pi.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">**exiting</span></code></dt><dd><p>Pointer to store the task pointer of the owner task
which is in the middle of exiting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">set_waiters</span></code></dt><dd><p>force setting the FUTEX_WAITERS bit (1) or not (0)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>0 - ready to wait;</p></li>
<li><p>1 - acquired the lock;</p></li>
<li><p>&lt;0 - error</p></li>
</ul>
</div></blockquote>
<p><strong>Description</strong></p>
<p>The hb-&gt;lock must be held by the caller.</p>
<p><strong>exiting</strong> is only set when the return value is -EBUSY. If so, this holds
a refcount on the exiting task on return and the caller needs to drop it
after waiting for the exit to complete.</p>
</div>
<dl class="function">
<dt id="c.it_IT.fixup_pi_owner">
int <code class="sig-name descname">fixup_pi_owner</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em>, struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, int<em> locked</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.fixup_pi_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Post lock pi_state and corner case management</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>user address of the futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>futex_q (contains pi_state and access to the rt_mutex)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">locked</span></code></dt><dd><p>if the attempt to take the rt_mutex succeeded (1) or not (0)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After attempting to lock an rt_mutex, this function is called to cleanup
the pi_state owner as well as handle race conditions that may allow us to
acquire the lock. Must be called with the hb lock held.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>1 - success, lock taken;</p></li>
<li><p>0 - success, lock not taken;</p></li>
<li><p>&lt;0 - on error (-EFAULT)</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.it_IT.requeue_futex">
void <code class="sig-name descname">requeue_futex</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, struct futex_hash_bucket<em> *hb1</em>, struct futex_hash_bucket<em> *hb2</em>, union futex_key<em> *key2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.requeue_futex" title="Permalink to this definition">¶</a></dt>
<dd><p>Requeue a futex_q from one hb to another</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>the futex_q to requeue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb1</span></code></dt><dd><p>the source hash_bucket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb2</span></code></dt><dd><p>the target hash_bucket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key2</span></code></dt><dd><p>the new key for the requeued futex_q</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.it_IT.requeue_pi_wake_futex">
void <code class="sig-name descname">requeue_pi_wake_futex</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, union futex_key<em> *key</em>, struct futex_hash_bucket<em> *hb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.requeue_pi_wake_futex" title="Permalink to this definition">¶</a></dt>
<dd><p>Wake a task that acquired the lock during requeue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>the futex_q</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key</span></code></dt><dd><p>the key of the requeue target futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>the hash_bucket of the requeue target futex</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During futex_requeue, with requeue_pi=1, it is possible to acquire the
target futex if it is uncontended or via a lock steal.</p>
<ol class="arabic simple">
<li><p>Set <strong>q</strong>::key to the requeue target futex key so the waiter can detect
the wakeup on the right futex.</p></li>
<li><p>Dequeue <strong>q</strong> from the hash bucket.</p></li>
<li><p>Set <strong>q</strong>::rt_waiter to NULL so the woken up task can detect atomic lock
acquisition.</p></li>
<li><p>Set the q-&gt;lock_ptr to the requeue target hb-&gt;lock for the case that
the waiter has to fixup the pi state.</p></li>
<li><p>Complete the requeue state so the waiter can make progress. After
this point the waiter task can return from the syscall immediately in
case that the pi state does not have to be fixed up.</p></li>
<li><p>Wake the waiter task.</p></li>
</ol>
<p>Must be called with both q-&gt;lock_ptr and hb-&gt;lock held.</p>
</div>
<dl class="function">
<dt id="c.it_IT.futex_proxy_trylock_atomic">
int <code class="sig-name descname">futex_proxy_trylock_atomic</code><span class="sig-paren">(</span>u32 __user<em> *pifutex</em>, struct futex_hash_bucket<em> *hb1</em>, struct futex_hash_bucket<em> *hb2</em>, union futex_key<em> *key1</em>, union futex_key<em> *key2</em>, struct futex_pi_state<em> **ps</em>, struct task_struct<em> **exiting</em>, int<em> set_waiters</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_proxy_trylock_atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt an atomic lock for the top waiter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*pifutex</span></code></dt><dd><p>the user address of the to futex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb1</span></code></dt><dd><p>the from futex hash bucket, must be locked by the caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb2</span></code></dt><dd><p>the to futex hash bucket, must be locked by the caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key1</span></code></dt><dd><p>the from futex key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*key2</span></code></dt><dd><p>the to futex key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_pi_state</span> <span class="pre">**ps</span></code></dt><dd><p>address to store the pi_state pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">**exiting</span></code></dt><dd><p>Pointer to store the task pointer of the owner task
which is in the middle of exiting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">set_waiters</span></code></dt><dd><p>force setting the FUTEX_WAITERS bit (1) or not (0)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try and get the lock on behalf of the top waiter if we can do it atomically.
Wake the top waiter if we succeed.  If the caller specified set_waiters,
then direct <a class="reference internal" href="#c.it_IT.futex_lock_pi_atomic" title="it_IT.futex_lock_pi_atomic"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_lock_pi_atomic()</span></code></a> to force setting the FUTEX_WAITERS bit.
hb1 and hb2 must be held by the caller.</p>
<p><strong>exiting</strong> is only set when the return value is -EBUSY. If so, this holds
a refcount on the exiting task on return and the caller needs to drop it
after waiting for the exit to complete.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>0 - failed to acquire the lock atomically;</p></li>
<li><p>&gt;0 - acquired the lock, return value is vpid of the top_waiter</p></li>
<li><p>&lt;0 - error</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.it_IT.futex_requeue">
int <code class="sig-name descname">futex_requeue</code><span class="sig-paren">(</span>u32 __user<em> *uaddr1</em>, unsigned int<em> flags</em>, u32 __user<em> *uaddr2</em>, int<em> nr_wake</em>, int<em> nr_requeue</em>, u32<em> *cmpval</em>, int<em> requeue_pi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_requeue" title="Permalink to this definition">¶</a></dt>
<dd><p>Requeue waiters from uaddr1 to uaddr2</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr1</span></code></dt><dd><p>source futex user address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>futex flags (FLAGS_SHARED, etc.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr2</span></code></dt><dd><p>target futex user address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_wake</span></code></dt><dd><p>number of waiters to wake (must be 1 for requeue_pi)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nr_requeue</span></code></dt><dd><p>number of waiters to requeue (0-INT_MAX)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*cmpval</span></code></dt><dd><p><strong>uaddr1</strong> expected value (or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">requeue_pi</span></code></dt><dd><p>if we are attempting to requeue from a non-pi futex to a
pi futex (pi to pi requeue is not supported)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Requeue waiters on uaddr1 to uaddr2. In the requeue_pi case, try to acquire
uaddr2 atomically on behalf of the top waiter.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>&gt;=0 - on success, the number of tasks requeued or woken;</p></li>
<li><p>&lt;0 - on error</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.it_IT.handle_early_requeue_pi_wakeup">
int <code class="sig-name descname">handle_early_requeue_pi_wakeup</code><span class="sig-paren">(</span>struct futex_hash_bucket<em> *hb</em>, struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, struct <a class="reference internal" href="../../../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.handle_early_requeue_pi_wakeup" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle early wakeup on the initial futex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>the hash_bucket futex_q was original enqueued on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>the futex_q woken while waiting to be requeued</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*timeout</span></code></dt><dd><p>the timeout associated with the wait (NULL if none)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the cause for the early wakeup.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p>-EWOULDBLOCK or -ETIMEDOUT or -ERESTARTNOINTR</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.it_IT.futex_wait_requeue_pi">
int <code class="sig-name descname">futex_wait_requeue_pi</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em>, unsigned int<em> flags</em>, u32<em> val</em>, ktime_t<em> *abs_time</em>, u32<em> bitset</em>, u32 __user<em> *uaddr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_wait_requeue_pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait on uaddr and take uaddr2</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>the futex we initially wait on (non-pi)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>futex flags (FLAGS_SHARED, FLAGS_CLOCKRT, etc.), they must be
the same type, no requeueing from private to shared, etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">val</span></code></dt><dd><p>the expected value of uaddr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ktime_t</span> <span class="pre">*abs_time</span></code></dt><dd><p>absolute timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">bitset</span></code></dt><dd><p>32 bit wakeup bitset set by userspace, defaults to all</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr2</span></code></dt><dd><p>the pi futex we will take prior to returning to user-space</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller will wait on uaddr and will be requeued by <a class="reference internal" href="#c.it_IT.futex_requeue" title="it_IT.futex_requeue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_requeue()</span></code></a> to
uaddr2 which must be PI aware and unique from uaddr.  Normal wakeup will wake
on uaddr2 and complete the acquisition of the rt_mutex prior to returning to
userspace.  This ensures the rt_mutex maintains an owner when it has waiters;
without one, the pi logic would not know which task to boost/deboost, if
there was a need to.</p>
<p>We call schedule in <a class="reference internal" href="#c.it_IT.futex_wait_queue" title="it_IT.futex_wait_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_wait_queue()</span></code></a> when we enqueue and return there
via the following–
1) wakeup on uaddr2 after an atomic lock acquisition by <a class="reference internal" href="#c.it_IT.futex_requeue" title="it_IT.futex_requeue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_requeue()</span></code></a>
2) wakeup on uaddr2 after a requeue
3) signal
4) timeout</p>
<p>If 3, cleanup and return -ERESTARTNOINTR.</p>
<p>If 2, we may then block on trying to take the rt_mutex and return via:
5) successful lock
6) signal
7) timeout
8) other lock acquisition failure</p>
<p>If 6, return -EWOULDBLOCK (restarting the syscall would do the same).</p>
<p>If 4 or 7, we cleanup and return with -ETIMEDOUT.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>0 - On success;</p></li>
<li><p>&lt;0 - On error</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.it_IT.futex_wait_queue">
void <code class="sig-name descname">futex_wait_queue</code><span class="sig-paren">(</span>struct futex_hash_bucket<em> *hb</em>, struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, struct <a class="reference internal" href="../../../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_wait_queue" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#c.it_IT.futex_queue" title="it_IT.futex_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">futex_queue()</span></code></a> and wait for wakeup, timeout, or signal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*hb</span></code></dt><dd><p>the futex hash bucket, must be locked by the caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>the futex_q to queue up on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*timeout</span></code></dt><dd><p>the prepared hrtimer_sleeper, or null for no timeout</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.it_IT.unqueue_multiple">
int <code class="sig-name descname">unqueue_multiple</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_vector" title="futex_vector">futex_vector</a><em> *v</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.unqueue_multiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove various futexes from their hash bucket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_vector</span> <span class="pre">*v</span></code></dt><dd><p>The list of futexes to unqueue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Number of futexes in the list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to unqueue a list of futexes. This can’t fail.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul>
<li><p>&gt;=0 - Index of the last futex that was awoken;</p></li>
<li><dl class="option-list">
<dt><kbd><span class="option">-1</span></kbd></dt>
<dd><ul class="simple">
<li><p>No futex was awoken</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.it_IT.futex_wait_multiple_setup">
int <code class="sig-name descname">futex_wait_multiple_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_vector" title="futex_vector">futex_vector</a><em> *vs</em>, int<em> count</em>, int<em> *woken</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_wait_multiple_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare to wait and enqueue multiple futexes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_vector</span> <span class="pre">*vs</span></code></dt><dd><p>The futex list to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>The size of the list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*woken</span></code></dt><dd><p>Index of the last woken futex, if any. Used to notify the
caller that it can return this index to userspace (return parameter)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepare multiple futexes in a single step and enqueue them. This may fail if
the futex list is invalid or if any futex was already awoken. On success the
task is ready to interruptible sleep.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>1 - One of the futexes was woken by another thread</p></li>
<li><p>0 - Success</p></li>
<li><p>&lt;0 - -EFAULT, -EWOULDBLOCK or -EINVAL</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.it_IT.futex_sleep_multiple">
void <code class="sig-name descname">futex_sleep_multiple</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_vector" title="futex_vector">futex_vector</a><em> *vs</em>, unsigned int<em> count</em>, struct <a class="reference internal" href="../../../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *to</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_sleep_multiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Check sleeping conditions and sleep</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_vector</span> <span class="pre">*vs</span></code></dt><dd><p>List of futexes to wait for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Length of vs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*to</span></code></dt><dd><p>Timeout</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sleep if and only if the timeout hasn’t expired and no futex on the list has
been woken up.</p>
</div>
<dl class="function">
<dt id="c.it_IT.futex_wait_multiple">
int <code class="sig-name descname">futex_wait_multiple</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_vector" title="futex_vector">futex_vector</a><em> *vs</em>, unsigned int<em> count</em>, struct <a class="reference internal" href="../../../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a><em> *to</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_wait_multiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare to wait on and enqueue several futexes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_vector</span> <span class="pre">*vs</span></code></dt><dd><p>The list of futexes to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>The number of objects</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*to</span></code></dt><dd><p>Timeout before giving up and returning to userspace</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Entry point for the FUTEX_WAIT_MULTIPLE futex operation, this function
sleeps on a group of futexes and returns on the first futex that is
wake, or after the timeout has elapsed.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>&gt;=0 - Hint to the futex that was awoken</p></li>
<li><p>&lt;0  - On error</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.it_IT.futex_wait_setup">
int <code class="sig-name descname">futex_wait_setup</code><span class="sig-paren">(</span>u32 __user<em> *uaddr</em>, u32<em> val</em>, unsigned int<em> flags</em>, struct <a class="reference internal" href="../../../kernel-hacking/locking.html#c.futex_q" title="futex_q">futex_q</a><em> *q</em>, struct futex_hash_bucket<em> **hb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.it_IT.futex_wait_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare to wait on a futex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*uaddr</span></code></dt><dd><p>the futex userspace address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">val</span></code></dt><dd><p>the expected value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>futex flags (FLAGS_SHARED, etc.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*q</span></code></dt><dd><p>the associated futex_q</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">**hb</span></code></dt><dd><p>storage for hash_bucket pointer to be returned to caller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Setup the futex_q and locate the hash_bucket.  Get the futex value and
compare it with the expected value.  Handle atomic faults internally.
Return with the hb lock held on success, and unlocked on failure.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>0 - uaddr contains val and hb has been locked;</p></li>
<li><p>&lt;1 - -EFAULT or -EWOULDBLOCK (uaddr does not contain val) and hb is unlocked</p></li>
</ul>
</div></blockquote>
</div>
</section>
<section id="approfondimenti">
<h2>Approfondimenti<a class="headerlink" href="#approfondimenti" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Documentation/locking/spinlocks.rst</span></code>: la guida di Linus Torvalds agli
spinlock del kernel.</p></li>
<li><p>Unix Systems for Modern Architectures: Symmetric Multiprocessing and
Caching for Kernel Programmers.</p>
<p>L’introduzione alla sincronizzazione a livello di kernel di Curt Schimmel
è davvero ottima (non è scritta per Linux, ma approssimativamente si adatta
a tutte le situazioni). Il libro è costoso, ma vale ogni singolo spicciolo
per capire la sincronizzazione nei sistemi multi-processore.
[ISBN: 0201633388]</p>
</li>
</ul>
</section>
<section id="ringraziamenti">
<h2>Ringraziamenti<a class="headerlink" href="#ringraziamenti" title="Permalink to this headline">¶</a></h2>
<p>Grazie a Telsa Gwynne per aver formattato questa guida in DocBook, averla
pulita e aggiunto un po’ di stile.</p>
<p>Grazie a Martin Pool, Philipp Rumpf, Stephen Rothwell, Paul Mackerras,
Ruedi Aschwanden, Alan Cox, Manfred Spraul, Tim Waugh, Pete Zaitcev,
James Morris, Robert Love, Paul McKenney, John Ashby per aver revisionato,
corretto, maledetto e commentato.</p>
<p>Grazie alla congrega per non aver avuto alcuna influenza su questo documento.</p>
</section>
<section id="glossario">
<h2>Glossario<a class="headerlink" href="#glossario" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>prelazione</dt><dd><p>Prima del kernel 2.5, o quando <code class="docutils literal notranslate"><span class="pre">CONFIG_PREEMPT</span></code> non è impostato, i processi
in contesto utente non si avvicendano nell’esecuzione (in pratica, il
processo userà il processore fino al proprio termine, a meno che non ci siano
delle interruzioni). Con l’aggiunta di <code class="docutils literal notranslate"><span class="pre">CONFIG_PREEMPT</span></code> nella versione
2.5.4 questo è cambiato: quando si è in contesto utente, processi con una
priorità maggiore possono subentrare nell’esecuzione: gli spinlock furono
cambiati per disabilitare la prelazioni, anche su sistemi monoprocessore.</p>
</dd>
<dt>bh</dt><dd><p>Bottom Half: per ragioni storiche, le funzioni che contengono ‘_bh’ nel
loro nome ora si riferiscono a qualsiasi interruzione software; per esempio,
spin_lock_bh() blocca qualsiasi interuzione software sul processore
corrente. I <em>Bottom Halves</em> sono deprecati, e probabilmente verranno
sostituiti dai tasklet. In un dato momento potrà esserci solo un
<em>bottom half</em> in esecuzione.</p>
</dd>
<dt>contesto d’interruzione</dt><dd><p>Non è il contesto utente: qui si processano le interruzioni hardware e
software. La macro in_interrupt() ritorna vero.</p>
</dd>
<dt>contesto utente</dt><dd><p>Il kernel che esegue qualcosa per conto di un particolare processo (per
esempio una chiamata di sistema) o di un thread del kernel. Potete
identificare il processo con la macro <code class="docutils literal notranslate"><span class="pre">current</span></code>. Da non confondere
con lo spazio utente. Può essere interrotto sia da interruzioni software
che hardware.</p>
</dd>
<dt>interruzione hardware</dt><dd><p>Richiesta di interruzione hardware. in_hardirq() ritorna vero in un
gestore d’interruzioni hardware.</p>
</dd>
<dt>interruzione software / softirq</dt><dd><p>Gestore di interruzioni software: in_hardirq() ritorna falso;
in_softirq() ritorna vero. I tasklet e le softirq sono entrambi
considerati ‘interruzioni software’.</p>
<p>In soldoni, un softirq è uno delle 32 interruzioni software che possono
essere eseguite su più processori in contemporanea. A volte si usa per
riferirsi anche ai tasklet (in pratica tutte le interruzioni software).</p>
</dd>
<dt>monoprocessore / UP</dt><dd><p>(Uni-Processor) un solo processore, ovvero non è SMP. (<code class="docutils literal notranslate"><span class="pre">CONFIG_SMP=n</span></code>).</p>
</dd>
<dt>multi-processore / SMP</dt><dd><p>(Symmetric Multi-Processor) kernel compilati per sistemi multi-processore
(<code class="docutils literal notranslate"><span class="pre">CONFIG_SMP=y</span></code>).</p>
</dd>
<dt>spazio utente</dt><dd><p>Un processo che esegue il proprio codice fuori dal kernel.</p>
</dd>
<dt>tasklet</dt><dd><p>Un’interruzione software registrabile dinamicamente che ha la garanzia
d’essere eseguita solo su un processore alla volta.</p>
</dd>
<dt>timer</dt><dd><p>Un’interruzione software registrabile dinamicamente che viene eseguita
(circa) in un determinato momento. Quando è in esecuzione è come un tasklet
(infatti, sono chiamati da <code class="docutils literal notranslate"><span class="pre">TIMER_SOFTIRQ</span></code>).</p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">L’inaffidabile guida alla sincronizzazione</a><ul>
<li><a class="reference internal" href="#introduzione">Introduzione</a></li>
<li><a class="reference internal" href="#il-problema-con-la-concorrenza">Il problema con la concorrenza</a><ul>
<li><a class="reference internal" href="#corse-critiche-e-sezioni-critiche">Corse critiche e sezioni critiche</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sincronizzazione-nel-kernel-linux">Sincronizzazione nel kernel Linux</a><ul>
<li><a class="reference internal" href="#i-due-principali-tipi-di-lock-nel-kernel-spinlock-e-mutex">I due principali tipi di <em>lock</em> nel kernel: spinlock e mutex</a></li>
<li><a class="reference internal" href="#i-lock-e-i-kernel-per-sistemi-monoprocessore">I <em>lock</em> e i kernel per sistemi monoprocessore</a></li>
<li><a class="reference internal" href="#sincronizzazione-in-contesto-utente">Sincronizzazione in contesto utente</a></li>
<li><a class="reference internal" href="#sincronizzazione-fra-il-contesto-utente-e-i-softirq">Sincronizzazione fra il contesto utente e i softirq</a></li>
<li><a class="reference internal" href="#sincronizzazione-fra-contesto-utente-e-i-tasklet">Sincronizzazione fra contesto utente e i tasklet</a></li>
<li><a class="reference internal" href="#sincronizzazione-fra-contesto-utente-e-i-timer">Sincronizzazione fra contesto utente e i timer</a></li>
<li><a class="reference internal" href="#sincronizzazione-fra-tasklet-e-timer">Sincronizzazione fra tasklet e timer</a><ul>
<li><a class="reference internal" href="#lo-stesso-tasklet-timer">Lo stesso tasklet/timer</a></li>
<li><a class="reference internal" href="#differenti-tasklet-timer">Differenti tasklet/timer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sincronizzazione-fra-softirq">Sincronizzazione fra softirq</a><ul>
<li><a class="reference internal" href="#lo-stesso-softirq">Lo stesso softirq</a></li>
<li><a class="reference internal" href="#diversi-softirqs">Diversi Softirqs</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#contesto-di-interruzione-hardware">Contesto di interruzione hardware</a><ul>
<li><a class="reference internal" href="#sincronizzazione-fra-interruzioni-hardware-e-softirq-tasklet">Sincronizzazione fra interruzioni hardware e softirq/tasklet</a></li>
<li><a class="reference internal" href="#sincronizzazione-fra-due-gestori-d-interruzioni-hardware">Sincronizzazione fra due gestori d’interruzioni hardware</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bigino-della-sincronizzazione">Bigino della sincronizzazione</a><ul>
<li><a class="reference internal" href="#tabella-dei-requisiti-minimi">Tabella dei requisiti minimi</a></li>
</ul>
</li>
<li><a class="reference internal" href="#le-funzioni-trylock">Le funzioni <em>trylock</em></a></li>
<li><a class="reference internal" href="#esempi-piu-comuni">Esempi più comuni</a><ul>
<li><a class="reference internal" href="#tutto-in-contesto-utente">Tutto in contesto utente</a></li>
<li><a class="reference internal" href="#accesso-dal-contesto-utente">Accesso dal contesto utente</a></li>
<li><a class="reference internal" href="#esporre-gli-oggetti-al-di-fuori-del-file">Esporre gli oggetti al di fuori del file</a><ul>
<li><a class="reference internal" href="#usare-operazioni-atomiche-per-il-contatore-di-riferimenti">Usare operazioni atomiche per il contatore di riferimenti</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proteggere-l-oggetto-stesso">Proteggere l’oggetto stesso</a></li>
</ul>
</li>
<li><a class="reference internal" href="#problemi-comuni">Problemi comuni</a><ul>
<li><a class="reference internal" href="#stallo-semplice-ed-avanzato">Stallo: semplice ed avanzato</a></li>
<li><a class="reference internal" href="#prevenire-gli-stalli">Prevenire gli stalli</a><ul>
<li><a class="reference internal" href="#ossessiva-prevenzione-degli-stalli">Ossessiva prevenzione degli stalli</a></li>
</ul>
</li>
<li><a class="reference internal" href="#corsa-fra-temporizzatori-un-passatempo-del-kernel">corsa fra temporizzatori: un passatempo del kernel</a></li>
</ul>
</li>
<li><a class="reference internal" href="#velocita-della-sincronizzazione">Velocità della sincronizzazione</a><ul>
<li><a class="reference internal" href="#read-write-lock-variants">Read/Write Lock Variants</a></li>
<li><a class="reference internal" href="#evitare-i-lock-read-copy-update">Evitare i <em>lock</em>: Read Copy Update</a></li>
<li><a class="reference internal" href="#dati-per-processore">Dati per processore</a></li>
<li><a class="reference internal" href="#dati-che-sono-usati-prevalentemente-dai-gestori-d-interruzioni">Dati che sono usati prevalentemente dai gestori d’interruzioni</a></li>
</ul>
</li>
<li><a class="reference internal" href="#quali-funzioni-possono-essere-chiamate-in-modo-sicuro-dalle-interruzioni">Quali funzioni possono essere chiamate in modo sicuro dalle interruzioni?</a><ul>
<li><a class="reference internal" href="#alcune-funzioni-che-dormono">Alcune funzioni che dormono</a></li>
<li><a class="reference internal" href="#alcune-funzioni-che-non-dormono">Alcune funzioni che non dormono</a></li>
</ul>
</li>
<li><a class="reference internal" href="#riferimento-per-l-api-dei-mutex">Riferimento per l’API dei Mutex</a></li>
<li><a class="reference internal" href="#riferimento-per-l-api-dei-futex">Riferimento per l’API dei Futex</a></li>
<li><a class="reference internal" href="#approfondimenti">Approfondimenti</a></li>
<li><a class="reference internal" href="#ringraziamenti">Ringraziamenti</a></li>
<li><a class="reference internal" href="#glossario">Glossario</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/translations/it_IT/kernel-hacking/locking.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/translations/it_IT/kernel-hacking/locking.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>