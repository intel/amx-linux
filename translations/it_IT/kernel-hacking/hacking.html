
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>L’inaffidabile guida all’hacking del kernel Linux &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="L’inaffidabile guida alla sincronizzazione" href="locking.html" />
    <link rel="prev" title="Guida all’hacking del kernel" href="index.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In caso di dubbi sulla correttezza del contenuto di questa traduzione,
l’unico riferimento valido è la documentazione ufficiale in inglese.
Per maggiori informazioni consultate le <a class="reference internal" href="../index.html#it-disclaimer"><span class="std std-ref">avvertenze</span></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Per leggere la documentazione originale in inglese:
<a class="reference internal" href="../../../kernel-hacking/hacking.html#kernel-hacking-hack"><span class="std std-ref">Documentation/kernel-hacking/hacking.rst</span></a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Original</dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../kernel-hacking/hacking.html#kernel-hacking-hack"><span class="std std-ref">Documentation/kernel-hacking/hacking.rst</span></a></p>
</dd>
<dt class="field-even">Translator</dt>
<dd class="field-even"><p>Federico Vaga &lt;<a class="reference external" href="mailto:federico&#46;vaga&#37;&#52;&#48;vaga&#46;pv&#46;it">federico<span>&#46;</span>vaga<span>&#64;</span>vaga<span>&#46;</span>pv<span>&#46;</span>it</a>&gt;</p>
</dd>
</dl>
<section id="l-inaffidabile-guida-all-hacking-del-kernel-linux">
<span id="it-kernel-hacking-hack"></span><h1>L’inaffidabile guida all’hacking del kernel Linux<a class="headerlink" href="#l-inaffidabile-guida-all-hacking-del-kernel-linux" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Rusty Russell</p>
</dd>
</dl>
<section id="introduzione">
<h2>Introduzione<a class="headerlink" href="#introduzione" title="Permalink to this headline">¶</a></h2>
<p>Benvenuto, gentile lettore, alla notevole ed inaffidabile guida all’hacking
del kernel Linux ad opera di Rusty. Questo documento descrive le procedure
più usate ed i concetti necessari per scrivere codice per il kernel: lo scopo
è di fornire ai programmatori C più esperti un manuale di base per sviluppo.
Eviterò dettagli implementativi: per questo abbiamo il codice,
ed ignorerò intere parti di alcune procedure.</p>
<p>Prima di leggere questa guida, sappiate che non ho mai voluto scriverla,
essendo esageratamente sotto qualificato, ma ho sempre voluto leggere
qualcosa di simile, e quindi questa era l’unica via. Spero che possa
crescere e diventare un compendio di buone pratiche, punti di partenza
e generiche informazioni.</p>
</section>
<section id="gli-attori">
<h2>Gli attori<a class="headerlink" href="#gli-attori" title="Permalink to this headline">¶</a></h2>
<p>In qualsiasi momento ognuna delle CPU di un sistema può essere:</p>
<ul class="simple">
<li><p>non associata ad alcun processo, servendo un’interruzione hardware;</p></li>
<li><p>non associata ad alcun processo, servendo un softirq o tasklet;</p></li>
<li><p>in esecuzione nello spazio kernel, associata ad un processo
(contesto utente);</p></li>
<li><p>in esecuzione di un processo nello spazio utente;</p></li>
</ul>
<p>Esiste un ordine fra questi casi. Gli ultimi due possono avvicendarsi (preempt)
l’un l’altro, ma a parte questo esiste una gerarchia rigida: ognuno di questi
può avvicendarsi solo ad uno di quelli sottostanti. Per esempio, mentre un
softirq è in esecuzione su d’una CPU, nessun altro softirq può avvicendarsi
nell’esecuzione, ma un’interruzione hardware può. Ciò nonostante, le altre CPU
del sistema operano indipendentemente.</p>
<p>Più avanti vedremo alcuni modi in cui dal contesto utente è possibile bloccare
le interruzioni, così da impedirne davvero il diritto di prelazione.</p>
<section id="contesto-utente">
<h3>Contesto utente<a class="headerlink" href="#contesto-utente" title="Permalink to this headline">¶</a></h3>
<p>Ci si trova nel contesto utente quando si arriva da una chiamata di sistema
od altre eccezioni: come nello spazio utente, altre procedure più importanti,
o le interruzioni, possono far valere il proprio diritto di prelazione sul
vostro processo. Potete sospendere l’esecuzione chiamando <code class="xref c c-func docutils literal notranslate"><span class="pre">schedule()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Si è sempre in contesto utente quando un modulo viene caricato o rimosso,
e durante le operazioni nello strato dei dispositivi a blocchi
(<em>block layer</em>).</p>
</div>
<p>Nel contesto utente, il puntatore <code class="docutils literal notranslate"><span class="pre">current</span></code> (il quale indica il processo al
momento in esecuzione) è valido, e <code class="xref c c-func docutils literal notranslate"><span class="pre">in_interrupt()</span></code>
(<code class="docutils literal notranslate"><span class="pre">include/linux/preempt.h</span></code>) è falsa.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Attenzione che se avete la prelazione o i softirq disabilitati (vedere
di seguito), <code class="xref c c-func docutils literal notranslate"><span class="pre">in_interrupt()</span></code> ritornerà un falso positivo.</p>
</div>
</section>
<section id="interruzioni-hardware-hard-irqs">
<h3>Interruzioni hardware (Hard IRQs)<a class="headerlink" href="#interruzioni-hardware-hard-irqs" title="Permalink to this headline">¶</a></h3>
<p>Temporizzatori, schede di rete e tastiere sono esempi di vero hardware
che possono produrre interruzioni in un qualsiasi momento. Il kernel esegue
i gestori d’interruzione che prestano un servizio all’hardware. Il kernel
garantisce che questi gestori non vengano mai interrotti: se una stessa
interruzione arriva, questa verrà accodata (o scartata).
Dato che durante la loro esecuzione le interruzioni vengono disabilitate,
i gestori d’interruzioni devono essere veloci: spesso si limitano
esclusivamente a notificare la presa in carico dell’interruzione,
programmare una ‘interruzione software’ per l’esecuzione e quindi terminare.</p>
<p>Potete dire d’essere in una interruzione hardware perché in_hardirq()
ritorna vero.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Attenzione, questa ritornerà un falso positivo se le interruzioni
sono disabilitate (vedere di seguito).</p>
</div>
</section>
<section id="contesto-d-interruzione-software-softirq-e-tasklet">
<h3>Contesto d’interruzione software: softirq e tasklet<a class="headerlink" href="#contesto-d-interruzione-software-softirq-e-tasklet" title="Permalink to this headline">¶</a></h3>
<p>Quando una chiamata di sistema sta per tornare allo spazio utente,
oppure un gestore d’interruzioni termina, qualsiasi ‘interruzione software’
marcata come pendente (solitamente da un’interruzione hardware) viene
eseguita (<code class="docutils literal notranslate"><span class="pre">kernel/softirq.c</span></code>).</p>
<p>La maggior parte del lavoro utile alla gestione di un’interruzione avviene qui.
All’inizio della transizione ai sistemi multiprocessore, c’erano solo i
cosiddetti ‘bottom half’ (BH), i quali non traevano alcun vantaggio da questi
sistemi. Non appena abbandonammo i computer raffazzonati con fiammiferi e
cicche, abbandonammo anche questa limitazione e migrammo alle interruzioni
software ‘softirqs’.</p>
<p>Il file <code class="docutils literal notranslate"><span class="pre">include/linux/interrupt.h</span></code> elenca i differenti tipi di ‘softirq’.
Un tipo di softirq molto importante è il timer (<code class="docutils literal notranslate"><span class="pre">include/linux/timer.h</span></code>):
potete programmarlo per far si che esegua funzioni dopo un determinato
periodo di tempo.</p>
<p>Dato che i softirq possono essere eseguiti simultaneamente su più di un
processore, spesso diventa estenuante l’averci a che fare. Per questa ragione,
i tasklet (<code class="docutils literal notranslate"><span class="pre">include/linux/interrupt.h</span></code>) vengo usati più di frequente:
possono essere registrati dinamicamente (il che significa che potete averne
quanti ne volete), e garantiscono che un qualsiasi tasklet verrà eseguito
solo su un processore alla volta, sebbene diversi tasklet possono essere
eseguiti simultaneamente.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Il nome ‘tasklet’ è ingannevole: non hanno niente a che fare
con i ‘processi’ (‘tasks’).</p>
</div>
<p>Potete determinate se siete in un softirq (o tasklet) utilizzando la
macro <code class="xref c c-func docutils literal notranslate"><span class="pre">in_softirq()</span></code> (<code class="docutils literal notranslate"><span class="pre">include/linux/preempt.h</span></code>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>State attenti che questa macro ritornerà un falso positivo
se <a class="reference internal" href="#it-local-bh-disable"><span class="std std-ref">botton half lock</span></a> è bloccato.</p>
</div>
</section>
</section>
<section id="alcune-regole-basilari">
<h2>Alcune regole basilari<a class="headerlink" href="#alcune-regole-basilari" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Nessuna protezione della memoria</dt><dd><p>Se corrompete la memoria, che sia in contesto utente o d’interruzione,
la macchina si pianterà. Siete sicuri che quello che volete fare
non possa essere fatto nello spazio utente?</p>
</dd>
<dt>Nessun numero in virgola mobile o MMX</dt><dd><p>Il contesto della FPU non è salvato; anche se siete in contesto utente
lo stato dell’FPU probabilmente non corrisponde a quello del processo
corrente: vi incasinerete con lo stato di qualche altro processo. Se
volete davvero usare la virgola mobile, allora dovrete salvare e recuperare
lo stato dell’FPU (ed evitare cambi di contesto). Generalmente è una
cattiva idea; usate l’aritmetica a virgola fissa.</p>
</dd>
<dt>Un limite rigido dello stack</dt><dd><p>A seconda della configurazione del kernel lo stack è fra 3K e 6K per la
maggior parte delle architetture a 32-bit; è di 14K per la maggior
parte di quelle a 64-bit; e spesso è condiviso con le interruzioni,
per cui non si può usare.
Evitare profonde ricorsioni ad enormi array locali nello stack
(allocateli dinamicamente).</p>
</dd>
<dt>Il kernel Linux è portabile</dt><dd><p>Quindi mantenetelo tale. Il vostro codice dovrebbe essere a 64-bit ed
indipendente dall’ordine dei byte (endianess) di un processore. Inoltre,
dovreste minimizzare il codice specifico per un processore; per esempio
il codice assembly dovrebbe essere incapsulato in modo pulito e minimizzato
per facilitarne la migrazione. Generalmente questo codice dovrebbe essere
limitato alla parte di kernel specifica per un’architettura.</p>
</dd>
</dl>
</section>
<section id="ioctl-non-scrivere-nuove-chiamate-di-sistema">
<h2>ioctl: non scrivere nuove chiamate di sistema<a class="headerlink" href="#ioctl-non-scrivere-nuove-chiamate-di-sistema" title="Permalink to this headline">¶</a></h2>
<p>Una chiamata di sistema, generalmente, è scritta così:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>asmlinkage long sys_mycall(int arg)
{
        return 0;
}
</pre></div>
</div>
<p>Primo, nella maggior parte dei casi non volete creare nuove chiamate di
sistema.
Create un dispositivo a caratteri ed implementate l’appropriata chiamata ioctl.
Questo meccanismo è molto più flessibile delle chiamate di sistema: esso non
dev’essere dichiarato in tutte le architetture nei file
<code class="docutils literal notranslate"><span class="pre">include/asm/unistd.h</span></code> e <code class="docutils literal notranslate"><span class="pre">arch/kernel/entry.S</span></code>; inoltre, è improbabile
che questo venga accettato da Linus.</p>
<p>Se tutto quello che il vostro codice fa è leggere o scrivere alcuni parametri,
considerate l’implementazione di un’interfaccia <code class="xref c c-func docutils literal notranslate"><span class="pre">sysfs()</span></code>.</p>
<p>All’interno di una ioctl vi trovate nel contesto utente di un processo. Quando
avviene un errore dovete ritornare un valore negativo di errno (consultate
<code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/errno-base.h</span></code>,
<code class="docutils literal notranslate"><span class="pre">include/uapi/asm-generic/errno.h</span></code> e <code class="docutils literal notranslate"><span class="pre">include/linux/errno.h</span></code>), altrimenti
ritornate 0.</p>
<p>Dopo aver dormito dovreste verificare se ci sono stati dei segnali: il modo
Unix/Linux di gestire un segnale è di uscire temporaneamente dalla chiamata
di sistema con l’errore <code class="docutils literal notranslate"><span class="pre">-ERESTARTSYS</span></code>. La chiamata di sistema ritornerà
al contesto utente, eseguirà il gestore del segnale e poi la vostra chiamata
di sistema riprenderà (a meno che l’utente non l’abbia disabilitata). Quindi,
dovreste essere pronti per continuare l’esecuzione, per esempio nel mezzo
della manipolazione di una struttura dati.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (signal_pending(current))
        return -ERESTARTSYS;
</pre></div>
</div>
<p>Se dovete eseguire dei calcoli molto lunghi: pensate allo spazio utente.
Se <strong>davvero</strong> volete farlo nel kernel ricordatevi di verificare periodicamente
se dovete <em>lasciare</em> il processore (ricordatevi che, per ogni processore, c’è
un sistema multi-processo senza diritto di prelazione).
Esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cond_resched(); /* Will sleep */
</pre></div>
</div>
<p>Una breve nota sulla progettazione delle interfacce: il motto dei sistemi
UNIX è “fornite meccanismi e non politiche”</p>
</section>
<section id="la-ricetta-per-uno-stallo">
<h2>La ricetta per uno stallo<a class="headerlink" href="#la-ricetta-per-uno-stallo" title="Permalink to this headline">¶</a></h2>
<p>Non è permesso invocare una procedura che potrebbe dormire, fanno eccezione
i seguenti casi:</p>
<ul class="simple">
<li><p>Siete in un contesto utente.</p></li>
<li><p>Non trattenete alcun spinlock.</p></li>
<li><p>Avete abilitato le interruzioni (in realtà, Andy Kleen dice che
lo schedulatore le abiliterà per voi, ma probabilmente questo non è quello
che volete).</p></li>
</ul>
<p>Da tener presente che alcune funzioni potrebbero dormire implicitamente:
le più comuni sono quelle per l’accesso allo spazio utente (*_user) e
quelle per l’allocazione della memoria senza l’opzione <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code></p>
<p>Dovreste sempre compilare il kernel con l’opzione <code class="docutils literal notranslate"><span class="pre">CONFIG_DEBUG_ATOMIC_SLEEP</span></code>
attiva, questa vi avviserà se infrangete una di queste regole.
Se <strong>infrangete</strong> le regole, allora potreste bloccare il vostro scatolotto.</p>
<p>Veramente.</p>
</section>
<section id="alcune-delle-procedure-piu-comuni">
<h2>Alcune delle procedure più comuni<a class="headerlink" href="#alcune-delle-procedure-piu-comuni" title="Permalink to this headline">¶</a></h2>
<section id="printk">
<h3><a class="reference internal" href="../../../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a><a class="headerlink" href="#printk" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/linux/printk.h</span></code></p>
<p><a class="reference internal" href="../../../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> fornisce messaggi alla console, dmesg, e al demone syslog.
Essa è utile per il debugging o per la notifica di errori; può essere
utilizzata anche all’interno del contesto d’interruzione, ma usatela con
cautela: una macchina che ha la propria console inondata da messaggi diventa
inutilizzabile. La funzione utilizza un formato stringa quasi compatibile con
la printf ANSI C, e la concatenazione di una stringa C come primo argomento
per indicare la “priorità”:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>printk(KERN_INFO &quot;i = %u\n&quot;, i);
</pre></div>
</div>
<p>Consultate <code class="docutils literal notranslate"><span class="pre">include/linux/kern_levels.h</span></code> per gli altri valori <code class="docutils literal notranslate"><span class="pre">KERN_</span></code>;
questi sono interpretati da syslog come livelli. Un caso speciale:
per stampare un indirizzo IP usate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__be32 ipaddress;
printk(KERN_INFO &quot;my ip: %pI4\n&quot;, &amp;ipaddress);
</pre></div>
</div>
<p><a class="reference internal" href="../../../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> utilizza un buffer interno di 1K e non s’accorge di
eventuali sforamenti. Accertatevi che vi basti.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Saprete di essere un vero hacker del kernel quando inizierete a digitare
nei vostri programmi utenti le printf come se fossero printk :)</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Un’altra nota a parte: la versione originale di Unix 6 aveva un commento
sopra alla funzione printf: “Printf non dovrebbe essere usata per il
chiacchiericcio”. Dovreste seguire questo consiglio.</p>
</div>
</section>
<section id="copy-to-user-copy-from-user-get-user-put-user">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">copy_to_user()</span></code> / <code class="xref c c-func docutils literal notranslate"><span class="pre">copy_from_user()</span></code> / <a class="reference internal" href="../../../core-api/mm-api.html#c.get_user" title="get_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_user()</span></code></a> / <a class="reference internal" href="../../../core-api/mm-api.html#c.put_user" title="put_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_user()</span></code></a><a class="headerlink" href="#copy-to-user-copy-from-user-get-user-put-user" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/linux/uaccess.h</span></code> / <code class="docutils literal notranslate"><span class="pre">asm/uaccess.h</span></code></p>
<p><strong>[DORMONO]</strong></p>
<p><a class="reference internal" href="../../../core-api/mm-api.html#c.put_user" title="put_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_user()</span></code></a> e <a class="reference internal" href="../../../core-api/mm-api.html#c.get_user" title="get_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_user()</span></code></a> sono usate per ricevere ed
impostare singoli valori (come int, char, o long) da e verso lo spazio utente.
Un puntatore nello spazio utente non dovrebbe mai essere dereferenziato: i dati
dovrebbero essere copiati usando suddette procedure. Entrambe ritornano
<code class="docutils literal notranslate"><span class="pre">-EFAULT</span></code> oppure 0.</p>
<p><code class="xref c c-func docutils literal notranslate"><span class="pre">copy_to_user()</span></code> e <code class="xref c c-func docutils literal notranslate"><span class="pre">copy_from_user()</span></code> sono più generiche:
esse copiano una quantità arbitraria di dati da e verso lo spazio utente.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Al contrario di:c:func:<cite><a class="reference internal" href="../../../core-api/mm-api.html#c.put_user" title="put_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_user()</span></code></a></cite> e <a class="reference internal" href="../../../core-api/mm-api.html#c.get_user" title="get_user"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_user()</span></code></a>, queste
funzioni ritornano la quantità di dati copiati (0 è comunque un successo).</p>
</div>
<p>[Sì, questa interfaccia mi imbarazza. La battaglia torna in auge anno
dopo anno. –RR]</p>
<p>Le funzioni potrebbero dormire implicitamente. Queste non dovrebbero mai essere
invocate fuori dal contesto utente (non ha senso), con le interruzioni
disabilitate, o con uno spinlock trattenuto.</p>
</section>
<section id="kmalloc-kfree">
<h3><a class="reference internal" href="../../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a>/<a class="reference internal" href="../../../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a><a class="headerlink" href="#kmalloc-kfree" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/linux/slab.h</span></code></p>
<p><strong>[POTREBBERO DORMIRE: LEGGI SOTTO]</strong></p>
<p>Queste procedure sono utilizzate per la richiesta dinamica di un puntatore ad
un pezzo di memoria allineato, esattamente come malloc e free nello spazio
utente, ma <a class="reference internal" href="../../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> ha un argomento aggiuntivo per indicare alcune
opzioni. Le opzioni più importanti sono:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code></dt><dd><p>Potrebbe dormire per librarare della memoria. L’opzione fornisce il modo
più affidabile per allocare memoria, ma il suo uso è strettamente limitato
allo spazio utente.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code></dt><dd><p>Non dorme. Meno affidabile di <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>, ma può essere usata in un
contesto d’interruzione. Dovreste avere <strong>davvero</strong> una buona strategia
per la gestione degli errori in caso di mancanza di memoria.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">GFP_DMA</span></code></dt><dd><p>Alloca memoria per il DMA sul bus ISA nello spazio d’indirizzamento
inferiore ai 16MB. Se non sapete cos’è allora non vi serve.
Molto inaffidabile.</p>
</dd>
</dl>
<p>Se vedete un messaggio d’avviso per una funzione dormiente che viene chiamata
da un contesto errato, allora probabilmente avete usato una funzione
d’allocazione dormiente da un contesto d’interruzione senza <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>.
Dovreste correggerlo. Sbrigatevi, non cincischiate.</p>
<p>Se allocate almeno <code class="docutils literal notranslate"><span class="pre">PAGE_SIZE``(``asm/page.h</span></code> o <code class="docutils literal notranslate"><span class="pre">asm/page_types.h</span></code>) byte,
considerate l’uso di <code class="xref c c-func docutils literal notranslate"><span class="pre">__get_free_pages()</span></code> (<code class="docutils literal notranslate"><span class="pre">include/linux/gfp.h</span></code>).
Accetta un argomento che definisce l’ordine (0 per per la dimensione di una
pagine, 1 per una doppia pagina, 2 per quattro pagine, eccetra) e le stesse
opzioni d’allocazione viste precedentemente.</p>
<p>Se state allocando un numero di byte notevolemnte superiore ad una pagina
potete usare <a class="reference internal" href="../../../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>. Essa allocherà memoria virtuale all’interno
dello spazio kernel. Questo è un blocco di memoria fisica non contiguo, ma
la MMU vi darà l’impressione che lo sia (quindi, sarà contiguo solo dal punto
di vista dei processori, non dal punto di vista dei driver dei dispositivi
esterni).
Se per qualche strana ragione avete davvero bisogno di una grossa quantità di
memoria fisica contigua, avete un problema: Linux non ha un buon supporto per
questo caso d’uso perché, dopo un po’ di tempo, la frammentazione della memoria
rende l’operazione difficile. Il modo migliore per allocare un simile blocco
all’inizio dell’avvio del sistema è attraverso la procedura
<code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_bootmem()</span></code>.</p>
<p>Prima di inventare la vostra cache per gli oggetti più usati, considerate
l’uso di una cache slab disponibile in <code class="docutils literal notranslate"><span class="pre">include/linux/slab.h</span></code>.</p>
</section>
<section id="current">
<h3><code class="xref c c-macro docutils literal notranslate"><span class="pre">current</span></code><a class="headerlink" href="#current" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/asm/current.h</span></code></p>
<p>Questa variabile globale (in realtà una macro) contiene un puntatore alla
struttura del processo corrente, quindi è valido solo dal contesto utente.
Per esempio, quando un processo esegue una chiamata di sistema, questo
punterà alla struttura dati del processo chiamate.
Nel contesto d’interruzione in suo valore <strong>non è NULL</strong>.</p>
</section>
<section id="mdelay-udelay">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">mdelay()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">udelay()</span></code><a class="headerlink" href="#mdelay-udelay" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/asm/delay.h</span></code> / <code class="docutils literal notranslate"><span class="pre">include/linux/delay.h</span></code></p>
<p>Le funzioni <code class="xref c c-func docutils literal notranslate"><span class="pre">udelay()</span></code> e <code class="xref c c-func docutils literal notranslate"><span class="pre">ndelay()</span></code> possono essere utilizzate
per brevi pause. Non usate grandi valori perché rischiate d’avere un
overflow - in questo contesto la funzione <code class="xref c c-func docutils literal notranslate"><span class="pre">mdelay()</span></code> è utile,
oppure considerate <a class="reference internal" href="../../../driver-api/basics.html#c.msleep" title="msleep"><code class="xref c c-func docutils literal notranslate"><span class="pre">msleep()</span></code></a>.</p>
</section>
<section id="cpu-to-be32-be32-to-cpu-cpu-to-le32-le32-to-cpu">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_to_be32()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">be32_to_cpu()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_to_le32()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">le32_to_cpu()</span></code><a class="headerlink" href="#cpu-to-be32-be32-to-cpu-cpu-to-le32-le32-to-cpu" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/asm/byteorder.h</span></code></p>
<p>La famiglia di funzioni <code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_to_be32()</span></code> (dove “32” può essere
sostituito da 64 o 16, e “be” con “le”) forniscono un modo generico
per fare conversioni sull’ordine dei byte (endianess): esse ritornano
il valore convertito. Tutte le varianti supportano anche il processo inverso:
<code class="xref c c-func docutils literal notranslate"><span class="pre">be32_to_cpu()</span></code>, eccetera.</p>
<p>Queste funzioni hanno principalmente due varianti: la variante per
puntatori, come <code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_to_be32p()</span></code>, che prende un puntatore
ad un tipo, e ritorna il valore convertito. L’altra variante per
la famiglia di conversioni “in-situ”, come <code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_to_be32s()</span></code>,
che convertono il valore puntato da un puntatore, e ritornano void.</p>
</section>
<section id="local-irq-save-local-irq-restore">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">local_irq_save()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">local_irq_restore()</span></code><a class="headerlink" href="#local-irq-save-local-irq-restore" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/linux/irqflags.h</span></code></p>
<p>Queste funzioni abilitano e disabilitano le interruzioni hardware
sul processore locale. Entrambe sono rientranti; esse salvano lo stato
precedente nel proprio argomento <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code>. Se sapete
che le interruzioni sono abilite, potete semplicemente utilizzare
<code class="xref c c-func docutils literal notranslate"><span class="pre">local_irq_disable()</span></code> e <code class="xref c c-func docutils literal notranslate"><span class="pre">local_irq_enable()</span></code>.</p>
</section>
<section id="local-bh-disable-local-bh-enable">
<span id="it-local-bh-disable"></span><h3><code class="xref c c-func docutils literal notranslate"><span class="pre">local_bh_disable()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">local_bh_enable()</span></code><a class="headerlink" href="#local-bh-disable-local-bh-enable" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/linux/bottom_half.h</span></code></p>
<p>Queste funzioni abilitano e disabilitano le interruzioni software
sul processore locale. Entrambe sono rientranti; se le interruzioni
software erano già state disabilitate in precedenza, rimarranno
disabilitate anche dopo aver invocato questa coppia di funzioni.
Lo scopo è di prevenire l’esecuzione di softirq e tasklet sul processore
attuale.</p>
</section>
<section id="smp-processor-id">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">smp_processor_id()</span></code><a class="headerlink" href="#smp-processor-id" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/linux/smp.h</span></code></p>
<p><code class="xref c c-func docutils literal notranslate"><span class="pre">get_cpu()</span></code> nega il diritto di prelazione (quindi non potete essere
spostati su un altro processore all’improvviso) e ritorna il numero
del processore attuale, fra 0 e <code class="docutils literal notranslate"><span class="pre">NR_CPUS</span></code>. Da notare che non è detto
che la numerazione dei processori sia continua. Quando avete terminato,
ritornate allo stato precedente con <code class="xref c c-func docutils literal notranslate"><span class="pre">put_cpu()</span></code>.</p>
<p>Se sapete che non dovete essere interrotti da altri processi (per esempio,
se siete in un contesto d’interruzione, o il diritto di prelazione
è disabilitato) potete utilizzare smp_processor_id().</p>
</section>
<section id="init-exit-initdata">
<h3><code class="docutils literal notranslate"><span class="pre">__init</span></code>/<code class="docutils literal notranslate"><span class="pre">__exit</span></code>/<code class="docutils literal notranslate"><span class="pre">__initdata</span></code><a class="headerlink" href="#init-exit-initdata" title="Permalink to this headline">¶</a></h3>
<p>Definite in  <code class="docutils literal notranslate"><span class="pre">include/linux/init.h</span></code></p>
<p>Dopo l’avvio, il kernel libera una sezione speciale; le funzioni marcate
con <code class="docutils literal notranslate"><span class="pre">__init</span></code> e le strutture dati marcate con <code class="docutils literal notranslate"><span class="pre">__initdata</span></code> vengono
eliminate dopo il completamento dell’avvio: in modo simile i moduli eliminano
questa memoria dopo l’inizializzazione. <code class="docutils literal notranslate"><span class="pre">__exit</span></code> viene utilizzato per
dichiarare che una funzione verrà utilizzata solo in fase di rimozione:
la detta funzione verrà eliminata quando il file che la contiene non è
compilato come modulo. Guardate l’header file per informazioni. Da notare che
non ha senso avere una funzione marcata come <code class="docutils literal notranslate"><span class="pre">__init</span></code> e al tempo stesso
esportata ai moduli utilizzando <code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL()</span></code> o
<code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_GPL()</span></code> - non funzionerà.</p>
</section>
<section id="initcall-module-init">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">__initcall()</span></code>/<a class="reference internal" href="../../../driver-api/basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a><a class="headerlink" href="#initcall-module-init" title="Permalink to this headline">¶</a></h3>
<p>Definite in  <code class="docutils literal notranslate"><span class="pre">include/linux/init.h</span></code> / <code class="docutils literal notranslate"><span class="pre">include/linux/module.h</span></code></p>
<p>Molte parti del kernel funzionano bene come moduli (componenti del kernel
caricabili dinamicamente). L’utilizzo delle macro <a class="reference internal" href="../../../driver-api/basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a>
e <a class="reference internal" href="../../../driver-api/basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a> semplifica la scrittura di codice che può funzionare
sia come modulo, sia come parte del kernel, senza l’ausilio di #ifdef.</p>
<p>La macro <a class="reference internal" href="../../../driver-api/basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> definisce quale funzione dev’essere
chiamata quando il modulo viene inserito (se il file è stato compilato come
tale), o in fase di avvio : se il file non è stato compilato come modulo la
macro <a class="reference internal" href="../../../driver-api/basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> diventa equivalente a <code class="xref c c-func docutils literal notranslate"><span class="pre">__initcall()</span></code>,
la quale, tramite qualche magia del linker, s’assicura che la funzione venga
chiamata durante l’avvio.</p>
<p>La funzione può ritornare un numero d’errore negativo per scatenare un
fallimento del caricamento (sfortunatamente, questo non ha effetto se il
modulo è compilato come parte integrante del kernel). Questa funzione è chiamata
in contesto utente con le interruzioni abilitate, quindi potrebbe dormire.</p>
</section>
<section id="module-exit">
<h3><a class="reference internal" href="../../../driver-api/basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a><a class="headerlink" href="#module-exit" title="Permalink to this headline">¶</a></h3>
<p>Definita in  <code class="docutils literal notranslate"><span class="pre">include/linux/module.h</span></code></p>
<p>Questa macro definisce la funzione che dev’essere chiamata al momento della
rimozione (o mai, nel caso in cui il file sia parte integrante del kernel).
Essa verrà chiamata solo quando il contatore d’uso del modulo raggiunge lo
zero. Questa funzione può anche dormire, ma non può fallire: tutto dev’essere
ripulito prima che la funzione ritorni.</p>
<p>Da notare che questa macro è opzionale: se non presente, il modulo non sarà
removibile (a meno che non usiate ‘rmmod -f’ ).</p>
</section>
<section id="try-module-get-module-put">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">try_module_get()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">module_put()</span></code><a class="headerlink" href="#try-module-get-module-put" title="Permalink to this headline">¶</a></h3>
<p>Definite in <code class="docutils literal notranslate"><span class="pre">include/linux/module.h</span></code></p>
<p>Queste funzioni maneggiano il contatore d’uso del modulo per proteggerlo dalla
rimozione (in aggiunta, un modulo non può essere rimosso se un altro modulo
utilizzo uno dei sui simboli esportati: vedere di seguito). Prima di eseguire
codice del modulo, dovreste chiamare <code class="xref c c-func docutils literal notranslate"><span class="pre">try_module_get()</span></code> su quel modulo:
se fallisce significa che il modulo è stato rimosso e dovete agire come se
non fosse presente. Altrimenti, potete accedere al modulo in sicurezza, e
chiamare <code class="xref c c-func docutils literal notranslate"><span class="pre">module_put()</span></code> quando avete finito.</p>
<p>La maggior parte delle strutture registrabili hanno un campo owner
(proprietario), come nella struttura
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file_operations</span></code>.
Impostate questo campo al valore della macro <code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code>.</p>
</section>
</section>
<section id="code-d-attesa-include-linux-wait-h">
<h2>Code d’attesa <code class="docutils literal notranslate"><span class="pre">include/linux/wait.h</span></code><a class="headerlink" href="#code-d-attesa-include-linux-wait-h" title="Permalink to this headline">¶</a></h2>
<p><strong>[DORMONO]</strong></p>
<p>Una coda d’attesa è usata per aspettare che qualcuno vi attivi quando una
certa condizione s’avvera. Per evitare corse critiche, devono essere usate
con cautela. Dichiarate una <code class="xref c c-type docutils literal notranslate"><span class="pre">wait_queue_head_t</span></code>, e poi i processi
che vogliono attendere il verificarsi di quella condizione dichiareranno
una <code class="xref c c-type docutils literal notranslate"><span class="pre">wait_queue_entry_t</span></code> facendo riferimento a loro stessi, poi
metteranno questa in coda.</p>
<section id="dichiarazione">
<h3>Dichiarazione<a class="headerlink" href="#dichiarazione" title="Permalink to this headline">¶</a></h3>
<p>Potere dichiarare una <code class="docutils literal notranslate"><span class="pre">wait_queue_head_t</span></code> utilizzando la macro
<code class="xref c c-func docutils literal notranslate"><span class="pre">DECLARE_WAIT_QUEUE_HEAD()</span></code> oppure utilizzando la procedura
<code class="xref c c-func docutils literal notranslate"><span class="pre">init_waitqueue_head()</span></code> nel vostro codice d’inizializzazione.</p>
</section>
<section id="accodamento">
<h3>Accodamento<a class="headerlink" href="#accodamento" title="Permalink to this headline">¶</a></h3>
<p>Mettersi in una coda d’attesa è piuttosto complesso, perché dovete
mettervi in coda prima di verificare la condizione. Esiste una macro
a questo scopo: <a class="reference internal" href="../../../driver-api/basics.html#c.wait_event_interruptible" title="wait_event_interruptible"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_event_interruptible()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">include/linux/wait.h</span></code>).
Il primo argomento è la testa della coda d’attesa, e il secondo è
un’espressione che dev’essere valutata; la macro ritorna 0 quando questa
espressione è vera, altrimenti <code class="docutils literal notranslate"><span class="pre">-ERESTARTSYS</span></code> se è stato ricevuto un segnale.
La versione <a class="reference internal" href="../../../driver-api/basics.html#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal notranslate"><span class="pre">wait_event()</span></code></a> ignora i segnali.</p>
</section>
<section id="svegliare-una-procedura-in-coda">
<h3>Svegliare una procedura in coda<a class="headerlink" href="#svegliare-una-procedura-in-coda" title="Permalink to this headline">¶</a></h3>
<p>Chiamate <code class="xref c c-func docutils literal notranslate"><span class="pre">wake_up()</span></code> (<code class="docutils literal notranslate"><span class="pre">include/linux/wait.h</span></code>); questa attiverà tutti
i processi in coda. Ad eccezione se uno di questi è impostato come
<code class="docutils literal notranslate"><span class="pre">TASK_EXCLUSIVE</span></code>, in questo caso i rimanenti non verranno svegliati.
Nello stesso header file esistono altre varianti di questa funzione.</p>
</section>
</section>
<section id="operazioni-atomiche">
<h2>Operazioni atomiche<a class="headerlink" href="#operazioni-atomiche" title="Permalink to this headline">¶</a></h2>
<p>Certe operazioni sono garantite come atomiche su tutte le piattaforme.
Il primo gruppo di operazioni utilizza <code class="xref c c-type docutils literal notranslate"><span class="pre">atomic_t</span></code>
(<code class="docutils literal notranslate"><span class="pre">include/asm/atomic.h</span></code>); questo contiene un intero con segno (minimo 32bit),
e dovete utilizzare queste funzione per modificare o leggere variabili di tipo
<code class="xref c c-type docutils literal notranslate"><span class="pre">atomic_t</span></code>. <code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_read()</span></code> e <code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_set()</span></code> leggono ed
impostano il contatore, <code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_add()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_sub()</span></code>,
<code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_inc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec()</span></code>, e
<code class="xref c c-func docutils literal notranslate"><span class="pre">atomic_dec_and_test()</span></code> (ritorna vero se raggiunge zero dopo essere
stata decrementata).</p>
<p>Sì. Ritorna vero (ovvero != 0) se la variabile atomica è zero.</p>
<p>Da notare che queste funzioni sono più lente rispetto alla normale aritmetica,
e quindi non dovrebbero essere usate a sproposito.</p>
<p>Il secondo gruppo di operazioni atomiche sono definite in
<code class="docutils literal notranslate"><span class="pre">include/linux/bitops.h</span></code> ed agiscono sui bit d’una variabile di tipo
<code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>. Queste operazioni prendono come argomento un puntatore
alla variabile, e un numero di bit dove 0 è quello meno significativo.
<a class="reference internal" href="../../../core-api/kernel-api.html#c.set_bit" title="set_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">set_bit()</span></code></a>, <a class="reference internal" href="../../../core-api/kernel-api.html#c.clear_bit" title="clear_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">clear_bit()</span></code></a> e <a class="reference internal" href="../../../core-api/kernel-api.html#c.change_bit" title="change_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">change_bit()</span></code></a>
impostano, cancellano, ed invertono il bit indicato.
<a class="reference internal" href="../../../core-api/kernel-api.html#c.test_and_set_bit" title="test_and_set_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">test_and_set_bit()</span></code></a>, <a class="reference internal" href="../../../core-api/kernel-api.html#c.test_and_clear_bit" title="test_and_clear_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">test_and_clear_bit()</span></code></a> e
<a class="reference internal" href="../../../core-api/kernel-api.html#c.test_and_change_bit" title="test_and_change_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">test_and_change_bit()</span></code></a> fanno la stessa cosa, ad eccezione che
ritornano vero se il bit era impostato; queste sono particolarmente
utili quando si vuole impostare atomicamente dei flag.</p>
<p>Con queste operazioni è possibile utilizzare indici di bit che eccedono
il valore <code class="docutils literal notranslate"><span class="pre">BITS_PER_LONG</span></code>. Il comportamento è strano sulle piattaforme
big-endian quindi è meglio evitarlo.</p>
</section>
<section id="simboli">
<h2>Simboli<a class="headerlink" href="#simboli" title="Permalink to this headline">¶</a></h2>
<p>All’interno del kernel, si seguono le normali regole del linker (ovvero,
a meno che un simbolo non venga dichiarato con visibilita limitata ad un
file con la parola chiave <code class="docutils literal notranslate"><span class="pre">static</span></code>, esso può essere utilizzato in qualsiasi
parte del kernel). Nonostante ciò, per i moduli, esiste una tabella dei
simboli esportati che limita i punti di accesso al kernel. Anche i moduli
possono esportare simboli.</p>
<section id="export-symbol">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL()</span></code><a class="headerlink" href="#export-symbol" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/linux/export.h</span></code></p>
<p>Questo è il classico metodo per esportare un simbolo: i moduli caricati
dinamicamente potranno utilizzare normalmente il simbolo.</p>
</section>
<section id="export-symbol-gpl">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_GPL()</span></code><a class="headerlink" href="#export-symbol-gpl" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/linux/export.h</span></code></p>
<p>Essa è simile a <code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL()</span></code> ad eccezione del fatto che i
simboli esportati con <code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_GPL()</span></code> possono essere
utilizzati solo dai moduli che hanno dichiarato una licenza compatibile
con la GPL attraverso <code class="xref c c-func docutils literal notranslate"><span class="pre">MODULE_LICENSE()</span></code>. Questo implica che la
funzione esportata è considerata interna, e non una vera e propria interfaccia.
Alcuni manutentori e sviluppatori potrebbero comunque richiedere
<code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_GPL()</span></code> quando si aggiungono nuove funzionalità o
interfacce.</p>
</section>
<section id="export-symbol-ns">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_NS()</span></code><a class="headerlink" href="#export-symbol-ns" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/linux/export.h</span></code></p>
<p>Questa è una variate di <cite>EXPORT_SYMBOL()</cite> che permette di specificare uno
spazio dei nomi. Lo spazio dei nomi è documentato in
<a class="reference internal" href="../core-api/symbol-namespaces.html"><span class="doc">Spazio dei nomi dei simboli</span></a>.</p>
</section>
<section id="export-symbol-ns-gpl">
<h3><code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_NS_GPL()</span></code><a class="headerlink" href="#export-symbol-ns-gpl" title="Permalink to this headline">¶</a></h3>
<p>Definita in <code class="docutils literal notranslate"><span class="pre">include/linux/export.h</span></code></p>
<p>Questa è una variate di <cite>EXPORT_SYMBOL_GPL()</cite> che permette di specificare uno
spazio dei nomi. Lo spazio dei nomi è documentato in
<a class="reference internal" href="../core-api/symbol-namespaces.html"><span class="doc">Spazio dei nomi dei simboli</span></a>.</p>
</section>
</section>
<section id="procedure-e-convenzioni">
<h2>Procedure e convenzioni<a class="headerlink" href="#procedure-e-convenzioni" title="Permalink to this headline">¶</a></h2>
<section id="liste-doppiamente-concatenate-include-linux-list-h">
<h3>Liste doppiamente concatenate <code class="docutils literal notranslate"><span class="pre">include/linux/list.h</span></code><a class="headerlink" href="#liste-doppiamente-concatenate-include-linux-list-h" title="Permalink to this headline">¶</a></h3>
<p>Un tempo negli header del kernel c’erano tre gruppi di funzioni per
le liste concatenate, ma questa è stata la vincente. Se non avete particolari
necessità per una semplice lista concatenata, allora questa è una buona scelta.</p>
<p>In particolare, <a class="reference internal" href="../../../core-api/kernel-api.html#c.list_for_each_entry" title="list_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry()</span></code></a> è utile.</p>
</section>
<section id="convenzione-dei-valori-di-ritorno">
<h3>Convenzione dei valori di ritorno<a class="headerlink" href="#convenzione-dei-valori-di-ritorno" title="Permalink to this headline">¶</a></h3>
<p>Per codice chiamato in contesto utente, è molto comune sfidare le convenzioni
C e ritornare 0 in caso di successo, ed un codice di errore negativo
(eg. <code class="docutils literal notranslate"><span class="pre">-EFAULT</span></code>) nei casi fallimentari. Questo potrebbe essere controintuitivo
a prima vista, ma è abbastanza diffuso nel kernel.</p>
<p>Utilizzate <code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code> (<code class="docutils literal notranslate"><span class="pre">include/linux/err.h</span></code>) per codificare
un numero d’errore negativo in un puntatore, e <code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code> e
<code class="xref c c-func docutils literal notranslate"><span class="pre">PTR_ERR()</span></code> per recuperarlo di nuovo: così si evita d’avere un
puntatore dedicato per il numero d’errore. Da brividi, ma in senso positivo.</p>
</section>
<section id="rompere-la-compilazione">
<h3>Rompere la compilazione<a class="headerlink" href="#rompere-la-compilazione" title="Permalink to this headline">¶</a></h3>
<p>Linus e gli altri sviluppatori a volte cambiano i nomi delle funzioni e
delle strutture nei kernel in sviluppo; questo non è solo per tenere
tutti sulle spine: questo riflette cambiamenti fondamentati (eg. la funzione
non può più essere chiamata con le funzioni attive, o fa controlli aggiuntivi,
o non fa più controlli che venivano fatti in precedenza). Solitamente a questo
s’accompagna un’adeguata e completa nota sulla lista di discussone
più adatta; cercate negli archivi. Solitamente eseguire una semplice
sostituzione su tutto un file rendere le cose <strong>peggiori</strong>.</p>
</section>
<section id="inizializzazione-dei-campi-d-una-struttura">
<h3>Inizializzazione dei campi d’una struttura<a class="headerlink" href="#inizializzazione-dei-campi-d-una-struttura" title="Permalink to this headline">¶</a></h3>
<p>Il metodo preferito per l’inizializzazione delle strutture è quello
di utilizzare gli inizializzatori designati, come definiti nello
standard ISO C99, eg:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct block_device_operations opt_fops = {
        .open               = opt_open,
        .release            = opt_release,
        .ioctl              = opt_ioctl,
        .check_media_change = opt_media_change,
};
</pre></div>
</div>
<p>Questo rende più facile la ricerca con grep, e rende più chiaro quale campo
viene impostato. Dovreste fare così perché si mostra meglio.</p>
</section>
<section id="estensioni-gnu">
<h3>Estensioni GNU<a class="headerlink" href="#estensioni-gnu" title="Permalink to this headline">¶</a></h3>
<p>Le estensioni GNU sono esplicitamente permesse nel kernel Linux. Da notare
che alcune delle più complesse non sono ben supportate, per via dello scarso
sviluppo, ma le seguenti sono da considerarsi la norma (per maggiori dettagli,
leggete la sezione “C Extensions” nella pagina info di GCC - Sì, davvero
la pagina info, la pagina man è solo un breve riassunto delle cose nella
pagina info).</p>
<ul class="simple">
<li><p>Funzioni inline</p></li>
<li><p>Istruzioni in espressioni (ie. il costrutto ({ and }) ).</p></li>
<li><p>Dichiarate attributi di una funzione / variabile / tipo
(__attribute__)</p></li>
<li><p>typeof</p></li>
<li><p>Array con lunghezza zero</p></li>
<li><p>Macro varargs</p></li>
<li><p>Aritmentica sui puntatori void</p></li>
<li><p>Inizializzatori non costanti</p></li>
<li><p>Istruzioni assembler (non al di fuori di ‘arch/’ e ‘include/asm/’)</p></li>
<li><p>Nomi delle funzioni come stringhe (__func__).</p></li>
<li><p>__builtin_constant_p()</p></li>
</ul>
<p>Siate sospettosi quando utilizzate long long nel kernel, il codice generato
da gcc è orribile ed anche peggio: le divisioni e le moltiplicazioni non
funzionano sulle piattaforme i386 perché le rispettive funzioni di runtime
di GCC non sono incluse nell’ambiente del kernel.</p>
</section>
<section id="c">
<h3>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h3>
<p>Solitamente utilizzare il C++ nel kernel è una cattiva idea perché
il kernel non fornisce il necessario ambiente di runtime e gli header file
non sono stati verificati. Rimane comunque possibile, ma non consigliato.
Se davvero volete usarlo, almeno evitate le eccezioni.</p>
</section>
<section id="numif">
<h3>NUMif<a class="headerlink" href="#numif" title="Permalink to this headline">¶</a></h3>
<p>Viene generalmente considerato più pulito l’uso delle macro negli header file
(o all’inizio dei file .c) per astrarre funzioni piuttosto che utlizzare
l’istruzione di pre-processore `#if’ all’interno del codice sorgente.</p>
</section>
</section>
<section id="mettere-le-vostre-cose-nel-kernel">
<h2>Mettere le vostre cose nel kernel<a class="headerlink" href="#mettere-le-vostre-cose-nel-kernel" title="Permalink to this headline">¶</a></h2>
<p>Al fine d’avere le vostre cose in ordine per l’inclusione ufficiale, o
anche per avere patch pulite, c’è del lavoro amministrativo da fare:</p>
<ul>
<li><p>Trovare chi è responsabile del codice che state modificando. Guardare in cima
ai file sorgenti, all’interno del file <code class="docutils literal notranslate"><span class="pre">MAINTAINERS</span></code>, ed alla fine
di tutti nel file <code class="docutils literal notranslate"><span class="pre">CREDITS</span></code>. Dovreste coordinarvi con queste persone
per evitare di duplicare gli sforzi, o provare qualcosa che è già stato
rigettato.</p>
<p>Assicuratevi di mettere il vostro nome ed indirizzo email in cima a
tutti i file che create o che maneggiate significativamente. Questo è
il primo posto dove le persone guarderanno quando troveranno un baco,
o quando <strong>loro</strong> vorranno fare una modifica.</p>
</li>
<li><p>Solitamente vorrete un’opzione di configurazione per la vostra modifica
al kernel. Modificate <code class="docutils literal notranslate"><span class="pre">Kconfig</span></code> nella cartella giusta. Il linguaggio
Config è facile con copia ed incolla, e c’è una completa documentazione
nel file <code class="docutils literal notranslate"><span class="pre">Documentation/kbuild/kconfig-language.rst</span></code>.</p>
<p>Nella descrizione della vostra opzione, assicuratevi di parlare sia agli
utenti esperti sia agli utente che non sanno nulla del vostro lavoro.
Menzionate qui le incompatibilità ed i problemi. Chiaramente la
descrizione deve terminare con “if in doubt, say N” (se siete in dubbio,
dite N) (oppure, occasionalmente, `Y’); questo è per le persone che non
hanno idea di che cosa voi stiate parlando.</p>
</li>
<li><p>Modificate il file <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>: le variabili CONFIG sono esportate qui,
quindi potete solitamente aggiungere una riga come la seguete
“obj-$(CONFIG_xxx) += xxx.o”. La sintassi è documentata nel file
<code class="docutils literal notranslate"><span class="pre">Documentation/kbuild/makefiles.rst</span></code>.</p></li>
<li><p>Aggiungete voi stessi in <code class="docutils literal notranslate"><span class="pre">CREDITS</span></code> se credete di aver fatto qualcosa di
notevole, solitamente qualcosa che supera il singolo file (comunque il vostro
nome dovrebbe essere all’inizio dei file sorgenti). <code class="docutils literal notranslate"><span class="pre">MAINTAINERS</span></code> significa
che volete essere consultati quando vengono fatte delle modifiche ad un
sottosistema, e quando ci sono dei bachi; questo implica molto di più di un
semplice impegno su una parte del codice.</p></li>
<li><p>Infine, non dimenticatevi di leggere
<code class="docutils literal notranslate"><span class="pre">Documentation/process/submitting-patches.rst</span></code>.</p></li>
</ul>
</section>
<section id="trucchetti-del-kernel">
<h2>Trucchetti del kernel<a class="headerlink" href="#trucchetti-del-kernel" title="Permalink to this headline">¶</a></h2>
<p>Dopo una rapida occhiata al codice, questi sono i preferiti. Sentitevi liberi
di aggiungerne altri.</p>
<p><code class="docutils literal notranslate"><span class="pre">arch/x86/include/asm/delay.h</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define ndelay(n) (__builtin_constant_p(n) ? \
        ((n) &gt; 20000 ? __bad_ndelay() : __const_udelay((n) * 5ul)) : \
        __ndelay(n))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">include/linux/fs.h</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
 * Kernel pointers have redundant information, so we can use a
 * scheme where we can return either an error code or a dentry
 * pointer with the same return value.
 *
 * This should be a per-architecture thing, to allow different
 * error and pointer decisions.
 */
 #define ERR_PTR(err)    ((void *)((long)(err)))
 #define PTR_ERR(ptr)    ((long)(ptr))
 #define IS_ERR(ptr)     ((unsigned long)(ptr) &gt; (unsigned long)(-1000))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">arch/x86/include/asm/uaccess_32.h:</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define copy_to_user(to,from,n)                         \
        (__builtin_constant_p(n) ?                      \
         __constant_copy_to_user((to),(from),(n)) :     \
         __generic_copy_to_user((to),(from),(n)))
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">arch/sparc/kernel/head.S:</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
 * Sun people can&#39;t spell worth damn. &quot;compatability&quot; indeed.
 * At least we *know* we can&#39;t spell, and use a spell-checker.
 */

/* Uh, actually Linus it is I who cannot spell. Too much murky
 * Sparc assembly will do this to ya.
 */
C_LABEL(cputypvar):
        .asciz &quot;compatibility&quot;

/* Tested on SS-5, SS-10. Probably someone at Sun applied a spell-checker. */
        .align 4
C_LABEL(cputypvar_sun4m):
        .asciz &quot;compatible&quot;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">arch/sparc/lib/checksum.S:</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Sun, you just can&#39;t beat me, you just can&#39;t.  Stop trying,
 * give up.  I&#39;m serious, I am going to kick the living shit
 * out of you, game over, lights out.
 */
</pre></div>
</div>
</section>
<section id="ringraziamenti">
<h2>Ringraziamenti<a class="headerlink" href="#ringraziamenti" title="Permalink to this headline">¶</a></h2>
<p>Ringrazio Andi Kleen per le sue idee, le risposte alle mie domande,
le correzioni dei miei errori, l’aggiunta di contenuti, eccetera.
Philipp Rumpf per l’ortografia e per aver reso più chiaro il testo, e
per alcuni eccellenti punti tutt’altro che ovvi. Werner Almesberger
per avermi fornito un ottimo riassunto di <a class="reference internal" href="../../../core-api/genericirq.html#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">disable_irq()</span></code></a>,
e Jes Sorensen e Andrea Arcangeli per le precisazioni. Michael Elizabeth
Chastain per aver verificato ed aggiunto la sezione configurazione.
Telsa Gwynne per avermi insegnato DocBook.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">L’inaffidabile guida all’hacking del kernel Linux</a><ul>
<li><a class="reference internal" href="#introduzione">Introduzione</a></li>
<li><a class="reference internal" href="#gli-attori">Gli attori</a><ul>
<li><a class="reference internal" href="#contesto-utente">Contesto utente</a></li>
<li><a class="reference internal" href="#interruzioni-hardware-hard-irqs">Interruzioni hardware (Hard IRQs)</a></li>
<li><a class="reference internal" href="#contesto-d-interruzione-software-softirq-e-tasklet">Contesto d’interruzione software: softirq e tasklet</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alcune-regole-basilari">Alcune regole basilari</a></li>
<li><a class="reference internal" href="#ioctl-non-scrivere-nuove-chiamate-di-sistema">ioctl: non scrivere nuove chiamate di sistema</a></li>
<li><a class="reference internal" href="#la-ricetta-per-uno-stallo">La ricetta per uno stallo</a></li>
<li><a class="reference internal" href="#alcune-delle-procedure-piu-comuni">Alcune delle procedure più comuni</a><ul>
<li><a class="reference internal" href="#printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a></li>
<li><a class="reference internal" href="#copy-to-user-copy-from-user-get-user-put-user"><code class="xref c c-func docutils literal notranslate"><span class="pre">copy_to_user()</span></code> / <code class="xref c c-func docutils literal notranslate"><span class="pre">copy_from_user()</span></code> / <code class="xref c c-func docutils literal notranslate"><span class="pre">get_user()</span></code> / <code class="xref c c-func docutils literal notranslate"><span class="pre">put_user()</span></code></a></li>
<li><a class="reference internal" href="#kmalloc-kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a></li>
<li><a class="reference internal" href="#current"><code class="xref c c-macro docutils literal notranslate"><span class="pre">current</span></code></a></li>
<li><a class="reference internal" href="#mdelay-udelay"><code class="xref c c-func docutils literal notranslate"><span class="pre">mdelay()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">udelay()</span></code></a></li>
<li><a class="reference internal" href="#cpu-to-be32-be32-to-cpu-cpu-to-le32-le32-to-cpu"><code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_to_be32()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">be32_to_cpu()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">cpu_to_le32()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">le32_to_cpu()</span></code></a></li>
<li><a class="reference internal" href="#local-irq-save-local-irq-restore"><code class="xref c c-func docutils literal notranslate"><span class="pre">local_irq_save()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">local_irq_restore()</span></code></a></li>
<li><a class="reference internal" href="#local-bh-disable-local-bh-enable"><code class="xref c c-func docutils literal notranslate"><span class="pre">local_bh_disable()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">local_bh_enable()</span></code></a></li>
<li><a class="reference internal" href="#smp-processor-id"><code class="xref c c-func docutils literal notranslate"><span class="pre">smp_processor_id()</span></code></a></li>
<li><a class="reference internal" href="#init-exit-initdata"><code class="docutils literal notranslate"><span class="pre">__init</span></code>/<code class="docutils literal notranslate"><span class="pre">__exit</span></code>/<code class="docutils literal notranslate"><span class="pre">__initdata</span></code></a></li>
<li><a class="reference internal" href="#initcall-module-init"><code class="xref c c-func docutils literal notranslate"><span class="pre">__initcall()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a></li>
<li><a class="reference internal" href="#module-exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a></li>
<li><a class="reference internal" href="#try-module-get-module-put"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_module_get()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">module_put()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#code-d-attesa-include-linux-wait-h">Code d’attesa <code class="docutils literal notranslate"><span class="pre">include/linux/wait.h</span></code></a><ul>
<li><a class="reference internal" href="#dichiarazione">Dichiarazione</a></li>
<li><a class="reference internal" href="#accodamento">Accodamento</a></li>
<li><a class="reference internal" href="#svegliare-una-procedura-in-coda">Svegliare una procedura in coda</a></li>
</ul>
</li>
<li><a class="reference internal" href="#operazioni-atomiche">Operazioni atomiche</a></li>
<li><a class="reference internal" href="#simboli">Simboli</a><ul>
<li><a class="reference internal" href="#export-symbol"><code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL()</span></code></a></li>
<li><a class="reference internal" href="#export-symbol-gpl"><code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_GPL()</span></code></a></li>
<li><a class="reference internal" href="#export-symbol-ns"><code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_NS()</span></code></a></li>
<li><a class="reference internal" href="#export-symbol-ns-gpl"><code class="xref c c-func docutils literal notranslate"><span class="pre">EXPORT_SYMBOL_NS_GPL()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#procedure-e-convenzioni">Procedure e convenzioni</a><ul>
<li><a class="reference internal" href="#liste-doppiamente-concatenate-include-linux-list-h">Liste doppiamente concatenate <code class="docutils literal notranslate"><span class="pre">include/linux/list.h</span></code></a></li>
<li><a class="reference internal" href="#convenzione-dei-valori-di-ritorno">Convenzione dei valori di ritorno</a></li>
<li><a class="reference internal" href="#rompere-la-compilazione">Rompere la compilazione</a></li>
<li><a class="reference internal" href="#inizializzazione-dei-campi-d-una-struttura">Inizializzazione dei campi d’una struttura</a></li>
<li><a class="reference internal" href="#estensioni-gnu">Estensioni GNU</a></li>
<li><a class="reference internal" href="#c">C++</a></li>
<li><a class="reference internal" href="#numif">NUMif</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mettere-le-vostre-cose-nel-kernel">Mettere le vostre cose nel kernel</a></li>
<li><a class="reference internal" href="#trucchetti-del-kernel">Trucchetti del kernel</a></li>
<li><a class="reference internal" href="#ringraziamenti">Ringraziamenti</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/translations/it_IT/kernel-hacking/hacking.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/translations/it_IT/kernel-hacking/hacking.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>