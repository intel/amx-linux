
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>ACPI Based Device Enumeration &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="ACPI _OSI and _REV methods" href="osi.html" />
    <link rel="prev" title="MDIO bus and PHYs in ACPI" href="dsd/phy.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="acpi-based-device-enumeration">
<h1>ACPI Based Device Enumeration<a class="headerlink" href="#acpi-based-device-enumeration" title="Permalink to this headline">¶</a></h1>
<p>ACPI 5 introduced a set of new resources (UartTSerialBus, I2cSerialBus,
SpiSerialBus, GpioIo and GpioInt) which can be used in enumerating slave
devices behind serial bus controllers.</p>
<p>In addition we are starting to see peripherals integrated in the
SoC/Chipset to appear only in ACPI namespace. These are typically devices
that are accessed through memory-mapped registers.</p>
<p>In order to support this and re-use the existing drivers as much as
possible we decided to do following:</p>
<blockquote>
<div><ul class="simple">
<li><p>Devices that have no bus connector resource are represented as
platform devices.</p></li>
<li><p>Devices behind real busses where there is a connector resource
are represented as <a class="reference internal" href="../../driver-api/spi.html#c.spi_device" title="spi_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">spi_device</span></code></a> or struct i2c_device. Note
that standard UARTs are not busses so there is no struct uart_device,
although some of them may be represented by struct serdev_device.</p></li>
</ul>
</div></blockquote>
<p>As both ACPI and Device Tree represent a tree of devices (and their
resources) this implementation follows the Device Tree way as much as
possible.</p>
<p>The ACPI implementation enumerates devices behind busses (platform, SPI,
I2C, and in some cases UART), creates the physical devices and binds them
to their ACPI handle in the ACPI namespace.</p>
<p>This means that when ACPI_HANDLE(dev) returns non-NULL the device was
enumerated from ACPI namespace. This handle can be used to extract other
device-specific configuration. There is an example of this below.</p>
<section id="platform-bus-support">
<h2>Platform bus support<a class="headerlink" href="#platform-bus-support" title="Permalink to this headline">¶</a></h2>
<p>Since we are using platform devices to represent devices that are not
connected to any physical bus we only need to implement a platform driver
for the device and add supported ACPI IDs. If this same IP-block is used on
some other non-ACPI platform, the driver might work out of the box or needs
some minor changes.</p>
<p>Adding ACPI support for an existing driver should be pretty
straightforward. Here is the simplest example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct acpi_device_id mydrv_acpi_match[] = {
        /* ACPI IDs here */
        { }
};
MODULE_DEVICE_TABLE(acpi, mydrv_acpi_match);

static struct platform_driver my_driver = {
        ...
        .driver = {
                .acpi_match_table = mydrv_acpi_match,
        },
};
</pre></div>
</div>
<p>If the driver needs to perform more complex initialization like getting and
configuring GPIOs it can get its ACPI handle and extract this information
from ACPI tables.</p>
</section>
<section id="dma-support">
<h2>DMA support<a class="headerlink" href="#dma-support" title="Permalink to this headline">¶</a></h2>
<p>DMA controllers enumerated via ACPI should be registered in the system to
provide generic access to their resources. For example, a driver that would
like to be accessible to slave devices via generic API call
dma_request_chan() must register itself at the end of the probe function like
this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = devm_acpi_dma_controller_register(dev, xlate_func, dw);
/* Handle the error if it&#39;s not a case of !CONFIG_ACPI */
</pre></div>
</div>
<p>and implement custom xlate function if needed (usually acpi_dma_simple_xlate()
is enough) which converts the FixedDMA resource provided by struct
acpi_dma_spec into the corresponding DMA channel. A piece of code for that case
could look like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#ifdef CONFIG_ACPI
struct filter_args {
        /* Provide necessary information for the filter_func */
        ...
};

static bool filter_func(struct dma_chan *chan, void *param)
{
        /* Choose the proper channel */
        ...
}

static struct dma_chan *xlate_func(struct acpi_dma_spec *dma_spec,
                struct acpi_dma *adma)
{
        dma_cap_mask_t cap;
        struct filter_args args;

        /* Prepare arguments for filter_func */
        ...
        return dma_request_channel(cap, filter_func, &amp;args);
}
#else
static struct dma_chan *xlate_func(struct acpi_dma_spec *dma_spec,
                struct acpi_dma *adma)
{
        return NULL;
}
#endif
</pre></div>
</div>
<p>dma_request_chan() will call xlate_func() for each registered DMA controller.
In the xlate function the proper channel must be chosen based on
information in struct acpi_dma_spec and the properties of the controller
provided by struct acpi_dma.</p>
<p>Clients must call dma_request_chan() with the string parameter that corresponds
to a specific FixedDMA resource. By default “tx” means the first entry of the
FixedDMA resource array, “rx” means the second entry. The table below shows a
layout:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Device (I2C0)
{
        ...
        Method (_CRS, 0, NotSerialized)
        {
                Name (DBUF, ResourceTemplate ()
                {
                        FixedDMA (0x0018, 0x0004, Width32bit, _Y48)
                        FixedDMA (0x0019, 0x0005, Width32bit, )
                })
        ...
        }
}
</pre></div>
</div>
<p>So, the FixedDMA with request line 0x0018 is “tx” and next one is “rx” in
this example.</p>
<p>In robust cases the client unfortunately needs to call
acpi_dma_request_slave_chan_by_index() directly and therefore choose the
specific FixedDMA resource by its index.</p>
</section>
<section id="named-interrupts">
<h2>Named Interrupts<a class="headerlink" href="#named-interrupts" title="Permalink to this headline">¶</a></h2>
<p>Drivers enumerated via ACPI can have names to interrupts in the ACPI table
which can be used to get the IRQ number in the driver.</p>
<p>The interrupt name can be listed in _DSD as ‘interrupt-names’. The names
should be listed as an array of strings which will map to the Interrupt()
resource in the ACPI table corresponding to its index.</p>
<p>The table below shows an example of its usage:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Device (DEV0) {
    ...
    Name (_CRS, ResourceTemplate() {
        ...
        Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) {
            0x20,
            0x24
        }
    })

    Name (_DSD, Package () {
        ToUUID(&quot;daffd814-6eba-4d8c-8a91-bc9bbf4aa301&quot;),
        Package () {
            Package () { &quot;interrupt-names&quot;, Package () { &quot;default&quot;, &quot;alert&quot; } },
        }
    ...
    })
}
</pre></div>
</div>
<p>The interrupt name ‘default’ will correspond to 0x20 in Interrupt()
resource and ‘alert’ to 0x24. Note that only the Interrupt() resource
is mapped and not GpioInt() or similar.</p>
<p>The driver can call the function - fwnode_irq_get_byname() with the fwnode
and interrupt name as arguments to get the corresponding IRQ number.</p>
</section>
<section id="spi-serial-bus-support">
<h2>SPI serial bus support<a class="headerlink" href="#spi-serial-bus-support" title="Permalink to this headline">¶</a></h2>
<p>Slave devices behind SPI bus have SpiSerialBus resource attached to them.
This is extracted automatically by the SPI core and the slave devices are
enumerated once spi_register_master() is called by the bus driver.</p>
<p>Here is what the ACPI namespace for a SPI slave might look like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Device (EEP0)
{
        Name (_ADR, 1)
        Name (_CID, Package () {
                &quot;ATML0025&quot;,
                &quot;AT25&quot;,
        })
        ...
        Method (_CRS, 0, NotSerialized)
        {
                SPISerialBus(1, PolarityLow, FourWireMode, 8,
                        ControllerInitiated, 1000000, ClockPolarityLow,
                        ClockPhaseFirst, &quot;\\_SB.PCI0.SPI1&quot;,)
        }
        ...
</pre></div>
</div>
<p>The SPI device drivers only need to add ACPI IDs in a similar way to
the platform device drivers. Below is an example where we add ACPI support
to at25 SPI eeprom driver (this is meant for the above ACPI snippet):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct acpi_device_id at25_acpi_match[] = {
        { &quot;AT25&quot;, 0 },
        { }
};
MODULE_DEVICE_TABLE(acpi, at25_acpi_match);

static struct spi_driver at25_driver = {
        .driver = {
                ...
                .acpi_match_table = at25_acpi_match,
        },
};
</pre></div>
</div>
<p>Note that this driver actually needs more information like page size of the
eeprom, etc. This information can be passed via _DSD method like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Device (EEP0)
{
        ...
        Name (_DSD, Package ()
        {
                ToUUID(&quot;daffd814-6eba-4d8c-8a91-bc9bbf4aa301&quot;),
                Package ()
                {
                        Package () { &quot;size&quot;, 1024 },
                        Package () { &quot;pagesize&quot;, 32 },
                        Package () { &quot;address-width&quot;, 16 },
                }
        })
}
</pre></div>
</div>
<p>Then the at25 SPI driver can get this configuration by calling device property
APIs during -&gt;probe() phase like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = device_property_read_u32(dev, &quot;size&quot;, &amp;size);
if (err)
        ...error handling...

err = device_property_read_u32(dev, &quot;pagesize&quot;, &amp;page_size);
if (err)
        ...error handling...

err = device_property_read_u32(dev, &quot;address-width&quot;, &amp;addr_width);
if (err)
        ...error handling...
</pre></div>
</div>
</section>
<section id="i2c-serial-bus-support">
<h2>I2C serial bus support<a class="headerlink" href="#i2c-serial-bus-support" title="Permalink to this headline">¶</a></h2>
<p>The slaves behind I2C bus controller only need to add the ACPI IDs like
with the platform and SPI drivers. The I2C core automatically enumerates
any slave devices behind the controller device once the adapter is
registered.</p>
<p>Below is an example of how to add ACPI support to the existing mpu3050
input driver:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct acpi_device_id mpu3050_acpi_match[] = {
        { &quot;MPU3050&quot;, 0 },
        { }
};
MODULE_DEVICE_TABLE(acpi, mpu3050_acpi_match);

static struct i2c_driver mpu3050_i2c_driver = {
        .driver = {
                .name   = &quot;mpu3050&quot;,
                .pm     = &amp;mpu3050_pm,
                .of_match_table = mpu3050_of_match,
                .acpi_match_table = mpu3050_acpi_match,
        },
        .probe          = mpu3050_probe,
        .remove         = mpu3050_remove,
        .id_table       = mpu3050_ids,
};
module_i2c_driver(mpu3050_i2c_driver);
</pre></div>
</div>
</section>
<section id="reference-to-pwm-device">
<h2>Reference to PWM device<a class="headerlink" href="#reference-to-pwm-device" title="Permalink to this headline">¶</a></h2>
<p>Sometimes a device can be a consumer of PWM channel. Obviously OS would like
to know which one. To provide this mapping the special property has been
introduced, i.e.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Device (DEV)
{
    Name (_DSD, Package ()
    {
        ToUUID(&quot;daffd814-6eba-4d8c-8a91-bc9bbf4aa301&quot;),
        Package () {
            Package () { &quot;compatible&quot;, Package () { &quot;pwm-leds&quot; } },
            Package () { &quot;label&quot;, &quot;alarm-led&quot; },
            Package () { &quot;pwms&quot;,
                Package () {
                    &quot;\\_SB.PCI0.PWM&quot;,  // &lt;PWM device reference&gt;
                    0,                 // &lt;PWM index&gt;
                    600000000,         // &lt;PWM period&gt;
                    0,                 // &lt;PWM flags&gt;
                }
            }
        }
    })
    ...
}
</pre></div>
</div>
<p>In the above example the PWM-based LED driver references to the PWM channel 0
of _SB.PCI0.PWM device with initial period setting equal to 600 ms (note that
value is given in nanoseconds).</p>
</section>
<section id="gpio-support">
<h2>GPIO support<a class="headerlink" href="#gpio-support" title="Permalink to this headline">¶</a></h2>
<p>ACPI 5 introduced two new resources to describe GPIO connections: GpioIo
and GpioInt. These resources can be used to pass GPIO numbers used by
the device to the driver. ACPI 5.1 extended this with _DSD (Device
Specific Data) which made it possible to name the GPIOs among other things.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Device (DEV)
{
        Method (_CRS, 0, NotSerialized)
        {
                Name (SBUF, ResourceTemplate()
                {
                        // Used to power on/off the device
                        GpioIo (Exclusive, PullNone, 0, 0, IoRestrictionOutputOnly,
                                &quot;\\_SB.PCI0.GPI0&quot;, 0, ResourceConsumer) { 85 }

                        // Interrupt for the device
                        GpioInt (Edge, ActiveHigh, ExclusiveAndWake, PullNone, 0,
                                 &quot;\\_SB.PCI0.GPI0&quot;, 0, ResourceConsumer) { 88 }
                }

                Return (SBUF)
        }

        // ACPI 5.1 _DSD used for naming the GPIOs
        Name (_DSD, Package ()
        {
                ToUUID(&quot;daffd814-6eba-4d8c-8a91-bc9bbf4aa301&quot;),
                Package ()
                {
                        Package () { &quot;power-gpios&quot;, Package () { ^DEV, 0, 0, 0 } },
                        Package () { &quot;irq-gpios&quot;, Package () { ^DEV, 1, 0, 0 } },
                }
        })
        ...
}
</pre></div>
</div>
<p>These GPIO numbers are controller relative and path “\_SB.PCI0.GPI0”
specifies the path to the controller. In order to use these GPIOs in Linux
we need to translate them to the corresponding Linux GPIO descriptors.</p>
<p>There is a standard GPIO API for that and it is documented in
Documentation/admin-guide/gpio/.</p>
<p>In the above example we can get the corresponding two GPIO descriptors with
a code like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/gpio/consumer.h&gt;
...

struct gpio_desc *irq_desc, *power_desc;

irq_desc = gpiod_get(dev, &quot;irq&quot;);
if (IS_ERR(irq_desc))
        /* handle error */

power_desc = gpiod_get(dev, &quot;power&quot;);
if (IS_ERR(power_desc))
        /* handle error */

/* Now we can use the GPIO descriptors */
</pre></div>
</div>
<p>There are also devm_* versions of these functions which release the
descriptors once the device is released.</p>
<p>See <a class="reference internal" href="gpio-properties.html"><span class="doc">_DSD Device Properties Related to GPIO</span></a> for more information
about the _DSD binding related to GPIOs.</p>
</section>
<section id="rs-485-support">
<h2>RS-485 support<a class="headerlink" href="#rs-485-support" title="Permalink to this headline">¶</a></h2>
<p>ACPI _DSD (Device Specific Data) can be used to describe RS-485 capability
of UART.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Device (DEV)
{
        ...

        // ACPI 5.1 _DSD used for RS-485 capabilities
        Name (_DSD, Package ()
        {
                ToUUID(&quot;daffd814-6eba-4d8c-8a91-bc9bbf4aa301&quot;),
                Package ()
                {
                        Package () {&quot;rs485-rts-active-low&quot;, Zero},
                        Package () {&quot;rs485-rx-active-high&quot;, Zero},
                        Package () {&quot;rs485-rx-during-tx&quot;, Zero},
                }
        })
        ...
</pre></div>
</div>
</section>
<section id="mfd-devices">
<h2>MFD devices<a class="headerlink" href="#mfd-devices" title="Permalink to this headline">¶</a></h2>
<p>The MFD devices register their children as platform devices. For the child
devices there needs to be an ACPI handle that they can use to reference
parts of the ACPI namespace that relate to them. In the Linux MFD subsystem
we provide two ways:</p>
<blockquote>
<div><ul class="simple">
<li><p>The children share the parent ACPI handle.</p></li>
<li><p>The MFD cell can specify the ACPI id of the device.</p></li>
</ul>
</div></blockquote>
<p>For the first case, the MFD drivers do not need to do anything. The
resulting child platform device will have its ACPI_COMPANION() set to point
to the parent device.</p>
<p>If the ACPI namespace has a device that we can match using an ACPI id or ACPI
adr, the cell should be set like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct mfd_cell_acpi_match my_subdevice_cell_acpi_match = {
        .pnpid = &quot;XYZ0001&quot;,
        .adr = 0,
};

static struct mfd_cell my_subdevice_cell = {
        .name = &quot;my_subdevice&quot;,
        /* set the resources relative to the parent */
        .acpi_match = &amp;my_subdevice_cell_acpi_match,
};
</pre></div>
</div>
<p>The ACPI id “XYZ0001” is then used to lookup an ACPI device directly under
the MFD device and if found, that ACPI companion device is bound to the
resulting child platform device.</p>
</section>
<section id="device-tree-namespace-link-device-id">
<h2>Device Tree namespace link device ID<a class="headerlink" href="#device-tree-namespace-link-device-id" title="Permalink to this headline">¶</a></h2>
<p>The Device Tree protocol uses device identification based on the “compatible”
property whose value is a string or an array of strings recognized as device
identifiers by drivers and the driver core.  The set of all those strings may be
regarded as a device identification namespace analogous to the ACPI/PNP device
ID namespace.  Consequently, in principle it should not be necessary to allocate
a new (and arguably redundant) ACPI/PNP device ID for a devices with an existing
identification string in the Device Tree (DT) namespace, especially if that ID
is only needed to indicate that a given device is compatible with another one,
presumably having a matching driver in the kernel already.</p>
<p>In ACPI, the device identification object called _CID (Compatible ID) is used to
list the IDs of devices the given one is compatible with, but those IDs must
belong to one of the namespaces prescribed by the ACPI specification (see
Section 6.1.2 of ACPI 6.0 for details) and the DT namespace is not one of them.
Moreover, the specification mandates that either a _HID or an _ADR identification
object be present for all ACPI objects representing devices (Section 6.1 of ACPI
6.0).  For non-enumerable bus types that object must be _HID and its value must
be a device ID from one of the namespaces prescribed by the specification too.</p>
<p>The special DT namespace link device ID, PRP0001, provides a means to use the
existing DT-compatible device identification in ACPI and to satisfy the above
requirements following from the ACPI specification at the same time.  Namely,
if PRP0001 is returned by _HID, the ACPI subsystem will look for the
“compatible” property in the device object’s _DSD and will use the value of that
property to identify the corresponding device in analogy with the original DT
device identification algorithm.  If the “compatible” property is not present
or its value is not valid, the device will not be enumerated by the ACPI
subsystem.  Otherwise, it will be enumerated automatically as a platform device
(except when an I2C or SPI link from the device to its parent is present, in
which case the ACPI core will leave the device enumeration to the parent’s
driver) and the identification strings from the “compatible” property value will
be used to find a driver for the device along with the device IDs listed by _CID
(if present).</p>
<p>Analogously, if PRP0001 is present in the list of device IDs returned by _CID,
the identification strings listed by the “compatible” property value (if present
and valid) will be used to look for a driver matching the device, but in that
case their relative priority with respect to the other device IDs listed by
_HID and _CID depends on the position of PRP0001 in the _CID return package.
Specifically, the device IDs returned by _HID and preceding PRP0001 in the _CID
return package will be checked first.  Also in that case the bus type the device
will be enumerated to depends on the device ID returned by _HID.</p>
<p>For example, the following ACPI sample might be used to enumerate an lm75-type
I2C temperature sensor and match it to the driver using the Device Tree
namespace link:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Device (TMP0)
{
        Name (_HID, &quot;PRP0001&quot;)
        Name (_DSD, Package () {
                ToUUID(&quot;daffd814-6eba-4d8c-8a91-bc9bbf4aa301&quot;),
                Package () {
                        Package () { &quot;compatible&quot;, &quot;ti,tmp75&quot; },
                }
        })
        Method (_CRS, 0, Serialized)
        {
                Name (SBUF, ResourceTemplate ()
                {
                        I2cSerialBusV2 (0x48, ControllerInitiated,
                                400000, AddressingMode7Bit,
                                &quot;\\_SB.PCI0.I2C1&quot;, 0x00,
                                ResourceConsumer, , Exclusive,)
                })
                Return (SBUF)
        }
}
</pre></div>
</div>
<p>It is valid to define device objects with a _HID returning PRP0001 and without
the “compatible” property in the _DSD or a _CID as long as one of their
ancestors provides a _DSD with a valid “compatible” property.  Such device
objects are then simply regarded as additional “blocks” providing hierarchical
configuration information to the driver of the composite ancestor device.</p>
<p>However, PRP0001 can only be returned from either _HID or _CID of a device
object if all of the properties returned by the _DSD associated with it (either
the _DSD of the device object itself or the _DSD of its ancestor in the
“composite device” case described above) can be used in the ACPI environment.
Otherwise, the _DSD itself is regarded as invalid and therefore the “compatible”
property returned by it is meaningless.</p>
<p>Refer to <a class="reference internal" href="DSD-properties-rules.html"><span class="doc">_DSD Device Properties Usage Rules</span></a> for more
information.</p>
</section>
<section id="pci-hierarchy-representation">
<h2>PCI hierarchy representation<a class="headerlink" href="#pci-hierarchy-representation" title="Permalink to this headline">¶</a></h2>
<p>Sometimes it could be useful to enumerate a PCI device, knowing its position on
the PCI bus.</p>
<p>For example, some systems use PCI devices soldered directly on the mother board,
in a fixed position (ethernet, Wi-Fi, serial ports, etc.). In this conditions it
is possible to refer to these PCI devices knowing their position on the PCI bus
topology.</p>
<p>To identify a PCI device, a complete hierarchical description is required, from
the chipset root port to the final device, through all the intermediate
bridges/switches of the board.</p>
<p>For example, let’s assume we have a system with a PCIe serial port, an
Exar XR17V3521, soldered on the main board. This UART chip also includes
16 GPIOs and we want to add the property <code class="docutils literal notranslate"><span class="pre">gpio-line-names</span></code> [1] to these pins.
In this case, the <code class="docutils literal notranslate"><span class="pre">lspci</span></code> output for this component is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>07:00.0 Serial controller: Exar Corp. XR17V3521 Dual PCIe UART (rev 03)
</pre></div>
</div>
<p>The complete <code class="docutils literal notranslate"><span class="pre">lspci</span></code> output (manually reduced in length) is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>00:00.0 Host bridge: Intel Corp... Host Bridge (rev 0d)
...
00:13.0 PCI bridge: Intel Corp... PCI Express Port A #1 (rev fd)
00:13.1 PCI bridge: Intel Corp... PCI Express Port A #2 (rev fd)
00:13.2 PCI bridge: Intel Corp... PCI Express Port A #3 (rev fd)
00:14.0 PCI bridge: Intel Corp... PCI Express Port B #1 (rev fd)
00:14.1 PCI bridge: Intel Corp... PCI Express Port B #2 (rev fd)
...
05:00.0 PCI bridge: Pericom Semiconductor Device 2404 (rev 05)
06:01.0 PCI bridge: Pericom Semiconductor Device 2404 (rev 05)
06:02.0 PCI bridge: Pericom Semiconductor Device 2404 (rev 05)
06:03.0 PCI bridge: Pericom Semiconductor Device 2404 (rev 05)
07:00.0 Serial controller: Exar Corp. XR17V3521 Dual PCIe UART (rev 03) &lt;-- Exar
...
</pre></div>
</div>
<p>The bus topology is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-[0000:00]-+-00.0
           ...
           +-13.0-[01]----00.0
           +-13.1-[02]----00.0
           +-13.2-[03]--
           +-14.0-[04]----00.0
           +-14.1-[05-09]----00.0-[06-09]--+-01.0-[07]----00.0 &lt;-- Exar
           |                               +-02.0-[08]----00.0
           |                               \-03.0-[09]--
           ...
           \-1f.1
</pre></div>
</div>
<p>To describe this Exar device on the PCI bus, we must start from the ACPI name
of the chipset bridge (also called “root port”) with address:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Bus: 0 - Device: 14 - Function: 1
</pre></div>
</div>
<p>To find this information, it is necessary to disassemble the BIOS ACPI tables,
in particular the DSDT (see also [2]):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mkdir ~/tables/
cd ~/tables/
acpidump &gt; acpidump
acpixtract -a acpidump
iasl -e ssdt?.* -d dsdt.dat
</pre></div>
</div>
<p>Now, in the dsdt.dsl, we have to search the device whose address is related to
0x14 (device) and 0x01 (function). In this case we can find the following
device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Scope (_SB.PCI0)
{
... other definitions follow ...
        Device (RP02)
        {
                Method (_ADR, 0, NotSerialized)  // _ADR: Address
                {
                        If ((RPA2 != Zero))
                        {
                                Return (RPA2) /* \RPA2 */
                        }
                        Else
                        {
                                Return (0x00140001)
                        }
                }
... other definitions follow ...
</pre></div>
</div>
<p>and the _ADR method [3] returns exactly the device/function couple that
we are looking for. With this information and analyzing the above <code class="docutils literal notranslate"><span class="pre">lspci</span></code>
output (both the devices list and the devices tree), we can write the following
ACPI description for the Exar PCIe UART, also adding the list of its GPIO line
names:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Scope (_SB.PCI0.RP02)
{
        Device (BRG1) //Bridge
        {
                Name (_ADR, 0x0000)

                Device (BRG2) //Bridge
                {
                        Name (_ADR, 0x00010000)

                        Device (EXAR)
                        {
                                Name (_ADR, 0x0000)

                                Name (_DSD, Package ()
                                {
                                        ToUUID(&quot;daffd814-6eba-4d8c-8a91-bc9bbf4aa301&quot;),
                                        Package ()
                                        {
                                                Package ()
                                                {
                                                        &quot;gpio-line-names&quot;,
                                                        Package ()
                                                        {
                                                                &quot;mode_232&quot;,
                                                                &quot;mode_422&quot;,
                                                                &quot;mode_485&quot;,
                                                                &quot;misc_1&quot;,
                                                                &quot;misc_2&quot;,
                                                                &quot;misc_3&quot;,
                                                                &quot;&quot;,
                                                                &quot;&quot;,
                                                                &quot;aux_1&quot;,
                                                                &quot;aux_2&quot;,
                                                                &quot;aux_3&quot;,
                                                        }
                                                }
                                        }
                                })
                        }
                }
        }
}
</pre></div>
</div>
<p>The location “_SB.PCI0.RP02” is obtained by the above investigation in the
dsdt.dsl table, whereas the device names “BRG1”, “BRG2” and “EXAR” are
created analyzing the position of the Exar UART in the PCI bus topology.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>[1] <a class="reference internal" href="gpio-properties.html"><span class="doc">_DSD Device Properties Related to GPIO</span></a></p>
<p>[2] <a class="reference internal" href="../../admin-guide/acpi/initrd_table_override.html"><span class="doc">Upgrading ACPI tables via initrd</span></a></p>
<dl class="simple">
<dt>[3] ACPI Specifications, Version 6.3 - Paragraph 6.1.1 _ADR Address)</dt><dd><p><a class="reference external" href="https://uefi.org/sites/default/files/resources/ACPI_6_3_May16.pdf">https://uefi.org/sites/default/files/resources/ACPI_6_3_May16.pdf</a>,
referenced 2020-11-18</p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ACPI Based Device Enumeration</a><ul>
<li><a class="reference internal" href="#platform-bus-support">Platform bus support</a></li>
<li><a class="reference internal" href="#dma-support">DMA support</a></li>
<li><a class="reference internal" href="#named-interrupts">Named Interrupts</a></li>
<li><a class="reference internal" href="#spi-serial-bus-support">SPI serial bus support</a></li>
<li><a class="reference internal" href="#i2c-serial-bus-support">I2C serial bus support</a></li>
<li><a class="reference internal" href="#reference-to-pwm-device">Reference to PWM device</a></li>
<li><a class="reference internal" href="#gpio-support">GPIO support</a></li>
<li><a class="reference internal" href="#rs-485-support">RS-485 support</a></li>
<li><a class="reference internal" href="#mfd-devices">MFD devices</a></li>
<li><a class="reference internal" href="#device-tree-namespace-link-device-id">Device Tree namespace link device ID</a></li>
<li><a class="reference internal" href="#pci-hierarchy-representation">PCI hierarchy representation</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/firmware-guide/acpi/enumeration.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/firmware-guide/acpi/enumeration.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>