
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Packet MMAP &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux Phonet protocol family" href="phonet.html" />
    <link rel="prev" title="Operational States" href="operstates.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="packet-mmap">
<h1>Packet MMAP<a class="headerlink" href="#packet-mmap" title="Permalink to this headline">¶</a></h1>
<section id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>This file documents the mmap() facility available with the PACKET
socket interface. This type of sockets is used for</p>
<ol class="lowerroman simple">
<li><p>capture network traffic with utilities like tcpdump,</p></li>
<li><p>transmit network traffic, or any other that needs raw
access to network interface.</p></li>
</ol>
<p>Howto can be found at:</p>
<blockquote>
<div><p><a class="reference external" href="https://sites.google.com/site/packetmmap/">https://sites.google.com/site/packetmmap/</a></p>
</div></blockquote>
<dl class="simple">
<dt>Please send your comments to</dt><dd><ul class="simple">
<li><p>Ulisses Alonso Camaró &lt;<a class="reference external" href="mailto:uaca&#37;&#52;&#48;i&#46;hate&#46;spam&#46;alumni&#46;uv&#46;es">uaca<span>&#64;</span>i<span>&#46;</span>hate<span>&#46;</span>spam<span>&#46;</span>alumni<span>&#46;</span>uv<span>&#46;</span>es</a>&gt;</p></li>
<li><p>Johann Baudy</p></li>
</ul>
</dd>
</dl>
</section>
<section id="why-use-packet-mmap">
<h2>Why use PACKET_MMAP<a class="headerlink" href="#why-use-packet-mmap" title="Permalink to this headline">¶</a></h2>
<p>Non PACKET_MMAP capture process (plain AF_PACKET) is very
inefficient. It uses very limited buffers and requires one system call to
capture each packet, it requires two if you want to get packet’s timestamp
(like libpcap always does).</p>
<p>On the other hand PACKET_MMAP is very efficient. PACKET_MMAP provides a size
configurable circular buffer mapped in user space that can be used to either
send or receive packets. This way reading packets just needs to wait for them,
most of the time there is no need to issue a single system call. Concerning
transmission, multiple packets can be sent through one system call to get the
highest bandwidth. By using a shared buffer between the kernel and the user
also has the benefit of minimizing packet copies.</p>
<p>It’s fine to use PACKET_MMAP to improve the performance of the capture and
transmission process, but it isn’t everything. At least, if you are capturing
at high speeds (this is relative to the cpu speed), you should check if the
device driver of your network interface card supports some sort of interrupt
load mitigation or (even better) if it supports NAPI, also make sure it is
enabled. For transmission, check the MTU (Maximum Transmission Unit) used and
supported by devices of your network. CPU IRQ pinning of your network interface
card can also be an advantage.</p>
</section>
<section id="how-to-use-mmap-to-improve-capture-process">
<h2>How to use mmap() to improve capture process<a class="headerlink" href="#how-to-use-mmap-to-improve-capture-process" title="Permalink to this headline">¶</a></h2>
<p>From the user standpoint, you should use the higher level libpcap library, which
is a de facto standard, portable across nearly all operating systems
including Win32.</p>
<p>Packet MMAP support was integrated into libpcap around the time of version 1.3.0;
TPACKET_V3 support was added in version 1.5.0</p>
</section>
<section id="how-to-use-mmap-directly-to-improve-capture-process">
<h2>How to use mmap() directly to improve capture process<a class="headerlink" href="#how-to-use-mmap-directly-to-improve-capture-process" title="Permalink to this headline">¶</a></h2>
<p>From the system calls stand point, the use of PACKET_MMAP involves
the following process:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[setup]     socket() -------&gt; creation of the capture socket
            setsockopt() ---&gt; allocation of the circular buffer (ring)
                              option: PACKET_RX_RING
            mmap() ---------&gt; mapping of the allocated buffer to the
                              user process

[capture]   poll() ---------&gt; to wait for incoming packets

[shutdown]  close() --------&gt; destruction of the capture socket and
                              deallocation of all associated
                              resources.
</pre></div>
</div>
<p>socket creation and destruction is straight forward, and is done
the same way with or without PACKET_MMAP:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fd = socket(PF_PACKET, mode, htons(ETH_P_ALL));
</pre></div>
</div>
<p>where mode is SOCK_RAW for the raw interface were link level
information can be captured or SOCK_DGRAM for the cooked
interface where link level information capture is not
supported and a link level pseudo-header is provided
by the kernel.</p>
<p>The destruction of the socket and all associated resources
is done by a simple call to close(fd).</p>
<p>Similarly as without PACKET_MMAP, it is possible to use one socket
for capture and transmission. This can be done by mapping the
allocated RX and TX buffer ring with a single mmap() call.
See “Mapping and use of the circular buffer (ring)”.</p>
<p>Next I will describe PACKET_MMAP settings and its constraints,
also the mapping of the circular buffer in the user process and
the use of this buffer.</p>
</section>
<section id="how-to-use-mmap-directly-to-improve-transmission-process">
<h2>How to use mmap() directly to improve transmission process<a class="headerlink" href="#how-to-use-mmap-directly-to-improve-transmission-process" title="Permalink to this headline">¶</a></h2>
<p>Transmission process is similar to capture as shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[setup]         socket() -------&gt; creation of the transmission socket
                setsockopt() ---&gt; allocation of the circular buffer (ring)
                                  option: PACKET_TX_RING
                bind() ---------&gt; bind transmission socket with a network interface
                mmap() ---------&gt; mapping of the allocated buffer to the
                                  user process

[transmission]  poll() ---------&gt; wait for free packets (optional)
                send() ---------&gt; send all packets that are set as ready in
                                  the ring
                                  The flag MSG_DONTWAIT can be used to return
                                  before end of transfer.

[shutdown]      close() --------&gt; destruction of the transmission socket and
                                  deallocation of all associated resources.
</pre></div>
</div>
<p>Socket creation and destruction is also straight forward, and is done
the same way as in capturing described in the previous paragraph:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fd = socket(PF_PACKET, mode, 0);
</pre></div>
</div>
<p>The protocol can optionally be 0 in case we only want to transmit
via this socket, which avoids an expensive call to packet_rcv().
In this case, you also need to bind(2) the TX_RING with sll_protocol = 0
set. Otherwise, htons(ETH_P_ALL) or any other protocol, for example.</p>
<p>Binding the socket to your network interface is mandatory (with zero copy) to
know the header size of frames used in the circular buffer.</p>
<p>As capture, each frame contains two parts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   --------------------
   | struct tpacket_hdr | Header. It contains the status of
   |                    | of this frame
   |--------------------|
   | data buffer        |
   .                    .  Data that will be sent over the network interface.
   .                    .
   --------------------

bind() associates the socket to your network interface thanks to
sll_ifindex parameter of struct sockaddr_ll.

Initialization example::

   struct sockaddr_ll my_addr;
   struct ifreq s_ifr;
   ...

   strscpy_pad (s_ifr.ifr_name, &quot;eth0&quot;, sizeof(s_ifr.ifr_name));

   /* get interface index of eth0 */
   ioctl(this-&gt;socket, SIOCGIFINDEX, &amp;s_ifr);

   /* fill sockaddr_ll struct to prepare binding */
   my_addr.sll_family = AF_PACKET;
   my_addr.sll_protocol = htons(ETH_P_ALL);
   my_addr.sll_ifindex =  s_ifr.ifr_ifindex;

   /* bind socket to eth0 */
   bind(this-&gt;socket, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr_ll));

A complete tutorial is available at: https://sites.google.com/site/packetmmap/
</pre></div>
</div>
<p>By default, the user should put data at:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>frame base + TPACKET_HDRLEN - sizeof(struct sockaddr_ll)
</pre></div>
</div>
<p>So, whatever you choose for the socket mode (SOCK_DGRAM or SOCK_RAW),
the beginning of the user data will be at:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>frame base + TPACKET_ALIGN(sizeof(struct tpacket_hdr))
</pre></div>
</div>
<p>If you wish to put user data at a custom offset from the beginning of
the frame (for payload alignment with SOCK_RAW mode for instance) you
can set tp_net (with SOCK_DGRAM) or tp_mac (with SOCK_RAW). In order
to make this work it must be enabled previously with setsockopt()
and the PACKET_TX_HAS_OFF option.</p>
</section>
<section id="packet-mmap-settings">
<h2>PACKET_MMAP settings<a class="headerlink" href="#packet-mmap-settings" title="Permalink to this headline">¶</a></h2>
<p>To setup PACKET_MMAP from user level code is done with a call like</p>
<blockquote>
<div><ul>
<li><p>Capture process:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>setsockopt(fd, SOL_PACKET, PACKET_RX_RING, (void *) &amp;req, sizeof(req))
</pre></div>
</div>
</li>
<li><p>Transmission process:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>setsockopt(fd, SOL_PACKET, PACKET_TX_RING, (void *) &amp;req, sizeof(req))
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p>The most significant argument in the previous call is the req parameter,
this parameter must to have the following structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct tpacket_req
{
    unsigned int    tp_block_size;  /* Minimal size of contiguous block */
    unsigned int    tp_block_nr;    /* Number of blocks */
    unsigned int    tp_frame_size;  /* Size of frame */
    unsigned int    tp_frame_nr;    /* Total number of frames */
};
</pre></div>
</div>
<p>This structure is defined in /usr/include/linux/if_packet.h and establishes a
circular buffer (ring) of unswappable memory.
Being mapped in the capture process allows reading the captured frames and
related meta-information like timestamps without requiring a system call.</p>
<p>Frames are grouped in blocks. Each block is a physically contiguous
region of memory and holds tp_block_size/tp_frame_size frames. The total number
of blocks is tp_block_nr. Note that tp_frame_nr is a redundant parameter because:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>frames_per_block = tp_block_size/tp_frame_size
</pre></div>
</div>
<p>indeed, packet_set_ring checks that the following condition is true:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>frames_per_block * tp_block_nr == tp_frame_nr
</pre></div>
</div>
<p>Lets see an example, with the following values:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tp_block_size= 4096
tp_frame_size= 2048
tp_block_nr  = 4
tp_frame_nr  = 8
</pre></div>
</div>
<p>we will get the following buffer structure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        block #1                 block #2
+---------+---------+    +---------+---------+
| frame 1 | frame 2 |    | frame 3 | frame 4 |
+---------+---------+    +---------+---------+

        block #3                 block #4
+---------+---------+    +---------+---------+
| frame 5 | frame 6 |    | frame 7 | frame 8 |
+---------+---------+    +---------+---------+
</pre></div>
</div>
<p>A frame can be of any size with the only condition it can fit in a block. A block
can only hold an integer number of frames, or in other words, a frame cannot
be spawned across two blocks, so there are some details you have to take into
account when choosing the frame_size. See “Mapping and use of the circular
buffer (ring)”.</p>
</section>
<section id="packet-mmap-setting-constraints">
<h2>PACKET_MMAP setting constraints<a class="headerlink" href="#packet-mmap-setting-constraints" title="Permalink to this headline">¶</a></h2>
<p>In kernel versions prior to 2.4.26 (for the 2.4 branch) and 2.6.5 (2.6 branch),
the PACKET_MMAP buffer could hold only 32768 frames in a 32 bit architecture or
16384 in a 64 bit architecture.</p>
<section id="block-size-limit">
<h3>Block size limit<a class="headerlink" href="#block-size-limit" title="Permalink to this headline">¶</a></h3>
<p>As stated earlier, each block is a contiguous physical region of memory. These
memory regions are allocated with calls to the __get_free_pages() function. As
the name indicates, this function allocates pages of memory, and the second
argument is “order” or a power of two number of pages, that is
(for PAGE_SIZE == 4096) order=0 ==&gt; 4096 bytes, order=1 ==&gt; 8192 bytes,
order=2 ==&gt; 16384 bytes, etc. The maximum size of a
region allocated by __get_free_pages is determined by the MAX_ORDER macro. More
precisely the limit can be calculated as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PAGE_SIZE &lt;&lt; MAX_ORDER

In a i386 architecture PAGE_SIZE is 4096 bytes
In a 2.4/i386 kernel MAX_ORDER is 10
In a 2.6/i386 kernel MAX_ORDER is 11
</pre></div>
</div>
<p>So get_free_pages can allocate as much as 4MB or 8MB in a 2.4/2.6 kernel
respectively, with an i386 architecture.</p>
<p>User space programs can include /usr/include/sys/user.h and
/usr/include/linux/mmzone.h to get PAGE_SIZE MAX_ORDER declarations.</p>
<p>The pagesize can also be determined dynamically with the getpagesize (2)
system call.</p>
</section>
<section id="block-number-limit">
<h3>Block number limit<a class="headerlink" href="#block-number-limit" title="Permalink to this headline">¶</a></h3>
<p>To understand the constraints of PACKET_MMAP, we have to see the structure
used to hold the pointers to each block.</p>
<p>Currently, this structure is a dynamically allocated vector with kmalloc
called pg_vec, its size limits the number of blocks that can be allocated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+---+---+---+---+
| x | x | x | x |
+---+---+---+---+
  |   |   |   |
  |   |   |   v
  |   |   v  block #4
  |   v  block #3
  v  block #2
 block #1
</pre></div>
</div>
<p>kmalloc allocates any number of bytes of physically contiguous memory from
a pool of pre-determined sizes. This pool of memory is maintained by the slab
allocator which is at the end the responsible for doing the allocation and
hence which imposes the maximum memory that kmalloc can allocate.</p>
<p>In a 2.4/2.6 kernel and the i386 architecture, the limit is 131072 bytes. The
predetermined sizes that kmalloc uses can be checked in the “size-&lt;bytes&gt;”
entries of /proc/slabinfo</p>
<p>In a 32 bit architecture, pointers are 4 bytes long, so the total number of
pointers to blocks is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>131072/4 = 32768 blocks
</pre></div>
</div>
</section>
</section>
<section id="packet-mmap-buffer-size-calculator">
<h2>PACKET_MMAP buffer size calculator<a class="headerlink" href="#packet-mmap-buffer-size-calculator" title="Permalink to this headline">¶</a></h2>
<p>Definitions:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>&lt;size-max&gt;</p></td>
<td><p>is the maximum size of allocable with kmalloc
(see /proc/slabinfo)</p></td>
</tr>
<tr class="row-even"><td><p>&lt;pointer size&gt;</p></td>
<td><p>depends on the architecture – <code class="docutils literal notranslate"><span class="pre">sizeof(void</span> <span class="pre">*)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>&lt;page size&gt;</p></td>
<td><p>depends on the architecture – PAGE_SIZE or getpagesize (2)</p></td>
</tr>
<tr class="row-even"><td><p>&lt;max-order&gt;</p></td>
<td><p>is the value defined with MAX_ORDER</p></td>
</tr>
<tr class="row-odd"><td><p>&lt;frame size&gt;</p></td>
<td><p>it’s an upper bound of frame’s capture size (more on this later)</p></td>
</tr>
</tbody>
</table>
<p>from these definitions we will derive:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;block number&gt; = &lt;size-max&gt;/&lt;pointer size&gt;
&lt;block size&gt; = &lt;pagesize&gt; &lt;&lt; &lt;max-order&gt;
</pre></div>
</div>
<p>so, the max buffer size is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;block number&gt; * &lt;block size&gt;
</pre></div>
</div>
<p>and, the number of frames be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;block number&gt; * &lt;block size&gt; / &lt;frame size&gt;
</pre></div>
</div>
<p>Suppose the following parameters, which apply for 2.6 kernel and an
i386 architecture:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;size-max&gt; = 131072 bytes
&lt;pointer size&gt; = 4 bytes
&lt;pagesize&gt; = 4096 bytes
&lt;max-order&gt; = 11
</pre></div>
</div>
<p>and a value for &lt;frame size&gt; of 2048 bytes. These parameters will yield:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;block number&gt; = 131072/4 = 32768 blocks
&lt;block size&gt; = 4096 &lt;&lt; 11 = 8 MiB.
</pre></div>
</div>
<p>and hence the buffer will have a 262144 MiB size. So it can hold
262144 MiB / 2048 bytes = 134217728 frames</p>
<p>Actually, this buffer size is not possible with an i386 architecture.
Remember that the memory is allocated in kernel space, in the case of
an i386 kernel’s memory size is limited to 1GiB.</p>
<p>All memory allocations are not freed until the socket is closed. The memory
allocations are done with GFP_KERNEL priority, this basically means that
the allocation can wait and swap other process’ memory in order to allocate
the necessary memory, so normally limits can be reached.</p>
<section id="other-constraints">
<h3>Other constraints<a class="headerlink" href="#other-constraints" title="Permalink to this headline">¶</a></h3>
<p>If you check the source code you will see that what I draw here as a frame
is not only the link level frame. At the beginning of each frame there is a
header called struct tpacket_hdr used in PACKET_MMAP to hold link level’s frame
meta information like timestamp. So what we draw here a frame it’s really
the following (from include/linux/if_packet.h):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*
  Frame structure:

  - Start. Frame must be aligned to TPACKET_ALIGNMENT=16
  - struct tpacket_hdr
  - pad to TPACKET_ALIGNMENT=16
  - struct sockaddr_ll
  - Gap, chosen so that packet data (Start+tp_net) aligns to
    TPACKET_ALIGNMENT=16
  - Start+tp_mac: [ Optional MAC header ]
  - Start+tp_net: Packet data, aligned to TPACKET_ALIGNMENT=16.
  - Pad to align to TPACKET_ALIGNMENT=16
*/
</pre></div>
</div>
<p>The following are conditions that are checked in packet_set_ring</p>
<blockquote>
<div><ul class="simple">
<li><p>tp_block_size must be a multiple of PAGE_SIZE (1)</p></li>
<li><p>tp_frame_size must be greater than TPACKET_HDRLEN (obvious)</p></li>
<li><p>tp_frame_size must be a multiple of TPACKET_ALIGNMENT</p></li>
<li><p>tp_frame_nr   must be exactly frames_per_block*tp_block_nr</p></li>
</ul>
</div></blockquote>
<p>Note that tp_block_size should be chosen to be a power of two or there will
be a waste of memory.</p>
</section>
<section id="mapping-and-use-of-the-circular-buffer-ring">
<h3>Mapping and use of the circular buffer (ring)<a class="headerlink" href="#mapping-and-use-of-the-circular-buffer-ring" title="Permalink to this headline">¶</a></h3>
<p>The mapping of the buffer in the user process is done with the conventional
mmap function. Even the circular buffer is compound of several physically
discontiguous blocks of memory, they are contiguous to the user space, hence
just one call to mmap is needed:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
</pre></div>
</div>
<p>If tp_frame_size is a divisor of tp_block_size frames will be
contiguously spaced by tp_frame_size bytes. If not, each
tp_block_size/tp_frame_size frames there will be a gap between
the frames. This is because a frame cannot be spawn across two
blocks.</p>
<p>To use one socket for capture and transmission, the mapping of both the
RX and TX buffer ring has to be done with one call to mmap:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>...
setsockopt(fd, SOL_PACKET, PACKET_RX_RING, &amp;foo, sizeof(foo));
setsockopt(fd, SOL_PACKET, PACKET_TX_RING, &amp;bar, sizeof(bar));
...
rx_ring = mmap(0, size * 2, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
tx_ring = rx_ring + size;
</pre></div>
</div>
<p>RX must be the first as the kernel maps the TX ring memory right
after the RX one.</p>
<p>At the beginning of each frame there is an status field (see
struct tpacket_hdr). If this field is 0 means that the frame is ready
to be used for the kernel, If not, there is a frame the user can read
and the following flags apply:</p>
<section id="capture-process">
<h4>Capture process<a class="headerlink" href="#capture-process" title="Permalink to this headline">¶</a></h4>
<p>From include/linux/if_packet.h:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define TP_STATUS_COPY          (1 &lt;&lt; 1)
#define TP_STATUS_LOSING        (1 &lt;&lt; 2)
#define TP_STATUS_CSUMNOTREADY  (1 &lt;&lt; 3)
#define TP_STATUS_CSUM_VALID    (1 &lt;&lt; 7)
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>TP_STATUS_COPY</p></td>
<td><p>This flag indicates that the frame (and associated
meta information) has been truncated because it’s
larger than tp_frame_size. This packet can be
read entirely with recvfrom().</p>
<p>In order to make this work it must to be
enabled previously with setsockopt() and
the PACKET_COPY_THRESH option.</p>
<p>The number of frames that can be buffered to
be read with recvfrom is limited like a normal socket.
See the SO_RCVBUF option in the socket (7) man page.</p>
</td>
</tr>
<tr class="row-even"><td><p>TP_STATUS_LOSING</p></td>
<td><p>indicates there were packet drops from last time
statistics where checked with getsockopt() and
the PACKET_STATISTICS option.</p></td>
</tr>
<tr class="row-odd"><td><p>TP_STATUS_CSUMNOTREADY</p></td>
<td><p>currently it’s used for outgoing IP packets which
its checksum will be done in hardware. So while
reading the packet we should not try to check the
checksum.</p></td>
</tr>
<tr class="row-even"><td><p>TP_STATUS_CSUM_VALID</p></td>
<td><p>This flag indicates that at least the transport
header checksum of the packet has been already
validated on the kernel side. If the flag is not set
then we are free to check the checksum by ourselves
provided that TP_STATUS_CSUMNOTREADY is also not set.</p></td>
</tr>
</tbody>
</table>
<p>for convenience there are also the following defines:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define TP_STATUS_KERNEL        0
#define TP_STATUS_USER          1
</pre></div>
</div>
<p>The kernel initializes all frames to TP_STATUS_KERNEL, when the kernel
receives a packet it puts in the buffer and updates the status with
at least the TP_STATUS_USER flag. Then the user can read the packet,
once the packet is read the user must zero the status field, so the kernel
can use again that frame buffer.</p>
<p>The user can use poll (any other variant should apply too) to check if new
packets are in the ring:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pollfd pfd;

pfd.fd = fd;
pfd.revents = 0;
pfd.events = POLLIN|POLLRDNORM|POLLERR;

if (status == TP_STATUS_KERNEL)
    retval = poll(&amp;pfd, 1, timeout);
</pre></div>
</div>
<p>It doesn’t incur in a race condition to first check the status value and
then poll for frames.</p>
</section>
<section id="transmission-process">
<h4>Transmission process<a class="headerlink" href="#transmission-process" title="Permalink to this headline">¶</a></h4>
<p>Those defines are also used for transmission:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define TP_STATUS_AVAILABLE        0 // Frame is available
#define TP_STATUS_SEND_REQUEST     1 // Frame will be sent on next send()
#define TP_STATUS_SENDING          2 // Frame is currently in transmission
#define TP_STATUS_WRONG_FORMAT     4 // Frame format is not correct
</pre></div>
</div>
<p>First, the kernel initializes all frames to TP_STATUS_AVAILABLE. To send a
packet, the user fills a data buffer of an available frame, sets tp_len to
current data buffer size and sets its status field to TP_STATUS_SEND_REQUEST.
This can be done on multiple frames. Once the user is ready to transmit, it
calls send(). Then all buffers with status equal to TP_STATUS_SEND_REQUEST are
forwarded to the network device. The kernel updates each status of sent
frames with TP_STATUS_SENDING until the end of transfer.</p>
<p>At the end of each transfer, buffer status returns to TP_STATUS_AVAILABLE.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>header-&gt;tp_len = in_i_size;
header-&gt;tp_status = TP_STATUS_SEND_REQUEST;
retval = send(this-&gt;socket, NULL, 0, 0);
</pre></div>
</div>
<p>The user can also use poll() to check if a buffer is available:</p>
<p>(status == TP_STATUS_SENDING)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pollfd pfd;
pfd.fd = fd;
pfd.revents = 0;
pfd.events = POLLOUT;
retval = poll(&amp;pfd, 1, timeout);
</pre></div>
</div>
</section>
</section>
</section>
<section id="what-tpacket-versions-are-available-and-when-to-use-them">
<h2>What TPACKET versions are available and when to use them?<a class="headerlink" href="#what-tpacket-versions-are-available-and-when-to-use-them" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int val = tpacket_version;
setsockopt(fd, SOL_PACKET, PACKET_VERSION, &amp;val, sizeof(val));
getsockopt(fd, SOL_PACKET, PACKET_VERSION, &amp;val, sizeof(val));
</pre></div>
</div>
<p>where ‘tpacket_version’ can be TPACKET_V1 (default), TPACKET_V2, TPACKET_V3.</p>
<dl>
<dt>TPACKET_V1:</dt><dd><ul class="simple">
<li><p>Default if not otherwise specified by setsockopt(2)</p></li>
<li><p>RX_RING, TX_RING available</p></li>
</ul>
</dd>
<dt>TPACKET_V1 –&gt; TPACKET_V2:</dt><dd><ul>
<li><p>Made 64 bit clean due to unsigned long usage in TPACKET_V1
structures, thus this also works on 64 bit kernel with 32 bit
userspace and the like</p></li>
<li><p>Timestamp resolution in nanoseconds instead of microseconds</p></li>
<li><p>RX_RING, TX_RING available</p></li>
<li><p>VLAN metadata information available for packets
(TP_STATUS_VLAN_VALID, TP_STATUS_VLAN_TPID_VALID),
in the tpacket2_hdr structure:</p>
<blockquote>
<div><ul class="simple">
<li><p>TP_STATUS_VLAN_VALID bit being set into the tp_status field indicates
that the tp_vlan_tci field has valid VLAN TCI value</p></li>
<li><p>TP_STATUS_VLAN_TPID_VALID bit being set into the tp_status field
indicates that the tp_vlan_tpid field has valid VLAN TPID value</p></li>
</ul>
</div></blockquote>
</li>
<li><p>How to switch to TPACKET_V2:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Replace struct tpacket_hdr by struct tpacket2_hdr</p></li>
<li><p>Query header len and save</p></li>
<li><p>Set protocol version to 2, set up ring as usual</p></li>
<li><p>For getting the sockaddr_ll,
use <code class="docutils literal notranslate"><span class="pre">(void</span> <span class="pre">*)hdr</span> <span class="pre">+</span> <span class="pre">TPACKET_ALIGN(hdrlen)</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">(void</span> <span class="pre">*)hdr</span> <span class="pre">+</span> <span class="pre">TPACKET_ALIGN(sizeof(struct</span> <span class="pre">tpacket_hdr))</span></code></p></li>
</ol>
</div></blockquote>
</li>
</ul>
</dd>
<dt>TPACKET_V2 –&gt; TPACKET_V3:</dt><dd><ul>
<li><dl>
<dt>Flexible buffer implementation for RX_RING:</dt><dd><ol class="arabic">
<li><p>Blocks can be configured with non-static frame-size</p></li>
<li><p>Read/poll is at a block-level (as opposed to packet-level)</p></li>
<li><p>Added poll timeout to avoid indefinite user-space wait
on idle links</p></li>
<li><p>Added user-configurable knobs:</p>
<blockquote>
<div><p>4.1 block::timeout
4.2 tpkt_hdr::sk_rxhash</p>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
</li>
<li><p>RX Hash data available in user space</p></li>
<li><p>TX_RING semantics are conceptually similar to TPACKET_V2;
use tpacket3_hdr instead of tpacket2_hdr, and TPACKET3_HDRLEN
instead of TPACKET2_HDRLEN. In the current implementation,
the tp_next_offset field in the tpacket3_hdr MUST be set to
zero, indicating that the ring does not hold variable sized frames.
Packets with non-zero values of tp_next_offset will be dropped.</p></li>
</ul>
</dd>
</dl>
</section>
<section id="af-packet-fanout-mode">
<h2>AF_PACKET fanout mode<a class="headerlink" href="#af-packet-fanout-mode" title="Permalink to this headline">¶</a></h2>
<p>In the AF_PACKET fanout mode, packet reception can be load balanced among
processes. This also works in combination with mmap(2) on packet sockets.</p>
<p>Currently implemented fanout policies are:</p>
<blockquote>
<div><ul class="simple">
<li><p>PACKET_FANOUT_HASH: schedule to socket by skb’s packet hash</p></li>
<li><p>PACKET_FANOUT_LB: schedule to socket by round-robin</p></li>
<li><p>PACKET_FANOUT_CPU: schedule to socket by CPU packet arrives on</p></li>
<li><p>PACKET_FANOUT_RND: schedule to socket by random selection</p></li>
<li><p>PACKET_FANOUT_ROLLOVER: if one socket is full, rollover to another</p></li>
<li><p>PACKET_FANOUT_QM: schedule to socket by skbs recorded queue_mapping</p></li>
</ul>
</div></blockquote>
<p>Minimal example code by David S. Miller (try things like “./test eth0 hash”,
“./test eth0 lb”, etc.):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/ioctl.h&gt;

#include &lt;unistd.h&gt;

#include &lt;linux/if_ether.h&gt;
#include &lt;linux/if_packet.h&gt;

#include &lt;net/if.h&gt;

static const char *device_name;
static int fanout_type;
static int fanout_id;

#ifndef PACKET_FANOUT
# define PACKET_FANOUT                      18
# define PACKET_FANOUT_HASH         0
# define PACKET_FANOUT_LB           1
#endif

static int setup_socket(void)
{
        int err, fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_IP));
        struct sockaddr_ll ll;
        struct ifreq ifr;
        int fanout_arg;

        if (fd &lt; 0) {
                perror(&quot;socket&quot;);
                return EXIT_FAILURE;
        }

        memset(&amp;ifr, 0, sizeof(ifr));
        strcpy(ifr.ifr_name, device_name);
        err = ioctl(fd, SIOCGIFINDEX, &amp;ifr);
        if (err &lt; 0) {
                perror(&quot;SIOCGIFINDEX&quot;);
                return EXIT_FAILURE;
        }

        memset(&amp;ll, 0, sizeof(ll));
        ll.sll_family = AF_PACKET;
        ll.sll_ifindex = ifr.ifr_ifindex;
        err = bind(fd, (struct sockaddr *) &amp;ll, sizeof(ll));
        if (err &lt; 0) {
                perror(&quot;bind&quot;);
                return EXIT_FAILURE;
        }

        fanout_arg = (fanout_id | (fanout_type &lt;&lt; 16));
        err = setsockopt(fd, SOL_PACKET, PACKET_FANOUT,
                        &amp;fanout_arg, sizeof(fanout_arg));
        if (err) {
                perror(&quot;setsockopt&quot;);
                return EXIT_FAILURE;
        }

        return fd;
}

static void fanout_thread(void)
{
        int fd = setup_socket();
        int limit = 10000;

        if (fd &lt; 0)
                exit(fd);

        while (limit-- &gt; 0) {
                char buf[1600];
                int err;

                err = read(fd, buf, sizeof(buf));
                if (err &lt; 0) {
                        perror(&quot;read&quot;);
                        exit(EXIT_FAILURE);
                }
                if ((limit % 10) == 0)
                        fprintf(stdout, &quot;(%d) \n&quot;, getpid());
        }

        fprintf(stdout, &quot;%d: Received 10000 packets\n&quot;, getpid());

        close(fd);
        exit(0);
}

int main(int argc, char **argp)
{
        int fd, err;
        int i;

        if (argc != 3) {
                fprintf(stderr, &quot;Usage: %s INTERFACE {hash|lb}\n&quot;, argp[0]);
                return EXIT_FAILURE;
        }

        if (!strcmp(argp[2], &quot;hash&quot;))
                fanout_type = PACKET_FANOUT_HASH;
        else if (!strcmp(argp[2], &quot;lb&quot;))
                fanout_type = PACKET_FANOUT_LB;
        else {
                fprintf(stderr, &quot;Unknown fanout type [%s]\n&quot;, argp[2]);
                exit(EXIT_FAILURE);
        }

        device_name = argp[1];
        fanout_id = getpid() &amp; 0xffff;

        for (i = 0; i &lt; 4; i++) {
                pid_t pid = fork();

                switch (pid) {
                case 0:
                        fanout_thread();

                case -1:
                        perror(&quot;fork&quot;);
                        exit(EXIT_FAILURE);
                }
        }

        for (i = 0; i &lt; 4; i++) {
                int status;

                wait(&amp;status);
        }

        return 0;
}
</pre></div>
</div>
</section>
<section id="af-packet-tpacket-v3-example">
<h2>AF_PACKET TPACKET_V3 example<a class="headerlink" href="#af-packet-tpacket-v3-example" title="Permalink to this headline">¶</a></h2>
<p>AF_PACKET’s TPACKET_V3 ring buffer can be configured to use non-static frame
sizes by doing it’s own memory management. It is based on blocks where polling
works on a per block basis instead of per ring as in TPACKET_V2 and predecessor.</p>
<p>It is said that TPACKET_V3 brings the following benefits:</p>
<blockquote>
<div><ul class="simple">
<li><p>~15% - 20% reduction in CPU-usage</p></li>
<li><p>~20% increase in packet capture rate</p></li>
<li><p>~2x increase in packet density</p></li>
<li><p>Port aggregation analysis</p></li>
<li><p>Non static frame size to capture entire packet payload</p></li>
</ul>
</div></blockquote>
<p>So it seems to be a good candidate to be used with packet fanout.</p>
<p>Minimal example code by Daniel Borkmann based on Chetan Loke’s lolpcap (compile
it with gcc -Wall -O2 blob.c, and try things like “./a.out eth0”, etc.):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Written from scratch, but kernel-to-user space API usage
* dissected from lolpcap:
*  Copyright 2011, Chetan Loke &lt;loke.chetan@gmail.com&gt;
*  License: GPL, version 2.0
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;net/if.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;poll.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;linux/if_packet.h&gt;
#include &lt;linux/if_ether.h&gt;
#include &lt;linux/ip.h&gt;

#ifndef likely
# define likely(x)          __builtin_expect(!!(x), 1)
#endif
#ifndef unlikely
# define unlikely(x)                __builtin_expect(!!(x), 0)
#endif

struct block_desc {
        uint32_t version;
        uint32_t offset_to_priv;
        struct tpacket_hdr_v1 h1;
};

struct ring {
        struct iovec *rd;
        uint8_t *map;
        struct tpacket_req3 req;
};

static unsigned long packets_total = 0, bytes_total = 0;
static sig_atomic_t sigint = 0;

static void sighandler(int num)
{
        sigint = 1;
}

static int setup_socket(struct ring *ring, char *netdev)
{
        int err, i, fd, v = TPACKET_V3;
        struct sockaddr_ll ll;
        unsigned int blocksiz = 1 &lt;&lt; 22, framesiz = 1 &lt;&lt; 11;
        unsigned int blocknum = 64;

        fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
        if (fd &lt; 0) {
                perror(&quot;socket&quot;);
                exit(1);
        }

        err = setsockopt(fd, SOL_PACKET, PACKET_VERSION, &amp;v, sizeof(v));
        if (err &lt; 0) {
                perror(&quot;setsockopt&quot;);
                exit(1);
        }

        memset(&amp;ring-&gt;req, 0, sizeof(ring-&gt;req));
        ring-&gt;req.tp_block_size = blocksiz;
        ring-&gt;req.tp_frame_size = framesiz;
        ring-&gt;req.tp_block_nr = blocknum;
        ring-&gt;req.tp_frame_nr = (blocksiz * blocknum) / framesiz;
        ring-&gt;req.tp_retire_blk_tov = 60;
        ring-&gt;req.tp_feature_req_word = TP_FT_REQ_FILL_RXHASH;

        err = setsockopt(fd, SOL_PACKET, PACKET_RX_RING, &amp;ring-&gt;req,
                        sizeof(ring-&gt;req));
        if (err &lt; 0) {
                perror(&quot;setsockopt&quot;);
                exit(1);
        }

        ring-&gt;map = mmap(NULL, ring-&gt;req.tp_block_size * ring-&gt;req.tp_block_nr,
                        PROT_READ | PROT_WRITE, MAP_SHARED | MAP_LOCKED, fd, 0);
        if (ring-&gt;map == MAP_FAILED) {
                perror(&quot;mmap&quot;);
                exit(1);
        }

        ring-&gt;rd = malloc(ring-&gt;req.tp_block_nr * sizeof(*ring-&gt;rd));
        assert(ring-&gt;rd);
        for (i = 0; i &lt; ring-&gt;req.tp_block_nr; ++i) {
                ring-&gt;rd[i].iov_base = ring-&gt;map + (i * ring-&gt;req.tp_block_size);
                ring-&gt;rd[i].iov_len = ring-&gt;req.tp_block_size;
        }

        memset(&amp;ll, 0, sizeof(ll));
        ll.sll_family = PF_PACKET;
        ll.sll_protocol = htons(ETH_P_ALL);
        ll.sll_ifindex = if_nametoindex(netdev);
        ll.sll_hatype = 0;
        ll.sll_pkttype = 0;
        ll.sll_halen = 0;

        err = bind(fd, (struct sockaddr *) &amp;ll, sizeof(ll));
        if (err &lt; 0) {
                perror(&quot;bind&quot;);
                exit(1);
        }

        return fd;
}

static void display(struct tpacket3_hdr *ppd)
{
        struct ethhdr *eth = (struct ethhdr *) ((uint8_t *) ppd + ppd-&gt;tp_mac);
        struct iphdr *ip = (struct iphdr *) ((uint8_t *) eth + ETH_HLEN);

        if (eth-&gt;h_proto == htons(ETH_P_IP)) {
                struct sockaddr_in ss, sd;
                char sbuff[NI_MAXHOST], dbuff[NI_MAXHOST];

                memset(&amp;ss, 0, sizeof(ss));
                ss.sin_family = PF_INET;
                ss.sin_addr.s_addr = ip-&gt;saddr;
                getnameinfo((struct sockaddr *) &amp;ss, sizeof(ss),
                            sbuff, sizeof(sbuff), NULL, 0, NI_NUMERICHOST);

                memset(&amp;sd, 0, sizeof(sd));
                sd.sin_family = PF_INET;
                sd.sin_addr.s_addr = ip-&gt;daddr;
                getnameinfo((struct sockaddr *) &amp;sd, sizeof(sd),
                            dbuff, sizeof(dbuff), NULL, 0, NI_NUMERICHOST);

                printf(&quot;%s -&gt; %s, &quot;, sbuff, dbuff);
        }

        printf(&quot;rxhash: 0x%x\n&quot;, ppd-&gt;hv1.tp_rxhash);
}

static void walk_block(struct block_desc *pbd, const int block_num)
{
        int num_pkts = pbd-&gt;h1.num_pkts, i;
        unsigned long bytes = 0;
        struct tpacket3_hdr *ppd;

        ppd = (struct tpacket3_hdr *) ((uint8_t *) pbd +
                                    pbd-&gt;h1.offset_to_first_pkt);
        for (i = 0; i &lt; num_pkts; ++i) {
                bytes += ppd-&gt;tp_snaplen;
                display(ppd);

                ppd = (struct tpacket3_hdr *) ((uint8_t *) ppd +
                                            ppd-&gt;tp_next_offset);
        }

        packets_total += num_pkts;
        bytes_total += bytes;
}

static void flush_block(struct block_desc *pbd)
{
        pbd-&gt;h1.block_status = TP_STATUS_KERNEL;
}

static void teardown_socket(struct ring *ring, int fd)
{
        munmap(ring-&gt;map, ring-&gt;req.tp_block_size * ring-&gt;req.tp_block_nr);
        free(ring-&gt;rd);
        close(fd);
}

int main(int argc, char **argp)
{
        int fd, err;
        socklen_t len;
        struct ring ring;
        struct pollfd pfd;
        unsigned int block_num = 0, blocks = 64;
        struct block_desc *pbd;
        struct tpacket_stats_v3 stats;

        if (argc != 2) {
                fprintf(stderr, &quot;Usage: %s INTERFACE\n&quot;, argp[0]);
                return EXIT_FAILURE;
        }

        signal(SIGINT, sighandler);

        memset(&amp;ring, 0, sizeof(ring));
        fd = setup_socket(&amp;ring, argp[argc - 1]);
        assert(fd &gt; 0);

        memset(&amp;pfd, 0, sizeof(pfd));
        pfd.fd = fd;
        pfd.events = POLLIN | POLLERR;
        pfd.revents = 0;

        while (likely(!sigint)) {
                pbd = (struct block_desc *) ring.rd[block_num].iov_base;

                if ((pbd-&gt;h1.block_status &amp; TP_STATUS_USER) == 0) {
                        poll(&amp;pfd, 1, -1);
                        continue;
                }

                walk_block(pbd, block_num);
                flush_block(pbd);
                block_num = (block_num + 1) % blocks;
        }

        len = sizeof(stats);
        err = getsockopt(fd, SOL_PACKET, PACKET_STATISTICS, &amp;stats, &amp;len);
        if (err &lt; 0) {
                perror(&quot;getsockopt&quot;);
                exit(1);
        }

        fflush(stdout);
        printf(&quot;\nReceived %u packets, %lu bytes, %u dropped, freeze_q_cnt: %u\n&quot;,
            stats.tp_packets, bytes_total, stats.tp_drops,
            stats.tp_freeze_q_cnt);

        teardown_socket(&amp;ring, fd);
        return 0;
}
</pre></div>
</div>
</section>
<section id="packet-qdisc-bypass">
<h2>PACKET_QDISC_BYPASS<a class="headerlink" href="#packet-qdisc-bypass" title="Permalink to this headline">¶</a></h2>
<p>If there is a requirement to load the network with many packets in a similar
fashion as pktgen does, you might set the following option after socket
creation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int one = 1;
setsockopt(fd, SOL_PACKET, PACKET_QDISC_BYPASS, &amp;one, sizeof(one));
</pre></div>
</div>
<p>This has the side-effect, that packets sent through PF_PACKET will bypass the
kernel’s qdisc layer and are forcedly pushed to the driver directly. Meaning,
packet are not buffered, tc disciplines are ignored, increased loss can occur
and such packets are also not visible to other PF_PACKET sockets anymore. So,
you have been warned; generally, this can be useful for stress testing various
components of a system.</p>
<p>On default, PACKET_QDISC_BYPASS is disabled and needs to be explicitly enabled
on PF_PACKET sockets.</p>
</section>
<section id="packet-timestamp">
<h2>PACKET_TIMESTAMP<a class="headerlink" href="#packet-timestamp" title="Permalink to this headline">¶</a></h2>
<p>The PACKET_TIMESTAMP setting determines the source of the timestamp in
the packet meta information for mmap(2)ed RX_RING and TX_RINGs.  If your
NIC is capable of timestamping packets in hardware, you can request those
hardware timestamps to be used. Note: you may need to enable the generation
of hardware timestamps with SIOCSHWTSTAMP (see related information from
<a class="reference internal" href="timestamping.html"><span class="doc">Timestamping</span></a>).</p>
<p>PACKET_TIMESTAMP accepts the same integer bit field as SO_TIMESTAMPING:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int req = SOF_TIMESTAMPING_RAW_HARDWARE;
setsockopt(fd, SOL_PACKET, PACKET_TIMESTAMP, (void *) &amp;req, sizeof(req))
</pre></div>
</div>
<p>For the mmap(2)ed ring buffers, such timestamps are stored in the
<code class="docutils literal notranslate"><span class="pre">tpacket{,2,3}_hdr</span></code> structure’s tp_sec and <code class="docutils literal notranslate"><span class="pre">tp_{n,u}sec</span></code> members.
To determine what kind of timestamp has been reported, the tp_status field
is binary or’ed with the following possible bits …</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TP_STATUS_TS_RAW_HARDWARE
TP_STATUS_TS_SOFTWARE
</pre></div>
</div>
<p>… that are equivalent to its <code class="docutils literal notranslate"><span class="pre">SOF_TIMESTAMPING_*</span></code> counterparts. For the
RX_RING, if neither is set (i.e. PACKET_TIMESTAMP is not set), then a
software fallback was invoked <em>within</em> PF_PACKET’s processing code (less
precise).</p>
<p>Getting timestamps for the TX_RING works as follows: i) fill the ring frames,
ii) call sendto() e.g. in blocking mode, iii) wait for status of relevant
frames to be updated resp. the frame handed over to the application, iv) walk
through the frames to pick up the individual hw/sw timestamps.</p>
<p>Only (!) if transmit timestamping is enabled, then these bits are combined
with binary | with TP_STATUS_AVAILABLE, so you must check for that in your
application (e.g. !(tp_status &amp; (TP_STATUS_SEND_REQUEST | TP_STATUS_SENDING))
in a first step to see if the frame belongs to the application, and then
one can extract the type of timestamp in a second step from tp_status)!</p>
<p>If you don’t care about them, thus having it disabled, checking for
TP_STATUS_AVAILABLE resp. TP_STATUS_WRONG_FORMAT is sufficient. If in the
TX_RING part only TP_STATUS_AVAILABLE is set, then the tp_sec and tp_{n,u}sec
members do not contain a valid value. For TX_RINGs, by default no timestamp
is generated!</p>
<p>See include/linux/net_tstamp.h and <a class="reference internal" href="timestamping.html"><span class="doc">Timestamping</span></a>
for more information on hardware timestamps.</p>
</section>
<section id="miscellaneous-bits">
<h2>Miscellaneous bits<a class="headerlink" href="#miscellaneous-bits" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Packet sockets work well together with Linux socket filters, thus you also
might want to have a look at <a class="reference internal" href="filter.html"><span class="doc">Linux Socket Filtering aka Berkeley Packet Filter (BPF)</span></a></p></li>
</ul>
</section>
<section id="thanks">
<h2>THANKS<a class="headerlink" href="#thanks" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Jesse Brandeburg, for fixing my grammathical/spelling errors</p>
</div></blockquote>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Packet MMAP</a><ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#why-use-packet-mmap">Why use PACKET_MMAP</a></li>
<li><a class="reference internal" href="#how-to-use-mmap-to-improve-capture-process">How to use mmap() to improve capture process</a></li>
<li><a class="reference internal" href="#how-to-use-mmap-directly-to-improve-capture-process">How to use mmap() directly to improve capture process</a></li>
<li><a class="reference internal" href="#how-to-use-mmap-directly-to-improve-transmission-process">How to use mmap() directly to improve transmission process</a></li>
<li><a class="reference internal" href="#packet-mmap-settings">PACKET_MMAP settings</a></li>
<li><a class="reference internal" href="#packet-mmap-setting-constraints">PACKET_MMAP setting constraints</a><ul>
<li><a class="reference internal" href="#block-size-limit">Block size limit</a></li>
<li><a class="reference internal" href="#block-number-limit">Block number limit</a></li>
</ul>
</li>
<li><a class="reference internal" href="#packet-mmap-buffer-size-calculator">PACKET_MMAP buffer size calculator</a><ul>
<li><a class="reference internal" href="#other-constraints">Other constraints</a></li>
<li><a class="reference internal" href="#mapping-and-use-of-the-circular-buffer-ring">Mapping and use of the circular buffer (ring)</a><ul>
<li><a class="reference internal" href="#capture-process">Capture process</a></li>
<li><a class="reference internal" href="#transmission-process">Transmission process</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#what-tpacket-versions-are-available-and-when-to-use-them">What TPACKET versions are available and when to use them?</a></li>
<li><a class="reference internal" href="#af-packet-fanout-mode">AF_PACKET fanout mode</a></li>
<li><a class="reference internal" href="#af-packet-tpacket-v3-example">AF_PACKET TPACKET_V3 example</a></li>
<li><a class="reference internal" href="#packet-qdisc-bypass">PACKET_QDISC_BYPASS</a></li>
<li><a class="reference internal" href="#packet-timestamp">PACKET_TIMESTAMP</a></li>
<li><a class="reference internal" href="#miscellaneous-bits">Miscellaneous bits</a></li>
<li><a class="reference internal" href="#thanks">THANKS</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/networking/packet_mmap.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/networking/packet_mmap.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>