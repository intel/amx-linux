
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>PHY Abstraction Layer &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="phylink" href="sfp-phylink.html" />
    <link rel="prev" title="Page Pool API" href="page_pool.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="phy-abstraction-layer">
<h1>PHY Abstraction Layer<a class="headerlink" href="#phy-abstraction-layer" title="Permalink to this headline">¶</a></h1>
<section id="purpose">
<h2>Purpose<a class="headerlink" href="#purpose" title="Permalink to this headline">¶</a></h2>
<p>Most network devices consist of set of registers which provide an interface
to a MAC layer, which communicates with the physical connection through a
PHY.  The PHY concerns itself with negotiating link parameters with the link
partner on the other side of the network connection (typically, an ethernet
cable), and provides a register interface to allow drivers to determine what
settings were chosen, and to configure what settings are allowed.</p>
<p>While these devices are distinct from the network devices, and conform to a
standard layout for the registers, it has been common practice to integrate
the PHY management code with the network driver.  This has resulted in large
amounts of redundant code.  Also, on embedded systems with multiple (and
sometimes quite different) ethernet controllers connected to the same
management bus, it is difficult to ensure safe use of the bus.</p>
<p>Since the PHYs are devices, and the management busses through which they are
accessed are, in fact, busses, the PHY Abstraction Layer treats them as such.
In doing so, it has these goals:</p>
<ol class="arabic simple">
<li><p>Increase code-reuse</p></li>
<li><p>Increase overall code-maintainability</p></li>
<li><p>Speed development time for new network drivers, and for new systems</p></li>
</ol>
<p>Basically, this layer is meant to provide an interface to PHY devices which
allows network driver writers to write as little code as possible, while
still providing a full feature set.</p>
</section>
<section id="the-mdio-bus">
<h2>The MDIO bus<a class="headerlink" href="#the-mdio-bus" title="Permalink to this headline">¶</a></h2>
<p>Most network devices are connected to a PHY by means of a management bus.
Different devices use different busses (though some share common interfaces).
In order to take advantage of the PAL, each bus interface needs to be
registered as a distinct device.</p>
<ol class="arabic">
<li><p>read and write functions must be implemented. Their prototypes are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int write(struct mii_bus *bus, int mii_id, int regnum, u16 value);
int read(struct mii_bus *bus, int mii_id, int regnum);
</pre></div>
</div>
<p>mii_id is the address on the bus for the PHY, and regnum is the register
number.  These functions are guaranteed not to be called from interrupt
time, so it is safe for them to block, waiting for an interrupt to signal
the operation is complete</p>
</li>
<li><p>A reset function is optional. This is used to return the bus to an
initialized state.</p></li>
<li><p>A probe function is needed.  This function should set up anything the bus
driver needs, setup the mii_bus structure, and register with the PAL using
mdiobus_register.  Similarly, there’s a remove function to undo all of
that (use mdiobus_unregister).</p></li>
<li><p>Like any driver, the device_driver structure must be configured, and init
exit functions are used to register the driver.</p></li>
<li><p>The bus must also be declared somewhere as a device, and registered.</p></li>
</ol>
<p>As an example for how one driver implemented an mdio bus driver, see
drivers/net/ethernet/freescale/fsl_pq_mdio.c and an associated DTS file
for one of the users. (e.g. “git grep fsl,.*-mdio arch/powerpc/boot/dts/”)</p>
</section>
<section id="rg-mii-electrical-interface-considerations">
<h2>(RG)MII/electrical interface considerations<a class="headerlink" href="#rg-mii-electrical-interface-considerations" title="Permalink to this headline">¶</a></h2>
<p>The Reduced Gigabit Medium Independent Interface (RGMII) is a 12-pin
electrical signal interface using a synchronous 125Mhz clock signal and several
data lines. Due to this design decision, a 1.5ns to 2ns delay must be added
between the clock line (RXC or TXC) and the data lines to let the PHY (clock
sink) have a large enough setup and hold time to sample the data lines correctly. The
PHY library offers different types of PHY_INTERFACE_MODE_RGMII* values to let
the PHY driver and optionally the MAC driver, implement the required delay. The
values of phy_interface_t must be understood from the perspective of the PHY
device itself, leading to the following:</p>
<ul class="simple">
<li><p>PHY_INTERFACE_MODE_RGMII: the PHY is not responsible for inserting any
internal delay by itself, it assumes that either the Ethernet MAC (if capable)
or the PCB traces insert the correct 1.5-2ns delay</p></li>
<li><p>PHY_INTERFACE_MODE_RGMII_TXID: the PHY should insert an internal delay
for the transmit data lines (TXD[3:0]) processed by the PHY device</p></li>
<li><p>PHY_INTERFACE_MODE_RGMII_RXID: the PHY should insert an internal delay
for the receive data lines (RXD[3:0]) processed by the PHY device</p></li>
<li><p>PHY_INTERFACE_MODE_RGMII_ID: the PHY should insert internal delays for
both transmit AND receive data lines from/to the PHY device</p></li>
</ul>
<p>Whenever possible, use the PHY side RGMII delay for these reasons:</p>
<ul class="simple">
<li><p>PHY devices may offer sub-nanosecond granularity in how they allow a
receiver/transmitter side delay (e.g: 0.5, 1.0, 1.5ns) to be specified. Such
precision may be required to account for differences in PCB trace lengths</p></li>
<li><p>PHY devices are typically qualified for a large range of applications
(industrial, medical, automotive…), and they provide a constant and
reliable delay across temperature/pressure/voltage ranges</p></li>
<li><p>PHY device drivers in PHYLIB being reusable by nature, being able to
configure correctly a specified delay enables more designs with similar delay
requirements to be operated correctly</p></li>
</ul>
<p>For cases where the PHY is not capable of providing this delay, but the
Ethernet MAC driver is capable of doing so, the correct phy_interface_t value
should be PHY_INTERFACE_MODE_RGMII, and the Ethernet MAC driver should be
configured correctly in order to provide the required transmit and/or receive
side delay from the perspective of the PHY device. Conversely, if the Ethernet
MAC driver looks at the phy_interface_t value, for any other mode but
PHY_INTERFACE_MODE_RGMII, it should make sure that the MAC-level delays are
disabled.</p>
<p>In case neither the Ethernet MAC, nor the PHY are capable of providing the
required delays, as defined per the RGMII standard, several options may be
available:</p>
<ul class="simple">
<li><p>Some SoCs may offer a pin pad/mux/controller capable of configuring a given
set of pins’ strength, delays, and voltage; and it may be a suitable
option to insert the expected 2ns RGMII delay.</p></li>
<li><p>Modifying the PCB design to include a fixed delay (e.g: using a specifically
designed serpentine), which may not require software configuration at all.</p></li>
</ul>
<section id="common-problems-with-rgmii-delay-mismatch">
<h3>Common problems with RGMII delay mismatch<a class="headerlink" href="#common-problems-with-rgmii-delay-mismatch" title="Permalink to this headline">¶</a></h3>
<p>When there is a RGMII delay mismatch between the Ethernet MAC and the PHY, this
will most likely result in the clock and data line signals to be unstable when
the PHY or MAC take a snapshot of these signals to translate them into logical
1 or 0 states and reconstruct the data being transmitted/received. Typical
symptoms include:</p>
<ul class="simple">
<li><p>Transmission/reception partially works, and there is frequent or occasional
packet loss observed</p></li>
<li><p>Ethernet MAC may report some or all packets ingressing with a FCS/CRC error,
or just discard them all</p></li>
<li><p>Switching to lower speeds such as 10/100Mbits/sec makes the problem go away
(since there is enough setup/hold time in that case)</p></li>
</ul>
</section>
</section>
<section id="connecting-to-a-phy">
<h2>Connecting to a PHY<a class="headerlink" href="#connecting-to-a-phy" title="Permalink to this headline">¶</a></h2>
<p>Sometime during startup, the network driver needs to establish a connection
between the PHY device, and the network device.  At this time, the PHY’s bus
and drivers need to all have been loaded, so it is ready for the connection.
At this point, there are several ways to connect to the PHY:</p>
<ol class="arabic simple">
<li><p>The PAL handles everything, and only calls the network driver when
the link state changes, so it can react.</p></li>
<li><p>The PAL handles everything except interrupts (usually because the
controller has the interrupt registers).</p></li>
<li><p>The PAL handles everything, but checks in with the driver every second,
allowing the network driver to react first to any changes before the PAL
does.</p></li>
<li><p>The PAL serves only as a library of functions, with the network device
manually calling functions to update status, and configure the PHY</p></li>
</ol>
</section>
<section id="letting-the-phy-abstraction-layer-do-everything">
<h2>Letting the PHY Abstraction Layer do Everything<a class="headerlink" href="#letting-the-phy-abstraction-layer-do-everything" title="Permalink to this headline">¶</a></h2>
<p>If you choose option 1 (The hope is that every driver can, but to still be
useful to drivers that can’t), connecting to the PHY is simple:</p>
<p>First, you need a function to react to changes in the link state.  This
function follows this protocol:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void adjust_link(struct net_device *dev);
</pre></div>
</div>
<p>Next, you need to know the device name of the PHY connected to this device.
The name will look something like, “0:00”, where the first number is the
bus id, and the second is the PHY’s address on that bus.  Typically,
the bus is responsible for making its ID unique.</p>
<p>Now, to connect, just call this function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>phydev = phy_connect(dev, phy_name, &amp;adjust_link, interface);
</pre></div>
</div>
<p><em>phydev</em> is a pointer to the phy_device structure which represents the PHY.
If phy_connect is successful, it will return the pointer.  dev, here, is the
pointer to your net_device.  Once done, this function will have started the
PHY’s software state machine, and registered for the PHY’s interrupt, if it
has one.  The phydev structure will be populated with information about the
current state, though the PHY will not yet be truly operational at this
point.</p>
<p>PHY-specific flags should be set in phydev-&gt;dev_flags prior to the call
to <a class="reference internal" href="kapi.html#c.phy_connect" title="phy_connect"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_connect()</span></code></a> such that the underlying PHY driver can check for flags
and perform specific operations based on them.
This is useful if the system has put hardware restrictions on
the PHY/controller, of which the PHY needs to be aware.</p>
<p><em>interface</em> is a u32 which specifies the connection type used
between the controller and the PHY.  Examples are GMII, MII,
RGMII, and SGMII.  See “PHY interface mode” below.  For a full
list, see include/linux/phy.h</p>
<p>Now just make sure that phydev-&gt;supported and phydev-&gt;advertising have any
values pruned from them which don’t make sense for your controller (a 10/100
controller may be connected to a gigabit capable PHY, so you would need to
mask off SUPPORTED_1000baseT*).  See include/linux/ethtool.h for definitions
for these bitfields. Note that you should not SET any bits, except the
SUPPORTED_Pause and SUPPORTED_AsymPause bits (see below), or the PHY may get
put into an unsupported state.</p>
<p>Lastly, once the controller is ready to handle network traffic, you call
phy_start(phydev).  This tells the PAL that you are ready, and configures the
PHY to connect to the network. If the MAC interrupt of your network driver
also handles PHY status changes, just set phydev-&gt;irq to PHY_MAC_INTERRUPT
before you call phy_start and use <a class="reference internal" href="kapi.html#c.phy_mac_interrupt" title="phy_mac_interrupt"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_mac_interrupt()</span></code></a> from the network
driver. If you don’t want to use interrupts, set phydev-&gt;irq to PHY_POLL.
<a class="reference internal" href="kapi.html#c.phy_start" title="phy_start"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_start()</span></code></a> enables the PHY interrupts (if applicable) and starts the
phylib state machine.</p>
<p>When you want to disconnect from the network (even if just briefly), you call
phy_stop(phydev). This function also stops the phylib state machine and
disables PHY interrupts.</p>
</section>
<section id="phy-interface-modes">
<h2>PHY interface modes<a class="headerlink" href="#phy-interface-modes" title="Permalink to this headline">¶</a></h2>
<p>The PHY interface mode supplied in the <a class="reference internal" href="kapi.html#c.phy_connect" title="phy_connect"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_connect()</span></code></a> family of functions
defines the initial operating mode of the PHY interface.  This is not
guaranteed to remain constant; there are PHYs which dynamically change
their interface mode without software interaction depending on the
negotiation results.</p>
<p>Some of the interface modes are described below:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_SMII</span></code></dt><dd><p>This is serial MII, clocked at 125MHz, supporting 100M and 10M speeds.
Some details can be found in
<a class="reference external" href="https://opencores.org/ocsvn/smii/smii/trunk/doc/SMII.pdf">https://opencores.org/ocsvn/smii/smii/trunk/doc/SMII.pdf</a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_1000BASEX</span></code></dt><dd><p>This defines the 1000BASE-X single-lane serdes link as defined by the
802.3 standard section 36.  The link operates at a fixed bit rate of
1.25Gbaud using a 10B/8B encoding scheme, resulting in an underlying
data rate of 1Gbps.  Embedded in the data stream is a 16-bit control
word which is used to negotiate the duplex and pause modes with the
remote end.  This does not include “up-clocked” variants such as 2.5Gbps
speeds (see below.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_2500BASEX</span></code></dt><dd><p>This defines a variant of 1000BASE-X which is clocked 2.5 times as fast
as the 802.3 standard, giving a fixed bit rate of 3.125Gbaud.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_SGMII</span></code></dt><dd><p>This is used for Cisco SGMII, which is a modification of 1000BASE-X
as defined by the 802.3 standard.  The SGMII link consists of a single
serdes lane running at a fixed bit rate of 1.25Gbaud with 10B/8B
encoding.  The underlying data rate is 1Gbps, with the slower speeds of
100Mbps and 10Mbps being achieved through replication of each data symbol.
The 802.3 control word is re-purposed to send the negotiated speed and
duplex information from to the MAC, and for the MAC to acknowledge
receipt.  This does not include “up-clocked” variants such as 2.5Gbps
speeds.</p>
<p>Note: mismatched SGMII vs 1000BASE-X configuration on a link can
successfully pass data in some circumstances, but the 16-bit control
word will not be correctly interpreted, which may cause mismatches in
duplex, pause or other settings.  This is dependent on the MAC and/or
PHY behaviour.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_5GBASER</span></code></dt><dd><p>This is the IEEE 802.3 Clause 129 defined 5GBASE-R protocol. It is
identical to the 10GBASE-R protocol defined in Clause 49, with the
exception that it operates at half the frequency. Please refer to the
IEEE standard for the definition.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_10GBASER</span></code></dt><dd><p>This is the IEEE 802.3 Clause 49 defined 10GBASE-R protocol used with
various different mediums. Please refer to the IEEE standard for a
definition of this.</p>
<p>Note: 10GBASE-R is just one protocol that can be used with XFI and SFI.
XFI and SFI permit multiple protocols over a single SERDES lane, and
also defines the electrical characteristics of the signals with a host
compliance board plugged into the host XFP/SFP connector. Therefore,
XFI and SFI are not PHY interface types in their own right.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_10GKR</span></code></dt><dd><p>This is the IEEE 802.3 Clause 49 defined 10GBASE-R with Clause 73
autonegotiation. Please refer to the IEEE standard for further
information.</p>
<p>Note: due to legacy usage, some 10GBASE-R usage incorrectly makes
use of this definition.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_25GBASER</span></code></dt><dd><p>This is the IEEE 802.3 PCS Clause 107 defined 25GBASE-R protocol.
The PCS is identical to 10GBASE-R, i.e. 64B/66B encoded
running 2.5 as fast, giving a fixed bit rate of 25.78125 Gbaud.
Please refer to the IEEE standard for further information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_100BASEX</span></code></dt><dd><p>This defines IEEE 802.3 Clause 24.  The link operates at a fixed data
rate of 125Mpbs using a 4B/5B encoding scheme, resulting in an underlying
data rate of 100Mpbs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_QUSGMII</span></code></dt><dd><p>This defines the Cisco the Quad USGMII mode, which is the Quad variant of
the USGMII (Universal SGMII) link. It’s very similar to QSGMII, but uses
a Packet Control Header (PCH) instead of the 7 bytes preamble to carry not
only the port id, but also so-called “extensions”. The only documented
extension so-far in the specification is the inclusion of timestamps, for
PTP-enabled PHYs. This mode isn’t compatible with QSGMII, but offers the
same capabilities in terms of link speed and negociation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_1000BASEKX</span></code></dt><dd><p>This is 1000BASE-X as defined by IEEE 802.3 Clause 36 with Clause 73
autonegotiation. Generally, it will be used with a Clause 70 PMD. To
contrast with the 1000BASE-X phy mode used for Clause 38 and 39 PMDs, this
interface mode has different autonegotiation and only supports full duplex.</p>
</dd>
</dl>
</section>
<section id="pause-frames-flow-control">
<h2>Pause frames / flow control<a class="headerlink" href="#pause-frames-flow-control" title="Permalink to this headline">¶</a></h2>
<p>The PHY does not participate directly in flow control/pause frames except by
making sure that the SUPPORTED_Pause and SUPPORTED_AsymPause bits are set in
MII_ADVERTISE to indicate towards the link partner that the Ethernet MAC
controller supports such a thing. Since flow control/pause frames generation
involves the Ethernet MAC driver, it is recommended that this driver takes care
of properly indicating advertisement and support for such features by setting
the SUPPORTED_Pause and SUPPORTED_AsymPause bits accordingly. This can be done
either before or after <a class="reference internal" href="kapi.html#c.phy_connect" title="phy_connect"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_connect()</span></code></a> and/or as a result of implementing the
ethtool::set_pauseparam feature.</p>
</section>
<section id="keeping-close-tabs-on-the-pal">
<h2>Keeping Close Tabs on the PAL<a class="headerlink" href="#keeping-close-tabs-on-the-pal" title="Permalink to this headline">¶</a></h2>
<p>It is possible that the PAL’s built-in state machine needs a little help to
keep your network device and the PHY properly in sync.  If so, you can
register a helper function when connecting to the PHY, which will be called
every second before the state machine reacts to any changes.  To do this, you
need to manually call <a class="reference internal" href="kapi.html#c.phy_attach" title="phy_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_attach()</span></code></a> and <a class="reference internal" href="kapi.html#c.phy_prepare_link" title="phy_prepare_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_prepare_link()</span></code></a>, and then call
<a class="reference internal" href="kapi.html#c.phy_start_machine" title="phy_start_machine"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_start_machine()</span></code></a> with the second argument set to point to your special
handler.</p>
<p>Currently there are no examples of how to use this functionality, and testing
on it has been limited because the author does not have any drivers which use
it (they all use option 1).  So Caveat Emptor.</p>
</section>
<section id="doing-it-all-yourself">
<h2>Doing it all yourself<a class="headerlink" href="#doing-it-all-yourself" title="Permalink to this headline">¶</a></h2>
<p>There’s a remote chance that the PAL’s built-in state machine cannot track
the complex interactions between the PHY and your network device.  If this is
so, you can simply call <a class="reference internal" href="kapi.html#c.phy_attach" title="phy_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_attach()</span></code></a>, and not call phy_start_machine or
<a class="reference internal" href="kapi.html#c.phy_prepare_link" title="phy_prepare_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_prepare_link()</span></code></a>.  This will mean that phydev-&gt;state is entirely yours to
handle (phy_start and phy_stop toggle between some of the states, so you
might need to avoid them).</p>
<p>An effort has been made to make sure that useful functionality can be
accessed without the state-machine running, and most of these functions are
descended from functions which did not interact with a complex state-machine.
However, again, no effort has been made so far to test running without the
state machine, so tryer beware.</p>
<p>Here is a brief rundown of the functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_read(struct phy_device *phydev, u16 regnum);
int phy_write(struct phy_device *phydev, u16 regnum, u16 val);
</pre></div>
</div>
<p>Simple read/write primitives.  They invoke the bus’s read/write function
pointers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void phy_print_status(struct phy_device *phydev);
</pre></div>
</div>
<p>A convenience function to print out the PHY status neatly.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void phy_request_interrupt(struct phy_device *phydev);
</pre></div>
</div>
<p>Requests the IRQ for the PHY interrupts.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phy_device * phy_attach(struct net_device *dev, const char *phy_id,
                               phy_interface_t interface);
</pre></div>
</div>
<p>Attaches a network device to a particular PHY, binding the PHY to a generic
driver if none was found during bus initialization.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_start_aneg(struct phy_device *phydev);
</pre></div>
</div>
<p>Using variables inside the phydev structure, either configures advertising
and resets autonegotiation, or disables autonegotiation, and configures
forced settings.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline int phy_read_status(struct phy_device *phydev);
</pre></div>
</div>
<p>Fills the phydev structure with up-to-date information about the current
settings in the PHY.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_ethtool_ksettings_set(struct phy_device *phydev,
                              const struct ethtool_link_ksettings *cmd);
</pre></div>
</div>
<p>Ethtool convenience functions.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_mii_ioctl(struct phy_device *phydev,
                  struct mii_ioctl_data *mii_data, int cmd);
</pre></div>
</div>
<p>The MII ioctl.  Note that this function will completely screw up the state
machine if you write registers like BMCR, BMSR, ADVERTISE, etc.  Best to
use this only to write registers which are not standard, and don’t set off
a renegotiation.</p>
</section>
<section id="phy-device-drivers">
<h2>PHY Device Drivers<a class="headerlink" href="#phy-device-drivers" title="Permalink to this headline">¶</a></h2>
<p>With the PHY Abstraction Layer, adding support for new PHYs is
quite easy. In some cases, no work is required at all! However,
many PHYs require a little hand-holding to get up-and-running.</p>
<section id="generic-phy-driver">
<h3>Generic PHY driver<a class="headerlink" href="#generic-phy-driver" title="Permalink to this headline">¶</a></h3>
<p>If the desired PHY doesn’t have any errata, quirks, or special
features you want to support, then it may be best to not add
support, and let the PHY Abstraction Layer’s Generic PHY Driver
do all of the work.</p>
</section>
<section id="writing-a-phy-driver">
<h3>Writing a PHY driver<a class="headerlink" href="#writing-a-phy-driver" title="Permalink to this headline">¶</a></h3>
<p>If you do need to write a PHY driver, the first thing to do is
make sure it can be matched with an appropriate PHY device.
This is done during bus initialization by reading the device’s
UID (stored in registers 2 and 3), then comparing it to each
driver’s phy_id field by ANDing it with each driver’s
phy_id_mask field.  Also, it needs a name.  Here’s an example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct phy_driver dm9161_driver = {
      .phy_id         = 0x0181b880,
      .name           = &quot;Davicom DM9161E&quot;,
      .phy_id_mask    = 0x0ffffff0,
      ...
}
</pre></div>
</div>
<p>Next, you need to specify what features (speed, duplex, autoneg,
etc) your PHY device and driver support.  Most PHYs support
PHY_BASIC_FEATURES, but you can look in include/mii.h for other
features.</p>
<p>Each driver consists of a number of function pointers, documented
in include/linux/phy.h under the phy_driver structure.</p>
<p>Of these, only config_aneg and read_status are required to be
assigned by the driver code.  The rest are optional.  Also, it is
preferred to use the generic phy driver’s versions of these two
functions if at all possible: genphy_read_status and
genphy_config_aneg.  If this is not possible, it is likely that
you only need to perform some actions before and after invoking
these functions, and so your functions will wrap the generic
ones.</p>
<p>Feel free to look at the Marvell, Cicada, and Davicom drivers in
drivers/net/phy/ for examples (the lxt and qsemi drivers have
not been tested as of this writing).</p>
<p>The PHY’s MMD register accesses are handled by the PAL framework
by default, but can be overridden by a specific PHY driver if
required. This could be the case if a PHY was released for
manufacturing before the MMD PHY register definitions were
standardized by the IEEE. Most modern PHYs will be able to use
the generic PAL framework for accessing the PHY’s MMD registers.
An example of such usage is for Energy Efficient Ethernet support,
implemented in the PAL. This support uses the PAL to access MMD
registers for EEE query and configuration if the PHY supports
the IEEE standard access mechanisms, or can use the PHY’s specific
access interfaces if overridden by the specific PHY driver. See
the Micrel driver in drivers/net/phy/ for an example of how this
can be implemented.</p>
</section>
</section>
<section id="board-fixups">
<h2>Board Fixups<a class="headerlink" href="#board-fixups" title="Permalink to this headline">¶</a></h2>
<p>Sometimes the specific interaction between the platform and the PHY requires
special handling.  For instance, to change where the PHY’s clock input is,
or to add a delay to account for latency issues in the data path.  In order
to support such contingencies, the PHY Layer allows platform code to register
fixups to be run when the PHY is brought up (or subsequently reset).</p>
<p>When the PHY Layer brings up a PHY it checks to see if there are any fixups
registered for it, matching based on UID (contained in the PHY device’s phy_id
field) and the bus identifier (contained in phydev-&gt;dev.bus_id).  Both must
match, however two constants, PHY_ANY_ID and PHY_ANY_UID, are provided as
wildcards for the bus ID and UID, respectively.</p>
<p>When a match is found, the PHY layer will invoke the run function associated
with the fixup.  This function is passed a pointer to the phy_device of
interest.  It should therefore only operate on that PHY.</p>
<p>The platform code can either register the fixup using <a class="reference internal" href="kapi.html#c.phy_register_fixup" title="phy_register_fixup"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_register_fixup()</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_register_fixup(const char *phy_id,
        u32 phy_uid, u32 phy_uid_mask,
        int (*run)(struct phy_device *));
</pre></div>
</div>
<p>Or using one of the two stubs, phy_register_fixup_for_uid() and
phy_register_fixup_for_id():</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,
               int (*run)(struct phy_device *));
int phy_register_fixup_for_id(const char *phy_id,
               int (*run)(struct phy_device *));
</pre></div>
</div>
<p>The stubs set one of the two matching criteria, and set the other one to
match anything.</p>
<p>When <a class="reference internal" href="kapi.html#c.phy_register_fixup" title="phy_register_fixup"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_register_fixup()</span></code></a> or *_for_uid()/*_for_id() is called at module load
time, the module needs to unregister the fixup and free allocated memory when
it’s unloaded.</p>
<p>Call one of following function before unloading module:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int phy_unregister_fixup(const char *phy_id, u32 phy_uid, u32 phy_uid_mask);
int phy_unregister_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask);
int phy_register_fixup_for_id(const char *phy_id);
</pre></div>
</div>
</section>
<section id="standards">
<h2>Standards<a class="headerlink" href="#standards" title="Permalink to this headline">¶</a></h2>
<p>IEEE Standard 802.3: CSMA/CD Access Method and Physical Layer Specifications, Section Two:
<a class="reference external" href="http://standards.ieee.org/getieee802/download/802.3-2008_section2.pdf">http://standards.ieee.org/getieee802/download/802.3-2008_section2.pdf</a></p>
<p>RGMII v1.3:
<a class="reference external" href="http://web.archive.org/web/20160303212629/http://www.hp.com/rnd/pdfs/RGMIIv1_3.pdf">http://web.archive.org/web/20160303212629/http://www.hp.com/rnd/pdfs/RGMIIv1_3.pdf</a></p>
<p>RGMII v2.0:
<a class="reference external" href="http://web.archive.org/web/20160303171328/http://www.hp.com/rnd/pdfs/RGMIIv2_0_final_hp.pdf">http://web.archive.org/web/20160303171328/http://www.hp.com/rnd/pdfs/RGMIIv2_0_final_hp.pdf</a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">PHY Abstraction Layer</a><ul>
<li><a class="reference internal" href="#purpose">Purpose</a></li>
<li><a class="reference internal" href="#the-mdio-bus">The MDIO bus</a></li>
<li><a class="reference internal" href="#rg-mii-electrical-interface-considerations">(RG)MII/electrical interface considerations</a><ul>
<li><a class="reference internal" href="#common-problems-with-rgmii-delay-mismatch">Common problems with RGMII delay mismatch</a></li>
</ul>
</li>
<li><a class="reference internal" href="#connecting-to-a-phy">Connecting to a PHY</a></li>
<li><a class="reference internal" href="#letting-the-phy-abstraction-layer-do-everything">Letting the PHY Abstraction Layer do Everything</a></li>
<li><a class="reference internal" href="#phy-interface-modes">PHY interface modes</a></li>
<li><a class="reference internal" href="#pause-frames-flow-control">Pause frames / flow control</a></li>
<li><a class="reference internal" href="#keeping-close-tabs-on-the-pal">Keeping Close Tabs on the PAL</a></li>
<li><a class="reference internal" href="#doing-it-all-yourself">Doing it all yourself</a></li>
<li><a class="reference internal" href="#phy-device-drivers">PHY Device Drivers</a><ul>
<li><a class="reference internal" href="#generic-phy-driver">Generic PHY driver</a></li>
<li><a class="reference internal" href="#writing-a-phy-driver">Writing a PHY driver</a></li>
</ul>
</li>
<li><a class="reference internal" href="#board-fixups">Board Fixups</a></li>
<li><a class="reference internal" href="#standards">Standards</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/networking/phy.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/networking/phy.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>