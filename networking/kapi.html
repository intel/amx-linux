
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Linux Networking and Network Devices APIs &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="MSG_ZEROCOPY" href="msg_zerocopy.html" />
    <link rel="prev" title="J1939 Documentation" href="j1939.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="linux-networking-and-network-devices-apis">
<h1>Linux Networking and Network Devices APIs<a class="headerlink" href="#linux-networking-and-network-devices-apis" title="Permalink to this headline">¶</a></h1>
<section id="linux-networking">
<h2>Linux Networking<a class="headerlink" href="#linux-networking" title="Permalink to this headline">¶</a></h2>
<section id="networking-base-types">
<h3>Networking Base Types<a class="headerlink" href="#networking-base-types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.sock_type">
enum <code class="sig-name descname">sock_type</code><a class="headerlink" href="#c.sock_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Socket types</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></dt><dd><p>stream (connection) socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></dt><dd><p>datagram (conn.less) socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_RAW</span></code></dt><dd><p>raw socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_RDM</span></code></dt><dd><p>reliably-delivered message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_SEQPACKET</span></code></dt><dd><p>sequential packet socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_DCCP</span></code></dt><dd><p>Datagram Congestion Control Protocol socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SOCK_PACKET</span></code></dt><dd><p>linux specific way of getting packets at the dev level.
For writing rarp and other similar things on the user level.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>When adding some new socket type please
grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS
overrides this enum for binary compat reasons.</p>
<dl class="type">
<dt id="c.sock_shutdown_cmd">
enum <code class="sig-name descname">sock_shutdown_cmd</code><a class="headerlink" href="#c.sock_shutdown_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown types</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SHUT_RD</span></code></dt><dd><p>shutdown receptions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SHUT_WR</span></code></dt><dd><p>shutdown transmissions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SHUT_RDWR</span></code></dt><dd><p>shutdown receptions/transmissions</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.socket">
struct <code class="sig-name descname">socket</code><a class="headerlink" href="#c.socket" title="Permalink to this definition">¶</a></dt>
<dd><p>general BSD socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct socket {
    socket_state state;
    short type;
    unsigned long           flags;
    struct file             *file;
    struct sock             *sk;
    const struct proto_ops  *ops;
    struct socket_wq        wq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>socket state (<code class="docutils literal notranslate"><span class="pre">SS_CONNECTED</span></code>, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>socket type (<code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>socket flags (<code class="docutils literal notranslate"><span class="pre">SOCK_NOSPACE</span></code>, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>File back pointer for gc</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk</span></code></dt><dd><p>internal networking protocol agnostic socket representation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>protocol specific socket operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wq</span></code></dt><dd><p>wait queue for several uses</p>
</dd>
</dl>
</div>
</section>
<section id="socket-buffer-functions">
<h3>Socket Buffer Functions<a class="headerlink" href="#socket-buffer-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.skb_frag_size">
unsigned int <code class="sig-name descname">skb_frag_size</code><span class="sig-paren">(</span>const skb_frag_t<em> *frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of a skb fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>skb fragment</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_frag_size_set">
void <code class="sig-name descname">skb_frag_size_set</code><span class="sig-paren">(</span>skb_frag_t<em> *frag</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_size_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the size of a skb fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>skb fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size of fragment</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_frag_size_add">
void <code class="sig-name descname">skb_frag_size_add</code><span class="sig-paren">(</span>skb_frag_t<em> *frag</em>, int<em> delta</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_size_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Increments the size of a skb fragment by <strong>delta</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>skb fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">delta</span></code></dt><dd><p>value to add</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_frag_size_sub">
void <code class="sig-name descname">skb_frag_size_sub</code><span class="sig-paren">(</span>skb_frag_t<em> *frag</em>, int<em> delta</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_size_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrements the size of a skb fragment by <strong>delta</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>skb fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">delta</span></code></dt><dd><p>value to subtract</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_frag_must_loop">
bool <code class="sig-name descname">skb_frag_must_loop</code><span class="sig-paren">(</span>struct page<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_must_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <code class="docutils literal notranslate"><span class="pre">p</span></code> is a high memory page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*p</span></code></dt><dd><p>fragment’s page</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_frag_foreach_page">
<code class="sig-name descname">skb_frag_foreach_page</code><span class="sig-paren">(</span><em>f</em>, <em>f_off</em>, <em>f_len</em>, <em>p</em>, <em>p_off</em>, <em>p_len</em>, <em>copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_foreach_page" title="Permalink to this definition">¶</a></dt>
<dd><p>loop over pages in a fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code></dt><dd><p>skb frag to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f_off</span></code></dt><dd><p>offset from start of f-&gt;bv_page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f_len</span></code></dt><dd><p>length from f_off to loop over</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>(temp var) current page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p_off</span></code></dt><dd><p>(temp var) offset from start of current page,
non-zero only on first page.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p_len</span></code></dt><dd><p>(temp var) length in current page,
&lt; PAGE_SIZE only on first and last page.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copied</span></code></dt><dd><p>(temp var) length so far, excluding current p_len.</p>
<p>A fragment can hold a compound page, in which case per-page
operations, notably kmap_atomic, must be called for each
regular page.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.skb_shared_hwtstamps">
struct <code class="sig-name descname">skb_shared_hwtstamps</code><a class="headerlink" href="#c.skb_shared_hwtstamps" title="Permalink to this definition">¶</a></dt>
<dd><p>hardware time stamps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct skb_shared_hwtstamps {
    union {
        ktime_t hwtstamp;
        void *netdev_data;
    };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hwtstamp</span></code></dt><dd><p>hardware time stamp transformed into duration
since arbitrary point in time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_data</span></code></dt><dd><p>address/cookie of network device driver used as
reference to actual hardware time stamp</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Software time stamps generated by <a class="reference internal" href="../core-api/timekeeping.html#c.ktime_get_real" title="ktime_get_real"><code class="xref c c-func docutils literal notranslate"><span class="pre">ktime_get_real()</span></code></a> are stored in
skb-&gt;tstamp.</p>
<p>hwtstamps can only be compared against other hwtstamps from
the same device.</p>
<p>This structure is attached to packets as part of the
<code class="xref c c-type docutils literal notranslate"><span class="pre">skb_shared_info</span></code>. Use skb_hwtstamps() to get a pointer.</p>
<dl class="type">
<dt id="c.sk_buff">
struct <code class="sig-name descname">sk_buff</code><a class="headerlink" href="#c.sk_buff" title="Permalink to this definition">¶</a></dt>
<dd><p>socket buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sk_buff {
    union {
        struct {
            struct sk_buff          *next;
            struct sk_buff          *prev;
            union {
                struct net_device       *dev;
                unsigned long           dev_scratch;
            };
        };
        struct rb_node          rbnode;
        struct list_head        list;
        struct llist_node       ll_node;
    };
    union {
        struct sock             *sk;
        int ip_defrag_offset;
    };
    union {
        ktime_t tstamp;
        u64 skb_mstamp_ns;
    };
    char cb[48] ;
    union {
        struct {
            unsigned long   _skb_refdst;
            void (*destructor)(struct sk_buff *skb);
        };
        struct list_head        tcp_tsorted_anchor;
#ifdef CONFIG_NET_SOCK_MSG;
        unsigned long           _sk_redir;
#endif;
    };
#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE);
    unsigned long            _nfct;
#endif;
    unsigned int            len, data_len;
    __u16 mac_len, hdr_len;
    __u16 queue_mapping;
#ifdef __BIG_ENDIAN_BITFIELD;
#define CLONED_MASK     (1 &lt;&lt; 7);
#else;
#define CLONED_MASK     1;
#endif;
#define CLONED_OFFSET           offsetof(struct sk_buff, __cloned_offset);
    __u8 cloned:1,nohdr:1,fclone:2,peeked:1,head_frag:1,pfmemalloc:1, pp_recycle:1;
#ifdef CONFIG_SKB_EXTENSIONS;
    __u8 active_extensions;
#endif;
    __u8 pkt_type:3;
    __u8 ignore_df:1;
    __u8 nf_trace:1;
    __u8 ip_summed:2;
    __u8 ooo_okay:1;
    __u8 l4_hash:1;
    __u8 sw_hash:1;
    __u8 wifi_acked_valid:1;
    __u8 wifi_acked:1;
    __u8 no_fcs:1;
    __u8 encapsulation:1;
    __u8 encap_hdr_csum:1;
    __u8 csum_valid:1;
    __u8 remcsum_offload:1;
    __u8 csum_complete_sw:1;
    __u8 csum_level:2;
    __u8 dst_pending_confirm:1;
    __u8 mono_delivery_time:1;
#ifdef CONFIG_NET_CLS_ACT;
    __u8 tc_skip_classify:1;
    __u8 tc_at_ingress:1;
#endif;
#ifdef CONFIG_IPV6_NDISC_NODETYPE;
    __u8 ndisc_nodetype:2;
#endif;
    __u8 ipvs_property:1;
    __u8 inner_protocol_type:1;
#ifdef CONFIG_NET_SWITCHDEV;
    __u8 offload_fwd_mark:1;
    __u8 offload_l3_fwd_mark:1;
#endif;
    __u8 redirected:1;
#ifdef CONFIG_NET_REDIRECT;
    __u8 from_ingress:1;
#endif;
#ifdef CONFIG_NETFILTER_SKIP_EGRESS;
    __u8 nf_skip_egress:1;
#endif;
#ifdef CONFIG_TLS_DEVICE;
    __u8 decrypted:1;
#endif;
    __u8 slow_gro:1;
    __u8 csum_not_inet:1;
    __u8 scm_io_uring:1;
#ifdef CONFIG_NET_SCHED;
    __u16 tc_index;
#endif;
    union {
        __wsum csum;
        struct {
            __u16 csum_start;
            __u16 csum_offset;
        };
    };
    __u32 priority;
    int skb_iif;
    __u32 hash;
    union {
        u32 vlan_all;
        struct {
            __be16 vlan_proto;
            __u16 vlan_tci;
        };
    };
#if defined(CONFIG_NET_RX_BUSY_POLL) || defined(CONFIG_XPS);
    union {
        unsigned int    napi_id;
        unsigned int    sender_cpu;
    };
#endif;
    u16 alloc_cpu;
#ifdef CONFIG_NETWORK_SECMARK;
    __u32 secmark;
#endif;
    union {
        __u32 mark;
        __u32 reserved_tailroom;
    };
    union {
        __be16 inner_protocol;
        __u8 inner_ipproto;
    };
    __u16 inner_transport_header;
    __u16 inner_network_header;
    __u16 inner_mac_header;
    __be16 protocol;
    __u16 transport_header;
    __u16 network_header;
    __u16 mac_header;
#ifdef CONFIG_KCOV;
    u64 kcov_handle;
#endif;
    sk_buff_data_t tail;
    sk_buff_data_t end;
    unsigned char           *head, *data;
    unsigned int            truesize;
    refcount_t users;
#ifdef CONFIG_SKB_EXTENSIONS;
    struct skb_ext          *extensions;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><p>Next buffer in list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prev</span></code></dt><dd><p>Previous buffer in list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Device we arrived on/are leaving by</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_scratch</span></code></dt><dd><p>(aka <strong>dev</strong>) alternate use of <strong>dev</strong> when <strong>dev</strong> would be <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rbnode</span></code></dt><dd><p>RB tree node, alternative to next/prev for netem/tcp</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>queue head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ll_node</span></code></dt><dd><p>anchor in an llist (eg socket defer_list)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk</span></code></dt><dd><p>Socket we are owned by</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ip_defrag_offset</span></code></dt><dd><p>(aka <strong>sk</strong>) alternate use of <strong>sk</strong>, used in
fragmentation management</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tstamp</span></code></dt><dd><p>Time we arrived/left</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skb_mstamp_ns</span></code></dt><dd><p>(aka <strong>tstamp</strong>) earliest departure time; start point
for retransmit timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cb</span></code></dt><dd><p>Control buffer. Free for use by every layer. Put private vars here</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_skb_refdst</span></code></dt><dd><p>destination entry (with norefcount bit)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">destructor</span></code></dt><dd><p>Destruct function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tcp_tsorted_anchor</span></code></dt><dd><p>list structure for TCP (tp-&gt;tsorted_sent_queue)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_sk_redir</span></code></dt><dd><p>socket redirection information for skmsg</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_nfct</span></code></dt><dd><p>Associated connection, if any (with nfctinfo bits)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>Length of actual data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data_len</span></code></dt><dd><p>Data length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_len</span></code></dt><dd><p>Length of link layer header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hdr_len</span></code></dt><dd><p>writable header length of cloned skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queue_mapping</span></code></dt><dd><p>Queue mapping for multiqueue devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cloned</span></code></dt><dd><p>Head may be cloned (check refcnt to be sure)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nohdr</span></code></dt><dd><p>Payload reference only, must not modify header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fclone</span></code></dt><dd><p>skbuff clone status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peeked</span></code></dt><dd><p>this packet has been seen already, so stats have been
done for it, don’t do them again</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head_frag</span></code></dt><dd><p>skb was allocated from page fragments,
not allocated by <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> or <a class="reference internal" href="../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pfmemalloc</span></code></dt><dd><p>skbuff was allocated from PFMEMALLOC reserves</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pp_recycle</span></code></dt><dd><p>mark the packet for recycling instead of freeing (implies
page_pool support on driver)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active_extensions</span></code></dt><dd><p>active extensions (skb_ext_id types)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pkt_type</span></code></dt><dd><p>Packet class</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ignore_df</span></code></dt><dd><p>allow local fragmentation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nf_trace</span></code></dt><dd><p>netfilter packet trace flag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ip_summed</span></code></dt><dd><p>Driver fed us an IP checksum</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ooo_okay</span></code></dt><dd><p>allow the mapping of a socket to a queue to be changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l4_hash</span></code></dt><dd><p>indicate hash is a canonical 4-tuple hash over transport
ports.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sw_hash</span></code></dt><dd><p>indicates hash was computed in software stack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wifi_acked_valid</span></code></dt><dd><p>wifi_acked was set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wifi_acked</span></code></dt><dd><p>whether frame was acked on wifi or not</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">no_fcs</span></code></dt><dd><p>Request NIC to treat last 4 bytes as Ethernet FCS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encapsulation</span></code></dt><dd><p>indicates the inner headers in the skbuff are valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encap_hdr_csum</span></code></dt><dd><p>software checksum is needed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_valid</span></code></dt><dd><p>checksum is already valid</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remcsum_offload</span></code></dt><dd><p>remote checksum offload is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_complete_sw</span></code></dt><dd><p>checksum was completed by software</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_level</span></code></dt><dd><p>indicates the number of consecutive checksums found in
the packet minus one that have been verified as
CHECKSUM_UNNECESSARY (max 3)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dst_pending_confirm</span></code></dt><dd><p>need to confirm neighbour</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mono_delivery_time</span></code></dt><dd><p>When set, skb-&gt;tstamp has the
delivery_time in mono clock base (i.e. EDT).  Otherwise, the
skb-&gt;tstamp has the (rcv) timestamp at ingress and
delivery_time at egress.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tc_skip_classify</span></code></dt><dd><p>do not classify packet. set by IFB device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tc_at_ingress</span></code></dt><dd><p>used within tc_classify to distinguish in/egress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ndisc_nodetype</span></code></dt><dd><p>router type (from link layer)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ipvs_property</span></code></dt><dd><p>skbuff is owned by ipvs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_protocol_type</span></code></dt><dd><p>whether the inner protocol is
ENCAP_TYPE_ETHER or ENCAP_TYPE_IPPROTO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offload_fwd_mark</span></code></dt><dd><p>Packet was L2-forwarded in hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offload_l3_fwd_mark</span></code></dt><dd><p>Packet was L3-forwarded in hardware</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">redirected</span></code></dt><dd><p>packet was redirected by packet classifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">from_ingress</span></code></dt><dd><p>packet was redirected from the ingress path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nf_skip_egress</span></code></dt><dd><p>packet shall skip nf egress - see netfilter_netdev.h</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">decrypted</span></code></dt><dd><p>Decrypted SKB</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">slow_gro</span></code></dt><dd><p>state present at GRO time, slower prepare step required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_not_inet</span></code></dt><dd><p>use CRC32c to resolve CHECKSUM_PARTIAL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scm_io_uring</span></code></dt><dd><p>SKB holds io_uring registered files</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tc_index</span></code></dt><dd><p>Traffic control index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum</span></code></dt><dd><p>Checksum (must include start/offset pair)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_start</span></code></dt><dd><p>Offset from skb-&gt;head where checksumming should start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">csum_offset</span></code></dt><dd><p>Offset from csum_start where checksum should be stored</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priority</span></code></dt><dd><p>Packet queueing priority</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skb_iif</span></code></dt><dd><p>ifindex of device we arrived on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hash</span></code></dt><dd><p>the packet hash</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_all</span></code></dt><dd><p>vlan fields (proto &amp; tci)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_proto</span></code></dt><dd><p>vlan encapsulation protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_tci</span></code></dt><dd><p>vlan tag control information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">napi_id</span></code></dt><dd><p>id of the NAPI struct this skb came from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sender_cpu</span></code></dt><dd><p>(aka <strong>napi_id</strong>) source CPU in XPS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">alloc_cpu</span></code></dt><dd><p>CPU which did the skb allocation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">secmark</span></code></dt><dd><p>security marking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mark</span></code></dt><dd><p>Generic packet mark</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved_tailroom</span></code></dt><dd><p>(aka <strong>mark</strong>) number of bytes of free space available
at the tail of an sk_buff</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_protocol</span></code></dt><dd><p>Protocol (encapsulation)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_ipproto</span></code></dt><dd><p>(aka <strong>inner_protocol</strong>) stores ipproto when
skb-&gt;inner_protocol_type == ENCAP_TYPE_IPPROTO;</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_transport_header</span></code></dt><dd><p>Inner transport layer header (encapsulation)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_network_header</span></code></dt><dd><p>Network layer header (encapsulation)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">inner_mac_header</span></code></dt><dd><p>Link layer header (encapsulation)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">protocol</span></code></dt><dd><p>Packet protocol from driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">transport_header</span></code></dt><dd><p>Transport layer header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">network_header</span></code></dt><dd><p>Network layer header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_header</span></code></dt><dd><p>Link layer header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">kcov_handle</span></code></dt><dd><p>KCOV remote handle for remote coverage collection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tail</span></code></dt><dd><p>Tail pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end</span></code></dt><dd><p>End pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>Head of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Data head pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">truesize</span></code></dt><dd><p>Buffer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">users</span></code></dt><dd><p>User count - see {datagram,tcp}.c</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">extensions</span></code></dt><dd><p>allocated extensions, valid if active_extensions is nonzero</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_pfmemalloc">
bool <code class="sig-name descname">skb_pfmemalloc</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pfmemalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the skb was allocated from PFMEMALLOC reserves</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_dst">
struct dst_entry * <code class="sig-name descname">skb_dst</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst" title="Permalink to this definition">¶</a></dt>
<dd><p>returns skb dst_entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns skb dst_entry, regardless of reference taken or not.</p>
</div>
<dl class="function">
<dt id="c.skb_dst_set">
void <code class="sig-name descname">skb_dst_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct dst_entry<em> *dst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst_set" title="Permalink to this definition">¶</a></dt>
<dd><p>sets skb dst</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dst_entry</span> <span class="pre">*dst</span></code></dt><dd><p>dst entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets skb dst, assuming a reference was taken on dst and should
be released by skb_dst_drop()</p>
</div>
<dl class="function">
<dt id="c.skb_dst_set_noref">
void <code class="sig-name descname">skb_dst_set_noref</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct dst_entry<em> *dst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst_set_noref" title="Permalink to this definition">¶</a></dt>
<dd><p>sets skb dst, hopefully, without taking reference</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dst_entry</span> <span class="pre">*dst</span></code></dt><dd><p>dst entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets skb dst, assuming a reference was not taken on dst.
If dst entry is cached, we do not take reference and dst_release
will be avoided by refdst_drop. If dst entry is not cached, we take
reference, so that last dst_release can destroy the dst immediately.</p>
</div>
<dl class="function">
<dt id="c.skb_dst_is_noref">
bool <code class="sig-name descname">skb_dst_is_noref</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst_is_noref" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if skb dst isn’t refcounted</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_rtable">
struct rtable * <code class="sig-name descname">skb_rtable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_rtable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the skb <code class="xref c c-type docutils literal notranslate"><span class="pre">rtable</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_napi_id">
unsigned int <code class="sig-name descname">skb_napi_id</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_napi_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the skb’s NAPI id</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_unref">
bool <code class="sig-name descname">skb_unref</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement the skb’s reference count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if we can free the skb.</p>
</div>
<dl class="function">
<dt id="c.kfree_skb">
void <code class="sig-name descname">kfree_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>free an sk_buff with ‘NOT_SPECIFIED’ reason</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to free</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">alloc_skb</code><span class="sig-paren">(</span>unsigned int<em> size</em>, gfp_t<em> priority</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a network buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">priority</span></code></dt><dd><p>allocation mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a convenient wrapper around <a class="reference internal" href="#c.__alloc_skb" title="__alloc_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">__alloc_skb()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.skb_fclone_busy">
bool <code class="sig-name descname">skb_fclone_busy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_fclone_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if fclone is busy</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if skb is a fast clone, and its clone is not freed.
Some drivers call <a class="reference internal" href="#c.skb_orphan" title="skb_orphan"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_orphan()</span></code></a> in their ndo_start_xmit(),
so we also check that this didnt happen.</p>
</div>
<dl class="function">
<dt id="c.alloc_skb_fclone">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">alloc_skb_fclone</code><span class="sig-paren">(</span>unsigned int<em> size</em>, gfp_t<em> priority</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_skb_fclone" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a network buffer from fclone cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">priority</span></code></dt><dd><p>allocation mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a convenient wrapper around <a class="reference internal" href="#c.__alloc_skb" title="__alloc_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">__alloc_skb()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.skb_pad">
int <code class="sig-name descname">skb_pad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> pad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>zero pad the tail of an skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pad</span></code></dt><dd><p>space to pad</p>
<p>Ensure that a buffer is followed by a padding area that is zero
filled. Used by network drivers which may DMA or transfer data
beyond the buffer end onto the wire.</p>
<p>May return error in out of memory cases. The skb is freed on error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_empty">
int <code class="sig-name descname">skb_queue_empty</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a queue is empty</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>queue head</p>
<p>Returns true if the queue is empty, false otherwise.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_empty_lockless">
bool <code class="sig-name descname">skb_queue_empty_lockless</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_empty_lockless" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a queue is empty</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>queue head</p>
<p>Returns true if the queue is empty, false otherwise.
This variant can be used in lockless contexts.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_is_last">
bool <code class="sig-name descname">skb_queue_is_last</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_is_last" title="Permalink to this definition">¶</a></dt>
<dd><p>check if skb is the last entry in the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>queue head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
<p>Returns true if <strong>skb</strong> is the last buffer on the list.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_is_first">
bool <code class="sig-name descname">skb_queue_is_first</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_is_first" title="Permalink to this definition">¶</a></dt>
<dd><p>check if skb is the first entry in the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>queue head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
<p>Returns true if <strong>skb</strong> is the first buffer on the list.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_next">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_queue_next</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_next" title="Permalink to this definition">¶</a></dt>
<dd><p>return the next packet in the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>queue head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>current buffer</p>
<p>Return the next packet in <strong>list</strong> after <strong>skb</strong>.  It is only valid to
call this if <a class="reference internal" href="#c.skb_queue_is_last" title="skb_queue_is_last"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_queue_is_last()</span></code></a> evaluates to false.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_prev">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_queue_prev</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_prev" title="Permalink to this definition">¶</a></dt>
<dd><p>return the prev packet in the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>queue head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>current buffer</p>
<p>Return the prev packet in <strong>list</strong> before <strong>skb</strong>.  It is only valid to
call this if <a class="reference internal" href="#c.skb_queue_is_first" title="skb_queue_is_first"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_queue_is_first()</span></code></a> evaluates to false.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_get">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_get" title="Permalink to this definition">¶</a></dt>
<dd><p>reference buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to reference</p>
<p>Makes another reference to a socket buffer and returns a pointer
to the buffer.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_cloned">
int <code class="sig-name descname">skb_cloned</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cloned" title="Permalink to this definition">¶</a></dt>
<dd><p>is the buffer a clone</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to check</p>
<p>Returns true if the buffer was generated with <a class="reference internal" href="#c.skb_clone" title="skb_clone"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_clone()</span></code></a> and is
one of multiple shared copies of the buffer. Cloned buffers are
shared data so must not be written to under normal circumstances.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_header_cloned">
int <code class="sig-name descname">skb_header_cloned</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_header_cloned" title="Permalink to this definition">¶</a></dt>
<dd><p>is the header a clone</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to check</p>
<p>Returns true if modifying the header part of the buffer requires
the data to be copied.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_header_release">
void <code class="sig-name descname">__skb_header_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_header_release" title="Permalink to this definition">¶</a></dt>
<dd><p>allow clones to use the headroom</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to operate on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See “DOC: dataref and headerless skbs”.</p>
</div>
<dl class="function">
<dt id="c.skb_shared">
int <code class="sig-name descname">skb_shared</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_shared" title="Permalink to this definition">¶</a></dt>
<dd><p>is the buffer shared</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to check</p>
<p>Returns true if more than one person has a reference to this
buffer.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_share_check">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_share_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, gfp_t<em> pri</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_share_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check if buffer is shared and if so clone it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">pri</span></code></dt><dd><p>priority for memory allocation</p>
<p>If the buffer is shared the buffer is cloned and the old copy
drops a reference. A new clone with a single reference is returned.
If the buffer is not shared the original buffer is returned. When
being called from interrupt status or with spinlocks held pri must
be GFP_ATOMIC.</p>
<p>NULL is returned on a memory allocation failure.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_unshare">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_unshare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, gfp_t<em> pri</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_unshare" title="Permalink to this definition">¶</a></dt>
<dd><p>make a copy of a shared buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">pri</span></code></dt><dd><p>priority for memory allocation</p>
<p>If the socket buffer is a clone then this function creates a new
copy of the data, drops a reference count on the old copy and returns
the new copy with the reference count at 1. If the buffer is not a clone
the original buffer is returned. When called with a spinlock held or
from interrupt state <strong>pri</strong> must be <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned on a memory allocation failure.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_peek">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_peek</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at the head of an <code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff_head</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list_</span></code></dt><dd><p>list to peek at</p>
<p>Peek an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>. Unlike most other operations you _MUST_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for an empty list or a pointer to the head element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_peek">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__skb_peek</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at the head of a non-empty <code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff_head</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list_</span></code></dt><dd><p>list to peek at</p>
<p>Like <a class="reference internal" href="#c.skb_peek" title="skb_peek"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_peek()</span></code></a>, but the caller knows that the list is not empty.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_peek_next">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_peek_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, const struct sk_buff_head<em> *list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_peek_next" title="Permalink to this definition">¶</a></dt>
<dd><p>peek skb following the given one from a queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>skb to start from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list_</span></code></dt><dd><p>list to peek at</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when the end of the list is met or a pointer to the
next element. The reference count is not incremented and the
reference is therefore volatile. Use with caution.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_peek_tail">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_peek_tail</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_peek_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at the tail of an <code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff_head</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list_</span></code></dt><dd><p>list to peek at</p>
<p>Peek an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>. Unlike most other operations you _MUST_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for an empty list or a pointer to the tail element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_len">
__u32 <code class="sig-name descname">skb_queue_len</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_len" title="Permalink to this definition">¶</a></dt>
<dd><p>get queue length</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list_</span></code></dt><dd><p>list to measure</p>
<p>Return the length of an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> queue.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_len_lockless">
__u32 <code class="sig-name descname">skb_queue_len_lockless</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_len_lockless" title="Permalink to this definition">¶</a></dt>
<dd><p>get queue length</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list_</span></code></dt><dd><p>list to measure</p>
<p>Return the length of an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> queue.
This variant can be used in lockless contexts.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_queue_head_init">
void <code class="sig-name descname">__skb_queue_head_init</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_head_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize non-spinlock portions of sk_buff_head</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>queue to initialize</p>
<p>This initializes only the list and queue length aspects of
an sk_buff_head object.  This allows to initialize the list
aspects of an sk_buff_head without reinitializing things like
the spinlock.  It can also be used for on-stack sk_buff_head
objects where the spinlock is known to not be used.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_splice">
void <code class="sig-name descname">skb_queue_splice</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list</em>, struct sk_buff_head<em> *head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists, this is designed for stacks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_splice_init">
void <code class="sig-name descname">skb_queue_splice_init</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em>, struct sk_buff_head<em> *head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists and reinitialise the emptied list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list</p>
<p>The list at <strong>list</strong> is reinitialised</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_splice_tail">
void <code class="sig-name descname">skb_queue_splice_tail</code><span class="sig-paren">(</span>const struct sk_buff_head<em> *list</em>, struct sk_buff_head<em> *head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists, each list being a queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_splice_tail_init">
void <code class="sig-name descname">skb_queue_splice_tail_init</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em>, struct sk_buff_head<em> *head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice_tail_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists and reinitialise the emptied list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list</p>
<p>Each of the lists is a queue.
The list at <strong>list</strong> is reinitialised</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_queue_after">
void <code class="sig-name descname">__skb_queue_after</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *prev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_after" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list head</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*prev</span></code></dt><dd><p>place after this buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*newsk</span></code></dt><dd><p>buffer to queue</p>
<p>Queue a buffer int the middle of a list. This function takes no locks
and you must therefore hold required locks before calling it.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_queue_head">
void <code class="sig-name descname">__skb_queue_head</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_head" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list head</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*newsk</span></code></dt><dd><p>buffer to queue</p>
<p>Queue a buffer at the start of a list. This function takes no locks
and you must therefore hold required locks before calling it.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_queue_tail">
void <code class="sig-name descname">__skb_queue_tail</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list tail</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*newsk</span></code></dt><dd><p>buffer to queue</p>
<p>Queue a buffer at the end of a list. This function takes no locks
and you must therefore hold required locks before calling it.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_dequeue">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__skb_dequeue</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_dequeue" title="Permalink to this definition">¶</a></dt>
<dd><p>remove from the head of the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to dequeue from</p>
<p>Remove the head of the list. This function does not take any locks
so must be used with appropriate locks held only. The head item is
returned or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the list is empty.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_dequeue_tail">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__skb_dequeue_tail</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_dequeue_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>remove from the tail of the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to dequeue from</p>
<p>Remove the tail of the list. This function does not take any locks
so must be used with appropriate locks held only. The tail item is
returned or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the list is empty.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_len_add">
void <code class="sig-name descname">skb_len_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> delta</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_len_add" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a number to len fields of skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to add len to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">delta</span></code></dt><dd><p>number of bytes to add</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_fill_page_desc">
void <code class="sig-name descname">__skb_fill_page_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> i</em>, struct page<em> *page</em>, int<em> off</em>, int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_fill_page_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a paged fragment in an skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer containing fragment to be initialised</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>paged fragment index to initialise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the page to use for this fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">off</span></code></dt><dd><p>the offset to the data with <strong>page</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the length of the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises the <strong>i</strong>’th fragment of <strong>skb</strong> to point to <code class="xref c c-type docutils literal notranslate"><span class="pre">size</span></code> bytes at
offset <strong>off</strong> within <strong>page</strong>.</p>
<p>Does not take any additional reference on the fragment.</p>
</div>
<dl class="function">
<dt id="c.skb_fill_page_desc">
void <code class="sig-name descname">skb_fill_page_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> i</em>, struct page<em> *page</em>, int<em> off</em>, int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_fill_page_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a paged fragment in an skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer containing fragment to be initialised</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>paged fragment index to initialise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the page to use for this fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">off</span></code></dt><dd><p>the offset to the data with <strong>page</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the length of the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>As per <a class="reference internal" href="#c.__skb_fill_page_desc" title="__skb_fill_page_desc"><code class="xref c c-func docutils literal notranslate"><span class="pre">__skb_fill_page_desc()</span></code></a> – initialises the <strong>i</strong>’th fragment of
<strong>skb</strong> to point to <strong>size</strong> bytes at offset <strong>off</strong> within <strong>page</strong>. In
addition updates <strong>skb</strong> such that <strong>i</strong> is the last fragment.</p>
<p>Does not take any additional reference on the fragment.</p>
</div>
<dl class="function">
<dt id="c.skb_fill_page_desc_noacc">
void <code class="sig-name descname">skb_fill_page_desc_noacc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> i</em>, struct page<em> *page</em>, int<em> off</em>, int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_fill_page_desc_noacc" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a paged fragment in an skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer containing fragment to be initialised</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">i</span></code></dt><dd><p>paged fragment index to initialise</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the page to use for this fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">off</span></code></dt><dd><p>the offset to the data with <strong>page</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the length of the data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Variant of <a class="reference internal" href="#c.skb_fill_page_desc" title="skb_fill_page_desc"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_fill_page_desc()</span></code></a> which does not deal with
pfmemalloc, if page is not owned by us.</p>
</div>
<dl class="function">
<dt id="c.skb_headroom">
unsigned int <code class="sig-name descname">skb_headroom</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_headroom" title="Permalink to this definition">¶</a></dt>
<dd><p>bytes at buffer head</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to check</p>
<p>Return the number of bytes of free space at the head of an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_tailroom">
int <code class="sig-name descname">skb_tailroom</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tailroom" title="Permalink to this definition">¶</a></dt>
<dd><p>bytes at buffer end</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to check</p>
<p>Return the number of bytes of free space at the tail of an sk_buff</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_availroom">
int <code class="sig-name descname">skb_availroom</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_availroom" title="Permalink to this definition">¶</a></dt>
<dd><p>bytes at buffer end</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to check</p>
<p>Return the number of bytes of free space at the tail of an sk_buff
allocated by sk_stream_alloc()</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_reserve">
void <code class="sig-name descname">skb_reserve</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust headroom</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to alter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>bytes to move</p>
<p>Increase the headroom of an empty <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> by reducing the tail
room. This is only allowed for an empty buffer.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_tailroom_reserve">
void <code class="sig-name descname">skb_tailroom_reserve</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> mtu</em>, unsigned int<em> needed_tailroom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tailroom_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust reserved_tailroom</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to alter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mtu</span></code></dt><dd><p>maximum amount of headlen permitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">needed_tailroom</span></code></dt><dd><p>minimum amount of reserved_tailroom</p>
<p>Set reserved_tailroom so that headlen can be as large as possible but
not larger than mtu and tailroom cannot be smaller than
needed_tailroom.
The required headroom should already have been reserved before using
this function.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pskb_trim_unique">
void <code class="sig-name descname">pskb_trim_unique</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_trim_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>remove end from a paged unique (not cloned) buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to alter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>new length</p>
<p>This is identical to pskb_trim except that the caller knows that
the skb is not cloned so we should never get an error due to out-
of-memory.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_orphan">
void <code class="sig-name descname">skb_orphan</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_orphan" title="Permalink to this definition">¶</a></dt>
<dd><p>orphan a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to orphan</p>
<p>If a buffer currently has an owner then we call the owner’s
destructor function and make the <strong>skb</strong> unowned. The buffer continues
to exist but is no longer charged to its former owner.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_orphan_frags">
int <code class="sig-name descname">skb_orphan_frags</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_orphan_frags" title="Permalink to this definition">¶</a></dt>
<dd><p>orphan the frags contained in a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to orphan frags from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation mask for replacement pages</p>
<p>For each frag in the SKB which needs a destructor (i.e. has an
owner) create a copy of that frag and release the original
page by calling the destructor.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_queue_purge">
void <code class="sig-name descname">__skb_queue_purge</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_purge" title="Permalink to this definition">¶</a></dt>
<dd><p>empty a list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to empty</p>
<p>Delete all buffers on an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> list. Each buffer is removed from
the list and one reference dropped. This function does not take the
list lock and the caller must hold the relevant locks to use it.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_alloc_frag">
void * <code class="sig-name descname">netdev_alloc_frag</code><span class="sig-paren">(</span>unsigned int<em> fragsz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_alloc_frag" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a page fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fragsz</span></code></dt><dd><p>fragment size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a frag from a page for receive buffer.
Uses GFP_ATOMIC allocations.</p>
</div>
<dl class="function">
<dt id="c.netdev_alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">netdev_alloc_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, unsigned int<em> length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an skbuff for rx on a specific device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device to receive on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">length</span></code></dt><dd><p>length to allocate</p>
<p>Allocate a new <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and assign it a usage count of one. The
buffer has unspecified headroom built in. Users should allocate
the headroom they think they need without accounting for the
built in space. The built in space is used for optimisations.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if there is no free memory. Although this function
allocates memory it can be called from an interrupt.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__dev_alloc_pages">
struct page * <code class="sig-name descname">__dev_alloc_pages</code><span class="sig-paren">(</span>gfp_t<em> gfp_mask</em>, unsigned int<em> order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_alloc_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate page for network Rx</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority. Set __GFP_NOMEMALLOC if not for network Rx</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt><dd><p>size of the allocation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a new page.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
</div>
<dl class="function">
<dt id="c.__dev_alloc_page">
struct page * <code class="sig-name descname">__dev_alloc_page</code><span class="sig-paren">(</span>gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_alloc_page" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a page for network Rx</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority. Set __GFP_NOMEMALLOC if not for network Rx</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a new page.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
</div>
<dl class="function">
<dt id="c.dev_page_is_reusable">
bool <code class="sig-name descname">dev_page_is_reusable</code><span class="sig-paren">(</span>const struct page<em> *page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_page_is_reusable" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether a page can be reused for network Rx</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the page to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A page shouldn’t be considered for reusing/recycling if it was allocated
under memory pressure or at a distant memory node.</p>
<p>Returns false if this page should be returned to page allocator, true
otherwise.</p>
</div>
<dl class="function">
<dt id="c.skb_propagate_pfmemalloc">
void <code class="sig-name descname">skb_propagate_pfmemalloc</code><span class="sig-paren">(</span>const struct page<em> *page</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_propagate_pfmemalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate pfmemalloc if skb is allocated after RX page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>The page that was allocated from skb_alloc_page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>The skb that may need pfmemalloc set</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_frag_off">
unsigned int <code class="sig-name descname">skb_frag_off</code><span class="sig-paren">(</span>const skb_frag_t<em> *frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the offset of a skb fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>the paged fragment</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_frag_off_add">
void <code class="sig-name descname">skb_frag_off_add</code><span class="sig-paren">(</span>skb_frag_t<em> *frag</em>, int<em> delta</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_off_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Increments the offset of a skb fragment by <strong>delta</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>skb fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">delta</span></code></dt><dd><p>value to add</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_frag_off_set">
void <code class="sig-name descname">skb_frag_off_set</code><span class="sig-paren">(</span>skb_frag_t<em> *frag</em>, unsigned int<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_off_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the offset of a skb fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>skb fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset of fragment</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_frag_off_copy">
void <code class="sig-name descname">skb_frag_off_copy</code><span class="sig-paren">(</span>skb_frag_t<em> *fragto</em>, const skb_frag_t<em> *fragfrom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_off_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the offset of a skb fragment from another fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*fragto</span></code></dt><dd><p>skb fragment where offset is set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*fragfrom</span></code></dt><dd><p>skb fragment offset is copied from</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_frag_page">
struct page * <code class="sig-name descname">skb_frag_page</code><span class="sig-paren">(</span>const skb_frag_t<em> *frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_page" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve the page referred to by a paged fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>the paged fragment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span></code> associated with <strong>frag</strong>.</p>
</div>
<dl class="function">
<dt id="c.__skb_frag_ref">
void <code class="sig-name descname">__skb_frag_ref</code><span class="sig-paren">(</span>skb_frag_t<em> *frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_frag_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>take an addition reference on a paged fragment.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>the paged fragment</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes an additional reference on the paged fragment <strong>frag</strong>.</p>
</div>
<dl class="function">
<dt id="c.skb_frag_ref">
void <code class="sig-name descname">skb_frag_ref</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>take an addition reference on a paged fragment of an skb.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">f</span></code></dt><dd><p>the fragment offset.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes an additional reference on the <strong>f</strong>’th paged fragment of <strong>skb</strong>.</p>
</div>
<dl class="function">
<dt id="c.__skb_frag_unref">
void <code class="sig-name descname">__skb_frag_unref</code><span class="sig-paren">(</span>skb_frag_t<em> *frag</em>, bool<em> recycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_frag_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference on a paged fragment.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>the paged fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">recycle</span></code></dt><dd><p>recycle the page if allocated via page_pool</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a reference on the paged fragment <strong>frag</strong>
or recycles the page via the page_pool API.</p>
</div>
<dl class="function">
<dt id="c.skb_frag_unref">
void <code class="sig-name descname">skb_frag_unref</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference on a paged fragment of an skb.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">f</span></code></dt><dd><p>the fragment offset</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a reference on the <strong>f</strong>’th paged fragment of <strong>skb</strong>.</p>
</div>
<dl class="function">
<dt id="c.skb_frag_address">
void * <code class="sig-name descname">skb_frag_address</code><span class="sig-paren">(</span>const skb_frag_t<em> *frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_address" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the address of the data contained in a paged fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>the paged fragment buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the data within <strong>frag</strong>. The page must already
be mapped.</p>
</div>
<dl class="function">
<dt id="c.skb_frag_address_safe">
void * <code class="sig-name descname">skb_frag_address_safe</code><span class="sig-paren">(</span>const skb_frag_t<em> *frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_address_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the address of the data contained in a paged fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>the paged fragment buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the data within <strong>frag</strong>. Checks that the page
is mapped and returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.skb_frag_page_copy">
void <code class="sig-name descname">skb_frag_page_copy</code><span class="sig-paren">(</span>skb_frag_t<em> *fragto</em>, const skb_frag_t<em> *fragfrom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_page_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the page in a fragment from another fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*fragto</span></code></dt><dd><p>skb fragment where page is set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*fragfrom</span></code></dt><dd><p>skb fragment page is copied from</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_frag_set_page">
void <code class="sig-name descname">__skb_frag_set_page</code><span class="sig-paren">(</span>skb_frag_t<em> *frag</em>, struct page<em> *page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_frag_set_page" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the page contained in a paged fragment</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>the paged fragment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the page to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the fragment <strong>frag</strong> to contain <strong>page</strong>.</p>
</div>
<dl class="function">
<dt id="c.skb_frag_set_page">
void <code class="sig-name descname">skb_frag_set_page</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> f</em>, struct page<em> *page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_set_page" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the page contained in a paged fragment of an skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">f</span></code></dt><dd><p>the fragment offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>the page to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the <strong>f</strong>’th fragment of <strong>skb</strong> to contain <strong>page</strong>.</p>
</div>
<dl class="function">
<dt id="c.skb_frag_dma_map">
dma_addr_t <code class="sig-name descname">skb_frag_dma_map</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const skb_frag_t<em> *frag</em>, size_t<em> offset</em>, size_t<em> size</em>, enum dma_data_direction<em> dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_dma_map" title="Permalink to this definition">¶</a></dt>
<dd><p>maps a paged fragment via the DMA API</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device to map the fragment to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*frag</span></code></dt><dd><p>the paged fragment to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">offset</span></code></dt><dd><p>the offset within the fragment (starting at the
fragment’s own offset)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the number of bytes to map</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>the direction of the mapping (<code class="docutils literal notranslate"><span class="pre">PCI_DMA_*</span></code>)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps the page associated with <strong>frag</strong> to <strong>device</strong>.</p>
</div>
<dl class="function">
<dt id="c.skb_clone_writable">
int <code class="sig-name descname">skb_clone_writable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_clone_writable" title="Permalink to this definition">¶</a></dt>
<dd><p>is the header of a clone writable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length up to which to write</p>
<p>Returns true if modifying the header part of the cloned buffer
does not requires the data to be copied.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_cow">
int <code class="sig-name descname">skb_cow</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> headroom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cow" title="Permalink to this definition">¶</a></dt>
<dd><p>copy header of skb when it is required</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to cow</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">headroom</span></code></dt><dd><p>needed headroom</p>
<p>If the skb passed lacks sufficient headroom or its data part
is shared, data is reallocated. If reallocation fails, an error
is returned and original skb is not changed.</p>
<p>The result is skb with writable area skb-&gt;head…skb-&gt;tail
and at least <strong>headroom</strong> of space at head.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_cow_head">
int <code class="sig-name descname">skb_cow_head</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> headroom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cow_head" title="Permalink to this definition">¶</a></dt>
<dd><p>skb_cow but only making the head writable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to cow</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">headroom</span></code></dt><dd><p>needed headroom</p>
<p>This function is identical to skb_cow except that we replace the
skb_cloned check by skb_header_cloned.  It should be used when
you only need to push on some header and do not need to modify
the data.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_padto">
int <code class="sig-name descname">skb_padto</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_padto" title="Permalink to this definition">¶</a></dt>
<dd><p>pad an skbuff up to a minimal size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>minimal length</p>
<p>Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_put_padto">
int <code class="sig-name descname">__skb_put_padto</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em>, bool<em> free_on_error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_put_padto" title="Permalink to this definition">¶</a></dt>
<dd><p>increase size and pad an skbuff up to a minimal size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>minimal length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">free_on_error</span></code></dt><dd><p>free buffer on error</p>
<p>Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error if <strong>free_on_error</strong> is true.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_put_padto">
int <code class="sig-name descname">skb_put_padto</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_put_padto" title="Permalink to this definition">¶</a></dt>
<dd><p>increase size and pad an skbuff up to a minimal size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>minimal length</p>
<p>Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_linearize">
int <code class="sig-name descname">skb_linearize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_linearize" title="Permalink to this definition">¶</a></dt>
<dd><p>convert paged skb to linear one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to linarize</p>
<p>If there is no free memory -ENOMEM is returned, otherwise zero
is returned and the old skb data released.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_has_shared_frag">
bool <code class="sig-name descname">skb_has_shared_frag</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_has_shared_frag" title="Permalink to this definition">¶</a></dt>
<dd><p>can any frag be overwritten</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the skb has at least one frag that might be modified
by an external entity (as in vmsplice()/sendfile())</p>
</div>
<dl class="function">
<dt id="c.skb_linearize_cow">
int <code class="sig-name descname">skb_linearize_cow</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_linearize_cow" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure skb is linear and writable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to process</p>
<p>If there is no free memory -ENOMEM is returned, otherwise zero
is returned and the old skb data released.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_postpull_rcsum">
void <code class="sig-name descname">skb_postpull_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, const void<em> *start</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_postpull_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>update checksum for received skb after pull</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*start</span></code></dt><dd><p>start of data before pull</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data pulled</p>
<p>After doing a pull on a received packet, you need to call this to
update the CHECKSUM_COMPLETE checksum, or set ip_summed to
CHECKSUM_NONE so that it can be recomputed from scratch.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_postpush_rcsum">
void <code class="sig-name descname">skb_postpush_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, const void<em> *start</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_postpush_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>update checksum for received skb after push</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*start</span></code></dt><dd><p>start of data after push</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data pushed</p>
<p>After doing a push on a received packet, you need to call this to
update the CHECKSUM_COMPLETE checksum.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_push_rcsum">
void * <code class="sig-name descname">skb_push_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_push_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>push skb and update receive checksum</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data pulled</p>
<p>This function performs an skb_push on the packet and updates
the CHECKSUM_COMPLETE checksum.  It should be used on
receive path processing instead of skb_push unless you know
that the checksum difference is zero (e.g., a valid IP header)
or you are setting ip_summed to CHECKSUM_NONE.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pskb_trim_rcsum">
int <code class="sig-name descname">pskb_trim_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_trim_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>trim received skb and update checksum</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to trim</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>new length</p>
<p>This is exactly the same as pskb_trim except that it ensures the
checksum of received packets are still valid after the operation.
It can change skb pointers.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_needs_linearize">
bool <code class="sig-name descname">skb_needs_linearize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, netdev_features_t<em> features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_needs_linearize" title="Permalink to this definition">¶</a></dt>
<dd><p>check if we need to linearize a given skb depending on the given device features.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>socket buffer to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">features</span></code></dt><dd><p>net device features</p>
<p>Returns true if either:
1. skb has frag_list and the device doesn’t support FRAGLIST, or
2. skb is fragmented and the device does not support SG.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_get_timestamp">
void <code class="sig-name descname">skb_get_timestamp</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct __kernel_old_timeval<em> *stamp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_get_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>get timestamp from a skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>skb to get stamp from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">__kernel_old_timeval</span> <span class="pre">*stamp</span></code></dt><dd><p>pointer to struct __kernel_old_timeval to store stamp in</p>
<p>Timestamps are stored in the skb as offsets to a base timestamp.
This function converts the offset back to a struct timeval and stores
it in stamp.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_complete_tx_timestamp">
void <code class="sig-name descname">skb_complete_tx_timestamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct <a class="reference internal" href="#c.skb_shared_hwtstamps" title="skb_shared_hwtstamps">skb_shared_hwtstamps</a><em> *hwtstamps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_complete_tx_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>deliver cloned skb with tx timestamps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>clone of the original outgoing packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skb_shared_hwtstamps</span> <span class="pre">*hwtstamps</span></code></dt><dd><p>hardware time stamps</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>PHY drivers may accept clones of transmitted packets for
timestamping via their phy_driver.txtstamp method. These drivers
must call this function to return the skb back to the stack with a
timestamp.</p>
</div>
<dl class="function">
<dt id="c.skb_tstamp_tx">
void <code class="sig-name descname">skb_tstamp_tx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *orig_skb</em>, struct <a class="reference internal" href="#c.skb_shared_hwtstamps" title="skb_shared_hwtstamps">skb_shared_hwtstamps</a><em> *hwtstamps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tstamp_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>queue clone of skb with send time stamps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*orig_skb</span></code></dt><dd><p>the original outgoing packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skb_shared_hwtstamps</span> <span class="pre">*hwtstamps</span></code></dt><dd><p>hardware time stamps, may be NULL if not available</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the skb has a socket associated, then this function clones the
skb (thus sharing the actual data and optional structures), stores
the optional hardware time stamping information (if non NULL) or
generates a software time stamp (otherwise), then queues the clone
to the error queue of the socket.  Errors are silently ignored.</p>
</div>
<dl class="function">
<dt id="c.skb_tx_timestamp">
void <code class="sig-name descname">skb_tx_timestamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tx_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver hook for transmit timestamping</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>A socket buffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ethernet MAC Drivers should call this function in their hard_xmit()
function immediately before giving the sk_buff to the MAC hardware.</p>
<p>Specifically, one should make absolutely sure that this function is
called before TX completion of this packet can trigger.  Otherwise
the packet could potentially already be freed.</p>
</div>
<dl class="function">
<dt id="c.skb_complete_wifi_ack">
void <code class="sig-name descname">skb_complete_wifi_ack</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, bool<em> acked</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_complete_wifi_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>deliver skb with wifi status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the original outgoing packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">acked</span></code></dt><dd><p>ack status</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_checksum_complete">
__sum16 <code class="sig-name descname">skb_checksum_complete</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate checksum of an entire packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>packet to process</p>
<p>This function calculates the checksum over the entire packet plus
the value of skb-&gt;csum.  The latter can be used to supply the
checksum of a pseudo header as used by TCP/UDP.  It returns the
checksum.</p>
<p>For protocols that contain complete checksums such as ICMP/TCP/UDP,
this function can be used to verify that checksum on received
packets.  In that case the function should return zero if the
checksum is correct.  In particular, this function will return zero
if skb-&gt;ip_summed is CHECKSUM_UNNECESSARY which indicates that the
hardware has already verified the correctness of the checksum.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.skb_ext">
struct <code class="sig-name descname">skb_ext</code><a class="headerlink" href="#c.skb_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>sk_buff extensions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct skb_ext {
    refcount_t refcnt;
    u8 offset[SKB_EXT_NUM];
    u8 chunks;
    char data[] ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">refcnt</span></code></dt><dd><p>1 on allocation, deallocated on 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>offset to add to <strong>data</strong> to obtain extension address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chunks</span></code></dt><dd><p>size currently allocated, stored in SKB_EXT_ALIGN_SHIFT units</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>start of extension data, variable sized</p>
</dd>
</dl>
</div>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>offsets/lengths are stored in chunks of 8 bytes, this allows</dt><dd><p>to use ‘u8’ types while allowing up to 2kb worth of extension data.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.skb_checksum_none_assert">
void <code class="sig-name descname">skb_checksum_none_assert</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_none_assert" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure skb ip_summed is CHECKSUM_NONE</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>skb to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>fresh skbs have their ip_summed set to CHECKSUM_NONE.
Instead of forcing ip_summed to CHECKSUM_NONE, we can
use this helper, to document places where we make this assertion.</p>
</div>
<dl class="function">
<dt id="c.skb_head_is_locked">
bool <code class="sig-name descname">skb_head_is_locked</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_head_is_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the skb-&gt;head is locked down</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>skb to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The head on skbs build around a head frag can be removed if they are
not cloned.  This function returns true if the skb head is locked down
due to either being allocated via kmalloc, or by being a clone with
multiple references to the head.</p>
</div>
<dl class="type">
<dt id="c.sock_common">
struct <code class="sig-name descname">sock_common</code><a class="headerlink" href="#c.sock_common" title="Permalink to this definition">¶</a></dt>
<dd><p>minimal network layer representation of sockets</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sock_common {
    union {
        __addrpair skc_addrpair;
        struct {
            __be32 skc_daddr;
            __be32 skc_rcv_saddr;
        };
    };
    union {
        unsigned int    skc_hash;
        __u16 skc_u16hashes[2];
    };
    union {
        __portpair skc_portpair;
        struct {
            __be16 skc_dport;
            __u16 skc_num;
        };
    };
    unsigned short          skc_family;
    volatile unsigned char  skc_state;
    unsigned char           skc_reuse:4;
    unsigned char           skc_reuseport:1;
    unsigned char           skc_ipv6only:1;
    unsigned char           skc_net_refcnt:1;
    int skc_bound_dev_if;
    union {
        struct hlist_node       skc_bind_node;
        struct hlist_node       skc_portaddr_node;
    };
    struct proto            *skc_prot;
    possible_net_t skc_net;
#if IS_ENABLED(CONFIG_IPV6);
    struct in6_addr         skc_v6_daddr;
    struct in6_addr         skc_v6_rcv_saddr;
#endif;
    atomic64_t skc_cookie;
    union {
        unsigned long   skc_flags;
        struct sock     *skc_listener;
        struct inet_timewait_death_row *skc_tw_dr;
    };
    union {
        struct hlist_node       skc_node;
        struct hlist_nulls_node skc_nulls_node;
    };
    unsigned short          skc_tx_queue_mapping;
#ifdef CONFIG_SOCK_RX_QUEUE_MAPPING;
    unsigned short          skc_rx_queue_mapping;
#endif;
    union {
        int skc_incoming_cpu;
        u32 skc_rcv_wnd;
        u32 skc_tw_rcv_nxt;
    };
    refcount_t skc_refcnt;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_addrpair</span></code></dt><dd><p>8-byte-aligned __u64 union of <strong>skc_daddr</strong> &amp; <strong>skc_rcv_saddr</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_daddr</span></code></dt><dd><p>Foreign IPv4 addr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_rcv_saddr</span></code></dt><dd><p>Bound local IPv4 addr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_hash</span></code></dt><dd><p>hash value used with various protocol lookup tables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_u16hashes</span></code></dt><dd><p>two u16 hash values used by UDP lookup tables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_portpair</span></code></dt><dd><p>__u32 union of <strong>skc_dport</strong> &amp; <strong>skc_num</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_struct}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_dport</span></code></dt><dd><p>placeholder for inet_dport/tw_dport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_num</span></code></dt><dd><p>placeholder for inet_num/tw_num</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_family</span></code></dt><dd><p>network address family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_state</span></code></dt><dd><p>Connection state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_reuse</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_reuseport</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_ipv6only</span></code></dt><dd><p>socket is IPV6 only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_net_refcnt</span></code></dt><dd><p>socket is using net ref counting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_bound_dev_if</span></code></dt><dd><p>bound device index if != 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_bind_node</span></code></dt><dd><p>bind hash linkage for various protocol lookup tables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_portaddr_node</span></code></dt><dd><p>second hash linkage for UDP/UDP-Lite protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_prot</span></code></dt><dd><p>protocol handlers inside a network family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_net</span></code></dt><dd><p>reference to the network namespace of this socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_v6_daddr</span></code></dt><dd><p>IPV6 destination address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_v6_rcv_saddr</span></code></dt><dd><p>IPV6 source address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_cookie</span></code></dt><dd><p>socket’s cookie value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_flags</span></code></dt><dd><p>place holder for sk_flags
<code class="docutils literal notranslate"><span class="pre">SO_LINGER</span></code> (l_onoff), <code class="docutils literal notranslate"><span class="pre">SO_BROADCAST</span></code>, <code class="docutils literal notranslate"><span class="pre">SO_KEEPALIVE</span></code>,
<code class="docutils literal notranslate"><span class="pre">SO_OOBINLINE</span></code> settings, <code class="docutils literal notranslate"><span class="pre">SO_TIMESTAMPING</span></code> settings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_listener</span></code></dt><dd><p>connection request listener socket (aka rsk_listener)
[union with <strong>skc_flags</strong>]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_tw_dr</span></code></dt><dd><p>(aka tw_dr) ptr to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">inet_timewait_death_row</span></code>
[union with <strong>skc_flags</strong>]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_node</span></code></dt><dd><p>main hash linkage for various protocol lookup tables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_nulls_node</span></code></dt><dd><p>main hash linkage for TCP/UDP/UDP-Lite protocol</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_tx_queue_mapping</span></code></dt><dd><p>tx queue number for this connection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_rx_queue_mapping</span></code></dt><dd><p>rx queue number for this connection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_incoming_cpu</span></code></dt><dd><p>record/match cpu processing incoming packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_rcv_wnd</span></code></dt><dd><p>(aka rsk_rcv_wnd) TCP receive window size (possibly scaled)
[union with <strong>skc_incoming_cpu</strong>]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_tw_rcv_nxt</span></code></dt><dd><p>(aka tw_rcv_nxt) TCP window next expected seq number
[union with <strong>skc_incoming_cpu</strong>]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skc_refcnt</span></code></dt><dd><p>reference count</p>
<p>This is the minimal network layer representation of sockets, the header
for <a class="reference internal" href="#c.sock" title="sock"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span></code></a> and struct inet_timewait_sock.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.sock">
struct <code class="sig-name descname">sock</code><a class="headerlink" href="#c.sock" title="Permalink to this definition">¶</a></dt>
<dd><p>network layer representation of sockets</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sock {
    struct sock_common      __sk_common;
#define sk_node                 __sk_common.skc_node;
#define sk_nulls_node           __sk_common.skc_nulls_node;
#define sk_refcnt               __sk_common.skc_refcnt;
#define sk_tx_queue_mapping     __sk_common.skc_tx_queue_mapping;
#ifdef CONFIG_SOCK_RX_QUEUE_MAPPING;
#define sk_rx_queue_mapping     __sk_common.skc_rx_queue_mapping;
#endif;
#define sk_dontcopy_begin       __sk_common.skc_dontcopy_begin;
#define sk_dontcopy_end         __sk_common.skc_dontcopy_end;
#define sk_hash                 __sk_common.skc_hash;
#define sk_portpair             __sk_common.skc_portpair;
#define sk_num                  __sk_common.skc_num;
#define sk_dport                __sk_common.skc_dport;
#define sk_addrpair             __sk_common.skc_addrpair;
#define sk_daddr                __sk_common.skc_daddr;
#define sk_rcv_saddr            __sk_common.skc_rcv_saddr;
#define sk_family               __sk_common.skc_family;
#define sk_state                __sk_common.skc_state;
#define sk_reuse                __sk_common.skc_reuse;
#define sk_reuseport            __sk_common.skc_reuseport;
#define sk_ipv6only             __sk_common.skc_ipv6only;
#define sk_net_refcnt           __sk_common.skc_net_refcnt;
#define sk_bound_dev_if         __sk_common.skc_bound_dev_if;
#define sk_bind_node            __sk_common.skc_bind_node;
#define sk_prot                 __sk_common.skc_prot;
#define sk_net                  __sk_common.skc_net;
#define sk_v6_daddr             __sk_common.skc_v6_daddr;
#define sk_v6_rcv_saddr __sk_common.skc_v6_rcv_saddr;
#define sk_cookie               __sk_common.skc_cookie;
#define sk_incoming_cpu         __sk_common.skc_incoming_cpu;
#define sk_flags                __sk_common.skc_flags;
#define sk_rxhash               __sk_common.skc_rxhash;
    struct dst_entry __rcu  *sk_rx_dst;
    int sk_rx_dst_ifindex;
    u32 sk_rx_dst_cookie;
    socket_lock_t sk_lock;
    atomic_t sk_drops;
    int sk_rcvlowat;
    struct sk_buff_head     sk_error_queue;
    struct sk_buff_head     sk_receive_queue;
    struct {
        atomic_t rmem_alloc;
        int len;
        struct sk_buff  *head;
        struct sk_buff  *tail;
    } sk_backlog;
#define sk_rmem_alloc sk_backlog.rmem_alloc;
    int sk_forward_alloc;
    u32 sk_reserved_mem;
#ifdef CONFIG_NET_RX_BUSY_POLL;
    unsigned int            sk_ll_usec;
    unsigned int            sk_napi_id;
#endif;
    int sk_rcvbuf;
    struct sk_filter __rcu  *sk_filter;
    union {
        struct socket_wq __rcu  *sk_wq;
    };
#ifdef CONFIG_XFRM;
    struct xfrm_policy __rcu *sk_policy[2];
#endif;
    struct dst_entry __rcu  *sk_dst_cache;
    atomic_t sk_omem_alloc;
    int sk_sndbuf;
    int sk_wmem_queued;
    refcount_t sk_wmem_alloc;
    unsigned long           sk_tsq_flags;
    union {
        struct sk_buff  *sk_send_head;
        struct rb_root  tcp_rtx_queue;
    };
    struct sk_buff_head     sk_write_queue;
    __s32 sk_peek_off;
    int sk_write_pending;
    __u32 sk_dst_pending_confirm;
    u32 sk_pacing_status;
    long sk_sndtimeo;
    struct timer_list       sk_timer;
    __u32 sk_priority;
    __u32 sk_mark;
    unsigned long           sk_pacing_rate;
    unsigned long           sk_max_pacing_rate;
    struct page_frag        sk_frag;
    netdev_features_t sk_route_caps;
    int sk_gso_type;
    unsigned int            sk_gso_max_size;
    gfp_t sk_allocation;
    __u32 sk_txhash;
    u8 sk_gso_disabled : 1,sk_kern_sock : 1,sk_no_check_tx : 1,sk_no_check_rx : 1, sk_userlocks : 4;
    u8 sk_pacing_shift;
    u16 sk_type;
    u16 sk_protocol;
    u16 sk_gso_max_segs;
    unsigned long           sk_lingertime;
    struct proto            *sk_prot_creator;
    rwlock_t sk_callback_lock;
    int sk_err, sk_err_soft;
    u32 sk_ack_backlog;
    u32 sk_max_ack_backlog;
    kuid_t sk_uid;
    u8 sk_txrehash;
#ifdef CONFIG_NET_RX_BUSY_POLL;
    u8 sk_prefer_busy_poll;
    u16 sk_busy_poll_budget;
#endif;
    spinlock_t sk_peer_lock;
    int sk_bind_phc;
    struct pid              *sk_peer_pid;
    const struct cred       *sk_peer_cred;
    long sk_rcvtimeo;
    ktime_t sk_stamp;
#if BITS_PER_LONG==32;
    seqlock_t sk_stamp_seq;
#endif;
    atomic_t sk_tskey;
    atomic_t sk_zckey;
    u32 sk_tsflags;
    u8 sk_shutdown;
    u8 sk_clockid;
    u8 sk_txtime_deadline_mode : 1,sk_txtime_report_errors : 1, sk_txtime_unused : 6;
    bool sk_use_task_frag;
    struct socket           *sk_socket;
    void *sk_user_data;
#ifdef CONFIG_SECURITY;
    void *sk_security;
#endif;
    struct sock_cgroup_data sk_cgrp_data;
    struct mem_cgroup       *sk_memcg;
    void (*sk_state_change)(struct sock *sk);
    void (*sk_data_ready)(struct sock *sk);
    void (*sk_write_space)(struct sock *sk);
    void (*sk_error_report)(struct sock *sk);
    int (*sk_backlog_rcv)(struct sock *sk, struct sk_buff *skb);
#ifdef CONFIG_SOCK_VALIDATE_XMIT;
    struct sk_buff*         (*sk_validate_xmit_skb)(struct sock *sk,struct net_device *dev, struct sk_buff *skb);
#endif;
    void (*sk_destruct)(struct sock *sk);
    struct sock_reuseport __rcu     *sk_reuseport_cb;
#ifdef CONFIG_BPF_SYSCALL;
    struct bpf_local_storage __rcu  *sk_bpf_storage;
#endif;
    struct rcu_head         sk_rcu;
    netns_tracker ns_tracker;
    struct hlist_node       sk_bind2_node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__sk_common</span></code></dt><dd><p>shared layout with inet_timewait_sock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rx_dst</span></code></dt><dd><p>receive input route used by early demux</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rx_dst_ifindex</span></code></dt><dd><p>ifindex for <strong>sk_rx_dst</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rx_dst_cookie</span></code></dt><dd><p>cookie for <strong>sk_rx_dst</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_lock</span></code></dt><dd><p>synchronizer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_drops</span></code></dt><dd><p>raw/udp drops counter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rcvlowat</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_RCVLOWAT</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_error_queue</span></code></dt><dd><p>rarely used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_receive_queue</span></code></dt><dd><p>incoming packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_backlog</span></code></dt><dd><p>always used with the per-socket spinlock held</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_forward_alloc</span></code></dt><dd><p>space allocated forward</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_reserved_mem</span></code></dt><dd><p>space reserved and non-reclaimable for the socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_ll_usec</span></code></dt><dd><p>usecs to busypoll when there is no data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_napi_id</span></code></dt><dd><p>id of the last napi context to receive data for sk</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rcvbuf</span></code></dt><dd><p>size of receive buffer in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_filter</span></code></dt><dd><p>socket filtering instructions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_wq</span></code></dt><dd><p>sock wait queue and async head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_policy</span></code></dt><dd><p>flow policy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_dst_cache</span></code></dt><dd><p>destination cache</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_omem_alloc</span></code></dt><dd><p>“o” is “option” or “other”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_sndbuf</span></code></dt><dd><p>size of send buffer in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_wmem_queued</span></code></dt><dd><p>persistent queue size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_wmem_alloc</span></code></dt><dd><p>transmit queue bytes committed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_tsq_flags</span></code></dt><dd><p>TCP Small Queues flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_send_head</span></code></dt><dd><p>front of stuff to transmit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tcp_rtx_queue</span></code></dt><dd><p>TCP re-transmit queue [union with <strong>sk_send_head</strong>]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_write_queue</span></code></dt><dd><p>Packet sending queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_peek_off</span></code></dt><dd><p>current peek_offset value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_write_pending</span></code></dt><dd><p>a write to stream socket waits to start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_dst_pending_confirm</span></code></dt><dd><p>need to confirm neighbour</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_pacing_status</span></code></dt><dd><p>Pacing status (requested, handled by sch_fq)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_sndtimeo</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_SNDTIMEO</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_timer</span></code></dt><dd><p>sock cleanup timer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_priority</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_PRIORITY</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_mark</span></code></dt><dd><p>generic packet mark</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_pacing_rate</span></code></dt><dd><p>Pacing rate (if supported by transport/packet scheduler)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_max_pacing_rate</span></code></dt><dd><p>Maximum pacing rate (<code class="docutils literal notranslate"><span class="pre">SO_MAX_PACING_RATE</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_frag</span></code></dt><dd><p>cached page frag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_route_caps</span></code></dt><dd><p>route capabilities (e.g. <code class="docutils literal notranslate"><span class="pre">NETIF_F_TSO</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_gso_type</span></code></dt><dd><p>GSO type (e.g. <code class="docutils literal notranslate"><span class="pre">SKB_GSO_TCPV4</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_gso_max_size</span></code></dt><dd><p>Maximum GSO segment size to build</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_allocation</span></code></dt><dd><p>allocation mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_txhash</span></code></dt><dd><p>computed flow hash for use on transmit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_gso_disabled</span></code></dt><dd><p>if set, NETIF_F_GSO_MASK is forbidden.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_kern_sock</span></code></dt><dd><p>True if sock is using kernel lock classes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_no_check_tx</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_NO_CHECK</span></code> setting, set checksum in TX packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_no_check_rx</span></code></dt><dd><p>allow zero checksum in RX packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_userlocks</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_SNDBUF</span></code> and <code class="docutils literal notranslate"><span class="pre">SO_RCVBUF</span></code> settings</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_pacing_shift</span></code></dt><dd><p>scaling factor for TCP Small Queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_type</span></code></dt><dd><p>socket type (<code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_protocol</span></code></dt><dd><p>which protocol this socket belongs in this network family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_gso_max_segs</span></code></dt><dd><p>Maximum number of GSO segments</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_lingertime</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_LINGER</span></code> l_linger setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_prot_creator</span></code></dt><dd><p>sk_prot of original sock creator (see ipv6_setsockopt,
IPV6_ADDRFORM for instance)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_callback_lock</span></code></dt><dd><p>used with the callbacks in the end of this struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_err</span></code></dt><dd><p>last error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_err_soft</span></code></dt><dd><p>errors that don’t cause failure but are the cause of a
persistent failure not just ‘timed out’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_ack_backlog</span></code></dt><dd><p>current listen backlog</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_max_ack_backlog</span></code></dt><dd><p>listen backlog set in listen()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_uid</span></code></dt><dd><p>user id of owner</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_txrehash</span></code></dt><dd><p>enable TX hash rethink</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_prefer_busy_poll</span></code></dt><dd><p>prefer busypolling over softirq processing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_busy_poll_budget</span></code></dt><dd><p>napi processing budget when busypolling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_peer_lock</span></code></dt><dd><p>lock protecting <strong>sk_peer_pid</strong> and <strong>sk_peer_cred</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_bind_phc</span></code></dt><dd><p>SO_TIMESTAMPING bind PHC index of PTP virtual clock
for timestamping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_peer_pid</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pid</span></code> for this socket’s peer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_peer_cred</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_PEERCRED</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rcvtimeo</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">SO_RCVTIMEO</span></code> setting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_stamp</span></code></dt><dd><p>time stamp of last packet received</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_stamp_seq</span></code></dt><dd><p>lock for accessing sk_stamp on 32 bit architectures only</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_tskey</span></code></dt><dd><p>counter to disambiguate concurrent tstamp requests</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_zckey</span></code></dt><dd><p>counter to order MSG_ZEROCOPY notifications</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_tsflags</span></code></dt><dd><p>SO_TIMESTAMPING flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_shutdown</span></code></dt><dd><p>mask of <code class="docutils literal notranslate"><span class="pre">SEND_SHUTDOWN</span></code> and/or <code class="docutils literal notranslate"><span class="pre">RCV_SHUTDOWN</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_clockid</span></code></dt><dd><p>clockid used by time-based scheduling (SO_TXTIME)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_txtime_deadline_mode</span></code></dt><dd><p>set deadline mode for SO_TXTIME</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_txtime_report_errors</span></code></dt><dd><p>set report errors mode for SO_TXTIME</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_txtime_unused</span></code></dt><dd><p>unused txtime flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_use_task_frag</span></code></dt><dd><p>allow <a class="reference internal" href="#c.sk_page_frag" title="sk_page_frag"><code class="xref c c-func docutils literal notranslate"><span class="pre">sk_page_frag()</span></code></a> to use current-&gt;task_frag.
Sockets that can be used under memory reclaim should
set this to false.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_socket</span></code></dt><dd><p>Identd and reporting IO signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_user_data</span></code></dt><dd><p>RPC layer private data. Write-protected by <strong>sk_callback_lock</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_security</span></code></dt><dd><p>used by security modules</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_cgrp_data</span></code></dt><dd><p>cgroup data for this cgroup</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_memcg</span></code></dt><dd><p>this socket’s memory cgroup association</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_state_change</span></code></dt><dd><p>callback to indicate change in the state of the sock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_data_ready</span></code></dt><dd><p>callback to indicate there is data to be processed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_write_space</span></code></dt><dd><p>callback to indicate there is bf sending space available</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_error_report</span></code></dt><dd><p>callback to indicate errors (e.g. <code class="docutils literal notranslate"><span class="pre">MSG_ERRQUEUE</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_backlog_rcv</span></code></dt><dd><p>callback to process the backlog</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_validate_xmit_skb</span></code></dt><dd><p>ptr to an optional validate function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_destruct</span></code></dt><dd><p>called at sock freeing time, i.e. when all refcnt == 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_reuseport_cb</span></code></dt><dd><p>reuseport group container</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_bpf_storage</span></code></dt><dd><p>ptr to cache and control for bpf_sk_storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_rcu</span></code></dt><dd><p>used during RCU grace period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ns_tracker</span></code></dt><dd><p>tracker for netns reference</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sk_bind2_node</span></code></dt><dd><p>bind node in the bhash2 table</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sk_user_data_is_nocopy">
bool <code class="sig-name descname">sk_user_data_is_nocopy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_user_data_is_nocopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if sk_user_data pointer must not be copied</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__locked_read_sk_user_data_with_flags">
void * <code class="sig-name descname">__locked_read_sk_user_data_with_flags</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, uintptr_t<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__locked_read_sk_user_data_with_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>return the pointer only if argument flags all has been set in sk_user_data. Otherwise return NULL</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uintptr_t</span> <span class="pre">flags</span></code></dt><dd><p>flag bits</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must be holding sk-&gt;sk_callback_lock.</p>
</div>
<dl class="function">
<dt id="c.__rcu_dereference_sk_user_data_with_flags">
void * <code class="sig-name descname">__rcu_dereference_sk_user_data_with_flags</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, uintptr_t<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__rcu_dereference_sk_user_data_with_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>return the pointer only if argument flags all has been set in sk_user_data. Otherwise return NULL</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uintptr_t</span> <span class="pre">flags</span></code></dt><dd><p>flag bits</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sk_for_each_entry_offset_rcu">
<code class="sig-name descname">sk_for_each_entry_offset_rcu</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_for_each_entry_offset_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list at a given struct offset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">tpos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>offset of hlist_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.lock_sock_fast">
bool <code class="sig-name descname">lock_sock_fast</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lock_sock_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>fast version of lock_sock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This version should be used for very small section, where process wont block
return false if fast path is taken:</p>
<blockquote>
<div><p>sk_lock.slock locked, owned = 0, BH disabled</p>
</div></blockquote>
<p>return true if slow path is taken:</p>
<blockquote>
<div><p>sk_lock.slock unlocked, owned = 1, BH enabled</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.unlock_sock_fast">
void <code class="sig-name descname">unlock_sock_fast</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, bool<em> slow</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_sock_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>complement of lock_sock_fast</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">slow</span></code></dt><dd><p>slow mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>fast unlock socket for user context.
If slow mode is on, we call regular release_sock()</p>
</div>
<dl class="function">
<dt id="c.sk_wmem_alloc_get">
int <code class="sig-name descname">sk_wmem_alloc_get</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_wmem_alloc_get" title="Permalink to this definition">¶</a></dt>
<dd><p>returns write allocations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>sk_wmem_alloc minus initial offset of one</p>
</div>
<dl class="function">
<dt id="c.sk_rmem_alloc_get">
int <code class="sig-name descname">sk_rmem_alloc_get</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_rmem_alloc_get" title="Permalink to this definition">¶</a></dt>
<dd><p>returns read allocations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>sk_rmem_alloc</p>
</div>
<dl class="function">
<dt id="c.sk_has_allocations">
bool <code class="sig-name descname">sk_has_allocations</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_has_allocations" title="Permalink to this definition">¶</a></dt>
<dd><p>check if allocations are outstanding</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if socket has write or read allocations</p>
</div>
<dl class="function">
<dt id="c.skwq_has_sleeper">
bool <code class="sig-name descname">skwq_has_sleeper</code><span class="sig-paren">(</span>struct socket_wq<em> *wq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skwq_has_sleeper" title="Permalink to this definition">¶</a></dt>
<dd><p>check if there are any waiting processes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket_wq</span> <span class="pre">*wq</span></code></dt><dd><p>struct socket_wq</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if socket_wq has waiting processes</p>
<p><strong>Description</strong></p>
<p>The purpose of the skwq_has_sleeper and sock_poll_wait is to wrap the memory
barrier call. They were added due to the race found within the tcp code.</p>
<p>Consider following tcp code paths:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU1                CPU2
sys_select          receive packet
...                 ...
__add_wait_queue    update tp-&gt;rcv_nxt
...                 ...
tp-&gt;rcv_nxt check   sock_def_readable
...                 {
schedule               rcu_read_lock();
                       wq = rcu_dereference(sk-&gt;sk_wq);
                       if (wq &amp;&amp; waitqueue_active(&amp;wq-&gt;wait))
                           wake_up_interruptible(&amp;wq-&gt;wait)
                       ...
                    }
</pre></div>
</div>
<p>The race for tcp fires when the __add_wait_queue changes done by CPU1 stay
in its cache, and so does the tp-&gt;rcv_nxt update on CPU2 side.  The CPU1
could then endup calling schedule and sleep forever if there are no more
data on the socket.</p>
</div>
<dl class="function">
<dt id="c.sock_poll_wait">
void <code class="sig-name descname">sock_poll_wait</code><span class="sig-paren">(</span>struct file<em> *filp</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, poll_table<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_poll_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>place memory barrier behind the poll_wait call.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*filp</span></code></dt><dd><p>file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*p</span></code></dt><dd><p>poll_table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See the comments in the wq_has_sleeper function.</p>
</div>
<dl class="function">
<dt id="c.sk_page_frag">
struct page_frag * <code class="sig-name descname">sk_page_frag</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_page_frag" title="Permalink to this definition">¶</a></dt>
<dd><p>return an appropriate page_frag</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the per task page_frag instead of the per socket one for
optimization when we know that we’re in process context and own
everything that’s associated with <code class="docutils literal notranslate"><span class="pre">current</span></code>.</p>
<p>Both direct reclaim and page faults can nest inside other
socket operations and end up recursing into <a class="reference internal" href="#c.sk_page_frag" title="sk_page_frag"><code class="xref c c-func docutils literal notranslate"><span class="pre">sk_page_frag()</span></code></a>
while it’s already in use: explicitly avoid task page_frag
when users disable sk_use_task_frag.</p>
<p><strong>Return</strong></p>
<p>a per task page_frag if context allows that,
otherwise a per socket one.</p>
</div>
<dl class="function">
<dt id="c._sock_tx_timestamp">
void <code class="sig-name descname">_sock_tx_timestamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, __u16<em> tsflags</em>, __u8<em> *tx_flags</em>, __u32<em> *tskey</em><span class="sig-paren">)</span><a class="headerlink" href="#c._sock_tx_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>checks whether the outgoing packet is to be time stamped</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket sending this packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u16</span> <span class="pre">tsflags</span></code></dt><dd><p>timestamping flags to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u8</span> <span class="pre">*tx_flags</span></code></dt><dd><p>completed with instructions for time stamping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u32</span> <span class="pre">*tskey</span></code></dt><dd><p>filled in with next sk_tskey (not for TCP, which uses seqno)</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>callers should take care of initial <code class="docutils literal notranslate"><span class="pre">*tx_flags</span></code> value (usually 0)</p>
</div>
<dl class="function">
<dt id="c.sk_eat_skb">
void <code class="sig-name descname">sk_eat_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_eat_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a skb if it is no longer needed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket to eat this skb from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>socket buffer to eat</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine must be called with interrupts disabled or with the socket
locked so that the sk_buff queue operation is ok.</p>
</div>
<dl class="function">
<dt id="c.skb_steal_sock">
struct <a class="reference internal" href="#c.sock" title="sock">sock</a> * <code class="sig-name descname">skb_steal_sock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, bool<em> *refcounted</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_steal_sock" title="Permalink to this definition">¶</a></dt>
<dd><p>steal a socket from an sk_buff</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>sk_buff to steal the socket from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*refcounted</span></code></dt><dd><p>is set to true if the socket is reference-counted</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sock_alloc_file">
struct file * <code class="sig-name descname">sock_alloc_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, int<em> flags</em>, const char<em> *dname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_alloc_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind a <a class="reference internal" href="#c.socket" title="socket"><code class="xref c c-type docutils literal notranslate"><span class="pre">socket</span></code></a> to a <code class="xref c c-type docutils literal notranslate"><span class="pre">file</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>file status flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*dname</span></code></dt><dd><p>protocol name</p>
<p>Returns the <code class="xref c c-type docutils literal notranslate"><span class="pre">file</span></code> bound with <strong>sock</strong>, implicitly storing it
in sock-&gt;file. If dname is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, sets to “”.
On failure the return is a ERR pointer (see linux/err.h).
This function uses GFP_KERNEL internally.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sock_from_file">
struct <a class="reference internal" href="#c.socket" title="socket">socket</a> * <code class="sig-name descname">sock_from_file</code><span class="sig-paren">(</span>struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <a class="reference internal" href="#c.socket" title="socket"><code class="xref c c-type docutils literal notranslate"><span class="pre">socket</span></code></a> bounded to <strong>file</strong>.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file</p>
<p>On failure returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sockfd_lookup">
struct <a class="reference internal" href="#c.socket" title="socket">socket</a> * <code class="sig-name descname">sockfd_lookup</code><span class="sig-paren">(</span>int<em> fd</em>, int<em> *err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sockfd_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Go from a file number to its socket slot</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>file handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*err</span></code></dt><dd><p>pointer to an error code return</p>
<p>The file handle passed in is locked and the socket it is bound
to is returned. If an error occurs the err pointer is overwritten
with a negative errno code and NULL is returned. The function checks
for both invalid handles and passing a handle which is not a socket.</p>
<p>On a success the socket object pointer is returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sock_alloc">
struct <a class="reference internal" href="#c.socket" title="socket">socket</a> * <code class="sig-name descname">sock_alloc</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.sock_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a new inode and socket object. The two are bound together
and initialised. The socket is then returned. If we are out of inodes
NULL is returned. This functions uses GFP_KERNEL internally.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sock_release">
void <code class="sig-name descname">sock_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_release" title="Permalink to this definition">¶</a></dt>
<dd><p>close a socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket to close</p>
<p>The socket is released from the protocol stack if it has a release
callback, and the inode is then released if the socket is bound to
an inode not a file.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sock_sendmsg">
int <code class="sig-name descname">sock_sendmsg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, struct msghdr<em> *msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_sendmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>send a message through <strong>sock</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg</span></code></dt><dd><p>message to send</p>
<p>Sends <strong>msg</strong> through <strong>sock</strong>, passing through LSM.
Returns the number of bytes sent, or an error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_sendmsg">
int <code class="sig-name descname">kernel_sendmsg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, struct msghdr<em> *msg</em>, struct kvec<em> *vec</em>, size_t<em> num</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sendmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>send a message through <strong>sock</strong> (kernel-space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg</span></code></dt><dd><p>message header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*vec</span></code></dt><dd><p>kernel vec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num</span></code></dt><dd><p>vec array length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>total message data size</p>
<p>Builds the message data with <strong>vec</strong> and sends it through <strong>sock</strong>.
Returns the number of bytes sent, or an error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_sendmsg_locked">
int <code class="sig-name descname">kernel_sendmsg_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, struct msghdr<em> *msg</em>, struct kvec<em> *vec</em>, size_t<em> num</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sendmsg_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>send a message through <strong>sock</strong> (kernel-space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>sock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg</span></code></dt><dd><p>message header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*vec</span></code></dt><dd><p>output s/g array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num</span></code></dt><dd><p>output s/g array length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>total message data size</p>
<p>Builds the message data with <strong>vec</strong> and sends it through <strong>sock</strong>.
Returns the number of bytes sent, or an error code.
Caller must hold <strong>sk</strong>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sock_recvmsg">
int <code class="sig-name descname">sock_recvmsg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, struct msghdr<em> *msg</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_recvmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>receive a message from <strong>sock</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg</span></code></dt><dd><p>message to receive</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>message flags</p>
<p>Receives <strong>msg</strong> from <strong>sock</strong>, passing through LSM. Returns the total number
of bytes received, or an error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_recvmsg">
int <code class="sig-name descname">kernel_recvmsg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, struct msghdr<em> *msg</em>, struct kvec<em> *vec</em>, size_t<em> num</em>, size_t<em> size</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_recvmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a message from a socket (kernel space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>The socket to receive the message from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg</span></code></dt><dd><p>Received message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*vec</span></code></dt><dd><p>Input s/g array for message data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num</span></code></dt><dd><p>Size of input s/g array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Number of bytes to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>Message flags (MSG_DONTWAIT, etc…)</p>
<p>On return the msg structure contains the scatter/gather array passed in the
vec argument. The array is modified so that it consists of the unfilled
portion of the original array.</p>
<p>The returned value is the total number of bytes received, or an error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sock_create_lite">
int <code class="sig-name descname">sock_create_lite</code><span class="sig-paren">(</span>int<em> family</em>, int<em> type</em>, int<em> protocol</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> **res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_create_lite" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family (AF_INET, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>communication type (SOCK_STREAM, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt><dd><p>protocol (0, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**res</span></code></dt><dd><p>new socket</p>
<p>Creates a new socket and assigns it to <strong>res</strong>, passing through LSM.
The new socket initialization is not complete, see <a class="reference internal" href="#c.kernel_accept" title="kernel_accept"><code class="xref c c-func docutils literal notranslate"><span class="pre">kernel_accept()</span></code></a>.
Returns 0 or an error. On failure <strong>res</strong> is set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
This function internally uses GFP_KERNEL.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__sock_create">
int <code class="sig-name descname">__sock_create</code><span class="sig-paren">(</span>struct net<em> *net</em>, int<em> family</em>, int<em> type</em>, int<em> protocol</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> **res</em>, int<em> kern</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sock_create" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family (AF_INET, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>communication type (SOCK_STREAM, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt><dd><p>protocol (0, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**res</span></code></dt><dd><p>new socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kern</span></code></dt><dd><p>boolean for kernel space sockets</p>
<p>Creates a new socket and assigns it to <strong>res</strong>, passing through LSM.
Returns 0 or an error. On failure <strong>res</strong> is set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. <strong>kern</strong> must
be set to true if the socket resides in kernel space.
This function internally uses GFP_KERNEL.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sock_create">
int <code class="sig-name descname">sock_create</code><span class="sig-paren">(</span>int<em> family</em>, int<em> type</em>, int<em> protocol</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> **res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_create" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family (AF_INET, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>communication type (SOCK_STREAM, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt><dd><p>protocol (0, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**res</span></code></dt><dd><p>new socket</p>
<p>A wrapper around <a class="reference internal" href="#c.__sock_create" title="__sock_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">__sock_create()</span></code></a>.
Returns 0 or an error. This function internally uses GFP_KERNEL.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sock_create_kern">
int <code class="sig-name descname">sock_create_kern</code><span class="sig-paren">(</span>struct net<em> *net</em>, int<em> family</em>, int<em> type</em>, int<em> protocol</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> **res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_create_kern" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a socket (kernel space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family (AF_INET, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>communication type (SOCK_STREAM, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">protocol</span></code></dt><dd><p>protocol (0, …)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**res</span></code></dt><dd><p>new socket</p>
<p>A wrapper around <a class="reference internal" href="#c.__sock_create" title="__sock_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">__sock_create()</span></code></a>.
Returns 0 or an error. This function internally uses GFP_KERNEL.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sock_register">
int <code class="sig-name descname">sock_register</code><span class="sig-paren">(</span>const struct net_proto_family<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_register" title="Permalink to this definition">¶</a></dt>
<dd><p>add a socket protocol handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_proto_family</span> <span class="pre">*ops</span></code></dt><dd><p>description of protocol</p>
<p>This function is called by a protocol handler that wants to
advertise its address family, and have it linked into the
socket interface. The value ops-&gt;family corresponds to the
socket system call protocol family.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sock_unregister">
void <code class="sig-name descname">sock_unregister</code><span class="sig-paren">(</span>int<em> family</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a protocol handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family to remove</p>
<p>This function is called by a protocol handler that wants to
remove its address family, and have it unlinked from the
new socket creation.</p>
<p>If protocol handler is a module, then it can use module reference
counts to protect against new references. If protocol handler is not
a module then it needs to provide its own protection in
the ops-&gt;create routine.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_bind">
int <code class="sig-name descname">kernel_bind</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, struct sockaddr<em> *addr</em>, int<em> addrlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>bind an address to a socket (kernel space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*addr</span></code></dt><dd><p>address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addrlen</span></code></dt><dd><p>length of address</p>
<p>Returns 0 or an error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_listen">
int <code class="sig-name descname">kernel_listen</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, int<em> backlog</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_listen" title="Permalink to this definition">¶</a></dt>
<dd><p>move socket to listening state (kernel space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">backlog</span></code></dt><dd><p>pending connections queue size</p>
<p>Returns 0 or an error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_accept">
int <code class="sig-name descname">kernel_accept</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> **newsock</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>accept a connection (kernel space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>listening socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**newsock</span></code></dt><dd><p>new connected socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags</p>
<p><strong>flags</strong> must be SOCK_CLOEXEC, SOCK_NONBLOCK or 0.
If it fails, <strong>newsock</strong> is guaranteed to be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
Returns 0 or an error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_connect">
int <code class="sig-name descname">kernel_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, struct sockaddr<em> *addr</em>, int<em> addrlen</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect a socket (kernel space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*addr</span></code></dt><dd><p>address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addrlen</span></code></dt><dd><p>address length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags (O_NONBLOCK, …)</p>
<p>For datagram sockets, <strong>addr</strong> is the address to which datagrams are sent
by default, and the only address from which datagrams are received.
For stream sockets, attempts to connect to <strong>addr</strong>.
Returns 0 or an error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_getsockname">
int <code class="sig-name descname">kernel_getsockname</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, struct sockaddr<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_getsockname" title="Permalink to this definition">¶</a></dt>
<dd><p>get the address which the socket is bound (kernel space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*addr</span></code></dt><dd><p>address holder</p>
<p>Fills the <strong>addr</strong> pointer with the address which the socket is bound.
Returns the length of the address in bytes or an error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_getpeername">
int <code class="sig-name descname">kernel_getpeername</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, struct sockaddr<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_getpeername" title="Permalink to this definition">¶</a></dt>
<dd><p>get the address which the socket is connected (kernel space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*addr</span></code></dt><dd><p>address holder</p>
<p>Fills the <strong>addr</strong> pointer with the address which the socket is connected.
Returns the length of the address in bytes or an error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_sendpage">
int <code class="sig-name descname">kernel_sendpage</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, struct page<em> *page</em>, int<em> offset</em>, size_t<em> size</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sendpage" title="Permalink to this definition">¶</a></dt>
<dd><p>send a <code class="xref c c-type docutils literal notranslate"><span class="pre">page</span></code> through a socket (kernel space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>page offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>total size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags (MSG_DONTWAIT, …)</p>
<p>Returns the total amount sent in bytes or an error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_sendpage_locked">
int <code class="sig-name descname">kernel_sendpage_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, struct page<em> *page</em>, int<em> offset</em>, size_t<em> size</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sendpage_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>send a <code class="xref c c-type docutils literal notranslate"><span class="pre">page</span></code> through the locked sock (kernel space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>sock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*page</span></code></dt><dd><p>page</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>page offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>total size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>flags (MSG_DONTWAIT, …)</p>
<p>Returns the total amount sent in bytes or an error.
Caller must hold <strong>sk</strong>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_sock_shutdown">
int <code class="sig-name descname">kernel_sock_shutdown</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, enum <a class="reference internal" href="#c.sock_shutdown_cmd" title="sock_shutdown_cmd">sock_shutdown_cmd</a><em> how</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sock_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>shut down part of a full-duplex connection (kernel space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">sock_shutdown_cmd</span> <span class="pre">how</span></code></dt><dd><p>connection part</p>
<p>Returns 0 or an error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kernel_sock_ip_overhead">
u32 <code class="sig-name descname">kernel_sock_ip_overhead</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_sock_ip_overhead" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the IP overhead imposed by a socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
<p>This routine returns the IP overhead imposed by a socket i.e.
the length of the underlying IP header, depending on whether
this is an IPv4 or IPv6 socket and the length from IP options turned
on at the socket. Assumes that the caller has a lock on the socket.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.build_skb_around">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">build_skb_around</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, void<em> *data</em>, unsigned int<em> frag_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.build_skb_around" title="Permalink to this definition">¶</a></dt>
<dd><p>build a network buffer around provided skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>sk_buff provide by caller, must be memset cleared</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data buffer provided by caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">frag_size</span></code></dt><dd><p>size of data, or 0 if head was kmalloced</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.napi_build_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">napi_build_skb</code><span class="sig-paren">(</span>void<em> *data</em>, unsigned int<em> frag_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_build_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>build a network buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>data buffer provided by caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">frag_size</span></code></dt><dd><p>size of data, or 0 if head was kmalloced</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Version of __napi_build_skb() that takes care of skb-&gt;head_frag
and skb-&gt;pfmemalloc when the data is a page or page fragment.</p>
<p>Returns a new <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> on success, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on allocation failure.</p>
</div>
<dl class="function">
<dt id="c.__alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__alloc_skb</code><span class="sig-paren">(</span>unsigned int<em> size</em>, gfp_t<em> gfp_mask</em>, int<em> flags</em>, int<em> node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a network buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>If SKB_ALLOC_FCLONE is set, allocate from fclone cache
instead of head cache and allocate a cloned (child) skb.
If SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for
allocations in case the data is required for writeback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">node</span></code></dt><dd><p>numa node to allocate memory on</p>
<p>Allocate a new <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>. The returned buffer has no headroom and a
tail room of at least size bytes. The object has a reference count
of one. The return is the buffer. On a failure the return is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>Buffers may only be allocated from interrupts using a <strong>gfp_mask</strong> of
<code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__netdev_alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__netdev_alloc_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, unsigned int<em> len</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__netdev_alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an skbuff for rx on a specific device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device to receive on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>get_free_pages mask, passed to alloc_skb</p>
<p>Allocate a new <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and assign it a usage count of one. The
buffer has NET_SKB_PAD headroom built in. Users should allocate
the headroom they think they need without accounting for the
built in space. The built in space is used for optimisations.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__napi_alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__napi_alloc_skb</code><span class="sig-paren">(</span>struct napi_struct<em> *napi</em>, unsigned int<em> len</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__napi_alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate skbuff for rx in a specific NAPI instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*napi</span></code></dt><dd><p>napi instance this buffer was allocated for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>get_free_pages mask, passed to alloc_skb and alloc_pages</p>
<p>Allocate a new sk_buff for use in NAPI receive.  This buffer will
attempt to allocate the head from a special reserved region used
only for NAPI Rx allocation.  By doing this we can save several
CPU cycles by avoiding having to disable and re-enable IRQs.</p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__kfree_skb">
void <code class="sig-name descname">__kfree_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__kfree_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>private function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
<p>Free an sk_buff. Release anything attached to the buffer.
Clean the state. This is an internal helper function. Users should
always call kfree_skb</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kfree_skb_reason">
void __fix_address <code class="sig-name descname">kfree_skb_reason</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, enum skb_drop_reason<em> reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_skb_reason" title="Permalink to this definition">¶</a></dt>
<dd><p>free an sk_buff with special reason</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to free</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">skb_drop_reason</span> <span class="pre">reason</span></code></dt><dd><p>reason why this skb is dropped</p>
<p>Drop a reference to the buffer and free it if the usage count has
hit zero. Meanwhile, pass the drop reason to ‘kfree_skb’
tracepoint.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_tx_error">
void <code class="sig-name descname">skb_tx_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tx_error" title="Permalink to this definition">¶</a></dt>
<dd><p>report an sk_buff xmit error</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer that triggered an error</p>
<p>Report xmit error if a device callback is tracking this skb.
skb must be freed afterwards.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.consume_skb">
void <code class="sig-name descname">consume_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.consume_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>free an skbuff</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to free</p>
<p>Drop a ref to the buffer and free it if the usage count has hit zero
Functions identically to kfree_skb, but kfree_skb assumes that the frame
is being dropped after a failure and notes that</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.alloc_skb_for_msg">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">alloc_skb_for_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *first</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_skb_for_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate sk_buff to wrap frag list forming a msg</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*first</span></code></dt><dd><p>first sk_buff of the msg</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_morph">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_morph</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *dst</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_morph" title="Permalink to this definition">¶</a></dt>
<dd><p>morph one skb into another</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*dst</span></code></dt><dd><p>the skb to receive the contents</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*src</span></code></dt><dd><p>the skb to supply the contents</p>
<p>This is identical to skb_clone except that the target skb is
supplied by the user.</p>
<p>The target skb is returned upon exit.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_copy_ubufs">
int <code class="sig-name descname">skb_copy_ubufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_ubufs" title="Permalink to this definition">¶</a></dt>
<dd><p>copy userspace skb frags buffers to kernel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the skb to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
<p>This must be called on skb with SKBFL_ZEROCOPY_ENABLE.
It will copy all frags into kernel and drop the reference
to userspace pages.</p>
<p>If this function is called from an interrupt gfp_mask() must be
<code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>.</p>
<p>Returns 0 on success or a negative error code on failure
to allocate kernel memory to copy to.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_clone">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_clone</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate an sk_buff</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to clone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
<p>Duplicate an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>. The new one is not owned by a socket. Both
copies share the same packet data but not structure. The new
buffer has a reference count of 1. If the allocation fails the
function returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> otherwise the new buffer is returned.</p>
<p>If this function is called from an interrupt gfp_mask() must be
<code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_copy">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_copy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>create private copy of an sk_buff</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
<p>Make a copy of both an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and its data. This is used when the
caller wishes to modify the data and needs a private copy of the
data to alter. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure or the pointer to the buffer
on success. The returned buffer has a reference count of 1.</p>
<p>As by-product this function converts non-linear <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> to linear
one, so that <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> becomes completely private and caller is allowed
to modify all the data of returned buffer. This means that this
function is not recommended for use in circumstances when only
header is going to be modified. Use pskb_copy() instead.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__pskb_copy_fclone">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__pskb_copy_fclone</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> headroom</em>, gfp_t<em> gfp_mask</em>, bool<em> fclone</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pskb_copy_fclone" title="Permalink to this definition">¶</a></dt>
<dd><p>create copy of an sk_buff with private head.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">headroom</span></code></dt><dd><p>headroom of new skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">fclone</span></code></dt><dd><p>if true allocate the copy of the skb from the fclone
cache instead of the head cache; it is recommended to set this
to true for the cases where the copy will likely be cloned</p>
<p>Make a copy of both an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and part of its data, located
in header. Fragmented data remain shared. This is used when
the caller wishes to modify only header of <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and needs
private copy of the header to alter. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure
or the pointer to the buffer on success.
The returned buffer has a reference count of 1.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pskb_expand_head">
int <code class="sig-name descname">pskb_expand_head</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> nhead</em>, int<em> ntail</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_expand_head" title="Permalink to this definition">¶</a></dt>
<dd><p>reallocate header of <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to reallocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nhead</span></code></dt><dd><p>room to add at head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ntail</span></code></dt><dd><p>room to add at tail</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
<p>Expands (or creates identical copy, if <strong>nhead</strong> and <strong>ntail</strong> are zero)
header of <strong>skb</strong>. <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> itself is not changed. <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> MUST have
reference count of 1. Returns zero in the case of success or error,
if expansion failed. In the last case, <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> is not changed.</p>
<p>All the pointers pointing into skb header may change and must be
reloaded after call to this function.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_expand_head">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_expand_head</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> headroom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_expand_head" title="Permalink to this definition">¶</a></dt>
<dd><p>reallocate header of <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to reallocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">headroom</span></code></dt><dd><p>needed headroom</p>
<p>Unlike skb_realloc_headroom, this one does not allocate a new skb
if possible; copies skb-&gt;sk to new skb as needed
and frees original skb in case of failures.</p>
<p>It expect increased headroom and generates warning otherwise.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_copy_expand">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_copy_expand</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> newheadroom</em>, int<em> newtailroom</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>copy and expand sk_buff</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">newheadroom</span></code></dt><dd><p>new free bytes at head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">newtailroom</span></code></dt><dd><p>new free bytes at tail</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation priority</p>
<p>Make a copy of both an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> and its data and while doing so
allocate additional space.</p>
<p>This is used when the caller wishes to modify the data and needs a
private copy of the data to alter as well as more space for new fields.
Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure or the pointer to the buffer
on success. The returned buffer has a reference count of 1.</p>
<p>You must pass <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code> as the allocation priority if this function
is called from an interrupt.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_pad">
int <code class="sig-name descname">__skb_pad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> pad</em>, bool<em> free_on_error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>zero pad the tail of an skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pad</span></code></dt><dd><p>space to pad</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">free_on_error</span></code></dt><dd><p>free buffer on error</p>
<p>Ensure that a buffer is followed by a padding area that is zero
filled. Used by network drivers which may DMA or transfer data
beyond the buffer end onto the wire.</p>
<p>May return error in out of memory cases. The skb is freed on error
if <strong>free_on_error</strong> is true.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pskb_put">
void * <code class="sig-name descname">pskb_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *tail</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_put" title="Permalink to this definition">¶</a></dt>
<dd><p>add data to the tail of a potentially fragmented buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>start of the buffer to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*tail</span></code></dt><dd><p>tail fragment of the buffer to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to add</p>
<p>This function extends the used data area of the potentially
fragmented buffer. <strong>tail</strong> must be the last fragment of <strong>skb</strong> – or
<strong>skb</strong> itself. If this would exceed the total buffer size the kernel
will panic. A pointer to the first byte of the extra data is
returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_put">
void * <code class="sig-name descname">skb_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_put" title="Permalink to this definition">¶</a></dt>
<dd><p>add data to a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to add</p>
<p>This function extends the used data area of the buffer. If this would
exceed the total buffer size the kernel will panic. A pointer to the
first byte of the extra data is returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_push">
void * <code class="sig-name descname">skb_push</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_push" title="Permalink to this definition">¶</a></dt>
<dd><p>add data to the start of a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to add</p>
<p>This function extends the used data area of the buffer at the buffer
start. If this would exceed the total buffer headroom the kernel will
panic. A pointer to the first byte of the extra data is returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_pull">
void * <code class="sig-name descname">skb_pull</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pull" title="Permalink to this definition">¶</a></dt>
<dd><p>remove data from the start of a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to remove</p>
<p>This function removes data from the start of a buffer, returning
the memory to the headroom. A pointer to the next data in the buffer
is returned. Once the data has been pulled future pushes will overwrite
the old data.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_pull_data">
void * <code class="sig-name descname">skb_pull_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pull_data" title="Permalink to this definition">¶</a></dt>
<dd><p>remove data from the start of a buffer returning its original position.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>amount of data to remove</p>
<p>This function removes data from the start of a buffer, returning
the memory to the headroom. A pointer to the original data in the buffer
is returned after checking if there is enough data to pull. Once the
data has been pulled future pushes will overwrite the old data.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_trim">
void <code class="sig-name descname">skb_trim</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_trim" title="Permalink to this definition">¶</a></dt>
<dd><p>remove end from a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to alter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>new length</p>
<p>Cut the length of a buffer down by removing data from the tail. If
the buffer is already under the length specified it is not modified.
The skb must be linear.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__pskb_pull_tail">
void * <code class="sig-name descname">__pskb_pull_tail</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> delta</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pskb_pull_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>advance tail of skb header</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to reallocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">delta</span></code></dt><dd><p>number of bytes to advance tail</p>
<p>The function makes a sense only on a fragmented <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a>,
it expands header moving its tail forward and copying necessary
data from fragmented part.</p>
<p><a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> MUST have reference count of 1.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (and <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> does not change) if pull failed
or value of new tail of skb in the case of success.</p>
<p>All the pointers pointing into skb header may change and must be
reloaded after call to this function.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_copy_bits">
int <code class="sig-name descname">skb_copy_bits</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> offset</em>, void<em> *to</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>copy bits from skb to kernel buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>source skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*to</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy</p>
<p>Copy the specified number of bytes from the source skb to the
destination buffer.</p>
<dl class="simple">
<dt>CAUTION ! :</dt><dd><p>If its prototype is ever changed,
check arch/{*}/net/{*}.S files,
since it is called from BPF assembly code.</p>
</dd>
</dl>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_store_bits">
int <code class="sig-name descname">skb_store_bits</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> offset</em>, const void<em> *from</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_store_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>store bits from kernel buffer to skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*from</span></code></dt><dd><p>source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy</p>
<p>Copy the specified number of bytes from the source buffer to the
destination skb.  This function handles all the messy bits of
traversing fragment lists and such.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_zerocopy">
int <code class="sig-name descname">skb_zerocopy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *to</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *from</em>, int<em> len</em>, int<em> hlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_zerocopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero copy skb to skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*to</span></code></dt><dd><p>destination buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*from</span></code></dt><dd><p>source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to copy from source buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">hlen</span></code></dt><dd><p>size of linear headroom in destination buffer</p>
<p>Copies up to <cite>len</cite> bytes from <cite>from</cite> to <cite>to</cite> by creating references
to the frags in the source buffer.</p>
<p>The <cite>hlen</cite> as calculated by skb_zerocopy_headlen() specifies the
headroom in the <cite>to</cite> buffer.</p>
<p>Return value:
0: everything is OK
-ENOMEM: couldn’t orphan frags of <strong>from</strong> due to lack of memory
-EFAULT: <a class="reference internal" href="#c.skb_copy_bits" title="skb_copy_bits"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_copy_bits()</span></code></a> found some problem with skb geometry</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_dequeue">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_dequeue</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dequeue" title="Permalink to this definition">¶</a></dt>
<dd><p>remove from the head of the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to dequeue from</p>
<p>Remove the head of the list. The list lock is taken so the function
may be used safely with other locking list functions. The head item is
returned or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the list is empty.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_dequeue_tail">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_dequeue_tail</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dequeue_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>remove from the tail of the queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to dequeue from</p>
<p>Remove the tail of the list. The list lock is taken so the function
may be used safely with other locking list functions. The tail item is
returned or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the list is empty.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_purge">
void <code class="sig-name descname">skb_queue_purge</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_purge" title="Permalink to this definition">¶</a></dt>
<dd><p>empty a list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to empty</p>
<p>Delete all buffers on an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> list. Each buffer is removed from
the list and one reference dropped. This function takes the list
lock and is atomic with respect to other list locking functions.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_head">
void <code class="sig-name descname">skb_queue_head</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_head" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list head</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*newsk</span></code></dt><dd><p>buffer to queue</p>
<p>Queue a buffer at the start of the list. This function takes the
list lock and can be used safely with other locking <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> functions
safely.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_queue_tail">
void <code class="sig-name descname">skb_queue_tail</code><span class="sig-paren">(</span>struct sk_buff_head<em> *list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list tail</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*newsk</span></code></dt><dd><p>buffer to queue</p>
<p>Queue a buffer at the tail of the list. This function takes the
list lock and can be used safely with other locking <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a> functions
safely.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_unlink">
void <code class="sig-name descname">skb_unlink</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct sk_buff_head<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a buffer from a list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to remove</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to use</p>
<p>Remove a packet from a list. The list locks are taken and this
function is atomic with respect to other list locked calls</p>
<p>You must know what list the SKB is on.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_append">
void <code class="sig-name descname">skb_append</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *old</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *newsk</em>, struct sk_buff_head<em> *list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_append" title="Permalink to this definition">¶</a></dt>
<dd><p>append a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*old</span></code></dt><dd><p>buffer to insert after</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*newsk</span></code></dt><dd><p>buffer to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*list</span></code></dt><dd><p>list to use</p>
<p>Place a packet after a given packet in a list. The list locks are taken
and this function is atomic with respect to other list locked calls.
A buffer cannot be placed on two lists at the same time.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_split">
void <code class="sig-name descname">skb_split</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb1</em>, const u32<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split fragmented skb to two parts at length len.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the buffer to split</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb1</span></code></dt><dd><p>the buffer to receive the second part</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">len</span></code></dt><dd><p>new length for skb</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_prepare_seq_read">
void <code class="sig-name descname">skb_prepare_seq_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> from</em>, unsigned int<em> to</em>, struct skb_seq_state<em> *st</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_prepare_seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a sequential read of skb data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the buffer to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">from</span></code></dt><dd><p>lower offset of data to be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">to</span></code></dt><dd><p>upper offset of data to be read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skb_seq_state</span> <span class="pre">*st</span></code></dt><dd><p>state variable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the specified state variable. Must be called before
invoking <a class="reference internal" href="#c.skb_seq_read" title="skb_seq_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_seq_read()</span></code></a> for the first time.</p>
</div>
<dl class="function">
<dt id="c.skb_seq_read">
unsigned int <code class="sig-name descname">skb_seq_read</code><span class="sig-paren">(</span>unsigned int<em> consumed</em>, const u8<em> **data</em>, struct skb_seq_state<em> *st</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Sequentially read skb data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">consumed</span></code></dt><dd><p>number of bytes consumed by the caller so far</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">**data</span></code></dt><dd><p>destination pointer for data to be returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skb_seq_state</span> <span class="pre">*st</span></code></dt><dd><p>state variable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a block of skb data at <strong>consumed</strong> relative to the
lower offset specified to <a class="reference internal" href="#c.skb_prepare_seq_read" title="skb_prepare_seq_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_prepare_seq_read()</span></code></a>. Assigns
the head of the data block to <strong>data</strong> and returns the length
of the block or 0 if the end of the skb data or the upper
offset has been reached.</p>
<p>The caller is not required to consume all of the data
returned, i.e. <strong>consumed</strong> is typically set to the number
of bytes already consumed and the next call to
<a class="reference internal" href="#c.skb_seq_read" title="skb_seq_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_seq_read()</span></code></a> will return the remaining part of the block.</p>
<dl class="simple">
<dt>Note 1: The size of each block of data returned can be arbitrary,</dt><dd><p>this limitation is the cost for zerocopy sequential
reads of potentially non linear data.</p>
</dd>
<dt>Note 2: Fragment lists within fragments are not implemented</dt><dd><p>at the moment, state-&gt;root_skb could be replaced with
a stack for this purpose.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_abort_seq_read">
void <code class="sig-name descname">skb_abort_seq_read</code><span class="sig-paren">(</span>struct skb_seq_state<em> *st</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_abort_seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Abort a sequential read of skb data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skb_seq_state</span> <span class="pre">*st</span></code></dt><dd><p>state variable</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called if <a class="reference internal" href="#c.skb_seq_read" title="skb_seq_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">skb_seq_read()</span></code></a> was not called until it
returned 0.</p>
</div>
<dl class="function">
<dt id="c.skb_find_text">
unsigned int <code class="sig-name descname">skb_find_text</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> from</em>, unsigned int<em> to</em>, struct ts_config<em> *config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_find_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a text pattern in skb data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the buffer to look in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">from</span></code></dt><dd><p>search offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">to</span></code></dt><dd><p>search limit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*config</span></code></dt><dd><p>textsearch configuration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds a pattern in the skb data according to the specified
textsearch configuration. Use <a class="reference internal" href="../core-api/kernel-api.html#c.textsearch_next" title="textsearch_next"><code class="xref c c-func docutils literal notranslate"><span class="pre">textsearch_next()</span></code></a> to retrieve
subsequent occurrences of the pattern. Returns the offset
to the first occurrence or UINT_MAX if no match was found.</p>
</div>
<dl class="function">
<dt id="c.skb_pull_rcsum">
void * <code class="sig-name descname">skb_pull_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pull_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>pull skb and update receive checksum</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data pulled</p>
<p>This function performs an skb_pull on the packet and updates
the CHECKSUM_COMPLETE checksum.  It should be used on
receive path processing instead of skb_pull unless you know
that the checksum difference is zero (e.g., a valid IP header)
or you are setting ip_summed to CHECKSUM_NONE.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_segment">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_segment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *head_skb</em>, netdev_features_t<em> features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform protocol segmentation on skb.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*head_skb</span></code></dt><dd><p>buffer to segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">features</span></code></dt><dd><p>features for the output path (see dev-&gt;features)</p>
<p>This function performs segmentation on the given skb.  It returns
a pointer to the first in a list of new skbs for the segments.
In case of error it returns ERR_PTR(err).</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_to_sgvec">
int <code class="sig-name descname">skb_to_sgvec</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct scatterlist<em> *sg</em>, int<em> offset</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_to_sgvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a scatter-gather list from a socket buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>Socket buffer containing the buffers to be mapped</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*sg</span></code></dt><dd><p>The scatter-gather list to map into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>The offset into the buffer’s contents to start mapping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of buffer space to be mapped</p>
<p>Fill the specified scatter-gather list with mappings/pointers into a
region of the buffer space attached to a socket buffer. Returns either
the number of scatterlist items used, or -EMSGSIZE if the contents
could not fit.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_cow_data">
int <code class="sig-name descname">skb_cow_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> tailbits</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> **trailer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cow_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that a socket buffer’s data buffers are writable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>The socket buffer to check.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">tailbits</span></code></dt><dd><p>Amount of trailing space to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**trailer</span></code></dt><dd><p>Returned pointer to the skb where the <strong>tailbits</strong> space begins</p>
<p>Make sure that the data buffers attached to a socket buffer are
writable. If they are not, private copies are made of the data buffers
and the socket buffer is set to use these instead.</p>
<p>If <strong>tailbits</strong> is given, make sure that there is space to write <strong>tailbits</strong>
bytes of data beyond current end of socket buffer.  <strong>trailer</strong> will be
set to point to the skb in which this space begins.</p>
<p>The number of scatterlist elements required to completely map the
COW’d and extended socket buffer will be returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_clone_sk">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_clone_sk</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_clone_sk" title="Permalink to this definition">¶</a></dt>
<dd><p>create clone of skb, and take reference to socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the skb to clone</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a clone of a buffer that holds a reference on
sk_refcnt.  Buffers created via this function are meant to be
returned using sock_queue_err_skb, or free via kfree_skb.</p>
<p>When passing buffers allocated with this function to sock_queue_err_skb
it is necessary to wrap the call with sock_hold/sock_put in order to
prevent the socket from being released prior to being enqueued on
the sk_error_queue.</p>
</div>
<dl class="function">
<dt id="c.skb_partial_csum_set">
bool <code class="sig-name descname">skb_partial_csum_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, u16<em> start</em>, u16<em> off</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_partial_csum_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set up and verify partial csum values for packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the skb to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">start</span></code></dt><dd><p>the number of bytes after skb-&gt;data to start checksumming.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">off</span></code></dt><dd><p>the offset from start to place the checksum.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For untrusted partially-checksummed packets, we need to make sure the values
for skb-&gt;csum_start and skb-&gt;csum_offset are valid so we don’t oops.</p>
<p>This function checks and sets those values and skb-&gt;ip_summed: if this
returns false you should drop the packet.</p>
</div>
<dl class="function">
<dt id="c.skb_checksum_setup">
int <code class="sig-name descname">skb_checksum_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, bool<em> recalculate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>set up partial checksum offset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the skb to set up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">recalculate</span></code></dt><dd><p>if true the pseudo-header checksum will be recalculated</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_checksum_trimmed">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">skb_checksum_trimmed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> transport_len</em>, __sum16(<em>*skb_chkf</em>)(struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *skb)<span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_trimmed" title="Permalink to this definition">¶</a></dt>
<dd><p>validate checksum of an skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>the skb to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">transport_len</span></code></dt><dd><p>the data length beyond the network header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__sum16(*skb_chkf)(struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb)</span></code></dt><dd><p>checksum function to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Applies the given checksum function skb_chkf to the provided skb.
Returns a checked and maybe trimmed skb. Returns NULL on error.</p>
<p>If the skb has data beyond the given transport length, then a
trimmed &amp; cloned skb is checked and returned.</p>
<p>Caller needs to set the skb transport header and free any returned skb if it
differs from the provided skb.</p>
</div>
<dl class="function">
<dt id="c.skb_try_coalesce">
bool <code class="sig-name descname">skb_try_coalesce</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *to</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *from</em>, bool<em> *fragstolen</em>, int<em> *delta_truesize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_try_coalesce" title="Permalink to this definition">¶</a></dt>
<dd><p>try to merge skb to prior one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*to</span></code></dt><dd><p>prior buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*from</span></code></dt><dd><p>buffer to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*fragstolen</span></code></dt><dd><p>pointer to boolean</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*delta_truesize</span></code></dt><dd><p>how much more was allocated than was requested</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_scrub_packet">
void <code class="sig-name descname">skb_scrub_packet</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, bool<em> xnet</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_scrub_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>scrub an skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to clean</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">xnet</span></code></dt><dd><p>packet is crossing netns</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>skb_scrub_packet can be used after encapsulating or decapsulting a packet
into/from a tunnel. Some information have to be cleared during these
operations.
skb_scrub_packet can also be used to clean a skb before injecting it in
another namespace (<strong>xnet</strong> == true). We have to clear all information in the
skb that could impact namespace isolation.</p>
</div>
<dl class="function">
<dt id="c.skb_gso_validate_network_len">
bool <code class="sig-name descname">skb_gso_validate_network_len</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> mtu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_gso_validate_network_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Will a split GSO skb fit into a given MTU?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>GSO skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mtu</span></code></dt><dd><p>MTU to validate against</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>skb_gso_validate_network_len validates if a given skb will fit a
wanted MTU once split. It considers L3 headers, L4 headers, and the
payload.</p>
</div>
<dl class="function">
<dt id="c.skb_gso_validate_mac_len">
bool <code class="sig-name descname">skb_gso_validate_mac_len</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_gso_validate_mac_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Will a split GSO skb fit in a given length?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>GSO skb</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length to validate against</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>skb_gso_validate_mac_len validates if a given skb will fit a wanted
length once split, including L2, L3 and L4 headers and the payload.</p>
</div>
<dl class="function">
<dt id="c.skb_eth_pop">
int <code class="sig-name descname">skb_eth_pop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_eth_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop the Ethernet header at the head of a packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>Socket buffer to modify</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drop the Ethernet header of <strong>skb</strong>.</p>
<p>Expects that skb-&gt;data points to the mac header and that no VLAN tags are
present.</p>
<p>Returns 0 on success, -errno otherwise.</p>
</div>
<dl class="function">
<dt id="c.skb_eth_push">
int <code class="sig-name descname">skb_eth_push</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, const unsigned char<em> *dst</em>, const unsigned char<em> *src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_eth_push" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new Ethernet header at the head of a packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>Socket buffer to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*dst</span></code></dt><dd><p>Destination MAC address of the new header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*src</span></code></dt><dd><p>Source MAC address of the new header</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepend <strong>skb</strong> with a new Ethernet header.</p>
<p>Expects that skb-&gt;data points to the mac header, which must be empty.</p>
<p>Returns 0 on success, -errno otherwise.</p>
</div>
<dl class="function">
<dt id="c.skb_mpls_push">
int <code class="sig-name descname">skb_mpls_push</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, __be32<em> mpls_lse</em>, __be16<em> mpls_proto</em>, int<em> mac_len</em>, bool<em> ethernet</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_mpls_push" title="Permalink to this definition">¶</a></dt>
<dd><p>push a new MPLS header after mac_len bytes from start of the packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">mpls_lse</span></code></dt><dd><p>MPLS label stack entry to push</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be16</span> <span class="pre">mpls_proto</span></code></dt><dd><p>ethertype of the new MPLS header (expects 0x8847 or 0x8848)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mac_len</span></code></dt><dd><p>length of the MAC header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">ethernet</span></code></dt><dd><p>flag to indicate if the resulting packet after skb_mpls_push is
ethernet</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expects skb-&gt;data at mac header.</p>
<p>Returns 0 on success, -errno otherwise.</p>
</div>
<dl class="function">
<dt id="c.skb_mpls_pop">
int <code class="sig-name descname">skb_mpls_pop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, __be16<em> next_proto</em>, int<em> mac_len</em>, bool<em> ethernet</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_mpls_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>pop the outermost MPLS header</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be16</span> <span class="pre">next_proto</span></code></dt><dd><p>ethertype of header after popped MPLS header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mac_len</span></code></dt><dd><p>length of the MAC header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">ethernet</span></code></dt><dd><p>flag to indicate if the packet is ethernet</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expects skb-&gt;data at mac header.</p>
<p>Returns 0 on success, -errno otherwise.</p>
</div>
<dl class="function">
<dt id="c.skb_mpls_update_lse">
int <code class="sig-name descname">skb_mpls_update_lse</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, __be32<em> mpls_lse</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_mpls_update_lse" title="Permalink to this definition">¶</a></dt>
<dd><p>modify outermost MPLS header and update csum</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">mpls_lse</span></code></dt><dd><p>new MPLS label stack entry to update to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expects skb-&gt;data at mac header.</p>
<p>Returns 0 on success, -errno otherwise.</p>
</div>
<dl class="function">
<dt id="c.skb_mpls_dec_ttl">
int <code class="sig-name descname">skb_mpls_dec_ttl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_mpls_dec_ttl" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement the TTL of the outermost MPLS header</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expects skb-&gt;data at mac header.</p>
<p>Returns 0 on success, -errno otherwise.</p>
</div>
<dl class="function">
<dt id="c.alloc_skb_with_frags">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">alloc_skb_with_frags</code><span class="sig-paren">(</span>unsigned long<em> header_len</em>, unsigned long<em> data_len</em>, int<em> max_page_order</em>, int<em> *errcode</em>, gfp_t<em> gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_skb_with_frags" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate skb with page frags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">header_len</span></code></dt><dd><p>size of linear part</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">data_len</span></code></dt><dd><p>needed length in frags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_page_order</span></code></dt><dd><p>max page order desired.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*errcode</span></code></dt><dd><p>pointer to error code if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>allocation mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used to allocate a paged skb, given a maximal order for frags.</p>
</div>
<dl class="function">
<dt id="c.skb_condense">
void <code class="sig-name descname">skb_condense</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_condense" title="Permalink to this definition">¶</a></dt>
<dd><p>try to get rid of fragments/frag_list if possible</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Can be used to save memory before skb is added to a busy queue.
If packet has bytes in frags and enough tail room in skb-&gt;head,
pull all of them, so that we can free the frags right now and adjust
truesize.</p>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>We do not reallocate skb-&gt;head thus can not fail.
Caller must re-evaluate skb-&gt;truesize if needed.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.skb_ext_add">
void * <code class="sig-name descname">skb_ext_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, enum skb_ext_id<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_ext_add" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate space for given extension, COW if needed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">skb_ext_id</span> <span class="pre">id</span></code></dt><dd><p>extension to allocate space for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates enough space for the given extension.
If the extension is already present, a pointer to that extension
is returned.</p>
<p>If the skb was cloned, COW applies and the returned memory can be
modified without changing the extension space of clones buffers.</p>
<p>Returns pointer to the extension or NULL on allocation failure.</p>
</div>
<dl class="function">
<dt id="c.sk_ns_capable">
bool <code class="sig-name descname">sk_ns_capable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, struct user_namespace<em> *user_ns</em>, int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_ns_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>General socket capability test</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>Socket to use a capability on or through</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*user_ns</span></code></dt><dd><p>The user namespace of the capability to use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>The capability to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test to see if the opener of the socket had when the socket was
created and the current process has the capability <strong>cap</strong> in the user
namespace <strong>user_ns</strong>.</p>
</div>
<dl class="function">
<dt id="c.sk_capable">
bool <code class="sig-name descname">sk_capable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>Socket global capability test</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>Socket to use a capability on or through</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>The global capability to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test to see if the opener of the socket had when the socket was
created and the current process has the capability <strong>cap</strong> in all user
namespaces.</p>
</div>
<dl class="function">
<dt id="c.sk_net_capable">
bool <code class="sig-name descname">sk_net_capable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_net_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>Network namespace socket capability test</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>Socket to use a capability on or through</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>The capability to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test to see if the opener of the socket had when the socket was created
and the current process has the capability <strong>cap</strong> over the network namespace
the socket is a member of.</p>
</div>
<dl class="function">
<dt id="c.sk_set_memalloc">
void <code class="sig-name descname">sk_set_memalloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_set_memalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>sets <code class="docutils literal notranslate"><span class="pre">SOCK_MEMALLOC</span></code></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket to set it on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set <code class="docutils literal notranslate"><span class="pre">SOCK_MEMALLOC</span></code> on a socket for access to emergency reserves.
It’s the responsibility of the admin to adjust min_free_kbytes
to meet the requirements</p>
</div>
<dl class="function">
<dt id="c.sk_alloc">
struct <a class="reference internal" href="#c.sock" title="sock">sock</a> * <code class="sig-name descname">sk_alloc</code><span class="sig-paren">(</span>struct net<em> *net</em>, int<em> family</em>, gfp_t<em> priority</em>, struct proto<em> *prot</em>, int<em> kern</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>All socket objects are allocated here</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>protocol family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">priority</span></code></dt><dd><p>for allocation (<code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>, <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>, etc)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">proto</span> <span class="pre">*prot</span></code></dt><dd><p>struct proto associated with this new sock instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kern</span></code></dt><dd><p>is this to be a kernel socket?</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sk_clone_lock">
struct <a class="reference internal" href="#c.sock" title="sock">sock</a> * <code class="sig-name descname">sk_clone_lock</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, const gfp_t<em> priority</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_clone_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>clone a socket, and lock its clone</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>the socket to clone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">gfp_t</span> <span class="pre">priority</span></code></dt><dd><p>for allocation (<code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code>, <code class="docutils literal notranslate"><span class="pre">GFP_ATOMIC</span></code>, etc)</p>
<p>Caller must unlock socket even in error path (bh_unlock_sock(newsk))</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_page_frag_refill">
bool <code class="sig-name descname">skb_page_frag_refill</code><span class="sig-paren">(</span>unsigned int<em> sz</em>, struct page_frag<em> *pfrag</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_page_frag_refill" title="Permalink to this definition">¶</a></dt>
<dd><p>check that a page_frag contains enough room</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz</span></code></dt><dd><p>minimum size of the fragment we want to get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page_frag</span> <span class="pre">*pfrag</span></code></dt><dd><p>pointer to page_frag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>priority for memory allocation</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>While this allocator tries to use high order pages, there is
no guarantee that allocations succeed. Therefore, <strong>sz</strong> MUST be
less or equal than PAGE_SIZE.</p>
</div>
<dl class="function">
<dt id="c.sk_wait_data">
int <code class="sig-name descname">sk_wait_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, long<em> *timeo</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_wait_data" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for data to arrive at sk_receive_queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>sock to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*timeo</span></code></dt><dd><p>for how long</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>last skb seen on sk_receive_queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Now socket state including sk-&gt;sk_err is changed only under lock,
hence we may omit checks after joining wait queue.
We check receive queue before schedule() only as optimization;
it is very likely that release_sock() added new data.</p>
</div>
<dl class="function">
<dt id="c.__sk_mem_schedule">
int <code class="sig-name descname">__sk_mem_schedule</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, int<em> size</em>, int<em> kind</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sk_mem_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>increase sk_forward_alloc and memory_allocated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>memory size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">kind</span></code></dt><dd><p>allocation type</p>
<p>If kind is SK_MEM_SEND, it means wmem allocation. Otherwise it means
rmem allocation. This function assumes that protocols which have
memory_pressure use sk_wmem_queued as write buffer accounting.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__sk_mem_reclaim">
void <code class="sig-name descname">__sk_mem_reclaim</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, int<em> amount</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sk_mem_reclaim" title="Permalink to this definition">¶</a></dt>
<dd><p>reclaim sk_forward_alloc and memory_allocated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">amount</span></code></dt><dd><p>number of bytes (rounded down to a PAGE_SIZE multiple)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__skb_try_recv_datagram">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__skb_try_recv_datagram</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, struct sk_buff_head<em> *queue</em>, unsigned int<em> flags</em>, int<em> *off</em>, int<em> *err</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> **last</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_try_recv_datagram" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a datagram skbuff</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*queue</span></code></dt><dd><p>socket queue from which to receive</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>MSG_ flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*off</span></code></dt><dd><p>an offset in bytes to peek skb from. Returns an offset
within an skb where data actually starts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*err</span></code></dt><dd><p>error code returned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**last</span></code></dt><dd><p>set to last peeked message to inform the wait function
what to look for when peeking</p>
<blockquote>
<div><p>Get a datagram skbuff, understands the peeking, nonblocking wakeups
and possible races. This replaces identical code in packet, raw and
udp, as well as the IPX AX.25 and Appletalk. It also finally fixes
the long standing peek and read race for datagram sockets. If you
alter this routine remember it must be re-entrant.</p>
<p>This function will lock the socket if a skb is returned, so
the caller needs to unlock the socket in that case (usually by
calling skb_free_datagram). Returns NULL with <strong>err</strong> set to
-EAGAIN if no data was available or to some other value if an
error was detected.</p>
<ul class="simple">
<li><p>It does not lock socket since today. This function is</p></li>
<li><p>free of race conditions. This measure should/can improve</p></li>
<li><p>significantly datagram socket latencies at high loads,</p></li>
<li><p>when data copying to user space takes lots of time.</p></li>
<li><p>(BTW I’ve just killed the last cli() in IP/IPv6/core/netlink/packet</p></li>
<li><ol class="arabic simple" start="8">
<li><p>Great win.)</p></li>
</ol>
</li>
<li><p>–ANK (980729)</p></li>
</ul>
<p>The order of the tests when we find no data waiting are specified
quite explicitly by POSIX 1003.1g, don’t change them without having
the standard around please.</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_kill_datagram">
int <code class="sig-name descname">skb_kill_datagram</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_kill_datagram" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a datagram skbuff forcibly</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>datagram skbuff</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>MSG_ flags</p>
<p>This function frees a datagram skbuff that was received by
skb_recv_datagram.  The flags argument must match the one
used for skb_recv_datagram.</p>
<p>If the MSG_PEEK flag is set, and the packet is still on the
receive queue of the socket, it will be taken off the queue
before it is freed.</p>
<p>This function currently only disables BH when acquiring the
sk_receive_queue lock.  Therefore it must not be used in a
context where that lock is acquired in an IRQ context.</p>
<p>It returns 0 if the packet was removed by us.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_copy_and_hash_datagram_iter">
int <code class="sig-name descname">skb_copy_and_hash_datagram_iter</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> offset</em>, struct iov_iter<em> *to</em>, int<em> len</em>, struct ahash_request<em> *hash</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_and_hash_datagram_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy datagram to an iovec iterator and update a hash.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in the buffer to start copying from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*to</span></code></dt><dd><p>iovec iterator to copy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to copy from buffer to iovec</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ahash_request</span> <span class="pre">*hash</span></code></dt><dd><p>hash request to update</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_copy_datagram_iter">
int <code class="sig-name descname">skb_copy_datagram_iter</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> offset</em>, struct iov_iter<em> *to</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_datagram_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a datagram to an iovec iterator.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in the buffer to start copying from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*to</span></code></dt><dd><p>iovec iterator to copy to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to copy from buffer to iovec</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_copy_datagram_from_iter">
int <code class="sig-name descname">skb_copy_datagram_from_iter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> offset</em>, struct iov_iter<em> *from</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_datagram_from_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a datagram from an iov_iter.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>offset in the buffer to start copying to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*from</span></code></dt><dd><p>the copy source</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>amount of data to copy to buffer from iovec</p>
<p>Returns 0 or -EFAULT.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.zerocopy_sg_from_iter">
int <code class="sig-name descname">zerocopy_sg_from_iter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct iov_iter<em> *from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.zerocopy_sg_from_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a zerocopy datagram from an iov_iter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*from</span></code></dt><dd><p>the source to copy from</p>
<p>The function will first copy up to headlen, and then pin the userspace
pages and build frags through them.</p>
<p>Returns 0, -EFAULT or -EMSGSIZE.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skb_copy_and_csum_datagram_msg">
int <code class="sig-name descname">skb_copy_and_csum_datagram_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> hlen</em>, struct msghdr<em> *msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_and_csum_datagram_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy and checksum skb to user iovec.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>skbuff</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">hlen</span></code></dt><dd><p>hardware length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg</span></code></dt><dd><p>destination</p>
<p>Caller _must_ check that skb will fit to this iovec.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>0       - success.</dt><dd><p>-EINVAL - checksum failure.
-EFAULT - fault during copy.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.datagram_poll">
__poll_t <code class="sig-name descname">datagram_poll</code><span class="sig-paren">(</span>struct file<em> *file</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a><em> *sock</em>, poll_table<em> *wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.datagram_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>generic datagram poll</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*sock</span></code></dt><dd><p>socket</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_table</span> <span class="pre">*wait</span></code></dt><dd><p>poll table</p>
<p>Datagram poll: Again totally generic. This also handles
sequenced packet sockets providing the socket receive queue
is only ever holding data ready to receive.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>when you <em>don’t</em> use this routine for this protocol,</dt><dd><p>and you use a different write policy from sock_writeable()
then please supply your own write_space callback.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sk_stream_wait_connect">
int <code class="sig-name descname">sk_stream_wait_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, long<em> *timeo_p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_stream_wait_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for a socket to get into the connected state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>sock to wait on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*timeo_p</span></code></dt><dd><p>for how long to wait</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called with the socket locked.</p>
</div>
<dl class="function">
<dt id="c.sk_stream_wait_memory">
int <code class="sig-name descname">sk_stream_wait_memory</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, long<em> *timeo_p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_stream_wait_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for more memory for a socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>socket to wait for memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">*timeo_p</span></code></dt><dd><p>for how long</p>
</dd>
</dl>
</div>
</section>
<section id="socket-filter">
<h3>Socket Filter<a class="headerlink" href="#socket-filter" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.sk_filter_trim_cap">
int <code class="sig-name descname">sk_filter_trim_cap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned int<em> cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_filter_trim_cap" title="Permalink to this definition">¶</a></dt>
<dd><p>run a packet through a socket filter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>sock associated with <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">sk_buff</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to filter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cap</span></code></dt><dd><p>limit on how short the eBPF program may trim the packet</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Run the eBPF program and then cut skb-&gt;data to correct size returned by
the program. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller
than pkt_len we keep whole skb-&gt;data. This is the socket level
wrapper to bpf_prog_run. It returns 0 if the packet should
be accepted or -EPERM if the packet should be tossed.</p>
</div>
<dl class="function">
<dt id="c.bpf_prog_create">
int <code class="sig-name descname">bpf_prog_create</code><span class="sig-paren">(</span>struct bpf_prog<em> **pfp</em>, struct sock_fprog_kern<em> *fprog</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bpf_prog_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create an unattached filter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_prog</span> <span class="pre">**pfp</span></code></dt><dd><p>the unattached filter that is created</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock_fprog_kern</span> <span class="pre">*fprog</span></code></dt><dd><p>the filter program</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a filter independent of any socket. We first run some
sanity checks on it to make sure it does not explode on us later.
If an error occurs or there is insufficient memory for the filter
a negative errno code is returned. On success the return is zero.</p>
</div>
<dl class="function">
<dt id="c.bpf_prog_create_from_user">
int <code class="sig-name descname">bpf_prog_create_from_user</code><span class="sig-paren">(</span>struct bpf_prog<em> **pfp</em>, struct sock_fprog<em> *fprog</em>, bpf_aux_classic_check_t<em> trans</em>, bool<em> save_orig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bpf_prog_create_from_user" title="Permalink to this definition">¶</a></dt>
<dd><p>create an unattached filter from user buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">bpf_prog</span> <span class="pre">**pfp</span></code></dt><dd><p>the unattached filter that is created</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock_fprog</span> <span class="pre">*fprog</span></code></dt><dd><p>the filter program</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bpf_aux_classic_check_t</span> <span class="pre">trans</span></code></dt><dd><p>post-classic verifier transformation handler</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">save_orig</span></code></dt><dd><p>save classic BPF program</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function effectively does the same as <a class="reference internal" href="#c.bpf_prog_create" title="bpf_prog_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">bpf_prog_create()</span></code></a>, only
that it builds up its insns buffer from user space provided buffer.
It also allows for passing a bpf_aux_classic_check_t handler.</p>
</div>
<dl class="function">
<dt id="c.sk_attach_filter">
int <code class="sig-name descname">sk_attach_filter</code><span class="sig-paren">(</span>struct sock_fprog<em> *fprog</em>, struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_attach_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a socket filter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock_fprog</span> <span class="pre">*fprog</span></code></dt><dd><p>the filter program</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>the socket to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attach the user’s filter code. We first run some sanity checks on
it to make sure it does not explode on us later. If an error
occurs or there is insufficient memory for the filter a negative
errno code is returned. On success the return is zero.</p>
</div>
</section>
<section id="generic-network-statistics">
<h3>Generic Network Statistics<a class="headerlink" href="#generic-network-statistics" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.gnet_stats_basic">
struct <code class="sig-name descname">gnet_stats_basic</code><a class="headerlink" href="#c.gnet_stats_basic" title="Permalink to this definition">¶</a></dt>
<dd><p>byte/packet throughput statistics</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gnet_stats_basic {
    __u64 bytes;
    __u32 packets;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bytes</span></code></dt><dd><p>number of seen bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">packets</span></code></dt><dd><p>number of seen packets</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.gnet_stats_rate_est">
struct <code class="sig-name descname">gnet_stats_rate_est</code><a class="headerlink" href="#c.gnet_stats_rate_est" title="Permalink to this definition">¶</a></dt>
<dd><p>rate estimator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gnet_stats_rate_est {
    __u32 bps;
    __u32 pps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bps</span></code></dt><dd><p>current byte rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps</span></code></dt><dd><p>current packet rate</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.gnet_stats_rate_est64">
struct <code class="sig-name descname">gnet_stats_rate_est64</code><a class="headerlink" href="#c.gnet_stats_rate_est64" title="Permalink to this definition">¶</a></dt>
<dd><p>rate estimator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gnet_stats_rate_est64 {
    __u64 bps;
    __u64 pps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">bps</span></code></dt><dd><p>current byte rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pps</span></code></dt><dd><p>current packet rate</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.gnet_stats_queue">
struct <code class="sig-name descname">gnet_stats_queue</code><a class="headerlink" href="#c.gnet_stats_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>queuing statistics</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gnet_stats_queue {
    __u32 qlen;
    __u32 backlog;
    __u32 drops;
    __u32 requeues;
    __u32 overlimits;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qlen</span></code></dt><dd><p>queue length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">backlog</span></code></dt><dd><p>backlog size of queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drops</span></code></dt><dd><p>number of dropped packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">requeues</span></code></dt><dd><p>number of requeues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">overlimits</span></code></dt><dd><p>number of enqueues over the limit</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.gnet_estimator">
struct <code class="sig-name descname">gnet_estimator</code><a class="headerlink" href="#c.gnet_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>rate estimator configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gnet_estimator {
    signed char     interval;
    unsigned char   ewma_log;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">interval</span></code></dt><dd><p>sampling period</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ewma_log</span></code></dt><dd><p>the log of measurement window weight</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.gnet_stats_start_copy_compat">
int <code class="sig-name descname">gnet_stats_start_copy_compat</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> type</em>, int<em> tc_stats_type</em>, int<em> xstats_type</em>, spinlock_t<em> *lock</em>, struct gnet_dump<em> *d</em>, int<em> padattr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_start_copy_compat" title="Permalink to this definition">¶</a></dt>
<dd><p>start dumping procedure in compatibility mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>socket buffer to put statistics TLVs into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>TLV type for top level statistic TLV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">tc_stats_type</span></code></dt><dd><p>TLV type for backward compatibility struct tc_stats TLV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">xstats_type</span></code></dt><dd><p>TLV type for backward compatibility xstats TLV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>statistics lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">padattr</span></code></dt><dd><p>padding attribute</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the dumping handle, grabs the statistic lock and appends
an empty TLV header to the socket buffer for use a container for all
other statistic TLVS.</p>
<p>The dumping handle is marked to be in backward compatibility mode telling
all gnet_stats_copy_XXX() functions to fill a local copy of struct tc_stats.</p>
<p>Returns 0 on success or -1 if the room in the socket buffer was not sufficient.</p>
</div>
<dl class="function">
<dt id="c.gnet_stats_start_copy">
int <code class="sig-name descname">gnet_stats_start_copy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, int<em> type</em>, spinlock_t<em> *lock</em>, struct gnet_dump<em> *d</em>, int<em> padattr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_start_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>start dumping procedure in compatibility mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>socket buffer to put statistics TLVs into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>TLV type for top level statistic TLV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>statistics lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">padattr</span></code></dt><dd><p>padding attribute</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the dumping handle, grabs the statistic lock and appends
an empty TLV header to the socket buffer for use a container for all
other statistic TLVS.</p>
<p>Returns 0 on success or -1 if the room in the socket buffer was not sufficient.</p>
</div>
<dl class="function">
<dt id="c.gnet_stats_copy_basic">
int <code class="sig-name descname">gnet_stats_copy_basic</code><span class="sig-paren">(</span>struct gnet_dump<em> *d</em>, struct gnet_stats_basic_sync __percpu<em> *cpu</em>, struct gnet_stats_basic_sync<em> *b</em>, bool<em> running</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_basic" title="Permalink to this definition">¶</a></dt>
<dd><p>copy basic statistics into statistic TLV</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_sync</span> <span class="pre">__percpu</span> <span class="pre">*cpu</span></code></dt><dd><p>copy statistic per cpu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_sync</span> <span class="pre">*b</span></code></dt><dd><p>basic statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">running</span></code></dt><dd><p>true if <strong>b</strong> represents a running qdisc, thus <strong>b</strong>’s
internal values might change during basic reads.
Only used if <strong>cpu</strong> is NULL</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>task; must not be run from IRQ or BH contexts</p>
<p><strong>Description</strong></p>
<p>Appends the basic statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy()</span></code></a>.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
</div>
<dl class="function">
<dt id="c.gnet_stats_copy_basic_hw">
int <code class="sig-name descname">gnet_stats_copy_basic_hw</code><span class="sig-paren">(</span>struct gnet_dump<em> *d</em>, struct gnet_stats_basic_sync __percpu<em> *cpu</em>, struct gnet_stats_basic_sync<em> *b</em>, bool<em> running</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_basic_hw" title="Permalink to this definition">¶</a></dt>
<dd><p>copy basic hw statistics into statistic TLV</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_sync</span> <span class="pre">__percpu</span> <span class="pre">*cpu</span></code></dt><dd><p>copy statistic per cpu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_sync</span> <span class="pre">*b</span></code></dt><dd><p>basic statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">running</span></code></dt><dd><p>true if <strong>b</strong> represents a running qdisc, thus <strong>b</strong>’s
internal values might change during basic reads.
Only used if <strong>cpu</strong> is NULL</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>task; must not be run from IRQ or BH contexts</p>
<p><strong>Description</strong></p>
<p>Appends the basic statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy()</span></code></a>.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
</div>
<dl class="function">
<dt id="c.gnet_stats_copy_rate_est">
int <code class="sig-name descname">gnet_stats_copy_rate_est</code><span class="sig-paren">(</span>struct gnet_dump<em> *d</em>, struct net_rate_estimator __rcu<em> **rate_est</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_rate_est" title="Permalink to this definition">¶</a></dt>
<dd><p>copy rate estimator statistics into statistics TLV</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**rate_est</span></code></dt><dd><p>rate estimator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the rate estimator statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy()</span></code></a>.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
</div>
<dl class="function">
<dt id="c.gnet_stats_copy_queue">
int <code class="sig-name descname">gnet_stats_copy_queue</code><span class="sig-paren">(</span>struct gnet_dump<em> *d</em>, struct <a class="reference internal" href="#c.gnet_stats_queue" title="gnet_stats_queue">gnet_stats_queue</a> __percpu<em> *cpu_q</em>, struct <a class="reference internal" href="#c.gnet_stats_queue" title="gnet_stats_queue">gnet_stats_queue</a><em> *q</em>, __u32<em> qlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>copy queue statistics into statistics TLV</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_queue</span> <span class="pre">__percpu</span> <span class="pre">*cpu_q</span></code></dt><dd><p>per cpu queue statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_queue</span> <span class="pre">*q</span></code></dt><dd><p>queue statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__u32</span> <span class="pre">qlen</span></code></dt><dd><p>queue length statistics</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the queue statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy()</span></code></a>. Using per cpu queue statistics if
they are available.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
</div>
<dl class="function">
<dt id="c.gnet_stats_copy_app">
int <code class="sig-name descname">gnet_stats_copy_app</code><span class="sig-paren">(</span>struct gnet_dump<em> *d</em>, void<em> *st</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_app" title="Permalink to this definition">¶</a></dt>
<dd><p>copy application specific statistics into statistics TLV</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*d</span></code></dt><dd><p>dumping handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*st</span></code></dt><dd><p>application specific statistics data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the application specific statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy()</span></code></a> and remembers the data for XSTATS if the dumping
handle is in backward compatibility mode.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
</div>
<dl class="function">
<dt id="c.gnet_stats_finish_copy">
int <code class="sig-name descname">gnet_stats_finish_copy</code><span class="sig-paren">(</span>struct gnet_dump<em> *d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_finish_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>finish dumping procedure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*d</span></code></dt><dd><p>dumping handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Corrects the length of the top level TLV to include all TLVs added
by gnet_stats_copy_XXX() calls. Adds the backward compatibility TLVs
if <a class="reference internal" href="#c.gnet_stats_start_copy_compat" title="gnet_stats_start_copy_compat"><code class="xref c c-func docutils literal notranslate"><span class="pre">gnet_stats_start_copy_compat()</span></code></a> was used and releases the statistics
lock.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
</div>
<dl class="function">
<dt id="c.gen_new_estimator">
int <code class="sig-name descname">gen_new_estimator</code><span class="sig-paren">(</span>struct gnet_stats_basic_sync<em> *bstats</em>, struct gnet_stats_basic_sync __percpu<em> *cpu_bstats</em>, struct net_rate_estimator __rcu<em> **rate_est</em>, spinlock_t<em> *lock</em>, bool<em> running</em>, struct nlattr<em> *opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_new_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new rate estimator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_sync</span> <span class="pre">*bstats</span></code></dt><dd><p>basic statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_sync</span> <span class="pre">__percpu</span> <span class="pre">*cpu_bstats</span></code></dt><dd><p>bstats per cpu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**rate_est</span></code></dt><dd><p>rate estimator statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>lock for statistics and control path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">running</span></code></dt><dd><p>true if <strong>bstats</strong> represents a running qdisc, thus <strong>bstats</strong>’
internal values might change during basic reads. Only used
if <strong>bstats_cpu</strong> is NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nlattr</span> <span class="pre">*opt</span></code></dt><dd><p>rate estimator configuration TLV</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new rate estimator with <code class="xref c c-type docutils literal notranslate"><span class="pre">bstats</span></code> as source and <code class="xref c c-type docutils literal notranslate"><span class="pre">rate_est</span></code>
as destination. A new timer with the interval specified in the
configuration TLV is created. Upon each interval, the latest statistics
will be read from <code class="xref c c-type docutils literal notranslate"><span class="pre">bstats</span></code> and the estimated rate will be stored in
<code class="xref c c-type docutils literal notranslate"><span class="pre">rate_est</span></code> with the statistics lock grabbed during this period.</p>
<p>Returns 0 on success or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.gen_kill_estimator">
void <code class="sig-name descname">gen_kill_estimator</code><span class="sig-paren">(</span>struct net_rate_estimator __rcu<em> **rate_est</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_kill_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a rate estimator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**rate_est</span></code></dt><dd><p>rate estimator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the rate estimator.</p>
</div>
<dl class="function">
<dt id="c.gen_replace_estimator">
int <code class="sig-name descname">gen_replace_estimator</code><span class="sig-paren">(</span>struct gnet_stats_basic_sync<em> *bstats</em>, struct gnet_stats_basic_sync __percpu<em> *cpu_bstats</em>, struct net_rate_estimator __rcu<em> **rate_est</em>, spinlock_t<em> *lock</em>, bool<em> running</em>, struct nlattr<em> *opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_replace_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>replace rate estimator configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_sync</span> <span class="pre">*bstats</span></code></dt><dd><p>basic statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_sync</span> <span class="pre">__percpu</span> <span class="pre">*cpu_bstats</span></code></dt><dd><p>bstats per cpu</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**rate_est</span></code></dt><dd><p>rate estimator statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">spinlock_t</span> <span class="pre">*lock</span></code></dt><dd><p>lock for statistics and control path</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">running</span></code></dt><dd><p>true if <strong>bstats</strong> represents a running qdisc, thus <strong>bstats</strong>’
internal values might change during basic reads. Only used
if <strong>cpu_bstats</strong> is NULL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nlattr</span> <span class="pre">*opt</span></code></dt><dd><p>rate estimator configuration TLV</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replaces the configuration of a rate estimator by calling
<a class="reference internal" href="#c.gen_kill_estimator" title="gen_kill_estimator"><code class="xref c c-func docutils literal notranslate"><span class="pre">gen_kill_estimator()</span></code></a> and <a class="reference internal" href="#c.gen_new_estimator" title="gen_new_estimator"><code class="xref c c-func docutils literal notranslate"><span class="pre">gen_new_estimator()</span></code></a>.</p>
<p>Returns 0 on success or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.gen_estimator_active">
bool <code class="sig-name descname">gen_estimator_active</code><span class="sig-paren">(</span>struct net_rate_estimator __rcu<em> **rate_est</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_estimator_active" title="Permalink to this definition">¶</a></dt>
<dd><p>test if estimator is currently in use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**rate_est</span></code></dt><dd><p>rate estimator</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if estimator is active, and false if not.</p>
</div>
</section>
<section id="sun-rpc-subsystem">
<h3>SUN RPC subsystem<a class="headerlink" href="#sun-rpc-subsystem" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.xdr_encode_opaque_fixed">
__be32 * <code class="sig-name descname">xdr_encode_opaque_fixed</code><span class="sig-paren">(</span>__be32<em> *p</em>, const void<em> *ptr</em>, unsigned int<em> nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_encode_opaque_fixed" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode fixed length opaque data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">*p</span></code></dt><dd><p>pointer to current position in XDR buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to data to encode (or NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt><dd><p>size of data.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the array of data of length nbytes at ptr to the XDR buffer
at position p, then align to the next 32-bit boundary by padding
with zero bytes (see RFC1832).
Returns the updated current XDR buffer position</p>
<p><strong>Note</strong></p>
<p>if ptr is NULL, only the padding is performed.</p>
</div>
<dl class="function">
<dt id="c.xdr_encode_opaque">
__be32 * <code class="sig-name descname">xdr_encode_opaque</code><span class="sig-paren">(</span>__be32<em> *p</em>, const void<em> *ptr</em>, unsigned int<em> nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_encode_opaque" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode variable length opaque data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">*p</span></code></dt><dd><p>pointer to current position in XDR buffer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>pointer to data to encode (or NULL)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt><dd><p>size of data.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated current XDR buffer position</p>
</div>
<dl class="function">
<dt id="c.xdr_terminate_string">
void <code class="sig-name descname">xdr_terminate_string</code><span class="sig-paren">(</span>const struct xdr_buf<em> *buf</em>, const u32<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_terminate_string" title="Permalink to this definition">¶</a></dt>
<dd><p>‘0’-terminate a string residing in an xdr_buf</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*buf</span></code></dt><dd><p>XDR buffer where string resides</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">len</span></code></dt><dd><p>length of string, in bytes</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xdr_inline_pages">
void <code class="sig-name descname">xdr_inline_pages</code><span class="sig-paren">(</span>struct xdr_buf<em> *xdr</em>, unsigned int<em> offset</em>, struct page<em> **pages</em>, unsigned int<em> base</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_inline_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare receive buffer for a large reply</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*xdr</span></code></dt><dd><p>xdr_buf into which reply will be placed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>expected offset where data payload will start, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>vector of struct page pointers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>offset in first page where receive should start, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>expected size of the upper layer data payload, in bytes</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c._copy_from_pages">
void <code class="sig-name descname">_copy_from_pages</code><span class="sig-paren">(</span>char<em> *p</em>, struct page<em> **pages</em>, size_t<em> pgbase</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c._copy_from_pages" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*p</span></code></dt><dd><p>pointer to destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>array of pages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">pgbase</span></code></dt><dd><p>offset of source data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data into an arbitrary memory location from an array of pages
The copy is assumed to be non-overlapping.</p>
</div>
<dl class="function">
<dt id="c.xdr_stream_pos">
unsigned int <code class="sig-name descname">xdr_stream_pos</code><span class="sig-paren">(</span>const struct xdr_stream<em> *xdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current offset from the start of the xdr_stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to struct xdr_stream</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xdr_page_pos">
unsigned int <code class="sig-name descname">xdr_page_pos</code><span class="sig-paren">(</span>const struct xdr_stream<em> *xdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_page_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current offset from the start of the xdr pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to struct xdr_stream</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xdr_init_encode">
void <code class="sig-name descname">xdr_init_encode</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, struct xdr_buf<em> *buf</em>, __be32<em> *p</em>, struct rpc_rqst<em> *rqst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_init_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a struct xdr_stream for sending data.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*buf</span></code></dt><dd><p>pointer to XDR buffer in which to encode data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">*p</span></code></dt><dd><p>current pointer inside XDR buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*rqst</span></code></dt><dd><p>pointer to controlling rpc_rqst, for debugging</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>at the moment the RPC client only passes the length of our</dt><dd><p>scratch buffer in the xdr_buf’s header kvec. Previously this
meant we needed to call xdr_adjust_iovec() after encoding the
data. With the new scheme, the xdr_stream manages the details
of the buffer length, and takes care of adjusting the kvec
length for us.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xdr_init_encode_pages">
void <code class="sig-name descname">xdr_init_encode_pages</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, struct xdr_buf<em> *buf</em>, struct page<em> **pages</em>, struct rpc_rqst<em> *rqst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_init_encode_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an xdr_stream for encoding into pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*buf</span></code></dt><dd><p>pointer to XDR buffer into which to encode data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>list of pages to decode into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*rqst</span></code></dt><dd><p>pointer to controlling rpc_rqst, for debugging</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__xdr_commit_encode">
void <code class="sig-name descname">__xdr_commit_encode</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__xdr_commit_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure all data is written to buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We handle encoding across page boundaries by giving the caller a
temporary location to write to, then later copying the data into
place; xdr_commit_encode does that copying.</p>
<p>Normally the caller doesn’t need to call this directly, as the
following xdr_reserve_space will do it.  But an explicit call may be
required at the end of encoding, or any other time when the xdr_buf
data might be read.</p>
</div>
<dl class="function">
<dt id="c.xdr_reserve_space">
__be32 * <code class="sig-name descname">xdr_reserve_space</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, size_t<em> nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_reserve_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve buffer space for sending</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nbytes</span></code></dt><dd><p>number of bytes to reserve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that we have enough buffer space to encode ‘nbytes’ more
bytes of data. If so, update the total xdr_buf length, and
adjust the length of the current kvec.</p>
</div>
<dl class="function">
<dt id="c.xdr_reserve_space_vec">
int <code class="sig-name descname">xdr_reserve_space_vec</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, struct kvec<em> *vec</em>, size_t<em> nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_reserve_space_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserves a large amount of buffer space for sending</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*vec</span></code></dt><dd><p>pointer to a kvec array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nbytes</span></code></dt><dd><p>number of bytes to reserve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reserves enough buffer space to encode ‘nbytes’ of data and stores the
pointers in ‘vec’. The size argument passed to <a class="reference internal" href="#c.xdr_reserve_space" title="xdr_reserve_space"><code class="xref c c-func docutils literal notranslate"><span class="pre">xdr_reserve_space()</span></code></a> is
determined based on the number of bytes remaining in the current page to
avoid invalidating iov_base pointers when xdr_commit_encode() is called.</p>
</div>
<dl class="function">
<dt id="c.xdr_truncate_encode">
void <code class="sig-name descname">xdr_truncate_encode</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_truncate_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate an encode buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>new length of buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Truncates the xdr stream, so that xdr-&gt;buf-&gt;len == len,
and xdr-&gt;p points at offset len from the start of the buffer, and
head, tail, and page lengths are adjusted to correspond.</p>
<p>If this means moving xdr-&gt;p to a different buffer, we assume that
the end pointer should be set to the end of the current page,
except in the case of the head buffer when we assume the head
buffer’s current length represents the end of the available buffer.</p>
<p>This is <em>not</em> safe to use on a buffer that already has inlined page
cache pages (as in a zero-copy server read reply), except for the
simple case of truncating from one position in the tail to another.</p>
</div>
<dl class="function">
<dt id="c.xdr_restrict_buflen">
int <code class="sig-name descname">xdr_restrict_buflen</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, int<em> newbuflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_restrict_buflen" title="Permalink to this definition">¶</a></dt>
<dd><p>decrease available buffer space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">newbuflen</span></code></dt><dd><p>new maximum number of bytes available</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adjust our idea of how much space is available in the buffer.
If we’ve already used too much space in the buffer, returns -1.
If the available space is already smaller than newbuflen, returns 0
and does nothing.  Otherwise, adjusts xdr-&gt;buf-&gt;buflen to newbuflen
and ensures xdr-&gt;end is set at most offset newbuflen from the start
of the buffer.</p>
</div>
<dl class="function">
<dt id="c.xdr_write_pages">
void <code class="sig-name descname">xdr_write_pages</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, struct page<em> **pages</em>, unsigned int<em> base</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_write_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a list of pages into an XDR buffer for sending</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>array of pages to insert</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>starting offset of first data byte in <strong>pages</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of data bytes in <strong>pages</strong> to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After the <strong>pages</strong> are added, the tail iovec is instantiated pointing to
end of the head buffer, and the stream is set up to encode subsequent
items into the tail.</p>
</div>
<dl class="function">
<dt id="c.xdr_init_decode">
void <code class="sig-name descname">xdr_init_decode</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, struct xdr_buf<em> *buf</em>, __be32<em> *p</em>, struct rpc_rqst<em> *rqst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_init_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an xdr_stream for decoding data.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*buf</span></code></dt><dd><p>pointer to XDR buffer from which to decode data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">*p</span></code></dt><dd><p>current pointer inside XDR buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*rqst</span></code></dt><dd><p>pointer to controlling rpc_rqst, for debugging</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xdr_init_decode_pages">
void <code class="sig-name descname">xdr_init_decode_pages</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, struct xdr_buf<em> *buf</em>, struct page<em> **pages</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_init_decode_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an xdr_stream for decoding into pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*buf</span></code></dt><dd><p>pointer to XDR buffer from which to decode data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>list of pages to decode into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length in bytes of buffer in pages</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xdr_inline_decode">
__be32 * <code class="sig-name descname">xdr_inline_decode</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, size_t<em> nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_inline_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve XDR data to decode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">nbytes</span></code></dt><dd><p>number of bytes of data to decode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the input buffer is long enough to enable us to decode
‘nbytes’ more bytes of data starting at the current position.
If so return the current pointer, then update the current
pointer position.</p>
</div>
<dl class="function">
<dt id="c.xdr_read_pages">
unsigned int <code class="sig-name descname">xdr_read_pages</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_read_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>align page-based XDR data to current pointer position</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes of page data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Moves data beyond the current pointer position from the XDR head[] buffer
into the page list. Any data that lies beyond current position + <strong>len</strong>
bytes is moved into the XDR tail[]. The xdr_stream current position is
then advanced past that data to align to the next XDR object in the tail.</p>
<p>Returns the number of XDR encoded bytes now contained in the pages</p>
</div>
<dl class="function">
<dt id="c.xdr_set_pagelen">
void <code class="sig-name descname">xdr_set_pagelen</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_set_pagelen" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the length of the XDR pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>new length of the XDR page data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Either grows or shrinks the length of the xdr pages by setting pagelen to
<strong>len</strong> bytes. When shrinking, any extra data is moved into buf-&gt;tail, whereas
when growing any data beyond the current pointer is moved into the tail.</p>
<p>Returns True if the operation was successful, and False otherwise.</p>
</div>
<dl class="function">
<dt id="c.xdr_enter_page">
void <code class="sig-name descname">xdr_enter_page</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_enter_page" title="Permalink to this definition">¶</a></dt>
<dd><p>decode data from the XDR page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes of page data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Moves data beyond the current pointer position from the XDR head[] buffer
into the page list. Any data that lies beyond current position + “len”
bytes is moved into the XDR tail[]. The current pointer is then
repositioned at the beginning of the first XDR page.</p>
</div>
<dl class="function">
<dt id="c.xdr_buf_subsegment">
int <code class="sig-name descname">xdr_buf_subsegment</code><span class="sig-paren">(</span>const struct xdr_buf<em> *buf</em>, struct xdr_buf<em> *subbuf</em>, unsigned int<em> base</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_buf_subsegment" title="Permalink to this definition">¶</a></dt>
<dd><p>set subbuf to a portion of buf</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*buf</span></code></dt><dd><p>an xdr buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*subbuf</span></code></dt><dd><p>the result buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>beginning of range in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>length of range in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>sets <strong>subbuf</strong> to an xdr buffer representing the portion of <strong>buf</strong> of
length <strong>len</strong> starting at offset <strong>base</strong>.</p>
<p><strong>buf</strong> and <strong>subbuf</strong> may be pointers to the same struct xdr_buf.</p>
<p>Returns -1 if base or length are out of bounds.</p>
</div>
<dl class="function">
<dt id="c.xdr_stream_subsegment">
bool <code class="sig-name descname">xdr_stream_subsegment</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, struct xdr_buf<em> *subbuf</em>, unsigned int<em> nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_subsegment" title="Permalink to this definition">¶</a></dt>
<dd><p>set <strong>subbuf</strong> to a portion of <strong>xdr</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>an xdr_stream set up for decoding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*subbuf</span></code></dt><dd><p>the result buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt><dd><p>length of <strong>xdr</strong> to extract, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up <strong>subbuf</strong> to represent a portion of <strong>xdr</strong>. The portion
starts at the current offset in <strong>xdr</strong>, and extends for a length
of <strong>nbytes</strong>. If this is successful, <strong>xdr</strong> is advanced to the next
XDR data item following that portion.</p>
<dl class="simple">
<dt>Return values:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">true</span></code>: <strong>subbuf</strong> has been initialized, and <strong>xdr</strong> has been advanced.
<code class="docutils literal notranslate"><span class="pre">false</span></code>: a bounds error has occurred</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xdr_stream_move_subsegment">
unsigned int <code class="sig-name descname">xdr_stream_move_subsegment</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, unsigned int<em> offset</em>, unsigned int<em> target</em>, unsigned int<em> length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_move_subsegment" title="Permalink to this definition">¶</a></dt>
<dd><p>Move part of a stream to another position</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>the source xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>the source offset of the segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">target</span></code></dt><dd><p>the target offset of the segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">length</span></code></dt><dd><p>the number of bytes to move</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Moves <strong>length</strong> bytes from <strong>offset</strong> to <strong>target</strong> in the xdr_stream, overwriting
anything in its space. Returns the number of bytes in the segment.</p>
</div>
<dl class="function">
<dt id="c.xdr_stream_zero">
unsigned int <code class="sig-name descname">xdr_stream_zero</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, unsigned int<em> offset</em>, unsigned int<em> length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>zero out a portion of an xdr_stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>an xdr_stream to zero out</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt><dd><p>the starting point in the stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">length</span></code></dt><dd><p>the number of bytes to zero</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xdr_buf_trim">
void <code class="sig-name descname">xdr_buf_trim</code><span class="sig-paren">(</span>struct xdr_buf<em> *buf</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_buf_trim" title="Permalink to this definition">¶</a></dt>
<dd><p>lop at most “len” bytes off the end of “buf”</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*buf</span></code></dt><dd><p>buf to be trimmed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>number of bytes to reduce “buf” by</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Trim an xdr_buf by the given number of bytes by fixing up the lengths. Note
that it’s possible that we’ll trim less than that amount if the xdr_buf is
too small, or if (for instance) it’s all in the head and the parser has
already read too far into it.</p>
</div>
<dl class="function">
<dt id="c.xdr_stream_decode_opaque">
ssize_t <code class="sig-name descname">xdr_stream_decode_opaque</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, void<em> *ptr</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_decode_opaque" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode variable length opaque</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ptr</span></code></dt><dd><p>location to store opaque data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of storage buffer <strong>ptr</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return values:</dt><dd><p>On success, returns size of object stored in <strong>*ptr</strong>
<code class="docutils literal notranslate"><span class="pre">-EBADMSG</span></code> on XDR buffer overflow
<code class="docutils literal notranslate"><span class="pre">-EMSGSIZE</span></code> on overflow of storage buffer <strong>ptr</strong></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xdr_stream_decode_opaque_dup">
ssize_t <code class="sig-name descname">xdr_stream_decode_opaque_dup</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, void<em> **ptr</em>, size_t<em> maxlen</em>, gfp_t<em> gfp_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_decode_opaque_dup" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode and duplicate variable length opaque</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">**ptr</span></code></dt><dd><p>location to store pointer to opaque data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">maxlen</span></code></dt><dd><p>maximum acceptable object size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_flags</span></code></dt><dd><p>GFP mask to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return values:</dt><dd><p>On success, returns size of object stored in <strong>*ptr</strong>
<code class="docutils literal notranslate"><span class="pre">-EBADMSG</span></code> on XDR buffer overflow
<code class="docutils literal notranslate"><span class="pre">-EMSGSIZE</span></code> if the size of the object would exceed <strong>maxlen</strong>
<code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> on memory allocation failure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xdr_stream_decode_string">
ssize_t <code class="sig-name descname">xdr_stream_decode_string</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, char<em> *str</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_decode_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode variable length string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*str</span></code></dt><dd><p>location to store string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>size of storage buffer <strong>str</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return values:</dt><dd><p>On success, returns length of NUL-terminated string stored in <strong>*str</strong>
<code class="docutils literal notranslate"><span class="pre">-EBADMSG</span></code> on XDR buffer overflow
<code class="docutils literal notranslate"><span class="pre">-EMSGSIZE</span></code> on overflow of storage buffer <strong>str</strong></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xdr_stream_decode_string_dup">
ssize_t <code class="sig-name descname">xdr_stream_decode_string_dup</code><span class="sig-paren">(</span>struct xdr_stream<em> *xdr</em>, char<em> **str</em>, size_t<em> maxlen</em>, gfp_t<em> gfp_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_decode_string_dup" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode and duplicate variable length string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*xdr</span></code></dt><dd><p>pointer to xdr_stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**str</span></code></dt><dd><p>location to store pointer to string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">maxlen</span></code></dt><dd><p>maximum acceptable string length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_flags</span></code></dt><dd><p>GFP mask to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return values:</dt><dd><p>On success, returns length of NUL-terminated string stored in <strong>*ptr</strong>
<code class="docutils literal notranslate"><span class="pre">-EBADMSG</span></code> on XDR buffer overflow
<code class="docutils literal notranslate"><span class="pre">-EMSGSIZE</span></code> if the size of the string would exceed <strong>maxlen</strong>
<code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> on memory allocation failure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.svc_xprt_deferred_close">
void <code class="sig-name descname">svc_xprt_deferred_close</code><span class="sig-paren">(</span>struct svc_xprt<em> *xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_xprt_deferred_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a transport</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used in contexts that need to defer the work of shutting down
the transport to an nfsd thread.</p>
</div>
<dl class="function">
<dt id="c.svc_xprt_received">
void <code class="sig-name descname">svc_xprt_received</code><span class="sig-paren">(</span>struct svc_xprt<em> *xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_xprt_received" title="Permalink to this definition">¶</a></dt>
<dd><p>start next receiver thread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>controlling transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold the XPT_BUSY bit and must
not thereafter touch transport data.</p>
<p><strong>Note</strong></p>
<p>XPT_DATA only gets cleared when a read-attempt finds no (or
insufficient) data.</p>
</div>
<dl class="function">
<dt id="c.svc_xprt_create">
int <code class="sig-name descname">svc_xprt_create</code><span class="sig-paren">(</span>struct svc_serv<em> *serv</em>, const char<em> *xprt_name</em>, struct net<em> *net</em>, const int<em> family</em>, const unsigned short<em> port</em>, int<em> flags</em>, const struct cred<em> *cred</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_xprt_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new listener to <strong>serv</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_serv</span> <span class="pre">*serv</span></code></dt><dd><p>target RPC service</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*xprt_name</span></code></dt><dd><p>transport class name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>network namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">family</span></code></dt><dd><p>network address family</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">port</span></code></dt><dd><p>listener port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>SVC_SOCK flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*cred</span></code></dt><dd><p>credential to bind to this transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Return values:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">0</span></code>: New listener added successfully
<code class="docutils literal notranslate"><span class="pre">-EPROTONOSUPPORT</span></code>: Requested transport type not supported</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.svc_print_addr">
char * <code class="sig-name descname">svc_print_addr</code><span class="sig-paren">(</span>struct svc_rqst<em> *rqstp</em>, char<em> *buf</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_print_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Format rq_addr field for printing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_rqst</span> <span class="pre">*rqstp</span></code></dt><dd><p>svc_rqst struct containing address to print</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>target buffer for formatted address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>length of target buffer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.svc_xprt_enqueue">
void <code class="sig-name descname">svc_xprt_enqueue</code><span class="sig-paren">(</span>struct svc_xprt<em> *xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_xprt_enqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a transport on an idle nfsd thread</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport with data pending</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.svc_reserve">
void <code class="sig-name descname">svc_reserve</code><span class="sig-paren">(</span>struct svc_rqst<em> *rqstp</em>, int<em> space</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>change the space reserved for the reply to a request.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_rqst</span> <span class="pre">*rqstp</span></code></dt><dd><p>The request in question</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">space</span></code></dt><dd><p>new max space to reserve</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each request reserves some space on the output queue of the transport
to make sure the reply fits.  This function reduces that reserved
space to be the amount of space used already, plus <strong>space</strong>.</p>
</div>
<dl class="function">
<dt id="c.svc_xprt_close">
void <code class="sig-name descname">svc_xprt_close</code><span class="sig-paren">(</span>struct svc_xprt<em> *xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_xprt_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a client connection</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport to disconnect</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.svc_xprt_destroy_all">
void <code class="sig-name descname">svc_xprt_destroy_all</code><span class="sig-paren">(</span>struct svc_serv<em> *serv</em>, struct net<em> *net</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_xprt_destroy_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroy transports associated with <strong>serv</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_serv</span> <span class="pre">*serv</span></code></dt><dd><p>RPC service to be shut down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>target network namespace</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Server threads may still be running (especially in the case where the
service is still running in other network namespaces).</p>
<p>So we shut down sockets the same way we would on a running server, by
setting XPT_CLOSE, enqueuing, and letting a thread pick it up to do
the close.  In the case there are no such other threads,
threads running, svc_clean_up_xprts() does a simple version of a
server’s main event loop, and in the case where there are other
threads, we may need to wait a little while and then check again to
see if they’re done.</p>
</div>
<dl class="function">
<dt id="c.svc_find_xprt">
struct svc_xprt * <code class="sig-name descname">svc_find_xprt</code><span class="sig-paren">(</span>struct svc_serv<em> *serv</em>, const char<em> *xcl_name</em>, struct net<em> *net</em>, const sa_family_t<em> af</em>, const unsigned short<em> port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_find_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>find an RPC transport instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_serv</span> <span class="pre">*serv</span></code></dt><dd><p>pointer to svc_serv to search</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*xcl_name</span></code></dt><dd><p>C string containing transport’s class name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>owner net pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">sa_family_t</span> <span class="pre">af</span></code></dt><dd><p>Address family of transport’s local address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">port</span></code></dt><dd><p>transport’s IP port number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the transport instance pointer for the endpoint accepting
connections/peer traffic from the specified transport class,
address family and port.</p>
<p>Specifying 0 for the address family or port is effectively a
wild-card, and will result in matching the first transport in the
service’s list that has a matching class name.</p>
</div>
<dl class="function">
<dt id="c.svc_xprt_names">
int <code class="sig-name descname">svc_xprt_names</code><span class="sig-paren">(</span>struct svc_serv<em> *serv</em>, char<em> *buf</em>, const int<em> buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_xprt_names" title="Permalink to this definition">¶</a></dt>
<dd><p>format a buffer with a list of transport names</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">svc_serv</span> <span class="pre">*serv</span></code></dt><dd><p>pointer to an RPC service</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>pointer to a buffer to be filled in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt><dd><p>length of buffer to be filled in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fills in <strong>buf</strong> with a string containing a list of transport names,
each name terminated with ‘n’.</p>
<p>Returns positive length of the filled-in string on success; otherwise
a negative errno value is returned if an error occurs.</p>
</div>
<dl class="function">
<dt id="c.xprt_register_transport">
int <code class="sig-name descname">xprt_register_transport</code><span class="sig-paren">(</span>struct xprt_class<em> *transport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_register_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>register a transport implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xprt_class</span> <span class="pre">*transport</span></code></dt><dd><p>transport to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a transport implementation is loaded as a kernel module, it can
call this interface to make itself known to the RPC client.</p>
<p><strong>Return</strong></p>
<p>0:           transport successfully registered
-EEXIST:     transport already registered
-EINVAL:     transport module being unloaded</p>
</div>
<dl class="function">
<dt id="c.xprt_unregister_transport">
int <code class="sig-name descname">xprt_unregister_transport</code><span class="sig-paren">(</span>struct xprt_class<em> *transport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_unregister_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a transport implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xprt_class</span> <span class="pre">*transport</span></code></dt><dd><p>transport to unregister</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0:           transport successfully unregistered
-ENOENT:     transport never registered</p>
</div>
<dl class="function">
<dt id="c.xprt_find_transport_ident">
int <code class="sig-name descname">xprt_find_transport_ident</code><span class="sig-paren">(</span>const char<em> *netid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_find_transport_ident" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a netid into a transport identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*netid</span></code></dt><dd><p>transport to load</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>&gt; 0:         transport identifier
-ENOENT:     transport module not available</p>
</div>
<dl class="function">
<dt id="c.xprt_reserve_xprt">
int <code class="sig-name descname">xprt_reserve_xprt</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em>, struct rpc_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_reserve_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>serialize write access to transports</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>pointer to the target transport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>task that is requesting access to the transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prevents mixing the payload of separate requests, and prevents
transport connects from colliding with writes.  No congestion control
is provided.</p>
</div>
<dl class="function">
<dt id="c.xprt_release_xprt">
void <code class="sig-name descname">xprt_release_xprt</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em>, struct rpc_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_release_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>allow other requests to use a transport</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport with other tasks potentially waiting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>task that is releasing access to the transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that “task” can be NULL.  No congestion control is provided.</p>
</div>
<dl class="function">
<dt id="c.xprt_release_xprt_cong">
void <code class="sig-name descname">xprt_release_xprt_cong</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em>, struct rpc_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_release_xprt_cong" title="Permalink to this definition">¶</a></dt>
<dd><p>allow other requests to use a transport</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport with other tasks potentially waiting</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>task that is releasing access to the transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that “task” can be NULL.  Another task is awoken to use the
transport if the transport’s congestion window allows it.</p>
</div>
<dl class="function">
<dt id="c.xprt_request_get_cong">
bool <code class="sig-name descname">xprt_request_get_cong</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em>, struct rpc_rqst<em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_request_get_cong" title="Permalink to this definition">¶</a></dt>
<dd><p>Request congestion control credits</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>pointer to transport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*req</span></code></dt><dd><p>pointer to RPC request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Useful for transports that require congestion control.</p>
</div>
<dl class="function">
<dt id="c.xprt_release_rqst_cong">
void <code class="sig-name descname">xprt_release_rqst_cong</code><span class="sig-paren">(</span>struct rpc_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_release_rqst_cong" title="Permalink to this definition">¶</a></dt>
<dd><p>housekeeping when request is complete</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>RPC request that recently completed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Useful for transports that require congestion control.</p>
</div>
<dl class="function">
<dt id="c.xprt_adjust_cwnd">
void <code class="sig-name descname">xprt_adjust_cwnd</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em>, struct rpc_task<em> *task</em>, int<em> result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_adjust_cwnd" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust transport congestion window</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>pointer to xprt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>recently completed RPC request used to adjust window</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">result</span></code></dt><dd><p>result code of completed RPC request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The transport code maintains an estimate on the maximum number of out-
standing RPC requests, using a smoothed version of the congestion
avoidance implemented in 44BSD. This is basically the Van Jacobson
congestion algorithm: If a retransmit occurs, the congestion window is
halved; otherwise, it is incremented by 1/cwnd when</p>
<blockquote>
<div><ul class="simple">
<li><p>a reply is received and</p></li>
<li><p>a full number of requests are outstanding and</p></li>
<li><p>the congestion window hasn’t been updated recently.</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.xprt_wake_pending_tasks">
void <code class="sig-name descname">xprt_wake_pending_tasks</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em>, int<em> status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_wake_pending_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>wake all tasks on a transport’s pending queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport with waiting tasks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt><dd><p>result code to plant in each task before waking it</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xprt_wait_for_buffer_space">
void <code class="sig-name descname">xprt_wait_for_buffer_space</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_wait_for_buffer_space" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for transport output buffer to clear</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that we only set the timer for the case of RPC_IS_SOFT(), since
we don’t in general want to force a socket disconnection due to
an incomplete RPC call transmission.</p>
</div>
<dl class="function">
<dt id="c.xprt_write_space">
bool <code class="sig-name descname">xprt_write_space</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_write_space" title="Permalink to this definition">¶</a></dt>
<dd><p>wake the task waiting for transport output buffer space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport with waiting tasks</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Can be called in a soft IRQ context, so xprt_write_space never sleeps.</p>
</div>
<dl class="function">
<dt id="c.xprt_disconnect_done">
void <code class="sig-name descname">xprt_disconnect_done</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_disconnect_done" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a transport as disconnected</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport to flag for disconnect</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xprt_force_disconnect">
void <code class="sig-name descname">xprt_force_disconnect</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_force_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>force a transport to disconnect</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport to disconnect</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xprt_reconnect_delay">
unsigned long <code class="sig-name descname">xprt_reconnect_delay</code><span class="sig-paren">(</span>const struct rpc_xprt<em> *xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_reconnect_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the wait before scheduling a connect</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport instance</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xprt_reconnect_backoff">
void <code class="sig-name descname">xprt_reconnect_backoff</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em>, unsigned long<em> init_to</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_reconnect_backoff" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the new re-establish timeout</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">init_to</span></code></dt><dd><p>initial reestablish timeout</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xprt_lookup_rqst">
struct rpc_rqst * <code class="sig-name descname">xprt_lookup_rqst</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em>, __be32<em> xid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_lookup_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>find an RPC request corresponding to an XID</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>transport on which the original request was transmitted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be32</span> <span class="pre">xid</span></code></dt><dd><p>RPC XID of incoming reply</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller holds xprt-&gt;queue_lock.</p>
</div>
<dl class="function">
<dt id="c.xprt_pin_rqst">
void <code class="sig-name descname">xprt_pin_rqst</code><span class="sig-paren">(</span>struct rpc_rqst<em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_pin_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>Pin a request on the transport receive list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*req</span></code></dt><dd><p>Request to pin</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must ensure this is atomic with the call to <a class="reference internal" href="#c.xprt_lookup_rqst" title="xprt_lookup_rqst"><code class="xref c c-func docutils literal notranslate"><span class="pre">xprt_lookup_rqst()</span></code></a>
so should be holding xprt-&gt;queue_lock.</p>
</div>
<dl class="function">
<dt id="c.xprt_unpin_rqst">
void <code class="sig-name descname">xprt_unpin_rqst</code><span class="sig-paren">(</span>struct rpc_rqst<em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_unpin_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpin a request on the transport receive list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*req</span></code></dt><dd><p>Request to pin</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller should be holding xprt-&gt;queue_lock.</p>
</div>
<dl class="function">
<dt id="c.xprt_update_rtt">
void <code class="sig-name descname">xprt_update_rtt</code><span class="sig-paren">(</span>struct rpc_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_update_rtt" title="Permalink to this definition">¶</a></dt>
<dd><p>Update RPC RTT statistics</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>RPC request that recently completed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller holds xprt-&gt;queue_lock.</p>
</div>
<dl class="function">
<dt id="c.xprt_complete_rqst">
void <code class="sig-name descname">xprt_complete_rqst</code><span class="sig-paren">(</span>struct rpc_task<em> *task</em>, int<em> copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_complete_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>called when reply processing is complete</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>RPC request that recently completed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">copied</span></code></dt><dd><p>actual number of bytes received from the transport</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller holds xprt-&gt;queue_lock.</p>
</div>
<dl class="function">
<dt id="c.xprt_wait_for_reply_request_def">
void <code class="sig-name descname">xprt_wait_for_reply_request_def</code><span class="sig-paren">(</span>struct rpc_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_wait_for_reply_request_def" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for reply</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>pointer to rpc_task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a request’s retransmit timeout based on the transport’s
default timeout parameters.  Used by transports that don’t adjust
the retransmit timeout based on round-trip time estimation,
and put the task to sleep on the pending queue.</p>
</div>
<dl class="function">
<dt id="c.xprt_wait_for_reply_request_rtt">
void <code class="sig-name descname">xprt_wait_for_reply_request_rtt</code><span class="sig-paren">(</span>struct rpc_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_wait_for_reply_request_rtt" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for reply using RTT estimator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>pointer to rpc_task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a request’s retransmit timeout using the RTT estimator,
and put the task to sleep on the pending queue.</p>
</div>
<dl class="function">
<dt id="c.xprt_get">
struct rpc_xprt * <code class="sig-name descname">xprt_get</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_get" title="Permalink to this definition">¶</a></dt>
<dd><p>return a reference to an RPC transport.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>pointer to the transport</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.xprt_put">
void <code class="sig-name descname">xprt_put</code><span class="sig-paren">(</span>struct rpc_xprt<em> *xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to an RPC transport.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>pointer to the transport</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_wake_up">
void <code class="sig-name descname">rpc_wake_up</code><span class="sig-paren">(</span>struct rpc_wait_queue<em> *queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_wake_up" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up all rpc_tasks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_wait_queue</span> <span class="pre">*queue</span></code></dt><dd><p>rpc_wait_queue on which the tasks are sleeping</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grabs queue-&gt;lock</p>
</div>
<dl class="function">
<dt id="c.rpc_wake_up_status">
void <code class="sig-name descname">rpc_wake_up_status</code><span class="sig-paren">(</span>struct rpc_wait_queue<em> *queue</em>, int<em> status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_wake_up_status" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up all rpc_tasks and set their status value.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_wait_queue</span> <span class="pre">*queue</span></code></dt><dd><p>rpc_wait_queue on which the tasks are sleeping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt><dd><p>status value to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grabs queue-&gt;lock</p>
</div>
<dl class="function">
<dt id="c.rpc_malloc">
int <code class="sig-name descname">rpc_malloc</code><span class="sig-paren">(</span>struct rpc_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate RPC buffer resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>RPC task</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A single memory region is allocated, which is split between the
RPC call and RPC reply that this task is being used for. When
this RPC is retired, the memory is released by calling rpc_free.</p>
<p>To prevent rpciod from hanging, this allocator never sleeps,
returning -ENOMEM and suppressing warning if the request cannot
be serviced immediately. The caller can arrange to sleep in a
way that is safe for rpciod.</p>
<p>Most requests are ‘small’ (under 2KiB) and can be serviced from a
mempool, ensuring that NFS reads and writes can always proceed,
and that there is good locality of reference for these buffers.</p>
</div>
<dl class="function">
<dt id="c.rpc_free">
void <code class="sig-name descname">rpc_free</code><span class="sig-paren">(</span>struct rpc_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free RPC buffer resources allocated via rpc_malloc</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>RPC task</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.csum_partial_copy_to_xdr">
int <code class="sig-name descname">csum_partial_copy_to_xdr</code><span class="sig-paren">(</span>struct xdr_buf<em> *xdr</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.csum_partial_copy_to_xdr" title="Permalink to this definition">¶</a></dt>
<dd><p>checksum and copy data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*xdr</span></code></dt><dd><p>target XDR buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>source skb</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>We have set things up such that we perform the checksum of the UDP
packet in parallel with the copies into the RPC client iovec.  -DaveM</p>
</div>
<dl class="function">
<dt id="c.rpc_alloc_iostats">
struct rpc_iostats * <code class="sig-name descname">rpc_alloc_iostats</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_alloc_iostats" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an rpc_iostats structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>RPC program, version, and xprt</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_free_iostats">
void <code class="sig-name descname">rpc_free_iostats</code><span class="sig-paren">(</span>struct rpc_iostats<em> *stats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_free_iostats" title="Permalink to this definition">¶</a></dt>
<dd><p>release an rpc_iostats structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_iostats</span> <span class="pre">*stats</span></code></dt><dd><p>doomed rpc_iostats structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_count_iostats_metrics">
void <code class="sig-name descname">rpc_count_iostats_metrics</code><span class="sig-paren">(</span>const struct rpc_task<em> *task</em>, struct rpc_iostats<em> *op_metrics</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_count_iostats_metrics" title="Permalink to this definition">¶</a></dt>
<dd><p>tally up per-task stats</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>completed rpc_task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_iostats</span> <span class="pre">*op_metrics</span></code></dt><dd><p>stat structure for OP that will accumulate stats from <strong>task</strong></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_count_iostats">
void <code class="sig-name descname">rpc_count_iostats</code><span class="sig-paren">(</span>const struct rpc_task<em> *task</em>, struct rpc_iostats<em> *stats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_count_iostats" title="Permalink to this definition">¶</a></dt>
<dd><p>tally up per-task stats</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>completed rpc_task</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_iostats</span> <span class="pre">*stats</span></code></dt><dd><p>array of stat structures</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses the statidx from <strong>task</strong></p>
</div>
<dl class="function">
<dt id="c.rpc_queue_upcall">
int <code class="sig-name descname">rpc_queue_upcall</code><span class="sig-paren">(</span>struct rpc_pipe<em> *pipe</em>, struct rpc_pipe_msg<em> *msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_queue_upcall" title="Permalink to this definition">¶</a></dt>
<dd><p>queue an upcall message to userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p>upcall pipe on which to queue given message</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_msg</span> <span class="pre">*msg</span></code></dt><dd><p>message to queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call with an <strong>inode</strong> created by rpc_mkpipe() to queue an upcall.
A userspace process may then later read the upcall by performing a
read on an open file for this inode.  It is up to the caller to
initialize the fields of <strong>msg</strong> (other than <strong>msg-&gt;list</strong>) appropriately.</p>
</div>
<dl class="function">
<dt id="c.rpc_mkpipe_dentry">
struct dentry * <code class="sig-name descname">rpc_mkpipe_dentry</code><span class="sig-paren">(</span>struct dentry<em> *parent</em>, const char<em> *name</em>, void<em> *private</em>, struct rpc_pipe<em> *pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_mkpipe_dentry" title="Permalink to this definition">¶</a></dt>
<dd><p>make an rpc_pipefs file for kernel&lt;-&gt;userspace communication</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*parent</span></code></dt><dd><p>dentry of directory to create new “pipe” in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name of pipe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*private</span></code></dt><dd><p>private data to associate with the pipe, for the caller’s use</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe</span> <span class="pre">*pipe</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">rpc_pipe</span></code> containing input parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Data is made available for userspace to read by calls to
<a class="reference internal" href="#c.rpc_queue_upcall" title="rpc_queue_upcall"><code class="xref c c-func docutils literal notranslate"><span class="pre">rpc_queue_upcall()</span></code></a>.  The actual reads will result in calls to
<strong>ops-&gt;upcall</strong>, which will be called with the file pointer,
message, and userspace buffer to copy to.</p>
<p>Writes can come at any time, and do not necessarily have to be
responses to upcalls.  They will result in calls to <strong>msg-&gt;downcall</strong>.</p>
<p>The <strong>private</strong> argument passed here will be available to all these methods
from the file pointer, via RPC_I(file_inode(file))-&gt;private.</p>
</div>
<dl class="function">
<dt id="c.rpc_unlink">
int <code class="sig-name descname">rpc_unlink</code><span class="sig-paren">(</span>struct dentry<em> *dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a pipe</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*dentry</span></code></dt><dd><p>dentry for the pipe, as returned from rpc_mkpipe</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this call, lookups will no longer find the pipe, and any
attempts to read or write using preexisting opens of the pipe will
return -EPIPE.</p>
</div>
<dl class="function">
<dt id="c.rpc_init_pipe_dir_head">
void <code class="sig-name descname">rpc_init_pipe_dir_head</code><span class="sig-paren">(</span>struct rpc_pipe_dir_head<em> *pdh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_init_pipe_dir_head" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a struct rpc_pipe_dir_head</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*pdh</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_head</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_init_pipe_dir_object">
void <code class="sig-name descname">rpc_init_pipe_dir_object</code><span class="sig-paren">(</span>struct rpc_pipe_dir_object<em> *pdo</em>, const struct rpc_pipe_dir_object_ops<em> *pdo_ops</em>, void<em> *pdo_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_init_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a struct rpc_pipe_dir_object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*pdo</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object_ops</span> <span class="pre">*pdo_ops</span></code></dt><dd><p>pointer to const struct rpc_pipe_dir_object_ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*pdo_data</span></code></dt><dd><p>pointer to caller-defined data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_add_pipe_dir_object">
int <code class="sig-name descname">rpc_add_pipe_dir_object</code><span class="sig-paren">(</span>struct net<em> *net</em>, struct rpc_pipe_dir_head<em> *pdh</em>, struct rpc_pipe_dir_object<em> *pdo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_add_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd><p>associate a rpc_pipe_dir_object to a directory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>pointer to struct net</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*pdh</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*pdo</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_object</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_remove_pipe_dir_object">
void <code class="sig-name descname">rpc_remove_pipe_dir_object</code><span class="sig-paren">(</span>struct net<em> *net</em>, struct rpc_pipe_dir_head<em> *pdh</em>, struct rpc_pipe_dir_object<em> *pdo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_remove_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a rpc_pipe_dir_object from a directory</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>pointer to struct net</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*pdh</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*pdo</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_object</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_find_or_alloc_pipe_dir_object">
struct rpc_pipe_dir_object * <code class="sig-name descname">rpc_find_or_alloc_pipe_dir_object</code><span class="sig-paren">(</span>struct net<em> *net</em>, struct rpc_pipe_dir_head<em> *pdh</em>, int (<em>*match</em>)(struct rpc_pipe_dir_object *, void *), struct rpc_pipe_dir_object *(*alloc)(void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_find_or_alloc_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>pointer to struct net</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*pdh</span></code></dt><dd><p>pointer to struct rpc_pipe_dir_head</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*match)(struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>match struct rpc_pipe_dir_object to data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*(*alloc)(void</span> <span class="pre">*)</span></code></dt><dd><p>allocate a new struct rpc_pipe_dir_object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>user defined data for match() and alloc()</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpcb_getport_async">
void <code class="sig-name descname">rpcb_getport_async</code><span class="sig-paren">(</span>struct rpc_task<em> *task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpcb_getport_async" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the port for a given RPC service on a given host</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*task</span></code></dt><dd><p>task that is waiting for portmapper request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This one can be called for an ongoing RPC request, and can be used in
an async (rpciod) context.</p>
</div>
<dl class="function">
<dt id="c.rpc_create">
struct rpc_clnt * <code class="sig-name descname">rpc_create</code><span class="sig-paren">(</span>struct rpc_create_args<em> *args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create an RPC client and transport with one call</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_create_args</span> <span class="pre">*args</span></code></dt><dd><p>rpc_clnt create argument structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates and initializes an RPC transport and an RPC client.</p>
<p>It can ping the server in order to determine if it is up, and to see if
it supports this program and version.  RPC_CLNT_CREATE_NOPING disables
this behavior so asynchronous tasks can also use rpc_create.</p>
</div>
<dl class="function">
<dt id="c.rpc_clone_client">
struct rpc_clnt * <code class="sig-name descname">rpc_clone_client</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clone_client" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone an RPC client structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>RPC client whose parameters are copied</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a fresh RPC client or an ERR_PTR.</p>
</div>
<dl class="function">
<dt id="c.rpc_clone_client_set_auth">
struct rpc_clnt * <code class="sig-name descname">rpc_clone_client_set_auth</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, rpc_authflavor_t<em> flavor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clone_client_set_auth" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone an RPC client structure and set its auth</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>RPC client whose parameters are copied</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rpc_authflavor_t</span> <span class="pre">flavor</span></code></dt><dd><p>security flavor for new client</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a fresh RPC client or an ERR_PTR.</p>
</div>
<dl class="function">
<dt id="c.rpc_switch_client_transport">
int <code class="sig-name descname">rpc_switch_client_transport</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, struct xprt_create<em> *args</em>, const struct rpc_timeout<em> *timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_switch_client_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>switch the RPC transport on the fly</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>pointer to a struct rpc_clnt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xprt_create</span> <span class="pre">*args</span></code></dt><dd><p>pointer to the new transport arguments</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_timeout</span> <span class="pre">*timeout</span></code></dt><dd><p>pointer to the new timeout parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows the caller to switch the RPC transport for the
rpc_clnt structure ‘clnt’ to allow it to connect to a mirrored NFS
server, for instance.  It assumes that the caller has ensured that
there are no active RPC tasks by using some form of locking.</p>
<p>Returns zero if “clnt” is now using the new xprt.  Otherwise a
negative errno is returned, and “clnt” continues to use the old
xprt.</p>
</div>
<dl class="function">
<dt id="c.rpc_clnt_iterate_for_each_xprt">
int <code class="sig-name descname">rpc_clnt_iterate_for_each_xprt</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, int (<em>*fn</em>)(struct rpc_clnt *, struct rpc_xprt *, void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_iterate_for_each_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to all transports</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>pointer to client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*fn)(struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>function to apply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>void pointer to function data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of RPC transports currently attached to the
client and applies the function fn(clnt, xprt, data).</p>
<p>On error, the iteration stops, and the function returns the error value.</p>
</div>
<dl class="function">
<dt id="c.rpc_cancel_tasks">
unsigned long <code class="sig-name descname">rpc_cancel_tasks</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, int<em> error</em>, bool (<em>*fnmatch</em>)(const struct rpc_task *, const void *), const void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_cancel_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>try to cancel a set of RPC tasks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>Pointer to RPC client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">error</span></code></dt><dd><p>RPC task error value to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">(*fnmatch)(const</span> <span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>Pointer to selector function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>User data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses <strong>fnmatch</strong> to define a set of RPC tasks that are to be cancelled.
The argument <strong>error</strong> must be a negative error value.</p>
</div>
<dl class="function">
<dt id="c.rpc_bind_new_program">
struct rpc_clnt * <code class="sig-name descname">rpc_bind_new_program</code><span class="sig-paren">(</span>struct rpc_clnt<em> *old</em>, const struct rpc_program<em> *program</em>, u32<em> vers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_bind_new_program" title="Permalink to this definition">¶</a></dt>
<dd><p>bind a new RPC program to an existing client</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*old</span></code></dt><dd><p>old rpc_client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_program</span> <span class="pre">*program</span></code></dt><dd><p>rpc program to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">vers</span></code></dt><dd><p>rpc program version</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clones the rpc client and sets up a new RPC program. This is mainly
of use for enabling different RPC programs to share the same transport.
The Sun NFSv2/v3 ACL protocol can do this.</p>
</div>
<dl class="function">
<dt id="c.rpc_run_task">
struct rpc_task * <code class="sig-name descname">rpc_run_task</code><span class="sig-paren">(</span>const struct rpc_task_setup<em> *task_setup_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_run_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a new RPC task, then run rpc_execute against it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_task_setup</span> <span class="pre">*task_setup_data</span></code></dt><dd><p>pointer to task initialisation data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_call_sync">
int <code class="sig-name descname">rpc_call_sync</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, const struct rpc_message<em> *msg</em>, int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_call_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a synchronous RPC call</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>pointer to RPC client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_message</span> <span class="pre">*msg</span></code></dt><dd><p>RPC call parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>RPC call flags</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_call_async">
int <code class="sig-name descname">rpc_call_async</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, const struct rpc_message<em> *msg</em>, int<em> flags</em>, const struct rpc_call_ops<em> *tk_ops</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_call_async" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an asynchronous RPC call</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>pointer to RPC client</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_message</span> <span class="pre">*msg</span></code></dt><dd><p>RPC call parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>RPC call flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_call_ops</span> <span class="pre">*tk_ops</span></code></dt><dd><p>RPC call ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>user call data</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_prepare_reply_pages">
void <code class="sig-name descname">rpc_prepare_reply_pages</code><span class="sig-paren">(</span>struct rpc_rqst<em> *req</em>, struct page<em> **pages</em>, unsigned int<em> base</em>, unsigned int<em> len</em>, unsigned int<em> hdrsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_prepare_reply_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare to receive a reply data payload into pages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*req</span></code></dt><dd><p>RPC request to prepare</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**pages</span></code></dt><dd><p>vector of struct page pointers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt><dd><p>offset in first page where receive should start, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>expected size of the upper layer data payload, in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hdrsize</span></code></dt><dd><p>expected size of upper layer reply header, in XDR words</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_peeraddr">
size_t <code class="sig-name descname">rpc_peeraddr</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, struct sockaddr<em> *buf</em>, size_t<em> bufsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_peeraddr" title="Permalink to this definition">¶</a></dt>
<dd><p>extract remote peer address from clnt’s xprt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>RPC client structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*buf</span></code></dt><dd><p>target buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">bufsize</span></code></dt><dd><p>length of target buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes that are actually in the stored address.</p>
</div>
<dl class="function">
<dt id="c.rpc_peeraddr2str">
const char * <code class="sig-name descname">rpc_peeraddr2str</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, enum rpc_display_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_peeraddr2str" title="Permalink to this definition">¶</a></dt>
<dd><p>return remote peer address in printable format</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>RPC client structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">rpc_display_format_t</span> <span class="pre">format</span></code></dt><dd><p>address format</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>NB: the lifetime of the memory referenced by the returned pointer is
the same as the rpc_xprt itself.  As long as the caller uses this
pointer, it must hold the RCU read lock.</p>
</div>
<dl class="function">
<dt id="c.rpc_localaddr">
int <code class="sig-name descname">rpc_localaddr</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, struct sockaddr<em> *buf</em>, size_t<em> buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_localaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>discover local endpoint address for an RPC client</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>RPC client structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*buf</span></code></dt><dd><p>target buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">buflen</span></code></dt><dd><p>size of target buffer, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero and fills in “buf” and “buflen” if successful;
otherwise, a negative errno is returned.</p>
<p>This works even if the underlying transport is not currently connected,
or if the upper layer never previously provided a source address.</p>
<p>The result of this function call is transient: multiple calls in
succession may give different results, depending on how local
networking configuration changes over time.</p>
</div>
<dl class="function">
<dt id="c.rpc_net_ns">
struct net * <code class="sig-name descname">rpc_net_ns</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_net_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the network namespace for this RPC client</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>RPC client to query</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_max_payload">
size_t <code class="sig-name descname">rpc_max_payload</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_max_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Get maximum payload size for a transport, in bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>RPC client to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For stream transports, this is one RPC record fragment (see RFC
1831), as we don’t support multi-record requests yet.  For datagram
transports, this is the size of an IP packet minus the IP, UDP, and
RPC header sizes.</p>
</div>
<dl class="function">
<dt id="c.rpc_max_bc_payload">
size_t <code class="sig-name descname">rpc_max_bc_payload</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_max_bc_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Get maximum backchannel payload size, in bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>RPC client to query</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_force_rebind">
void <code class="sig-name descname">rpc_force_rebind</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_force_rebind" title="Permalink to this definition">¶</a></dt>
<dd><p>force transport to check that remote port is unchanged</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>client to rebind</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_clnt_test_and_add_xprt">
int <code class="sig-name descname">rpc_clnt_test_and_add_xprt</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, struct rpc_xprt_switch<em> *xps</em>, struct rpc_xprt<em> *xprt</em>, void<em> *dummy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_test_and_add_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>Test and add a new transport to a rpc_clnt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>pointer to struct rpc_clnt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt_switch</span> <span class="pre">*xps</span></code></dt><dd><p>pointer to struct rpc_xprt_switch,</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>pointer struct rpc_xprt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dummy</span></code></dt><dd><p>unused</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.rpc_clnt_setup_test_and_add_xprt">
int <code class="sig-name descname">rpc_clnt_setup_test_and_add_xprt</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, struct rpc_xprt_switch<em> *xps</em>, struct rpc_xprt<em> *xprt</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_setup_test_and_add_xprt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>struct rpc_clnt to get the new transport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt_switch</span> <span class="pre">*xps</span></code></dt><dd><p>the rpc_xprt_switch to hold the new transport</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*xprt</span></code></dt><dd><p>the rpc_xprt to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>a struct rpc_add_xprt_test pointer that holds the test function
and test function call data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>This is an rpc_clnt_add_xprt setup() function which returns 1 so:</dt><dd><p>1) caller of the test function must dereference the rpc_xprt_switch
and the rpc_xprt.
2) test function must call rpc_xprt_switch_add_xprt, usually in
the rpc_call_done routine.</p>
</dd>
</dl>
<p>Upon success (return of 1), the test function adds the new
transport to the rpc_clnt xprt switch</p>
</div>
<dl class="function">
<dt id="c.rpc_clnt_add_xprt">
int <code class="sig-name descname">rpc_clnt_add_xprt</code><span class="sig-paren">(</span>struct rpc_clnt<em> *clnt</em>, struct xprt_create<em> *xprtargs</em>, int (<em>*setup</em>)(struct rpc_clnt *, struct rpc_xprt_switch *, struct rpc_xprt *, void *), void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_add_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new transport to a rpc_clnt</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*clnt</span></code></dt><dd><p>pointer to struct rpc_clnt</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xprt_create</span> <span class="pre">*xprtargs</span></code></dt><dd><p>pointer to struct xprt_create</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*setup)(struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">rpc_xprt_switch</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span></code></dt><dd><p>callback to test and/or set up the connection</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>pointer to setup function data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new transport using the parameters set in args and
adds it to clnt.
If ping is set, then test that connectivity succeeds before
adding the new transport.</p>
</div>
</section>
</section>
<section id="network-device-support">
<h2>Network device support<a class="headerlink" href="#network-device-support" title="Permalink to this headline">¶</a></h2>
<section id="driver-support">
<h3>Driver Support<a class="headerlink" href="#driver-support" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.dev_add_pack">
void <code class="sig-name descname">dev_add_pack</code><span class="sig-paren">(</span>struct packet_type<em> *pt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_add_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>add packet handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">packet_type</span> <span class="pre">*pt</span></code></dt><dd><p>packet type declaration</p>
<p>Add a protocol handler to the networking stack. The passed <code class="xref c c-type docutils literal notranslate"><span class="pre">packet_type</span></code>
is linked into kernel lists and may not be freed until it has been
removed from the kernel lists.</p>
<p>This call does not sleep therefore it can not
guarantee all CPU’s that are in middle of receiving packets
will see the new packet type (until the next received packet).</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__dev_remove_pack">
void <code class="sig-name descname">__dev_remove_pack</code><span class="sig-paren">(</span>struct packet_type<em> *pt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_remove_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>remove packet handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">packet_type</span> <span class="pre">*pt</span></code></dt><dd><p>packet type declaration</p>
<p>Remove a protocol handler that was previously added to the kernel
protocol handlers by <a class="reference internal" href="#c.dev_add_pack" title="dev_add_pack"><code class="xref c c-func docutils literal notranslate"><span class="pre">dev_add_pack()</span></code></a>. The passed <code class="xref c c-type docutils literal notranslate"><span class="pre">packet_type</span></code> is removed
from the kernel lists and can be freed or reused once this function
returns.</p>
<p>The packet type might still be in use by receivers
and must not be freed until after all the CPU’s have gone
through a quiescent state.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_remove_pack">
void <code class="sig-name descname">dev_remove_pack</code><span class="sig-paren">(</span>struct packet_type<em> *pt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_remove_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>remove packet handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">packet_type</span> <span class="pre">*pt</span></code></dt><dd><p>packet type declaration</p>
<p>Remove a protocol handler that was previously added to the kernel
protocol handlers by <a class="reference internal" href="#c.dev_add_pack" title="dev_add_pack"><code class="xref c c-func docutils literal notranslate"><span class="pre">dev_add_pack()</span></code></a>. The passed <code class="xref c c-type docutils literal notranslate"><span class="pre">packet_type</span></code> is removed
from the kernel lists and can be freed or reused once this function
returns.</p>
<p>This call sleeps to guarantee that no CPU is looking at the packet
type after return.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_get_iflink">
int <code class="sig-name descname">dev_get_iflink</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_iflink" title="Permalink to this definition">¶</a></dt>
<dd><p>get ‘iflink’ value of a interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>targeted interface</p>
<p>Indicates the ifindex the interface is linked to.
Physical interfaces have the same ‘ifindex’ and ‘iflink’ values.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_fill_metadata_dst">
int <code class="sig-name descname">dev_fill_metadata_dst</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_fill_metadata_dst" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve tunnel egress information.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>targeted interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>The packet.</p>
<p>For better visibility of tunnel traffic OVS needs to retrieve
egress tunnel information for a packet. Following API allows
user to get this info.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__dev_get_by_name">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">__dev_get_by_name</code><span class="sig-paren">(</span>struct net<em> *net</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_get_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name to find</p>
<p>Find an interface by name. Must be called under RTNL semaphore
or <strong>dev_base_lock</strong>. If the name is found a pointer to the device
is returned. If the name is not found then <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned. The
reference counters are not incremented so the caller must be
careful with locks.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_get_by_name_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_get_by_name_rcu</code><span class="sig-paren">(</span>struct net<em> *net</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_name_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name to find</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find an interface by name.
If the name is found a pointer to the device is returned.
If the name is not found then <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned.
The reference counters are not incremented so the caller must be
careful with locks. The caller must hold RCU lock.</p>
</div>
<dl class="function">
<dt id="c.dev_get_by_name">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_get_by_name</code><span class="sig-paren">(</span>struct net<em> *net</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name to find</p>
<p>Find an interface by name. This can be called from any
context and does its own locking. The returned handle has
the usage count incremented and the caller must use <a class="reference internal" href="#c.dev_put" title="dev_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">dev_put()</span></code></a> to
release it when it is no longer needed. <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if no
matching device is found.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__dev_get_by_index">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">__dev_get_by_index</code><span class="sig-paren">(</span>struct net<em> *net</em>, int<em> ifindex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_get_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its ifindex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ifindex</span></code></dt><dd><p>index of device</p>
<p>Search for an interface by index. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the device
is not found or a pointer to the device. The device has not
had its reference counter increased so the caller must be careful
about locking. The caller must hold either the RTNL semaphore
or <strong>dev_base_lock</strong>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_get_by_index_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_get_by_index_rcu</code><span class="sig-paren">(</span>struct net<em> *net</em>, int<em> ifindex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_index_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its ifindex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ifindex</span></code></dt><dd><p>index of device</p>
<p>Search for an interface by index. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the device
is not found or a pointer to the device. The device has not
had its reference counter increased so the caller must be careful
about locking. The caller must hold RCU lock.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_get_by_index">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_get_by_index</code><span class="sig-paren">(</span>struct net<em> *net</em>, int<em> ifindex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its ifindex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ifindex</span></code></dt><dd><p>index of device</p>
<p>Search for an interface by index. Returns NULL if the device
is not found or a pointer to the device. The device returned has
had a reference added and the pointer is safe until the user calls
dev_put to indicate they have finished with it.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_get_by_napi_id">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_get_by_napi_id</code><span class="sig-paren">(</span>unsigned int<em> napi_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_napi_id" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by napi_id</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">napi_id</span></code></dt><dd><p>ID of the NAPI struct</p>
<p>Search for an interface by NAPI ID. Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the device
is not found or a pointer to the device. The device has not had
its reference counter increased so the caller must be careful
about locking. The caller must hold RCU lock.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_getbyhwaddr_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">dev_getbyhwaddr_rcu</code><span class="sig-paren">(</span>struct net<em> *net</em>, unsigned short<em> type</em>, const char<em> *ha</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_getbyhwaddr_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its hardware address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">type</span></code></dt><dd><p>media type of device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*ha</span></code></dt><dd><p>hardware address</p>
<p>Search for an interface by MAC address. Returns NULL if the device
is not found or a pointer to the device.
The caller must hold RCU or RTNL.
The returned device has not had its ref count increased
and the caller must therefore be careful about locking</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__dev_get_by_flags">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">__dev_get_by_flags</code><span class="sig-paren">(</span>struct net<em> *net</em>, unsigned short<em> if_flags</em>, unsigned short<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_get_by_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>find any device with given flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>the applicable net namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">if_flags</span></code></dt><dd><p>IFF_* values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">mask</span></code></dt><dd><p>bitmask of bits in if_flags to check</p>
<p>Search for any interface with the given flags. Returns NULL if a device
is not found or a pointer to the device. Must be called inside
rtnl_lock(), and result refcount is unchanged.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_valid_name">
bool <code class="sig-name descname">dev_valid_name</code><span class="sig-paren">(</span>const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_valid_name" title="Permalink to this definition">¶</a></dt>
<dd><p>check if name is okay for network device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name string</p>
<p>Network device names need to be valid file names to
allow sysfs to work.  We also disallow any kind of
whitespace.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_alloc_name">
int <code class="sig-name descname">dev_alloc_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_alloc_name" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a name for a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name format string</p>
<p>Passed a format string - eg “lt``d``” it will try and find a suitable
id. It scans list of devices to build up a free map, then chooses
the first empty slot. The caller must hold the dev_base or rtnl lock
while allocating the name and adding the device in order to avoid
duplicates.
Limited to bits_per_byte * page size devices (ie 32K on most platforms).
Returns the number of the unit assigned or a negative errno code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_set_alias">
int <code class="sig-name descname">dev_set_alias</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, const char<em> *alias</em>, size_t<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>change ifalias of a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*alias</span></code></dt><dd><p>name up to IFALIASZ</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">len</span></code></dt><dd><p>limit of bytes to copy from info</p>
<p>Set ifalias for a device,</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_features_change">
void <code class="sig-name descname">netdev_features_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_features_change" title="Permalink to this definition">¶</a></dt>
<dd><p>device changes features</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to cause notification</p>
<p>Called to indicate a device has changed features.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_state_change">
void <code class="sig-name descname">netdev_state_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_state_change" title="Permalink to this definition">¶</a></dt>
<dd><p>device changes state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to cause notification</p>
<p>Called to indicate a device has changed state. This function calls
the notifier chains for netdev_chain and sends a NEWLINK message
to the routing socket.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__netdev_notify_peers">
void <code class="sig-name descname">__netdev_notify_peers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__netdev_notify_peers" title="Permalink to this definition">¶</a></dt>
<dd><p>notify network peers about existence of <strong>dev</strong>, to be called when rtnl lock is already held.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate traffic such that interested network peers are aware of
<strong>dev</strong>, such as by generating a gratuitous ARP. This may be used when
a device wants to inform the rest of the network about some sort of
reconfiguration such as a failover event or virtual machine
migration.</p>
</div>
<dl class="function">
<dt id="c.netdev_notify_peers">
void <code class="sig-name descname">netdev_notify_peers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_notify_peers" title="Permalink to this definition">¶</a></dt>
<dd><p>notify network peers about existence of <strong>dev</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate traffic such that interested network peers are aware of
<strong>dev</strong>, such as by generating a gratuitous ARP. This may be used when
a device wants to inform the rest of the network about some sort of
reconfiguration such as a failover event or virtual machine
migration.</p>
</div>
<dl class="function">
<dt id="c.dev_open">
int <code class="sig-name descname">dev_open</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct netlink_ext_ack<em> *extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_open" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare an interface for use.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to open</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*extack</span></code></dt><dd><p>netlink extended ack</p>
<p>Takes a device from down to up state. The device’s private open
function is invoked and then the multicast lists are loaded. Finally
the device is moved into the up state and a <code class="docutils literal notranslate"><span class="pre">NETDEV_UP</span></code> message is
sent to the netdev notifier chain.</p>
<p>Calling this function on an active interface is a nop. On a failure
a negative errno code is returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_close">
void <code class="sig-name descname">dev_close</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_close" title="Permalink to this definition">¶</a></dt>
<dd><p>shutdown an interface.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to shutdown</p>
<p>This function moves an active device into down state. A
<code class="docutils literal notranslate"><span class="pre">NETDEV_GOING_DOWN</span></code> is sent to the netdev notifier chain. The device
is then deactivated and finally a <code class="docutils literal notranslate"><span class="pre">NETDEV_DOWN</span></code> is sent to the notifier
chain.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_disable_lro">
void <code class="sig-name descname">dev_disable_lro</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_disable_lro" title="Permalink to this definition">¶</a></dt>
<dd><p>disable Large Receive Offload on a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
<p>Disable Large Receive Offload (LRO) on a net device.  Must be
called under RTNL.  This is needed if received packets may be
forwarded to another interface.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.register_netdevice_notifier">
int <code class="sig-name descname">register_netdevice_notifier</code><span class="sig-paren">(</span>struct notifier_block<em> *nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_netdevice_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>register a network notifier block</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>notifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a notifier to be called when network device events occur.
The notifier passed is linked into the kernel structures and must
not be reused until it has been unregistered. A negative errno code
is returned on a failure.</p>
<p>When registered all registration and up events are replayed
to the new notifier to allow device to have a race free
view of the network device list.</p>
</div>
<dl class="function">
<dt id="c.unregister_netdevice_notifier">
int <code class="sig-name descname">unregister_netdevice_notifier</code><span class="sig-paren">(</span>struct notifier_block<em> *nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdevice_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a network notifier block</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>notifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister a notifier previously registered by
<a class="reference internal" href="#c.register_netdevice_notifier" title="register_netdevice_notifier"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_netdevice_notifier()</span></code></a>. The notifier is unlinked into the
kernel structures and may then be reused. A negative errno code
is returned on a failure.</p>
<p>After unregistering unregister and down device events are synthesized
for all devices on the device list to the removed notifier to remove
the need for special case cleanup code.</p>
</div>
<dl class="function">
<dt id="c.register_netdevice_notifier_net">
int <code class="sig-name descname">register_netdevice_notifier_net</code><span class="sig-paren">(</span>struct net<em> *net</em>, struct notifier_block<em> *nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_netdevice_notifier_net" title="Permalink to this definition">¶</a></dt>
<dd><p>register a per-netns network notifier block</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>network namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>notifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a notifier to be called when network device events occur.
The notifier passed is linked into the kernel structures and must
not be reused until it has been unregistered. A negative errno code
is returned on a failure.</p>
<p>When registered all registration and up events are replayed
to the new notifier to allow device to have a race free
view of the network device list.</p>
</div>
<dl class="function">
<dt id="c.unregister_netdevice_notifier_net">
int <code class="sig-name descname">unregister_netdevice_notifier_net</code><span class="sig-paren">(</span>struct net<em> *net</em>, struct notifier_block<em> *nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdevice_notifier_net" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a per-netns network notifier block</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>network namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>notifier</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister a notifier previously registered by
<a class="reference internal" href="#c.register_netdevice_notifier" title="register_netdevice_notifier"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_netdevice_notifier()</span></code></a>. The notifier is unlinked into the
kernel structures and may then be reused. A negative errno code
is returned on a failure.</p>
<p>After unregistering unregister and down device events are synthesized
for all devices on the device list to the removed notifier to remove
the need for special case cleanup code.</p>
</div>
<dl class="function">
<dt id="c.call_netdevice_notifiers">
int <code class="sig-name descname">call_netdevice_notifiers</code><span class="sig-paren">(</span>unsigned long<em> val</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_netdevice_notifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>call all network notifier blocks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">val</span></code></dt><dd><p>value passed unmodified to notifier function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>net_device pointer passed unmodified to notifier function</p>
<p>Call all network notifier blocks.  Parameters and return value
are as for raw_notifier_call_chain().</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_forward_skb">
int <code class="sig-name descname">dev_forward_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_forward_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>loopback an skb to another netif</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>destination network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to forward</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>return values:</dt><dd><p>NET_RX_SUCCESS  (no congestion)
NET_RX_DROP     (packet was dropped, but freed)</p>
</dd>
</dl>
<p>dev_forward_skb can be used for injecting an skb from the
start_xmit function of one device into the receive queue
of another device.</p>
<p>The receiving device may be in another namespace, so
we have to clear all information in the skb that could
impact namespace isolation.</p>
</div>
<dl class="function">
<dt id="c.dev_nit_active">
bool <code class="sig-name descname">dev_nit_active</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_nit_active" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if any network interface taps are in use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device to check for the presence of taps</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_set_real_num_rx_queues">
int <code class="sig-name descname">netif_set_real_num_rx_queues</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, unsigned int<em> rxq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_set_real_num_rx_queues" title="Permalink to this definition">¶</a></dt>
<dd><p>set actual number of RX queues used</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>Network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rxq</span></code></dt><dd><p>Actual number of RX queues</p>
<p>This must be called either with the rtnl_lock held or before
registration of the net device.  Returns 0 on success, or a
negative error code.  If called before registration, it always
succeeds.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_set_real_num_queues">
int <code class="sig-name descname">netif_set_real_num_queues</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, unsigned int<em> txq</em>, unsigned int<em> rxq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_set_real_num_queues" title="Permalink to this definition">¶</a></dt>
<dd><p>set actual number of RX and TX queues used</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>Network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">txq</span></code></dt><dd><p>Actual number of TX queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rxq</span></code></dt><dd><p>Actual number of RX queues</p>
<p>Set the real number of both TX and RX queues.
Does nothing if the number of queues is already correct.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_set_tso_max_size">
void <code class="sig-name descname">netif_set_tso_max_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_set_tso_max_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set the max size of TSO frames supported</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>netdev to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>max skb-&gt;len of a TSO frame</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the limit on the size of TSO super-frames the device can handle.
Unless explicitly set the stack will assume the value of
<code class="docutils literal notranslate"><span class="pre">GSO_LEGACY_MAX_SIZE</span></code>.</p>
</div>
<dl class="function">
<dt id="c.netif_set_tso_max_segs">
void <code class="sig-name descname">netif_set_tso_max_segs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, unsigned int<em> segs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_set_tso_max_segs" title="Permalink to this definition">¶</a></dt>
<dd><p>set the max number of segs supported for TSO</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>netdev to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">segs</span></code></dt><dd><p>max number of TCP segments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the limit on the number of TCP segments the device can generate from
a single TSO super-frame.
Unless explicitly set the stack will assume the value of <code class="docutils literal notranslate"><span class="pre">GSO_MAX_SEGS</span></code>.</p>
</div>
<dl class="function">
<dt id="c.netif_inherit_tso_max">
void <code class="sig-name descname">netif_inherit_tso_max</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *to</em>, const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_inherit_tso_max" title="Permalink to this definition">¶</a></dt>
<dd><p>copy all TSO limits from a lower device to an upper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*to</span></code></dt><dd><p>netdev to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*from</span></code></dt><dd><p>netdev from which to copy the limits</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_get_num_default_rss_queues">
int <code class="sig-name descname">netif_get_num_default_rss_queues</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.netif_get_num_default_rss_queues" title="Permalink to this definition">¶</a></dt>
<dd><p>default number of RSS queues</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default value is the number of physical cores if there are only 1 or 2, or
divided by 2 if there are more.</p>
</div>
<dl class="function">
<dt id="c.netif_device_detach">
void <code class="sig-name descname">netif_device_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_device_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>mark device as removed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark device as removed from system and therefore no longer available.</p>
</div>
<dl class="function">
<dt id="c.netif_device_attach">
void <code class="sig-name descname">netif_device_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_device_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>mark device as attached</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark device as attached from system and restart if needed.</p>
</div>
<dl class="function">
<dt id="c.__skb_gso_segment">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="sig-name descname">__skb_gso_segment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, netdev_features_t<em> features</em>, bool<em> tx_path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_gso_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform segmentation on skb.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to segment</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">features</span></code></dt><dd><p>features for the output path (see dev-&gt;features)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">tx_path</span></code></dt><dd><p>whether it is called in TX path</p>
<p>This function segments the given skb and returns a list of segments.</p>
<p>It may return NULL if the skb requires no segmentation.  This is
only possible when GSO is used for verifying header integrity.</p>
<p>Segmentation preserves SKB_GSO_CB_OFFSET bytes of previous skb cb.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_loopback_xmit">
int <code class="sig-name descname">dev_loopback_xmit</code><span class="sig-paren">(</span>struct net<em> *net</em>, struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_loopback_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>loop back <strong>skb</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>network namespace this loopback is happening in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>sk needed to be a netfilter okfn</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to transmit</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__dev_queue_xmit">
int <code class="sig-name descname">__dev_queue_xmit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *sb_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_queue_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit a buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to transmit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*sb_dev</span></code></dt><dd><p>suboordinate device used for L2 forwarding offload</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue a buffer for transmission to a network device. The caller must
have set the device and priority and built the buffer before calling
this function. The function can be called from an interrupt.</p>
<p>When calling this method, interrupts MUST be enabled. This is because
the BH enable code must have IRQs enabled so that it will not deadlock.</p>
<p>Regardless of the return value, the skb is consumed, so it is currently
difficult to retry a send to this method. (You can bump the ref count
before sending to hold a reference for retry if you are careful.)</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li><p>0                          - buffer successfully transmitted</p></li>
<li><p>positive qdisc return code - NET_XMIT_DROP etc.</p></li>
<li><p>negative errno             - other errors</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.rps_may_expire_flow">
bool <code class="sig-name descname">rps_may_expire_flow</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, u16<em> rxq_index</em>, u32<em> flow_id</em>, u16<em> filter_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rps_may_expire_flow" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether an RFS hardware filter may be removed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>Device on which the filter was set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">rxq_index</span></code></dt><dd><p>RX queue index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flow_id</span></code></dt><dd><p>Flow ID passed to ndo_rx_flow_steer()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">filter_id</span></code></dt><dd><p>Filter ID returned by ndo_rx_flow_steer()</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers that implement ndo_rx_flow_steer() should periodically call
this function for each installed filter and remove the filters for
which it returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
</div>
<dl class="function">
<dt id="c.__netif_rx">
int <code class="sig-name descname">__netif_rx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__netif_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Slightly optimized version of netif_rx</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to post</p>
<p>This behaves as netif_rx except that it does not disable bottom halves.
As a result this function may only be invoked from the interrupt context
(either hard or soft interrupt).</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_rx">
int <code class="sig-name descname">netif_rx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>post buffer to the network code</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to post</p>
<p>This function receives a packet from a device driver and queues it for
the upper (protocol) levels to process via the backlog NAPI device. It
always succeeds. The buffer may be dropped during processing for
congestion control or by the protocol layers.
The network buffer is passed via the backlog NAPI device. Modern NIC
driver should use NAPI and GRO.
This function can used from interrupt and from process context. The
caller from process context must not disable interrupts before invoking
this function.</p>
<p>return values:
NET_RX_SUCCESS  (no congestion)
NET_RX_DROP     (packet was dropped)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_is_rx_handler_busy">
bool <code class="sig-name descname">netdev_is_rx_handler_busy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_is_rx_handler_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if receive handler is registered</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to check</p>
<p>Check if a receive handler is already registered for a given device.
Return true if there one.</p>
<p>The caller must hold the rtnl_mutex.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_rx_handler_register">
int <code class="sig-name descname">netdev_rx_handler_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, rx_handler_func_t<em> *rx_handler</em>, void<em> *rx_handler_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_rx_handler_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register receive handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to register a handler for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_handler_func_t</span> <span class="pre">*rx_handler</span></code></dt><dd><p>receive handler to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*rx_handler_data</span></code></dt><dd><p>data pointer that is used by rx handler</p>
<p>Register a receive handler for a device. This handler will then be
called from __netif_receive_skb. A negative errno code is returned
on a failure.</p>
<p>The caller must hold the rtnl_mutex.</p>
<p>For a general description of rx_handler, see enum rx_handler_result.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_rx_handler_unregister">
void <code class="sig-name descname">netdev_rx_handler_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_rx_handler_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister receive handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to unregister a handler from</p>
<p>Unregister a receive handler from a device.</p>
<p>The caller must hold the rtnl_mutex.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_receive_skb_core">
int <code class="sig-name descname">netif_receive_skb_core</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_receive_skb_core" title="Permalink to this definition">¶</a></dt>
<dd><p>special purpose version of netif_receive_skb</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to process</p>
<p>More direct receive version of <a class="reference internal" href="#c.netif_receive_skb" title="netif_receive_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_receive_skb()</span></code></a>.  It should
only be used by callers that have a need to skip RPS and Generic XDP.
Caller must also take care of handling if <code class="docutils literal notranslate"><span class="pre">(page_is_)pfmemalloc</span></code>.</p>
<p>This function may only be called from softirq context and interrupts
should be enabled.</p>
<p>Return values (usually ignored):
NET_RX_SUCCESS: no congestion
NET_RX_DROP: packet was dropped</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_receive_skb">
int <code class="sig-name descname">netif_receive_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_receive_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>process receive buffer from network</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to process</p>
<p><a class="reference internal" href="#c.netif_receive_skb" title="netif_receive_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_receive_skb()</span></code></a> is the main receive data processing function.
It always succeeds. The buffer may be dropped during processing
for congestion control or by the protocol layers.</p>
<p>This function may only be called from softirq context and interrupts
should be enabled.</p>
<p>Return values (usually ignored):
NET_RX_SUCCESS: no congestion
NET_RX_DROP: packet was dropped</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_receive_skb_list">
void <code class="sig-name descname">netif_receive_skb_list</code><span class="sig-paren">(</span>struct list_head<em> *head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_receive_skb_list" title="Permalink to this definition">¶</a></dt>
<dd><p>process many receive buffers from network</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>list of skbs to process.</p>
<p>Since return value of <a class="reference internal" href="#c.netif_receive_skb" title="netif_receive_skb"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_receive_skb()</span></code></a> is normally ignored, and
wouldn’t be meaningful for a list, this function returns void.</p>
<p>This function may only be called from softirq context and interrupts
should be enabled.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__napi_schedule">
void <code class="sig-name descname">__napi_schedule</code><span class="sig-paren">(</span>struct napi_struct<em> *n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__napi_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule for receive</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*n</span></code></dt><dd><p>entry to schedule</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The entry’s receive function will be scheduled to run.
Consider using <a class="reference internal" href="#c.__napi_schedule_irqoff" title="__napi_schedule_irqoff"><code class="xref c c-func docutils literal notranslate"><span class="pre">__napi_schedule_irqoff()</span></code></a> if hard irqs are masked.</p>
</div>
<dl class="function">
<dt id="c.napi_schedule_prep">
bool <code class="sig-name descname">napi_schedule_prep</code><span class="sig-paren">(</span>struct napi_struct<em> *n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_schedule_prep" title="Permalink to this definition">¶</a></dt>
<dd><p>check if napi can be scheduled</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*n</span></code></dt><dd><p>napi context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test if NAPI routine is already running, and if not mark
it as running.  This is used as a condition variable to
insure only one NAPI poll instance runs.  We also make
sure there is no pending NAPI disable.</p>
</div>
<dl class="function">
<dt id="c.__napi_schedule_irqoff">
void <code class="sig-name descname">__napi_schedule_irqoff</code><span class="sig-paren">(</span>struct napi_struct<em> *n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__napi_schedule_irqoff" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule for receive</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*n</span></code></dt><dd><p>entry to schedule</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Variant of <a class="reference internal" href="#c.__napi_schedule" title="__napi_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">__napi_schedule()</span></code></a> assuming hard irqs are masked.</p>
<p>On PREEMPT_RT enabled kernels this maps to <a class="reference internal" href="#c.__napi_schedule" title="__napi_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">__napi_schedule()</span></code></a>
because the interrupt disabled assumption might not be true
due to force-threaded interrupts and spinlock substitution.</p>
</div>
<dl class="function">
<dt id="c.napi_enable">
void <code class="sig-name descname">napi_enable</code><span class="sig-paren">(</span>struct napi_struct<em> *n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable NAPI scheduling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resume NAPI from being scheduled on this context.
Must be paired with napi_disable.</p>
</div>
<dl class="function">
<dt id="c.netdev_has_upper_dev">
bool <code class="sig-name descname">netdev_has_upper_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *upper_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_has_upper_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device is linked to an upper device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*upper_dev</span></code></dt><dd><p>upper device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out if a device is linked to specified upper device and return true
in case it is. Note that this checks only immediate upper device,
not through a complete stack of devices. The caller must hold the RTNL lock.</p>
</div>
<dl class="function">
<dt id="c.netdev_has_upper_dev_all_rcu">
bool <code class="sig-name descname">netdev_has_upper_dev_all_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *upper_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_has_upper_dev_all_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device is linked to an upper device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*upper_dev</span></code></dt><dd><p>upper device to check</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out if a device is linked to specified upper device and return true
in case it is. Note that this checks the entire upper device chain.
The caller must hold rcu lock.</p>
</div>
<dl class="function">
<dt id="c.netdev_has_any_upper_dev">
bool <code class="sig-name descname">netdev_has_any_upper_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_has_any_upper_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device is linked to some device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out if a device is linked to an upper device and return true in case
it is. The caller must hold the RTNL lock.</p>
</div>
<dl class="function">
<dt id="c.netdev_master_upper_dev_get">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">netdev_master_upper_dev_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_master_upper_dev_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get master upper device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a master upper device and return pointer to it or NULL in case
it’s not there. The caller must hold the RTNL lock.</p>
</div>
<dl class="function">
<dt id="c.netdev_upper_get_next_dev_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">netdev_upper_get_next_dev_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct list_head<em> **iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_upper_get_next_dev_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next dev from upper list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**iter</span></code></dt><dd><p>list_head ** of the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next device from the dev’s upper list, starting from iter
position. The caller must hold RCU read lock.</p>
</div>
<dl class="function">
<dt id="c.netdev_lower_get_next_private">
void * <code class="sig-name descname">netdev_lower_get_next_private</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct list_head<em> **iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_next_private" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next -&gt;private from the lower neighbour list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**iter</span></code></dt><dd><p>list_head ** of the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next netdev_adjacent-&gt;private from the dev’s lower neighbour
list, starting from iter position. The caller must hold either hold the
RTNL lock or its own locking that guarantees that the neighbour lower
list will remain unchanged.</p>
</div>
<dl class="function">
<dt id="c.netdev_lower_get_next_private_rcu">
void * <code class="sig-name descname">netdev_lower_get_next_private_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct list_head<em> **iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_next_private_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next -&gt;private from the lower neighbour list, RCU variant</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**iter</span></code></dt><dd><p>list_head ** of the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next netdev_adjacent-&gt;private from the dev’s lower neighbour
list, starting from iter position. The caller must hold RCU read lock.</p>
</div>
<dl class="function">
<dt id="c.netdev_lower_get_next">
void * <code class="sig-name descname">netdev_lower_get_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct list_head<em> **iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next device from the lower neighbour list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**iter</span></code></dt><dd><p>list_head ** of the current position</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next netdev_adjacent from the dev’s lower neighbour
list, starting from iter position. The caller must hold RTNL lock or
its own locking that guarantees that the neighbour lower
list will remain unchanged.</p>
</div>
<dl class="function">
<dt id="c.netdev_lower_get_first_private_rcu">
void * <code class="sig-name descname">netdev_lower_get_first_private_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_first_private_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first -&gt;private from the lower neighbour list, RCU variant</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the first netdev_adjacent-&gt;private from the dev’s lower neighbour
list. The caller must hold RCU read lock.</p>
</div>
<dl class="function">
<dt id="c.netdev_master_upper_dev_get_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">netdev_master_upper_dev_get_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_master_upper_dev_get_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get master upper device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a master upper device and return pointer to it or NULL in case
it’s not there. The caller must hold the RCU read lock.</p>
</div>
<dl class="function">
<dt id="c.netdev_upper_dev_link">
int <code class="sig-name descname">netdev_upper_dev_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *upper_dev</em>, struct netlink_ext_ack<em> *extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_upper_dev_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a link to the upper device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*upper_dev</span></code></dt><dd><p>new upper device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*extack</span></code></dt><dd><p>netlink extended ack</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a link to device which is upper to this one. The caller must hold
the RTNL lock. On a failure a negative errno code is returned.
On success the reference counts are adjusted and the function
returns zero.</p>
</div>
<dl class="function">
<dt id="c.netdev_master_upper_dev_link">
int <code class="sig-name descname">netdev_master_upper_dev_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *upper_dev</em>, void<em> *upper_priv</em>, void<em> *upper_info</em>, struct netlink_ext_ack<em> *extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_master_upper_dev_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a master link to the upper device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*upper_dev</span></code></dt><dd><p>new upper device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*upper_priv</span></code></dt><dd><p>upper device private</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*upper_info</span></code></dt><dd><p>upper info to be passed down via notifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*extack</span></code></dt><dd><p>netlink extended ack</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a link to device which is upper to this one. In this case, only
one master upper device can be linked, although other non-master devices
might be linked as well. The caller must hold the RTNL lock.
On a failure a negative errno code is returned. On success the reference
counts are adjusted and the function returns zero.</p>
</div>
<dl class="function">
<dt id="c.netdev_upper_dev_unlink">
void <code class="sig-name descname">netdev_upper_dev_unlink</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *upper_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_upper_dev_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a link to upper device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*upper_dev</span></code></dt><dd><p>new upper device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a link to device which is upper to this one. The caller must hold
the RTNL lock.</p>
</div>
<dl class="function">
<dt id="c.netdev_bonding_info_change">
void <code class="sig-name descname">netdev_bonding_info_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct netdev_bonding_info<em> *bonding_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_bonding_info_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Dispatch event about slave change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_bonding_info</span> <span class="pre">*bonding_info</span></code></dt><dd><p>info to dispatch</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send NETDEV_BONDING_INFO to netdev notifiers with info.
The caller must hold the RTNL lock.</p>
</div>
<dl class="function">
<dt id="c.netdev_get_xmit_slave">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">netdev_get_xmit_slave</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, bool<em> all_slaves</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_get_xmit_slave" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the xmit slave of master device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>The packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">all_slaves</span></code></dt><dd><p>assume all the slaves are active</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The reference counters are not incremented so the caller must be
careful with locks. The caller must hold RCU lock.
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if no slave is found.</p>
</div>
<dl class="function">
<dt id="c.netdev_sk_get_lowest_dev">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">netdev_sk_get_lowest_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em> *sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_sk_get_lowest_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the lowest device in chain given device and socket</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*sk</span></code></dt><dd><p>the socket</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> is returned if no lower device is found.</p>
</div>
<dl class="function">
<dt id="c.netdev_lower_state_changed">
void <code class="sig-name descname">netdev_lower_state_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *lower_dev</em>, void<em> *lower_state_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_state_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Dispatch event about lower device state change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*lower_dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*lower_state_info</span></code></dt><dd><p>state to dispatch</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send NETDEV_CHANGELOWERSTATE to netdev notifiers with info.
The caller must hold the RTNL lock.</p>
</div>
<dl class="function">
<dt id="c.dev_set_promiscuity">
int <code class="sig-name descname">dev_set_promiscuity</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, int<em> inc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_promiscuity" title="Permalink to this definition">¶</a></dt>
<dd><p>update promiscuity count on a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inc</span></code></dt><dd><p>modifier</p>
<p>Add or remove promiscuity from a device. While the count in the device
remains above zero the interface remains promiscuous. Once it hits zero
the device reverts back to normal filtering operation. A negative inc
value is used to drop promiscuity on the device.
Return 0 if successful or a negative errno code on error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_set_allmulti">
int <code class="sig-name descname">dev_set_allmulti</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, int<em> inc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_allmulti" title="Permalink to this definition">¶</a></dt>
<dd><p>update allmulti count on a device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">inc</span></code></dt><dd><p>modifier</p>
<p>Add or remove reception of all multicast frames to a device. While the
count in the device remains above zero the interface remains listening
to all interfaces. Once it hits zero the device reverts back to normal
filtering operation. A negative <strong>inc</strong> value is used to drop the counter
when releasing a resource needing all multicasts.
Return 0 if successful or a negative errno code on error.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_get_flags">
unsigned int <code class="sig-name descname">dev_get_flags</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>get flags reported to userspace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
<p>Get the combination of flag bits exported through APIs to userspace.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_change_flags">
int <code class="sig-name descname">dev_change_flags</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, unsigned int<em> flags</em>, struct netlink_ext_ack<em> *extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_change_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>change device settings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>device state flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*extack</span></code></dt><dd><p>netlink extended ack</p>
<p>Change settings on device based state flags. The flags are
in the userspace exported format.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_pre_changeaddr_notify">
int <code class="sig-name descname">dev_pre_changeaddr_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, const char<em> *addr</em>, struct netlink_ext_ack<em> *extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_pre_changeaddr_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Call NETDEV_PRE_CHANGEADDR.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*addr</span></code></dt><dd><p>new address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*extack</span></code></dt><dd><p>netlink extended ack</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_set_mac_address">
int <code class="sig-name descname">dev_set_mac_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct sockaddr<em> *sa</em>, struct netlink_ext_ack<em> *extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_mac_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Change Media Access Control Address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*sa</span></code></dt><dd><p>new address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*extack</span></code></dt><dd><p>netlink extended ack</p>
<p>Change the hardware (MAC) address of the device</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_get_port_parent_id">
int <code class="sig-name descname">dev_get_port_parent_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct netdev_phys_item_id<em> *ppid</em>, bool<em> recurse</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_port_parent_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the device’s port parent identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_phys_item_id</span> <span class="pre">*ppid</span></code></dt><dd><p>pointer to a storage for the port’s parent identifier</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">recurse</span></code></dt><dd><p>allow/disallow recursion to lower devices</p>
<p>Get the devices’s port parent identifier</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_port_same_parent_id">
bool <code class="sig-name descname">netdev_port_same_parent_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *a</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_port_same_parent_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if two network devices have the same port parent identifier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*a</span></code></dt><dd><p>first network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*b</span></code></dt><dd><p>second network device</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_update_features">
void <code class="sig-name descname">netdev_update_features</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_update_features" title="Permalink to this definition">¶</a></dt>
<dd><p>recalculate device features</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device to check</p>
<p>Recalculate dev-&gt;features set and send notifications if it
has changed. Should be called after driver or hardware dependent
conditions might have changed that influence the features.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_change_features">
void <code class="sig-name descname">netdev_change_features</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_change_features" title="Permalink to this definition">¶</a></dt>
<dd><p>recalculate device features</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device to check</p>
<p>Recalculate dev-&gt;features set and send notifications even
if they have not changed. Should be called instead of
<a class="reference internal" href="#c.netdev_update_features" title="netdev_update_features"><code class="xref c c-func docutils literal notranslate"><span class="pre">netdev_update_features()</span></code></a> if also dev-&gt;vlan_features might
have changed to allow the changes to be propagated to stacked
VLAN devices.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_stacked_transfer_operstate">
void <code class="sig-name descname">netif_stacked_transfer_operstate</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *rootdev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_stacked_transfer_operstate" title="Permalink to this definition">¶</a></dt>
<dd><p>transfer operstate</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*rootdev</span></code></dt><dd><p>the root or lower level device to transfer state from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>the device to transfer operstate to</p>
<p>Transfer operational state from root to device. This is normally
called when a stacking relationship exists between the root
device and the device(a leaf device).</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.register_netdevice">
int <code class="sig-name descname">register_netdevice</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_netdevice" title="Permalink to this definition">¶</a></dt>
<dd><p>register a network device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Take a prepared network device structure and make it externally accessible.
A <code class="docutils literal notranslate"><span class="pre">NETDEV_REGISTER</span></code> message is sent to the netdev notifier chain.
Callers must hold the rtnl lock - you may want <a class="reference internal" href="#c.register_netdev" title="register_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_netdev()</span></code></a>
instead of this.</p>
</div>
<dl class="function">
<dt id="c.init_dummy_netdev">
int <code class="sig-name descname">init_dummy_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_dummy_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>init a dummy network device for NAPI</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to init</p>
<p>This takes a network device structure and initialize the minimum
amount of fields so it can be used to schedule NAPI polls without
registering a full blown interface. This is to be used by drivers
that need to tie several hardware interfaces to a single NAPI
poll scheduler due to HW limitations.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.register_netdev">
int <code class="sig-name descname">register_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>register a network device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to register</p>
<p>Take a completed network device structure and add it to the kernel
interfaces. A <code class="docutils literal notranslate"><span class="pre">NETDEV_REGISTER</span></code> message is sent to the netdev notifier
chain. 0 is returned on success. A negative errno code is returned
on a failure to set up the device, or if the name is a duplicate.</p>
<p>This is a wrapper around register_netdevice that takes the rtnl semaphore
and expands the device name if you passed a format string to
alloc_netdev.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_get_stats">
struct <a class="reference internal" href="statistics.html#c.rtnl_link_stats64" title="rtnl_link_stats64">rtnl_link_stats64</a> * <code class="sig-name descname">dev_get_stats</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="statistics.html#c.rtnl_link_stats64" title="rtnl_link_stats64">rtnl_link_stats64</a><em> *storage</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>get network device statistics</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to get statistics from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rtnl_link_stats64</span> <span class="pre">*storage</span></code></dt><dd><p>place to store stats</p>
<p>Get network statistics from device. Return <strong>storage</strong>.
The device driver may provide its own method by setting
dev-&gt;netdev_ops-&gt;get_stats64 or dev-&gt;netdev_ops-&gt;get_stats;
otherwise the internal statistics structure is used.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_fetch_sw_netstats">
void <code class="sig-name descname">dev_fetch_sw_netstats</code><span class="sig-paren">(</span>struct <a class="reference internal" href="statistics.html#c.rtnl_link_stats64" title="rtnl_link_stats64">rtnl_link_stats64</a><em> *s</em>, const struct pcpu_sw_netstats __percpu<em> *netstats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_fetch_sw_netstats" title="Permalink to this definition">¶</a></dt>
<dd><p>get per-cpu network device statistics</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rtnl_link_stats64</span> <span class="pre">*s</span></code></dt><dd><p>place to store stats</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pcpu_sw_netstats</span> <span class="pre">__percpu</span> <span class="pre">*netstats</span></code></dt><dd><p>per-cpu network stats to read from</p>
<p>Read per-cpu network statistics and populate the related fields in <strong>s</strong>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.dev_get_tstats64">
void <code class="sig-name descname">dev_get_tstats64</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="statistics.html#c.rtnl_link_stats64" title="rtnl_link_stats64">rtnl_link_stats64</a><em> *s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_tstats64" title="Permalink to this definition">¶</a></dt>
<dd><p>ndo_get_stats64 implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to get statistics from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rtnl_link_stats64</span> <span class="pre">*s</span></code></dt><dd><p>place to store stats</p>
<p>Populate <strong>s</strong> from dev-&gt;stats and dev-&gt;tstats. Can be used as
ndo_get_stats64() callback.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_sw_irq_coalesce_default_on">
void <code class="sig-name descname">netdev_sw_irq_coalesce_default_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_sw_irq_coalesce_default_on" title="Permalink to this definition">¶</a></dt>
<dd><p>enable SW IRQ coalescing by default</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>netdev to enable the IRQ coalescing on</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets a conservative default for SW IRQ coalescing. Users can use
sysfs attributes to override the default values.</p>
</div>
<dl class="function">
<dt id="c.alloc_netdev_mqs">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">alloc_netdev_mqs</code><span class="sig-paren">(</span>int<em> sizeof_priv</em>, const char<em> *name</em>, unsigned char<em> name_assign_type</em>, void (<em>*setup</em>)(struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *), unsigned int<em> txqs</em>, unsigned int<em> rxqs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_netdev_mqs" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate network device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sizeof_priv</span></code></dt><dd><p>size of private data to allocate space for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>device name format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">name_assign_type</span></code></dt><dd><p>origin of device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*setup)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span></code></dt><dd><p>callback to initialize device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">txqs</span></code></dt><dd><p>the number of TX subqueues to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rxqs</span></code></dt><dd><p>the number of RX subqueues to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a <a class="reference internal" href="#c.net_device" title="net_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span></code></a> with private data area for driver use
and performs basic initialization.  Also allocates subqueue structs
for each queue on the device.</p>
</div>
<dl class="function">
<dt id="c.free_netdev">
void <code class="sig-name descname">free_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>free network device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does the last stage of destroying an allocated device
interface. The reference to the device object is released. If this
is the last reference then it will be freed.Must be called in process
context.</p>
</div>
<dl class="function">
<dt id="c.synchronize_net">
void <code class="sig-name descname">synchronize_net</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_net" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchronize with packet receive processing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Wait for packets currently being received to be done.
Does not block later packets from starting.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.unregister_netdevice_queue">
void <code class="sig-name descname">unregister_netdevice_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct list_head<em> *head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdevice_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>remove device from the kernel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>list</p>
<p>This function shuts down a device interface and removes it
from the kernel tables.
If head not NULL, device is queued to be unregistered later.</p>
<p>Callers must hold the rtnl semaphore.  You may want
<a class="reference internal" href="#c.unregister_netdev" title="unregister_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">unregister_netdev()</span></code></a> instead of this.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.unregister_netdevice_many">
void <code class="sig-name descname">unregister_netdevice_many</code><span class="sig-paren">(</span>struct list_head<em> *head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdevice_many" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister many devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>list of devices</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>As most callers use a stack allocated list_head,</dt><dd><p>we force a <a class="reference internal" href="../core-api/kernel-api.html#c.list_del" title="list_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del()</span></code></a> to make sure stack wont be corrupted later.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.unregister_netdev">
void <code class="sig-name descname">unregister_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>remove device from the kernel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
<p>This function shuts down a device interface and removes it
from the kernel tables.</p>
<p>This is just a wrapper for unregister_netdevice that takes
the rtnl semaphore.  In general you want to use this and not
unregister_netdevice.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__dev_change_net_namespace">
int <code class="sig-name descname">__dev_change_net_namespace</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct net<em> *net</em>, const char<em> *pat</em>, int<em> new_ifindex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_change_net_namespace" title="Permalink to this definition">¶</a></dt>
<dd><p>move device to different nethost namespace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*net</span></code></dt><dd><p>network namespace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pat</span></code></dt><dd><p>If not NULL name pattern to try if the current device name
is already taken in the destination network namespace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">new_ifindex</span></code></dt><dd><p>If not zero, specifies device index in the target
namespace.</p>
<blockquote>
<div><p>This function shuts down a device interface and moves it
to a new network namespace. On success 0 is returned, on
a failure a netagive errno code is returned.</p>
<p>Callers must hold the rtnl semaphore.</p>
</div></blockquote>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_increment_features">
netdev_features_t <code class="sig-name descname">netdev_increment_features</code><span class="sig-paren">(</span>netdev_features_t<em> all</em>, netdev_features_t<em> one</em>, netdev_features_t<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_increment_features" title="Permalink to this definition">¶</a></dt>
<dd><p>increment feature set by one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">all</span></code></dt><dd><p>current feature set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">one</span></code></dt><dd><p>new feature set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_features_t</span> <span class="pre">mask</span></code></dt><dd><p>mask feature set</p>
<p>Computes a new feature set after adding a device with feature set
<strong>one</strong> to the master device with current feature set <strong>all</strong>.  Will not
enable anything that is off in <strong>mask</strong>. Returns the new feature set.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.eth_header">
int <code class="sig-name descname">eth_header</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, unsigned short<em> type</em>, const void<em> *daddr</em>, const void<em> *saddr</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header" title="Permalink to this definition">¶</a></dt>
<dd><p>create the Ethernet header</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>buffer to alter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>source device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">type</span></code></dt><dd><p>Ethernet type field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*daddr</span></code></dt><dd><p>destination address (NULL leave destination address)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*saddr</span></code></dt><dd><p>source address (NULL use device source address)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>packet length (&lt;= skb-&gt;len)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the protocol type. For a packet of type ETH_P_802_3/2 we put the length
in here instead.</p>
</div>
<dl class="function">
<dt id="c.eth_get_headlen">
u32 <code class="sig-name descname">eth_get_headlen</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, const void<em> *data</em>, u32<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_get_headlen" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the length of header for an ethernet frame</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>pointer to start of frame</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">len</span></code></dt><dd><p>total length of frame</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make a best effort attempt to pull the length for all of the headers for
a given frame in a linear buffer.</p>
</div>
<dl class="function">
<dt id="c.eth_type_trans">
__be16 <code class="sig-name descname">eth_type_trans</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_type_trans" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the packet’s protocol ID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>received socket data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>receiving network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The rule here is that we
assume 802.3 if the type field is short enough to be a length.
This is normal practice and works for any ‘now in use’ protocol.</p>
</div>
<dl class="function">
<dt id="c.eth_header_parse">
int <code class="sig-name descname">eth_header_parse</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, unsigned char<em> *haddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>extract hardware address from packet</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>packet to extract header from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*haddr</span></code></dt><dd><p>destination buffer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.eth_header_cache">
int <code class="sig-name descname">eth_header_cache</code><span class="sig-paren">(</span>const struct neighbour<em> *neigh</em>, struct hh_cache<em> *hh</em>, __be16<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>fill cache entry from neighbour</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">neighbour</span> <span class="pre">*neigh</span></code></dt><dd><p>source neighbour</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hh_cache</span> <span class="pre">*hh</span></code></dt><dd><p>destination cache entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__be16</span> <span class="pre">type</span></code></dt><dd><p>Ethernet type field</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create an Ethernet header template from the neighbour.</p>
</div>
<dl class="function">
<dt id="c.eth_header_cache_update">
void <code class="sig-name descname">eth_header_cache_update</code><span class="sig-paren">(</span>struct hh_cache<em> *hh</em>, const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, const unsigned char<em> *haddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header_cache_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update cache entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hh_cache</span> <span class="pre">*hh</span></code></dt><dd><p>destination cache entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*haddr</span></code></dt><dd><p>new hardware address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by Address Resolution module to notify changes in address.</p>
</div>
<dl class="function">
<dt id="c.eth_header_parse_protocol">
__be16 <code class="sig-name descname">eth_header_parse_protocol</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header_parse_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>extract protocol from L2 header</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>packet to extract protocol from</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.eth_prepare_mac_addr_change">
int <code class="sig-name descname">eth_prepare_mac_addr_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, void<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_prepare_mac_addr_change" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare for mac change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>socket address</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.eth_commit_mac_addr_change">
void <code class="sig-name descname">eth_commit_mac_addr_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, void<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_commit_mac_addr_change" title="Permalink to this definition">¶</a></dt>
<dd><p>commit mac change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>socket address</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.eth_mac_addr">
int <code class="sig-name descname">eth_mac_addr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, void<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_mac_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>set new Ethernet hardware address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*p</span></code></dt><dd><p>socket address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Change hardware address of device.</p>
<p>This doesn’t change hardware matching, so needs to be overridden
for most real devices.</p>
</div>
<dl class="function">
<dt id="c.ether_setup">
void <code class="sig-name descname">ether_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>setup Ethernet network device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the fields of the device structure with Ethernet-generic values.</p>
</div>
<dl class="function">
<dt id="c.alloc_etherdev_mqs">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="sig-name descname">alloc_etherdev_mqs</code><span class="sig-paren">(</span>int<em> sizeof_priv</em>, unsigned int<em> txqs</em>, unsigned int<em> rxqs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_etherdev_mqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates and sets up an Ethernet device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">sizeof_priv</span></code></dt><dd><p>Size of additional driver-private structure to be allocated
for this Ethernet device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">txqs</span></code></dt><dd><p>The number of TX queues this device has.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rxqs</span></code></dt><dd><p>The number of RX queues this device has.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the fields of the device structure with Ethernet-generic
values. Basically does everything except registering the device.</p>
<p>Constructs a new net device, complete with a private data area of
size (sizeof_priv).  A 32-byte (not bit) alignment is enforced for
this private data area.</p>
</div>
<dl class="function">
<dt id="c.platform_get_ethdev_address">
int <code class="sig-name descname">platform_get_ethdev_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *netdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_ethdev_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Set netdev’s MAC address from a given device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Pointer to the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*netdev</span></code></dt><dd><p>Pointer to netdev to write the address to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper around eth_platform_get_mac_address() which writes the address
directly to netdev-&gt;dev_addr.</p>
</div>
<dl class="function">
<dt id="c.fwnode_get_mac_address">
int <code class="sig-name descname">fwnode_get_mac_address</code><span class="sig-paren">(</span>struct fwnode_handle<em> *fwnode</em>, char<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fwnode_get_mac_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the MAC from the firmware node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>Pointer to the firmware node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*addr</span></code></dt><dd><p>Address of buffer to store the MAC in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the firmware node for the best MAC address to use.  ‘mac-address’ is
checked first, because that is supposed to contain to “most recent” MAC
address. If that isn’t set, then ‘local-mac-address’ is checked next,
because that is the default address.  If that isn’t set, then the obsolete
‘address’ is checked, just in case we’re using an old device tree.</p>
<p>Note that the ‘address’ property is supposed to contain a virtual address of
the register set, but some DTS files have redefined that property to be the
MAC address.</p>
<p>All-zero MAC addresses are rejected, because those could be properties that
exist in the firmware tables, but were not updated by the firmware.  For
example, the DTS could define ‘mac-address’ and ‘local-mac-address’, with
zero MAC addresses.  Some older U-Boots only initialized ‘local-mac-address’.
In this case, the real MAC is in ‘local-mac-address’, and ‘mac-address’
exists but is all zeros.</p>
</div>
<dl class="function">
<dt id="c.device_get_mac_address">
int <code class="sig-name descname">device_get_mac_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, char<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_get_mac_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the MAC for a given device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Pointer to the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*addr</span></code></dt><dd><p>Address of buffer to store the MAC in</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.device_get_ethdev_address">
int <code class="sig-name descname">device_get_ethdev_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *netdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_get_ethdev_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Set netdev’s MAC address from a given device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Pointer to the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*netdev</span></code></dt><dd><p>Pointer to netdev to write the address to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper around <a class="reference internal" href="#c.device_get_mac_address" title="device_get_mac_address"><code class="xref c c-func docutils literal notranslate"><span class="pre">device_get_mac_address()</span></code></a> which writes the address
directly to netdev-&gt;dev_addr.</p>
</div>
<dl class="function">
<dt id="c.netif_carrier_on">
void <code class="sig-name descname">netif_carrier_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_carrier_on" title="Permalink to this definition">¶</a></dt>
<dd><p>set carrier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device has detected acquisition of carrier.</p>
</div>
<dl class="function">
<dt id="c.netif_carrier_off">
void <code class="sig-name descname">netif_carrier_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_carrier_off" title="Permalink to this definition">¶</a></dt>
<dd><p>clear carrier</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device has detected loss of carrier.</p>
</div>
<dl class="function">
<dt id="c.netif_carrier_event">
void <code class="sig-name descname">netif_carrier_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_carrier_event" title="Permalink to this definition">¶</a></dt>
<dd><p>report carrier state event</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device has detected a carrier event but the carrier state wasn’t changed.
Use in drivers when querying carrier state asynchronously, to avoid missing
events (link flaps) if link recovers before it’s queried.</p>
</div>
<dl class="function">
<dt id="c.is_link_local_ether_addr">
bool <code class="sig-name descname">is_link_local_ether_addr</code><span class="sig-paren">(</span>const u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_link_local_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given Ethernet address is link-local</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if address is link local reserved addr (01:80:c2:00:00:0X) per
IEEE 802.1Q 8.6.3 Frame filtering.</p>
<p>Please note: addr must be aligned to u16.</p>
</div>
<dl class="function">
<dt id="c.is_zero_ether_addr">
bool <code class="sig-name descname">is_zero_ether_addr</code><span class="sig-paren">(</span>const u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_zero_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if give Ethernet address is all zeros.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is all zeroes.</p>
<p>Please note: addr must be aligned to u16.</p>
</div>
<dl class="function">
<dt id="c.is_multicast_ether_addr">
bool <code class="sig-name descname">is_multicast_ether_addr</code><span class="sig-paren">(</span>const u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_multicast_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is a multicast.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is a multicast address.
By definition the broadcast address is also a multicast address.</p>
</div>
<dl class="function">
<dt id="c.is_local_ether_addr">
bool <code class="sig-name descname">is_local_ether_addr</code><span class="sig-paren">(</span>const u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_local_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is locally-assigned one (IEEE 802).</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is a local address.</p>
</div>
<dl class="function">
<dt id="c.is_broadcast_ether_addr">
bool <code class="sig-name descname">is_broadcast_ether_addr</code><span class="sig-paren">(</span>const u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_broadcast_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is broadcast</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is the broadcast address.</p>
<p>Please note: addr must be aligned to u16.</p>
</div>
<dl class="function">
<dt id="c.is_unicast_ether_addr">
bool <code class="sig-name descname">is_unicast_ether_addr</code><span class="sig-paren">(</span>const u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_unicast_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is unicast</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is a unicast address.</p>
</div>
<dl class="function">
<dt id="c.is_valid_ether_addr">
bool <code class="sig-name descname">is_valid_ether_addr</code><span class="sig-paren">(</span>const u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_valid_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the given Ethernet address is valid</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not
a multicast address, and is not FF:FF:FF:FF:FF:FF.</p>
<p>Return true if the address is valid.</p>
<p>Please note: addr must be aligned to u16.</p>
</div>
<dl class="function">
<dt id="c.eth_proto_is_802_3">
bool <code class="sig-name descname">eth_proto_is_802_3</code><span class="sig-paren">(</span>__be16<em> proto</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_proto_is_802_3" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a given Ethertype/length is a protocol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__be16</span> <span class="pre">proto</span></code></dt><dd><p>Ethertype/length value to be tested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check that the value from the Ethertype/length field is a valid Ethertype.</p>
<p>Return true if the valid is an 802.3 supported Ethertype.</p>
</div>
<dl class="function">
<dt id="c.eth_random_addr">
void <code class="sig-name descname">eth_random_addr</code><span class="sig-paren">(</span>u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_random_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate software assigned random Ethernet address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate a random Ethernet address (MAC) that is not multicast
and has the local assigned bit set.</p>
</div>
<dl class="function">
<dt id="c.eth_broadcast_addr">
void <code class="sig-name descname">eth_broadcast_addr</code><span class="sig-paren">(</span>u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_broadcast_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign broadcast address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assign the broadcast address to the given address array.</p>
</div>
<dl class="function">
<dt id="c.eth_zero_addr">
void <code class="sig-name descname">eth_zero_addr</code><span class="sig-paren">(</span>u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_zero_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign zero address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assign the zero address to the given address array.</p>
</div>
<dl class="function">
<dt id="c.eth_hw_addr_random">
void <code class="sig-name descname">eth_hw_addr_random</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_hw_addr_random" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate software assigned random Ethernet and set device flag</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate a random Ethernet address (MAC) to be used by a net device
and set addr_assign_type so the state can be read by sysfs and be
used by userspace.</p>
</div>
<dl class="function">
<dt id="c.eth_hw_addr_crc">
u32 <code class="sig-name descname">eth_hw_addr_crc</code><span class="sig-paren">(</span>struct netdev_hw_addr<em> *ha</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_hw_addr_crc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate CRC from netdev_hw_addr</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_hw_addr</span> <span class="pre">*ha</span></code></dt><dd><p>pointer to hardware address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate CRC from a hardware address as basis for filter hashes.</p>
</div>
<dl class="function">
<dt id="c.ether_addr_copy">
void <code class="sig-name descname">ether_addr_copy</code><span class="sig-paren">(</span>u8<em> *dst</em>, const u8<em> *src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy an Ethernet address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*dst</span></code></dt><dd><p>Pointer to a six-byte array Ethernet address destination</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*src</span></code></dt><dd><p>Pointer to a six-byte array Ethernet address source</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Please note: dst &amp; src must both be aligned to u16.</p>
</div>
<dl class="function">
<dt id="c.eth_hw_addr_set">
void <code class="sig-name descname">eth_hw_addr_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, const u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_hw_addr_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign Ethernet address to a net_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to net_device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>address to assign</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assign given address to the net_device, addr_assign_type is not changed.</p>
</div>
<dl class="function">
<dt id="c.eth_hw_addr_inherit">
void <code class="sig-name descname">eth_hw_addr_inherit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dst</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_hw_addr_inherit" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy dev_addr from another net_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dst</span></code></dt><dd><p>pointer to net_device to copy dev_addr to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*src</span></code></dt><dd><p>pointer to net_device to copy dev_addr from</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the Ethernet address from one net_device to another along with
the address attributes (addr_assign_type).</p>
</div>
<dl class="function">
<dt id="c.ether_addr_equal">
bool <code class="sig-name descname">ether_addr_equal</code><span class="sig-paren">(</span>const u8<em> *addr1</em>, const u8<em> *addr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet addresses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr1</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr2</span></code></dt><dd><p>Pointer other six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses, returns true if equal</p>
<p>Please note: addr1 &amp; addr2 must both be aligned to u16.</p>
</div>
<dl class="function">
<dt id="c.ether_addr_equal_64bits">
bool <code class="sig-name descname">ether_addr_equal_64bits</code><span class="sig-paren">(</span>const u8<em> *addr1</em>, const u8<em> *addr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal_64bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet addresses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr1</span></code></dt><dd><p>Pointer to an array of 8 bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr2</span></code></dt><dd><p>Pointer to an other array of 8 bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses, returns true if equal, false otherwise.</p>
<p>The function doesn’t need any conditional branches and possibly uses
word memory accesses on CPU allowing cheap unaligned memory reads.
arrays = { byte1, byte2, byte3, byte4, byte5, byte6, pad1, pad2 }</p>
<p>Please note that alignment of addr1 &amp; addr2 are only guaranteed to be 16 bits.</p>
</div>
<dl class="function">
<dt id="c.ether_addr_equal_unaligned">
bool <code class="sig-name descname">ether_addr_equal_unaligned</code><span class="sig-paren">(</span>const u8<em> *addr1</em>, const u8<em> *addr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal_unaligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two not u16 aligned Ethernet addresses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr1</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr2</span></code></dt><dd><p>Pointer other six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses, returns true if equal</p>
<p>Please note: Use only when any Ethernet address may not be u16 aligned.</p>
</div>
<dl class="function">
<dt id="c.ether_addr_equal_masked">
bool <code class="sig-name descname">ether_addr_equal_masked</code><span class="sig-paren">(</span>const u8<em> *addr1</em>, const u8<em> *addr2</em>, const u8<em> *mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal_masked" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet addresses with a mask</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr1</span></code></dt><dd><p>Pointer to a six-byte array containing the 1st Ethernet address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr2</span></code></dt><dd><p>Pointer to a six-byte array containing the 2nd Ethernet address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*mask</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address bitmask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses with a mask, returns true if for every bit
set in the bitmask the equivalent bits in the ethernet addresses are equal.
Using a mask with all bits set is a slower ether_addr_equal.</p>
</div>
<dl class="function">
<dt id="c.ether_addr_to_u64">
u64 <code class="sig-name descname">ether_addr_to_u64</code><span class="sig-paren">(</span>const u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_to_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an Ethernet address into a u64 value.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return a u64 value of the address</p>
</div>
<dl class="function">
<dt id="c.u64_to_ether_addr">
void <code class="sig-name descname">u64_to_ether_addr</code><span class="sig-paren">(</span>u64<em> u</em>, u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.u64_to_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a u64 to an Ethernet address.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">u</span></code></dt><dd><p>u64 to convert to an Ethernet MAC address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array to contain the Ethernet address</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.eth_addr_dec">
void <code class="sig-name descname">eth_addr_dec</code><span class="sig-paren">(</span>u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_addr_dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement the given MAC address</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing Ethernet address to decrement</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.eth_addr_inc">
void <code class="sig-name descname">eth_addr_inc</code><span class="sig-paren">(</span>u8<em> *addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_addr_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the given MAC address.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*addr</span></code></dt><dd><p>Pointer to a six-byte array containing Ethernet address to increment.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.is_etherdev_addr">
bool <code class="sig-name descname">is_etherdev_addr</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, const u8 addr[6 +<em> 2]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_etherdev_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell if given Ethernet address belongs to the device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>Pointer to a device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">addr[6</span> <span class="pre">+</span> <span class="pre">2]</span></code></dt><dd><p>Pointer to a six-byte array containing the Ethernet address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare passed address with all addresses of the device. Return true if the
address if one of the device addresses.</p>
<p>Note that this function calls <a class="reference internal" href="#c.ether_addr_equal_64bits" title="ether_addr_equal_64bits"><code class="xref c c-func docutils literal notranslate"><span class="pre">ether_addr_equal_64bits()</span></code></a> so take care of
the right padding.</p>
</div>
<dl class="function">
<dt id="c.compare_ether_header">
unsigned long <code class="sig-name descname">compare_ether_header</code><span class="sig-paren">(</span>const void<em> *a</em>, const void<em> *b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.compare_ether_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet headers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*a</span></code></dt><dd><p>Pointer to Ethernet header</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*b</span></code></dt><dd><p>Pointer to Ethernet header</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet headers, returns 0 if equal.
This assumes that the network header (i.e., IP header) is 4-byte
aligned OR the platform can handle unaligned access.  This is the
case for all packets coming into netif_receive_skb or similar
entry points.</p>
</div>
<dl class="function">
<dt id="c.eth_hw_addr_gen">
void <code class="sig-name descname">eth_hw_addr_gen</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, const u8<em> *base_addr</em>, unsigned int<em> id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_hw_addr_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate and assign Ethernet address to a port</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to port’s net_device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*base_addr</span></code></dt><dd><p>base Ethernet address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt><dd><p>offset to add to the base address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate a MAC address using a base address and an offset and assign it
to a net_device. Commonly used by switch drivers which need to compute
addresses for all their ports. addr_assign_type is not changed.</p>
</div>
<dl class="function">
<dt id="c.eth_skb_pad">
int <code class="sig-name descname">eth_skb_pad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_skb_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad buffer to mininum number of octets for Ethernet frame</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>Buffer to pad</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An Ethernet frame should have a minimum size of 60 bytes.  This function
takes short frames and pads them with zeros up to the 60 byte limit.</p>
</div>
<dl class="function">
<dt id="c.napi_schedule">
void <code class="sig-name descname">napi_schedule</code><span class="sig-paren">(</span>struct napi_struct<em> *n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule NAPI poll</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule NAPI poll routine to be called if it is not already
running.</p>
</div>
<dl class="function">
<dt id="c.napi_schedule_irqoff">
void <code class="sig-name descname">napi_schedule_irqoff</code><span class="sig-paren">(</span>struct napi_struct<em> *n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_schedule_irqoff" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule NAPI poll</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Variant of <a class="reference internal" href="#c.napi_schedule" title="napi_schedule"><code class="xref c c-func docutils literal notranslate"><span class="pre">napi_schedule()</span></code></a>, assuming hard irqs are masked.</p>
</div>
<dl class="function">
<dt id="c.napi_complete">
bool <code class="sig-name descname">napi_complete</code><span class="sig-paren">(</span>struct napi_struct<em> *n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>NAPI processing complete</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark NAPI processing as complete.
Consider using napi_complete_done() instead.
Return false if device should avoid rearming interrupts.</p>
</div>
<dl class="function">
<dt id="c.napi_disable">
void <code class="sig-name descname">napi_disable</code><span class="sig-paren">(</span>struct napi_struct<em> *n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>prevent NAPI from scheduling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop NAPI from being scheduled on this context.
Waits till any outstanding processing completes.</p>
</div>
<dl class="function">
<dt id="c.napi_synchronize">
void <code class="sig-name descname">napi_synchronize</code><span class="sig-paren">(</span>const struct napi_struct<em> *n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_synchronize" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until NAPI is not running</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until NAPI is done being scheduled on this context.
Waits till any outstanding processing completes but
does not disable future activations.</p>
</div>
<dl class="function">
<dt id="c.napi_if_scheduled_mark_missed">
bool <code class="sig-name descname">napi_if_scheduled_mark_missed</code><span class="sig-paren">(</span>struct napi_struct<em> *n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_if_scheduled_mark_missed" title="Permalink to this definition">¶</a></dt>
<dd><p>if napi is running, set the NAPIF_STATE_MISSED</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*n</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If napi is running, set the NAPIF_STATE_MISSED, and return true if
NAPI is scheduled.</p>
</div>
<dl class="type">
<dt id="c.netdev_priv_flags">
enum <code class="sig-name descname">netdev_priv_flags</code><a class="headerlink" href="#c.netdev_priv_flags" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#c.net_device" title="net_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span></code></a> priv_flags</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IFF_802_1Q_VLAN</span></code></dt><dd><p>802.1Q VLAN device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_EBRIDGE</span></code></dt><dd><p>Ethernet bridging device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_BONDING</span></code></dt><dd><p>bonding master or slave</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_ISATAP</span></code></dt><dd><p>ISATAP interface (RFC4214)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_WAN_HDLC</span></code></dt><dd><p>WAN HDLC device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_XMIT_DST_RELEASE</span></code></dt><dd><p>dev_hard_start_xmit() is allowed to
release skb-&gt;dst</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_DONT_BRIDGE</span></code></dt><dd><p>disallow bridging this ether dev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_DISABLE_NETPOLL</span></code></dt><dd><p>disable netpoll at run-time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_MACVLAN_PORT</span></code></dt><dd><p>device used as macvlan port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_BRIDGE_PORT</span></code></dt><dd><p>device used as bridge port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_OVS_DATAPATH</span></code></dt><dd><p>device used as Open vSwitch datapath port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_TX_SKB_SHARING</span></code></dt><dd><p>The interface supports sharing skbs on transmit</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_UNICAST_FLT</span></code></dt><dd><p>Supports unicast filtering</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_TEAM_PORT</span></code></dt><dd><p>device used as team port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_SUPP_NOFCS</span></code></dt><dd><p>device supports sending custom FCS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_LIVE_ADDR_CHANGE</span></code></dt><dd><p>device supports hardware address
change when it’s running</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_MACVLAN</span></code></dt><dd><p>Macvlan device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_XMIT_DST_RELEASE_PERM</span></code></dt><dd><p>IFF_XMIT_DST_RELEASE not taking into account
underlying stacked devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_L3MDEV_MASTER</span></code></dt><dd><p>device is an L3 master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_NO_QUEUE</span></code></dt><dd><p>device can run without qdisc attached</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_OPENVSWITCH</span></code></dt><dd><p>device is a Open vSwitch master</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_L3MDEV_SLAVE</span></code></dt><dd><p>device is enslaved to an L3 master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_TEAM</span></code></dt><dd><p>device is a team device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_RXFH_CONFIGURED</span></code></dt><dd><p>device has had Rx Flow indirection table configured</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_PHONY_HEADROOM</span></code></dt><dd><p>the headroom value is controlled by an external
entity (i.e. the master device for bridged veth)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_MACSEC</span></code></dt><dd><p>device is a MACsec device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_NO_RX_HANDLER</span></code></dt><dd><p>device doesn’t support the rx_handler hook</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_FAILOVER</span></code></dt><dd><p>device is a failover master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_FAILOVER_SLAVE</span></code></dt><dd><p>device is lower dev of a failover master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_L3MDEV_RX_HANDLER</span></code></dt><dd><p>only invoke the rx handler of L3 master device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_NO_ADDRCONF</span></code></dt><dd><p>prevent ipv6 addrconf</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_TX_SKB_NO_LINEAR</span></code></dt><dd><p>device/driver is capable of xmitting frames with
skb_headlen(skb) == 0 (data starts from frag0)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IFF_CHANGE_PROTO_DOWN</span></code></dt><dd><p>device supports setting carrier via IFLA_PROTO_DOWN</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These are the <a class="reference internal" href="#c.net_device" title="net_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span></code></a>, they are only set internally
by drivers and used in the kernel. These flags are invisible to
userspace; this means that the order of these flags can change
during any kernel release.</p>
<p>You should have a pretty good reason to be extending these flags.</p>
<dl class="type">
<dt id="c.net_device">
struct <code class="sig-name descname">net_device</code><a class="headerlink" href="#c.net_device" title="Permalink to this definition">¶</a></dt>
<dd><p>The DEVICE structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct net_device {
    char name[IFNAMSIZ];
    struct netdev_name_node *name_node;
    struct dev_ifalias      __rcu *ifalias;
    unsigned long           mem_end;
    unsigned long           mem_start;
    unsigned long           base_addr;
    unsigned long           state;
    struct list_head        dev_list;
    struct list_head        napi_list;
    struct list_head        unreg_list;
    struct list_head        close_list;
    struct list_head        ptype_all;
    struct list_head        ptype_specific;
    struct {
        struct list_head upper;
        struct list_head lower;
    } adj_list;
    unsigned int            flags;
    unsigned long long      priv_flags;
    const struct net_device_ops *netdev_ops;
    int ifindex;
    unsigned short          gflags;
    unsigned short          hard_header_len;
    unsigned int            mtu;
    unsigned short          needed_headroom;
    unsigned short          needed_tailroom;
    netdev_features_t features;
    netdev_features_t hw_features;
    netdev_features_t wanted_features;
    netdev_features_t vlan_features;
    netdev_features_t hw_enc_features;
    netdev_features_t mpls_features;
    netdev_features_t gso_partial_features;
    unsigned int            min_mtu;
    unsigned int            max_mtu;
    unsigned short          type;
    unsigned char           min_header_len;
    unsigned char           name_assign_type;
    int group;
    struct net_device_stats stats;
    struct net_device_core_stats __percpu *core_stats;
    atomic_t carrier_up_count;
    atomic_t carrier_down_count;
#ifdef CONFIG_WIRELESS_EXT;
    const struct iw_handler_def *wireless_handlers;
    struct iw_public_data   *wireless_data;
#endif;
    const struct ethtool_ops *ethtool_ops;
#ifdef CONFIG_NET_L3_MASTER_DEV;
    const struct l3mdev_ops *l3mdev_ops;
#endif;
#if IS_ENABLED(CONFIG_IPV6);
    const struct ndisc_ops *ndisc_ops;
#endif;
#ifdef CONFIG_XFRM_OFFLOAD;
    const struct xfrmdev_ops *xfrmdev_ops;
#endif;
#if IS_ENABLED(CONFIG_TLS_DEVICE);
    const struct tlsdev_ops *tlsdev_ops;
#endif;
    const struct header_ops *header_ops;
    unsigned char           operstate;
    unsigned char           link_mode;
    unsigned char           if_port;
    unsigned char           dma;
    unsigned char           perm_addr[MAX_ADDR_LEN];
    unsigned char           addr_assign_type;
    unsigned char           addr_len;
    unsigned char           upper_level;
    unsigned char           lower_level;
    unsigned short          neigh_priv_len;
    unsigned short          dev_id;
    unsigned short          dev_port;
    unsigned short          padded;
    spinlock_t addr_list_lock;
    int irq;
    struct netdev_hw_addr_list      uc;
    struct netdev_hw_addr_list      mc;
    struct netdev_hw_addr_list      dev_addrs;
#ifdef CONFIG_SYSFS;
    struct kset             *queues_kset;
#endif;
#ifdef CONFIG_LOCKDEP;
    struct list_head        unlink_list;
#endif;
    unsigned int            promiscuity;
    unsigned int            allmulti;
    bool uc_promisc;
#ifdef CONFIG_LOCKDEP;
    unsigned char           nested_level;
#endif;
    struct in_device __rcu  *ip_ptr;
    struct inet6_dev __rcu  *ip6_ptr;
#if IS_ENABLED(CONFIG_VLAN_8021Q);
    struct vlan_info __rcu  *vlan_info;
#endif;
#if IS_ENABLED(CONFIG_NET_DSA);
    struct dsa_port         *dsa_ptr;
#endif;
#if IS_ENABLED(CONFIG_TIPC);
    struct tipc_bearer __rcu *tipc_ptr;
#endif;
#if IS_ENABLED(CONFIG_ATALK);
    void *atalk_ptr;
#endif;
#if IS_ENABLED(CONFIG_AX25);
    void *ax25_ptr;
#endif;
#if IS_ENABLED(CONFIG_CFG80211);
    struct wireless_dev     *ieee80211_ptr;
#endif;
#if IS_ENABLED(CONFIG_IEEE802154) || IS_ENABLED(CONFIG_6LOWPAN);
    struct wpan_dev         *ieee802154_ptr;
#endif;
#if IS_ENABLED(CONFIG_MPLS_ROUTING);
    struct mpls_dev __rcu   *mpls_ptr;
#endif;
#if IS_ENABLED(CONFIG_MCTP);
    struct mctp_dev __rcu   *mctp_ptr;
#endif;
    const unsigned char     *dev_addr;
    struct netdev_rx_queue  *_rx;
    unsigned int            num_rx_queues;
    unsigned int            real_num_rx_queues;
    struct bpf_prog __rcu   *xdp_prog;
    unsigned long           gro_flush_timeout;
    int napi_defer_hard_irqs;
#define GRO_LEGACY_MAX_SIZE     65536u;
#define GRO_MAX_SIZE            (8 * 65535u);
    unsigned int            gro_max_size;
    rx_handler_func_t __rcu *rx_handler;
    void __rcu              *rx_handler_data;
#ifdef CONFIG_NET_CLS_ACT;
    struct mini_Qdisc __rcu *miniq_ingress;
#endif;
    struct netdev_queue __rcu *ingress_queue;
#ifdef CONFIG_NETFILTER_INGRESS;
    struct nf_hook_entries __rcu *nf_hooks_ingress;
#endif;
    unsigned char           broadcast[MAX_ADDR_LEN];
#ifdef CONFIG_RFS_ACCEL;
    struct cpu_rmap         *rx_cpu_rmap;
#endif;
    struct hlist_node       index_hlist;
    struct netdev_queue     *_tx ;
    unsigned int            num_tx_queues;
    unsigned int            real_num_tx_queues;
    struct Qdisc __rcu      *qdisc;
    unsigned int            tx_queue_len;
    spinlock_t tx_global_lock;
    struct xdp_dev_bulk_queue __percpu *xdp_bulkq;
#ifdef CONFIG_XPS;
    struct xps_dev_maps __rcu *xps_maps[XPS_MAPS_MAX];
#endif;
#ifdef CONFIG_NET_CLS_ACT;
    struct mini_Qdisc __rcu *miniq_egress;
#endif;
#ifdef CONFIG_NETFILTER_EGRESS;
    struct nf_hook_entries __rcu *nf_hooks_egress;
#endif;
#ifdef CONFIG_NET_SCHED;
    unsigned long qdisc_hash[1 &lt;&lt; ((4) - 1)];
#endif;
    struct timer_list       watchdog_timer;
    int watchdog_timeo;
    u32 proto_down_reason;
    struct list_head        todo_list;
#ifdef CONFIG_PCPU_DEV_REFCNT;
    int __percpu            *pcpu_refcnt;
#else;
    refcount_t dev_refcnt;
#endif;
    struct ref_tracker_dir  refcnt_tracker;
    struct list_head        link_watch_list;
    enum {
        NETREG_UNINITIALIZED=0,
        NETREG_REGISTERED,
        NETREG_UNREGISTERING,
        NETREG_UNREGISTERED,
        NETREG_RELEASED,
        NETREG_DUMMY,
    } reg_state:8;
    bool dismantle;
    enum {
        RTNL_LINK_INITIALIZED,
        RTNL_LINK_INITIALIZING,
    } rtnl_link_state:16;
    bool needs_free_netdev;
    void (*priv_destructor)(struct net_device *dev);
#ifdef CONFIG_NETPOLL;
    struct netpoll_info __rcu       *npinfo;
#endif;
    possible_net_t nd_net;
    void *ml_priv;
    enum netdev_ml_priv_type        ml_priv_type;
    union {
        struct pcpu_lstats __percpu             *lstats;
        struct pcpu_sw_netstats __percpu        *tstats;
        struct pcpu_dstats __percpu             *dstats;
    };
#if IS_ENABLED(CONFIG_GARP);
    struct garp_port __rcu  *garp_port;
#endif;
#if IS_ENABLED(CONFIG_MRP);
    struct mrp_port __rcu   *mrp_port;
#endif;
#if IS_ENABLED(CONFIG_NET_DROP_MONITOR);
    struct dm_hw_stat_delta __rcu *dm_private;
#endif;
    struct device           dev;
    const struct attribute_group *sysfs_groups[4];
    const struct attribute_group *sysfs_rx_queue_group;
    const struct rtnl_link_ops *rtnl_link_ops;
#define GSO_MAX_SEGS            65535u;
#define GSO_LEGACY_MAX_SIZE     65536u;
#define GSO_MAX_SIZE            (8 * GSO_MAX_SEGS);
    unsigned int            gso_max_size;
#define TSO_LEGACY_MAX_SIZE     65536;
#define TSO_MAX_SIZE            UINT_MAX;
    unsigned int            tso_max_size;
    u16 gso_max_segs;
#define TSO_MAX_SEGS            U16_MAX;
    u16 tso_max_segs;
#ifdef CONFIG_DCB;
    const struct dcbnl_rtnl_ops *dcbnl_ops;
#endif;
    s16 num_tc;
    struct netdev_tc_txq    tc_to_txq[TC_MAX_QUEUE];
    u8 prio_tc_map[TC_BITMASK + 1];
#if IS_ENABLED(CONFIG_FCOE);
    unsigned int            fcoe_ddp_xid;
#endif;
#if IS_ENABLED(CONFIG_CGROUP_NET_PRIO);
    struct netprio_map __rcu *priomap;
#endif;
    struct phy_device       *phydev;
    struct sfp_bus          *sfp_bus;
    struct lock_class_key   *qdisc_tx_busylock;
    bool proto_down;
    unsigned wol_enabled:1;
    unsigned threaded:1;
    struct list_head        net_notifier_list;
#if IS_ENABLED(CONFIG_MACSEC);
    const struct macsec_ops *macsec_ops;
#endif;
    const struct udp_tunnel_nic_info        *udp_tunnel_nic_info;
    struct udp_tunnel_nic   *udp_tunnel_nic;
    struct bpf_xdp_entity   xdp_state[__MAX_XDP_MODE];
    u8 dev_addr_shadow[MAX_ADDR_LEN];
    netdevice_tracker linkwatch_dev_tracker;
    netdevice_tracker watchdog_dev_tracker;
    netdevice_tracker dev_registered_tracker;
    struct rtnl_hw_stats64  *offload_xstats_l3;
    struct devlink_port     *devlink_port;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>This is the first field of the “visible” part of this structure
(i.e. as seen by users in the “Space.c” file).  It is the name
of the interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name_node</span></code></dt><dd><p>Name hashlist node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ifalias</span></code></dt><dd><p>SNMP alias</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_end</span></code></dt><dd><p>Shared memory end</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mem_start</span></code></dt><dd><p>Shared memory start</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base_addr</span></code></dt><dd><p>Device I/O address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>Generic network queuing layer state, see netdev_state_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_list</span></code></dt><dd><p>The global list of network devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">napi_list</span></code></dt><dd><p>List entry used for polling NAPI devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unreg_list</span></code></dt><dd><p>List entry  when we are unregistering the
device; see the function unregister_netdev</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">close_list</span></code></dt><dd><p>List entry used when we are closing the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptype_all</span></code></dt><dd><p>Device-specific packet handlers for all protocols</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ptype_specific</span></code></dt><dd><p>Device-specific, protocol-specific packet handlers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adj_list</span></code></dt><dd><p>Directly linked devices, like slaves for bonding</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Interface flags (a la BSD)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv_flags</span></code></dt><dd><p>Like ‘flags’ but invisible to userspace,
see if.h for the definitions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netdev_ops</span></code></dt><dd><p>Includes several pointers to callbacks,
if one wants to override the ndo_*() functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ifindex</span></code></dt><dd><p>interface index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gflags</span></code></dt><dd><p>Global flags ( kept as legacy )</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hard_header_len</span></code></dt><dd><p>Maximum hardware header length.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mtu</span></code></dt><dd><p>Interface MTU value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needed_headroom</span></code></dt><dd><p>Extra headroom the hardware may need, but not in all
cases can this be guaranteed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needed_tailroom</span></code></dt><dd><p>Extra tailroom the hardware may need, but not in all
cases can this be guaranteed. Some cases also use
LL_MAX_HEADER instead to allocate the skb</p>
<blockquote>
<div><p>interface address info:</p>
</div></blockquote>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">features</span></code></dt><dd><p>Currently active device features</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_features</span></code></dt><dd><p>User-changeable features</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wanted_features</span></code></dt><dd><p>User-requested features</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_features</span></code></dt><dd><p>Mask of features inheritable by VLAN devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hw_enc_features</span></code></dt><dd><p>Mask of features inherited by encapsulating devices
This field indicates what encapsulation
offloads the hardware is capable of doing,
and drivers will need to set them appropriately.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mpls_features</span></code></dt><dd><p>Mask of features inheritable by MPLS</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gso_partial_features</span></code></dt><dd><p>value(s) from NETIF_F_GSO*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_mtu</span></code></dt><dd><p>Interface Minimum MTU value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_mtu</span></code></dt><dd><p>Interface Maximum MTU value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Interface hardware type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_header_len</span></code></dt><dd><p>Minimum hardware header length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name_assign_type</span></code></dt><dd><p>network interface name assignment type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">group</span></code></dt><dd><p>The group the device belongs to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats</span></code></dt><dd><p>Statistics struct, which was left as a legacy, use
rtnl_link_stats64 instead</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">core_stats</span></code></dt><dd><p>core networking counters,
do not use this in drivers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">carrier_up_count</span></code></dt><dd><p>Number of times the carrier has been up</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">carrier_down_count</span></code></dt><dd><p>Number of times the carrier has been down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wireless_handlers</span></code></dt><dd><p>List of functions to handle Wireless Extensions,
instead of ioctl,
see &lt;net/iw_handler.h&gt; for details.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wireless_data</span></code></dt><dd><p>Instance data managed by the core of wireless extensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ethtool_ops</span></code></dt><dd><p>Management operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l3mdev_ops</span></code></dt><dd><p>Layer 3 master device operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ndisc_ops</span></code></dt><dd><p>Includes callbacks for different IPv6 neighbour
discovery handling. Necessary for e.g. 6LoWPAN.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xfrmdev_ops</span></code></dt><dd><p>Transformation offload operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tlsdev_ops</span></code></dt><dd><p>Transport Layer Security offload operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header_ops</span></code></dt><dd><p>Includes callbacks for creating,parsing,caching,etc
of Layer 2 headers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">operstate</span></code></dt><dd><p>RFC2863 operstate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_mode</span></code></dt><dd><p>Mapping policy to operstate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">if_port</span></code></dt><dd><p>Selectable AUI, TP, …</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma</span></code></dt><dd><p>DMA channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">perm_addr</span></code></dt><dd><p>Permanent hw address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_assign_type</span></code></dt><dd><p>Hw address assignment type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_len</span></code></dt><dd><p>Hardware address length</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">upper_level</span></code></dt><dd><p>Maximum depth level of upper devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lower_level</span></code></dt><dd><p>Maximum depth level of lower devices.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">neigh_priv_len</span></code></dt><dd><p>Used in neigh_alloc()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_id</span></code></dt><dd><p>Used to differentiate devices that share
the same link layer address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_port</span></code></dt><dd><p>Used to differentiate devices that share
the same function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">padded</span></code></dt><dd><p>How much padding added by alloc_netdev()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_list_lock</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>Device IRQ number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uc</span></code></dt><dd><p>unicast mac addresses</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mc</span></code></dt><dd><p>multicast mac addresses</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_addrs</span></code></dt><dd><p>list of device hw addresses</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">queues_kset</span></code></dt><dd><p>Group of all Kobjects in the Tx and RX queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unlink_list</span></code></dt><dd><p>As netif_addr_lock() can be called recursively,
keep a list of interfaces to be deleted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">promiscuity</span></code></dt><dd><p>Number of times the NIC is told to work in
promiscuous mode; if it becomes 0 the NIC will
exit promiscuous mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">allmulti</span></code></dt><dd><p>Counter, enables or disables allmulticast mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uc_promisc</span></code></dt><dd><p>Counter that indicates promiscuous mode
has been enabled due to the need to listen to
additional unicast addresses in a device that
does not implement ndo_set_rx_mode()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nested_level</span></code></dt><dd><p>Used as a parameter of spin_lock_nested() of
dev-&gt;addr_list_lock.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ip_ptr</span></code></dt><dd><p>IPv4 specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ip6_ptr</span></code></dt><dd><p>IPv6 specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vlan_info</span></code></dt><dd><p>VLAN info</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dsa_ptr</span></code></dt><dd><p>dsa specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tipc_ptr</span></code></dt><dd><p>TIPC specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">atalk_ptr</span></code></dt><dd><p>AppleTalk link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ax25_ptr</span></code></dt><dd><p>AX.25 specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ieee80211_ptr</span></code></dt><dd><p>IEEE 802.11 specific data, assign before registering</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ieee802154_ptr</span></code></dt><dd><p>IEEE 802.15.4 low-rate Wireless Personal Area Network
device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mpls_ptr</span></code></dt><dd><p>mpls_dev struct pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mctp_ptr</span></code></dt><dd><p>MCTP specific data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_addr</span></code></dt><dd><p>Hw address (before bcast,
because most packets are unicast)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_rx</span></code></dt><dd><p>Array of RX queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_rx_queues</span></code></dt><dd><p>Number of RX queues
allocated at <a class="reference internal" href="#c.register_netdev" title="register_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_netdev()</span></code></a> time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">real_num_rx_queues</span></code></dt><dd><p>Number of RX queues currently active in device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xdp_prog</span></code></dt><dd><p>XDP sockets filter program pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gro_flush_timeout</span></code></dt><dd><p>timeout for GRO layer in NAPI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">napi_defer_hard_irqs</span></code></dt><dd><p>If not zero, provides a counter that would
allow to avoid NIC hard IRQ, on busy queues.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gro_max_size</span></code></dt><dd><p>Maximum size of aggregated packet in generic
receive offload (GRO)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_handler</span></code></dt><dd><p>handler for received packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_handler_data</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">miniq_ingress</span></code></dt><dd><p>ingress/clsact qdisc specific data for
ingress processing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ingress_queue</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nf_hooks_ingress</span></code></dt><dd><p>netfilter hooks executed for ingress packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">broadcast</span></code></dt><dd><p>hw bcast address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rx_cpu_rmap</span></code></dt><dd><p>CPU reverse-mapping for RX completion interrupts,
indexed by RX queue number. Assigned by driver.
This must only be set if the ndo_rx_flow_steer
operation is defined</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">index_hlist</span></code></dt><dd><p>Device index hash chain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_tx</span></code></dt><dd><p>Array of TX queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_tx_queues</span></code></dt><dd><p>Number of TX queues allocated at alloc_netdev_mq() time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">real_num_tx_queues</span></code></dt><dd><p>Number of TX queues currently active in device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qdisc</span></code></dt><dd><p>Root qdisc from userspace point of view</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_queue_len</span></code></dt><dd><p>Max frames per queue allowed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tx_global_lock</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xdp_bulkq</span></code></dt><dd><p>XDP device bulk queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xps_maps</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">miniq_egress</span></code></dt><dd><p>clsact qdisc specific data for
egress processing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nf_hooks_egress</span></code></dt><dd><p>netfilter hooks executed for egress packets</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qdisc_hash</span></code></dt><dd><p>qdisc hash table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">watchdog_timer</span></code></dt><dd><p>List of timers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">watchdog_timeo</span></code></dt><dd><p>Represents the timeout that is used by
the watchdog (see dev_watchdog())</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proto_down_reason</span></code></dt><dd><p>reason a netdev interface is held down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">todo_list</span></code></dt><dd><p>Delayed register/unregister</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcpu_refcnt</span></code></dt><dd><p>Number of references to this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_refcnt</span></code></dt><dd><p>Number of references to this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcnt_tracker</span></code></dt><dd><p>Tracker directory for tracked references to this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_watch_list</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reg_state</span></code></dt><dd><p>Register/unregister state machine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dismantle</span></code></dt><dd><p>Device is going to be freed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtnl_link_state</span></code></dt><dd><p>This enum represents the phases of creating
a new link</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">needs_free_netdev</span></code></dt><dd><p>Should unregister perform free_netdev?</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv_destructor</span></code></dt><dd><p>Called from unregister</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">npinfo</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nd_net</span></code></dt><dd><p>Network namespace this network device is inside</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ml_priv</span></code></dt><dd><p>Mid-layer private</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ml_priv_type</span></code></dt><dd><p>Mid-layer private type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lstats</span></code></dt><dd><p>Loopback statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tstats</span></code></dt><dd><p>Tunnel statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dstats</span></code></dt><dd><p>Dummy statistics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">garp_port</span></code></dt><dd><p>GARP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mrp_port</span></code></dt><dd><p>MRP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dm_private</span></code></dt><dd><p>Drop monitor private</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Class/net/name entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs_groups</span></code></dt><dd><p>Space for optional device, statistics and wireless
sysfs groups</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs_rx_queue_group</span></code></dt><dd><p>Space for optional per-rx queue attributes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rtnl_link_ops</span></code></dt><dd><p>Rtnl_link_ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gso_max_size</span></code></dt><dd><p>Maximum size of generic segmentation offload</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tso_max_size</span></code></dt><dd><p>Device (as in HW) limit on the max TSO request size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gso_max_segs</span></code></dt><dd><p>Maximum number of segments that can be passed to the
NIC for GSO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tso_max_segs</span></code></dt><dd><p>Device (as in HW) limit on the max TSO segment count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dcbnl_ops</span></code></dt><dd><p>Data Center Bridging netlink ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_tc</span></code></dt><dd><p>Number of traffic classes in the net device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tc_to_txq</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prio_tc_map</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fcoe_ddp_xid</span></code></dt><dd><p>Max exchange id for FCoE LRO by ddp</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priomap</span></code></dt><dd><p>XXX: need comments on this one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phydev</span></code></dt><dd><p>Physical device may attach itself
for hardware timestamping</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sfp_bus</span></code></dt><dd><p>attached <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">qdisc_tx_busylock</span></code></dt><dd><p>lockdep class annotating Qdisc-&gt;busylock spinlock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proto_down</span></code></dt><dd><p>protocol port state information can be sent to the
switch driver and used to set the phys state of the
switch port.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">wol_enabled</span></code></dt><dd><p>Wake-on-LAN is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">threaded</span></code></dt><dd><p>napi threaded mode is enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">net_notifier_list</span></code></dt><dd><p>List of per-net netdev notifier block
that follow this device when it is moved
to another network namespace.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">macsec_ops</span></code></dt><dd><p>MACsec offloading ops</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">udp_tunnel_nic_info</span></code></dt><dd><p>static structure describing the UDP tunnel
offload capabilities of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">udp_tunnel_nic</span></code></dt><dd><p>UDP tunnel offload state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xdp_state</span></code></dt><dd><p>stores info on attached XDP BPF programs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_addr_shadow</span></code></dt><dd><p>Copy of <strong>dev_addr</strong> to catch direct writes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">linkwatch_dev_tracker</span></code></dt><dd><p>refcount tracker used by linkwatch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">watchdog_dev_tracker</span></code></dt><dd><p>refcount tracker used by watchdog.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_registered_tracker</span></code></dt><dd><p>tracker for reference held while
registered</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">offload_xstats_l3</span></code></dt><dd><p>L3 HW stats for this netdevice.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devlink_port</span></code></dt><dd><p>Pointer to related devlink port structure.
Assigned by a driver before netdev registration using
SET_NETDEV_DEVLINK_PORT macro. This pointer is static
during the time netdevice is registered.</p>
<blockquote>
<div><p>FIXME: cleanup <a class="reference internal" href="#c.net_device" title="net_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span></code></a> such that network protocol info
moves out.</p>
</div></blockquote>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Actually, this whole structure is a big mistake.  It mixes I/O
data with strictly “high-level” data, and it has to know about
almost every data structure used in the INET module.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_priv">
void * <code class="sig-name descname">netdev_priv</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>access network device private data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get network device private data</p>
</div>
<dl class="function">
<dt id="c.netif_napi_add">
void <code class="sig-name descname">netif_napi_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct napi_struct<em> *napi</em>, int (<em>*poll</em>)(struct napi_struct *, int)<span class="sig-paren">)</span><a class="headerlink" href="#c.netif_napi_add" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a NAPI context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*napi</span></code></dt><dd><p>NAPI context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*poll)(struct</span> <span class="pre">napi_struct</span> <span class="pre">*,</span> <span class="pre">int)</span></code></dt><dd><p>polling function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.netif_napi_add" title="netif_napi_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_napi_add()</span></code></a> must be used to initialize a NAPI context prior to calling
<em>any</em> of the other NAPI-related functions.</p>
</div>
<dl class="function">
<dt id="c.netif_napi_add_tx">
void <code class="sig-name descname">netif_napi_add_tx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct napi_struct<em> *napi</em>, int (<em>*poll</em>)(struct napi_struct *, int)<span class="sig-paren">)</span><a class="headerlink" href="#c.netif_napi_add_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a NAPI context to be used for Tx only</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*napi</span></code></dt><dd><p>NAPI context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*poll)(struct</span> <span class="pre">napi_struct</span> <span class="pre">*,</span> <span class="pre">int)</span></code></dt><dd><p>polling function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant of <a class="reference internal" href="#c.netif_napi_add" title="netif_napi_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_napi_add()</span></code></a> should be used from drivers using NAPI
to exclusively poll a TX queue.
This will avoid we add it into napi_hash[], thus polluting this hash table.</p>
</div>
<dl class="function">
<dt id="c.__netif_napi_del">
void <code class="sig-name descname">__netif_napi_del</code><span class="sig-paren">(</span>struct napi_struct<em> *napi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__netif_napi_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a NAPI context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*napi</span></code></dt><dd><p>NAPI context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Warning: caller must observe RCU grace period before freeing memory
containing <strong>napi</strong>. Drivers might want to call this helper to combine
all the needed RCU grace periods into a single one.</p>
</div>
<dl class="function">
<dt id="c.netif_napi_del">
void <code class="sig-name descname">netif_napi_del</code><span class="sig-paren">(</span>struct napi_struct<em> *napi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_napi_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a NAPI context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*napi</span></code></dt><dd><p>NAPI context</p>
<p><a class="reference internal" href="#c.netif_napi_del" title="netif_napi_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">netif_napi_del()</span></code></a> removes a NAPI context from the network device NAPI list</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_start_queue">
void <code class="sig-name descname">netif_start_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_start_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>allow transmit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
<p>Allow upper layers to call the device hard_start_xmit routine.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_wake_queue">
void <code class="sig-name descname">netif_wake_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_wake_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>restart transmit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
<p>Allow upper layers to call the device hard_start_xmit routine.
Used for flow control when transmit resources are available.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_stop_queue">
void <code class="sig-name descname">netif_stop_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_stop_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>stop transmitted packets</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
<p>Stop upper layers calling the device hard_start_xmit routine.
Used for flow control when transmit resources are unavailable.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_queue_stopped">
bool <code class="sig-name descname">netif_queue_stopped</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_queue_stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>test if transmit queue is flowblocked</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
<p>Test if transmit queue on device is currently unable to send.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_queue_set_dql_min_limit">
void <code class="sig-name descname">netdev_queue_set_dql_min_limit</code><span class="sig-paren">(</span>struct netdev_queue<em> *dev_queue</em>, unsigned int<em> min_limit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_queue_set_dql_min_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>set dql minimum limit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_queue</span> <span class="pre">*dev_queue</span></code></dt><dd><p>pointer to transmit queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min_limit</span></code></dt><dd><p>dql minimum limit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forces xmit_more() to return true until the minimum threshold
defined by <strong>min_limit</strong> is reached (or until the tx queue is
empty). Warning: to be use with care, misuse will impact the
latency.</p>
</div>
<dl class="function">
<dt id="c.netdev_txq_bql_enqueue_prefetchw">
void <code class="sig-name descname">netdev_txq_bql_enqueue_prefetchw</code><span class="sig-paren">(</span>struct netdev_queue<em> *dev_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_txq_bql_enqueue_prefetchw" title="Permalink to this definition">¶</a></dt>
<dd><p>prefetch bql data for write</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_queue</span> <span class="pre">*dev_queue</span></code></dt><dd><p>pointer to transmit queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>BQL enabled drivers might use this helper in their ndo_start_xmit(),
to give appropriate hint to the CPU.</p>
</div>
<dl class="function">
<dt id="c.netdev_txq_bql_complete_prefetchw">
void <code class="sig-name descname">netdev_txq_bql_complete_prefetchw</code><span class="sig-paren">(</span>struct netdev_queue<em> *dev_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_txq_bql_complete_prefetchw" title="Permalink to this definition">¶</a></dt>
<dd><p>prefetch bql data for write</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_queue</span> <span class="pre">*dev_queue</span></code></dt><dd><p>pointer to transmit queue</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>BQL enabled drivers might use this helper in their TX completion path,
to give appropriate hint to the CPU.</p>
</div>
<dl class="function">
<dt id="c.netdev_tx_sent_queue">
void <code class="sig-name descname">netdev_tx_sent_queue</code><span class="sig-paren">(</span>struct netdev_queue<em> *dev_queue</em>, unsigned int<em> bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_tx_sent_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>report the number of bytes queued to a given tx queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_queue</span> <span class="pre">*dev_queue</span></code></dt><dd><p>network device queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bytes</span></code></dt><dd><p>number of bytes queued to the device queue</p>
<p>Report the number of bytes queued for sending/completion to the network
device hardware queue. <strong>bytes</strong> should be a good approximation and should
exactly match <a class="reference internal" href="#c.netdev_completed_queue" title="netdev_completed_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">netdev_completed_queue()</span></code></a> <strong>bytes</strong>.
This is typically called once per packet, from ndo_start_xmit().</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_sent_queue">
void <code class="sig-name descname">netdev_sent_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, unsigned int<em> bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_sent_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>report the number of bytes queued to hardware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bytes</span></code></dt><dd><p>number of bytes queued to the hardware device queue</p>
<p>Report the number of bytes queued for sending/completion to the network
device hardware queue#0. <strong>bytes</strong> should be a good approximation and should
exactly match <a class="reference internal" href="#c.netdev_completed_queue" title="netdev_completed_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">netdev_completed_queue()</span></code></a> <strong>bytes</strong>.
This is typically called once per packet, from ndo_start_xmit().</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_tx_completed_queue">
void <code class="sig-name descname">netdev_tx_completed_queue</code><span class="sig-paren">(</span>struct netdev_queue<em> *dev_queue</em>, unsigned int<em> pkts</em>, unsigned int<em> bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_tx_completed_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>report number of packets/bytes at TX completion.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netdev_queue</span> <span class="pre">*dev_queue</span></code></dt><dd><p>network device queue</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pkts</span></code></dt><dd><p>number of packets (currently ignored)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bytes</span></code></dt><dd><p>number of bytes dequeued from the device queue</p>
<p>Must be called at most once per TX completion round (and not per
individual packet), so that BQL can adjust its limits appropriately.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_completed_queue">
void <code class="sig-name descname">netdev_completed_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, unsigned int<em> pkts</em>, unsigned int<em> bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_completed_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>report bytes and packets completed by device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pkts</span></code></dt><dd><p>actual number of packets sent over the medium</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bytes</span></code></dt><dd><p>actual number of bytes sent over the medium</p>
<p>Report the number of bytes and packets transmitted by the network device
hardware queue over the physical medium, <strong>bytes</strong> must exactly match the
<strong>bytes</strong> amount passed to <a class="reference internal" href="#c.netdev_sent_queue" title="netdev_sent_queue"><code class="xref c c-func docutils literal notranslate"><span class="pre">netdev_sent_queue()</span></code></a></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_reset_queue">
void <code class="sig-name descname">netdev_reset_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_reset_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the packets and bytes count of a network device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev_queue</span></code></dt><dd><p>network device</p>
<p>Reset the bytes and packet count of a network device and clear the
software flow control OFF bit for this network device</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netdev_cap_txqueue">
u16 <code class="sig-name descname">netdev_cap_txqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, u16<em> queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_cap_txqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>check if selected tx queue exceeds device queues</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt><dd><p>given tx queue index</p>
<p>Returns 0 if given tx queue index &gt;= number of device tx queues,
otherwise returns the originally passed tx queue index.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_running">
bool <code class="sig-name descname">netif_running</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_running" title="Permalink to this definition">¶</a></dt>
<dd><p>test if up</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
<p>Test if the device has been brought up.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.netif_start_subqueue">
void <code class="sig-name descname">netif_start_subqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, u16<em> queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_start_subqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>allow sending packets on subqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt><dd><p>sub queue index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start individual transmit queue of a device with multiple transmit queues.</p>
</div>
<dl class="function">
<dt id="c.netif_stop_subqueue">
void <code class="sig-name descname">netif_stop_subqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, u16<em> queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_stop_subqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>stop sending packets on subqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt><dd><p>sub queue index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop individual transmit queue of a device with multiple transmit queues.</p>
</div>
<dl class="function">
<dt id="c.__netif_subqueue_stopped">
bool <code class="sig-name descname">__netif_subqueue_stopped</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, u16<em> queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__netif_subqueue_stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>test status of subqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt><dd><p>sub queue index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check individual transmit queue of a device with multiple transmit queues.</p>
</div>
<dl class="function">
<dt id="c.netif_subqueue_stopped">
bool <code class="sig-name descname">netif_subqueue_stopped</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_subqueue_stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>test status of subqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>sub queue buffer pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check individual transmit queue of a device with multiple transmit queues.</p>
</div>
<dl class="function">
<dt id="c.netif_wake_subqueue">
void <code class="sig-name descname">netif_wake_subqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, u16<em> queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_wake_subqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>allow sending packets on subqueue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt><dd><p>sub queue index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resume individual transmit queue of a device with multiple transmit queues.</p>
</div>
<dl class="function">
<dt id="c.netif_attr_test_mask">
bool <code class="sig-name descname">netif_attr_test_mask</code><span class="sig-paren">(</span>unsigned long<em> j</em>, const unsigned long<em> *mask</em>, unsigned int<em> nr_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_attr_test_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Test a CPU or Rx queue set in a mask</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>CPU/Rx queue index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*mask</span></code></dt><dd><p>bitmask of all cpus/rx queues</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bits</span></code></dt><dd><p>number of bits in the bitmask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test if a CPU or Rx queue index is set in a mask of all CPU/Rx queues.</p>
</div>
<dl class="function">
<dt id="c.netif_attr_test_online">
bool <code class="sig-name descname">netif_attr_test_online</code><span class="sig-paren">(</span>unsigned long<em> j</em>, const unsigned long<em> *online_mask</em>, unsigned int<em> nr_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_attr_test_online" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for online CPU/Rx queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt><dd><p>CPU/Rx queue index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*online_mask</span></code></dt><dd><p>bitmask for CPUs/Rx queues that are online</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bits</span></code></dt><dd><p>number of bits in the bitmask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if a CPU/Rx queue is online.</p>
</div>
<dl class="function">
<dt id="c.netif_attrmask_next">
unsigned int <code class="sig-name descname">netif_attrmask_next</code><span class="sig-paren">(</span>int<em> n</em>, const unsigned long<em> *srcp</em>, unsigned int<em> nr_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_attrmask_next" title="Permalink to this definition">¶</a></dt>
<dd><p>get the next CPU/Rx queue in a cpu/Rx queues mask</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n</span></code></dt><dd><p>CPU/Rx queue index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*srcp</span></code></dt><dd><p>the cpumask/Rx queue mask pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bits</span></code></dt><dd><p>number of bits in the bitmask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns &gt;= nr_bits if no further CPUs/Rx queues set.</p>
</div>
<dl class="function">
<dt id="c.netif_attrmask_next_and">
int <code class="sig-name descname">netif_attrmask_next_and</code><span class="sig-paren">(</span>int<em> n</em>, const unsigned long<em> *src1p</em>, const unsigned long<em> *src2p</em>, unsigned int<em> nr_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_attrmask_next_and" title="Permalink to this definition">¶</a></dt>
<dd><p>get the next CPU/Rx queue in *src1p &amp; *src2p</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">n</span></code></dt><dd><p>CPU/Rx queue index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src1p</span></code></dt><dd><p>the first CPUs/Rx queues mask pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*src2p</span></code></dt><dd><p>the second CPUs/Rx queues mask pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bits</span></code></dt><dd><p>number of bits in the bitmask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns &gt;= nr_bits if no further CPUs/Rx queues set in both.</p>
</div>
<dl class="function">
<dt id="c.netif_is_multiqueue">
bool <code class="sig-name descname">netif_is_multiqueue</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_is_multiqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>test if device has multiple transmit queues</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if device has multiple transmit queues</p>
</div>
<dl class="function">
<dt id="c.dev_hold">
void <code class="sig-name descname">dev_hold</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_hold" title="Permalink to this definition">¶</a></dt>
<dd><p>get reference to device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hold reference to device to keep it from being freed.
Try using netdev_hold() instead.</p>
</div>
<dl class="function">
<dt id="c.dev_put">
void <code class="sig-name descname">dev_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release reference to device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release reference to device to allow it to be freed.
Try using netdev_put() instead.</p>
</div>
<dl class="function">
<dt id="c.netif_carrier_ok">
bool <code class="sig-name descname">netif_carrier_ok</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_carrier_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>test if carrier present</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if carrier is present on device</p>
</div>
<dl class="function">
<dt id="c.netif_dormant_on">
void <code class="sig-name descname">netif_dormant_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_dormant_on" title="Permalink to this definition">¶</a></dt>
<dd><p>mark device as dormant.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark device as dormant (as per RFC2863).</p>
<p>The dormant state indicates that the relevant interface is not
actually in a condition to pass packets (i.e., it is not ‘up’) but is
in a “pending” state, waiting for some external event.  For “on-
demand” interfaces, this new state identifies the situation where the
interface is waiting for events to place it in the up state.</p>
</div>
<dl class="function">
<dt id="c.netif_dormant_off">
void <code class="sig-name descname">netif_dormant_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_dormant_off" title="Permalink to this definition">¶</a></dt>
<dd><p>set device as not dormant.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device is not in dormant state.</p>
</div>
<dl class="function">
<dt id="c.netif_dormant">
bool <code class="sig-name descname">netif_dormant</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_dormant" title="Permalink to this definition">¶</a></dt>
<dd><p>test if device is dormant</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if device is dormant.</p>
</div>
<dl class="function">
<dt id="c.netif_testing_on">
void <code class="sig-name descname">netif_testing_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_testing_on" title="Permalink to this definition">¶</a></dt>
<dd><p>mark device as under test.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark device as under test (as per RFC2863).</p>
<p>The testing state indicates that some test(s) must be performed on
the interface. After completion, of the test, the interface state
will change to up, dormant, or down, as appropriate.</p>
</div>
<dl class="function">
<dt id="c.netif_testing_off">
void <code class="sig-name descname">netif_testing_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_testing_off" title="Permalink to this definition">¶</a></dt>
<dd><p>set device as not under test.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device is not in testing state.</p>
</div>
<dl class="function">
<dt id="c.netif_testing">
bool <code class="sig-name descname">netif_testing</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_testing" title="Permalink to this definition">¶</a></dt>
<dd><p>test if device is under test</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if device is under test</p>
</div>
<dl class="function">
<dt id="c.netif_oper_up">
bool <code class="sig-name descname">netif_oper_up</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_oper_up" title="Permalink to this definition">¶</a></dt>
<dd><p>test if device is operational</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if carrier is operational</p>
</div>
<dl class="function">
<dt id="c.netif_device_present">
bool <code class="sig-name descname">netif_device_present</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_device_present" title="Permalink to this definition">¶</a></dt>
<dd><p>is device available or removed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if device has not been removed from system.</p>
</div>
<dl class="function">
<dt id="c.netif_tx_lock">
void <code class="sig-name descname">netif_tx_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_tx_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>grab network device transmit lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get network device transmit lock</p>
</div>
<dl class="function">
<dt id="c.__dev_uc_sync">
int <code class="sig-name descname">__dev_uc_sync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, int (<em>*sync</em>)(struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *, const unsigned char *), int (*unsync)(struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *, const unsigned char *)<span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_uc_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchonize device’s unicast list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*sync)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span></code></dt><dd><p>function to call if address should be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*unsync)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span></code></dt><dd><p>function to call if address should be removed</p>
<p>Add newly added addresses to the interface, and release
addresses that have been deleted.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__dev_uc_unsync">
void <code class="sig-name descname">__dev_uc_unsync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, int (<em>*unsync</em>)(struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *, const unsigned char *)<span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_uc_unsync" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove synchronized addresses from device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*unsync)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span></code></dt><dd><p>function to call if address should be removed</p>
<p>Remove all addresses that were added to the device by dev_uc_sync().</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__dev_mc_sync">
int <code class="sig-name descname">__dev_mc_sync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, int (<em>*sync</em>)(struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *, const unsigned char *), int (*unsync)(struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *, const unsigned char *)<span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_mc_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchonize device’s multicast list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*sync)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span></code></dt><dd><p>function to call if address should be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*unsync)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span></code></dt><dd><p>function to call if address should be removed</p>
<p>Add newly added addresses to the interface, and release
addresses that have been deleted.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__dev_mc_unsync">
void <code class="sig-name descname">__dev_mc_unsync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, int (<em>*unsync</em>)(struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *, const unsigned char *)<span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_mc_unsync" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove synchronized addresses from device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>device to sync</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*unsync)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span></code></dt><dd><p>function to call if address should be removed</p>
<p>Remove all addresses that were added to the device by dev_mc_sync().</p>
</dd>
</dl>
</div>
</section>
<section id="phy-support">
<h3>PHY Support<a class="headerlink" href="#phy-support" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.phy_print_status">
void <code class="sig-name descname">phy_print_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_print_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to print out the current phy status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_get_rate_matching">
int <code class="sig-name descname">phy_get_rate_matching</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> iface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_get_rate_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if rate matching is supported</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>The phy device to return rate matching for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">iface</span></code></dt><dd><p>The interface mode to use</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This determines the type of rate matching (if any) that <strong>phy</strong> supports
using <strong>iface</strong>. <strong>iface</strong> may be <code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_NA</span></code> to determine if any
interface supports rate matching.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>The type of rate matching <strong>phy</strong> supports for <strong>iface</strong>, or</dt><dd><p><code class="docutils literal notranslate"><span class="pre">RATE_MATCH_NONE</span></code>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_restart_aneg">
int <code class="sig-name descname">phy_restart_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_restart_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>restart auto-negotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Restart the autonegotiation on <strong>phydev</strong>.  Returns &gt;= 0 on success or
negative errno on error.</p>
</div>
<dl class="function">
<dt id="c.phy_aneg_done">
int <code class="sig-name descname">phy_aneg_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_aneg_done" title="Permalink to this definition">¶</a></dt>
<dd><p>return auto-negotiation status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the auto-negotiation status from this <strong>phydev</strong>
Returns &gt; 0 on success or &lt; 0 on error. 0 means that auto-negotiation
is still pending.</p>
</div>
<dl class="function">
<dt id="c.phy_mii_ioctl">
int <code class="sig-name descname">phy_mii_ioctl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, struct ifreq<em> *ifr</em>, int<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_mii_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>generic PHY MII ioctl interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span> <span class="pre">*ifr</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span></code> for socket ioctl’s</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl cmd to execute</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function is currently incompatible with the
PHYCONTROL layer.  It changes registers without regard to
current state.  Use at own risk.</p>
</div>
<dl class="function">
<dt id="c.phy_do_ioctl">
int <code class="sig-name descname">phy_do_ioctl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct ifreq<em> *ifr</em>, int<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_do_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>generic ndo_eth_ioctl implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>the net_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span> <span class="pre">*ifr</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span></code> for socket ioctl’s</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl cmd to execute</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_do_ioctl_running">
int <code class="sig-name descname">phy_do_ioctl_running</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct ifreq<em> *ifr</em>, int<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_do_ioctl_running" title="Permalink to this definition">¶</a></dt>
<dd><p>generic ndo_eth_ioctl implementation but test first</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>the net_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span> <span class="pre">*ifr</span></code></dt><dd><p><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span></code> for socket ioctl’s</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl cmd to execute</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as phy_do_ioctl, but ensures that net_device is running before
handling the ioctl.</p>
</div>
<dl class="function">
<dt id="c.phy_queue_state_machine">
void <code class="sig-name descname">phy_queue_state_machine</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, unsigned long<em> jiffies</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_queue_state_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigger the state machine to run soon</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">jiffies</span></code></dt><dd><p>Run the state machine after these jiffies</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_trigger_machine">
void <code class="sig-name descname">phy_trigger_machine</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_trigger_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigger the state machine to run now</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_ethtool_get_strings">
int <code class="sig-name descname">phy_ethtool_get_strings</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u8<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_get_strings" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the statistic counter names</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*data</span></code></dt><dd><p>Where to put the strings</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_ethtool_get_sset_count">
int <code class="sig-name descname">phy_ethtool_get_sset_count</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_get_sset_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of statistic counters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_ethtool_get_stats">
int <code class="sig-name descname">phy_ethtool_get_stats</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, struct ethtool_stats<em> *stats</em>, u64<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_get_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the statistic counters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_stats</span> <span class="pre">*stats</span></code></dt><dd><p>What counters to get</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">*data</span></code></dt><dd><p>Where to store the counters</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_start_cable_test">
int <code class="sig-name descname">phy_start_cable_test</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, struct netlink_ext_ack<em> *extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start_cable_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a cable test</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*extack</span></code></dt><dd><p>extack for reporting useful error messages</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_start_cable_test_tdr">
int <code class="sig-name descname">phy_start_cable_test_tdr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, struct netlink_ext_ack<em> *extack</em>, const struct <a class="reference internal" href="#c.phy_tdr_config" title="phy_tdr_config">phy_tdr_config</a><em> *config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start_cable_test_tdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a raw TDR cable test</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*extack</span></code></dt><dd><p>extack for reporting useful error messages</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">phy_tdr_config</span> <span class="pre">*config</span></code></dt><dd><p>Configuration of the test to run</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_start_aneg">
int <code class="sig-name descname">phy_start_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>start auto-negotiation for this PHY device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Sanitizes the settings (if we’re not autonegotiating</dt><dd><p>them), and then calls the driver’s config_aneg function.
If the PHYCONTROL Layer is operating, we change the state to
reflect the beginning of Auto-negotiation or forcing.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_speed_down">
int <code class="sig-name descname">phy_speed_down</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, bool<em> sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_speed_down" title="Permalink to this definition">¶</a></dt>
<dd><p>set speed to lowest speed supported by both link partners</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">sync</span></code></dt><dd><p>perform action synchronously</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Typically used to save energy when waiting for a WoL packet</p>
<p>WARNING: Setting sync to false may cause the system being unable to suspend
in case the PHY generates an interrupt when finishing the autonegotiation.
This interrupt may wake up the system immediately after suspend.
Therefore use sync = false only if you’re sure it’s safe with the respective
network chip.</p>
</div>
<dl class="function">
<dt id="c.phy_speed_up">
int <code class="sig-name descname">phy_speed_up</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_speed_up" title="Permalink to this definition">¶</a></dt>
<dd><p>(re)set advertised speeds to all supported speeds</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to revert the effect of phy_speed_down</p>
</div>
<dl class="function">
<dt id="c.phy_start_machine">
void <code class="sig-name descname">phy_start_machine</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>start PHY state machine tracking</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>The PHY infrastructure can run a state machine</dt><dd><p>which tracks whether the PHY is starting up, negotiating,
etc.  This function starts the delayed workqueue which tracks
the state of the PHY. If you want to maintain your own state machine,
do not call this function.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_error">
void <code class="sig-name descname">phy_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_error" title="Permalink to this definition">¶</a></dt>
<dd><p>enter HALTED state for this PHY device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Moves the PHY to the HALTED state in response to a read
or write error, and tells the controller the link is down.
Must not be called from interrupt context, or while the
phydev-&gt;lock is held.</p>
</div>
<dl class="function">
<dt id="c.phy_request_interrupt">
void <code class="sig-name descname">phy_request_interrupt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_request_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>request and enable interrupt for a PHY device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Request and enable the interrupt for the given PHY.</dt><dd><p>If this fails, then we set irq to PHY_POLL.
This should only be called with a valid IRQ number.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_free_interrupt">
void <code class="sig-name descname">phy_free_interrupt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_free_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>disable and free interrupt for a PHY device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Disable and free the interrupt for the given PHY.</dt><dd><p>This should only be called with a valid IRQ number.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_stop">
void <code class="sig-name descname">phy_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring down the PHY link, and stop checking the status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_start">
void <code class="sig-name descname">phy_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start or restart a PHY device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Indicates the attached device’s readiness to</dt><dd><p>handle PHY-related work.  Used during startup to start the
PHY, and after a call to <a class="reference internal" href="#c.phy_stop" title="phy_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_stop()</span></code></a> to resume operation.
Also used to indicate the MDIO bus has cleared an error
condition.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_mac_interrupt">
void <code class="sig-name descname">phy_mac_interrupt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_mac_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>MAC says the link has changed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>phy_device struct with changed link</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The MAC layer is able to indicate there has been a change in the PHY link
status. Trigger the state machine and work a work queue.</p>
</div>
<dl class="function">
<dt id="c.phy_init_eee">
int <code class="sig-name descname">phy_init_eee</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, bool<em> clk_stop_enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_init_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>init and check the EEE feature</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">clk_stop_enable</span></code></dt><dd><p>PHY may stop the clock during LPI</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>it checks if the Energy-Efficient Ethernet (EEE)
is supported by looking at the MMD registers 3.20 and 7.60/61
and it programs the MMD register 3.0 setting the “Clock stop enable”
bit if required.</p>
</div>
<dl class="function">
<dt id="c.phy_get_eee_err">
int <code class="sig-name descname">phy_get_eee_err</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_get_eee_err" title="Permalink to this definition">¶</a></dt>
<dd><p>report the EEE wake error count</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>it is to report the number of time where the PHY
failed to complete its normal wake sequence.</p>
</div>
<dl class="function">
<dt id="c.phy_ethtool_get_eee">
int <code class="sig-name descname">phy_ethtool_get_eee</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, struct ethtool_eee<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_get_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>get EEE supported and status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span> <span class="pre">*data</span></code></dt><dd><p>ethtool_eee data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>it reportes the Supported/Advertisement/LP Advertisement
capabilities.</p>
</div>
<dl class="function">
<dt id="c.phy_ethtool_set_eee">
int <code class="sig-name descname">phy_ethtool_set_eee</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, struct ethtool_eee<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_set_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>set EEE supported and status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span> <span class="pre">*data</span></code></dt><dd><p>ethtool_eee data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>it is to program the Advertisement EEE register.</p>
</div>
<dl class="function">
<dt id="c.phy_ethtool_set_wol">
int <code class="sig-name descname">phy_ethtool_set_wol</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, struct ethtool_wolinfo<em> *wol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_set_wol" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure Wake On LAN</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_wolinfo</span> <span class="pre">*wol</span></code></dt><dd><p>Configuration requested</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_ethtool_get_wol">
void <code class="sig-name descname">phy_ethtool_get_wol</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, struct ethtool_wolinfo<em> *wol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_get_wol" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current Wake On LAN configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_wolinfo</span> <span class="pre">*wol</span></code></dt><dd><p>Store the current configuration here</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_ethtool_nway_reset">
int <code class="sig-name descname">phy_ethtool_nway_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_nway_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Restart auto negotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Network device to restart autoneg for</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_config_interrupt">
int <code class="sig-name descname">phy_config_interrupt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, bool<em> interrupts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_config_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>configure the PHY device for the requested interrupts</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">interrupts</span></code></dt><dd><p>interrupt flags to configure for this <strong>phydev</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or &lt; 0 on error.</p>
</div>
<dl class="function">
<dt id="c.phy_find_valid">
const struct phy_setting * <code class="sig-name descname">phy_find_valid</code><span class="sig-paren">(</span>int<em> speed</em>, int<em> duplex</em>, unsigned long<em> *supported</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_find_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>find a PHY setting that matches the requested parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>desired speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">duplex</span></code></dt><dd><p>desired duplex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*supported</span></code></dt><dd><p>mask of supported link modes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Locate a supported phy setting that is, in priority order:
- an exact match for the specified speed and duplex mode
- a match for the specified speed, or slower speed
- the slowest supported speed
Returns the matched phy_setting entry, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no supported phy
settings were found.</p>
</div>
<dl class="function">
<dt id="c.phy_supported_speeds">
unsigned int <code class="sig-name descname">phy_supported_speeds</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phy</em>, unsigned int<em> *speeds</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_supported_speeds" title="Permalink to this definition">¶</a></dt>
<dd><p>return all speeds currently supported by a phy device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phy</span></code></dt><dd><p>The phy device to return supported speeds of.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*speeds</span></code></dt><dd><p>buffer to store supported speeds in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>size of speeds buffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of supported speeds, and fills the speeds
buffer with the supported speeds. If speeds buffer is too small to contain
all currently supported speeds, will return as many speeds as can fit.</p>
</div>
<dl class="function">
<dt id="c.phy_check_valid">
bool <code class="sig-name descname">phy_check_valid</code><span class="sig-paren">(</span>int<em> speed</em>, int<em> duplex</em>, unsigned long<em> *features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_check_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>check if there is a valid PHY setting which matches speed, duplex, and feature mask</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>speed to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">duplex</span></code></dt><dd><p>duplex to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*features</span></code></dt><dd><p>A mask of the valid settings</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if there is a valid setting, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.phy_sanitize_settings">
void <code class="sig-name descname">phy_sanitize_settings</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_sanitize_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure the PHY is set to supported speed and duplex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Make sure the PHY is set to supported speeds and</dt><dd><p>duplexes.  Drop down by one in this order:  1000/FULL,
1000/HALF, 100/FULL, 100/HALF, 10/FULL, 10/HALF.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_check_link_status">
int <code class="sig-name descname">phy_check_link_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_check_link_status" title="Permalink to this definition">¶</a></dt>
<dd><p>check link status and set state accordingly</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for link and whether autoneg was triggered / is running
and set state accordingly</p>
</div>
<dl class="function">
<dt id="c._phy_start_aneg">
int <code class="sig-name descname">_phy_start_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c._phy_start_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>start auto-negotiation for this PHY device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Sanitizes the settings (if we’re not autonegotiating</dt><dd><p>them), and then calls the driver’s config_aneg function.
If the PHYCONTROL Layer is operating, we change the state to
reflect the beginning of Auto-negotiation or forcing.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_stop_machine">
void <code class="sig-name descname">phy_stop_machine</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_stop_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the PHY state machine tracking</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Stops the state machine delayed workqueue, sets the</dt><dd><p>state to UP (unless it wasn’t up yet). This function must be
called BEFORE phy_detach.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_disable_interrupts">
int <code class="sig-name descname">phy_disable_interrupts</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_disable_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable the PHY interrupts from the PHY side</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_interrupt">
irqreturn_t <code class="sig-name descname">phy_interrupt</code><span class="sig-paren">(</span>int<em> irq</em>, void<em> *phy_dat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>PHY interrupt handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>interrupt line</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*phy_dat</span></code></dt><dd><p>phy_device pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle PHY interrupt</p>
</div>
<dl class="function">
<dt id="c.phy_enable_interrupts">
int <code class="sig-name descname">phy_enable_interrupts</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_enable_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the interrupts from the PHY side</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_state_machine">
void <code class="sig-name descname">phy_state_machine</code><span class="sig-paren">(</span>struct work_struct<em> *work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_state_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle the state machine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*work</span></code></dt><dd><p>work_struct that describes the work to be done</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_speed_to_str">
const char * <code class="sig-name descname">phy_speed_to_str</code><span class="sig-paren">(</span>int<em> speed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_speed_to_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string representing the PHY link speed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>Speed of the link</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_duplex_to_str">
const char * <code class="sig-name descname">phy_duplex_to_str</code><span class="sig-paren">(</span>unsigned int<em> duplex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_duplex_to_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return string describing the duplex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">duplex</span></code></dt><dd><p>Duplex setting to describe</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_rate_matching_to_str">
const char * <code class="sig-name descname">phy_rate_matching_to_str</code><span class="sig-paren">(</span>int<em> rate_matching</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_rate_matching_to_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string describing the rate matching</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">rate_matching</span></code></dt><dd><p>Type of rate matching to describe</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_interface_num_ports">
int <code class="sig-name descname">phy_interface_num_ports</code><span class="sig-paren">(</span><a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_interface_num_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of links that can be carried by a given MAC-PHY physical link. Returns 0 if this is unknown, the number of links else.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>The interface mode we want to get the number of ports</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_lookup_setting">
const struct phy_setting * <code class="sig-name descname">phy_lookup_setting</code><span class="sig-paren">(</span>int<em> speed</em>, int<em> duplex</em>, const unsigned long<em> *mask</em>, bool<em> exact</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_lookup_setting" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup a PHY setting</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>speed to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">duplex</span></code></dt><dd><p>duplex to match</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*mask</span></code></dt><dd><p>allowed link modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">exact</span></code></dt><dd><p>an exact match is required</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the settings array for a setting that matches the speed and
duplex, and which is supported.</p>
<p>If <strong>exact</strong> is unset, either an exact match or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for no match will
be returned.</p>
<p>If <strong>exact</strong> is set, an exact match, the fastest supported setting at
or below the specified speed, the slowest supported setting, or if
they all fail, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> will be returned.</p>
</div>
<dl class="function">
<dt id="c.phy_set_max_speed">
void <code class="sig-name descname">phy_set_max_speed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> max_speed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_set_max_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the maximum speed the PHY should support</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>The phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">max_speed</span></code></dt><dd><p>Maximum speed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The PHY might be more capable than the MAC. For example a Fast Ethernet
is connected to a 1G PHY. This function allows the MAC to indicate its
maximum speed, and so limit what the PHY will advertise.</p>
</div>
<dl class="function">
<dt id="c.phy_resolve_aneg_pause">
void <code class="sig-name descname">phy_resolve_aneg_pause</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_resolve_aneg_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine pause autoneg results</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>The phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Once autoneg has completed the local pause settings can be
resolved.  Determine if pause and asymmetric pause should be used
by the MAC.</p>
</div>
<dl class="function">
<dt id="c.phy_resolve_aneg_linkmode">
void <code class="sig-name descname">phy_resolve_aneg_linkmode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_resolve_aneg_linkmode" title="Permalink to this definition">¶</a></dt>
<dd><p>resolve the advertisements into PHY settings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>The phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resolve our and the link partner advertisements into their corresponding
speed and duplex. If full duplex was negotiated, extract the pause mode
from the link partner mask.</p>
</div>
<dl class="function">
<dt id="c.phy_check_downshift">
void <code class="sig-name descname">phy_check_downshift</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_check_downshift" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether downshift occurred</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>The phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether a downshift to a lower speed occurred. If this should be the
case warn the user.
Prerequisite for detecting downshift is that PHY driver implements the
read_status callback and sets phydev-&gt;speed to the actual link speed.</p>
</div>
<dl class="function">
<dt id="c.__phy_read_mmd">
int <code class="sig-name descname">__phy_read_mmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_read_mmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for reading a register from an MMD on a given PHY.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>The phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>The MMD to read from (0..31)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>The register on the MMD to read (0..65535)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same rules as for <a class="reference internal" href="#c.__phy_read" title="__phy_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">__phy_read()</span></code></a>;</p>
</div>
<dl class="function">
<dt id="c.phy_read_mmd">
int <code class="sig-name descname">phy_read_mmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_read_mmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for reading a register from an MMD on a given PHY.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>The phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>The MMD to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>The register on the MMD to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same rules as for <a class="reference internal" href="#c.phy_read" title="phy_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_read()</span></code></a>;</p>
</div>
<dl class="function">
<dt id="c.__phy_write_mmd">
int <code class="sig-name descname">__phy_write_mmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_write_mmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for writing a register on an MMD on a given PHY.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>The phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>The MMD to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>The register on the MMD to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>value to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same rules as for <a class="reference internal" href="#c.__phy_write" title="__phy_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">__phy_write()</span></code></a>;</p>
</div>
<dl class="function">
<dt id="c.phy_write_mmd">
int <code class="sig-name descname">phy_write_mmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_write_mmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for writing a register on an MMD on a given PHY.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>The phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>The MMD to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>The register on the MMD to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>value to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same rules as for <a class="reference internal" href="#c.phy_write" title="phy_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_write()</span></code></a>;</p>
</div>
<dl class="function">
<dt id="c.phy_modify_changed">
int <code class="sig-name descname">phy_modify_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_modify_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for modifying a PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>new value of bits set in mask to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
<p><strong>Description</strong></p>
<p>Returns negative errno, 0 if there was no change, and 1 in case of change</p>
</div>
<dl class="function">
<dt id="c.__phy_modify">
int <code class="sig-name descname">__phy_modify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_modify" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for modifying a PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>new value of bits set in mask to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
</div>
<dl class="function">
<dt id="c.phy_modify">
int <code class="sig-name descname">phy_modify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_modify" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for modifying a given PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>new value of bits set in mask to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
</div>
<dl class="function">
<dt id="c.__phy_modify_mmd_changed">
int <code class="sig-name descname">__phy_modify_mmd_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_modify_mmd_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for modifying a register on MMD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>the MMD containing register to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>new value of bits set in mask to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocked helper function which allows a MMD register to be modified as
new register value = (old register value &amp; ~mask) | set</p>
<p>Returns negative errno, 0 if there was no change, and 1 in case of change</p>
</div>
<dl class="function">
<dt id="c.phy_modify_mmd_changed">
int <code class="sig-name descname">phy_modify_mmd_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_modify_mmd_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for modifying a register on MMD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>the MMD containing register to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>new value of bits set in mask to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
<p><strong>Description</strong></p>
<p>Returns negative errno, 0 if there was no change, and 1 in case of change</p>
</div>
<dl class="function">
<dt id="c.__phy_modify_mmd">
int <code class="sig-name descname">__phy_modify_mmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_modify_mmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for modifying a register on MMD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>the MMD containing register to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>new value of bits set in mask to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
</div>
<dl class="function">
<dt id="c.phy_modify_mmd">
int <code class="sig-name descname">phy_modify_mmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_modify_mmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for modifying a register on MMD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>the MMD containing register to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>new value of bits set in mask to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
</div>
<dl class="function">
<dt id="c.phy_save_page">
int <code class="sig-name descname">phy_save_page</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_save_page" title="Permalink to this definition">¶</a></dt>
<dd><p>take the bus lock and save the current page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Take the MDIO bus lock, and return the current page number. On error,
returns a negative errno. <a class="reference internal" href="#c.phy_restore_page" title="phy_restore_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_restore_page()</span></code></a> must always be called
after this, irrespective of success or failure of this call.</p>
</div>
<dl class="function">
<dt id="c.phy_select_page">
int <code class="sig-name descname">phy_select_page</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_select_page" title="Permalink to this definition">¶</a></dt>
<dd><p>take the bus lock, save the current page, and set a page</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>desired page</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Take the MDIO bus lock to protect against concurrent access, save the
current PHY page, and set the current page.  On error, returns a
negative errno, otherwise returns the previous page number.
<a class="reference internal" href="#c.phy_restore_page" title="phy_restore_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_restore_page()</span></code></a> must always be called after this, irrespective
of success or failure of this call.</p>
</div>
<dl class="function">
<dt id="c.phy_restore_page">
int <code class="sig-name descname">phy_restore_page</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> oldpage</em>, int<em> ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_restore_page" title="Permalink to this definition">¶</a></dt>
<dd><p>restore the page register and release the bus lock</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">oldpage</span></code></dt><dd><p>the old page, return value from <a class="reference internal" href="#c.phy_save_page" title="phy_save_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_save_page()</span></code></a> or <a class="reference internal" href="#c.phy_select_page" title="phy_select_page"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_select_page()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ret</span></code></dt><dd><p>operation’s return code</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release the MDIO bus lock, restoring <strong>oldpage</strong> if it is a valid page.
This function propagates the earliest error code from the group of
operations.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><p><strong>oldpage</strong> if it was a negative value, otherwise
<strong>ret</strong> if it was a negative errno value, otherwise
phy_write_page()’s negative value if it were in error, otherwise
<strong>ret</strong>.</p>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.phy_read_paged">
int <code class="sig-name descname">phy_read_paged</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> page</em>, u32<em> regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_read_paged" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for reading a paged register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>the page for the phy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same rules as for <a class="reference internal" href="#c.phy_read" title="phy_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_read()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.phy_write_paged">
int <code class="sig-name descname">phy_write_paged</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> page</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_write_paged" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for writing a paged register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>the page for the phy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>value to write</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same rules as for <a class="reference internal" href="#c.phy_write" title="phy_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_write()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.phy_modify_paged_changed">
int <code class="sig-name descname">phy_modify_paged_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> page</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_modify_paged_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for modifying a paged register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>the page for the phy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>bit mask of bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, 0 if there was no change, and 1 in case of change</p>
</div>
<dl class="function">
<dt id="c.phy_modify_paged">
int <code class="sig-name descname">phy_modify_paged</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> page</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_modify_paged" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for modifying a paged register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">page</span></code></dt><dd><p>the page for the phy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>bit mask of bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same rules as for <a class="reference internal" href="#c.phy_read" title="phy_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_read()</span></code></a> and <a class="reference internal" href="#c.phy_write" title="phy_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_write()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.genphy_c45_pma_resume">
int <code class="sig-name descname">genphy_c45_pma_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_pma_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>wakes up the PMA module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_c45_pma_suspend">
int <code class="sig-name descname">genphy_c45_pma_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_pma_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>suspends the PMA module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_c45_pma_baset1_setup_master_slave">
int <code class="sig-name descname">genphy_c45_pma_baset1_setup_master_slave</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_pma_baset1_setup_master_slave" title="Permalink to this definition">¶</a></dt>
<dd><p>configures forced master/slave role of BaseT1 devices.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_c45_pma_setup_forced">
int <code class="sig-name descname">genphy_c45_pma_setup_forced</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_pma_setup_forced" title="Permalink to this definition">¶</a></dt>
<dd><p>configures a forced speed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_c45_an_config_aneg">
int <code class="sig-name descname">genphy_c45_an_config_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_an_config_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>configure advertisement registers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure advertisement registers based on modes set in phydev-&gt;advertising</p>
<p>Returns negative errno code on failure, 0 if advertisement didn’t change,
or 1 if advertised modes changed.</p>
</div>
<dl class="function">
<dt id="c.genphy_c45_an_disable_aneg">
int <code class="sig-name descname">genphy_c45_an_disable_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_an_disable_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>disable auto-negotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable auto-negotiation in the Clause 45 PHY. The link parameters
are controlled through the PMA/PMD MMD registers.</p>
<p>Returns zero on success, negative errno code on failure.</p>
</div>
<dl class="function">
<dt id="c.genphy_c45_restart_aneg">
int <code class="sig-name descname">genphy_c45_restart_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_restart_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable and restart auto-negotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This assumes that the auto-negotiation MMD is present.</p>
<p>Enable and restart auto-negotiation.</p>
</div>
<dl class="function">
<dt id="c.genphy_c45_check_and_restart_aneg">
int <code class="sig-name descname">genphy_c45_check_and_restart_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, bool<em> restart</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_check_and_restart_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable and restart auto-negotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">restart</span></code></dt><dd><p>whether aneg restart is requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This assumes that the auto-negotiation MMD is present.</p>
<p>Check, and restart auto-negotiation if needed.</p>
</div>
<dl class="function">
<dt id="c.genphy_c45_aneg_done">
int <code class="sig-name descname">genphy_c45_aneg_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_aneg_done" title="Permalink to this definition">¶</a></dt>
<dd><p>return auto-negotiation complete status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This assumes that the auto-negotiation MMD is present.</p>
<p>Reads the status register from the auto-negotiation MMD, returning:
- positive if auto-negotiation is complete
- negative errno code on error
- zero otherwise</p>
</div>
<dl class="function">
<dt id="c.genphy_c45_read_link">
int <code class="sig-name descname">genphy_c45_read_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_read_link" title="Permalink to this definition">¶</a></dt>
<dd><p>read the overall link status from the MMDs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the link status from the specified MMDs, and if they all indicate
that the link is up, set phydev-&gt;link to 1.  If an error is encountered,
a negative errno will be returned, otherwise zero.</p>
</div>
<dl class="function">
<dt id="c.genphy_c45_read_lpa">
int <code class="sig-name descname">genphy_c45_read_lpa</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_read_lpa" title="Permalink to this definition">¶</a></dt>
<dd><p>read the link partner advertisement and pause</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the Clause 45 defined base (7.19) and 10G (7.33) status registers,
filling in the link partner advertisement, pause and asym_pause members
in <strong>phydev</strong>.  This assumes that the auto-negotiation MMD is present, and
the backplane bit (7.48.0) is clear.  Clause 45 PHY drivers are expected
to fill in the remainder of the link partner advert from vendor registers.</p>
</div>
<dl class="function">
<dt id="c.genphy_c45_pma_baset1_read_master_slave">
int <code class="sig-name descname">genphy_c45_pma_baset1_read_master_slave</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_pma_baset1_read_master_slave" title="Permalink to this definition">¶</a></dt>
<dd><p>read forced master/slave configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_c45_read_pma">
int <code class="sig-name descname">genphy_c45_read_pma</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_read_pma" title="Permalink to this definition">¶</a></dt>
<dd><p>read link speed etc from PMA</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_c45_read_mdix">
int <code class="sig-name descname">genphy_c45_read_mdix</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_read_mdix" title="Permalink to this definition">¶</a></dt>
<dd><p>read mdix status from PMA</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_c45_pma_read_abilities">
int <code class="sig-name descname">genphy_c45_pma_read_abilities</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_pma_read_abilities" title="Permalink to this definition">¶</a></dt>
<dd><p>read supported link modes from PMA</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the supported link modes from the PMA Status 2 (1.8) register. If bit
1.8.9 is set, the list of supported modes is build using the values in the
PMA Extended Abilities (1.11) register, indicating 1000BASET an 10G related
modes. If bit 1.11.14 is set, then the list is also extended with the modes
in the 2.5G/5G PMA Extended register (1.21), indicating if 2.5GBASET and
5GBASET are supported.</p>
</div>
<dl class="function">
<dt id="c.genphy_c45_read_status">
int <code class="sig-name descname">genphy_c45_read_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_read_status" title="Permalink to this definition">¶</a></dt>
<dd><p>read PHY status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads status from PHY and sets phy_device members accordingly.</p>
</div>
<dl class="function">
<dt id="c.genphy_c45_config_aneg">
int <code class="sig-name descname">genphy_c45_config_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_config_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>restart auto-negotiation or forced setup</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>If auto-negotiation is enabled, we configure the</dt><dd><p>advertising, and then restart auto-negotiation.  If it is not
enabled, then we force a configuration.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_c45_fast_retrain">
int <code class="sig-name descname">genphy_c45_fast_retrain</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, bool<em> enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c45_fast_retrain" title="Permalink to this definition">¶</a></dt>
<dd><p>configure fast retrain registers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">enable</span></code></dt><dd><p>enable fast retrain or not</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>If fast-retrain is enabled, we configure PHY as</dt><dd><p>advertising fast retrain capable and THP Bypass Request, then
enable fast retrain. If it is not enabled, we configure fast
retrain disabled.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.phy_interface_t">
enum <code class="sig-name descname">phy_interface_t</code><a class="headerlink" href="#c.phy_interface_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface Mode definitions</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_NA</span></code></dt><dd><p>Not Applicable - don’t touch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_INTERNAL</span></code></dt><dd><p>No interface, MAC and PHY combined</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_MII</span></code></dt><dd><p>Media-independent interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_GMII</span></code></dt><dd><p>Gigabit media-independent interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_SGMII</span></code></dt><dd><p>Serial gigabit media-independent interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_TBI</span></code></dt><dd><p>Ten Bit Interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_REVMII</span></code></dt><dd><p>Reverse Media Independent Interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_RMII</span></code></dt><dd><p>Reduced Media Independent Interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_REVRMII</span></code></dt><dd><p>Reduced Media Independent Interface in PHY role</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_RGMII</span></code></dt><dd><p>Reduced gigabit media-independent interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_RGMII_ID</span></code></dt><dd><p>RGMII with Internal RX+TX delay</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_RGMII_RXID</span></code></dt><dd><p>RGMII with Internal RX delay</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_RGMII_TXID</span></code></dt><dd><p>RGMII with Internal RX delay</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_RTBI</span></code></dt><dd><p>Reduced TBI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_SMII</span></code></dt><dd><p>Serial MII</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_XGMII</span></code></dt><dd><p>10 gigabit media-independent interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_XLGMII</span></code></dt><dd><p>40 gigabit media-independent interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_MOCA</span></code></dt><dd><p>Multimedia over Coax</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_QSGMII</span></code></dt><dd><p>Quad SGMII</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_TRGMII</span></code></dt><dd><p>Turbo RGMII</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_100BASEX</span></code></dt><dd><p>100 BaseX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_1000BASEX</span></code></dt><dd><p>1000 BaseX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_2500BASEX</span></code></dt><dd><p>2500 BaseX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_5GBASER</span></code></dt><dd><p>5G BaseR</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_RXAUI</span></code></dt><dd><p>Reduced XAUI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_XAUI</span></code></dt><dd><p>10 Gigabit Attachment Unit Interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_10GBASER</span></code></dt><dd><p>10G BaseR</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_25GBASER</span></code></dt><dd><p>25G BaseR</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_USXGMII</span></code></dt><dd><p>Universal Serial 10GE MII</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_10GKR</span></code></dt><dd><p>10GBASE-KR - with Clause 73 AN</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_QUSGMII</span></code></dt><dd><p>Quad Universal SGMII</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_1000BASEKX</span></code></dt><dd><p>1000Base-KX - with Clause 73 AN</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_MAX</span></code></dt><dd><p>Book keeping</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Describes the interface between the MAC and PHY.</p>
<dl class="function">
<dt id="c.phy_modes">
const char * <code class="sig-name descname">phy_modes</code><span class="sig-paren">(</span><a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>map phy_interface_t enum to device tree binding of phy-mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p><a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">phy_interface_t</span></code></a> value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>maps enum <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">phy_interface_t</span></code></a> defined in this file
into the device tree binding of ‘phy-mode’, so that Ethernet
device driver can get PHY interface from device tree.</p>
</div>
<dl class="type">
<dt id="c.mdio_bus_stats">
struct <code class="sig-name descname">mdio_bus_stats</code><a class="headerlink" href="#c.mdio_bus_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Statistics counters for MDIO busses</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mdio_bus_stats {
    u64_stats_t transfers;
    u64_stats_t errors;
    u64_stats_t writes;
    u64_stats_t reads;
    struct u64_stats_sync syncp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">transfers</span></code></dt><dd><p>Total number of transfers, i.e. <strong>writes</strong> + <strong>reads</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">errors</span></code></dt><dd><p>Number of MDIO transfers that returned an error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">writes</span></code></dt><dd><p>Number of write transfers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reads</span></code></dt><dd><p>Number of read transfers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">syncp</span></code></dt><dd><p>Synchronisation for incrementing statistics</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.phy_package_shared">
struct <code class="sig-name descname">phy_package_shared</code><a class="headerlink" href="#c.phy_package_shared" title="Permalink to this definition">¶</a></dt>
<dd><p>Shared information in PHY packages</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phy_package_shared {
    int addr;
    refcount_t refcnt;
    unsigned long flags;
    size_t priv_size;
    void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>Common PHY address used to combine PHYs in one package</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">refcnt</span></code></dt><dd><p>Number of PHYs connected to this shared data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Initialization of PHY package</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv_size</span></code></dt><dd><p>Size of the shared private data <strong>priv</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>Driver private data shared across a PHY package</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Represents a shared structure between different phydev’s in the same
package, for example a quad PHY. See <a class="reference internal" href="#c.phy_package_join" title="phy_package_join"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_package_join()</span></code></a> and
<a class="reference internal" href="#c.phy_package_leave" title="phy_package_leave"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_package_leave()</span></code></a>.</p>
<dl class="type">
<dt id="c.mii_bus">
struct <code class="sig-name descname">mii_bus</code><a class="headerlink" href="#c.mii_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents an MDIO bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mii_bus {
    struct module *owner;
    const char *name;
    char id[MII_BUS_ID_SIZE];
    void *priv;
    int (*read)(struct mii_bus *bus, int addr, int regnum);
    int (*write)(struct mii_bus *bus, int addr, int regnum, u16 val);
    int (*reset)(struct mii_bus *bus);
    struct mdio_bus_stats stats[PHY_MAX_ADDR];
    struct mutex mdio_lock;
    struct device *parent;
    enum {
        MDIOBUS_ALLOCATED = 1,
        MDIOBUS_REGISTERED,
        MDIOBUS_UNREGISTERED,
        MDIOBUS_RELEASED,
    } state;
    struct device dev;
    struct mdio_device *mdio_map[PHY_MAX_ADDR];
    u32 phy_mask;
    u32 phy_ignore_ta_mask;
    int irq[PHY_MAX_ADDR];
    int reset_delay_us;
    int reset_post_delay_us;
    struct gpio_desc *reset_gpiod;
    enum {
        MDIOBUS_NO_CAP = 0,
        MDIOBUS_C22,
        MDIOBUS_C45,
        MDIOBUS_C22_C45,
    } probe_capabilities;
    struct mutex shared_lock;
    struct phy_package_shared *shared[PHY_MAX_ADDR];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>Who owns this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>User friendly name for this MDIO device, or driver name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>Unique identifier for this bus, typical from bus hierarchy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>Driver private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read</span></code></dt><dd><p>Perform a read transfer on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write</span></code></dt><dd><p>Perform a write transfer on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset</span></code></dt><dd><p>Perform a reset of the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats</span></code></dt><dd><p>Statistic counters per device on the bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mdio_lock</span></code></dt><dd><p>A lock to ensure that only one thing can read/write
the MDIO bus at a time</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>Parent device of this bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>State of bus structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>Kernel device representation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mdio_map</span></code></dt><dd><p>list of all MDIO devices on bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_mask</span></code></dt><dd><p>PHY addresses to be ignored when probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_ignore_ta_mask</span></code></dt><dd><p>PHY addresses to ignore the TA/read failure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>An array of interrupts, each PHY’s interrupt at the index
matching its address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_delay_us</span></code></dt><dd><p>GPIO reset pulse width in microseconds</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_post_delay_us</span></code></dt><dd><p>GPIO reset deassert delay in microseconds</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reset_gpiod</span></code></dt><dd><p>Reset GPIO descriptor pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe_capabilities</span></code></dt><dd><p>bus capabilities, used for probing</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shared_lock</span></code></dt><dd><p>protect access to the shared element</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shared</span></code></dt><dd><p>shared state across different PHYs</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The Bus class for PHYs.  Devices which provide access to
PHYs should register using this structure</p>
<dl class="function">
<dt id="c.mdiobus_alloc">
struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a> * <code class="sig-name descname">mdiobus_alloc</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an MDIO bus structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The internal state of the MDIO bus will be set of MDIOBUS_ALLOCATED ready
for the driver to register the bus.</p>
</div>
<dl class="type">
<dt id="c.phy_state">
enum <code class="sig-name descname">phy_state</code><a class="headerlink" href="#c.phy_state" title="Permalink to this definition">¶</a></dt>
<dd><p>PHY state machine states:</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">PHY_DOWN</span></code></dt><dd><p>PHY device and driver are not ready for anything.  probe
should be called if and only if the PHY is in this state,
given that the PHY device exists.
- PHY driver probe function will set the state to <strong>PHY_READY</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_READY</span></code></dt><dd><p>PHY is ready to send and receive packets, but the
controller is not.  By default, PHYs which do not implement
probe will be set to this state by <a class="reference internal" href="#c.phy_probe" title="phy_probe"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_probe()</span></code></a>.
- start will set the state to UP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_HALTED</span></code></dt><dd><p>PHY is up, but no polling or interrupts are done. Or
PHY is in an error state.
- phy_start moves to <strong>PHY_UP</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_UP</span></code></dt><dd><p>The PHY and attached device are ready to do work.
Interrupts should be started here.
- timer moves to <strong>PHY_NOLINK</strong> or <strong>PHY_RUNNING</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_RUNNING</span></code></dt><dd><p>PHY is currently up, running, and possibly sending
and/or receiving packets
- irq or timer will set <strong>PHY_NOLINK</strong> if link goes down
- phy_stop moves to <strong>PHY_HALTED</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_NOLINK</span></code></dt><dd><p>PHY is up, but not currently plugged in.
- irq or timer will set <strong>PHY_RUNNING</strong> if link comes back
- phy_stop moves to <strong>PHY_HALTED</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PHY_CABLETEST</span></code></dt><dd><p>PHY is performing a cable test. Packet reception/sending
is not expected to work, carrier will be indicated as down. PHY will be
poll once per second, or on interrupt for it current state.
Once complete, move to UP to restart the PHY.
- phy_stop aborts the running test and moves to <strong>PHY_HALTED</strong></p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.phy_c45_device_ids">
struct <code class="sig-name descname">phy_c45_device_ids</code><a class="headerlink" href="#c.phy_c45_device_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>802.3-c45 Device Identifiers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phy_c45_device_ids {
    u32 devices_in_package;
    u32 mmds_present;
    u32 device_ids[MDIO_MMD_NUM];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">devices_in_package</span></code></dt><dd><p>IEEE 802.3 devices in package register value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmds_present</span></code></dt><dd><p>bit vector of MMDs present.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_ids</span></code></dt><dd><p>The device identifer for each present device.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.phy_device">
struct <code class="sig-name descname">phy_device</code><a class="headerlink" href="#c.phy_device" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of a PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phy_device {
    struct mdio_device mdio;
    struct phy_driver *drv;
    struct device_link *devlink;
    u32 phy_id;
    struct phy_c45_device_ids c45_ids;
    unsigned is_c45:1;
    unsigned is_internal:1;
    unsigned is_pseudo_fixed_link:1;
    unsigned is_gigabit_capable:1;
    unsigned has_fixups:1;
    unsigned suspended:1;
    unsigned suspended_by_mdio_bus:1;
    unsigned sysfs_links:1;
    unsigned loopback_enabled:1;
    unsigned downshifted_rate:1;
    unsigned is_on_sfp_module:1;
    unsigned mac_managed_pm:1;
    unsigned autoneg:1;
    unsigned link:1;
    unsigned autoneg_complete:1;
    unsigned interrupts:1;
    unsigned irq_suspended:1;
    unsigned irq_rerun:1;
    int rate_matching;
    enum phy_state state;
    u32 dev_flags;
    phy_interface_t interface;
    int speed;
    int duplex;
    int port;
    int pause;
    int asym_pause;
    u8 master_slave_get;
    u8 master_slave_set;
    u8 master_slave_state;
    unsigned long supported[BITS_TO_LONGS(__ETHTOOL_LINK_MODE_MASK_NBITS)];
    unsigned long advertising[BITS_TO_LONGS(__ETHTOOL_LINK_MODE_MASK_NBITS)];
    unsigned long lp_advertising[BITS_TO_LONGS(__ETHTOOL_LINK_MODE_MASK_NBITS)];
    unsigned long adv_old[BITS_TO_LONGS(__ETHTOOL_LINK_MODE_MASK_NBITS)];
    unsigned long host_interfaces[BITS_TO_LONGS(PHY_INTERFACE_MODE_MAX)];
    u32 eee_broken_modes;
#ifdef CONFIG_LED_TRIGGER_PHY;
    struct phy_led_trigger *phy_led_triggers;
    unsigned int phy_num_led_triggers;
    struct phy_led_trigger *last_triggered;
    struct phy_led_trigger *led_link_trigger;
#endif;
    int irq;
    void *priv;
    struct phy_package_shared *shared;
    struct sk_buff *skb;
    void *ehdr;
    struct nlattr *nest;
    struct delayed_work state_queue;
    struct mutex lock;
    bool sfp_bus_attached;
    struct sfp_bus *sfp_bus;
    struct phylink *phylink;
    struct net_device *attached_dev;
    struct mii_timestamper *mii_ts;
    struct pse_control *psec;
    u8 mdix;
    u8 mdix_ctrl;
    int pma_extable;
    unsigned int link_down_events;
    void (*phy_link_change)(struct phy_device *phydev, bool up);
    void (*adjust_link)(struct net_device *dev);
#if IS_ENABLED(CONFIG_MACSEC);
    const struct macsec_ops *macsec_ops;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mdio</span></code></dt><dd><p>MDIO bus this PHY is on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drv</span></code></dt><dd><p>Pointer to the driver for this PHY instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devlink</span></code></dt><dd><p>Create a link between phy dev and mac dev, if the external phy
used by current mac interface is managed by another mac interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_id</span></code></dt><dd><p>UID for this device found during discovery</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c45_ids</span></code></dt><dd><p>802.3-c45 Device Identifiers if is_c45.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_c45</span></code></dt><dd><p>Set to true if this PHY uses clause 45 addressing.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_internal</span></code></dt><dd><p>Set to true if this PHY is internal to a MAC.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_pseudo_fixed_link</span></code></dt><dd><p>Set to true if this PHY is an Ethernet switch, etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_gigabit_capable</span></code></dt><dd><p>Set to true if PHY supports 1000Mbps</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">has_fixups</span></code></dt><dd><p>Set to true if this PHY has fixups/quirks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspended</span></code></dt><dd><p>Set to true if this PHY has been suspended successfully.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspended_by_mdio_bus</span></code></dt><dd><p>Set to true if this PHY was suspended by MDIO bus.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sysfs_links</span></code></dt><dd><p>Internal boolean tracking sysfs symbolic links setup/removal.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">loopback_enabled</span></code></dt><dd><p>Set true if this PHY has been loopbacked successfully.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">downshifted_rate</span></code></dt><dd><p>Set true if link speed has been downshifted.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">is_on_sfp_module</span></code></dt><dd><p>Set true if PHY is located on an SFP module.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_managed_pm</span></code></dt><dd><p>Set true if MAC driver takes of suspending/resuming PHY</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">autoneg</span></code></dt><dd><p>Flag autoneg being used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link</span></code></dt><dd><p>Current link state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">autoneg_complete</span></code></dt><dd><p>Flag auto negotiation of the link has completed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interrupts</span></code></dt><dd><p>Flag interrupts have been enabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_suspended</span></code></dt><dd><p>Flag indicating PHY is suspended and therefore interrupt
handling shall be postponed until PHY has resumed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq_rerun</span></code></dt><dd><p>Flag indicating interrupts occurred while PHY was suspended,
requiring a rerun of the interrupt handler after resume</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate_matching</span></code></dt><dd><p>Current rate matching mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>State of the PHY for management purposes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev_flags</span></code></dt><dd><p>Device-specific flags used by the PHY driver.</p>
<ul class="simple">
<li><p>Bits [15:0] are free to use by the PHY driver to communicate
driver specific behavior.</p></li>
<li><p>Bits [23:16] are currently reserved for future use.</p></li>
<li><p>Bits [31:24] are reserved for defining generic
PHY driver behavior.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interface</span></code></dt><dd><p><a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">phy_interface_t</span></code></a> value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">speed</span></code></dt><dd><p>Current link speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duplex</span></code></dt><dd><p>Current duplex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">port</span></code></dt><dd><p>Current port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pause</span></code></dt><dd><p>Current pause</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">asym_pause</span></code></dt><dd><p>Current asymmetric pause</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master_slave_get</span></code></dt><dd><p>Current master/slave advertisement</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master_slave_set</span></code></dt><dd><p>User requested master/slave configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">master_slave_state</span></code></dt><dd><p>Current master/slave configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported</span></code></dt><dd><p>Combined MAC/PHY supported linkmodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">advertising</span></code></dt><dd><p>Currently advertised linkmodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lp_advertising</span></code></dt><dd><p>Current link partner advertised linkmodes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adv_old</span></code></dt><dd><p>Saved advertised while power saving for WoL</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">host_interfaces</span></code></dt><dd><p>PHY interface modes supported by host</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">eee_broken_modes</span></code></dt><dd><p>Energy efficient ethernet modes which should be prohibited</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_led_triggers</span></code></dt><dd><p>Array of LED triggers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_num_led_triggers</span></code></dt><dd><p>Number of triggers in <strong>phy_led_triggers</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last_triggered</span></code></dt><dd><p>last LED trigger for link speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">led_link_trigger</span></code></dt><dd><p>LED trigger for link up/down</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">irq</span></code></dt><dd><p>IRQ number of the PHY’s interrupt (-1 if none)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>Pointer to driver private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">shared</span></code></dt><dd><p>Pointer to private data shared by phys in one package</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">skb</span></code></dt><dd><p>Netlink message for cable diagnostics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ehdr</span></code></dt><dd><p>nNtlink header for cable diagnostics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nest</span></code></dt><dd><p>Netlink nest used for cable diagnostics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">state_queue</span></code></dt><dd><p>Work queue for state machine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>Mutex for serialization access to PHY</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sfp_bus_attached</span></code></dt><dd><p>Flag indicating whether the SFP bus has been attached</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sfp_bus</span></code></dt><dd><p>SFP bus attached to this PHY’s fiber port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phylink</span></code></dt><dd><p>Pointer to phylink instance for this PHY</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">attached_dev</span></code></dt><dd><p>The attached enet driver’s device instance ptr</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mii_ts</span></code></dt><dd><p>Pointer to time stamper callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">psec</span></code></dt><dd><p>Pointer to Power Sourcing Equipment control struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mdix</span></code></dt><dd><p>Current crossover</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mdix_ctrl</span></code></dt><dd><p>User setting of crossover</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pma_extable</span></code></dt><dd><p>Cached value of PMA/PMD Extended Abilities Register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_down_events</span></code></dt><dd><p>Number of times link was lost</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_link_change</span></code></dt><dd><p>Callback for phylink for notification of link change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">adjust_link</span></code></dt><dd><p>Callback for the enet controller to respond to changes: in the
link state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">macsec_ops</span></code></dt><dd><p>MACsec offloading ops.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>interrupts currently only supports enabled or disabled,
but could be changed in the future to support enabling
and disabling specific interrupts</p>
<p>Contains some infrastructure for polling and interrupt
handling, as well as handling shifts in PHY hardware state</p>
<dl class="type">
<dt id="c.phy_tdr_config">
struct <code class="sig-name descname">phy_tdr_config</code><a class="headerlink" href="#c.phy_tdr_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration of a TDR raw test</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phy_tdr_config {
    u32 first;
    u32 last;
    u32 step;
    s8 pair;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">first</span></code></dt><dd><p>Distance for first data collection point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">last</span></code></dt><dd><p>Distance for last data collection point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">step</span></code></dt><dd><p>Step between data collection points</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pair</span></code></dt><dd><p>Bitmap of cable pairs to collect data for</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>A structure containing possible configuration parameters
for a TDR cable test. The driver does not need to implement
all the parameters, but should report what is actually used.
All distances are in centimeters.</p>
<dl class="type">
<dt id="c.phy_driver">
struct <code class="sig-name descname">phy_driver</code><a class="headerlink" href="#c.phy_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver structure for a particular PHY type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phy_driver {
    struct mdio_driver_common mdiodrv;
    u32 phy_id;
    char *name;
    u32 phy_id_mask;
    const unsigned long * const features;
    u32 flags;
    const void *driver_data;
    int (*soft_reset)(struct phy_device *phydev);
    int (*config_init)(struct phy_device *phydev);
    int (*probe)(struct phy_device *phydev);
    int (*get_features)(struct phy_device *phydev);
    int (*get_rate_matching)(struct phy_device *phydev, phy_interface_t iface);
    int (*suspend)(struct phy_device *phydev);
    int (*resume)(struct phy_device *phydev);
    int (*config_aneg)(struct phy_device *phydev);
    int (*aneg_done)(struct phy_device *phydev);
    int (*read_status)(struct phy_device *phydev);
    int (*config_intr)(struct phy_device *phydev);
    irqreturn_t (*handle_interrupt)(struct phy_device *phydev);
    void (*remove)(struct phy_device *phydev);
    int (*match_phy_device)(struct phy_device *phydev);
    int (*set_wol)(struct phy_device *dev, struct ethtool_wolinfo *wol);
    void (*get_wol)(struct phy_device *dev, struct ethtool_wolinfo *wol);
    void (*link_change_notify)(struct phy_device *dev);
    int (*read_mmd)(struct phy_device *dev, int devnum, u16 regnum);
    int (*write_mmd)(struct phy_device *dev, int devnum, u16 regnum, u16 val);
    int (*read_page)(struct phy_device *dev);
    int (*write_page)(struct phy_device *dev, int page);
    int (*module_info)(struct phy_device *dev, struct ethtool_modinfo *modinfo);
    int (*module_eeprom)(struct phy_device *dev, struct ethtool_eeprom *ee, u8 *data);
    int (*cable_test_start)(struct phy_device *dev);
    int (*cable_test_tdr_start)(struct phy_device *dev, const struct phy_tdr_config *config);
    int (*cable_test_get_status)(struct phy_device *dev, bool *finished);
    int (*get_sset_count)(struct phy_device *dev);
    void (*get_strings)(struct phy_device *dev, u8 *data);
    void (*get_stats)(struct phy_device *dev, struct ethtool_stats *stats, u64 *data);
    int (*get_tunable)(struct phy_device *dev, struct ethtool_tunable *tuna, void *data);
    int (*set_tunable)(struct phy_device *dev,struct ethtool_tunable *tuna, const void *data);
    int (*set_loopback)(struct phy_device *dev, bool enable);
    int (*get_sqi)(struct phy_device *dev);
    int (*get_sqi_max)(struct phy_device *dev);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mdiodrv</span></code></dt><dd><p>Data common to all MDIO devices</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_id</span></code></dt><dd><p>The result of reading the UID registers of this PHY
type, and ANDing them with the phy_id_mask.  This driver
only works for PHYs with IDs which match this field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>The friendly name of this PHY type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_id_mask</span></code></dt><dd><p>Defines the important bits of the phy_id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">features</span></code></dt><dd><p>A mandatory list of features (speed, duplex, etc)
supported by this PHY</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>A bitfield defining certain other features this PHY
supports (like interrupts)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_data</span></code></dt><dd><p>Static driver data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">soft_reset</span></code></dt><dd><p>Called to issue a PHY software reset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config_init</span></code></dt><dd><p>Called to initialize the PHY,
including after a reset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">probe</span></code></dt><dd><p>Called during discovery.  Used to set
up device-specific structures, if any</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_features</span></code></dt><dd><p>Probe the hardware to determine what
abilities it has.  Should only set phydev-&gt;supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_rate_matching</span></code></dt><dd><p>Get the supported type of rate matching for a
particular phy interface. This is used by phy consumers to determine
whether to advertise lower-speed modes for that interface. It is
assumed that if a rate matching mode is supported on an interface,
then that interface’s rate can be adapted to all slower link speeds
supported by the phy. If the interface is not supported, this should
return <code class="docutils literal notranslate"><span class="pre">RATE_MATCH_NONE</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suspend</span></code></dt><dd><p>Suspend the hardware, saving state if needed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">resume</span></code></dt><dd><p>Resume the hardware, restoring state if needed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config_aneg</span></code></dt><dd><p>Configures the advertisement and resets
autonegotiation if phydev-&gt;autoneg is on,
forces the speed to the current settings in phydev
if phydev-&gt;autoneg is off</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aneg_done</span></code></dt><dd><p>Determines the auto negotiation result</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_status</span></code></dt><dd><p>Determines the negotiated speed and duplex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">config_intr</span></code></dt><dd><p>Enables or disables interrupts.
It should also clear any pending interrupts prior to enabling the
IRQs and after disabling them.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">handle_interrupt</span></code></dt><dd><p>Override default interrupt handling</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove</span></code></dt><dd><p>Clears up any memory if needed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">match_phy_device</span></code></dt><dd><p>Returns true if this is a suitable
driver for the given phydev.  If NULL, matching is based on
phy_id and phy_id_mask.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_wol</span></code></dt><dd><p>Some devices (e.g. qnap TS-119P II) require PHY
register changes to enable Wake on LAN, so set_wol is
provided to be called in the ethernet driver’s set_wol
function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_wol</span></code></dt><dd><p>See set_wol, but for checking whether Wake on LAN
is enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_change_notify</span></code></dt><dd><p>Called to inform a PHY device driver
when the core is about to change the link state. This
callback is supposed to be used as fixup hook for drivers
that need to take action when the link state
changes. Drivers are by no means allowed to mess with the
PHY device structure in their implementations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_mmd</span></code></dt><dd><p>PHY specific driver override for reading a MMD
register.  This function is optional for PHY specific
drivers.  When not provided, the default MMD read function
will be used by <a class="reference internal" href="#c.phy_read_mmd" title="phy_read_mmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_read_mmd()</span></code></a>, which will use either a
direct read for Clause 45 PHYs or an indirect read for
Clause 22 PHYs.  devnum is the MMD device number within the
PHY device, regnum is the register within the selected MMD
device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_mmd</span></code></dt><dd><p>PHY specific driver override for writing a MMD
register.  This function is optional for PHY specific
drivers.  When not provided, the default MMD write function
will be used by <a class="reference internal" href="#c.phy_write_mmd" title="phy_write_mmd"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_write_mmd()</span></code></a>, which will use either a
direct write for Clause 45 PHYs, or an indirect write for
Clause 22 PHYs.  devnum is the MMD device number within the
PHY device, regnum is the register within the selected MMD
device.  val is the value to be written.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read_page</span></code></dt><dd><p>Return the current PHY register page number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write_page</span></code></dt><dd><p>Set the current PHY register page number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module_info</span></code></dt><dd><p>Get the size and type of the eeprom contained
within a plug-in module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module_eeprom</span></code></dt><dd><p>Get the eeprom information from the plug-in
module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cable_test_start</span></code></dt><dd><p>Start a cable test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cable_test_tdr_start</span></code></dt><dd><p>Start a raw TDR cable test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cable_test_get_status</span></code></dt><dd><p>Once per second, or on interrupt,
request the status of the test.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_sset_count</span></code></dt><dd><p>Number of statistic counters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_strings</span></code></dt><dd><p>Names of the statistic counters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_stats</span></code></dt><dd><p>Return the statistic counter values</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_tunable</span></code></dt><dd><p>Return the value of a tunable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_tunable</span></code></dt><dd><p>Set the value of a tunable</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_loopback</span></code></dt><dd><p>Set the loopback mood of the PHY</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_sqi</span></code></dt><dd><p>Get the signal quality indication</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_sqi_max</span></code></dt><dd><p>Get the maximum signal quality indication</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>All functions are optional. If config_aneg or read_status
are not implemented, the phy core uses the genphy versions.
Note that none of these functions should be called from
interrupt time. The goal is for the bus read/write functions
to be able to block when the bus transaction is happening,
and be freed up by an interrupt (The MPC85xx has this ability,
though it is not currently supported in the driver).</p>
<dl class="function">
<dt id="c.phy_is_started">
bool <code class="sig-name descname">phy_is_started</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_is_started" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to check whether PHY is started</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>The phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_read">
int <code class="sig-name descname">phy_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for reading a given PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to read</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
</div>
<dl class="function">
<dt id="c.__phy_read">
int <code class="sig-name descname">__phy_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_read" title="Permalink to this definition">¶</a></dt>
<dd><p>convenience function for reading a given PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must have taken the MDIO bus lock.</p>
</div>
<dl class="function">
<dt id="c.phy_write">
int <code class="sig-name descname">phy_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for writing a given PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>value to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
</div>
<dl class="function">
<dt id="c.__phy_write">
int <code class="sig-name descname">__phy_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for writing a given PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>value to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must have taken the MDIO bus lock.</p>
</div>
<dl class="function">
<dt id="c.__phy_modify_changed">
int <code class="sig-name descname">__phy_modify_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_modify_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for modifying a PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>bit mask of bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocked helper function which allows a PHY register to be modified as
new register value = (old register value &amp; ~mask) | set</p>
<p>Returns negative errno, 0 if there was no change, and 1 in case of change</p>
</div>
<dl class="function">
<dt id="c.phy_read_mmd_poll_timeout">
<code class="sig-name descname">phy_read_mmd_poll_timeout</code><span class="sig-paren">(</span><em>phydev</em>, <em>devaddr</em>, <em>regnum</em>, <em>val</em>, <em>cond</em>, <em>sleep_us</em>, <em>timeout_us</em>, <em>sleep_before_read</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_read_mmd_poll_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Periodically poll a PHY register until a condition is met or a timeout occurs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phydev</span></code></dt><dd><p>The phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">devaddr</span></code></dt><dd><p>The MMD to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">regnum</span></code></dt><dd><p>The register on the MMD to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">val</span></code></dt><dd><p>Variable to read the register into</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cond</span></code></dt><dd><p>Break condition (usually involving <strong>val</strong>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sleep_us</span></code></dt><dd><p>Maximum time to sleep between reads in us (0
tight-loops).  Should be less than ~20ms since usleep_range
is used (see <a class="reference internal" href="../timers/timers-howto.html"><span class="doc">delays - Information on the various kernel delay / sleep mechanisms</span></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">timeout_us</span></code></dt><dd><p>Timeout in us, 0 means never timeout</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sleep_before_read</span></code></dt><dd><p>if it is true, sleep <strong>sleep_us</strong> before read.
Returns 0 on success and -ETIMEDOUT upon a timeout. In either
case, the last read value at <strong>args</strong> is stored in <strong>val</strong>. Must not
be called from atomic context if sleep_us or timeout_us are used.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__phy_set_bits">
int <code class="sig-name descname">__phy_set_bits</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_set_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for setting bits in a PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must have taken the MDIO bus lock.</p>
</div>
<dl class="function">
<dt id="c.__phy_clear_bits">
int <code class="sig-name descname">__phy_clear_bits</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_clear_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for clearing bits in a PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>bits to clear</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must have taken the MDIO bus lock.</p>
</div>
<dl class="function">
<dt id="c.phy_set_bits">
int <code class="sig-name descname">phy_set_bits</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_set_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for setting bits in a PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>bits to set</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_clear_bits">
int <code class="sig-name descname">phy_clear_bits</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_clear_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for clearing bits in a PHY register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>bits to clear</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.__phy_set_bits_mmd">
int <code class="sig-name descname">__phy_set_bits_mmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_set_bits_mmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for setting bits in a register on MMD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>the MMD containing register to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must have taken the MDIO bus lock.</p>
</div>
<dl class="function">
<dt id="c.__phy_clear_bits_mmd">
int <code class="sig-name descname">__phy_clear_bits_mmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__phy_clear_bits_mmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for clearing bits in a register on MMD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>the MMD containing register to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>bits to clear</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must have taken the MDIO bus lock.</p>
</div>
<dl class="function">
<dt id="c.phy_set_bits_mmd">
int <code class="sig-name descname">phy_set_bits_mmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_set_bits_mmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for setting bits in a register on MMD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>the MMD containing register to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>bits to set</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_clear_bits_mmd">
int <code class="sig-name descname">phy_clear_bits_mmd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> devad</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_clear_bits_mmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for clearing bits in a register on MMD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">devad</span></code></dt><dd><p>the MMD containing register to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>bits to clear</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_interrupt_is_valid">
bool <code class="sig-name descname">phy_interrupt_is_valid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_interrupt_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for testing a given PHY irq</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>must be kept in sync with addition/removal of PHY_POLL and
PHY_MAC_INTERRUPT</p>
</div>
<dl class="function">
<dt id="c.phy_polling_mode">
bool <code class="sig-name descname">phy_polling_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_polling_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for testing whether polling is used to detect PHY status changes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_has_hwtstamp">
bool <code class="sig-name descname">phy_has_hwtstamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_has_hwtstamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether a PHY time stamp configuration.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_has_rxtstamp">
bool <code class="sig-name descname">phy_has_rxtstamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_has_rxtstamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether a PHY supports receive time stamping.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_has_tsinfo">
bool <code class="sig-name descname">phy_has_tsinfo</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_has_tsinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether a PHY reports time stamping and/or PTP hardware clock capabilities.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_has_txtstamp">
bool <code class="sig-name descname">phy_has_txtstamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_has_txtstamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether a PHY supports transmit time stamping.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_is_internal">
bool <code class="sig-name descname">phy_is_internal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_is_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for testing if a PHY is internal</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_on_sfp">
bool <code class="sig-name descname">phy_on_sfp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_on_sfp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for testing if a PHY is on an SFP module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_interface_mode_is_rgmii">
bool <code class="sig-name descname">phy_interface_mode_is_rgmii</code><span class="sig-paren">(</span><a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_interface_mode_is_rgmii" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for testing if a PHY interface mode is RGMII (all variants)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">mode</span></code></dt><dd><p>the <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">phy_interface_t</span></code></a> enum</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_interface_mode_is_8023z">
bool <code class="sig-name descname">phy_interface_mode_is_8023z</code><span class="sig-paren">(</span><a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_interface_mode_is_8023z" title="Permalink to this definition">¶</a></dt>
<dd><p>does the PHY interface mode use 802.3z negotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">mode</span></code></dt><dd><p>one of <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">enum</span> <span class="pre">phy_interface_t</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the PHY interface mode uses the 16-bit negotiation
word as defined in 802.3z. (See 802.3-2015 37.2.1 Config_Reg encoding)</p>
</div>
<dl class="function">
<dt id="c.phy_interface_is_rgmii">
bool <code class="sig-name descname">phy_interface_is_rgmii</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_interface_is_rgmii" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for testing if a PHY interface is RGMII (all variants)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_is_pseudo_fixed_link">
bool <code class="sig-name descname">phy_is_pseudo_fixed_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_is_pseudo_fixed_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for testing if this PHY is the CPU port facing side of an Ethernet switch, or similar.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_module_driver">
<code class="sig-name descname">phy_module_driver</code><span class="sig-paren">(</span><em>__phy_drivers</em>, <em>__count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_module_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering PHY drivers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__phy_drivers</span></code></dt><dd><p>array of PHY drivers to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__count</span></code></dt><dd><p>Numbers of members in array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for PHY drivers which do not do anything special in module
init/exit. Each module may only use this macro once, and calling it
replaces <a class="reference internal" href="../driver-api/basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="../driver-api/basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal notranslate"><span class="pre">module_exit()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.phy_register_fixup">
int <code class="sig-name descname">phy_register_fixup</code><span class="sig-paren">(</span>const char<em> *bus_id</em>, u32<em> phy_uid</em>, u32<em> phy_uid_mask</em>, int (<em>*run</em>)(struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a> *)<span class="sig-paren">)</span><a class="headerlink" href="#c.phy_register_fixup" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new phy_fixup and adds it to the list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*bus_id</span></code></dt><dd><p>A string which matches phydev-&gt;mdio.dev.bus_id (or PHY_ANY_ID)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">phy_uid</span></code></dt><dd><p>Used to match against phydev-&gt;phy_id (the UID of the PHY)
It can also be PHY_ANY_UID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">phy_uid_mask</span></code></dt><dd><p>Applied to phydev-&gt;phy_id and fixup-&gt;phy_uid before
comparison</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*run)(struct</span> <span class="pre">phy_device</span> <span class="pre">*)</span></code></dt><dd><p>The actual code to be run when a matching PHY is found</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_unregister_fixup">
int <code class="sig-name descname">phy_unregister_fixup</code><span class="sig-paren">(</span>const char<em> *bus_id</em>, u32<em> phy_uid</em>, u32<em> phy_uid_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_unregister_fixup" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a phy_fixup from the list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*bus_id</span></code></dt><dd><p>A string matches fixup-&gt;bus_id (or PHY_ANY_ID) in phy_fixup_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">phy_uid</span></code></dt><dd><p>A phy id matches fixup-&gt;phy_id (or PHY_ANY_UID) in phy_fixup_list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">phy_uid_mask</span></code></dt><dd><p>Applied to phy_uid and fixup-&gt;phy_uid before comparison</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.get_phy_device">
struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a> * <code class="sig-name descname">get_phy_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, bool<em> is_c45</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_phy_device" title="Permalink to this definition">¶</a></dt>
<dd><p>reads the specified PHY device and returns its <strong>phy_device</strong> struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the target MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>PHY address on the MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_c45</span></code></dt><dd><p>If true the PHY uses the 802.3 clause 45 protocol</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Probe for a PHY at <strong>addr</strong> on <strong>bus</strong>.</p>
<p>When probing for a clause 22 PHY, then read the ID registers. If we find
a valid ID, allocate and return a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a>.</p>
<p>When probing for a clause 45 PHY, read the “devices in package” registers.
If the “devices in package” appears valid, read the ID registers for each
MMD, allocate and return a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a>.</p>
<p>Returns an allocated <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a> on success, <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code> if there is
no PHY present, or <code class="docutils literal notranslate"><span class="pre">-EIO</span></code> on bus access error.</p>
</div>
<dl class="function">
<dt id="c.phy_device_register">
int <code class="sig-name descname">phy_device_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the phy device on the MDIO bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>phy_device structure to be added to the MDIO bus</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_device_remove">
void <code class="sig-name descname">phy_device_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_device_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a previously registered phy device from the MDIO bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>phy_device structure to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This doesn’t free the phy_device itself, it merely reverses the effects
of <a class="reference internal" href="#c.phy_device_register" title="phy_device_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_device_register()</span></code></a>. Use phy_device_free() to free the device
after calling this function.</p>
</div>
<dl class="function">
<dt id="c.phy_get_c45_ids">
int <code class="sig-name descname">phy_get_c45_ids</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_get_c45_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Read 802.3-c45 IDs for phy device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>phy_device structure to read 802.3-c45 IDs</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero on success, <code class="docutils literal notranslate"><span class="pre">-EIO</span></code> on bus access error, or <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code> if
the “devices in package” is invalid.</p>
</div>
<dl class="function">
<dt id="c.phy_find_first">
struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a> * <code class="sig-name descname">phy_find_first</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_find_first" title="Permalink to this definition">¶</a></dt>
<dd><p>finds the first PHY device on the bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the target MII bus</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_connect_direct">
int <code class="sig-name descname">phy_connect_direct</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, void (<em>*handler</em>)(struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *), <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_connect_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>connect an ethernet device to a specific phy_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>the network device to connect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>the pointer to the phy device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*handler)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span></code></dt><dd><p>callback function for state change notifications</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>PHY device’s interface</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_connect">
struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a> * <code class="sig-name descname">phy_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, const char<em> *bus_id</em>, void (<em>*handler</em>)(struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *), <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect an ethernet device to a PHY device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>the network device to connect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*bus_id</span></code></dt><dd><p>the id string of the PHY device to connect</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*handler)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span></code></dt><dd><p>callback function for state change notifications</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>PHY device’s interface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Convenience function for connecting ethernet</dt><dd><p>devices to PHY devices.  The default behavior is for
the PHY infrastructure to handle everything, and only notify
the connected driver when the link status changes.  If you
don’t want, or can’t use the provided functionality, you may
choose to call only the subset of functions which provide
the desired functionality.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_disconnect">
void <code class="sig-name descname">phy_disconnect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disable interrupts, stop state machine, and detach a PHY device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_sfp_attach">
void <code class="sig-name descname">phy_sfp_attach</code><span class="sig-paren">(</span>void<em> *upstream</em>, struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_sfp_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach the SFP bus to the PHY upstream network device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*upstream</span></code></dt><dd><p>pointer to the phy device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>sfp bus representing cage being attached</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to fill in the sfp_upstream_ops .attach member.</p>
</div>
<dl class="function">
<dt id="c.phy_sfp_detach">
void <code class="sig-name descname">phy_sfp_detach</code><span class="sig-paren">(</span>void<em> *upstream</em>, struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_sfp_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>detach the SFP bus from the PHY upstream network device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*upstream</span></code></dt><dd><p>pointer to the phy device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>sfp bus representing cage being attached</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to fill in the sfp_upstream_ops .detach member.</p>
</div>
<dl class="function">
<dt id="c.phy_sfp_probe">
int <code class="sig-name descname">phy_sfp_probe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, const struct <a class="reference internal" href="#c.sfp_upstream_ops" title="sfp_upstream_ops">sfp_upstream_ops</a><em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_sfp_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>probe for a SFP cage attached to this PHY device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>Pointer to phy_device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sfp_upstream_ops</span> <span class="pre">*ops</span></code></dt><dd><p>SFP’s upstream operations</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_attach_direct">
int <code class="sig-name descname">phy_attach_direct</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> flags</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_attach_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a network device to a given PHY device pointer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>Pointer to phy_device to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>PHY device’s dev_flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>PHY device’s interface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Called by drivers to attach to a particular PHY</dt><dd><p>device. The phy_device is found, and properly hooked up
to the phy_driver.  If no driver is attached, then a
generic driver is used.  The phy_device is given a ptr to
the attaching device, and given a callback for link status
change.  The phy_device is returned to the attaching driver.
This function takes a reference on the phy device.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_attach">
struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a> * <code class="sig-name descname">phy_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em> *dev</em>, const char<em> *bus_id</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a network device to a particular PHY device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code></dt><dd><p>network device to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*bus_id</span></code></dt><dd><p>Bus ID of PHY device to attach</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>PHY device’s interface</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Same as phy_attach_direct() except that a PHY bus_id</dt><dd><p>string is passed instead of a pointer to a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_package_join">
int <code class="sig-name descname">phy_package_join</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> addr</em>, size_t<em> priv_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_package_join" title="Permalink to this definition">¶</a></dt>
<dd><p>join a common PHY group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>cookie and PHY address for global register access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">priv_size</span></code></dt><dd><p>if non-zero allocate this amount of bytes for private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This joins a PHY group and provides a shared storage for all phydevs in
this group. This is intended to be used for packages which contain
more than one PHY, for example a quad PHY transceiver.</p>
<p>The addr parameter serves as a cookie which has to have the same value
for all members of one group and as a PHY address to access generic
registers of a PHY package. Usually, one of the PHY addresses of the
different PHYs in the package provides access to these global registers.
The address which is given here, will be used in the phy_package_read()
and phy_package_write() convenience functions. If your PHY doesn’t have
global registers you can just pick any of the PHY addresses.</p>
<p>This will set the shared pointer of the phydev to the shared storage.
If this is the first call for a this cookie the shared storage will be
allocated. If priv_size is non-zero, the given amount of bytes are
allocated for the priv member.</p>
<p>Returns &lt; 1 on error, 0 on success. Esp. calling <a class="reference internal" href="#c.phy_package_join" title="phy_package_join"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_package_join()</span></code></a>
with the same cookie but a different priv_size is an error.</p>
</div>
<dl class="function">
<dt id="c.phy_package_leave">
void <code class="sig-name descname">phy_package_leave</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_package_leave" title="Permalink to this definition">¶</a></dt>
<dd><p>leave a common PHY group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This leaves a PHY group created by <a class="reference internal" href="#c.phy_package_join" title="phy_package_join"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_package_join()</span></code></a>. If this phydev
was the last user of the shared data between the group, this data is
freed. Resets the phydev-&gt;shared pointer to NULL.</p>
</div>
<dl class="function">
<dt id="c.devm_phy_package_join">
int <code class="sig-name descname">devm_phy_package_join</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, int<em> addr</em>, size_t<em> priv_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_phy_package_join" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed <a class="reference internal" href="#c.phy_package_join" title="phy_package_join"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_package_join()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device that is registering this PHY package</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>cookie and PHY address for global register access</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">priv_size</span></code></dt><dd><p>if non-zero allocate this amount of bytes for private data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.phy_package_join" title="phy_package_join"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_package_join()</span></code></a>. Shared storage fetched by this function,
<a class="reference internal" href="#c.phy_package_leave" title="phy_package_leave"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_package_leave()</span></code></a> is automatically called on driver detach. See
<a class="reference internal" href="#c.phy_package_join" title="phy_package_join"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_package_join()</span></code></a> for more information.</p>
</div>
<dl class="function">
<dt id="c.phy_detach">
void <code class="sig-name descname">phy_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>detach a PHY device from its network device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This detaches the phy device from its network device and the phy
driver, and drops the reference count taken in <a class="reference internal" href="#c.phy_attach_direct" title="phy_attach_direct"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_attach_direct()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.phy_reset_after_clk_enable">
int <code class="sig-name descname">phy_reset_after_clk_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_reset_after_clk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a PHY reset if needed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Some PHYs are known to need a reset after their refclk was</dt><dd><p>enabled. This function evaluates the flags and perform the reset if it’s
needed. Returns &lt; 0 on error, 0 if the phy wasn’t reset and 1 if the phy
was reset.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_config_eee_advert">
int <code class="sig-name descname">genphy_config_eee_advert</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_config_eee_advert" title="Permalink to this definition">¶</a></dt>
<dd><p>disable unwanted eee mode advertisement</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Writes MDIO_AN_EEE_ADV after disabling unsupported energy</dt><dd><p>efficent ethernet modes. Returns 0 if the PHY’s advertisement hasn’t
changed, and 1 if it has changed.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_setup_forced">
int <code class="sig-name descname">genphy_setup_forced</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_setup_forced" title="Permalink to this definition">¶</a></dt>
<dd><p>configures/forces speed/duplex from <strong>phydev</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Configures MII_BMCR to force speed/duplex</dt><dd><p>to the values in phydev. Assumes that the values are valid.
Please see <a class="reference internal" href="#c.phy_sanitize_settings" title="phy_sanitize_settings"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_sanitize_settings()</span></code></a>.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_restart_aneg">
int <code class="sig-name descname">genphy_restart_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_restart_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable and Restart Autonegotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_check_and_restart_aneg">
int <code class="sig-name descname">genphy_check_and_restart_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, bool<em> restart</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_check_and_restart_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable and restart auto-negotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">restart</span></code></dt><dd><p>whether aneg restart is requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check, and restart auto-negotiation if needed.</p>
</div>
<dl class="function">
<dt id="c.__genphy_config_aneg">
int <code class="sig-name descname">__genphy_config_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, bool<em> changed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__genphy_config_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>restart auto-negotiation or write BMCR</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">changed</span></code></dt><dd><p>whether autoneg is requested</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>If auto-negotiation is enabled, we configure the</dt><dd><p>advertising, and then restart auto-negotiation.  If it is not
enabled, then we write the BMCR.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_c37_config_aneg">
int <code class="sig-name descname">genphy_c37_config_aneg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c37_config_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>restart auto-negotiation or write BMCR</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>If auto-negotiation is enabled, we configure the</dt><dd><p>advertising, and then restart auto-negotiation.  If it is not
enabled, then we write the BMCR. This function is intended
for use with Clause 37 1000Base-X mode.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_aneg_done">
int <code class="sig-name descname">genphy_aneg_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_aneg_done" title="Permalink to this definition">¶</a></dt>
<dd><p>return auto-negotiation status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Reads the status register and returns 0 either if</dt><dd><p>auto-negotiation is incomplete, or if there was an error.
Returns BMSR_ANEGCOMPLETE if auto-negotiation is done.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_update_link">
int <code class="sig-name descname">genphy_update_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_update_link" title="Permalink to this definition">¶</a></dt>
<dd><p>update link status in <strong>phydev</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Update the value in phydev-&gt;link to reflect the</dt><dd><p>current link value.  In order to do this, we need to read
the status register twice, keeping the second value.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_read_status_fixed">
int <code class="sig-name descname">genphy_read_status_fixed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_read_status_fixed" title="Permalink to this definition">¶</a></dt>
<dd><p>read the link parameters for !aneg mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the current duplex and speed state for a PHY operating with
autonegotiation disabled.</p>
</div>
<dl class="function">
<dt id="c.genphy_read_status">
int <code class="sig-name descname">genphy_read_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_read_status" title="Permalink to this definition">¶</a></dt>
<dd><p>check the link status and update current link state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Check the link, then figure out the current state</dt><dd><p>by comparing what we advertise with what the link partner
advertises.  Start by checking the gigabit possibilities,
then move on to 10/100.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_c37_read_status">
int <code class="sig-name descname">genphy_c37_read_status</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c37_read_status" title="Permalink to this definition">¶</a></dt>
<dd><p>check the link status and update current link state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Check the link, then figure out the current state</dt><dd><p>by comparing what we advertise with what the link partner
advertises. This function is for Clause 37 1000Base-X mode.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_soft_reset">
int <code class="sig-name descname">genphy_soft_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_soft_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>software reset the PHY via BMCR_RESET bit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform a software PHY reset using the standard
BMCR_RESET bit and poll for the reset bit to be cleared.</p>
<p><strong>Return</strong></p>
<p>0 on success, &lt; 0 on failure</p>
</div>
<dl class="function">
<dt id="c.genphy_read_abilities">
int <code class="sig-name descname">genphy_read_abilities</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_read_abilities" title="Permalink to this definition">¶</a></dt>
<dd><p>read PHY abilities from Clause 22 registers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads the PHY’s abilities and populates
phydev-&gt;supported accordingly.</p>
<p><strong>Return</strong></p>
<p>0 on success, &lt; 0 on failure</p>
</div>
<dl class="function">
<dt id="c.phy_remove_link_mode">
void <code class="sig-name descname">phy_remove_link_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, u32<em> link_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_remove_link_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a supported link mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>phy_device structure to remove link mode from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">link_mode</span></code></dt><dd><p>Link mode to be removed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some MACs don’t support all link modes which the PHY
does.  e.g. a 1G MAC often does not support 1000Half. Add a helper
to remove a link mode.</p>
</div>
<dl class="function">
<dt id="c.phy_advertise_supported">
void <code class="sig-name descname">phy_advertise_supported</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_advertise_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>Advertise all supported modes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called to advertise all supported modes, doesn’t touch
pause mode advertising.</p>
</div>
<dl class="function">
<dt id="c.phy_support_sym_pause">
void <code class="sig-name descname">phy_support_sym_pause</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_support_sym_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable support of symmetrical pause</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by the MAC to indicate is supports symmetrical
Pause, but not asym pause.</p>
</div>
<dl class="function">
<dt id="c.phy_support_asym_pause">
void <code class="sig-name descname">phy_support_asym_pause</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_support_asym_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable support of asym pause</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by the MAC to indicate is supports Asym Pause.</p>
</div>
<dl class="function">
<dt id="c.phy_set_sym_pause">
void <code class="sig-name descname">phy_set_sym_pause</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, bool<em> rx</em>, bool<em> tx</em>, bool<em> autoneg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_set_sym_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure symmetric Pause</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">rx</span></code></dt><dd><p>Receiver Pause is supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">tx</span></code></dt><dd><p>Transmit Pause is supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">autoneg</span></code></dt><dd><p>Auto neg should be used</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure advertised Pause support depending on if
receiver pause and pause auto neg is supported. Generally called
from the set_pauseparam .ndo.</p>
</div>
<dl class="function">
<dt id="c.phy_set_asym_pause">
void <code class="sig-name descname">phy_set_asym_pause</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, bool<em> rx</em>, bool<em> tx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_set_asym_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure Pause and Asym Pause</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">rx</span></code></dt><dd><p>Receiver Pause is supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">tx</span></code></dt><dd><p>Transmit Pause is supported</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure advertised Pause support depending on if
transmit and receiver pause is supported. If there has been a
change in adverting, trigger a new autoneg. Generally called from
the set_pauseparam .ndo.</p>
</div>
<dl class="function">
<dt id="c.phy_validate_pause">
bool <code class="sig-name descname">phy_validate_pause</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, struct ethtool_pauseparam<em> *pp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_validate_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the PHY/MAC support the pause configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_pauseparam</span> <span class="pre">*pp</span></code></dt><dd><p>requested pause configuration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test if the PHY/MAC combination supports the Pause
configuration the user is requesting. Returns True if it is
supported, false otherwise.</p>
</div>
<dl class="function">
<dt id="c.phy_get_pause">
void <code class="sig-name descname">phy_get_pause</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, bool<em> *tx_pause</em>, bool<em> *rx_pause</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_get_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>resolve negotiated pause modes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*tx_pause</span></code></dt><dd><p>pointer to bool to indicate whether transmit pause should be
enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">*rx_pause</span></code></dt><dd><p>pointer to bool to indicate whether receive pause should be
enabled.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resolve and return the flow control modes according to the negotiation
result. This includes checking that we are operating in full duplex mode.
See linkmode_resolve_pause() for further details.</p>
</div>
<dl class="function">
<dt id="c.phy_get_internal_delay">
s32 <code class="sig-name descname">phy_get_internal_delay</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const int<em> *delay_values</em>, int<em> size</em>, bool<em> is_rx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_get_internal_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the index of the internal delay</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>pointer to the devices device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">*delay_values</span></code></dt><dd><p>array of delays the PHY supports</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the size of the delay array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_rx</span></code></dt><dd><p>boolean to indicate to get the rx internal delay</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the index within the array of internal delay passed in.
If the device property is not present then the interface type is checked
if the interface defines use of internal delay then a 1 is returned otherwise
a 0 is returned.
The array must be in ascending order. If PHY does not have an ascending order
array then size = 0 and the value of the delay property is returned.
Return -EINVAL if the delay is invalid or cannot be found.</p>
</div>
<dl class="function">
<dt id="c.fwnode_mdio_find_device">
struct mdio_device * <code class="sig-name descname">fwnode_mdio_find_device</code><span class="sig-paren">(</span>struct fwnode_handle<em> *fwnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fwnode_mdio_find_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a fwnode, find the mdio_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>pointer to the mdio_device’s fwnode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If successful, returns a pointer to the mdio_device with the embedded
<a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> refcount incremented by one, or NULL on failure.
The caller should call <a class="reference internal" href="../driver-api/infrastructure.html#c.put_device" title="put_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">put_device()</span></code></a> on the mdio_device after its use.</p>
</div>
<dl class="function">
<dt id="c.fwnode_phy_find_device">
struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a> * <code class="sig-name descname">fwnode_phy_find_device</code><span class="sig-paren">(</span>struct fwnode_handle<em> *phy_fwnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fwnode_phy_find_device" title="Permalink to this definition">¶</a></dt>
<dd><p>For provided phy_fwnode, find phy_device.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*phy_fwnode</span></code></dt><dd><p>Pointer to the phy’s fwnode.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If successful, returns a pointer to the phy_device with the embedded
<a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> refcount incremented by one, or NULL on failure.</p>
</div>
<dl class="function">
<dt id="c.device_phy_find_device">
struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a> * <code class="sig-name descname">device_phy_find_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_phy_find_device" title="Permalink to this definition">¶</a></dt>
<dd><p>For the given device, get the phy_device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Pointer to the given device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refer return conditions of <a class="reference internal" href="#c.fwnode_phy_find_device" title="fwnode_phy_find_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">fwnode_phy_find_device()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.fwnode_get_phy_node">
struct fwnode_handle * <code class="sig-name descname">fwnode_get_phy_node</code><span class="sig-paren">(</span>struct fwnode_handle<em> *fwnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fwnode_get_phy_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the phy_node using the named reference.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>Pointer to fwnode from which phy_node has to be obtained.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refer return conditions of fwnode_find_reference().
For ACPI, only “phy-handle” is supported. Legacy DT properties “phy”
and “phy-device” are not supported in ACPI. DT supports all the three
named references to the phy node.</p>
</div>
<dl class="function">
<dt id="c.phy_driver_register">
int <code class="sig-name descname">phy_driver_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_driver" title="phy_driver">phy_driver</a><em> *new_driver</em>, struct module<em> *owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_driver_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a phy_driver with the PHY layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_driver</span> <span class="pre">*new_driver</span></code></dt><dd><p>new phy_driver to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module owning this PHY</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.get_phy_c45_ids">
int <code class="sig-name descname">get_phy_c45_ids</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, struct <a class="reference internal" href="#c.phy_c45_device_ids" title="phy_c45_device_ids">phy_c45_device_ids</a><em> *c45_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_phy_c45_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>reads the specified addr for its 802.3-c45 IDs.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the target MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>PHY address on the MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_c45_device_ids</span> <span class="pre">*c45_ids</span></code></dt><dd><p>where to store the c45 ID information.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the PHY “devices in package”. If this appears to be valid, read
the PHY identifiers for each device. Return the “devices in package”
and identifiers in <strong>c45_ids</strong>.</p>
<p>Returns zero on success, <code class="docutils literal notranslate"><span class="pre">-EIO</span></code> on bus access error, or <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code> if
the “devices in package” is invalid.</p>
</div>
<dl class="function">
<dt id="c.get_phy_c22_id">
int <code class="sig-name descname">get_phy_c22_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, u32<em> *phy_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_phy_c22_id" title="Permalink to this definition">¶</a></dt>
<dd><p>reads the specified addr for its clause 22 ID.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the target MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>PHY address on the MII bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">*phy_id</span></code></dt><dd><p>where to store the ID retrieved.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the 802.3 clause 22 PHY ID from the PHY at <strong>addr</strong> on the <strong>bus</strong>,
placing it in <strong>phy_id</strong>. Return zero on successful read and the ID is
valid, <code class="docutils literal notranslate"><span class="pre">-EIO</span></code> on bus access error, or <code class="docutils literal notranslate"><span class="pre">-ENODEV</span></code> if no device responds
or invalid ID.</p>
</div>
<dl class="function">
<dt id="c.phy_prepare_link">
void <code class="sig-name descname">phy_prepare_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em>, void (<em>*handler</em>)(struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *)<span class="sig-paren">)</span><a class="headerlink" href="#c.phy_prepare_link" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares the PHY layer to monitor link status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*handler)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span></code></dt><dd><p>callback function for link status change notifications</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Tells the PHY infrastructure to handle the</dt><dd><p>gory details on monitoring link status (whether through
polling or an interrupt), and to call back to the
connected device driver when the link status changes.
If you want to monitor your own link state, don’t call
this function.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_poll_reset">
int <code class="sig-name descname">phy_poll_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_poll_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely wait until a PHY reset has properly completed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>The PHY device to poll</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl>
<dt>According to IEEE 802.3, Section 2, Subsection 22.2.4.1.1, as</dt><dd><p>published in 2008, a PHY reset may take up to 0.5 seconds.  The MII BMCR
register must be polled until the BMCR_RESET bit clears.</p>
<p>Furthermore, any attempts to write to PHY registers may have no effect
or even generate MDIO bus errors until this is complete.</p>
<p>Some PHYs (such as the Marvell 88E1111) don’t entirely conform to the
standard and do not fully reset after the BMCR_RESET bit is set, and may
even <em>REQUIRE</em> a soft-reset to properly restart autonegotiation.  In an
effort to support such broken PHYs, this function is separate from the
standard phy_init_hw() which will zero all the other bits in the BMCR
and reapply all driver-specific and board-specific fixups.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_config_advert">
int <code class="sig-name descname">genphy_config_advert</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_config_advert" title="Permalink to this definition">¶</a></dt>
<dd><p>sanitize and advertise auto-negotiation parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Writes MII_ADVERTISE with the appropriate values,</dt><dd><p>after sanitizing the values to make sure we only advertise
what is supported.  Returns &lt; 0 on error, 0 if the PHY’s advertisement
hasn’t changed, and &gt; 0 if it has changed.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.genphy_c37_config_advert">
int <code class="sig-name descname">genphy_c37_config_advert</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_c37_config_advert" title="Permalink to this definition">¶</a></dt>
<dd><p>sanitize and advertise auto-negotiation parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phydev</span></code></dt><dd><p>target phy_device struct</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Writes MII_ADVERTISE with the appropriate values,</dt><dd><p>after sanitizing the values to make sure we only advertise
what is supported.  Returns &lt; 0 on error, 0 if the PHY’s advertisement
hasn’t changed, and &gt; 0 if it has changed. This function is intended
for Clause 37 1000Base-X mode.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phy_probe">
int <code class="sig-name descname">phy_probe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>probe and init a PHY device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to probe and init</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Take care of setting up the phy_device structure,</dt><dd><p>set the state to READY (the driver’s init function should
set it to STARTING if needed).</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.mdiobus_alloc_size">
struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a> * <code class="sig-name descname">mdiobus_alloc_size</code><span class="sig-paren">(</span>size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_alloc_size" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a mii_bus structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>extra amount of memory to allocate for private storage.
If non-zero, then bus-&gt;priv is points to that memory.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called by a bus driver to allocate an mii_bus
structure to fill in.</p>
</div>
<dl class="function">
<dt id="c.mdio_find_bus">
struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a> * <code class="sig-name descname">mdio_find_bus</code><span class="sig-paren">(</span>const char<em> *mdio_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdio_find_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the name of a mdiobus, find the mii_bus.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*mdio_name</span></code></dt><dd><p>The name of a mdiobus.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a reference to the mii_bus, or NULL if none found.  The
embedded <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> will have its reference count incremented,
and this must be put_deviced’ed once the bus is finished with.</p>
</div>
<dl class="function">
<dt id="c.of_mdio_find_bus">
struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a> * <code class="sig-name descname">of_mdio_find_bus</code><span class="sig-paren">(</span>struct device_node<em> *mdio_bus_np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_mdio_find_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an mii_bus node, find the mii_bus.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*mdio_bus_np</span></code></dt><dd><p>Pointer to the mii_bus.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a reference to the mii_bus, or NULL if none found.  The
embedded <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> will have its reference count incremented,
and this must be put once the bus is finished with.</p>
<p>Because the association of a device_node and mii_bus is made via
of_mdiobus_register(), the mii_bus cannot be found before it is
registered with of_mdiobus_register().</p>
</div>
<dl class="function">
<dt id="c.__mdiobus_register">
int <code class="sig-name descname">__mdiobus_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, struct module<em> *owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mdiobus_register" title="Permalink to this definition">¶</a></dt>
<dd><p>bring up all the PHYs on a given bus and attach them to bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>target mii_bus</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*owner</span></code></dt><dd><p>module containing bus accessor functions</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Called by a bus driver to bring up all the PHYs</dt><dd><p>on a given bus, and attach them to the bus. Drivers should use
mdiobus_register() rather than <a class="reference internal" href="#c.__mdiobus_register" title="__mdiobus_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">__mdiobus_register()</span></code></a> unless they
need to pass a specific owner module. MDIO devices which are not
PHYs will not be brought up by this function. They are expected
to be explicitly listed in DT and instantiated by of_mdiobus_register().</p>
</dd>
</dl>
<p>Returns 0 on success or &lt; 0 on error.</p>
</div>
<dl class="function">
<dt id="c.mdiobus_free">
void <code class="sig-name descname">mdiobus_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a <a class="reference internal" href="#c.mii_bus" title="mii_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>mii_bus to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function releases the reference to the underlying device
object in the mii_bus.  If this is the last reference, the mii_bus
will be freed.</p>
</div>
<dl class="function">
<dt id="c.mdiobus_scan">
struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a> * <code class="sig-name descname">mdiobus_scan</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>scan a bus for MDIO devices.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>mii_bus to scan</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>address on bus to scan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function scans the MDIO bus, looking for devices which can be
identified using a vendor/product ID in registers 2 and 3. Not all
MDIO devices have such registers, but PHY devices typically
do. Hence this function assumes anything found is a PHY, or can be
treated as a PHY. Other MDIO devices, such as switches, will
probably not be found during the scan.</p>
</div>
<dl class="function">
<dt id="c.__mdiobus_read">
int <code class="sig-name descname">__mdiobus_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, u32<em> regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mdiobus_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlocked version of the mdiobus_read function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read a MDIO bus register. Caller must hold the mdio bus lock.</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context.</p>
</div>
<dl class="function">
<dt id="c.__mdiobus_write">
int <code class="sig-name descname">__mdiobus_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mdiobus_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlocked version of the mdiobus_write function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>value to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write a MDIO bus register. Caller must hold the mdio bus lock.</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context.</p>
</div>
<dl class="function">
<dt id="c.__mdiobus_modify_changed">
int <code class="sig-name descname">__mdiobus_modify_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mdiobus_modify_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlocked version of the mdiobus_modify function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to modify</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>bit mask of bits to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read, modify, and if any change, write the register value back to the
device. Any error returns a negative number.</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context.</p>
</div>
<dl class="function">
<dt id="c.mdiobus_read_nested">
int <code class="sig-name descname">mdiobus_read_nested</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, u32<em> regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_read_nested" title="Permalink to this definition">¶</a></dt>
<dd><p>Nested version of the mdiobus_read function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In case of nested MDIO bus access avoid lockdep false positives by
using mutex_lock_nested().</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
</div>
<dl class="function">
<dt id="c.mdiobus_read">
int <code class="sig-name descname">mdiobus_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, u32<em> regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for reading a given MII mgmt register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to read</p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
</div>
<dl class="function">
<dt id="c.mdiobus_write_nested">
int <code class="sig-name descname">mdiobus_write_nested</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_write_nested" title="Permalink to this definition">¶</a></dt>
<dd><p>Nested version of the mdiobus_write function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>value to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In case of nested MDIO bus access avoid lockdep false positives by
using mutex_lock_nested().</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
</div>
<dl class="function">
<dt id="c.mdiobus_write">
int <code class="sig-name descname">mdiobus_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, u32<em> regnum</em>, u16<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for writing a given MII mgmt register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">val</span></code></dt><dd><p>value to write to <strong>regnum</strong></p>
</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
</div>
<dl class="function">
<dt id="c.mdiobus_modify">
int <code class="sig-name descname">mdiobus_modify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_modify" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for modifying a given mdio device register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>bit mask of bits to set</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.mdiobus_modify_changed">
int <code class="sig-name descname">mdiobus_modify_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, int<em> addr</em>, u32<em> regnum</em>, u16<em> mask</em>, u16<em> set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_modify_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for modifying a given mdio device register and returning if it changed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the mii_bus struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">addr</span></code></dt><dd><p>the phy address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt><dd><p>register number to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">mask</span></code></dt><dd><p>bit mask of bits to clear</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">set</span></code></dt><dd><p>bit mask of bits to set</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.mdiobus_release">
void <code class="sig-name descname">mdiobus_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_release" title="Permalink to this definition">¶</a></dt>
<dd><p>mii_bus device release callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*d</span></code></dt><dd><p>the target <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> that contains the mii_bus</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called when the last reference to an mii_bus is
dropped, to free the underlying memory.</p>
</div>
<dl class="function">
<dt id="c.mdiobus_create_device">
int <code class="sig-name descname">mdiobus_create_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.mii_bus" title="mii_bus">mii_bus</a><em> *bus</em>, struct mdio_board_info<em> *bi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_create_device" title="Permalink to this definition">¶</a></dt>
<dd><p>create a full MDIO device given a mdio_board_info structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*bus</span></code></dt><dd><p>MDIO bus to create the devices on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_board_info</span> <span class="pre">*bi</span></code></dt><dd><p>mdio_board_info structure describing the devices</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or &lt; 0 on error.</p>
</div>
<dl class="function">
<dt id="c.mdio_bus_match">
int <code class="sig-name descname">mdio_bus_match</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct device_driver<em> *drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdio_bus_match" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if given MDIO driver supports the given MDIO device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>target MDIO device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*drv</span></code></dt><dd><p>given MDIO driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="simple">
<dt>Given a MDIO device, and a MDIO driver, return 1 if</dt><dd><p>the driver supports the device.  Otherwise, return 0. This may
require calling the devices own match function, since different classes
of MDIO devices have different match criteria.</p>
</dd>
</dl>
</div>
</section>
<section id="phylink">
<h3>PHYLINK<a class="headerlink" href="#phylink" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>PHYLINK interfaces traditional network drivers with PHYLIB, fixed-links,
and SFF modules (eg, hot-pluggable SFP) that may contain PHYs.  PHYLINK
provides management of the link state and link modes.</p>
</div></blockquote>
<dl class="type">
<dt id="c.phylink_link_state">
struct <code class="sig-name descname">phylink_link_state</code><a class="headerlink" href="#c.phylink_link_state" title="Permalink to this definition">¶</a></dt>
<dd><p>link state structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phylink_link_state {
    unsigned long advertising[BITS_TO_LONGS(__ETHTOOL_LINK_MODE_MASK_NBITS)];
    unsigned long lp_advertising[BITS_TO_LONGS(__ETHTOOL_LINK_MODE_MASK_NBITS)];
    phy_interface_t interface;
    int speed;
    int duplex;
    int pause;
    int rate_matching;
    unsigned int link:1;
    unsigned int an_enabled:1;
    unsigned int an_complete:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">advertising</span></code></dt><dd><p>ethtool bitmask containing advertised link modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lp_advertising</span></code></dt><dd><p>ethtool bitmask containing link partner advertised link
modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">interface</span></code></dt><dd><p>link <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code></a> mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">speed</span></code></dt><dd><p>link speed, one of the SPEED_* constants.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">duplex</span></code></dt><dd><p>link duplex mode, one of DUPLEX_* constants.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pause</span></code></dt><dd><p>link pause state, described by MLO_PAUSE_* constants.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rate_matching</span></code></dt><dd><p>rate matching being performed, one of the RATE_MATCH_*
constants. If rate matching is taking place, then the speed/duplex of
the medium link mode (<strong>speed</strong> and <strong>duplex</strong>) and the speed/duplex of the phy
interface mode (<strong>interface</strong>) are different.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link</span></code></dt><dd><p>true if the link is up.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">an_enabled</span></code></dt><dd><p>true if autonegotiation is enabled/desired.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">an_complete</span></code></dt><dd><p>true if autonegotiation has completed.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.phylink_config">
struct <code class="sig-name descname">phylink_config</code><a class="headerlink" href="#c.phylink_config" title="Permalink to this definition">¶</a></dt>
<dd><p>PHYLINK configuration structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phylink_config {
    struct device *dev;
    enum phylink_op_type type;
    bool legacy_pre_march2020;
    bool poll_fixed_state;
    bool mac_managed_pm;
    bool ovr_an_inband;
    void (*get_fixed_state)(struct phylink_config *config, struct phylink_link_state *state);
    unsigned long supported_interfaces[BITS_TO_LONGS(PHY_INTERFACE_MODE_MAX)];
    unsigned long mac_capabilities;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> associated with the MAC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>operation type of PHYLINK instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">legacy_pre_march2020</span></code></dt><dd><p>driver has not been updated for March 2020 updates
(See commit 7cceb599d15d (“net: phylink: avoid mac_config calls”)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll_fixed_state</span></code></dt><dd><p>if true, starts link_poll,
if MAC link is at <code class="docutils literal notranslate"><span class="pre">MLO_AN_FIXED</span></code> mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_managed_pm</span></code></dt><dd><p>if true, indicate the MAC driver is responsible for PHY PM.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ovr_an_inband</span></code></dt><dd><p>if true, override PCS to MLO_AN_INBAND</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_fixed_state</span></code></dt><dd><p>callback to execute to determine the fixed link state,
if MAC link is at <code class="docutils literal notranslate"><span class="pre">MLO_AN_FIXED</span></code> mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">supported_interfaces</span></code></dt><dd><p>bitmap describing which PHY_INTERFACE_MODE_xxx
are supported by the MAC/PCS.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_capabilities</span></code></dt><dd><p>MAC pause/speed/duplex capabilities.</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.phylink_mac_ops">
struct <code class="sig-name descname">phylink_mac_ops</code><a class="headerlink" href="#c.phylink_mac_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>MAC operations structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phylink_mac_ops {
    void (*validate)(struct phylink_config *config,unsigned long *supported, struct phylink_link_state *state);
    struct phylink_pcs *(*mac_select_pcs)(struct phylink_config *config, phy_interface_t interface);
    void (*mac_pcs_get_state)(struct phylink_config *config, struct phylink_link_state *state);
    int (*mac_prepare)(struct phylink_config *config, unsigned int mode, phy_interface_t iface);
    void (*mac_config)(struct phylink_config *config, unsigned int mode, const struct phylink_link_state *state);
    int (*mac_finish)(struct phylink_config *config, unsigned int mode, phy_interface_t iface);
    void (*mac_an_restart)(struct phylink_config *config);
    void (*mac_link_down)(struct phylink_config *config, unsigned int mode, phy_interface_t interface);
    void (*mac_link_up)(struct phylink_config *config,struct phy_device *phy, unsigned int mode,phy_interface_t interface, int speed, int duplex, bool tx_pause, bool rx_pause);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">validate</span></code></dt><dd><p>Validate and update the link configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_select_pcs</span></code></dt><dd><p>Select a PCS for the interface mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_pcs_get_state</span></code></dt><dd><p>Read the current link state from the hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_prepare</span></code></dt><dd><p>prepare for a major reconfiguration of the interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_config</span></code></dt><dd><p>configure the MAC for the selected mode and state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_finish</span></code></dt><dd><p>finish a major reconfiguration of the interface.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_an_restart</span></code></dt><dd><p>restart 802.3z BaseX autonegotiation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_link_down</span></code></dt><dd><p>take the link down.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mac_link_up</span></code></dt><dd><p>allow the link to come up.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The individual methods are described more fully below.</p>
<dl class="function">
<dt id="c.validate">
void <code class="sig-name descname">validate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a><em> *config</em>, unsigned long<em> *supported</em>, struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate and update the link configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*supported</span></code></dt><dd><p>ethtool bitmask for supported link modes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear bits in the <strong>supported</strong> and <strong>state-&gt;advertising</strong> masks that
are not supportable by the MAC.</p>
<p>Note that the PHY may be able to transform from one connection
technology to another, so, eg, don’t clear 1000BaseX just
because the MAC is unable to BaseX mode. This is more about
clearing unsupported speeds and duplex settings. The port modes
should not be cleared; <a class="reference internal" href="#c.phylink_set_port_modes" title="phylink_set_port_modes"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_set_port_modes()</span></code></a> will help with this.</p>
<p>When <strong>config-&gt;supported_interfaces</strong> has been set, phylink will iterate
over the supported interfaces to determine the full capability of the
MAC. The validation function must not print errors if <strong>state-&gt;interface</strong>
is set to an unexpected value.</p>
<p>When <strong>config-&gt;supported_interfaces</strong> is empty, phylink will call this
function with <strong>state-&gt;interface</strong> set to <code class="docutils literal notranslate"><span class="pre">PHY_INTERFACE_MODE_NA</span></code>, and
expects the MAC driver to return all supported link modes.</p>
<p>If the <strong>state-&gt;interface</strong> mode is not supported, then the <strong>supported</strong>
mask must be cleared.</p>
<p>This member is optional; if not set, the generic validator will be
used making use of <strong>config-&gt;mac_capabilities</strong> and
<strong>config-&gt;supported_interfaces</strong> to determine which link modes are
supported.</p>
</div>
<dl class="function">
<dt id="c.mac_select_pcs">
struct <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs">phylink_pcs</a> * <code class="sig-name descname">mac_select_pcs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a><em> *config</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_select_pcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a PCS for the interface mode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>PHY interface mode for PCS</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs</span></code></a> for the specified interface mode, or
NULL if none is required, or an error pointer on error.</p>
<p>This must not modify any state. It is used to query which PCS should
be used. Phylink will use this during validation to ensure that the
configuration is valid, and when setting a configuration to internally
set the PCS that will be used.</p>
</div>
<dl class="function">
<dt id="c.mac_pcs_get_state">
void <code class="sig-name descname">mac_pcs_get_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a><em> *config</em>, struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_pcs_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the current inband link state from the hardware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the current inband link state from the MAC PCS, reporting the
current speed in <strong>state-&gt;speed</strong>, duplex mode in <strong>state-&gt;duplex</strong>, pause
mode in <strong>state-&gt;pause</strong> using the <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_RX</span></code> and <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_TX</span></code> bits,
negotiation completion state in <strong>state-&gt;an_complete</strong>, and link up state
in <strong>state-&gt;link</strong>. If possible, <strong>state-&gt;lp_advertising</strong> should also be
populated.</p>
<p><strong>Note</strong></p>
<p>This is a legacy method. This function will not be called unless
legacy_pre_march2020 is set in <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a> and there is no
PCS attached.</p>
</div>
<dl class="function">
<dt id="c.mac_prepare">
int <code class="sig-name descname">mac_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a><em> *config</em>, unsigned int<em> mode</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> iface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare to change the PHY interface mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>one of <code class="docutils literal notranslate"><span class="pre">MLO_AN_FIXED</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_PHY</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_INBAND</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">iface</span></code></dt><dd><p>interface mode to switch to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>phylink will call this method at the beginning of a full initialisation
of the link, which includes changing the interface mode or at initial
startup time. It may be called for the current mode. The MAC driver
should perform whatever actions are required, e.g. disabling the
Serdes PHY.</p>
<p>This will be the first call in the sequence:
- <a class="reference internal" href="#c.mac_prepare" title="mac_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_prepare()</span></code></a>
- <a class="reference internal" href="#c.mac_config" title="mac_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_config()</span></code></a>
- <a class="reference internal" href="#c.pcs_config" title="pcs_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">pcs_config()</span></code></a>
- possible <a class="reference internal" href="#c.pcs_an_restart" title="pcs_an_restart"><code class="xref c c-func docutils literal notranslate"><span class="pre">pcs_an_restart()</span></code></a>
- <a class="reference internal" href="#c.mac_finish" title="mac_finish"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_finish()</span></code></a></p>
<p>Returns zero on success, or negative errno on failure which will be
reported to the kernel log.</p>
</div>
<dl class="function">
<dt id="c.mac_config">
void <code class="sig-name descname">mac_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a><em> *config</em>, unsigned int<em> mode</em>, const struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_config" title="Permalink to this definition">¶</a></dt>
<dd><p>configure the MAC for the selected mode and state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>one of <code class="docutils literal notranslate"><span class="pre">MLO_AN_FIXED</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_PHY</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_INBAND</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note - not all members of <strong>state</strong> are valid.  In particular,
<strong>state-&gt;lp_advertising</strong>, <strong>state-&gt;link</strong>, <strong>state-&gt;an_complete</strong> are never
guaranteed to be correct, and so any <a class="reference internal" href="#c.mac_config" title="mac_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_config()</span></code></a> implementation must
never reference these fields.</p>
<dl class="simple">
<dt>(this requires a rewrite - please refer to mac_link_up() for situations</dt><dd><p>where the PCS and MAC are not tightly integrated.)</p>
</dd>
</dl>
<p>In all negotiation modes, as defined by <strong>mode</strong>, <strong>state-&gt;pause</strong> indicates the
pause settings which should be applied as follows. If <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_AN</span></code> is not
set, <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_TX</span></code> and <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_RX</span></code> indicate whether the MAC should send
pause frames and/or act on received pause frames respectively. Otherwise,
the results of in-band negotiation/status from the MAC PCS should be used
to control the MAC pause mode settings.</p>
<p>The action performed depends on the currently selected mode:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">MLO_AN_FIXED</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_PHY</span></code>:</dt><dd><p>Configure for non-inband negotiation mode, where the link settings
are completely communicated via <a class="reference internal" href="#c.mac_link_up" title="mac_link_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_up()</span></code></a>.  The physical link
protocol from the MAC is specified by <strong>state-&gt;interface</strong>.</p>
<p><strong>state-&gt;advertising</strong> may be used, but is not required.</p>
<p>Older drivers (prior to the <a class="reference internal" href="#c.mac_link_up" title="mac_link_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_up()</span></code></a> change) may use <strong>state-&gt;speed</strong>,
<strong>state-&gt;duplex</strong> and <strong>state-&gt;pause</strong> to configure the MAC, but this is
deprecated; such drivers should be converted to use <a class="reference internal" href="#c.mac_link_up" title="mac_link_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_up()</span></code></a>.</p>
<p>Other members of <strong>state</strong> must be ignored.</p>
<p>Valid state members: interface, advertising.
Deprecated state members: speed, duplex, pause.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MLO_AN_INBAND</span></code>:</dt><dd><p>place the link in an inband negotiation mode (such as 802.3z
1000base-X or Cisco SGMII mode depending on the <strong>state-&gt;interface</strong>
mode). In both cases, link state management (whether the link
is up or not) is performed by the MAC, and reported via the
<a class="reference internal" href="#c.mac_pcs_get_state" title="mac_pcs_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_pcs_get_state()</span></code></a> callback. Changes in link state must be made
by calling <a class="reference internal" href="#c.phylink_mac_change" title="phylink_mac_change"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_mac_change()</span></code></a>.</p>
<p>Interface mode specific details are mentioned below.</p>
<p>If in 802.3z mode, the link speed is fixed, dependent on the
<strong>state-&gt;interface</strong>. Duplex and pause modes are negotiated via
the in-band configuration word. Advertised pause modes are set
according to the <strong>state-&gt;an_enabled</strong> and <strong>state-&gt;advertising</strong>
flags. Beware of MACs which only support full duplex at gigabit
and higher speeds.</p>
<p>If in Cisco SGMII mode, the link speed and duplex mode are passed
in the serial bitstream 16-bit configuration word, and the MAC
should be configured to read these bits and acknowledge the
configuration word. Nothing is advertised by the MAC. The MAC is
responsible for reading the configuration word and configuring
itself accordingly.</p>
<p>Valid state members: interface, an_enabled, pause, advertising.</p>
</dd>
</dl>
<p>Implementations are expected to update the MAC to reflect the
requested settings - i.o.w., if nothing has changed between two
calls, no action is expected.  If only flow control settings have
changed, flow control should be updated <em>without</em> taking the link
down.  This “update” behaviour is critical to avoid bouncing the
link up status.</p>
<p><strong>Note</strong></p>
<p>For legacy March 2020 drivers (drivers with legacy_pre_march2020 set
in their <code class="xref c c-type docutils literal notranslate"><span class="pre">phylnk_config</span></code> and which don’t have a PCS), this function will be
called on each link up event, and to also change the in-band advert. For
non-legacy drivers, it will only be called to reconfigure the MAC for a
“major” change in e.g. interface mode. It will not be called for changes
in speed, duplex or pause modes or to change the in-band advertisement.
In any case, it is strongly preferred that speed, duplex and pause settings
are handled in the <a class="reference internal" href="#c.mac_link_up" title="mac_link_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_up()</span></code></a> method and not in this method.</p>
</div>
<dl class="function">
<dt id="c.mac_finish">
int <code class="sig-name descname">mac_finish</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a><em> *config</em>, unsigned int<em> mode</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> iface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>finish a to change the PHY interface mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>one of <code class="docutils literal notranslate"><span class="pre">MLO_AN_FIXED</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_PHY</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_INBAND</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">iface</span></code></dt><dd><p>interface mode to switch to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>phylink will call this if it called <a class="reference internal" href="#c.mac_prepare" title="mac_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_prepare()</span></code></a> to allow the MAC to
complete any necessary steps after the MAC and PCS have been configured
for the <strong>mode</strong> and <strong>iface</strong>. E.g. a MAC driver may wish to re-enable the
Serdes PHY here if it was previously disabled by <a class="reference internal" href="#c.mac_prepare" title="mac_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_prepare()</span></code></a>.</p>
<p>Returns zero on success, or negative errno on failure which will be
reported to the kernel log.</p>
</div>
<dl class="function">
<dt id="c.mac_an_restart">
void <code class="sig-name descname">mac_an_restart</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a><em> *config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_an_restart" title="Permalink to this definition">¶</a></dt>
<dd><p>restart 802.3z BaseX autonegotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This is a legacy method. This function will not be called unless
legacy_pre_march2020 is set in <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a> and there is no
PCS attached.</p>
</div>
<dl class="function">
<dt id="c.mac_link_down">
void <code class="sig-name descname">mac_link_down</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a><em> *config</em>, unsigned int<em> mode</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_link_down" title="Permalink to this definition">¶</a></dt>
<dd><p>take the link down</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>link autonegotiation mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>link <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code></a> mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>mode</strong> is not an in-band negotiation mode (as defined by
phylink_autoneg_inband()), force the link down and disable any
Energy Efficient Ethernet MAC configuration. Interface type
selection must be done in <a class="reference internal" href="#c.mac_config" title="mac_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_config()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.mac_link_up">
void <code class="sig-name descname">mac_link_up</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a><em> *config</em>, struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phy</em>, unsigned int<em> mode</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em>, int<em> speed</em>, int<em> duplex</em>, bool<em> tx_pause</em>, bool<em> rx_pause</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mac_link_up" title="Permalink to this definition">¶</a></dt>
<dd><p>allow the link to come up</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phy</span></code></dt><dd><p>any attached phy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>link autonegotiation mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>link <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code></a> mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>link speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">duplex</span></code></dt><dd><p>link duplex</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">tx_pause</span></code></dt><dd><p>link transmit pause enablement status</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">rx_pause</span></code></dt><dd><p>link receive pause enablement status</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure the MAC for an established link.</p>
<p><strong>speed</strong>, <strong>duplex</strong>, <strong>tx_pause</strong> and <strong>rx_pause</strong> indicate the finalised link
settings, and should be used to configure the MAC block appropriately
where these settings are not automatically conveyed from the PCS block,
or if in-band negotiation (as defined by phylink_autoneg_inband(<strong>mode</strong>))
is disabled.</p>
<p>Note that when 802.3z in-band negotiation is in use, it is possible
that the user wishes to override the pause settings, and this should
be allowed when considering the implementation of this method.</p>
<p>If in-band negotiation mode is disabled, allow the link to come up. If
<strong>phy</strong> is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>, configure Energy Efficient Ethernet by calling
<a class="reference internal" href="#c.phy_init_eee" title="phy_init_eee"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_init_eee()</span></code></a> and perform appropriate MAC configuration for EEE.
Interface type selection must be done in <a class="reference internal" href="#c.mac_config" title="mac_config"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_config()</span></code></a>.</p>
</div>
<dl class="type">
<dt id="c.phylink_pcs">
struct <code class="sig-name descname">phylink_pcs</code><a class="headerlink" href="#c.phylink_pcs" title="Permalink to this definition">¶</a></dt>
<dd><p>PHYLINK PCS instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phylink_pcs {
    const struct phylink_pcs_ops *ops;
    bool poll;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.phylink_pcs_ops" title="phylink_pcs_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs_ops</span></code></a> structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">poll</span></code></dt><dd><p>poll the PCS for link changes</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is designed to be embedded within the PCS private data,
and will be passed between phylink and the PCS.</p>
<dl class="type">
<dt id="c.phylink_pcs_ops">
struct <code class="sig-name descname">phylink_pcs_ops</code><a class="headerlink" href="#c.phylink_pcs_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>MAC PCS operations structure.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phylink_pcs_ops {
    int (*pcs_validate)(struct phylink_pcs *pcs, unsigned long *supported, const struct phylink_link_state *state);
    void (*pcs_get_state)(struct phylink_pcs *pcs, struct phylink_link_state *state);
    int (*pcs_config)(struct phylink_pcs *pcs, unsigned int mode,phy_interface_t interface,const unsigned long *advertising, bool permit_pause_to_mac);
    void (*pcs_an_restart)(struct phylink_pcs *pcs);
    void (*pcs_link_up)(struct phylink_pcs *pcs, unsigned int mode, phy_interface_t interface, int speed, int duplex);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pcs_validate</span></code></dt><dd><p>validate the link configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcs_get_state</span></code></dt><dd><p>read the current MAC PCS link state from the hardware.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcs_config</span></code></dt><dd><p>configure the MAC PCS for the selected mode and state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcs_an_restart</span></code></dt><dd><p>restart 802.3z BaseX autonegotiation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcs_link_up</span></code></dt><dd><p>program the PCS for the resolved link configuration
(where necessary).</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.pcs_validate">
int <code class="sig-name descname">pcs_validate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs">phylink_pcs</a><em> *pcs</em>, unsigned long<em> *supported</em>, const struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcs_validate" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the link configuration.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs</span> <span class="pre">*pcs</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*supported</span></code></dt><dd><p>ethtool bitmask for supported link modes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*state</span></code></dt><dd><p>a const pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validate the interface mode, and advertising’s autoneg bit, removing any
media ethtool link modes that would not be supportable from the supported
mask. Phylink will propagate the changes to the advertising mask. See the
<a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_mac_ops</span></code></a> <a class="reference internal" href="#c.validate" title="validate"><code class="xref c c-func docutils literal notranslate"><span class="pre">validate()</span></code></a> method.</p>
<p>Returns -EINVAL if the interface mode/autoneg mode is not supported.
Returns non-zero positive if the link state can be supported.</p>
</div>
<dl class="function">
<dt id="c.pcs_get_state">
void <code class="sig-name descname">pcs_get_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs">phylink_pcs</a><em> *pcs</em>, struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcs_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the current inband link state from the hardware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs</span> <span class="pre">*pcs</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the current inband link state from the MAC PCS, reporting the
current speed in <strong>state-&gt;speed</strong>, duplex mode in <strong>state-&gt;duplex</strong>, pause
mode in <strong>state-&gt;pause</strong> using the <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_RX</span></code> and <code class="docutils literal notranslate"><span class="pre">MLO_PAUSE_TX</span></code> bits,
negotiation completion state in <strong>state-&gt;an_complete</strong>, and link up state
in <strong>state-&gt;link</strong>. If possible, <strong>state-&gt;lp_advertising</strong> should also be
populated.</p>
<p>When present, this overrides <a class="reference internal" href="#c.mac_pcs_get_state" title="mac_pcs_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_pcs_get_state()</span></code></a> in <a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">phylink_mac_ops</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.pcs_config">
int <code class="sig-name descname">pcs_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs">phylink_pcs</a><em> *pcs</em>, unsigned int<em> mode</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em>, const unsigned long<em> *advertising</em>, bool<em> permit_pause_to_mac</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcs_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the PCS mode and advertisement</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs</span> <span class="pre">*pcs</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>one of <code class="docutils literal notranslate"><span class="pre">MLO_AN_FIXED</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_PHY</span></code>, <code class="docutils literal notranslate"><span class="pre">MLO_AN_INBAND</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>interface mode to be used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*advertising</span></code></dt><dd><p>adertisement ethtool link mode mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">permit_pause_to_mac</span></code></dt><dd><p>permit forwarding pause resolution to MAC</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure the PCS for the operating mode, the interface mode, and set
the advertisement mask. <strong>permit_pause_to_mac</strong> indicates whether the
hardware may forward the pause mode resolution to the MAC.</p>
<p>When operating in <code class="docutils literal notranslate"><span class="pre">MLO_AN_INBAND</span></code>, inband should always be enabled,
otherwise inband should be disabled.</p>
<p>For SGMII, there is no advertisement from the MAC side, the PCS should
be programmed to acknowledge the inband word from the PHY.</p>
<p>For 1000BASE-X, the advertisement should be programmed into the PCS.</p>
<p>For most 10GBASE-R, there is no advertisement.</p>
</div>
<dl class="function">
<dt id="c.pcs_an_restart">
void <code class="sig-name descname">pcs_an_restart</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs">phylink_pcs</a><em> *pcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcs_an_restart" title="Permalink to this definition">¶</a></dt>
<dd><p>restart 802.3z BaseX autonegotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs</span> <span class="pre">*pcs</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When PCS ops are present, this overrides <a class="reference internal" href="#c.mac_an_restart" title="mac_an_restart"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_an_restart()</span></code></a> in <a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">phylink_mac_ops</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.pcs_link_up">
void <code class="sig-name descname">pcs_link_up</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs">phylink_pcs</a><em> *pcs</em>, unsigned int<em> mode</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em>, int<em> speed</em>, int<em> duplex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcs_link_up" title="Permalink to this definition">¶</a></dt>
<dd><p>program the PCS for the resolved link configuration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs</span> <span class="pre">*pcs</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_pcs" title="phylink_pcs"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_pcs</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>link autonegotiation mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>link <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code></a> mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>link speed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">duplex</span></code></dt><dd><p>link duplex</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call will be made just before <a class="reference internal" href="#c.mac_link_up" title="mac_link_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_up()</span></code></a> to inform the PCS of
the resolved link parameters. For example, a PCS operating in SGMII
mode without in-band AN needs to be manually configured for the link
and duplex setting. Otherwise, this should be a no-op.</p>
</div>
<dl class="function">
<dt id="c.phylink_get_link_timer_ns">
int <code class="sig-name descname">phylink_get_link_timer_ns</code><span class="sig-paren">(</span><a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_get_link_timer_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>return the PCS link timer value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>link <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code></a> mode</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the PCS link timer setting in nanoseconds for the PHY <strong>interface</strong>
mode, or -EINVAL if not appropriate.</p>
</div>
<dl class="type">
<dt id="c.phylink">
struct <code class="sig-name descname">phylink</code><a class="headerlink" href="#c.phylink" title="Permalink to this definition">¶</a></dt>
<dd><p>internal data type for phylink</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct phylink {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
</div>
<dl class="function">
<dt id="c.phylink_set_port_modes">
void <code class="sig-name descname">phylink_set_port_modes</code><span class="sig-paren">(</span>unsigned long<em> *mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_set_port_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>set the port type modes in the ethtool mask</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*mask</span></code></dt><dd><p>ethtool link mode mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets all the port type modes in the ethtool mask.  MAC drivers should
use this in their ‘validate’ callback.</p>
</div>
<dl class="function">
<dt id="c.phylink_interface_max_speed">
int <code class="sig-name descname">phylink_interface_max_speed</code><span class="sig-paren">(</span><a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_interface_max_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>get the maximum speed of a phy interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>phy interface mode defined by <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the maximum speed of a phy interface. This is intended to help
determine the correct speed to pass to the MAC when the phy is performing
rate matching.</p>
<p><strong>Return</strong></p>
<p>The maximum speed of <strong>interface</strong></p>
</div>
<dl class="function">
<dt id="c.phylink_caps_to_linkmodes">
void <code class="sig-name descname">phylink_caps_to_linkmodes</code><span class="sig-paren">(</span>unsigned long<em> *linkmodes</em>, unsigned long<em> caps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_caps_to_linkmodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert capabilities to ethtool link modes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*linkmodes</span></code></dt><dd><p>ethtool linkmode mask (must be already initialised)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">caps</span></code></dt><dd><p>bitmask of MAC capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set all possible pause, speed and duplex linkmodes in <strong>linkmodes</strong> that are
supported by the <strong>caps</strong>. <strong>linkmodes</strong> must have been initialised previously.</p>
</div>
<dl class="function">
<dt id="c.phylink_cap_from_speed_duplex">
unsigned long <code class="sig-name descname">phylink_cap_from_speed_duplex</code><span class="sig-paren">(</span>int<em> speed</em>, unsigned int<em> duplex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_cap_from_speed_duplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Get mac capability from speed/duplex</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">speed</span></code></dt><dd><p>the speed to search for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">duplex</span></code></dt><dd><p>the duplex to search for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the mac capability for a given speed and duplex.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>A mask with the mac capability patching <strong>speed</strong> and <strong>duplex</strong>, or 0 if</dt><dd><p>there were no matches.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phylink_get_capabilities">
unsigned long <code class="sig-name descname">phylink_get_capabilities</code><span class="sig-paren">(</span><a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em>, unsigned long<em> mac_capabilities</em>, int<em> rate_matching</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_get_capabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>get capabilities for a given MAC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>phy interface mode defined by <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mac_capabilities</span></code></dt><dd><p>bitmask of MAC capabilities</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">rate_matching</span></code></dt><dd><p>type of rate matching being performed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the MAC capabilities that are supported by the <strong>interface</strong> mode and
<strong>mac_capabilities</strong>.</p>
</div>
<dl class="function">
<dt id="c.phylink_validate_mask_caps">
void <code class="sig-name descname">phylink_validate_mask_caps</code><span class="sig-paren">(</span>unsigned long<em> *supported</em>, struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a><em> *state</em>, unsigned long<em> mac_capabilities</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_validate_mask_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>Restrict link modes based on caps</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*supported</span></code></dt><dd><p>ethtool bitmask for supported link modes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*state</span></code></dt><dd><p>pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mac_capabilities</span></code></dt><dd><p>bitmask of MAC capabilities</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate the supported link modes based on <strong>mac_capabilities</strong>, and restrict
<strong>supported</strong> and <strong>state</strong> based on that. Use this function if your capabiliies
aren’t constant, such as if they vary depending on the interface.</p>
</div>
<dl class="function">
<dt id="c.phylink_generic_validate">
void <code class="sig-name descname">phylink_generic_validate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a><em> *config</em>, unsigned long<em> *supported</em>, struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_generic_validate" title="Permalink to this definition">¶</a></dt>
<dd><p>generic <a class="reference internal" href="#c.validate" title="validate"><code class="xref c c-func docutils literal notranslate"><span class="pre">validate()</span></code></a> callback implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*config</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*supported</span></code></dt><dd><p>ethtool bitmask for supported link modes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generic implementation of the <a class="reference internal" href="#c.validate" title="validate"><code class="xref c c-func docutils literal notranslate"><span class="pre">validate()</span></code></a> callback that MAC drivers can
use when they pass the range of supported interfaces and MAC capabilities.</p>
</div>
<dl class="function">
<dt id="c.phylink_create">
struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a> * <code class="sig-name descname">phylink_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_config" title="phylink_config">phylink_config</a><em> *config</em>, struct fwnode_handle<em> *fwnode</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> iface</em>, const struct <a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops">phylink_mac_ops</a><em> *mac_ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a phylink instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span> <span class="pre">*config</span></code></dt><dd><p>a pointer to the target <a class="reference internal" href="#c.phylink_config" title="phylink_config"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_config</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span></code> describing the network
interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">iface</span></code></dt><dd><p>the desired link mode defined by <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">phy_interface_t</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">phylink_mac_ops</span> <span class="pre">*mac_ops</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_mac_ops</span></code></a> for the MAC.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new phylink instance, and parse the link parameters found in <strong>np</strong>.
This will parse in-band modes, fixed-link or SFP configuration.</p>
<p>Returns a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a>, or an error-pointer value. Users
must use IS_ERR() to check for errors from this function.</p>
<p><strong>Note</strong></p>
<p>the rtnl lock must not be held when calling this function.</p>
</div>
<dl class="function">
<dt id="c.phylink_destroy">
void <code class="sig-name descname">phylink_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup and destroy the phylink instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroy a phylink instance. Any PHY that has been attached must have been
cleaned up via <a class="reference internal" href="#c.phylink_disconnect_phy" title="phylink_disconnect_phy"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_disconnect_phy()</span></code></a> prior to calling this function.</p>
<p><strong>Note</strong></p>
<p>the rtnl lock must not be held when calling this function.</p>
</div>
<dl class="function">
<dt id="c.phylink_connect_phy">
int <code class="sig-name descname">phylink_connect_phy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, struct <a class="reference internal" href="#c.phy_device" title="phy_device">phy_device</a><em> *phy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_connect_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>connect a PHY to the phylink instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*phy</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phy_device" title="phy_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Connect <strong>phy</strong> to the phylink instance specified by <strong>pl</strong> by calling
<a class="reference internal" href="#c.phy_attach_direct" title="phy_attach_direct"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_attach_direct()</span></code></a>. Configure the <strong>phy</strong> according to the MAC driver’s
capabilities, start the PHYLIB state machine and enable any interrupts
that the PHY supports.</p>
<p>This updates the phylink’s ethtool supported and advertising link mode
masks.</p>
<p>Returns 0 on success or a negative errno.</p>
</div>
<dl class="function">
<dt id="c.phylink_of_phy_connect">
int <code class="sig-name descname">phylink_of_phy_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, struct device_node<em> *dn</em>, u32<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_of_phy_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect the PHY specified in the DT mode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*dn</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_node</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>PHY-specific flags to communicate to the PHY device driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Connect the phy specified in the device node <strong>dn</strong> to the phylink instance
specified by <strong>pl</strong>. Actions specified in <a class="reference internal" href="#c.phylink_connect_phy" title="phylink_connect_phy"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_connect_phy()</span></code></a> will be
performed.</p>
<p>Returns 0 on success or a negative errno.</p>
</div>
<dl class="function">
<dt id="c.phylink_fwnode_phy_connect">
int <code class="sig-name descname">phylink_fwnode_phy_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, struct fwnode_handle<em> *fwnode</em>, u32<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_fwnode_phy_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect the PHY specified in the fwnode.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>PHY-specific flags to communicate to the PHY device driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Connect the phy specified <strong>fwnode</strong> to the phylink instance specified
by <strong>pl</strong>.</p>
<p>Returns 0 on success or a negative errno.</p>
</div>
<dl class="function">
<dt id="c.phylink_disconnect_phy">
void <code class="sig-name descname">phylink_disconnect_phy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_disconnect_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect any PHY attached to the phylink instance.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disconnect any current PHY from the phylink instance described by <strong>pl</strong>.</p>
</div>
<dl class="function">
<dt id="c.phylink_mac_change">
void <code class="sig-name descname">phylink_mac_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, bool<em> up</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mac_change" title="Permalink to this definition">¶</a></dt>
<dd><p>notify phylink of a change in MAC state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">up</span></code></dt><dd><p>indicates whether the link is currently up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The MAC driver should call this driver when the state of its link
changes (eg, link failure, new negotiation results, etc.)</p>
</div>
<dl class="function">
<dt id="c.phylink_start">
void <code class="sig-name descname">phylink_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start a phylink instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start the phylink instance specified by <strong>pl</strong>, configuring the MAC for the
desired link mode(s) and negotiation style. This should be called from the
network device driver’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device_ops</span></code> ndo_open() method.</p>
</div>
<dl class="function">
<dt id="c.phylink_stop">
void <code class="sig-name descname">phylink_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stop a phylink instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop the phylink instance specified by <strong>pl</strong>. This should be called from the
network device driver’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device_ops</span></code> ndo_stop() method.  The
network device’s carrier state should not be changed prior to calling this
function.</p>
<p>This will synchronously bring down the link if the link is not already
down (in other words, it will trigger a <a class="reference internal" href="#c.mac_link_down" title="mac_link_down"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_down()</span></code></a> method call.)</p>
</div>
<dl class="function">
<dt id="c.phylink_suspend">
void <code class="sig-name descname">phylink_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, bool<em> mac_wol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>handle a network device suspend event</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">mac_wol</span></code></dt><dd><p>true if the MAC needs to receive packets for Wake-on-Lan</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle a network device suspend event. There are several cases:</p>
<ul class="simple">
<li><p>If Wake-on-Lan is not active, we can bring down the link between
the MAC and PHY by calling <a class="reference internal" href="#c.phylink_stop" title="phylink_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_stop()</span></code></a>.</p></li>
<li><p>If Wake-on-Lan is active, and being handled only by the PHY, we
can also bring down the link between the MAC and PHY.</p></li>
<li><p>If Wake-on-Lan is active, but being handled by the MAC, the MAC
still needs to receive packets, so we can not bring the link down.</p></li>
</ul>
</div>
<dl class="function">
<dt id="c.phylink_resume">
void <code class="sig-name descname">phylink_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>handle a network device resume event</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo the effects of <a class="reference internal" href="#c.phylink_suspend" title="phylink_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_suspend()</span></code></a>, returning the link to an
operational state.</p>
</div>
<dl class="function">
<dt id="c.phylink_ethtool_get_wol">
void <code class="sig-name descname">phylink_ethtool_get_wol</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, struct ethtool_wolinfo<em> *wol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_get_wol" title="Permalink to this definition">¶</a></dt>
<dd><p>get the wake on lan parameters for the PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_wolinfo</span> <span class="pre">*wol</span></code></dt><dd><p>a pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_wolinfo</span></code> to hold the read parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the wake on lan parameters from the PHY attached to the phylink
instance specified by <strong>pl</strong>. If no PHY is currently attached, report no
support for wake on lan.</p>
</div>
<dl class="function">
<dt id="c.phylink_ethtool_set_wol">
int <code class="sig-name descname">phylink_ethtool_set_wol</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, struct ethtool_wolinfo<em> *wol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_set_wol" title="Permalink to this definition">¶</a></dt>
<dd><p>set wake on lan parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_wolinfo</span> <span class="pre">*wol</span></code></dt><dd><p>a pointer to <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_wolinfo</span></code> for the desired parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the wake on lan parameters for the PHY attached to the phylink
instance specified by <strong>pl</strong>. If no PHY is attached, returns <code class="docutils literal notranslate"><span class="pre">EOPNOTSUPP</span></code>
error.</p>
<p>Returns zero on success or negative errno code.</p>
</div>
<dl class="function">
<dt id="c.phylink_ethtool_ksettings_get">
int <code class="sig-name descname">phylink_ethtool_ksettings_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, struct ethtool_link_ksettings<em> *kset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_ksettings_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current link settings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_link_ksettings</span> <span class="pre">*kset</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_link_ksettings</span></code> to hold link settings</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the current link settings for the phylink instance specified by <strong>pl</strong>.
This will be the link settings read from the MAC, PHY or fixed link
settings depending on the current negotiation mode.</p>
</div>
<dl class="function">
<dt id="c.phylink_ethtool_ksettings_set">
int <code class="sig-name descname">phylink_ethtool_ksettings_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, const struct ethtool_link_ksettings<em> *kset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_ksettings_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set the link settings</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ethtool_link_ksettings</span> <span class="pre">*kset</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_link_ksettings</span></code> for the desired modes</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phylink_ethtool_nway_reset">
int <code class="sig-name descname">phylink_ethtool_nway_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_nway_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>restart negotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Restart negotiation for the phylink instance specified by <strong>pl</strong>. This will
cause any attached phy to restart negotiation with the link partner, and
if the MAC is in a BaseX mode, the MAC will also be requested to restart
negotiation.</p>
<p>Returns zero on success, or negative error code.</p>
</div>
<dl class="function">
<dt id="c.phylink_ethtool_get_pauseparam">
void <code class="sig-name descname">phylink_ethtool_get_pauseparam</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, struct ethtool_pauseparam<em> *pause</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_get_pauseparam" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current pause parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_pauseparam</span> <span class="pre">*pause</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_pauseparam</span></code></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phylink_ethtool_set_pauseparam">
int <code class="sig-name descname">phylink_ethtool_set_pauseparam</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, struct ethtool_pauseparam<em> *pause</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_set_pauseparam" title="Permalink to this definition">¶</a></dt>
<dd><p>set the current pause parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_pauseparam</span> <span class="pre">*pause</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_pauseparam</span></code></p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phylink_get_eee_err">
int <code class="sig-name descname">phylink_get_eee_err</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_get_eee_err" title="Permalink to this definition">¶</a></dt>
<dd><p>read the energy efficient ethernet error counter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the Energy Efficient Ethernet error counter from the PHY associated
with the phylink instance specified by <strong>pl</strong>.</p>
<p>Returns positive error counter value, or negative error code.</p>
</div>
<dl class="function">
<dt id="c.phylink_init_eee">
int <code class="sig-name descname">phylink_init_eee</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, bool<em> clk_stop_enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_init_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>init and check the EEE features</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">clk_stop_enable</span></code></dt><dd><p>allow PHY to stop receive clock</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called either with RTNL held or within <a class="reference internal" href="#c.mac_link_up" title="mac_link_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_link_up()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.phylink_ethtool_get_eee">
int <code class="sig-name descname">phylink_ethtool_get_eee</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, struct ethtool_eee<em> *eee</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_get_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>read the energy efficient ethernet parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span> <span class="pre">*eee</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span></code> for the read parameters</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phylink_ethtool_set_eee">
int <code class="sig-name descname">phylink_ethtool_set_eee</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, struct ethtool_eee<em> *eee</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_ethtool_set_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>set the energy efficient ethernet parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span> <span class="pre">*eee</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eee</span></code> for the desired parameters</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.phylink_mii_ioctl">
int <code class="sig-name descname">phylink_mii_ioctl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, struct ifreq<em> *ifr</em>, int<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mii_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>generic mii ioctl interface</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span> <span class="pre">*ifr</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ifreq</span></code> for socket ioctls</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl cmd to execute</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform the specified MII ioctl on the PHY attached to the phylink instance
specified by <strong>pl</strong>. If no PHY is attached, emulate the presence of the PHY.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SIOCGMIIPHY</span></code>:</dt><dd><p>read register from the current PHY.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SIOCGMIIREG</span></code>:</dt><dd><p>read register from the specified PHY.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SIOCSMIIREG</span></code>:</dt><dd><p>set a register on the specified PHY.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero on success or negative error code.</p>
</div>
<dl class="function">
<dt id="c.phylink_speed_down">
int <code class="sig-name descname">phylink_speed_down</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em>, bool<em> sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_speed_down" title="Permalink to this definition">¶</a></dt>
<dd><p>set the non-SFP PHY to lowest speed supported by both link partners</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">sync</span></code></dt><dd><p>perform action synchronously</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If we have a PHY that is not part of a SFP module, then set the speed
as described in the <a class="reference internal" href="#c.phy_speed_down" title="phy_speed_down"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_speed_down()</span></code></a> function. Please see this function
for a description of the <strong>sync</strong> parameter.</p>
<p>Returns zero if there is no PHY, otherwise as per <a class="reference internal" href="#c.phy_speed_down" title="phy_speed_down"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_speed_down()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.phylink_speed_up">
int <code class="sig-name descname">phylink_speed_up</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink" title="phylink">phylink</a><em> *pl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_speed_up" title="Permalink to this definition">¶</a></dt>
<dd><p>restore the advertised speeds prior to the call to <a class="reference internal" href="#c.phylink_speed_down" title="phylink_speed_down"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_speed_down()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span> <span class="pre">*pl</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink" title="phylink"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink</span></code></a> returned from <a class="reference internal" href="#c.phylink_create" title="phylink_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">phylink_create()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If we have a PHY that is not part of a SFP module, then restore the
PHY speeds as per <a class="reference internal" href="#c.phy_speed_up" title="phy_speed_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_speed_up()</span></code></a>.</p>
<p>Returns zero if there is no PHY, otherwise as per <a class="reference internal" href="#c.phy_speed_up" title="phy_speed_up"><code class="xref c c-func docutils literal notranslate"><span class="pre">phy_speed_up()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.phylink_decode_usxgmii_word">
void <code class="sig-name descname">phylink_decode_usxgmii_word</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a><em> *state</em>, uint16_t<em> lpa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_decode_usxgmii_word" title="Permalink to this definition">¶</a></dt>
<dd><p>decode the USXGMII word from a MAC PCS</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint16_t</span> <span class="pre">lpa</span></code></dt><dd><p>a 16 bit value which stores the USXGMII auto-negotiation word</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for MAC PCS supporting the USXGMII protocol and the auto-negotiation
code word.  Decode the USXGMII code word and populate the corresponding fields
(speed, duplex) into the phylink_link_state structure.</p>
</div>
<dl class="function">
<dt id="c.phylink_mii_c22_pcs_decode_state">
void <code class="sig-name descname">phylink_mii_c22_pcs_decode_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a><em> *state</em>, u16<em> bmsr</em>, u16<em> lpa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mii_c22_pcs_decode_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode MAC PCS state from MII registers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">bmsr</span></code></dt><dd><p>The value of the <code class="docutils literal notranslate"><span class="pre">MII_BMSR</span></code> register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">lpa</span></code></dt><dd><p>The value of the <code class="docutils literal notranslate"><span class="pre">MII_LPA</span></code> register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for MAC PCS supporting the 802.3 clause 22 register set for
clause 37 negotiation and/or SGMII control.</p>
<p>Parse the Clause 37 or Cisco SGMII link partner negotiation word into
the phylink <strong>state</strong> structure. This is suitable to be used for implementing
the <a class="reference internal" href="#c.mac_pcs_get_state" title="mac_pcs_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_pcs_get_state()</span></code></a> member of the <a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_mac_ops</span></code></a> structure if
accessing <strong>bmsr</strong> and <strong>lpa</strong> cannot be done with MDIO directly.</p>
</div>
<dl class="function">
<dt id="c.phylink_mii_c22_pcs_get_state">
void <code class="sig-name descname">phylink_mii_c22_pcs_get_state</code><span class="sig-paren">(</span>struct mdio_device<em> *pcs</em>, struct <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state">phylink_link_state</a><em> *state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mii_c22_pcs_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>read the MAC PCS state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span> <span class="pre">*pcs</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span> <span class="pre">*state</span></code></dt><dd><p>a pointer to a <a class="reference internal" href="#c.phylink_link_state" title="phylink_link_state"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_link_state</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for MAC PCS supporting the 802.3 clause 22 register set for
clause 37 negotiation and/or SGMII control.</p>
<p>Read the MAC PCS state from the MII device configured in <strong>config</strong> and
parse the Clause 37 or Cisco SGMII link partner negotiation word into
the phylink <strong>state</strong> structure. This is suitable to be directly plugged
into the <a class="reference internal" href="#c.mac_pcs_get_state" title="mac_pcs_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_pcs_get_state()</span></code></a> member of the <a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_mac_ops</span></code></a>
structure.</p>
</div>
<dl class="function">
<dt id="c.phylink_mii_c22_pcs_encode_advertisement">
int <code class="sig-name descname">phylink_mii_c22_pcs_encode_advertisement</code><span class="sig-paren">(</span><a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em>, const unsigned long<em> *advertising</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mii_c22_pcs_encode_advertisement" title="Permalink to this definition">¶</a></dt>
<dd><p>configure the clause 37 PCS advertisement</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>the PHY interface mode being configured</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*advertising</span></code></dt><dd><p>the ethtool advertisement mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for MAC PCS supporting the 802.3 clause 22 register set for
clause 37 negotiation and/or SGMII control.</p>
<p>Encode the clause 37 PCS advertisement as specified by <strong>interface</strong> and
<strong>advertising</strong>.</p>
<p><strong>Return</strong></p>
<p>The new value for <strong>adv</strong>, or <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> if it should not be changed.</p>
</div>
<dl class="function">
<dt id="c.phylink_mii_c22_pcs_config">
int <code class="sig-name descname">phylink_mii_c22_pcs_config</code><span class="sig-paren">(</span>struct mdio_device<em> *pcs</em>, unsigned int<em> mode</em>, <a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a><em> interface</em>, const unsigned long<em> *advertising</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mii_c22_pcs_config" title="Permalink to this definition">¶</a></dt>
<dd><p>configure clause 22 PCS</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span> <span class="pre">*pcs</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt><dd><p>link autonegotiation mode</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt><dd><p>the PHY interface mode being configured</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*advertising</span></code></dt><dd><p>the ethtool advertisement mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure a Clause 22 PCS PHY with the appropriate negotiation
parameters for the <strong>mode</strong>, <strong>interface</strong> and <strong>advertising</strong> parameters.
Returns negative error number on failure, zero if the advertisement
has not changed, or positive if there is a change.</p>
</div>
<dl class="function">
<dt id="c.phylink_mii_c22_pcs_an_restart">
void <code class="sig-name descname">phylink_mii_c22_pcs_an_restart</code><span class="sig-paren">(</span>struct mdio_device<em> *pcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phylink_mii_c22_pcs_an_restart" title="Permalink to this definition">¶</a></dt>
<dd><p>restart 802.3z autonegotiation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span> <span class="pre">*pcs</span></code></dt><dd><p>a pointer to a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">mdio_device</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for MAC PCS supporting the 802.3 clause 22 register set for
clause 37 negotiation.</p>
<p>Restart the clause 37 negotiation with the link partner. This is
suitable to be directly plugged into the <a class="reference internal" href="#c.mac_pcs_get_state" title="mac_pcs_get_state"><code class="xref c c-func docutils literal notranslate"><span class="pre">mac_pcs_get_state()</span></code></a> member
of the <a class="reference internal" href="#c.phylink_mac_ops" title="phylink_mac_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phylink_mac_ops</span></code></a> structure.</p>
</div>
</section>
<section id="sfp-support">
<h3>SFP support<a class="headerlink" href="#sfp-support" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.sfp_bus">
struct <code class="sig-name descname">sfp_bus</code><a class="headerlink" href="#c.sfp_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>internal representation of a sfp bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sfp_bus {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
</div>
<dl class="type">
<dt id="c.sfp_eeprom_id">
struct <code class="sig-name descname">sfp_eeprom_id</code><a class="headerlink" href="#c.sfp_eeprom_id" title="Permalink to this definition">¶</a></dt>
<dd><p>raw SFP module identification information</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sfp_eeprom_id {
    struct sfp_eeprom_base base;
    struct sfp_eeprom_ext ext;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>base SFP module identification structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext</span></code></dt><dd><p>extended SFP module identification structure</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>See the SFF-8472 specification and related documents for the definition
of these structure members. This can be obtained from
<a class="reference external" href="https://www.snia.org/technology-communities/sff/specifications">https://www.snia.org/technology-communities/sff/specifications</a></p>
<dl class="type">
<dt id="c.sfp_upstream_ops">
struct <code class="sig-name descname">sfp_upstream_ops</code><a class="headerlink" href="#c.sfp_upstream_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>upstream operations structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sfp_upstream_ops {
    void (*attach)(void *priv, struct sfp_bus *bus);
    void (*detach)(void *priv, struct sfp_bus *bus);
    int (*module_insert)(void *priv, const struct sfp_eeprom_id *id);
    void (*module_remove)(void *priv);
    int (*module_start)(void *priv);
    void (*module_stop)(void *priv);
    void (*link_down)(void *priv);
    void (*link_up)(void *priv);
    int (*connect_phy)(void *priv, struct phy_device *);
    void (*disconnect_phy)(void *priv);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">attach</span></code></dt><dd><p>called when the sfp socket driver is bound to the upstream
(mandatory).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">detach</span></code></dt><dd><p>called when the sfp socket driver is unbound from the upstream
(mandatory).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module_insert</span></code></dt><dd><p>called after a module has been detected to determine
whether the module is supported for the upstream device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module_remove</span></code></dt><dd><p>called after the module has been removed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module_start</span></code></dt><dd><p>called after the PHY probe step</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">module_stop</span></code></dt><dd><p>called before the PHY is removed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_down</span></code></dt><dd><p>called when the link is non-operational for whatever
reason.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">link_up</span></code></dt><dd><p>called when the link is operational.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">connect_phy</span></code></dt><dd><p>called when an I2C accessible PHY has been detected
on the module.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">disconnect_phy</span></code></dt><dd><p>called when a module with an I2C accessible PHY has
been removed.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.sfp_parse_port">
int <code class="sig-name descname">sfp_parse_port</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em>, const struct <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id">sfp_eeprom_id</a><em> *id</em>, unsigned long<em> *support</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_parse_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the EEPROM base ID, setting the port type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span> <span class="pre">*id</span></code></dt><dd><p>a pointer to the module’s <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*support</span></code></dt><dd><p>optional pointer to an array of unsigned long for the
ethtool support mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the EEPROM identification given in <strong>id</strong>, and return one of
<code class="docutils literal notranslate"><span class="pre">PORT_TP</span></code>, <code class="docutils literal notranslate"><span class="pre">PORT_FIBRE</span></code> or <code class="docutils literal notranslate"><span class="pre">PORT_OTHER</span></code>. If <strong>support</strong> is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>,
also set the ethtool <code class="docutils literal notranslate"><span class="pre">ETHTOOL_LINK_MODE_xxx_BIT</span></code> corresponding with
the connector type.</p>
<p>If the port type is not known, returns <code class="docutils literal notranslate"><span class="pre">PORT_OTHER</span></code>.</p>
</div>
<dl class="function">
<dt id="c.sfp_may_have_phy">
bool <code class="sig-name descname">sfp_may_have_phy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em>, const struct <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id">sfp_eeprom_id</a><em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_may_have_phy" title="Permalink to this definition">¶</a></dt>
<dd><p>indicate whether the module may have a PHY</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span> <span class="pre">*id</span></code></dt><dd><p>a pointer to the module’s <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the EEPROM identification given in <strong>id</strong>, and return whether
this module may have a PHY.</p>
</div>
<dl class="function">
<dt id="c.sfp_parse_support">
void <code class="sig-name descname">sfp_parse_support</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em>, const struct <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id">sfp_eeprom_id</a><em> *id</em>, unsigned long<em> *support</em>, unsigned long<em> *interfaces</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_parse_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the eeprom id for supported link modes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span> <span class="pre">*id</span></code></dt><dd><p>a pointer to the module’s <a class="reference internal" href="#c.sfp_eeprom_id" title="sfp_eeprom_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_eeprom_id</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*support</span></code></dt><dd><p>pointer to an array of unsigned long for the ethtool support mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*interfaces</span></code></dt><dd><p>pointer to an array of unsigned long for phy interface modes
mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the EEPROM identification information and derive the supported
ethtool link modes for the module.</p>
</div>
<dl class="function">
<dt id="c.sfp_select_interface">
<a class="reference internal" href="#c.phy_interface_t" title="phy_interface_t">phy_interface_t</a> <code class="sig-name descname">sfp_select_interface</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em>, unsigned long<em> *link_modes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_select_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Select appropriate phy_interface_t mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*link_modes</span></code></dt><dd><p>ethtool link modes mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Derive the phy_interface_t mode for the SFP module from the link
modes mask.</p>
</div>
<dl class="function">
<dt id="c.sfp_bus_put">
void <code class="sig-name descname">sfp_bus_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_bus_put" title="Permalink to this definition">¶</a></dt>
<dd><p>put a reference on the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> found via <a class="reference internal" href="#c.sfp_bus_find_fwnode" title="sfp_bus_find_fwnode"><code class="xref c c-func docutils literal notranslate"><span class="pre">sfp_bus_find_fwnode()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Put a reference on the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> and free the underlying structure
if this was the last reference.</p>
</div>
<dl class="function">
<dt id="c.sfp_get_module_info">
int <code class="sig-name descname">sfp_get_module_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em>, struct ethtool_modinfo<em> *modinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_get_module_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the ethtool_modinfo for a SFP module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_modinfo</span> <span class="pre">*modinfo</span></code></dt><dd><p>a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_modinfo</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the type and eeprom_len parameters in <strong>modinfo</strong> for a module on
the sfp bus specified by <strong>bus</strong>.</p>
<p>Returns 0 on success or a negative errno number.</p>
</div>
<dl class="function">
<dt id="c.sfp_get_module_eeprom">
int <code class="sig-name descname">sfp_get_module_eeprom</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em>, struct ethtool_eeprom<em> *ee</em>, u8<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_get_module_eeprom" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the SFP module EEPROM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eeprom</span> <span class="pre">*ee</span></code></dt><dd><p>a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eeprom</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*data</span></code></dt><dd><p>buffer to contain the EEPROM data (must be at least <strong>ee-&gt;len</strong> bytes)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the EEPROM as specified by the supplied <strong>ee</strong>. See the documentation
for <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_eeprom</span></code> for the region to be read.</p>
<p>Returns 0 on success or a negative errno number.</p>
</div>
<dl class="function">
<dt id="c.sfp_get_module_eeprom_by_page">
int <code class="sig-name descname">sfp_get_module_eeprom_by_page</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em>, const struct ethtool_module_eeprom<em> *page</em>, struct netlink_ext_ack<em> *extack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_get_module_eeprom_by_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a page from the SFP module EEPROM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ethtool_module_eeprom</span> <span class="pre">*page</span></code></dt><dd><p>a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_module_eeprom</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">netlink_ext_ack</span> <span class="pre">*extack</span></code></dt><dd><p>extack for reporting problems</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read an EEPROM page as specified by the supplied <strong>page</strong>. See the
documentation for <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ethtool_module_eeprom</span></code> for the page to be read.</p>
<p>Returns 0 on success or a negative errno number. More error
information might be provided via extack</p>
</div>
<dl class="function">
<dt id="c.sfp_upstream_start">
void <code class="sig-name descname">sfp_upstream_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_upstream_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Inform the SFP that the network device is up</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the SFP socket that the network device is now up, so that the
module can be enabled by allowing TX_DISABLE to be deasserted. This
should be called from the network device driver’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device_ops</span></code>
ndo_open() method.</p>
</div>
<dl class="function">
<dt id="c.sfp_upstream_stop">
void <code class="sig-name descname">sfp_upstream_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_upstream_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Inform the SFP that the network device is down</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the SFP socket that the network device is now up, so that the
module can be disabled by asserting TX_DISABLE, disabling the laser
in optical modules. This should be called from the network device
driver’s <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device_ops</span></code> ndo_stop() method.</p>
</div>
<dl class="function">
<dt id="c.sfp_bus_find_fwnode">
struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a> * <code class="sig-name descname">sfp_bus_find_fwnode</code><span class="sig-paren">(</span>struct fwnode_handle<em> *fwnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_bus_find_fwnode" title="Permalink to this definition">¶</a></dt>
<dd><p>parse and locate the SFP bus from fwnode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*fwnode</span></code></dt><dd><p>firmware node for the parent device (MAC or PHY)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parse the parent device’s firmware node for a SFP bus, and locate
the sfp_bus structure, incrementing its reference count.  This must
be put via <a class="reference internal" href="#c.sfp_bus_put" title="sfp_bus_put"><code class="xref c c-func docutils literal notranslate"><span class="pre">sfp_bus_put()</span></code></a> when done.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>on success, a pointer to the sfp_bus structure,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no SFP is specified,</p></li>
<li><p>on failure, an error pointer value:</p></li>
<li><p>corresponding to the errors detailed for
fwnode_property_get_reference_args().</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if we failed to allocate the bus.</p></li>
<li><p>an error from the upstream’s connect_phy() method.</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sfp_bus_add_upstream">
int <code class="sig-name descname">sfp_bus_add_upstream</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em>, void<em> *upstream</em>, const struct <a class="reference internal" href="#c.sfp_upstream_ops" title="sfp_upstream_ops">sfp_upstream_ops</a><em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_bus_add_upstream" title="Permalink to this definition">¶</a></dt>
<dd><p>parse and register the neighbouring device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> found via <a class="reference internal" href="#c.sfp_bus_find_fwnode" title="sfp_bus_find_fwnode"><code class="xref c c-func docutils literal notranslate"><span class="pre">sfp_bus_find_fwnode()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*upstream</span></code></dt><dd><p>the upstream private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sfp_upstream_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the upstream’s <a class="reference internal" href="#c.sfp_upstream_ops" title="sfp_upstream_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_upstream_ops</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add upstream driver for the SFP bus, and if the bus is complete, register
the SFP bus using sfp_register_upstream().  This takes a reference on the
bus, so it is safe to put the bus after this call.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>on success, a pointer to the sfp_bus structure,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code> if no SFP is specified,</p></li>
<li><p>on failure, an error pointer value:</p></li>
<li><p>corresponding to the errors detailed for
fwnode_property_get_reference_args().</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ENOMEM</span></code> if we failed to allocate the bus.</p></li>
<li><p>an error from the upstream’s connect_phy() method.</p></li>
</ul>
</div></blockquote>
</div>
<dl class="function">
<dt id="c.sfp_bus_del_upstream">
void <code class="sig-name descname">sfp_bus_del_upstream</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sfp_bus" title="sfp_bus">sfp_bus</a><em> *bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sfp_bus_del_upstream" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a sfp bus</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span> <span class="pre">*bus</span></code></dt><dd><p>a pointer to the <a class="reference internal" href="#c.sfp_bus" title="sfp_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sfp_bus</span></code></a> structure for the sfp module</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Delete a previously registered upstream connection for the SFP
module. <strong>bus</strong> should have been added by <a class="reference internal" href="#c.sfp_bus_add_upstream" title="sfp_bus_add_upstream"><code class="xref c c-func docutils literal notranslate"><span class="pre">sfp_bus_add_upstream()</span></code></a>.</p>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Linux Networking and Network Devices APIs</a><ul>
<li><a class="reference internal" href="#linux-networking">Linux Networking</a><ul>
<li><a class="reference internal" href="#networking-base-types">Networking Base Types</a></li>
<li><a class="reference internal" href="#socket-buffer-functions">Socket Buffer Functions</a></li>
<li><a class="reference internal" href="#socket-filter">Socket Filter</a></li>
<li><a class="reference internal" href="#generic-network-statistics">Generic Network Statistics</a></li>
<li><a class="reference internal" href="#sun-rpc-subsystem">SUN RPC subsystem</a></li>
</ul>
</li>
<li><a class="reference internal" href="#network-device-support">Network device support</a><ul>
<li><a class="reference internal" href="#driver-support">Driver Support</a></li>
<li><a class="reference internal" href="#phy-support">PHY Support</a></li>
<li><a class="reference internal" href="#phylink">PHYLINK</a></li>
<li><a class="reference internal" href="#sfp-support">SFP support</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/networking/kapi.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/networking/kapi.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>