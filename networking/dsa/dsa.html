
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Architecture &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Broadcom RoboSwitch Ethernet switch driver" href="b53.html" />
    <link rel="prev" title="Distributed Switch Architecture" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="architecture">
<h1>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h1>
<p>This document describes the <strong>Distributed Switch Architecture (DSA)</strong> subsystem
design principles, limitations, interactions with other subsystems, and how to
develop drivers for this subsystem as well as a TODO for developers interested
in joining the effort.</p>
<section id="design-principles">
<h2>Design principles<a class="headerlink" href="#design-principles" title="Permalink to this headline">¶</a></h2>
<p>The Distributed Switch Architecture subsystem was primarily designed to
support Marvell Ethernet switches (MV88E6xxx, a.k.a. Link Street product
line) using Linux, but has since evolved to support other vendors as well.</p>
<p>The original philosophy behind this design was to be able to use unmodified
Linux tools such as bridge, iproute2, ifconfig to work transparently whether
they configured/queried a switch port network device or a regular network
device.</p>
<p>An Ethernet switch typically comprises multiple front-panel ports and one
or more CPU or management ports. The DSA subsystem currently relies on the
presence of a management port connected to an Ethernet controller capable of
receiving Ethernet frames from the switch. This is a very common setup for all
kinds of Ethernet switches found in Small Home and Office products: routers,
gateways, or even top-of-rack switches. This host Ethernet controller will
be later referred to as “master” and “cpu” in DSA terminology and code.</p>
<p>The D in DSA stands for Distributed, because the subsystem has been designed
with the ability to configure and manage cascaded switches on top of each other
using upstream and downstream Ethernet links between switches. These specific
ports are referred to as “dsa” ports in DSA terminology and code. A collection
of multiple switches connected to each other is called a “switch tree”.</p>
<p>For each front-panel port, DSA creates specialized network devices which are
used as controlling and data-flowing endpoints for use by the Linux networking
stack. These specialized network interfaces are referred to as “slave” network
interfaces in DSA terminology and code.</p>
<p>The ideal case for using DSA is when an Ethernet switch supports a “switch tag”
which is a hardware feature making the switch insert a specific tag for each
Ethernet frame it receives to/from specific ports to help the management
interface figure out:</p>
<ul class="simple">
<li><p>what port is this frame coming from</p></li>
<li><p>what was the reason why this frame got forwarded</p></li>
<li><p>how to send CPU originated traffic to specific ports</p></li>
</ul>
<p>The subsystem does support switches not capable of inserting/stripping tags, but
the features might be slightly limited in that case (traffic separation relies
on Port-based VLAN IDs).</p>
<p>Note that DSA does not currently create network interfaces for the “cpu” and
“dsa” ports because:</p>
<ul class="simple">
<li><p>the “cpu” port is the Ethernet switch facing side of the management
controller, and as such, would create a duplication of feature, since you
would get two interfaces for the same conduit: master netdev, and “cpu” netdev</p></li>
<li><p>the “dsa” port(s) are just conduits between two or more switches, and as such
cannot really be used as proper network interfaces either, only the
downstream, or the top-most upstream interface makes sense with that model</p></li>
</ul>
<section id="switch-tagging-protocols">
<h3>Switch tagging protocols<a class="headerlink" href="#switch-tagging-protocols" title="Permalink to this headline">¶</a></h3>
<p>DSA supports many vendor-specific tagging protocols, one software-defined
tagging protocol, and a tag-less mode as well (<code class="docutils literal notranslate"><span class="pre">DSA_TAG_PROTO_NONE</span></code>).</p>
<p>The exact format of the tag protocol is vendor specific, but in general, they
all contain something which:</p>
<ul class="simple">
<li><p>identifies which port the Ethernet frame came from/should be sent to</p></li>
<li><p>provides a reason why this frame was forwarded to the management interface</p></li>
</ul>
<p>All tagging protocols are in <code class="docutils literal notranslate"><span class="pre">net/dsa/tag_*.c</span></code> files and implement the
methods of the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dsa_device_ops</span></code> structure, which are detailed below.</p>
<p>Tagging protocols generally fall in one of three categories:</p>
<ol class="arabic simple">
<li><p>The switch-specific frame header is located before the Ethernet header,
shifting to the right (from the perspective of the DSA master’s frame
parser) the MAC DA, MAC SA, EtherType and the entire L2 payload.</p></li>
<li><p>The switch-specific frame header is located before the EtherType, keeping
the MAC DA and MAC SA in place from the DSA master’s perspective, but
shifting the ‘real’ EtherType and L2 payload to the right.</p></li>
<li><p>The switch-specific frame header is located at the tail of the packet,
keeping all frame headers in place and not altering the view of the packet
that the DSA master’s frame parser has.</p></li>
</ol>
<p>A tagging protocol may tag all packets with switch tags of the same length, or
the tag length might vary (for example packets with PTP timestamps might
require an extended switch tag, or there might be one tag length on TX and a
different one on RX). Either way, the tagging protocol driver must populate the
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dsa_device_ops::needed_headroom</span></code> and/or <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dsa_device_ops::needed_tailroom</span></code>
with the length in octets of the longest switch frame header/trailer. The DSA
framework will automatically adjust the MTU of the master interface to
accommodate for this extra size in order for DSA user ports to support the
standard MTU (L2 payload length) of 1500 octets. The <code class="docutils literal notranslate"><span class="pre">needed_headroom</span></code> and
<code class="docutils literal notranslate"><span class="pre">needed_tailroom</span></code> properties are also used to request from the network stack,
on a best-effort basis, the allocation of packets with enough extra space such
that the act of pushing the switch tag on transmission of a packet does not
cause it to reallocate due to lack of memory.</p>
<p>Even though applications are not expected to parse DSA-specific frame headers,
the format on the wire of the tagging protocol represents an Application Binary
Interface exposed by the kernel towards user space, for decoders such as
<code class="docutils literal notranslate"><span class="pre">libpcap</span></code>. The tagging protocol driver must populate the <code class="docutils literal notranslate"><span class="pre">proto</span></code> member of
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dsa_device_ops</span></code> with a value that uniquely describes the
characteristics of the interaction required between the switch hardware and the
data path driver: the offset of each bit field within the frame header and any
stateful processing required to deal with the frames (as may be required for
PTP timestamping).</p>
<p>From the perspective of the network stack, all switches within the same DSA
switch tree use the same tagging protocol. In case of a packet transiting a
fabric with more than one switch, the switch-specific frame header is inserted
by the first switch in the fabric that the packet was received on. This header
typically contains information regarding its type (whether it is a control
frame that must be trapped to the CPU, or a data frame to be forwarded).
Control frames should be decapsulated only by the software data path, whereas
data frames might also be autonomously forwarded towards other user ports of
other switches from the same fabric, and in this case, the outermost switch
ports must decapsulate the packet.</p>
<p>Note that in certain cases, it might be the case that the tagging format used
by a leaf switch (not connected directly to the CPU) is not the same as what
the network stack sees. This can be seen with Marvell switch trees, where the
CPU port can be configured to use either the DSA or the Ethertype DSA (EDSA)
format, but the DSA links are configured to use the shorter (without Ethertype)
DSA frame header, in order to reduce the autonomous packet forwarding overhead.
It still remains the case that, if the DSA switch tree is configured for the
EDSA tagging protocol, the operating system sees EDSA-tagged packets from the
leaf switches that tagged them with the shorter DSA header. This can be done
because the Marvell switch connected directly to the CPU is configured to
perform tag translation between DSA and EDSA (which is simply the operation of
adding or removing the <code class="docutils literal notranslate"><span class="pre">ETH_P_EDSA</span></code> EtherType and some padding octets).</p>
<p>It is possible to construct cascaded setups of DSA switches even if their
tagging protocols are not compatible with one another. In this case, there are
no DSA links in this fabric, and each switch constitutes a disjoint DSA switch
tree. The DSA links are viewed as simply a pair of a DSA master (the out-facing
port of the upstream DSA switch) and a CPU port (the in-facing port of the
downstream DSA switch).</p>
<p>The tagging protocol of the attached DSA switch tree can be viewed through the
<code class="docutils literal notranslate"><span class="pre">dsa/tagging</span></code> sysfs attribute of the DSA master:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cat /sys/class/net/eth0/dsa/tagging
</pre></div>
</div>
<p>If the hardware and driver are capable, the tagging protocol of the DSA switch
tree can be changed at runtime. This is done by writing the new tagging
protocol name to the same sysfs device attribute as above (the DSA master and
all attached switch ports must be down while doing this).</p>
<p>It is desirable that all tagging protocols are testable with the <code class="docutils literal notranslate"><span class="pre">dsa_loop</span></code>
mockup driver, which can be attached to any network interface. The goal is that
any network interface should be capable of transmitting the same packet in the
same way, and the tagger should decode the same received packet in the same way
regardless of the driver used for the switch control path, and the driver used
for the DSA master.</p>
<p>The transmission of a packet goes through the tagger’s <code class="docutils literal notranslate"><span class="pre">xmit</span></code> function.
The passed <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code> has <code class="docutils literal notranslate"><span class="pre">skb-&gt;data</span></code> pointing at
<code class="docutils literal notranslate"><span class="pre">skb_mac_header(skb)</span></code>, i.e. at the destination MAC address, and the passed
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*dev</span></code> represents the virtual DSA user network interface
whose hardware counterpart the packet must be steered to (i.e. <code class="docutils literal notranslate"><span class="pre">swp0</span></code>).
The job of this method is to prepare the skb in a way that the switch will
understand what egress port the packet is for (and not deliver it towards other
ports). Typically this is fulfilled by pushing a frame header. Checking for
insufficient size in the skb headroom or tailroom is unnecessary provided that
the <code class="docutils literal notranslate"><span class="pre">needed_headroom</span></code> and <code class="docutils literal notranslate"><span class="pre">needed_tailroom</span></code> properties were filled out
properly, because DSA ensures there is enough space before calling this method.</p>
<p>The reception of a packet goes through the tagger’s <code class="docutils literal notranslate"><span class="pre">rcv</span></code> function. The
passed <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code> has <code class="docutils literal notranslate"><span class="pre">skb-&gt;data</span></code> pointing at
<code class="docutils literal notranslate"><span class="pre">skb_mac_header(skb)</span> <span class="pre">+</span> <span class="pre">ETH_ALEN</span></code> octets, i.e. to where the first octet after
the EtherType would have been, were this frame not tagged. The role of this
method is to consume the frame header, adjust <code class="docutils literal notranslate"><span class="pre">skb-&gt;data</span></code> to really point at
the first octet after the EtherType, and to change <code class="docutils literal notranslate"><span class="pre">skb-&gt;dev</span></code> to point to the
virtual DSA user network interface corresponding to the physical front-facing
switch port that the packet was received on.</p>
<p>Since tagging protocols in category 1 and 2 break software (and most often also
hardware) packet dissection on the DSA master, features such as RPS (Receive
Packet Steering) on the DSA master would be broken. The DSA framework deals
with this by hooking into the flow dissector and shifting the offset at which
the IP header is to be found in the tagged frame as seen by the DSA master.
This behavior is automatic based on the <code class="docutils literal notranslate"><span class="pre">overhead</span></code> value of the tagging
protocol. If not all packets are of equal size, the tagger can implement the
<code class="docutils literal notranslate"><span class="pre">flow_dissect</span></code> method of the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dsa_device_ops</span></code> and override this
default behavior by specifying the correct offset incurred by each individual
RX packet. Tail taggers do not cause issues to the flow dissector.</p>
<p>Checksum offload should work with category 1 and 2 taggers when the DSA master
driver declares NETIF_F_HW_CSUM in vlan_features and looks at csum_start and
csum_offset. For those cases, DSA will shift the checksum start and offset by
the tag size. If the DSA master driver still uses the legacy NETIF_F_IP_CSUM
or NETIF_F_IPV6_CSUM in vlan_features, the offload might only work if the
offload hardware already expects that specific tag (perhaps due to matching
vendors). DSA slaves inherit those flags from the master port, and it is up to
the driver to correctly fall back to software checksum when the IP header is not
where the hardware expects. If that check is ineffective, the packets might go
to the network without a proper checksum (the checksum field will have the
pseudo IP header sum). For category 3, when the offload hardware does not
already expect the switch tag in use, the checksum must be calculated before any
tag is inserted (i.e. inside the tagger). Otherwise, the DSA master would
include the tail tag in the (software or hardware) checksum calculation. Then,
when the tag gets stripped by the switch during transmission, it will leave an
incorrect IP checksum in place.</p>
<p>Due to various reasons (most common being category 1 taggers being associated
with DSA-unaware masters, mangling what the master perceives as MAC DA), the
tagging protocol may require the DSA master to operate in promiscuous mode, to
receive all frames regardless of the value of the MAC DA. This can be done by
setting the <code class="docutils literal notranslate"><span class="pre">promisc_on_master</span></code> property of the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dsa_device_ops</span></code>.
Note that this assumes a DSA-unaware master driver, which is the norm.</p>
</section>
<section id="master-network-devices">
<h3>Master network devices<a class="headerlink" href="#master-network-devices" title="Permalink to this headline">¶</a></h3>
<p>Master network devices are regular, unmodified Linux network device drivers for
the CPU/management Ethernet interface. Such a driver might occasionally need to
know whether DSA is enabled (e.g.: to enable/disable specific offload features),
but the DSA subsystem has been proven to work with industry standard drivers:
<code class="docutils literal notranslate"><span class="pre">e1000e,</span></code> <code class="docutils literal notranslate"><span class="pre">mv643xx_eth</span></code> etc. without having to introduce modifications to these
drivers. Such network devices are also often referred to as conduit network
devices since they act as a pipe between the host processor and the hardware
Ethernet switch.</p>
</section>
<section id="networking-stack-hooks">
<h3>Networking stack hooks<a class="headerlink" href="#networking-stack-hooks" title="Permalink to this headline">¶</a></h3>
<p>When a master netdev is used with DSA, a small hook is placed in the
networking stack is in order to have the DSA subsystem process the Ethernet
switch specific tagging protocol. DSA accomplishes this by registering a
specific (and fake) Ethernet type (later becoming <code class="docutils literal notranslate"><span class="pre">skb-&gt;protocol</span></code>) with the
networking stack, this is also known as a <code class="docutils literal notranslate"><span class="pre">ptype</span></code> or <code class="docutils literal notranslate"><span class="pre">packet_type</span></code>. A typical
Ethernet Frame receive sequence looks like this:</p>
<p>Master network device (e.g.: e1000e):</p>
<ol class="arabic">
<li><p>Receive interrupt fires:</p>
<blockquote>
<div><ul class="simple">
<li><p>receive function is invoked</p></li>
<li><p>basic packet processing is done: getting length, status etc.</p></li>
<li><p>packet is prepared to be processed by the Ethernet layer by calling
<code class="docutils literal notranslate"><span class="pre">eth_type_trans</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p>net/ethernet/eth.c:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eth_type_trans(skb, dev)
        if (dev-&gt;dsa_ptr != NULL)
                -&gt; skb-&gt;protocol = ETH_P_XDSA
</pre></div>
</div>
</li>
<li><p>drivers/net/ethernet/*:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>netif_receive_skb(skb)
        -&gt; iterate over registered packet_type
                -&gt; invoke handler for ETH_P_XDSA, calls dsa_switch_rcv()
</pre></div>
</div>
</li>
<li><p>net/dsa/dsa.c:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-&gt; dsa_switch_rcv()
        -&gt; invoke switch tag specific protocol handler in &#39;net/dsa/tag_*.c&#39;
</pre></div>
</div>
</li>
<li><p>net/dsa/tag_*.c:</p>
<blockquote>
<div><ul class="simple">
<li><p>inspect and strip switch tag protocol to determine originating port</p></li>
<li><p>locate per-port network device</p></li>
<li><p>invoke <code class="docutils literal notranslate"><span class="pre">eth_type_trans()</span></code> with the DSA slave network device</p></li>
<li><p>invoked <code class="docutils literal notranslate"><span class="pre">netif_receive_skb()</span></code></p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>Past this point, the DSA slave network devices get delivered regular Ethernet
frames that can be processed by the networking stack.</p>
</section>
<section id="slave-network-devices">
<h3>Slave network devices<a class="headerlink" href="#slave-network-devices" title="Permalink to this headline">¶</a></h3>
<p>Slave network devices created by DSA are stacked on top of their master network
device, each of these network interfaces will be responsible for being a
controlling and data-flowing end-point for each front-panel port of the switch.
These interfaces are specialized in order to:</p>
<ul class="simple">
<li><p>insert/remove the switch tag protocol (if it exists) when sending traffic
to/from specific switch ports</p></li>
<li><p>query the switch for ethtool operations: statistics, link state,
Wake-on-LAN, register dumps…</p></li>
<li><p>manage external/internal PHY: link, auto-negotiation, etc.</p></li>
</ul>
<p>These slave network devices have custom net_device_ops and ethtool_ops function
pointers which allow DSA to introduce a level of layering between the networking
stack/ethtool and the switch driver implementation.</p>
<p>Upon frame transmission from these slave network devices, DSA will look up which
switch tagging protocol is currently registered with these network devices and
invoke a specific transmit routine which takes care of adding the relevant
switch tag in the Ethernet frames.</p>
<p>These frames are then queued for transmission using the master network device
<code class="docutils literal notranslate"><span class="pre">ndo_start_xmit()</span></code> function. Since they contain the appropriate switch tag, the
Ethernet switch will be able to process these incoming frames from the
management interface and deliver them to the physical switch port.</p>
<p>When using multiple CPU ports, it is possible to stack a LAG (bonding/team)
device between the DSA slave devices and the physical DSA masters. The LAG
device is thus also a DSA master, but the LAG slave devices continue to be DSA
masters as well (just with no user port assigned to them; this is needed for
recovery in case the LAG DSA master disappears). Thus, the data path of the LAG
DSA master is used asymmetrically. On RX, the <code class="docutils literal notranslate"><span class="pre">ETH_P_XDSA</span></code> handler, which
calls <code class="docutils literal notranslate"><span class="pre">dsa_switch_rcv()</span></code>, is invoked early (on the physical DSA master;
LAG slave). Therefore, the RX data path of the LAG DSA master is not used.
On the other hand, TX takes place linearly: <code class="docutils literal notranslate"><span class="pre">dsa_slave_xmit</span></code> calls
<code class="docutils literal notranslate"><span class="pre">dsa_enqueue_skb</span></code>, which calls <code class="docutils literal notranslate"><span class="pre">dev_queue_xmit</span></code> towards the LAG DSA master.
The latter calls <code class="docutils literal notranslate"><span class="pre">dev_queue_xmit</span></code> towards one physical DSA master or the
other, and in both cases, the packet exits the system through a hardware path
towards the switch.</p>
</section>
<section id="graphical-representation">
<h3>Graphical representation<a class="headerlink" href="#graphical-representation" title="Permalink to this headline">¶</a></h3>
<p>Summarized, this is basically how DSA looks like from a network device
perspective:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>             Unaware application
           opens and binds socket
                    |  ^
                    |  |
        +-----------v--|--------------------+
        |+------+ +------+ +------+ +------+|
        || swp0 | | swp1 | | swp2 | | swp3 ||
        |+------+-+------+-+------+-+------+|
        |          DSA switch driver        |
        +-----------------------------------+
                      |        ^
         Tag added by |        | Tag consumed by
        switch driver |        | switch driver
                      v        |
        +-----------------------------------+
        | Unmodified host interface driver  | Software
--------+-----------------------------------+------------
        |       Host interface (eth0)       | Hardware
        +-----------------------------------+
                      |        ^
      Tag consumed by |        | Tag added by
      switch hardware |        | switch hardware
                      v        |
        +-----------------------------------+
        |               Switch              |
        |+------+ +------+ +------+ +------+|
        || swp0 | | swp1 | | swp2 | | swp3 ||
        ++------+-+------+-+------+-+------++
</pre></div>
</div>
</section>
<section id="slave-mdio-bus">
<h3>Slave MDIO bus<a class="headerlink" href="#slave-mdio-bus" title="Permalink to this headline">¶</a></h3>
<p>In order to be able to read to/from a switch PHY built into it, DSA creates a
slave MDIO bus which allows a specific switch driver to divert and intercept
MDIO reads/writes towards specific PHY addresses. In most MDIO-connected
switches, these functions would utilize direct or indirect PHY addressing mode
to return standard MII registers from the switch builtin PHYs, allowing the PHY
library and/or to return link status, link partner pages, auto-negotiation
results, etc.</p>
<p>For Ethernet switches which have both external and internal MDIO buses, the
slave MII bus can be utilized to mux/demux MDIO reads and writes towards either
internal or external MDIO devices this switch might be connected to: internal
PHYs, external PHYs, or even external switches.</p>
</section>
<section id="data-structures">
<h3>Data structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h3>
<p>DSA data structures are defined in <code class="docutils literal notranslate"><span class="pre">include/net/dsa.h</span></code> as well as
<code class="docutils literal notranslate"><span class="pre">net/dsa/dsa_priv.h</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dsa_chip_data</span></code>: platform data configuration for a given switch device,
this structure describes a switch device’s parent device, its address, as
well as various properties of its ports: names/labels, and finally a routing
table indication (when cascading switches)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dsa_platform_data</span></code>: platform device configuration data which can reference
a collection of dsa_chip_data structures if multiple switches are cascaded,
the master network device this switch tree is attached to needs to be
referenced</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dsa_switch_tree</span></code>: structure assigned to the master network device under
<code class="docutils literal notranslate"><span class="pre">dsa_ptr</span></code>, this structure references a dsa_platform_data structure as well as
the tagging protocol supported by the switch tree, and which receive/transmit
function hooks should be invoked, information about the directly attached
switch is also provided: CPU port. Finally, a collection of dsa_switch are
referenced to address individual switches in the tree.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dsa_switch</span></code>: structure describing a switch device in the tree, referencing
a <code class="docutils literal notranslate"><span class="pre">dsa_switch_tree</span></code> as a backpointer, slave network devices, master network
device, and a reference to the backing``dsa_switch_ops``</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dsa_switch_ops</span></code>: structure referencing function pointers, see below for a
full description.</p></li>
</ul>
</section>
</section>
<section id="design-limitations">
<h2>Design limitations<a class="headerlink" href="#design-limitations" title="Permalink to this headline">¶</a></h2>
<section id="lack-of-cpu-dsa-network-devices">
<h3>Lack of CPU/DSA network devices<a class="headerlink" href="#lack-of-cpu-dsa-network-devices" title="Permalink to this headline">¶</a></h3>
<p>DSA does not currently create slave network devices for the CPU or DSA ports, as
described before. This might be an issue in the following cases:</p>
<ul class="simple">
<li><p>inability to fetch switch CPU port statistics counters using ethtool, which
can make it harder to debug MDIO switch connected using xMII interfaces</p></li>
<li><p>inability to configure the CPU port link parameters based on the Ethernet
controller capabilities attached to it: <a class="reference external" href="http://patchwork.ozlabs.org/patch/509806/">http://patchwork.ozlabs.org/patch/509806/</a></p></li>
<li><p>inability to configure specific VLAN IDs / trunking VLANs between switches
when using a cascaded setup</p></li>
</ul>
</section>
<section id="common-pitfalls-using-dsa-setups">
<h3>Common pitfalls using DSA setups<a class="headerlink" href="#common-pitfalls-using-dsa-setups" title="Permalink to this headline">¶</a></h3>
<p>Once a master network device is configured to use DSA (dev-&gt;dsa_ptr becomes
non-NULL), and the switch behind it expects a tagging protocol, this network
interface can only exclusively be used as a conduit interface. Sending packets
directly through this interface (e.g.: opening a socket using this interface)
will not make us go through the switch tagging protocol transmit function, so
the Ethernet switch on the other end, expecting a tag will typically drop this
frame.</p>
</section>
</section>
<section id="interactions-with-other-subsystems">
<h2>Interactions with other subsystems<a class="headerlink" href="#interactions-with-other-subsystems" title="Permalink to this headline">¶</a></h2>
<p>DSA currently leverages the following subsystems:</p>
<ul class="simple">
<li><p>MDIO/PHY library: <code class="docutils literal notranslate"><span class="pre">drivers/net/phy/phy.c</span></code>, <code class="docutils literal notranslate"><span class="pre">mdio_bus.c</span></code></p></li>
<li><p>Switchdev:<code class="docutils literal notranslate"><span class="pre">net/switchdev/*</span></code></p></li>
<li><p>Device Tree for various of_* functions</p></li>
<li><p>Devlink: <code class="docutils literal notranslate"><span class="pre">net/core/devlink.c</span></code></p></li>
</ul>
<section id="mdio-phy-library">
<h3>MDIO/PHY library<a class="headerlink" href="#mdio-phy-library" title="Permalink to this headline">¶</a></h3>
<p>Slave network devices exposed by DSA may or may not be interfacing with PHY
devices (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">phy_device</span></code> as defined in <code class="docutils literal notranslate"><span class="pre">include/linux/phy.h)</span></code>, but the DSA
subsystem deals with all possible combinations:</p>
<ul class="simple">
<li><p>internal PHY devices, built into the Ethernet switch hardware</p></li>
<li><p>external PHY devices, connected via an internal or external MDIO bus</p></li>
<li><p>internal PHY devices, connected via an internal MDIO bus</p></li>
<li><p>special, non-autonegotiated or non MDIO-managed PHY devices: SFPs, MoCA; a.k.a
fixed PHYs</p></li>
</ul>
<p>The PHY configuration is done by the <code class="docutils literal notranslate"><span class="pre">dsa_slave_phy_setup()</span></code> function and the
logic basically looks like this:</p>
<ul class="simple">
<li><p>if Device Tree is used, the PHY device is looked up using the standard
“phy-handle” property, if found, this PHY device is created and registered
using <code class="docutils literal notranslate"><span class="pre">of_phy_connect()</span></code></p></li>
<li><p>if Device Tree is used and the PHY device is “fixed”, that is, conforms to
the definition of a non-MDIO managed PHY as defined in
<code class="docutils literal notranslate"><span class="pre">Documentation/devicetree/bindings/net/fixed-link.txt</span></code>, the PHY is registered
and connected transparently using the special fixed MDIO bus driver</p></li>
<li><p>finally, if the PHY is built into the switch, as is very common with
standalone switch packages, the PHY is probed using the slave MII bus created
by DSA</p></li>
</ul>
</section>
<section id="switchdev">
<h3>SWITCHDEV<a class="headerlink" href="#switchdev" title="Permalink to this headline">¶</a></h3>
<p>DSA directly utilizes SWITCHDEV when interfacing with the bridge layer, and
more specifically with its VLAN filtering portion when configuring VLANs on top
of per-port slave network devices. As of today, the only SWITCHDEV objects
supported by DSA are the FDB and VLAN objects.</p>
</section>
<section id="devlink">
<h3>Devlink<a class="headerlink" href="#devlink" title="Permalink to this headline">¶</a></h3>
<p>DSA registers one devlink device per physical switch in the fabric.
For each devlink device, every physical port (i.e. user ports, CPU ports, DSA
links or unused ports) is exposed as a devlink port.</p>
<p>DSA drivers can make use of the following devlink features:</p>
<ul class="simple">
<li><p>Regions: debugging feature which allows user space to dump driver-defined
areas of hardware information in a low-level, binary format. Both global
regions as well as per-port regions are supported. It is possible to export
devlink regions even for pieces of data that are already exposed in some way
to the standard iproute2 user space programs (ip-link, bridge), like address
tables and VLAN tables. For example, this might be useful if the tables
contain additional hardware-specific details which are not visible through
the iproute2 abstraction, or it might be useful to inspect these tables on
the non-user ports too, which are invisible to iproute2 because no network
interface is registered for them.</p></li>
<li><p>Params: a feature which enables user to configure certain low-level tunable
knobs pertaining to the device. Drivers may implement applicable generic
devlink params, or may add new device-specific devlink params.</p></li>
<li><p>Resources: a monitoring feature which enables users to see the degree of
utilization of certain hardware tables in the device, such as FDB, VLAN, etc.</p></li>
<li><p>Shared buffers: a QoS feature for adjusting and partitioning memory and frame
reservations per port and per traffic class, in the ingress and egress
directions, such that low-priority bulk traffic does not impede the
processing of high-priority critical traffic.</p></li>
</ul>
<p>For more details, consult <code class="docutils literal notranslate"><span class="pre">Documentation/networking/devlink/</span></code>.</p>
</section>
<section id="device-tree">
<h3>Device Tree<a class="headerlink" href="#device-tree" title="Permalink to this headline">¶</a></h3>
<p>DSA features a standardized binding which is documented in
<code class="docutils literal notranslate"><span class="pre">Documentation/devicetree/bindings/net/dsa/dsa.txt</span></code>. PHY/MDIO library helper
functions such as <code class="docutils literal notranslate"><span class="pre">of_get_phy_mode()</span></code>, <code class="docutils literal notranslate"><span class="pre">of_phy_connect()</span></code> are also used to query
per-port PHY specific details: interface connection, MDIO bus location, etc.</p>
</section>
</section>
<section id="driver-development">
<h2>Driver development<a class="headerlink" href="#driver-development" title="Permalink to this headline">¶</a></h2>
<p>DSA switch drivers need to implement a <code class="docutils literal notranslate"><span class="pre">dsa_switch_ops</span></code> structure which will
contain the various members described below.</p>
<section id="probing-registration-and-device-lifetime">
<h3>Probing, registration and device lifetime<a class="headerlink" href="#probing-registration-and-device-lifetime" title="Permalink to this headline">¶</a></h3>
<p>DSA switches are regular <code class="docutils literal notranslate"><span class="pre">device</span></code> structures on buses (be they platform, SPI,
I2C, MDIO or otherwise). The DSA framework is not involved in their probing
with the device core.</p>
<p>Switch registration from the perspective of a driver means passing a valid
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dsa_switch</span></code> pointer to <code class="docutils literal notranslate"><span class="pre">dsa_register_switch()</span></code>, usually from the
switch driver’s probing function. The following members must be valid in the
provided structure:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ds-&gt;dev</span></code>: will be used to parse the switch’s OF node or platform data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ds-&gt;num_ports</span></code>: will be used to create the port list for this switch, and
to validate the port indices provided in the OF node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ds-&gt;ops</span></code>: a pointer to the <code class="docutils literal notranslate"><span class="pre">dsa_switch_ops</span></code> structure holding the DSA
method implementations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ds-&gt;priv</span></code>: backpointer to a driver-private data structure which can be
retrieved in all further DSA method callbacks.</p></li>
</ul>
<p>In addition, the following flags in the <code class="docutils literal notranslate"><span class="pre">dsa_switch</span></code> structure may optionally
be configured to obtain driver-specific behavior from the DSA core. Their
behavior when set is documented through comments in <code class="docutils literal notranslate"><span class="pre">include/net/dsa.h</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ds-&gt;vlan_filtering_is_global</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ds-&gt;needs_standalone_vlan_filtering</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ds-&gt;configure_vlan_while_not_filtering</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ds-&gt;untag_bridge_pvid</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ds-&gt;assisted_learning_on_cpu_port</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ds-&gt;mtu_enforcement_ingress</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ds-&gt;fdb_isolation</span></code></p></li>
</ul>
<p>Internally, DSA keeps an array of switch trees (group of switches) global to
the kernel, and attaches a <code class="docutils literal notranslate"><span class="pre">dsa_switch</span></code> structure to a tree on registration.
The tree ID to which the switch is attached is determined by the first u32
number of the <code class="docutils literal notranslate"><span class="pre">dsa,member</span></code> property of the switch’s OF node (0 if missing).
The switch ID within the tree is determined by the second u32 number of the
same OF property (0 if missing). Registering multiple switches with the same
switch ID and tree ID is illegal and will cause an error. Using platform data,
a single switch and a single switch tree is permitted.</p>
<p>In case of a tree with multiple switches, probing takes place asymmetrically.
The first N-1 callers of <code class="docutils literal notranslate"><span class="pre">dsa_register_switch()</span></code> only add their ports to the
port list of the tree (<code class="docutils literal notranslate"><span class="pre">dst-&gt;ports</span></code>), each port having a backpointer to its
associated switch (<code class="docutils literal notranslate"><span class="pre">dp-&gt;ds</span></code>). Then, these switches exit their
<code class="docutils literal notranslate"><span class="pre">dsa_register_switch()</span></code> call early, because <code class="docutils literal notranslate"><span class="pre">dsa_tree_setup_routing_table()</span></code>
has determined that the tree is not yet complete (not all ports referenced by
DSA links are present in the tree’s port list). The tree becomes complete when
the last switch calls <code class="docutils literal notranslate"><span class="pre">dsa_register_switch()</span></code>, and this triggers the effective
continuation of initialization (including the call to <code class="docutils literal notranslate"><span class="pre">ds-&gt;ops-&gt;setup()</span></code>) for
all switches within that tree, all as part of the calling context of the last
switch’s probe function.</p>
<p>The opposite of registration takes place when calling <code class="docutils literal notranslate"><span class="pre">dsa_unregister_switch()</span></code>,
which removes a switch’s ports from the port list of the tree. The entire tree
is torn down when the first switch unregisters.</p>
<p>It is mandatory for DSA switch drivers to implement the <code class="docutils literal notranslate"><span class="pre">shutdown()</span></code> callback
of their respective bus, and call <code class="docutils literal notranslate"><span class="pre">dsa_switch_shutdown()</span></code> from it (a minimal
version of the full teardown performed by <code class="docutils literal notranslate"><span class="pre">dsa_unregister_switch()</span></code>).
The reason is that DSA keeps a reference on the master net device, and if the
driver for the master device decides to unbind on shutdown, DSA’s reference
will block that operation from finalizing.</p>
<p>Either <code class="docutils literal notranslate"><span class="pre">dsa_switch_shutdown()</span></code> or <code class="docutils literal notranslate"><span class="pre">dsa_unregister_switch()</span></code> must be called,
but not both, and the device driver model permits the bus’ <code class="docutils literal notranslate"><span class="pre">remove()</span></code> method
to be called even if <code class="docutils literal notranslate"><span class="pre">shutdown()</span></code> was already called. Therefore, drivers are
expected to implement a mutual exclusion method between <code class="docutils literal notranslate"><span class="pre">remove()</span></code> and
<code class="docutils literal notranslate"><span class="pre">shutdown()</span></code> by setting their drvdata to NULL after any of these has run, and
checking whether the drvdata is NULL before proceeding to take any action.</p>
<p>After <code class="docutils literal notranslate"><span class="pre">dsa_switch_shutdown()</span></code> or <code class="docutils literal notranslate"><span class="pre">dsa_unregister_switch()</span></code> was called, no
further callbacks via the provided <code class="docutils literal notranslate"><span class="pre">dsa_switch_ops</span></code> may take place, and the
driver may free the data structures associated with the <code class="docutils literal notranslate"><span class="pre">dsa_switch</span></code>.</p>
</section>
<section id="switch-configuration">
<h3>Switch configuration<a class="headerlink" href="#switch-configuration" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">get_tag_protocol</span></code>: this is to indicate what kind of tagging protocol is
supported, should be a valid value from the <code class="docutils literal notranslate"><span class="pre">dsa_tag_protocol</span></code> enum.
The returned information does not have to be static; the driver is passed the
CPU port number, as well as the tagging protocol of a possibly stacked
upstream switch, in case there are hardware limitations in terms of supported
tag formats.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">change_tag_protocol</span></code>: when the default tagging protocol has compatibility
problems with the master or other issues, the driver may support changing it
at runtime, either through a device tree property or through sysfs. In that
case, further calls to <code class="docutils literal notranslate"><span class="pre">get_tag_protocol</span></code> should report the protocol in
current use.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">setup</span></code>: setup function for the switch, this function is responsible for setting
up the <code class="docutils literal notranslate"><span class="pre">dsa_switch_ops</span></code> private structure with all it needs: register maps,
interrupts, mutexes, locks, etc. This function is also expected to properly
configure the switch to separate all network interfaces from each other, that
is, they should be isolated by the switch hardware itself, typically by creating
a Port-based VLAN ID for each port and allowing only the CPU port and the
specific port to be in the forwarding vector. Ports that are unused by the
platform should be disabled. Past this function, the switch is expected to be
fully configured and ready to serve any kind of request. It is recommended
to issue a software reset of the switch during this setup function in order to
avoid relying on what a previous software agent such as a bootloader/firmware
may have previously configured. The method responsible for undoing any
applicable allocations or operations done here is <code class="docutils literal notranslate"><span class="pre">teardown</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_setup</span></code> and <code class="docutils literal notranslate"><span class="pre">port_teardown</span></code>: methods for initialization and
destruction of per-port data structures. It is mandatory for some operations
such as registering and unregistering devlink port regions to be done from
these methods, otherwise they are optional. A port will be torn down only if
it has been previously set up. It is possible for a port to be set up during
probing only to be torn down immediately afterwards, for example in case its
PHY cannot be found. In this case, probing of the DSA switch continues
without that particular port.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_change_master</span></code>: method through which the affinity (association used
for traffic termination purposes) between a user port and a CPU port can be
changed. By default all user ports from a tree are assigned to the first
available CPU port that makes sense for them (most of the times this means
the user ports of a tree are all assigned to the same CPU port, except for H
topologies as described in commit 2c0b03258b8b). The <code class="docutils literal notranslate"><span class="pre">port</span></code> argument
represents the index of the user port, and the <code class="docutils literal notranslate"><span class="pre">master</span></code> argument represents
the new DSA master <code class="docutils literal notranslate"><span class="pre">net_device</span></code>. The CPU port associated with the new
master can be retrieved by looking at <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dsa_port</span> <span class="pre">*cpu_dp</span> <span class="pre">=</span>
<span class="pre">master-&gt;dsa_ptr</span></code>. Additionally, the master can also be a LAG device where
all the slave devices are physical DSA masters. LAG DSA masters also have a
valid <code class="docutils literal notranslate"><span class="pre">master-&gt;dsa_ptr</span></code> pointer, however this is not unique, but rather a
duplicate of the first physical DSA master’s (LAG slave) <code class="docutils literal notranslate"><span class="pre">dsa_ptr</span></code>. In case
of a LAG DSA master, a further call to <code class="docutils literal notranslate"><span class="pre">port_lag_join</span></code> will be emitted
separately for the physical CPU ports associated with the physical DSA
masters, requesting them to create a hardware LAG associated with the LAG
interface.</p></li>
</ul>
</section>
<section id="phy-devices-and-link-management">
<h3>PHY devices and link management<a class="headerlink" href="#phy-devices-and-link-management" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">get_phy_flags</span></code>: Some switches are interfaced to various kinds of Ethernet PHYs,
if the PHY library PHY driver needs to know about information it cannot obtain
on its own (e.g.: coming from switch memory mapped registers), this function
should return a 32-bit bitmask of “flags” that is private between the switch
driver and the Ethernet PHY driver in <code class="docutils literal notranslate"><span class="pre">drivers/net/phy/\*</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phy_read</span></code>: Function invoked by the DSA slave MDIO bus when attempting to read
the switch port MDIO registers. If unavailable, return 0xffff for each read.
For builtin switch Ethernet PHYs, this function should allow reading the link
status, auto-negotiation results, link partner pages, etc.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phy_write</span></code>: Function invoked by the DSA slave MDIO bus when attempting to write
to the switch port MDIO registers. If unavailable return a negative error
code.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjust_link</span></code>: Function invoked by the PHY library when a slave network device
is attached to a PHY device. This function is responsible for appropriately
configuring the switch port link parameters: speed, duplex, pause based on
what the <code class="docutils literal notranslate"><span class="pre">phy_device</span></code> is providing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fixed_link_update</span></code>: Function invoked by the PHY library, and specifically by
the fixed PHY driver asking the switch driver for link parameters that could
not be auto-negotiated, or obtained by reading the PHY registers through MDIO.
This is particularly useful for specific kinds of hardware such as QSGMII,
MoCA or other kinds of non-MDIO managed PHYs where out of band link
information is obtained</p></li>
</ul>
</section>
<section id="ethtool-operations">
<h3>Ethtool operations<a class="headerlink" href="#ethtool-operations" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">get_strings</span></code>: ethtool function used to query the driver’s strings, will
typically return statistics strings, private flags strings, etc.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_ethtool_stats</span></code>: ethtool function used to query per-port statistics and
return their values. DSA overlays slave network devices general statistics:
RX/TX counters from the network device, with switch driver specific statistics
per port</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_sset_count</span></code>: ethtool function used to query the number of statistics items</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_wol</span></code>: ethtool function used to obtain Wake-on-LAN settings per-port, this
function may for certain implementations also query the master network device
Wake-on-LAN settings if this interface needs to participate in Wake-on-LAN</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set_wol</span></code>: ethtool function used to configure Wake-on-LAN settings per-port,
direct counterpart to set_wol with similar restrictions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set_eee</span></code>: ethtool function which is used to configure a switch port EEE (Green
Ethernet) settings, can optionally invoke the PHY library to enable EEE at the
PHY level if relevant. This function should enable EEE at the switch port MAC
controller and data-processing logic</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_eee</span></code>: ethtool function which is used to query a switch port EEE settings,
this function should return the EEE state of the switch port MAC controller
and data-processing logic as well as query the PHY for its currently configured
EEE settings</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_eeprom_len</span></code>: ethtool function returning for a given switch the EEPROM
length/size in bytes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_eeprom</span></code>: ethtool function returning for a given switch the EEPROM contents</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set_eeprom</span></code>: ethtool function writing specified data to a given switch EEPROM</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_regs_len</span></code>: ethtool function returning the register length for a given
switch</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_regs</span></code>: ethtool function returning the Ethernet switch internal register
contents. This function might require user-land code in ethtool to
pretty-print register values and registers</p></li>
</ul>
</section>
<section id="power-management">
<h3>Power management<a class="headerlink" href="#power-management" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">suspend</span></code>: function invoked by the DSA platform device when the system goes to
suspend, should quiesce all Ethernet switch activities, but keep ports
participating in Wake-on-LAN active as well as additional wake-up logic if
supported</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">resume</span></code>: function invoked by the DSA platform device when the system resumes,
should resume all Ethernet switch activities and re-configure the switch to be
in a fully active state</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_enable</span></code>: function invoked by the DSA slave network device ndo_open
function when a port is administratively brought up, this function should
fully enable a given switch port. DSA takes care of marking the port with
<code class="docutils literal notranslate"><span class="pre">BR_STATE_BLOCKING</span></code> if the port is a bridge member, or <code class="docutils literal notranslate"><span class="pre">BR_STATE_FORWARDING</span></code> if it
was not, and propagating these changes down to the hardware</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_disable</span></code>: function invoked by the DSA slave network device ndo_close
function when a port is administratively brought down, this function should
fully disable a given switch port. DSA takes care of marking the port with
<code class="docutils literal notranslate"><span class="pre">BR_STATE_DISABLED</span></code> and propagating changes to the hardware if this port is
disabled while being a bridge member</p></li>
</ul>
</section>
<section id="address-databases">
<h3>Address databases<a class="headerlink" href="#address-databases" title="Permalink to this headline">¶</a></h3>
<p>Switching hardware is expected to have a table for FDB entries, however not all
of them are active at the same time. An address database is the subset (partition)
of FDB entries that is active (can be matched by address learning on RX, or FDB
lookup on TX) depending on the state of the port. An address database may
occasionally be called “FID” (Filtering ID) in this document, although the
underlying implementation may choose whatever is available to the hardware.</p>
<p>For example, all ports that belong to a VLAN-unaware bridge (which is
<em>currently</em> VLAN-unaware) are expected to learn source addresses in the
database associated by the driver with that bridge (and not with other
VLAN-unaware bridges). During forwarding and FDB lookup, a packet received on a
VLAN-unaware bridge port should be able to find a VLAN-unaware FDB entry having
the same MAC DA as the packet, which is present on another port member of the
same bridge. At the same time, the FDB lookup process must be able to not find
an FDB entry having the same MAC DA as the packet, if that entry points towards
a port which is a member of a different VLAN-unaware bridge (and is therefore
associated with a different address database).</p>
<p>Similarly, each VLAN of each offloaded VLAN-aware bridge should have an
associated address database, which is shared by all ports which are members of
that VLAN, but not shared by ports belonging to different bridges that are
members of the same VID.</p>
<p>In this context, a VLAN-unaware database means that all packets are expected to
match on it irrespective of VLAN ID (only MAC address lookup), whereas a
VLAN-aware database means that packets are supposed to match based on the VLAN
ID from the classified 802.1Q header (or the pvid if untagged).</p>
<p>At the bridge layer, VLAN-unaware FDB entries have the special VID value of 0,
whereas VLAN-aware FDB entries have non-zero VID values. Note that a
VLAN-unaware bridge may have VLAN-aware (non-zero VID) FDB entries, and a
VLAN-aware bridge may have VLAN-unaware FDB entries. As in hardware, the
software bridge keeps separate address databases, and offloads to hardware the
FDB entries belonging to these databases, through switchdev, asynchronously
relative to the moment when the databases become active or inactive.</p>
<p>When a user port operates in standalone mode, its driver should configure it to
use a separate database called a port private database. This is different from
the databases described above, and should impede operation as standalone port
(packet in, packet out to the CPU port) as little as possible. For example,
on ingress, it should not attempt to learn the MAC SA of ingress traffic, since
learning is a bridging layer service and this is a standalone port, therefore
it would consume useless space. With no address learning, the port private
database should be empty in a naive implementation, and in this case, all
received packets should be trivially flooded to the CPU port.</p>
<p>DSA (cascade) and CPU ports are also called “shared” ports because they service
multiple address databases, and the database that a packet should be associated
to is usually embedded in the DSA tag. This means that the CPU port may
simultaneously transport packets coming from a standalone port (which were
classified by hardware in one address database), and from a bridge port (which
were classified to a different address database).</p>
<p>Switch drivers which satisfy certain criteria are able to optimize the naive
configuration by removing the CPU port from the flooding domain of the switch,
and just program the hardware with FDB entries pointing towards the CPU port
for which it is known that software is interested in those MAC addresses.
Packets which do not match a known FDB entry will not be delivered to the CPU,
which will save CPU cycles required for creating an skb just to drop it.</p>
<p>DSA is able to perform host address filtering for the following kinds of
addresses:</p>
<ul class="simple">
<li><p>Primary unicast MAC addresses of ports (<code class="docutils literal notranslate"><span class="pre">dev-&gt;dev_addr</span></code>). These are
associated with the port private database of the respective user port,
and the driver is notified to install them through <code class="docutils literal notranslate"><span class="pre">port_fdb_add</span></code> towards
the CPU port.</p></li>
<li><p>Secondary unicast and multicast MAC addresses of ports (addresses added
through <code class="docutils literal notranslate"><span class="pre">dev_uc_add()</span></code> and <code class="docutils literal notranslate"><span class="pre">dev_mc_add()</span></code>). These are also associated
with the port private database of the respective user port.</p></li>
<li><p>Local/permanent bridge FDB entries (<code class="docutils literal notranslate"><span class="pre">BR_FDB_LOCAL</span></code>). These are the MAC
addresses of the bridge ports, for which packets must be terminated locally
and not forwarded. They are associated with the address database for that
bridge.</p></li>
<li><p>Static bridge FDB entries installed towards foreign (non-DSA) interfaces
present in the same bridge as some DSA switch ports. These are also
associated with the address database for that bridge.</p></li>
<li><p>Dynamically learned FDB entries on foreign interfaces present in the same
bridge as some DSA switch ports, only if <code class="docutils literal notranslate"><span class="pre">ds-&gt;assisted_learning_on_cpu_port</span></code>
is set to true by the driver. These are associated with the address database
for that bridge.</p></li>
</ul>
<p>For various operations detailed below, DSA provides a <code class="docutils literal notranslate"><span class="pre">dsa_db</span></code> structure
which can be of the following types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DSA_DB_PORT</span></code>: the FDB (or MDB) entry to be installed or deleted belongs to
the port private database of user port <code class="docutils literal notranslate"><span class="pre">db-&gt;dp</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DSA_DB_BRIDGE</span></code>: the entry belongs to one of the address databases of bridge
<code class="docutils literal notranslate"><span class="pre">db-&gt;bridge</span></code>. Separation between the VLAN-unaware database and the per-VID
databases of this bridge is expected to be done by the driver.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DSA_DB_LAG</span></code>: the entry belongs to the address database of LAG <code class="docutils literal notranslate"><span class="pre">db-&gt;lag</span></code>.
Note: <code class="docutils literal notranslate"><span class="pre">DSA_DB_LAG</span></code> is currently unused and may be removed in the future.</p></li>
</ul>
<p>The drivers which act upon the <code class="docutils literal notranslate"><span class="pre">dsa_db</span></code> argument in <code class="docutils literal notranslate"><span class="pre">port_fdb_add</span></code>,
<code class="docutils literal notranslate"><span class="pre">port_mdb_add</span></code> etc should declare <code class="docutils literal notranslate"><span class="pre">ds-&gt;fdb_isolation</span></code> as true.</p>
<p>DSA associates each offloaded bridge and each offloaded LAG with a one-based ID
(<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dsa_bridge</span> <span class="pre">::</span> <span class="pre">num</span></code>, <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dsa_lag</span> <span class="pre">::</span> <span class="pre">id</span></code>) for the purposes of
refcounting addresses on shared ports. Drivers may piggyback on DSA’s numbering
scheme (the ID is readable through <code class="docutils literal notranslate"><span class="pre">db-&gt;bridge.num</span></code> and <code class="docutils literal notranslate"><span class="pre">db-&gt;lag.id</span></code> or may
implement their own.</p>
<p>Only the drivers which declare support for FDB isolation are notified of FDB
entries on the CPU port belonging to <code class="docutils literal notranslate"><span class="pre">DSA_DB_PORT</span></code> databases.
For compatibility/legacy reasons, <code class="docutils literal notranslate"><span class="pre">DSA_DB_BRIDGE</span></code> addresses are notified to
drivers even if they do not support FDB isolation. However, <code class="docutils literal notranslate"><span class="pre">db-&gt;bridge.num</span></code>
and <code class="docutils literal notranslate"><span class="pre">db-&gt;lag.id</span></code> are always set to 0 in that case (to denote the lack of
isolation, for refcounting purposes).</p>
<p>Note that it is not mandatory for a switch driver to implement physically
separate address databases for each standalone user port. Since FDB entries in
the port private databases will always point to the CPU port, there is no risk
for incorrect forwarding decisions. In this case, all standalone ports may
share the same database, but the reference counting of host-filtered addresses
(not deleting the FDB entry for a port’s MAC address if it’s still in use by
another port) becomes the responsibility of the driver, because DSA is unaware
that the port databases are in fact shared. This can be achieved by calling
<code class="docutils literal notranslate"><span class="pre">dsa_fdb_present_in_other_db()</span></code> and <code class="docutils literal notranslate"><span class="pre">dsa_mdb_present_in_other_db()</span></code>.
The down side is that the RX filtering lists of each user port are in fact
shared, which means that user port A may accept a packet with a MAC DA it
shouldn’t have, only because that MAC address was in the RX filtering list of
user port B. These packets will still be dropped in software, however.</p>
</section>
<section id="bridge-layer">
<h3>Bridge layer<a class="headerlink" href="#bridge-layer" title="Permalink to this headline">¶</a></h3>
<p>Offloading the bridge forwarding plane is optional and handled by the methods
below. They may be absent, return -EOPNOTSUPP, or <code class="docutils literal notranslate"><span class="pre">ds-&gt;max_num_bridges</span></code> may
be non-zero and exceeded, and in this case, joining a bridge port is still
possible, but the packet forwarding will take place in software, and the ports
under a software bridge must remain configured in the same way as for
standalone operation, i.e. have all bridging service functions (address
learning etc) disabled, and send all received packets to the CPU port only.</p>
<p>Concretely, a port starts offloading the forwarding plane of a bridge once it
returns success to the <code class="docutils literal notranslate"><span class="pre">port_bridge_join</span></code> method, and stops doing so after
<code class="docutils literal notranslate"><span class="pre">port_bridge_leave</span></code> has been called. Offloading the bridge means autonomously
learning FDB entries in accordance with the software bridge port’s state, and
autonomously forwarding (or flooding) received packets without CPU intervention.
This is optional even when offloading a bridge port. Tagging protocol drivers
are expected to call <code class="docutils literal notranslate"><span class="pre">dsa_default_offload_fwd_mark(skb)</span></code> for packets which
have already been autonomously forwarded in the forwarding domain of the
ingress switch port. DSA, through <code class="docutils literal notranslate"><span class="pre">dsa_port_devlink_setup()</span></code>, considers all
switch ports part of the same tree ID to be part of the same bridge forwarding
domain (capable of autonomous forwarding to each other).</p>
<p>Offloading the TX forwarding process of a bridge is a distinct concept from
simply offloading its forwarding plane, and refers to the ability of certain
driver and tag protocol combinations to transmit a single skb coming from the
bridge device’s transmit function to potentially multiple egress ports (and
thereby avoid its cloning in software).</p>
<p>Packets for which the bridge requests this behavior are called data plane
packets and have <code class="docutils literal notranslate"><span class="pre">skb-&gt;offload_fwd_mark</span></code> set to true in the tag protocol
driver’s <code class="docutils literal notranslate"><span class="pre">xmit</span></code> function. Data plane packets are subject to FDB lookup,
hardware learning on the CPU port, and do not override the port STP state.
Additionally, replication of data plane packets (multicast, flooding) is
handled in hardware and the bridge driver will transmit a single skb for each
packet that may or may not need replication.</p>
<p>When the TX forwarding offload is enabled, the tag protocol driver is
responsible to inject packets into the data plane of the hardware towards the
correct bridging domain (FID) that the port is a part of. The port may be
VLAN-unaware, and in this case the FID must be equal to the FID used by the
driver for its VLAN-unaware address database associated with that bridge.
Alternatively, the bridge may be VLAN-aware, and in that case, it is guaranteed
that the packet is also VLAN-tagged with the VLAN ID that the bridge processed
this packet in. It is the responsibility of the hardware to untag the VID on
the egress-untagged ports, or keep the tag on the egress-tagged ones.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">port_bridge_join</span></code>: bridge layer function invoked when a given switch port is
added to a bridge, this function should do what’s necessary at the switch
level to permit the joining port to be added to the relevant logical
domain for it to ingress/egress traffic with other members of the bridge.
By setting the <code class="docutils literal notranslate"><span class="pre">tx_fwd_offload</span></code> argument to true, the TX forwarding process
of this bridge is also offloaded.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_bridge_leave</span></code>: bridge layer function invoked when a given switch port is
removed from a bridge, this function should do what’s necessary at the
switch level to deny the leaving port from ingress/egress traffic from the
remaining bridge members.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_stp_state_set</span></code>: bridge layer function invoked when a given switch port STP
state is computed by the bridge layer and should be propagated to switch
hardware to forward/block/learn traffic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_bridge_flags</span></code>: bridge layer function invoked when a port must
configure its settings for e.g. flooding of unknown traffic or source address
learning. The switch driver is responsible for initial setup of the
standalone ports with address learning disabled and egress flooding of all
types of traffic, then the DSA core notifies of any change to the bridge port
flags when the port joins and leaves a bridge. DSA does not currently manage
the bridge port flags for the CPU port. The assumption is that address
learning should be statically enabled (if supported by the hardware) on the
CPU port, and flooding towards the CPU port should also be enabled, due to a
lack of an explicit address filtering mechanism in the DSA core.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_fast_age</span></code>: bridge layer function invoked when flushing the
dynamically learned FDB entries on the port is necessary. This is called when
transitioning from an STP state where learning should take place to an STP
state where it shouldn’t, or when leaving a bridge, or when address learning
is turned off via <code class="docutils literal notranslate"><span class="pre">port_bridge_flags</span></code>.</p></li>
</ul>
</section>
<section id="bridge-vlan-filtering">
<h3>Bridge VLAN filtering<a class="headerlink" href="#bridge-vlan-filtering" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">port_vlan_filtering</span></code>: bridge layer function invoked when the bridge gets
configured for turning on or off VLAN filtering. If nothing specific needs to
be done at the hardware level, this callback does not need to be implemented.
When VLAN filtering is turned on, the hardware must be programmed with
rejecting 802.1Q frames which have VLAN IDs outside of the programmed allowed
VLAN ID map/rules.  If there is no PVID programmed into the switch port,
untagged frames must be rejected as well. When turned off the switch must
accept any 802.1Q frames irrespective of their VLAN ID, and untagged frames are
allowed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_vlan_add</span></code>: bridge layer function invoked when a VLAN is configured
(tagged or untagged) for the given switch port. The CPU port becomes a member
of a VLAN only if a foreign bridge port is also a member of it (and
forwarding needs to take place in software), or the VLAN is installed to the
VLAN group of the bridge device itself, for termination purposes
(<code class="docutils literal notranslate"><span class="pre">bridge</span> <span class="pre">vlan</span> <span class="pre">add</span> <span class="pre">dev</span> <span class="pre">br0</span> <span class="pre">vid</span> <span class="pre">100</span> <span class="pre">self</span></code>). VLANs on shared ports are
reference counted and removed when there is no user left. Drivers do not need
to manually install a VLAN on the CPU port.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_vlan_del</span></code>: bridge layer function invoked when a VLAN is removed from the
given switch port</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_fdb_add</span></code>: bridge layer function invoked when the bridge wants to install a
Forwarding Database entry, the switch hardware should be programmed with the
specified address in the specified VLAN Id in the forwarding database
associated with this VLAN ID.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_fdb_del</span></code>: bridge layer function invoked when the bridge wants to remove a
Forwarding Database entry, the switch hardware should be programmed to delete
the specified MAC address from the specified VLAN ID if it was mapped into
this port forwarding database</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_fdb_dump</span></code>: bridge bypass function invoked by <code class="docutils literal notranslate"><span class="pre">ndo_fdb_dump</span></code> on the
physical DSA port interfaces. Since DSA does not attempt to keep in sync its
hardware FDB entries with the software bridge, this method is implemented as
a means to view the entries visible on user ports in the hardware database.
The entries reported by this function have the <code class="docutils literal notranslate"><span class="pre">self</span></code> flag in the output of
the <code class="docutils literal notranslate"><span class="pre">bridge</span> <span class="pre">fdb</span> <span class="pre">show</span></code> command.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_mdb_add</span></code>: bridge layer function invoked when the bridge wants to install
a multicast database entry. The switch hardware should be programmed with the
specified address in the specified VLAN ID in the forwarding database
associated with this VLAN ID.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_mdb_del</span></code>: bridge layer function invoked when the bridge wants to remove a
multicast database entry, the switch hardware should be programmed to delete
the specified MAC address from the specified VLAN ID if it was mapped into
this port forwarding database.</p></li>
</ul>
</section>
<section id="link-aggregation">
<h3>Link aggregation<a class="headerlink" href="#link-aggregation" title="Permalink to this headline">¶</a></h3>
<p>Link aggregation is implemented in the Linux networking stack by the bonding
and team drivers, which are modeled as virtual, stackable network interfaces.
DSA is capable of offloading a link aggregation group (LAG) to hardware that
supports the feature, and supports bridging between physical ports and LAGs,
as well as between LAGs. A bonding/team interface which holds multiple physical
ports constitutes a logical port, although DSA has no explicit concept of a
logical port at the moment. Due to this, events where a LAG joins/leaves a
bridge are treated as if all individual physical ports that are members of that
LAG join/leave the bridge. Switchdev port attributes (VLAN filtering, STP
state, etc) and objects (VLANs, MDB entries) offloaded to a LAG as bridge port
are treated similarly: DSA offloads the same switchdev object / port attribute
on all members of the LAG. Static bridge FDB entries on a LAG are not yet
supported, since the DSA driver API does not have the concept of a logical port
ID.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">port_lag_join</span></code>: function invoked when a given switch port is added to a
LAG. The driver may return <code class="docutils literal notranslate"><span class="pre">-EOPNOTSUPP</span></code>, and in this case, DSA will fall
back to a software implementation where all traffic from this port is sent to
the CPU.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_lag_leave</span></code>: function invoked when a given switch port leaves a LAG
and returns to operation as a standalone port.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_lag_change</span></code>: function invoked when the link state of any member of
the LAG changes, and the hashing function needs rebalancing to only make use
of the subset of physical LAG member ports that are up.</p></li>
</ul>
<p>Drivers that benefit from having an ID associated with each offloaded LAG
can optionally populate <code class="docutils literal notranslate"><span class="pre">ds-&gt;num_lag_ids</span></code> from the <code class="docutils literal notranslate"><span class="pre">dsa_switch_ops::setup</span></code>
method. The LAG ID associated with a bonding/team interface can then be
retrieved by a DSA switch driver using the <code class="docutils literal notranslate"><span class="pre">dsa_lag_id</span></code> function.</p>
</section>
<section id="iec-62439-2-mrp">
<h3>IEC 62439-2 (MRP)<a class="headerlink" href="#iec-62439-2-mrp" title="Permalink to this headline">¶</a></h3>
<p>The Media Redundancy Protocol is a topology management protocol optimized for
fast fault recovery time for ring networks, which has some components
implemented as a function of the bridge driver. MRP uses management PDUs
(Test, Topology, LinkDown/Up, Option) sent at a multicast destination MAC
address range of 01:15:4e:00:00:0x and with an EtherType of 0x88e3.
Depending on the node’s role in the ring (MRM: Media Redundancy Manager,
MRC: Media Redundancy Client, MRA: Media Redundancy Automanager), certain MRP
PDUs might need to be terminated locally and others might need to be forwarded.
An MRM might also benefit from offloading to hardware the creation and
transmission of certain MRP PDUs (Test).</p>
<p>Normally an MRP instance can be created on top of any network interface,
however in the case of a device with an offloaded data path such as DSA, it is
necessary for the hardware, even if it is not MRP-aware, to be able to extract
the MRP PDUs from the fabric before the driver can proceed with the software
implementation. DSA today has no driver which is MRP-aware, therefore it only
listens for the bare minimum switchdev objects required for the software assist
to work properly. The operations are detailed below.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">port_mrp_add</span></code> and <code class="docutils literal notranslate"><span class="pre">port_mrp_del</span></code>: notifies driver when an MRP instance
with a certain ring ID, priority, primary port and secondary port is
created/deleted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_mrp_add_ring_role</span></code> and <code class="docutils literal notranslate"><span class="pre">port_mrp_del_ring_role</span></code>: function invoked
when an MRP instance changes ring roles between MRM or MRC. This affects
which MRP PDUs should be trapped to software and which should be autonomously
forwarded.</p></li>
</ul>
</section>
<section id="iec-62439-3-hsr-prp">
<h3>IEC 62439-3 (HSR/PRP)<a class="headerlink" href="#iec-62439-3-hsr-prp" title="Permalink to this headline">¶</a></h3>
<p>The Parallel Redundancy Protocol (PRP) is a network redundancy protocol which
works by duplicating and sequence numbering packets through two independent L2
networks (which are unaware of the PRP tail tags carried in the packets), and
eliminating the duplicates at the receiver. The High-availability Seamless
Redundancy (HSR) protocol is similar in concept, except all nodes that carry
the redundant traffic are aware of the fact that it is HSR-tagged (because HSR
uses a header with an EtherType of 0x892f) and are physically connected in a
ring topology. Both HSR and PRP use supervision frames for monitoring the
health of the network and for discovery of other nodes.</p>
<p>In Linux, both HSR and PRP are implemented in the hsr driver, which
instantiates a virtual, stackable network interface with two member ports.
The driver only implements the basic roles of DANH (Doubly Attached Node
implementing HSR) and DANP (Doubly Attached Node implementing PRP); the roles
of RedBox and QuadBox are not implemented (therefore, bridging a hsr network
interface with a physical switch port does not produce the expected result).</p>
<p>A driver which is able of offloading certain functions of a DANP or DANH should
declare the corresponding netdev features as indicated by the documentation at
<code class="docutils literal notranslate"><span class="pre">Documentation/networking/netdev-features.rst</span></code>. Additionally, the following
methods must be implemented:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">port_hsr_join</span></code>: function invoked when a given switch port is added to a
DANP/DANH. The driver may return <code class="docutils literal notranslate"><span class="pre">-EOPNOTSUPP</span></code> and in this case, DSA will
fall back to a software implementation where all traffic from this port is
sent to the CPU.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">port_hsr_leave</span></code>: function invoked when a given switch port leaves a
DANP/DANH and returns to normal operation as a standalone port.</p></li>
</ul>
</section>
</section>
<section id="todo">
<h2>TODO<a class="headerlink" href="#todo" title="Permalink to this headline">¶</a></h2>
<section id="making-switchdev-and-dsa-converge-towards-an-unified-codebase">
<h3>Making SWITCHDEV and DSA converge towards an unified codebase<a class="headerlink" href="#making-switchdev-and-dsa-converge-towards-an-unified-codebase" title="Permalink to this headline">¶</a></h3>
<p>SWITCHDEV properly takes care of abstracting the networking stack with offload
capable hardware, but does not enforce a strict switch device driver model. On
the other DSA enforces a fairly strict device driver model, and deals with most
of the switch specific. At some point we should envision a merger between these
two subsystems and get the best of both worlds.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Architecture</a><ul>
<li><a class="reference internal" href="#design-principles">Design principles</a><ul>
<li><a class="reference internal" href="#switch-tagging-protocols">Switch tagging protocols</a></li>
<li><a class="reference internal" href="#master-network-devices">Master network devices</a></li>
<li><a class="reference internal" href="#networking-stack-hooks">Networking stack hooks</a></li>
<li><a class="reference internal" href="#slave-network-devices">Slave network devices</a></li>
<li><a class="reference internal" href="#graphical-representation">Graphical representation</a></li>
<li><a class="reference internal" href="#slave-mdio-bus">Slave MDIO bus</a></li>
<li><a class="reference internal" href="#data-structures">Data structures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-limitations">Design limitations</a><ul>
<li><a class="reference internal" href="#lack-of-cpu-dsa-network-devices">Lack of CPU/DSA network devices</a></li>
<li><a class="reference internal" href="#common-pitfalls-using-dsa-setups">Common pitfalls using DSA setups</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interactions-with-other-subsystems">Interactions with other subsystems</a><ul>
<li><a class="reference internal" href="#mdio-phy-library">MDIO/PHY library</a></li>
<li><a class="reference internal" href="#switchdev">SWITCHDEV</a></li>
<li><a class="reference internal" href="#devlink">Devlink</a></li>
<li><a class="reference internal" href="#device-tree">Device Tree</a></li>
</ul>
</li>
<li><a class="reference internal" href="#driver-development">Driver development</a><ul>
<li><a class="reference internal" href="#probing-registration-and-device-lifetime">Probing, registration and device lifetime</a></li>
<li><a class="reference internal" href="#switch-configuration">Switch configuration</a></li>
<li><a class="reference internal" href="#phy-devices-and-link-management">PHY devices and link management</a></li>
<li><a class="reference internal" href="#ethtool-operations">Ethtool operations</a></li>
<li><a class="reference internal" href="#power-management">Power management</a></li>
<li><a class="reference internal" href="#address-databases">Address databases</a></li>
<li><a class="reference internal" href="#bridge-layer">Bridge layer</a></li>
<li><a class="reference internal" href="#bridge-vlan-filtering">Bridge VLAN filtering</a></li>
<li><a class="reference internal" href="#link-aggregation">Link aggregation</a></li>
<li><a class="reference internal" href="#iec-62439-2-mrp">IEC 62439-2 (MRP)</a></li>
<li><a class="reference internal" href="#iec-62439-3-hsr-prp">IEC 62439-3 (HSR/PRP)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#todo">TODO</a><ul>
<li><a class="reference internal" href="#making-switchdev-and-dsa-converge-towards-an-unified-codebase">Making SWITCHDEV and DSA converge towards an unified codebase</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/networking/dsa/dsa.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/networking/dsa/dsa.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>