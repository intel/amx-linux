
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Kernel TLS offload &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux NFC subsystem" href="nfc.html" />
    <link rel="prev" title="Kernel TLS" href="tls.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="kernel-tls-offload">
<h1>Kernel TLS offload<a class="headerlink" href="#kernel-tls-offload" title="Permalink to this headline">¶</a></h1>
<section id="kernel-tls-operation">
<h2>Kernel TLS operation<a class="headerlink" href="#kernel-tls-operation" title="Permalink to this headline">¶</a></h2>
<p>Linux kernel provides TLS connection offload infrastructure. Once a TCP
connection is in <code class="docutils literal notranslate"><span class="pre">ESTABLISHED</span></code> state user space can enable the TLS Upper
Layer Protocol (ULP) and install the cryptographic connection state.
For details regarding the user-facing interface refer to the TLS
documentation in <a class="reference internal" href="tls.html#kernel-tls"><span class="std std-ref">Documentation/networking/tls.rst</span></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ktls</span></code> can operate in three modes:</p>
<blockquote>
<div><ul class="simple">
<li><p>Software crypto mode (<code class="docutils literal notranslate"><span class="pre">TLS_SW</span></code>) - CPU handles the cryptography.
In most basic cases only crypto operations synchronous with the CPU
can be used, but depending on calling context CPU may utilize
asynchronous crypto accelerators. The use of accelerators introduces extra
latency on socket reads (decryption only starts when a read syscall
is made) and additional I/O load on the system.</p></li>
<li><p>Packet-based NIC offload mode (<code class="docutils literal notranslate"><span class="pre">TLS_HW</span></code>) - the NIC handles crypto
on a packet by packet basis, provided the packets arrive in order.
This mode integrates best with the kernel stack and is described in detail
in the remaining part of this document
(<code class="docutils literal notranslate"><span class="pre">ethtool</span></code> flags <code class="docutils literal notranslate"><span class="pre">tls-hw-tx-offload</span></code> and <code class="docutils literal notranslate"><span class="pre">tls-hw-rx-offload</span></code>).</p></li>
<li><p>Full TCP NIC offload mode (<code class="docutils literal notranslate"><span class="pre">TLS_HW_RECORD</span></code>) - mode of operation where
NIC driver and firmware replace the kernel networking stack
with its own TCP handling, it is not usable in production environments
making use of the Linux networking stack for example any firewalling
abilities or QoS and packet scheduling (<code class="docutils literal notranslate"><span class="pre">ethtool</span></code> flag <code class="docutils literal notranslate"><span class="pre">tls-hw-record</span></code>).</p></li>
</ul>
</div></blockquote>
<p>The operation mode is selected automatically based on device configuration,
offload opt-in or opt-out on per-connection basis is not currently supported.</p>
<section id="tx">
<h3>TX<a class="headerlink" href="#tx" title="Permalink to this headline">¶</a></h3>
<p>At a high level user write requests are turned into a scatter list, the TLS ULP
intercepts them, inserts record framing, performs encryption (in <code class="docutils literal notranslate"><span class="pre">TLS_SW</span></code>
mode) and then hands the modified scatter list to the TCP layer. From this
point on the TCP stack proceeds as normal.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">TLS_HW</span></code> mode the encryption is not performed in the TLS ULP.
Instead packets reach a device driver, the driver will mark the packets
for crypto offload based on the socket the packet is attached to,
and send them to the device for encryption and transmission.</p>
</section>
<section id="rx">
<h3>RX<a class="headerlink" href="#rx" title="Permalink to this headline">¶</a></h3>
<p>On the receive side if the device handled decryption and authentication
successfully, the driver will set the decrypted bit in the associated
<a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span></code></a>. The packets reach the TCP stack and
are handled normally. <code class="docutils literal notranslate"><span class="pre">ktls</span></code> is informed when data is queued to the socket
and the <code class="docutils literal notranslate"><span class="pre">strparser</span></code> mechanism is used to delineate the records. Upon read
request, records are retrieved from the socket and passed to decryption routine.
If device decrypted all the segments of the record the decryption is skipped,
otherwise software path handles decryption.</p>
<figure class="align-center" id="id9" style="width: 28em">
<img alt="TLS offload layers" src="../_images/tls-offload-layers.svg" /><figcaption>
<p><span class="caption-text">Layers of Kernel TLS stack</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="device-configuration">
<h2>Device configuration<a class="headerlink" href="#device-configuration" title="Permalink to this headline">¶</a></h2>
<p>During driver initialization device sets the <code class="docutils literal notranslate"><span class="pre">NETIF_F_HW_TLS_RX</span></code> and
<code class="docutils literal notranslate"><span class="pre">NETIF_F_HW_TLS_TX</span></code> features and installs its
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tlsdev_ops</span></code>
pointer in the <code class="xref c c-member docutils literal notranslate"><span class="pre">tlsdev_ops</span></code> member of the
<a class="reference internal" href="kapi.html#c.net_device" title="net_device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span></code></a>.</p>
<p>When TLS cryptographic connection state is installed on a <code class="docutils literal notranslate"><span class="pre">ktls</span></code> socket
(note that it is done twice, once for RX and once for TX direction,
and the two are completely independent), the kernel checks if the underlying
network device is offload-capable and attempts the offload. In case offload
fails the connection is handled entirely in software using the same mechanism
as if the offload was never tried.</p>
<p>Offload request is performed via the <code class="xref c c-member docutils literal notranslate"><span class="pre">tls_dev_add</span></code> callback of
<code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">tlsdev_ops</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">tls_dev_add</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">net_device</span><span class="w"> </span><span class="o">*</span><span class="n">netdev</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="k">enum</span><span class="w"> </span><span class="n">tls_offload_ctx_dir</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="k">struct</span> <span class="nc">tls_crypto_info</span><span class="w"> </span><span class="o">*</span><span class="n">crypto_info</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="n">u32</span><span class="w"> </span><span class="n">start_offload_tcp_sn</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">direction</span></code> indicates whether the cryptographic information is for
the received or transmitted packets. Driver uses the <code class="docutils literal notranslate"><span class="pre">sk</span></code> parameter
to retrieve the connection 5-tuple and socket family (IPv4 vs IPv6).
Cryptographic information in <code class="docutils literal notranslate"><span class="pre">crypto_info</span></code> includes the key, iv, salt
as well as TLS record sequence number. <code class="docutils literal notranslate"><span class="pre">start_offload_tcp_sn</span></code> indicates
which TCP sequence number corresponds to the beginning of the record with
sequence number from <code class="docutils literal notranslate"><span class="pre">crypto_info</span></code>. The driver can add its state
at the end of kernel structures (see <code class="xref c c-member docutils literal notranslate"><span class="pre">driver_state</span></code> members
in <code class="docutils literal notranslate"><span class="pre">include/net/tls.h</span></code>) to avoid additional allocations and pointer
dereferences.</p>
<section id="id1">
<h3>TX<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>After TX state is installed, the stack guarantees that the first segment
of the stream will start exactly at the <code class="docutils literal notranslate"><span class="pre">start_offload_tcp_sn</span></code> sequence
number, simplifying TCP sequence number matching.</p>
<p>TX offload being fully initialized does not imply that all segments passing
through the driver and which belong to the offloaded socket will be after
the expected sequence number and will have kernel record information.
In particular, already encrypted data may have been queued to the socket
before installing the connection state in the kernel.</p>
</section>
<section id="id2">
<h3>RX<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>In RX direction local networking stack has little control over the segmentation,
so the initial records’ TCP sequence number may be anywhere inside the segment.</p>
</section>
</section>
<section id="normal-operation">
<h2>Normal operation<a class="headerlink" href="#normal-operation" title="Permalink to this headline">¶</a></h2>
<p>At the minimum the device maintains the following state for each connection, in
each direction:</p>
<blockquote>
<div><ul class="simple">
<li><p>crypto secrets (key, iv, salt)</p></li>
<li><p>crypto processing state (partial blocks, partial authentication tag, etc.)</p></li>
<li><p>record metadata (sequence number, processing offset and length)</p></li>
<li><p>expected TCP sequence number</p></li>
</ul>
</div></blockquote>
<p>There are no guarantees on record length or record segmentation. In particular
segments may start at any point of a record and contain any number of records.
Assuming segments are received in order, the device should be able to perform
crypto operations and authentication regardless of segmentation. For this
to be possible device has to keep small amount of segment-to-segment state.
This includes at least:</p>
<blockquote>
<div><ul class="simple">
<li><p>partial headers (if a segment carried only a part of the TLS header)</p></li>
<li><p>partial data block</p></li>
<li><p>partial authentication tag (all data had been seen but part of the
authentication tag has to be written or read from the subsequent segment)</p></li>
</ul>
</div></blockquote>
<p>Record reassembly is not necessary for TLS offload. If the packets arrive
in order the device should be able to handle them separately and make
forward progress.</p>
<section id="id3">
<h3>TX<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>The kernel stack performs record framing reserving space for the authentication
tag and populating all other TLS header and tailer fields.</p>
<p>Both the device and the driver maintain expected TCP sequence numbers
due to the possibility of retransmissions and the lack of software fallback
once the packet reaches the device.
For segments passed in order, the driver marks the packets with
a connection identifier (note that a 5-tuple lookup is insufficient to identify
packets requiring HW offload, see the <a class="reference internal" href="#tuple-problems"><span class="std std-ref">5-tuple matching limitations</span></a> section)
and hands them to the device. The device identifies the packet as requiring
TLS handling and confirms the sequence number matches its expectation.
The device performs encryption and authentication of the record data.
It replaces the authentication tag and TCP checksum with correct values.</p>
</section>
<section id="id4">
<h3>RX<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Before a packet is DMAed to the host (but after NIC’s embedded switching
and packet transformation functions) the device validates the Layer 4
checksum and performs a 5-tuple lookup to find any TLS connection the packet
may belong to (technically a 4-tuple
lookup is sufficient - IP addresses and TCP port numbers, as the protocol
is always TCP). If connection is matched device confirms if the TCP sequence
number is the expected one and proceeds to TLS handling (record delineation,
decryption, authentication for each record in the packet). The device leaves
the record framing unmodified, the stack takes care of record decapsulation.
Device indicates successful handling of TLS offload in the per-packet context
(descriptor) passed to the host.</p>
<p>Upon reception of a TLS offloaded packet, the driver sets
the <code class="xref c c-member docutils literal notranslate"><span class="pre">decrypted</span></code> mark in <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span></code></a>
corresponding to the segment. Networking stack makes sure decrypted
and non-decrypted segments do not get coalesced (e.g. by GRO or socket layer)
and takes care of partial decryption.</p>
</section>
</section>
<section id="resync-handling">
<h2>Resync handling<a class="headerlink" href="#resync-handling" title="Permalink to this headline">¶</a></h2>
<p>In presence of packet drops or network packet reordering, the device may lose
synchronization with the TLS stream, and require a resync with the kernel’s
TCP stack.</p>
<p>Note that resync is only attempted for connections which were successfully
added to the device table and are in TLS_HW mode. For example,
if the table was full when cryptographic state was installed in the kernel,
such connection will never get offloaded. Therefore the resync request
does not carry any cryptographic connection state.</p>
<section id="id5">
<h3>TX<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>Segments transmitted from an offloaded socket can get out of sync
in similar ways to the receive side-retransmissions - local drops
are possible, though network reorders are not. There are currently
two mechanisms for dealing with out of order segments.</p>
<section id="crypto-state-rebuilding">
<h4>Crypto state rebuilding<a class="headerlink" href="#crypto-state-rebuilding" title="Permalink to this headline">¶</a></h4>
<p>Whenever an out of order segment is transmitted the driver provides
the device with enough information to perform cryptographic operations.
This means most likely that the part of the record preceding the current
segment has to be passed to the device as part of the packet context,
together with its TCP sequence number and TLS record number. The device
can then initialize its crypto state, process and discard the preceding
data (to be able to insert the authentication tag) and move onto handling
the actual packet.</p>
<p>In this mode depending on the implementation the driver can either ask
for a continuation with the crypto state and the new sequence number
(next expected segment is the one after the out of order one), or continue
with the previous stream state - assuming that the out of order segment
was just a retransmission. The former is simpler, and does not require
retransmission detection therefore it is the recommended method until
such time it is proven inefficient.</p>
</section>
<section id="next-record-sync">
<h4>Next record sync<a class="headerlink" href="#next-record-sync" title="Permalink to this headline">¶</a></h4>
<p>Whenever an out of order segment is detected the driver requests
that the <code class="docutils literal notranslate"><span class="pre">ktls</span></code> software fallback code encrypt it. If the segment’s
sequence number is lower than expected the driver assumes retransmission
and doesn’t change device state. If the segment is in the future, it
may imply a local drop, the driver asks the stack to sync the device
to the next record state and falls back to software.</p>
<p>Resync request is indicated with:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">tls_offload_tx_resync_request</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="n">got_seq</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="n">exp_seq</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Until resync is complete driver should not access its expected TCP
sequence number (as it will be updated from a different context).
Following helper should be used to test if resync is complete:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">tls_offload_tx_resync_pending</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sock</span><span class="w"> </span><span class="o">*</span><span class="n">sk</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Next time <code class="docutils literal notranslate"><span class="pre">ktls</span></code> pushes a record it will first send its TCP sequence number
and TLS record number to the driver. Stack will also make sure that
the new record will start on a segment boundary (like it does when
the connection is initially added).</p>
</section>
</section>
<section id="id6">
<h3>RX<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>A small amount of RX reorder events may not require a full resynchronization.
In particular the device should not lose synchronization
when record boundary can be recovered:</p>
<figure class="align-center" id="id10">
<img alt="reorder of non-header segment" src="../_images/tls-offload-reorder-good.svg" /><figcaption>
<p><span class="caption-text">Reorder of non-header segment</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Green segments are successfully decrypted, blue ones are passed
as received on wire, red stripes mark start of new records.</p>
<p>In above case segment 1 is received and decrypted successfully.
Segment 2 was dropped so 3 arrives out of order. The device knows
the next record starts inside 3, based on record length in segment 1.
Segment 3 is passed untouched, because due to lack of data from segment 2
the remainder of the previous record inside segment 3 cannot be handled.
The device can, however, collect the authentication algorithm’s state
and partial block from the new record in segment 3 and when 4 and 5
arrive continue decryption. Finally when 2 arrives it’s completely outside
of expected window of the device so it’s passed as is without special
handling. <code class="docutils literal notranslate"><span class="pre">ktls</span></code> software fallback handles the decryption of record
spanning segments 1, 2 and 3. The device did not get out of sync,
even though two segments did not get decrypted.</p>
<p>Kernel synchronization may be necessary if the lost segment contained
a record header and arrived after the next record header has already passed:</p>
<figure class="align-center" id="id11">
<img alt="reorder of header segment" src="../_images/tls-offload-reorder-bad.svg" /><figcaption>
<p><span class="caption-text">Reorder of segment with a TLS header</span><a class="headerlink" href="#id11" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>In this example segment 2 gets dropped, and it contains a record header.
Device can only detect that segment 4 also contains a TLS header
if it knows the length of the previous record from segment 2. In this case
the device will lose synchronization with the stream.</p>
<section id="stream-scan-resynchronization">
<h4>Stream scan resynchronization<a class="headerlink" href="#stream-scan-resynchronization" title="Permalink to this headline">¶</a></h4>
<p>When the device gets out of sync and the stream reaches TCP sequence
numbers more than a max size record past the expected TCP sequence number,
the device starts scanning for a known header pattern. For example
for TLS 1.2 and TLS 1.3 subsequent bytes of value <code class="docutils literal notranslate"><span class="pre">0x03</span> <span class="pre">0x03</span></code> occur
in the SSL/TLS version field of the header. Once pattern is matched
the device continues attempting parsing headers at expected locations
(based on the length fields at guessed locations).
Whenever the expected location does not contain a valid header the scan
is restarted.</p>
<p>When the header is matched the device sends a confirmation request
to the kernel, asking if the guessed location is correct (if a TLS record
really starts there), and which record sequence number the given header had.
The kernel confirms the guessed location was correct and tells the device
the record sequence number. Meanwhile, the device had been parsing
and counting all records since the just-confirmed one, it adds the number
of records it had seen to the record number provided by the kernel.
At this point the device is in sync and can resume decryption at next
segment boundary.</p>
<p>In a pathological case the device may latch onto a sequence of matching
headers and never hear back from the kernel (there is no negative
confirmation from the kernel). The implementation may choose to periodically
restart scan. Given how unlikely falsely-matching stream is, however,
periodic restart is not deemed necessary.</p>
<p>Special care has to be taken if the confirmation request is passed
asynchronously to the packet stream and record may get processed
by the kernel before the confirmation request.</p>
</section>
<section id="stack-driven-resynchronization">
<h4>Stack-driven resynchronization<a class="headerlink" href="#stack-driven-resynchronization" title="Permalink to this headline">¶</a></h4>
<p>The driver may also request the stack to perform resynchronization
whenever it sees the records are no longer getting decrypted.
If the connection is configured in this mode the stack automatically
schedules resynchronization after it has received two completely encrypted
records.</p>
<p>The stack waits for the socket to drain and informs the device about
the next expected record number and its TCP sequence number. If the
records continue to be received fully encrypted stack retries the
synchronization with an exponential back off (first after 2 encrypted
records, then after 4 records, after 8, after 16… up until every
128 records).</p>
</section>
</section>
</section>
<section id="error-handling">
<h2>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h2>
<section id="id7">
<h3>TX<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Packets may be redirected or rerouted by the stack to a different
device than the selected TLS offload device. The stack will handle
such condition using the <code class="xref c c-func docutils literal notranslate"><span class="pre">sk_validate_xmit_skb()</span></code> helper
(TLS offload code installs <code class="xref c c-func docutils literal notranslate"><span class="pre">tls_validate_xmit_skb()</span></code> at this hook).
Offload maintains information about all records until the data is
fully acknowledged, so if skbs reach the wrong device they can be handled
by software fallback.</p>
<p>Any device TLS offload handling error on the transmission side must result
in the packet being dropped. For example if a packet got out of order
due to a bug in the stack or the device, reached the device and can’t
be encrypted such packet must be dropped.</p>
</section>
<section id="id8">
<h3>RX<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>If the device encounters any problems with TLS offload on the receive
side it should pass the packet to the host’s networking stack as it was
received on the wire.</p>
<p>For example authentication failure for any record in the segment should
result in passing the unmodified packet to the software fallback. This means
packets should not be modified “in place”. Splitting segments to handle partial
decryption is not advised. In other words either all records in the packet
had been handled successfully and authenticated or the packet has to be passed
to the host’s stack as it was on the wire (recovering original packet in the
driver if device provides precise error is sufficient).</p>
<p>The Linux networking stack does not provide a way of reporting per-packet
decryption and authentication errors, packets with errors must simply not
have the <code class="xref c c-member docutils literal notranslate"><span class="pre">decrypted</span></code> mark set.</p>
<p>A packet should also not be handled by the TLS offload if it contains
incorrect checksums.</p>
</section>
</section>
<section id="performance-metrics">
<h2>Performance metrics<a class="headerlink" href="#performance-metrics" title="Permalink to this headline">¶</a></h2>
<p>TLS offload can be characterized by the following basic metrics:</p>
<blockquote>
<div><ul class="simple">
<li><p>max connection count</p></li>
<li><p>connection installation rate</p></li>
<li><p>connection installation latency</p></li>
<li><p>total cryptographic performance</p></li>
</ul>
</div></blockquote>
<p>Note that each TCP connection requires a TLS session in both directions,
the performance may be reported treating each direction separately.</p>
<section id="max-connection-count">
<h3>Max connection count<a class="headerlink" href="#max-connection-count" title="Permalink to this headline">¶</a></h3>
<p>The number of connections device can support can be exposed via
<code class="docutils literal notranslate"><span class="pre">devlink</span> <span class="pre">resource</span></code> API.</p>
</section>
<section id="total-cryptographic-performance">
<h3>Total cryptographic performance<a class="headerlink" href="#total-cryptographic-performance" title="Permalink to this headline">¶</a></h3>
<p>Offload performance may depend on segment and record size.</p>
<p>Overload of the cryptographic subsystem of the device should not have
significant performance impact on non-offloaded streams.</p>
</section>
</section>
<section id="statistics">
<h2>Statistics<a class="headerlink" href="#statistics" title="Permalink to this headline">¶</a></h2>
<p>Following minimum set of TLS-related statistics should be reported
by the driver:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rx_tls_decrypted_packets</span></code> - number of successfully decrypted RX packets
which were part of a TLS stream.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rx_tls_decrypted_bytes</span></code> - number of TLS payload bytes in RX packets
which were successfully decrypted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rx_tls_ctx</span></code> - number of TLS RX HW offload contexts added to device for
decryption.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rx_tls_del</span></code> - number of TLS RX HW offload contexts deleted from device
(connection has finished).</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rx_tls_resync_req_pkt</span></code> - number of received TLS packets with a resync</dt><dd><p>request.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rx_tls_resync_req_start</span></code> - number of times the TLS async resync request</dt><dd><p>was started.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rx_tls_resync_req_end</span></code> - number of times the TLS async resync request</dt><dd><p>properly ended with providing the HW tracked tcp-seq.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rx_tls_resync_req_skip</span></code> - number of times the TLS async resync request</dt><dd><p>procedure was started by not properly ended.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rx_tls_resync_res_ok</span></code> - number of times the TLS resync response call to</dt><dd><p>the driver was successfully handled.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">rx_tls_resync_res_skip</span></code> - number of times the TLS resync response call to</dt><dd><p>the driver was terminated unsuccessfully.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">rx_tls_err</span></code> - number of RX packets which were part of a TLS stream
but were not decrypted due to unexpected error in the state machine.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx_tls_encrypted_packets</span></code> - number of TX packets passed to the device
for encryption of their TLS payload.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx_tls_encrypted_bytes</span></code> - number of TLS payload bytes in TX packets
passed to the device for encryption.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx_tls_ctx</span></code> - number of TLS TX HW offload contexts added to device for
encryption.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx_tls_ooo</span></code> - number of TX packets which were part of a TLS stream
but did not arrive in the expected order.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx_tls_skip_no_sync_data</span></code> - number of TX packets which were part of
a TLS stream and arrived out-of-order, but skipped the HW offload routine
and went to the regular transmit flow as they were retransmissions of the
connection handshake.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx_tls_drop_no_sync_data</span></code> - number of TX packets which were part of
a TLS stream dropped, because they arrived out of order and associated
record could not be found.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx_tls_drop_bypass_req</span></code> - number of TX packets which were part of a TLS
stream dropped, because they contain both data that has been encrypted by
software and data that expects hardware crypto offload.</p></li>
</ul>
</div></blockquote>
</section>
<section id="notable-corner-cases-exceptions-and-additional-requirements">
<h2>Notable corner cases, exceptions and additional requirements<a class="headerlink" href="#notable-corner-cases-exceptions-and-additional-requirements" title="Permalink to this headline">¶</a></h2>
<section id="tuple-matching-limitations">
<span id="tuple-problems"></span><h3>5-tuple matching limitations<a class="headerlink" href="#tuple-matching-limitations" title="Permalink to this headline">¶</a></h3>
<p>The device can only recognize received packets based on the 5-tuple
of the socket. Current <code class="docutils literal notranslate"><span class="pre">ktls</span></code> implementation will not offload sockets
routed through software interfaces such as those used for tunneling
or virtual networking. However, many packet transformations performed
by the networking stack (most notably any BPF logic) do not require
any intermediate software device, therefore a 5-tuple match may
consistently miss at the device level. In such cases the device
should still be able to perform TX offload (encryption) and should
fallback cleanly to software decryption (RX).</p>
</section>
<section id="out-of-order">
<h3>Out of order<a class="headerlink" href="#out-of-order" title="Permalink to this headline">¶</a></h3>
<p>Introducing extra processing in NICs should not cause packets to be
transmitted or received out of order, for example pure ACK packets
should not be reordered with respect to data segments.</p>
</section>
<section id="ingress-reorder">
<h3>Ingress reorder<a class="headerlink" href="#ingress-reorder" title="Permalink to this headline">¶</a></h3>
<p>A device is permitted to perform packet reordering for consecutive
TCP segments (i.e. placing packets in the correct order) but any form
of additional buffering is disallowed.</p>
</section>
<section id="coexistence-with-standard-networking-offload-features">
<h3>Coexistence with standard networking offload features<a class="headerlink" href="#coexistence-with-standard-networking-offload-features" title="Permalink to this headline">¶</a></h3>
<p>Offloaded <code class="docutils literal notranslate"><span class="pre">ktls</span></code> sockets should support standard TCP stack features
transparently. Enabling device TLS offload should not cause any difference
in packets as seen on the wire.</p>
</section>
<section id="transport-layer-transparency">
<h3>Transport layer transparency<a class="headerlink" href="#transport-layer-transparency" title="Permalink to this headline">¶</a></h3>
<p>The device should not modify any packet headers for the purpose
of the simplifying TLS offload.</p>
<p>The device should not depend on any packet headers beyond what is strictly
necessary for TLS offload.</p>
</section>
<section id="segment-drops">
<h3>Segment drops<a class="headerlink" href="#segment-drops" title="Permalink to this headline">¶</a></h3>
<p>Dropping packets is acceptable only in the event of catastrophic
system errors and should never be used as an error handling mechanism
in cases arising from normal operation. In other words, reliance
on TCP retransmissions to handle corner cases is not acceptable.</p>
</section>
<section id="tls-device-features">
<h3>TLS device features<a class="headerlink" href="#tls-device-features" title="Permalink to this headline">¶</a></h3>
<p>Drivers should ignore the changes to the TLS device feature flags.
These flags will be acted upon accordingly by the core <code class="docutils literal notranslate"><span class="pre">ktls</span></code> code.
TLS device feature flags only control adding of new TLS connection
offloads, old connections will remain active after flags are cleared.</p>
<p>TLS encryption cannot be offloaded to devices without checksum calculation
offload. Hence, TLS TX device feature flag requires TX csum offload being set.
Disabling the latter implies clearing the former. Disabling TX checksum offload
should not affect old connections, and drivers should make sure checksum
calculation does not break for them.
Similarly, device-offloaded TLS decryption implies doing RXCSUM. If the user
does not want to enable RX csum offload, TLS RX device feature is disabled
as well.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Kernel TLS offload</a><ul>
<li><a class="reference internal" href="#kernel-tls-operation">Kernel TLS operation</a><ul>
<li><a class="reference internal" href="#tx">TX</a></li>
<li><a class="reference internal" href="#rx">RX</a></li>
</ul>
</li>
<li><a class="reference internal" href="#device-configuration">Device configuration</a><ul>
<li><a class="reference internal" href="#id1">TX</a></li>
<li><a class="reference internal" href="#id2">RX</a></li>
</ul>
</li>
<li><a class="reference internal" href="#normal-operation">Normal operation</a><ul>
<li><a class="reference internal" href="#id3">TX</a></li>
<li><a class="reference internal" href="#id4">RX</a></li>
</ul>
</li>
<li><a class="reference internal" href="#resync-handling">Resync handling</a><ul>
<li><a class="reference internal" href="#id5">TX</a><ul>
<li><a class="reference internal" href="#crypto-state-rebuilding">Crypto state rebuilding</a></li>
<li><a class="reference internal" href="#next-record-sync">Next record sync</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6">RX</a><ul>
<li><a class="reference internal" href="#stream-scan-resynchronization">Stream scan resynchronization</a></li>
<li><a class="reference internal" href="#stack-driven-resynchronization">Stack-driven resynchronization</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#error-handling">Error handling</a><ul>
<li><a class="reference internal" href="#id7">TX</a></li>
<li><a class="reference internal" href="#id8">RX</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performance-metrics">Performance metrics</a><ul>
<li><a class="reference internal" href="#max-connection-count">Max connection count</a></li>
<li><a class="reference internal" href="#total-cryptographic-performance">Total cryptographic performance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#statistics">Statistics</a></li>
<li><a class="reference internal" href="#notable-corner-cases-exceptions-and-additional-requirements">Notable corner cases, exceptions and additional requirements</a><ul>
<li><a class="reference internal" href="#tuple-matching-limitations">5-tuple matching limitations</a></li>
<li><a class="reference internal" href="#out-of-order">Out of order</a></li>
<li><a class="reference internal" href="#ingress-reorder">Ingress reorder</a></li>
<li><a class="reference internal" href="#coexistence-with-standard-networking-offload-features">Coexistence with standard networking offload features</a></li>
<li><a class="reference internal" href="#transport-layer-transparency">Transport layer transparency</a></li>
<li><a class="reference internal" href="#segment-drops">Segment drops</a></li>
<li><a class="reference internal" href="#tls-device-features">TLS device features</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/networking/tls-offload.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/networking/tls-offload.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>