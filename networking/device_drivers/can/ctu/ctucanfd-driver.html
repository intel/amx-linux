
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>CTU CAN FD Driver &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Flexcan CAN Controller driver" href="../freescale/flexcan.html" />
    <link rel="prev" title="can327: ELM327 driver for Linux SocketCAN" href="../can327.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="ctu-can-fd-driver">
<h1>CTU CAN FD Driver<a class="headerlink" href="#ctu-can-fd-driver" title="Permalink to this headline">¶</a></h1>
<p>Author: Martin Jerabek &lt;<a class="reference external" href="mailto:martin&#46;jerabek01&#37;&#52;&#48;gmail&#46;com">martin<span>&#46;</span>jerabek01<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<section id="about-ctu-can-fd-ip-core">
<h2>About CTU CAN FD IP Core<a class="headerlink" href="#about-ctu-can-fd-ip-core" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://gitlab.fel.cvut.cz/canbus/ctucanfd_ip_core">CTU CAN FD</a>
is an open source soft core written in VHDL.
It originated in 2015 as Ondrej Ille’s project
at the <a class="reference external" href="https://meas.fel.cvut.cz/">Department of Measurement</a>
of <a class="reference external" href="http://www.fel.cvut.cz/en/">FEE</a> at <a class="reference external" href="https://www.cvut.cz/en">CTU</a>.</p>
<p>The SocketCAN driver for Xilinx Zynq SoC based MicroZed board
<a class="reference external" href="https://gitlab.fel.cvut.cz/canbus/zynq/zynq-can-sja1000-top">Vivado integration</a>
and Intel Cyclone V 5CSEMA4U23C6 based DE0-Nano-SoC Terasic board
<a class="reference external" href="https://gitlab.fel.cvut.cz/canbus/intel-soc-ctucanfd">QSys integration</a>
has been developed as well as support for
<a class="reference external" href="https://gitlab.fel.cvut.cz/canbus/pcie-ctucanfd">PCIe integration</a> of the core.</p>
<p>In the case of Zynq, the core is connected via the APB system bus, which does
not have enumeration support, and the device must be specified in Device Tree.
This kind of devices is called platform device in the kernel and is
handled by a platform device driver.</p>
<p>The basic functional model of the CTU CAN FD peripheral has been
accepted into QEMU mainline. See QEMU <a class="reference external" href="https://www.qemu.org/docs/master/system/devices/can.html">CAN emulation support</a>
for CAN FD buses, host connection and CTU CAN FD core emulation. The development
version of emulation support can be cloned from ctu-canfd branch of QEMU local
development <a class="reference external" href="https://gitlab.fel.cvut.cz/canbus/qemu-canbus">repository</a>.</p>
</section>
<section id="about-socketcan">
<h2>About SocketCAN<a class="headerlink" href="#about-socketcan" title="Permalink to this headline">¶</a></h2>
<p>SocketCAN is a standard common interface for CAN devices in the Linux
kernel. As the name suggests, the bus is accessed via sockets, similarly
to common network devices. The reasoning behind this is in depth
described in <a class="reference external" href="https://www.kernel.org/doc/html/latest/networking/can.html">Linux SocketCAN</a>.
In short, it offers a
natural way to implement and work with higher layer protocols over CAN,
in the same way as, e.g., UDP/IP over Ethernet.</p>
<section id="device-probe">
<h3>Device probe<a class="headerlink" href="#device-probe" title="Permalink to this headline">¶</a></h3>
<p>Before going into detail about the structure of a CAN bus device driver,
let’s reiterate how the kernel gets to know about the device at all.
Some buses, like PCI or PCIe, support device enumeration. That is, when
the system boots, it discovers all the devices on the bus and reads
their configuration. The kernel identifies the device via its vendor ID
and device ID, and if there is a driver registered for this identifier
combination, its probe method is invoked to populate the driver’s
instance for the given hardware. A similar situation goes with USB, only
it allows for device hot-plug.</p>
<p>The situation is different for peripherals which are directly embedded
in the SoC and connected to an internal system bus (AXI, APB, Avalon,
and others). These buses do not support enumeration, and thus the kernel
has to learn about the devices from elsewhere. This is exactly what the
Device Tree was made for.</p>
</section>
<section id="device-tree">
<h3>Device tree<a class="headerlink" href="#device-tree" title="Permalink to this headline">¶</a></h3>
<p>An entry in device tree states that a device exists in the system, how
it is reachable (on which bus it resides) and its configuration –
registers address, interrupts and so on. An example of such a device
tree is given in .</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/ {
    /* ... */
    amba: amba {
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;1&gt;;
        compatible = &quot;simple-bus&quot;;

        CTU_CAN_FD_0: CTU_CAN_FD@43c30000 {
            compatible = &quot;ctu,ctucanfd&quot;;
            interrupt-parent = &lt;&amp;intc&gt;;
            interrupts = &lt;0 30 4&gt;;
            clocks = &lt;&amp;clkc 15&gt;;
            reg = &lt;0x43c30000 0x10000&gt;;
        };
    };
};
</pre></div>
</div>
</section>
<section id="driver-structure">
<span id="sec-socketcan-drv"></span><h3>Driver structure<a class="headerlink" href="#driver-structure" title="Permalink to this headline">¶</a></h3>
<p>The driver can be divided into two parts – platform-dependent device
discovery and set up, and platform-independent CAN network device
implementation.</p>
<section id="platform-device-driver">
<span id="sec-socketcan-platdev"></span><h4>Platform device driver<a class="headerlink" href="#platform-device-driver" title="Permalink to this headline">¶</a></h4>
<p>In the case of Zynq, the core is connected via the AXI system bus, which
does not have enumeration support, and the device must be specified in
Device Tree. This kind of devices is called <em>platform device</em> in the
kernel and is handled by a <em>platform device driver</em> <a class="footnote-reference brackets" href="#id11" id="id1">1</a>.</p>
<p>A platform device driver provides the following things:</p>
<ul class="simple">
<li><p>A <em>probe</em> function</p></li>
<li><p>A <em>remove</em> function</p></li>
<li><p>A table of <em>compatible</em> devices that the driver can handle</p></li>
</ul>
<p>The <em>probe</em> function is called exactly once when the device appears (or
the driver is loaded, whichever happens later). If there are more
devices handled by the same driver, the <em>probe</em> function is called for
each one of them. Its role is to allocate and initialize resources
required for handling the device, as well as set up low-level functions
for the platform-independent layer, e.g., <em>read_reg</em> and <em>write_reg</em>.
After that, the driver registers the device to a higher layer, in our
case as a <em>network device</em>.</p>
<p>The <em>remove</em> function is called when the device disappears, or the
driver is about to be unloaded. It serves to free the resources
allocated in <em>probe</em> and to unregister the device from higher layers.</p>
<p>Finally, the table of <em>compatible</em> devices states which devices the
driver can handle. The Device Tree entry <code class="docutils literal notranslate"><span class="pre">compatible</span></code> is matched
against the tables of all <em>platform drivers</em>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Match table for OF platform binding */</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span> <span class="nc">of_device_id</span><span class="w"> </span><span class="n">ctucan_of_match</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ctu,canfd-2&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ctu,ctucanfd&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="cm">/* end of list */</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span><span class="w"> </span><span class="n">ctucan_of_match</span><span class="p">);</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ctucan_probe</span><span class="p">(</span><span class="k">struct</span> <span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">);</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ctucan_remove</span><span class="p">(</span><span class="k">struct</span> <span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">);</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">platform_driver</span><span class="w"> </span><span class="n">ctucanfd_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">probe</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">ctucan_probe</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctucan_remove</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DRIVER_NAME</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">of_match_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctucan_of_match</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">ctucanfd_driver</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="network-device-driver">
<span id="sec-socketcan-netdev"></span><h4>Network device driver<a class="headerlink" href="#network-device-driver" title="Permalink to this headline">¶</a></h4>
<p>Each network device must support at least these operations:</p>
<ul class="simple">
<li><p>Bring the device up: <code class="docutils literal notranslate"><span class="pre">ndo_open</span></code></p></li>
<li><p>Bring the device down: <code class="docutils literal notranslate"><span class="pre">ndo_close</span></code></p></li>
<li><p>Submit TX frames to the device: <code class="docutils literal notranslate"><span class="pre">ndo_start_xmit</span></code></p></li>
<li><p>Signal TX completion and errors to the network subsystem: ISR</p></li>
<li><p>Submit RX frames to the network subsystem: ISR and NAPI</p></li>
</ul>
<p>There are two possible event sources: the device and the network
subsystem. Device events are usually signaled via an interrupt, handled
in an Interrupt Service Routine (ISR). Handlers for the events
originating in the network subsystem are then specified in
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device_ops</span></code>.</p>
<p>When the device is brought up, e.g., by calling <code class="docutils literal notranslate"><span class="pre">ip</span> <span class="pre">link</span> <span class="pre">set</span> <span class="pre">can0</span> <span class="pre">up</span></code>,
the driver’s function <code class="docutils literal notranslate"><span class="pre">ndo_open</span></code> is called. It should validate the
interface configuration and configure and enable the device. The
analogous opposite is <code class="docutils literal notranslate"><span class="pre">ndo_close</span></code>, called when the device is being
brought down, be it explicitly or implicitly.</p>
<p>When the system should transmit a frame, it does so by calling
<code class="docutils literal notranslate"><span class="pre">ndo_start_xmit</span></code>, which enqueues the frame into the device. If the
device HW queue (FIFO, mailboxes or whatever the implementation is)
becomes full, the <code class="docutils literal notranslate"><span class="pre">ndo_start_xmit</span></code> implementation informs the network
subsystem that it should stop the TX queue (via <code class="docutils literal notranslate"><span class="pre">netif_stop_queue</span></code>).
It is then re-enabled later in ISR when the device has some space
available again and is able to enqueue another frame.</p>
<p>All the device events are handled in ISR, namely:</p>
<ol class="arabic simple">
<li><p><strong>TX completion</strong>. When the device successfully finishes transmitting
a frame, the frame is echoed locally. On error, an informative error
frame <a class="footnote-reference brackets" href="#id12" id="id2">2</a> is sent to the network subsystem instead. In both cases,
the software TX queue is resumed so that more frames may be sent.</p></li>
<li><p><strong>Error condition</strong>. If something goes wrong (e.g., the device goes
bus-off or RX overrun happens), error counters are updated, and
informative error frames are enqueued to SW RX queue.</p></li>
<li><p><strong>RX buffer not empty</strong>. In this case, read the RX frames and enqueue
them to SW RX queue. Usually NAPI is used as a middle layer (see ).</p></li>
</ol>
</section>
</section>
<section id="napi">
<span id="sec-socketcan-napi"></span><h3>NAPI<a class="headerlink" href="#napi" title="Permalink to this headline">¶</a></h3>
<p>The frequency of incoming frames can be high and the overhead to invoke
the interrupt service routine for each frame can cause significant
system load. There are multiple mechanisms in the Linux kernel to deal
with this situation. They evolved over the years of Linux kernel
development and enhancements. For network devices, the current standard
is NAPI – <em>the New API</em>. It is similar to classical top-half/bottom-half
interrupt handling in that it only acknowledges the interrupt in the ISR
and signals that the rest of the processing should be done in softirq
context. On top of that, it offers the possibility to <em>poll</em> for new
frames for a while. This has a potential to avoid the costly round of
enabling interrupts, handling an incoming IRQ in ISR, re-enabling the
softirq and switching context back to softirq.</p>
<p>More detailed documentation of NAPI may be found on the pages of Linux
Foundation <a class="reference external" href="https://wiki.linuxfoundation.org/networking/napi">https://wiki.linuxfoundation.org/networking/napi</a>.</p>
</section>
</section>
<section id="integrating-the-core-to-xilinx-zynq">
<h2>Integrating the core to Xilinx Zynq<a class="headerlink" href="#integrating-the-core-to-xilinx-zynq" title="Permalink to this headline">¶</a></h2>
<p>The core interfaces a simple subset of the Avalon
(search for Intel <strong>Avalon Interface Specifications</strong>)
bus as it was originally used on
Alterra FPGA chips, yet Xilinx natively interfaces with AXI
(search for ARM <strong>AMBA AXI and ACE Protocol Specification AXI3,
AXI4, and AXI4-Lite, ACE and ACE-Lite</strong>).
The most obvious solution would be to use
an Avalon/AXI bridge or implement some simple conversion entity.
However, the core’s interface is half-duplex with no handshake
signaling, whereas AXI is full duplex with two-way signaling. Moreover,
even AXI-Lite slave interface is quite resource-intensive, and the
flexibility and speed of AXI are not required for a CAN core.</p>
<p>Thus a much simpler bus was chosen – APB (Advanced Peripheral Bus)
(search for ARM <strong>AMBA APB Protocol Specification</strong>).
APB-AXI bridge is directly available in
Xilinx Vivado, and the interface adaptor entity is just a few simple
combinatorial assignments.</p>
<p>Finally, to be able to include the core in a block diagram as a custom
IP, the core, together with the APB interface, has been packaged as a
Vivado component.</p>
</section>
<section id="ctu-can-fd-driver-design">
<h2>CTU CAN FD Driver design<a class="headerlink" href="#ctu-can-fd-driver-design" title="Permalink to this headline">¶</a></h2>
<p>The general structure of a CAN device driver has already been examined
in . The next paragraphs provide a more detailed description of the CTU
CAN FD core driver in particular.</p>
<section id="low-level-driver">
<h3>Low-level driver<a class="headerlink" href="#low-level-driver" title="Permalink to this headline">¶</a></h3>
<p>The core is not intended to be used solely with SocketCAN, and thus it
is desirable to have an OS-independent low-level driver. This low-level
driver can then be used in implementations of OS driver or directly
either on bare metal or in a user-space application. Another advantage
is that if the hardware slightly changes, only the low-level driver
needs to be modified.</p>
<p>The code <a class="footnote-reference brackets" href="#id13" id="id3">3</a> is in part automatically generated and in part written
manually by the core author, with contributions of the thesis’ author.
The low-level driver supports operations such as: set bit timing, set
controller mode, enable/disable, read RX frame, write TX frame, and so
on.</p>
</section>
<section id="configuring-bit-timing">
<h3>Configuring bit timing<a class="headerlink" href="#configuring-bit-timing" title="Permalink to this headline">¶</a></h3>
<p>On CAN, each bit is divided into four segments: SYNC, PROP, PHASE1, and
PHASE2. Their duration is expressed in multiples of a Time Quantum
(details in <a class="reference external" href="http://esd.cs.ucr.edu/webres/can20.pdf">CAN Specification, Version 2.0</a>, chapter 8).
When configuring
bitrate, the durations of all the segments (and time quantum) must be
computed from the bitrate and Sample Point. This is performed
independently for both the Nominal bitrate and Data bitrate for CAN FD.</p>
<p>SocketCAN is fairly flexible and offers either highly customized
configuration by setting all the segment durations manually, or a
convenient configuration by setting just the bitrate and sample point
(and even that is chosen automatically per Bosch recommendation if not
specified). However, each CAN controller may have different base clock
frequency and different width of segment duration registers. The
algorithm thus needs the minimum and maximum values for the durations
(and clock prescaler) and tries to optimize the numbers to fit both the
constraints and the requested parameters.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">can_bittiming_const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span><span class="w">      </span><span class="cm">/* Name of the CAN controller hardware */</span><span class="w"></span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">tseg1_min</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Time segment 1 = prop_seg + phase_seg1 */</span><span class="w"></span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">tseg1_max</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">tseg2_min</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Time segment 2 = phase_seg2 */</span><span class="w"></span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">tseg2_max</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">sjw_max</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Synchronisation jump width */</span><span class="w"></span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">brp_min</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Bit-rate prescaler */</span><span class="w"></span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">brp_max</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__u32</span><span class="w"> </span><span class="n">brp_inc</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>[lst:can_bittiming_const]</p>
<p>A curious reader will notice that the durations of the segments PROP_SEG
and PHASE_SEG1 are not determined separately but rather combined and
then, by default, the resulting TSEG1 is evenly divided between PROP_SEG
and PHASE_SEG1. In practice, this has virtually no consequences as the
sample point is between PHASE_SEG1 and PHASE_SEG2. In CTU CAN FD,
however, the duration registers <code class="docutils literal notranslate"><span class="pre">PROP</span></code> and <code class="docutils literal notranslate"><span class="pre">PH1</span></code> have different
widths (6 and 7 bits, respectively), so the auto-computed values might
overflow the shorter register and must thus be redistributed among the
two <a class="footnote-reference brackets" href="#id14" id="id4">4</a>.</p>
</section>
<section id="handling-rx">
<h3>Handling RX<a class="headerlink" href="#handling-rx" title="Permalink to this headline">¶</a></h3>
<p>Frame reception is handled in NAPI queue, which is enabled from ISR when
the RXNE (RX FIFO Not Empty) bit is set. Frames are read one by one
until either no frame is left in the RX FIFO or the maximum work quota
has been reached for the NAPI poll run (see ). Each frame is then passed
to the network interface RX queue.</p>
<p>An incoming frame may be either a CAN 2.0 frame or a CAN FD frame. The
way to distinguish between these two in the kernel is to allocate either
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">can_frame</span></code> or <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">canfd_frame</span></code>, the two having different
sizes. In the controller, the information about the frame type is stored
in the first word of RX FIFO.</p>
<p>This brings us a chicken-egg problem: we want to allocate the <code class="docutils literal notranslate"><span class="pre">skb</span></code>
for the frame, and only if it succeeds, fetch the frame from FIFO;
otherwise keep it there for later. But to be able to allocate the
correct <code class="docutils literal notranslate"><span class="pre">skb</span></code>, we have to fetch the first work of FIFO. There are
several possible solutions:</p>
<ol class="arabic simple">
<li><p>Read the word, then allocate. If it fails, discard the rest of the
frame. When the system is low on memory, the situation is bad anyway.</p></li>
<li><p>Always allocate <code class="docutils literal notranslate"><span class="pre">skb</span></code> big enough for an FD frame beforehand. Then
tweak the <code class="docutils literal notranslate"><span class="pre">skb</span></code> internals to look like it has been allocated for
the smaller CAN 2.0 frame.</p></li>
<li><p>Add option to peek into the FIFO instead of consuming the word.</p></li>
<li><p>If the allocation fails, store the read word into driver’s data. On
the next try, use the stored word instead of reading it again.</p></li>
</ol>
<p>Option 1 is simple enough, but not very satisfying if we could do
better. Option 2 is not acceptable, as it would require modifying the
private state of an integral kernel structure. The slightly higher
memory consumption is just a virtual cherry on top of the “cake”. Option
3 requires non-trivial HW changes and is not ideal from the HW point of
view.</p>
<p>Option 4 seems like a good compromise, with its disadvantage being that
a partial frame may stay in the FIFO for a prolonged time. Nonetheless,
there may be just one owner of the RX FIFO, and thus no one else should
see the partial frame (disregarding some exotic debugging scenarios).
Basides, the driver resets the core on its initialization, so the
partial frame cannot be “adopted” either. In the end, option 4 was
selected <a class="footnote-reference brackets" href="#id15" id="id5">5</a>.</p>
<section id="timestamping-rx-frames">
<span id="subsec-ctucanfd-rxtimestamp"></span><h4>Timestamping RX frames<a class="headerlink" href="#timestamping-rx-frames" title="Permalink to this headline">¶</a></h4>
<p>The CTU CAN FD core reports the exact timestamp when the frame has been
received. The timestamp is by default captured at the sample point of
the last bit of EOF but is configurable to be captured at the SOF bit.
The timestamp source is external to the core and may be up to 64 bits
wide. At the time of writing, passing the timestamp from kernel to
userspace is not yet implemented, but is planned in the future.</p>
</section>
</section>
<section id="handling-tx">
<h3>Handling TX<a class="headerlink" href="#handling-tx" title="Permalink to this headline">¶</a></h3>
<p>The CTU CAN FD core has 4 independent TX buffers, each with its own
state and priority. When the core wants to transmit, a TX buffer in
Ready state with the highest priority is selected.</p>
<p>The priorities are 3bit numbers in register TX_PRIORITY
(nibble-aligned). This should be flexible enough for most use cases.
SocketCAN, however, supports only one FIFO queue for outgoing
frames <a class="footnote-reference brackets" href="#id16" id="id6">6</a>. The buffer priorities may be used to simulate the FIFO
behavior by assigning each buffer a distinct priority and <em>rotating</em> the
priorities after a frame transmission is completed.</p>
<p>In addition to priority rotation, the SW must maintain head and tail
pointers into the FIFO formed by the TX buffers to be able to determine
which buffer should be used for next frame (<code class="docutils literal notranslate"><span class="pre">txb_head</span></code>) and which
should be the first completed one (<code class="docutils literal notranslate"><span class="pre">txb_tail</span></code>). The actual buffer
indices are (obviously) modulo 4 (number of TX buffers), but the
pointers must be at least one bit wider to be able to distinguish
between FIFO full and FIFO empty – in this situation,
<img class="math" src="../../../../_images/math/a34e41d7be6e6c23b5f5d1d7240e482edbfbc28d.png" alt="txb\_head \equiv txb\_tail\ (\textrm{mod}\ 4)"/>. An example of how
the FIFO is maintained, together with priority rotation, is depicted in</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>TXB#</p></th>
<th class="head"><p>0</p></th>
<th class="head"><p>1</p></th>
<th class="head"><p>2</p></th>
<th class="head"><p>3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Seq</p></td>
<td><p>A</p></td>
<td><p>B</p></td>
<td><p>C</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Prio</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>T</p></td>
<td></td>
<td><p>H</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>TXB#</p></th>
<th class="head"><p>0</p></th>
<th class="head"><p>1</p></th>
<th class="head"><p>2</p></th>
<th class="head"><p>3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Seq</p></td>
<td></td>
<td><p>B</p></td>
<td><p>C</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Prio</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>T</p></td>
<td></td>
<td><p>H</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>TXB#</p></th>
<th class="head"><p>0</p></th>
<th class="head"><p>1</p></th>
<th class="head"><p>2</p></th>
<th class="head"><p>3</p></th>
<th class="head"><p>0’</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Seq</p></td>
<td><p>E</p></td>
<td><p>B</p></td>
<td><p>C</p></td>
<td><p>D</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Prio</p></td>
<td><p>4</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>T</p></td>
<td></td>
<td></td>
<td><p>H</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<figure class="align-default" id="id18">
<img alt="../../../../_images/fsm_txt_buffer_user.svg" src="../../../../_images/fsm_txt_buffer_user.svg" /><figcaption>
<p><span class="caption-text">TX Buffer states with possible transitions</span><a class="headerlink" href="#id18" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<section id="timestamping-tx-frames">
<span id="subsec-ctucanfd-txtimestamp"></span><h4>Timestamping TX frames<a class="headerlink" href="#timestamping-tx-frames" title="Permalink to this headline">¶</a></h4>
<p>When submitting a frame to a TX buffer, one may specify the timestamp at
which the frame should be transmitted. The frame transmission may start
later, but not sooner. Note that the timestamp does not participate in
buffer prioritization – that is decided solely by the mechanism
described above.</p>
<p>Support for time-based packet transmission was recently merged to Linux
v4.19 <a class="reference external" href="https://lwn.net/Articles/748879/">Time-based packet transmission</a>,
but it remains yet to be researched
whether this functionality will be practical for CAN.</p>
<p>Also similarly to retrieving the timestamp of RX frames, the core
supports retrieving the timestamp of TX frames – that is the time when
the frame was successfully delivered. The particulars are very similar
to timestamping RX frames and are described in .</p>
</section>
</section>
<section id="handling-rx-buffer-overrun">
<h3>Handling RX buffer overrun<a class="headerlink" href="#handling-rx-buffer-overrun" title="Permalink to this headline">¶</a></h3>
<p>When a received frame does no more fit into the hardware RX FIFO in its
entirety, RX FIFO overrun flag (STATUS[DOR]) is set and Data Overrun
Interrupt (DOI) is triggered. When servicing the interrupt, care must be
taken first to clear the DOR flag (via COMMAND[CDO]) and after that
clear the DOI interrupt flag. Otherwise, the interrupt would be
immediately <a class="footnote-reference brackets" href="#id17" id="id7">7</a> rearmed.</p>
<p><strong>Note</strong>: During development, it was discussed whether the internal HW
pipelining cannot disrupt this clear sequence and whether an additional
dummy cycle is necessary between clearing the flag and the interrupt. On
the Avalon interface, it indeed proved to be the case, but APB being
safe because it uses 2-cycle transactions. Essentially, the DOR flag
would be cleared, but DOI register’s Preset input would still be high
the cycle when the DOI clear request would also be applied (by setting
the register’s Reset input high). As Set had higher priority than Reset,
the DOI flag would not be reset. This has been already fixed by swapping
the Set/Reset priority (see issue #187).</p>
</section>
<section id="reporting-error-passive-and-bus-off-conditions">
<h3>Reporting Error Passive and Bus Off conditions<a class="headerlink" href="#reporting-error-passive-and-bus-off-conditions" title="Permalink to this headline">¶</a></h3>
<p>It may be desirable to report when the node reaches <em>Error Passive</em>,
<em>Error Warning</em>, and <em>Bus Off</em> conditions. The driver is notified about
error state change by an interrupt (EPI, EWLI), and then proceeds to
determine the core’s error state by reading its error counters.</p>
<p>There is, however, a slight race condition here – there is a delay
between the time when the state transition occurs (and the interrupt is
triggered) and when the error counters are read. When EPI is received,
the node may be either <em>Error Passive</em> or <em>Bus Off</em>. If the node goes
<em>Bus Off</em>, it obviously remains in the state until it is reset.
Otherwise, the node is <em>or was</em> <em>Error Passive</em>. However, it may happen
that the read state is <em>Error Warning</em> or even <em>Error Active</em>. It may be
unclear whether and what exactly to report in that case, but I
personally entertain the idea that the past error condition should still
be reported. Similarly, when EWLI is received but the state is later
detected to be <em>Error Passive</em>, <em>Error Passive</em> should be reported.</p>
</section>
</section>
<section id="ctu-can-fd-driver-sources-reference">
<h2>CTU CAN FD Driver Sources Reference<a class="headerlink" href="#ctu-can-fd-driver-sources-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.ctucan_probe_common">
int <code class="sig-name descname">ctucan_probe_common</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, void __iomem<em> *addr</em>, int<em> irq</em>, unsigned int<em> ntxbufs</em>, unsigned long<em> can_clk_rate</em>, int<em> pm_enable_call</em>, void (<em>*set_drvdata_fnc</em>)(struct <a class="reference internal" href="../../../../driver-api/infrastructure.html#c.device" title="device">device</a> *dev, struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a> *ndev)<span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_probe_common" title="Permalink to this definition">¶</a></dt>
<dd><p>Device type independent registration call</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Handle to the generic device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*addr</span></code></dt><dd><p>Base address of CTU CAN FD core address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>Interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ntxbufs</span></code></dt><dd><p>Number of implemented Tx buffers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">can_clk_rate</span></code></dt><dd><p>Clock rate, if 0 then clock are taken from device node</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pm_enable_call</span></code></dt><dd><p>Whether pm_runtime_enable should be called</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*set_drvdata_fnc)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev)</span></code></dt><dd><p>Function to set network driver data for physical device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does all the memory allocation and registration for the CAN
device.</p>
<p><strong>Return</strong></p>
<p>0 on success and failure value on error</p>
</div>
<dl class="function">
<dt id="c.ctucan_state_to_str">
const char * <code class="sig-name descname">ctucan_state_to_str</code><span class="sig-paren">(</span>enum can_state<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_state_to_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts CAN controller state code to corresponding text</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">can_state</span> <span class="pre">state</span></code></dt><dd><p>CAN controller state code</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to string representation of the error state</p>
</div>
<dl class="function">
<dt id="c.ctucan_reset">
int <code class="sig-name descname">ctucan_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Issues software reset request to CTU CAN FD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -<code class="docutils literal notranslate"><span class="pre">ETIMEDOUT</span></code> if CAN controller does not leave reset</p>
</div>
<dl class="function">
<dt id="c.ctucan_set_btr">
int <code class="sig-name descname">ctucan_set_btr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em>, struct can_bittiming<em> *bt</em>, bool<em> nominal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_set_btr" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets CAN bus bit timing in CTU CAN FD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">can_bittiming</span> <span class="pre">*bt</span></code></dt><dd><p>Pointer to Bit timing structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">nominal</span></code></dt><dd><p>True - Nominal bit timing, False - Data bit timing</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 - OK, -<code class="docutils literal notranslate"><span class="pre">EPERM</span></code> if controller is enabled</p>
</div>
<dl class="function">
<dt id="c.ctucan_set_bittiming">
int <code class="sig-name descname">ctucan_set_bittiming</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_set_bittiming" title="Permalink to this definition">¶</a></dt>
<dd><p>CAN set nominal bit timing routine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, -<code class="docutils literal notranslate"><span class="pre">EPERM</span></code> on error</p>
</div>
<dl class="function">
<dt id="c.ctucan_set_data_bittiming">
int <code class="sig-name descname">ctucan_set_data_bittiming</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_set_data_bittiming" title="Permalink to this definition">¶</a></dt>
<dd><p>CAN set data bit timing routine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, -<code class="docutils literal notranslate"><span class="pre">EPERM</span></code> on error</p>
</div>
<dl class="function">
<dt id="c.ctucan_set_secondary_sample_point">
int <code class="sig-name descname">ctucan_set_secondary_sample_point</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_set_secondary_sample_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets secondary sample point in CTU CAN FD</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, -<code class="docutils literal notranslate"><span class="pre">EPERM</span></code> if controller is enabled</p>
</div>
<dl class="function">
<dt id="c.ctucan_set_mode">
void <code class="sig-name descname">ctucan_set_mode</code><span class="sig-paren">(</span>struct ctucan_priv<em> *priv</em>, const struct can_ctrlmode<em> *mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets CTU CAN FDs mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctucan_priv</span> <span class="pre">*priv</span></code></dt><dd><p>Pointer to private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">can_ctrlmode</span> <span class="pre">*mode</span></code></dt><dd><p>Pointer to controller modes to be set</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ctucan_chip_start">
int <code class="sig-name descname">ctucan_chip_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_chip_start" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine starts the driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Routine expects that chip is in reset state. It setups initial
Tx buffers for FIFO priorities, sets bittiming, enables interrupts,
switches core to operational mode and changes controller
state to <code class="docutils literal notranslate"><span class="pre">CAN_STATE_STOPPED</span></code>.</p>
<p><strong>Return</strong></p>
<p>0 on success and failure value on error</p>
</div>
<dl class="function">
<dt id="c.ctucan_do_set_mode">
int <code class="sig-name descname">ctucan_do_set_mode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em>, enum can_mode<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_do_set_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets mode of the driver</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">can_mode</span> <span class="pre">mode</span></code></dt><dd><p>Tells the mode of the driver</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This check the drivers state and calls the corresponding modes to set.</p>
<p><strong>Return</strong></p>
<p>0 on success and failure value on error</p>
</div>
<dl class="function">
<dt id="c.ctucan_get_tx_status">
enum ctucan_txtb_status <code class="sig-name descname">ctucan_get_tx_status</code><span class="sig-paren">(</span>struct ctucan_priv<em> *priv</em>, u8<em> buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_get_tx_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets status of TXT buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctucan_priv</span> <span class="pre">*priv</span></code></dt><dd><p>Pointer to private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">buf</span></code></dt><dd><p>Buffer index (0-based)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Status of TXT buffer</p>
</div>
<dl class="function">
<dt id="c.ctucan_is_txt_buf_writable">
bool <code class="sig-name descname">ctucan_is_txt_buf_writable</code><span class="sig-paren">(</span>struct ctucan_priv<em> *priv</em>, u8<em> buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_is_txt_buf_writable" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if frame can be inserted to TXT Buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctucan_priv</span> <span class="pre">*priv</span></code></dt><dd><p>Pointer to private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">buf</span></code></dt><dd><p>Buffer index (0-based)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>True - Frame can be inserted to TXT Buffer, False - If attempted, frame will not be</dt><dd><p>inserted to TXT Buffer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ctucan_insert_frame">
bool <code class="sig-name descname">ctucan_insert_frame</code><span class="sig-paren">(</span>struct ctucan_priv<em> *priv</em>, const struct canfd_frame<em> *cf</em>, u8<em> buf</em>, bool<em> isfdf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_insert_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts frame to TXT buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctucan_priv</span> <span class="pre">*priv</span></code></dt><dd><p>Pointer to private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">canfd_frame</span> <span class="pre">*cf</span></code></dt><dd><p>Pointer to CAN frame to be inserted</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">buf</span></code></dt><dd><p>TXT Buffer index to which frame is inserted (0-based)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">isfdf</span></code></dt><dd><p>True - CAN FD Frame, False - CAN 2.0 Frame</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>True - Frame inserted successfully</dt><dd><dl class="simple">
<dt>False - Frame was not inserted due to one of:</dt><dd><ol class="arabic simple">
<li><p>TXT Buffer is not writable (it is in wrong state)</p></li>
<li><p>Invalid TXT buffer index</p></li>
<li><p>Invalid frame length</p></li>
</ol>
</dd>
</dl>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ctucan_give_txtb_cmd">
void <code class="sig-name descname">ctucan_give_txtb_cmd</code><span class="sig-paren">(</span>struct ctucan_priv<em> *priv</em>, enum ctucan_txtb_command<em> cmd</em>, u8<em> buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_give_txtb_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies command on TXT buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctucan_priv</span> <span class="pre">*priv</span></code></dt><dd><p>Pointer to private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ctucan_txtb_command</span> <span class="pre">cmd</span></code></dt><dd><p>Command to give</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">buf</span></code></dt><dd><p>Buffer index (0-based)</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ctucan_start_xmit">
netdev_tx_t <code class="sig-name descname">ctucan_start_xmit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.sk_buff" title="sk_buff">sk_buff</a><em> *skb</em>, struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_start_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts the transmission</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb</span></code></dt><dd><p>sk_buff pointer that contains data to be Txed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invoked from upper layers to initiate transmission. Uses the next available free TXT Buffer and
populates its fields to start the transmission.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">NETDEV_TX_OK</span></code> on success, <code class="docutils literal notranslate"><span class="pre">NETDEV_TX_BUSY</span></code> when no free TXT buffer is available,</dt><dd><p>negative return values reserved for error cases</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ctucan_read_rx_frame">
void <code class="sig-name descname">ctucan_read_rx_frame</code><span class="sig-paren">(</span>struct ctucan_priv<em> *priv</em>, struct canfd_frame<em> *cf</em>, u32<em> ffw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_read_rx_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads frame from RX FIFO</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctucan_priv</span> <span class="pre">*priv</span></code></dt><dd><p>Pointer to CTU CAN FD’s private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">canfd_frame</span> <span class="pre">*cf</span></code></dt><dd><p>Pointer to CAN frame struct</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">ffw</span></code></dt><dd><p>Previously read frame format word</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>Frame format word must be read separately and provided in ‘ffw’.</p>
</div>
<dl class="function">
<dt id="c.ctucan_rx">
int <code class="sig-name descname">ctucan_rx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Called from CAN ISR to complete the received frame processing</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is invoked from the CAN isr(poll) to process the Rx frames. It does minimal
processing and invokes “netif_receive_skb” to complete further processing.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>1 when frame is passed to the network layer, 0 when the first frame word is read but</dt><dd><p>system is out of free SKBs temporally and left code to resolve SKB allocation later,
-<code class="docutils literal notranslate"><span class="pre">EAGAIN</span></code> in a case of empty Rx FIFO.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ctucan_read_fault_state">
enum can_state <code class="sig-name descname">ctucan_read_fault_state</code><span class="sig-paren">(</span>struct ctucan_priv<em> *priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_read_fault_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads CTU CAN FDs fault confinement state.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctucan_priv</span> <span class="pre">*priv</span></code></dt><dd><p>Pointer to private data</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Fault confinement state of controller</p>
</div>
<dl class="function">
<dt id="c.ctucan_get_rec_tec">
void <code class="sig-name descname">ctucan_get_rec_tec</code><span class="sig-paren">(</span>struct ctucan_priv<em> *priv</em>, struct can_berr_counter<em> *bec</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_get_rec_tec" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads REC/TEC counter values from controller</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ctucan_priv</span> <span class="pre">*priv</span></code></dt><dd><p>Pointer to private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">can_berr_counter</span> <span class="pre">*bec</span></code></dt><dd><p>Pointer to Error counter structure</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ctucan_err_interrupt">
void <code class="sig-name descname">ctucan_err_interrupt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em>, u32<em> isr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_err_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Error frame ISR</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>net_device pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">isr</span></code></dt><dd><p>interrupt status register value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the CAN error interrupt and it will check the type of error and forward the error
frame to upper layers.</p>
</div>
<dl class="function">
<dt id="c.ctucan_rx_poll">
int <code class="sig-name descname">ctucan_rx_poll</code><span class="sig-paren">(</span>struct napi_struct<em> *napi</em>, int<em> quota</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_rx_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>Poll routine for rx packets (NAPI)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*napi</span></code></dt><dd><p>NAPI structure pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">quota</span></code></dt><dd><p>Max number of rx packets to be processed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the poll routine for rx part. It will process the packets maximux quota value.</p>
<p><strong>Return</strong></p>
<p>Number of packets received</p>
</div>
<dl class="function">
<dt id="c.ctucan_rotate_txb_prio">
void <code class="sig-name descname">ctucan_rotate_txb_prio</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_rotate_txb_prio" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates priorities of TXT Buffers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>net_device pointer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ctucan_tx_interrupt">
void <code class="sig-name descname">ctucan_tx_interrupt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_tx_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Tx done Isr</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>net_device pointer</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.ctucan_interrupt">
irqreturn_t <code class="sig-name descname">ctucan_interrupt</code><span class="sig-paren">(</span>int<em> irq</em>, void<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>CAN Isr</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>irq number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>device id pointer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the CTU CAN FD ISR. It checks for the type of interrupt
and invokes the corresponding ISR.</p>
<p><strong>Return</strong></p>
<p>IRQ_NONE - If CAN device is in sleep mode, IRQ_HANDLED otherwise</p>
</div>
<dl class="function">
<dt id="c.ctucan_chip_stop">
void <code class="sig-name descname">ctucan_chip_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_chip_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver stop routine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the drivers stop routine. It will disable the
interrupts and disable the controller.</p>
</div>
<dl class="function">
<dt id="c.ctucan_open">
int <code class="sig-name descname">ctucan_open</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver open routine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the driver open routine.</p>
<p><strong>Return</strong></p>
<p>0 on success and failure value on error</p>
</div>
<dl class="function">
<dt id="c.ctucan_close">
int <code class="sig-name descname">ctucan_close</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver close routine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 always</p>
</div>
<dl class="function">
<dt id="c.ctucan_get_berr_counter">
int <code class="sig-name descname">ctucan_get_berr_counter</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="../../../kapi.html#c.net_device" title="net_device">net_device</a><em> *ndev</em>, struct can_berr_counter<em> *bec</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_get_berr_counter" title="Permalink to this definition">¶</a></dt>
<dd><p>error counter routine</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*ndev</span></code></dt><dd><p>Pointer to net_device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">can_berr_counter</span> <span class="pre">*bec</span></code></dt><dd><p>Pointer to can_berr_counter structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the driver error counter routine.</p>
<p><strong>Return</strong></p>
<p>0 on success and failure value on error</p>
</div>
<dl class="function">
<dt id="c.ctucan_pci_probe">
int <code class="sig-name descname">ctucan_pci_probe</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em>, const struct <a class="reference internal" href="../../../../PCI/pci.html#c.pci_device_id" title="pci_device_id">pci_device_id</a><em> *ent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_pci_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>PCI registration call</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>Handle to the pci device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_device_id</span> <span class="pre">*ent</span></code></dt><dd><p>Pointer to the entry from ctucan_pci_tbl</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does all the memory allocation and registration for the CAN
device.</p>
<p><strong>Return</strong></p>
<p>0 on success and failure value on error</p>
</div>
<dl class="function">
<dt id="c.ctucan_pci_remove">
void <code class="sig-name descname">ctucan_pci_remove</code><span class="sig-paren">(</span>struct pci_dev<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_pci_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister the device after releasing the resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*pdev</span></code></dt><dd><p>Handle to the pci device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function frees all the resources allocated to the device.</p>
<p><strong>Return</strong></p>
<p>0 always</p>
</div>
<dl class="function">
<dt id="c.ctucan_platform_probe">
int <code class="sig-name descname">ctucan_platform_probe</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_platform_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Platform registration call</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>Handle to the platform device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does all the memory allocation and registration for the CAN
device.</p>
<p><strong>Return</strong></p>
<p>0 on success and failure value on error</p>
</div>
<dl class="function">
<dt id="c.ctucan_platform_remove">
int <code class="sig-name descname">ctucan_platform_remove</code><span class="sig-paren">(</span>struct platform_device<em> *pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ctucan_platform_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister the device after releasing the resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*pdev</span></code></dt><dd><p>Handle to the platform device structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function frees all the resources allocated to the device.</p>
<p><strong>Return</strong></p>
<p>0 always</p>
</div>
</section>
<section id="ctu-can-fd-ip-core-and-driver-development-acknowledgment">
<h2>CTU CAN FD IP Core and Driver Development Acknowledgment<a class="headerlink" href="#ctu-can-fd-ip-core-and-driver-development-acknowledgment" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Odrej Ille &lt;<a class="reference external" href="mailto:ondrej&#46;ille&#37;&#52;&#48;gmail&#46;com">ondrej<span>&#46;</span>ille<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<ul>
<li><p>started the project as student at Department of Measurement, FEE, CTU</p></li>
<li><p>invested great amount of personal time and enthusiasm to the project over years</p></li>
<li><p>worked on more funded tasks</p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://meas.fel.cvut.cz/">Department of Measurement</a>,
<a class="reference external" href="http://www.fel.cvut.cz/en/">Faculty of Electrical Engineering</a>,
<a class="reference external" href="https://www.cvut.cz/en">Czech Technical University</a></p>
<ul>
<li><p>is the main investor into the project over many years</p></li>
<li><p>uses project in their CAN/CAN FD diagnostics framework for <a class="reference external" href="https://www.skoda-auto.cz/">Skoda Auto</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://www.digiteqautomotive.com/en">Digiteq Automotive</a></p>
<ul>
<li><p>funding of the project CAN FD Open Cores Support Linux Kernel Based Systems</p></li>
<li><p>negotiated and paid CTU to allow public access to the project</p></li>
<li><p>provided additional funding of the work</p></li>
</ul>
</li>
<li><p><a class="reference external" href="https://control.fel.cvut.cz/en">Department of Control Engineering</a>,
<a class="reference external" href="http://www.fel.cvut.cz/en/">Faculty of Electrical Engineering</a>,
<a class="reference external" href="https://www.cvut.cz/en">Czech Technical University</a></p>
<ul>
<li><p>solving the project CAN FD Open Cores Support Linux Kernel Based Systems</p></li>
<li><p>providing GitLab management</p></li>
<li><p>virtual servers and computational power for continuous integration</p></li>
<li><p>providing hardware for HIL continuous integration tests</p></li>
</ul>
</li>
<li><p><a class="reference external" href="http://pikron.com/">PiKRON Ltd.</a></p>
<ul>
<li><p>minor funding to initiate preparation of the project open-sourcing</p></li>
</ul>
</li>
<li><p>Petr Porazil &lt;<a class="reference external" href="mailto:porazil&#37;&#52;&#48;pikron&#46;com">porazil<span>&#64;</span>pikron<span>&#46;</span>com</a>&gt;</p>
<ul>
<li><p>design of PCIe transceiver addon board and assembly of boards</p></li>
<li><p>design and assembly of MZ_APO baseboard for MicroZed/Zynq based system</p></li>
</ul>
</li>
<li><p>Martin Jerabek &lt;<a class="reference external" href="mailto:martin&#46;jerabek01&#37;&#52;&#48;gmail&#46;com">martin<span>&#46;</span>jerabek01<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<ul>
<li><p>Linux driver development</p></li>
<li><p>continuous integration platform architect and GHDL updates</p></li>
<li><p>theses <a class="reference external" href="https://dspace.cvut.cz/bitstream/handle/10467/80366/F3-DP-2019-Jerabek-Martin-Jerabek-thesis-2019-canfd.pdf">Open-source and Open-hardware CAN FD Protocol Support</a></p></li>
</ul>
</li>
<li><p>Jiri Novak &lt;<a class="reference external" href="mailto:jnovak&#37;&#52;&#48;fel&#46;cvut&#46;cz">jnovak<span>&#64;</span>fel<span>&#46;</span>cvut<span>&#46;</span>cz</a>&gt;</p>
<ul>
<li><p>project initiation, management and use at Department of Measurement, FEE, CTU</p></li>
</ul>
</li>
<li><p>Pavel Pisa &lt;<a class="reference external" href="mailto:pisa&#37;&#52;&#48;cmp&#46;felk&#46;cvut&#46;cz">pisa<span>&#64;</span>cmp<span>&#46;</span>felk<span>&#46;</span>cvut<span>&#46;</span>cz</a>&gt;</p>
<ul>
<li><p>initiate open-sourcing, project coordination, management at Department of Control Engineering, FEE, CTU</p></li>
</ul>
</li>
<li><p>Jaroslav Beran&lt;<a class="reference external" href="mailto:jara&#46;beran&#37;&#52;&#48;gmail&#46;com">jara<span>&#46;</span>beran<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>system integration for Intel SoC, core and driver testing and updates</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>Carsten Emde (<a class="reference external" href="https://www.osadl.org/">OSADL</a>)</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>provided OSADL expertise to discuss IP core licensing</p></li>
<li><p>pointed to possible deadlock for LGPL and CAN bus possible patent case which lead to relicense IP core design to BSD like license</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>Reiner Zitzmann and Holger Zeltwanger (<a class="reference external" href="https://www.can-cia.org/">CAN in Automation</a>)</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>provided suggestions and help to inform community about the project and invited us to events focused on CAN bus future development directions</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>Jan Charvat</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>implemented CTU CAN FD functional model for QEMU which has been integrated into QEMU mainline (<a class="reference external" href="https://www.qemu.org/docs/master/system/devices/can.html">docs/system/devices/can.rst</a>)</p></li>
<li><p>Bachelor theses Model of CAN FD Communication Controller for QEMU Emulator</p></li>
</ul>
</div></blockquote>
</section>
<section id="notes">
<h2>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Other buses have their own specific driver interface to set up the
device.</p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Not to be mistaken with CAN Error Frame. This is a <code class="docutils literal notranslate"><span class="pre">can_frame</span></code> with
<code class="docutils literal notranslate"><span class="pre">CAN_ERR_FLAG</span></code> set and some error info in its <code class="docutils literal notranslate"><span class="pre">data</span></code> field.</p>
</dd>
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Available in CTU CAN FD repository
<a class="reference external" href="https://gitlab.fel.cvut.cz/canbus/ctucanfd_ip_core">https://gitlab.fel.cvut.cz/canbus/ctucanfd_ip_core</a></p>
</dd>
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>As is done in the low-level driver functions
<code class="docutils literal notranslate"><span class="pre">ctucan_hw_set_nom_bittiming</span></code> and
<code class="docutils literal notranslate"><span class="pre">ctucan_hw_set_data_bittiming</span></code>.</p>
</dd>
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>At the time of writing this thesis, option 1 is still being used and
the modification is queued in gitlab issue #222</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>Strictly speaking, multiple CAN TX queues are supported since v4.19
<a class="reference external" href="https://lore.kernel.org/patchwork/patch/913526/">can: enable multi-queue for SocketCAN devices</a> but no mainline driver is using
them yet.</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id7">7</a></span></dt>
<dd><p>Or rather in the next clock cycle</p>
</dd>
</dl>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">CTU CAN FD Driver</a><ul>
<li><a class="reference internal" href="#about-ctu-can-fd-ip-core">About CTU CAN FD IP Core</a></li>
<li><a class="reference internal" href="#about-socketcan">About SocketCAN</a><ul>
<li><a class="reference internal" href="#device-probe">Device probe</a></li>
<li><a class="reference internal" href="#device-tree">Device tree</a></li>
<li><a class="reference internal" href="#driver-structure">Driver structure</a><ul>
<li><a class="reference internal" href="#platform-device-driver">Platform device driver</a></li>
<li><a class="reference internal" href="#network-device-driver">Network device driver</a></li>
</ul>
</li>
<li><a class="reference internal" href="#napi">NAPI</a></li>
</ul>
</li>
<li><a class="reference internal" href="#integrating-the-core-to-xilinx-zynq">Integrating the core to Xilinx Zynq</a></li>
<li><a class="reference internal" href="#ctu-can-fd-driver-design">CTU CAN FD Driver design</a><ul>
<li><a class="reference internal" href="#low-level-driver">Low-level driver</a></li>
<li><a class="reference internal" href="#configuring-bit-timing">Configuring bit timing</a></li>
<li><a class="reference internal" href="#handling-rx">Handling RX</a><ul>
<li><a class="reference internal" href="#timestamping-rx-frames">Timestamping RX frames</a></li>
</ul>
</li>
<li><a class="reference internal" href="#handling-tx">Handling TX</a><ul>
<li><a class="reference internal" href="#timestamping-tx-frames">Timestamping TX frames</a></li>
</ul>
</li>
<li><a class="reference internal" href="#handling-rx-buffer-overrun">Handling RX buffer overrun</a></li>
<li><a class="reference internal" href="#reporting-error-passive-and-bus-off-conditions">Reporting Error Passive and Bus Off conditions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctu-can-fd-driver-sources-reference">CTU CAN FD Driver Sources Reference</a></li>
<li><a class="reference internal" href="#ctu-can-fd-ip-core-and-driver-development-acknowledgment">CTU CAN FD IP Core and Driver Development Acknowledgment</a></li>
<li><a class="reference internal" href="#notes">Notes</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../_sources/networking/device_drivers/can/ctu/ctucanfd-driver.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../../_sources/networking/device_drivers/can/ctu/ctucanfd-driver.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>