
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>L2TP &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Linux LAPB Module Interface" href="lapb-module.html" />
    <link rel="prev" title="Kernel Connection Multiplexor" href="kcm.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="l2tp">
<h1>L2TP<a class="headerlink" href="#l2tp" title="Permalink to this headline">¶</a></h1>
<p>Layer 2 Tunneling Protocol (L2TP) allows L2 frames to be tunneled over
an IP network.</p>
<p>This document covers the kernel’s L2TP subsystem. It documents kernel
APIs for application developers who want to use the L2TP subsystem and
it provides some technical details about the internal implementation
which may be useful to kernel developers and maintainers.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The kernel’s L2TP subsystem implements the datapath for L2TPv2 and
L2TPv3. L2TPv2 is carried over UDP. L2TPv3 is carried over UDP or
directly over IP (protocol 115).</p>
<p>The L2TP RFCs define two basic kinds of L2TP packets: control packets
(the “control plane”), and data packets (the “data plane”). The kernel
deals only with data packets. The more complex control packets are
handled by user space.</p>
<p>An L2TP tunnel carries one or more L2TP sessions. Each tunnel is
associated with a socket. Each session is associated with a virtual
netdevice, e.g. <code class="docutils literal notranslate"><span class="pre">pppN</span></code>, <code class="docutils literal notranslate"><span class="pre">l2tpethN</span></code>, through which data frames pass
to/from L2TP. Fields in the L2TP header identify the tunnel or session
and whether it is a control or data packet. When tunnels and sessions
are set up using the Linux kernel API, we’re just setting up the L2TP
data path. All aspects of the control protocol are to be handled by
user space.</p>
<p>This split in responsibilities leads to a natural sequence of
operations when establishing tunnels and sessions. The procedure looks
like this:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Create a tunnel socket. Exchange L2TP control protocol messages
with the peer over that socket in order to establish a tunnel.</p></li>
<li><p>Create a tunnel context in the kernel, using information
obtained from the peer using the control protocol messages.</p></li>
<li><p>Exchange L2TP control protocol messages with the peer over the
tunnel socket in order to establish a session.</p></li>
<li><p>Create a session context in the kernel using information
obtained from the peer using the control protocol messages.</p></li>
</ol>
</div></blockquote>
</section>
<section id="l2tp-apis">
<h2>L2TP APIs<a class="headerlink" href="#l2tp-apis" title="Permalink to this headline">¶</a></h2>
<p>This section documents each userspace API of the L2TP subsystem.</p>
<section id="tunnel-sockets">
<h3>Tunnel Sockets<a class="headerlink" href="#tunnel-sockets" title="Permalink to this headline">¶</a></h3>
<p>L2TPv2 always uses UDP. L2TPv3 may use UDP or IP encapsulation.</p>
<p>To create a tunnel socket for use by L2TP, the standard POSIX
socket API is used.</p>
<p>For example, for a tunnel using IPv4 addresses and UDP encapsulation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
</pre></div>
</div>
<p>Or for a tunnel using IPv6 addresses and IP encapsulation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int sockfd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_L2TP);
</pre></div>
</div>
<p>UDP socket programming doesn’t need to be covered here.</p>
<p>IPPROTO_L2TP is an IP protocol type implemented by the kernel’s L2TP
subsystem. The L2TPIP socket address is defined in struct
sockaddr_l2tpip and struct sockaddr_l2tpip6 at
<a class="reference external" href="../../../include/uapi/linux/l2tp.h">include/uapi/linux/l2tp.h</a>. The address includes the L2TP tunnel
(connection) id. To use L2TP IP encapsulation, an L2TPv3 application
should bind the L2TPIP socket using the locally assigned
tunnel id. When the peer’s tunnel id and IP address is known, a
connect must be done.</p>
<p>If the L2TP application needs to handle L2TPv3 tunnel setup requests
from peers using L2TPIP, it must open a dedicated L2TPIP
socket to listen for those requests and bind the socket using tunnel
id 0 since tunnel setup requests are addressed to tunnel id 0.</p>
<p>An L2TP tunnel and all of its sessions are automatically closed when
its tunnel socket is closed.</p>
</section>
<section id="netlink-api">
<h3>Netlink API<a class="headerlink" href="#netlink-api" title="Permalink to this headline">¶</a></h3>
<p>L2TP applications use netlink to manage L2TP tunnel and session
instances in the kernel. The L2TP netlink API is defined in
<a class="reference external" href="../../../include/uapi/linux/l2tp.h">include/uapi/linux/l2tp.h</a>.</p>
<p>L2TP uses <a class="reference external" href="generic_netlink.html">Generic Netlink</a> (GENL). Several commands are defined:
Create, Delete, Modify and Get for tunnel and session
instances, e.g. <code class="docutils literal notranslate"><span class="pre">L2TP_CMD_TUNNEL_CREATE</span></code>. The API header lists the
netlink attribute types that can be used with each command.</p>
<p>Tunnel and session instances are identified by a locally unique
32-bit id.  L2TP tunnel ids are given by <code class="docutils literal notranslate"><span class="pre">L2TP_ATTR_CONN_ID</span></code> and
<code class="docutils literal notranslate"><span class="pre">L2TP_ATTR_PEER_CONN_ID</span></code> attributes and L2TP session ids are given
by <code class="docutils literal notranslate"><span class="pre">L2TP_ATTR_SESSION_ID</span></code> and <code class="docutils literal notranslate"><span class="pre">L2TP_ATTR_PEER_SESSION_ID</span></code>
attributes. If netlink is used to manage L2TPv2 tunnel and session
instances, the L2TPv2 16-bit tunnel/session id is cast to a 32-bit
value in these attributes.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">L2TP_CMD_TUNNEL_CREATE</span></code> command, <code class="docutils literal notranslate"><span class="pre">L2TP_ATTR_FD</span></code> tells the
kernel the tunnel socket fd being used. If not specified, the kernel
creates a kernel socket for the tunnel, using IP parameters set in
<code class="docutils literal notranslate"><span class="pre">L2TP_ATTR_IP[6]_SADDR</span></code>, <code class="docutils literal notranslate"><span class="pre">L2TP_ATTR_IP[6]_DADDR</span></code>,
<code class="docutils literal notranslate"><span class="pre">L2TP_ATTR_UDP_SPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">L2TP_ATTR_UDP_DPORT</span></code> attributes. Kernel
sockets are used to implement unmanaged L2TPv3 tunnels (iproute2’s “ip
l2tp” commands). If <code class="docutils literal notranslate"><span class="pre">L2TP_ATTR_FD</span></code> is given, it must be a socket fd
that is already bound and connected. There is more information about
unmanaged tunnels later in this document.</p>
<p><code class="docutils literal notranslate"><span class="pre">L2TP_CMD_TUNNEL_CREATE</span></code> attributes:-</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 11%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CONN_ID</p></td>
<td><p>Y</p></td>
<td><p>Sets the tunnel (connection) id.</p></td>
</tr>
<tr class="row-odd"><td><p>PEER_CONN_ID</p></td>
<td><p>Y</p></td>
<td><p>Sets the peer tunnel (connection) id.</p></td>
</tr>
<tr class="row-even"><td><p>PROTO_VERSION</p></td>
<td><p>Y</p></td>
<td><p>Protocol version. 2 or 3.</p></td>
</tr>
<tr class="row-odd"><td><p>ENCAP_TYPE</p></td>
<td><p>Y</p></td>
<td><p>Encapsulation type: UDP or IP.</p></td>
</tr>
<tr class="row-even"><td><p>FD</p></td>
<td><p>N</p></td>
<td><p>Tunnel socket file descriptor.</p></td>
</tr>
<tr class="row-odd"><td><p>UDP_CSUM</p></td>
<td><p>N</p></td>
<td><p>Enable IPv4 UDP checksums. Used only if FD is
not set.</p></td>
</tr>
<tr class="row-even"><td><p>UDP_ZERO_CSUM6_TX</p></td>
<td><p>N</p></td>
<td><p>Zero IPv6 UDP checksum on transmit. Used only
if FD is not set.</p></td>
</tr>
<tr class="row-odd"><td><p>UDP_ZERO_CSUM6_RX</p></td>
<td><p>N</p></td>
<td><p>Zero IPv6 UDP checksum on receive. Used only if
FD is not set.</p></td>
</tr>
<tr class="row-even"><td><p>IP_SADDR</p></td>
<td><p>N</p></td>
<td><p>IPv4 source address. Used only if FD is not
set.</p></td>
</tr>
<tr class="row-odd"><td><p>IP_DADDR</p></td>
<td><p>N</p></td>
<td><p>IPv4 destination address. Used only if FD is
not set.</p></td>
</tr>
<tr class="row-even"><td><p>UDP_SPORT</p></td>
<td><p>N</p></td>
<td><p>UDP source port. Used only if FD is not set.</p></td>
</tr>
<tr class="row-odd"><td><p>UDP_DPORT</p></td>
<td><p>N</p></td>
<td><p>UDP destination port. Used only if FD is not
set.</p></td>
</tr>
<tr class="row-even"><td><p>IP6_SADDR</p></td>
<td><p>N</p></td>
<td><p>IPv6 source address. Used only if FD is not
set.</p></td>
</tr>
<tr class="row-odd"><td><p>IP6_DADDR</p></td>
<td><p>N</p></td>
<td><p>IPv6 destination address. Used only if FD is
not set.</p></td>
</tr>
<tr class="row-even"><td><p>DEBUG</p></td>
<td><p>N</p></td>
<td><p>Debug flags.</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">L2TP_CMD_TUNNEL_DESTROY</span></code> attributes:-</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 12%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CONN_ID</p></td>
<td><p>Y</p></td>
<td><p>Identifies the tunnel id to be destroyed.</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">L2TP_CMD_TUNNEL_MODIFY</span></code> attributes:-</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 12%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CONN_ID</p></td>
<td><p>Y</p></td>
<td><p>Identifies the tunnel id to be modified.</p></td>
</tr>
<tr class="row-odd"><td><p>DEBUG</p></td>
<td><p>N</p></td>
<td><p>Debug flags.</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">L2TP_CMD_TUNNEL_GET</span></code> attributes:-</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 12%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CONN_ID</p></td>
<td><p>N</p></td>
<td><p>Identifies the tunnel id to be queried.
Ignored in DUMP requests.</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">L2TP_CMD_SESSION_CREATE</span></code> attributes:-</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 12%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CONN_ID</p></td>
<td><p>Y</p></td>
<td><p>The parent tunnel id.</p></td>
</tr>
<tr class="row-odd"><td><p>SESSION_ID</p></td>
<td><p>Y</p></td>
<td><p>Sets the session id.</p></td>
</tr>
<tr class="row-even"><td><p>PEER_SESSION_ID</p></td>
<td><p>Y</p></td>
<td><p>Sets the parent session id.</p></td>
</tr>
<tr class="row-odd"><td><p>PW_TYPE</p></td>
<td><p>Y</p></td>
<td><p>Sets the pseudowire type.</p></td>
</tr>
<tr class="row-even"><td><p>DEBUG</p></td>
<td><p>N</p></td>
<td><p>Debug flags.</p></td>
</tr>
<tr class="row-odd"><td><p>RECV_SEQ</p></td>
<td><p>N</p></td>
<td><p>Enable rx data sequence numbers.</p></td>
</tr>
<tr class="row-even"><td><p>SEND_SEQ</p></td>
<td><p>N</p></td>
<td><p>Enable tx data sequence numbers.</p></td>
</tr>
<tr class="row-odd"><td><p>LNS_MODE</p></td>
<td><p>N</p></td>
<td><p>Enable LNS mode (auto-enable data sequence
numbers).</p></td>
</tr>
<tr class="row-even"><td><p>RECV_TIMEOUT</p></td>
<td><p>N</p></td>
<td><p>Timeout to wait when reordering received
packets.</p></td>
</tr>
<tr class="row-odd"><td><p>L2SPEC_TYPE</p></td>
<td><p>N</p></td>
<td><p>Sets layer2-specific-sublayer type (L2TPv3
only).</p></td>
</tr>
<tr class="row-even"><td><p>COOKIE</p></td>
<td><p>N</p></td>
<td><p>Sets optional cookie (L2TPv3 only).</p></td>
</tr>
<tr class="row-odd"><td><p>PEER_COOKIE</p></td>
<td><p>N</p></td>
<td><p>Sets optional peer cookie (L2TPv3 only).</p></td>
</tr>
<tr class="row-even"><td><p>IFNAME</p></td>
<td><p>N</p></td>
<td><p>Sets interface name (L2TPv3 only).</p></td>
</tr>
</tbody>
</table>
<p>For Ethernet session types, this will create an l2tpeth virtual
interface which can then be configured as required. For PPP session
types, a PPPoL2TP socket must also be opened and connected, mapping it
onto the new session. This is covered in “PPPoL2TP Sockets” later.</p>
<p><code class="docutils literal notranslate"><span class="pre">L2TP_CMD_SESSION_DESTROY</span></code> attributes:-</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 11%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CONN_ID</p></td>
<td><p>Y</p></td>
<td><p>Identifies the parent tunnel id of the session
to be destroyed.</p></td>
</tr>
<tr class="row-odd"><td><p>SESSION_ID</p></td>
<td><p>Y</p></td>
<td><p>Identifies the session id to be destroyed.</p></td>
</tr>
<tr class="row-even"><td><p>IFNAME</p></td>
<td><p>N</p></td>
<td><p>Identifies the session by interface name. If
set, this overrides any CONN_ID and SESSION_ID
attributes. Currently supported for L2TPv3
Ethernet sessions only.</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">L2TP_CMD_SESSION_MODIFY</span></code> attributes:-</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 11%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CONN_ID</p></td>
<td><p>Y</p></td>
<td><p>Identifies the parent tunnel id of the session
to be modified.</p></td>
</tr>
<tr class="row-odd"><td><p>SESSION_ID</p></td>
<td><p>Y</p></td>
<td><p>Identifies the session id to be modified.</p></td>
</tr>
<tr class="row-even"><td><p>IFNAME</p></td>
<td><p>N</p></td>
<td><p>Identifies the session by interface name. If
set, this overrides any CONN_ID and SESSION_ID
attributes. Currently supported for L2TPv3
Ethernet sessions only.</p></td>
</tr>
<tr class="row-odd"><td><p>DEBUG</p></td>
<td><p>N</p></td>
<td><p>Debug flags.</p></td>
</tr>
<tr class="row-even"><td><p>RECV_SEQ</p></td>
<td><p>N</p></td>
<td><p>Enable rx data sequence numbers.</p></td>
</tr>
<tr class="row-odd"><td><p>SEND_SEQ</p></td>
<td><p>N</p></td>
<td><p>Enable tx data sequence numbers.</p></td>
</tr>
<tr class="row-even"><td><p>LNS_MODE</p></td>
<td><p>N</p></td>
<td><p>Enable LNS mode (auto-enable data sequence
numbers).</p></td>
</tr>
<tr class="row-odd"><td><p>RECV_TIMEOUT</p></td>
<td><p>N</p></td>
<td><p>Timeout to wait when reordering received
packets.</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">L2TP_CMD_SESSION_GET</span></code> attributes:-</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 12%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Required</p></th>
<th class="head"><p>Use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CONN_ID</p></td>
<td><p>N</p></td>
<td><p>Identifies the tunnel id to be queried.
Ignored for DUMP requests.</p></td>
</tr>
<tr class="row-odd"><td><p>SESSION_ID</p></td>
<td><p>N</p></td>
<td><p>Identifies the session id to be queried.
Ignored for DUMP requests.</p></td>
</tr>
<tr class="row-even"><td><p>IFNAME</p></td>
<td><p>N</p></td>
<td><p>Identifies the session by interface name.
If set, this overrides any CONN_ID and
SESSION_ID attributes. Ignored for DUMP
requests. Currently supported for L2TPv3
Ethernet sessions only.</p></td>
</tr>
</tbody>
</table>
<p>Application developers should refer to <a class="reference external" href="../../../include/uapi/linux/l2tp.h">include/uapi/linux/l2tp.h</a> for
netlink command and attribute definitions.</p>
<p>Sample userspace code using <a class="reference external" href="https://www.netfilter.org/projects/libmnl">libmnl</a>:</p>
<blockquote>
<div><ul>
<li><p>Open L2TP netlink socket:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nl_sock *nl_sock;
int l2tp_nl_family_id;

nl_sock = nl_socket_alloc();
genl_connect(nl_sock);
genl_id = genl_ctrl_resolve(nl_sock, L2TP_GENL_NAME);
</pre></div>
</div>
</li>
<li><p>Create a tunnel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nlmsghdr *nlh;
struct genlmsghdr *gnlh;

nlh = mnl_nlmsg_put_header(buf);
nlh-&gt;nlmsg_type = genl_id; /* assigned to genl socket */
nlh-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
nlh-&gt;nlmsg_seq = seq;

gnlh = mnl_nlmsg_put_extra_header(nlh, sizeof(*gnlh));
gnlh-&gt;cmd = L2TP_CMD_TUNNEL_CREATE;
gnlh-&gt;version = L2TP_GENL_VERSION;
gnlh-&gt;reserved = 0;

mnl_attr_put_u32(nlh, L2TP_ATTR_FD, tunl_sock_fd);
mnl_attr_put_u32(nlh, L2TP_ATTR_CONN_ID, tid);
mnl_attr_put_u32(nlh, L2TP_ATTR_PEER_CONN_ID, peer_tid);
mnl_attr_put_u8(nlh, L2TP_ATTR_PROTO_VERSION, protocol_version);
mnl_attr_put_u16(nlh, L2TP_ATTR_ENCAP_TYPE, encap);
</pre></div>
</div>
</li>
<li><p>Create a session:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nlmsghdr *nlh;
struct genlmsghdr *gnlh;

nlh = mnl_nlmsg_put_header(buf);
nlh-&gt;nlmsg_type = genl_id; /* assigned to genl socket */
nlh-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
nlh-&gt;nlmsg_seq = seq;

gnlh = mnl_nlmsg_put_extra_header(nlh, sizeof(*gnlh));
gnlh-&gt;cmd = L2TP_CMD_SESSION_CREATE;
gnlh-&gt;version = L2TP_GENL_VERSION;
gnlh-&gt;reserved = 0;

mnl_attr_put_u32(nlh, L2TP_ATTR_CONN_ID, tid);
mnl_attr_put_u32(nlh, L2TP_ATTR_PEER_CONN_ID, peer_tid);
mnl_attr_put_u32(nlh, L2TP_ATTR_SESSION_ID, sid);
mnl_attr_put_u32(nlh, L2TP_ATTR_PEER_SESSION_ID, peer_sid);
mnl_attr_put_u16(nlh, L2TP_ATTR_PW_TYPE, pwtype);
/* there are other session options which can be set using netlink
 * attributes during session creation -- see l2tp.h
 */
</pre></div>
</div>
</li>
<li><p>Delete a session:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nlmsghdr *nlh;
struct genlmsghdr *gnlh;

nlh = mnl_nlmsg_put_header(buf);
nlh-&gt;nlmsg_type = genl_id; /* assigned to genl socket */
nlh-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
nlh-&gt;nlmsg_seq = seq;

gnlh = mnl_nlmsg_put_extra_header(nlh, sizeof(*gnlh));
gnlh-&gt;cmd = L2TP_CMD_SESSION_DELETE;
gnlh-&gt;version = L2TP_GENL_VERSION;
gnlh-&gt;reserved = 0;

mnl_attr_put_u32(nlh, L2TP_ATTR_CONN_ID, tid);
mnl_attr_put_u32(nlh, L2TP_ATTR_SESSION_ID, sid);
</pre></div>
</div>
</li>
<li><p>Delete a tunnel and all of its sessions (if any):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct nlmsghdr *nlh;
struct genlmsghdr *gnlh;

nlh = mnl_nlmsg_put_header(buf);
nlh-&gt;nlmsg_type = genl_id; /* assigned to genl socket */
nlh-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
nlh-&gt;nlmsg_seq = seq;

gnlh = mnl_nlmsg_put_extra_header(nlh, sizeof(*gnlh));
gnlh-&gt;cmd = L2TP_CMD_TUNNEL_DELETE;
gnlh-&gt;version = L2TP_GENL_VERSION;
gnlh-&gt;reserved = 0;

mnl_attr_put_u32(nlh, L2TP_ATTR_CONN_ID, tid);
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</section>
<section id="pppol2tp-session-socket-api">
<h3>PPPoL2TP Session Socket API<a class="headerlink" href="#pppol2tp-session-socket-api" title="Permalink to this headline">¶</a></h3>
<p>For PPP session types, a PPPoL2TP socket must be opened and connected
to the L2TP session.</p>
<p>When creating PPPoL2TP sockets, the application provides information
to the kernel about the tunnel and session in a socket connect()
call. Source and destination tunnel and session ids are provided, as
well as the file descriptor of a UDP or L2TPIP socket. See struct
pppol2tp_addr in <a class="reference external" href="../../../include/linux/if_pppol2tp.h">include/linux/if_pppol2tp.h</a>. For historical reasons,
there are unfortunately slightly different address structures for
L2TPv2/L2TPv3 IPv4/IPv6 tunnels and userspace must use the appropriate
structure that matches the tunnel socket type.</p>
<p>Userspace may control behavior of the tunnel or session using
setsockopt and ioctl on the PPPoX socket. The following socket
options are supported:-</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>DEBUG</p></td>
<td><p>bitmask of debug message categories. See below.</p></td>
</tr>
<tr class="row-even"><td><p>SENDSEQ</p></td>
<td><ul class="simple">
<li><p>0 =&gt; don’t send packets with sequence numbers</p></li>
<li><p>1 =&gt; send packets with sequence numbers</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>RECVSEQ</p></td>
<td><ul class="simple">
<li><p>0 =&gt; receive packet sequence numbers are optional</p></li>
<li><p>1 =&gt; drop receive packets without sequence numbers</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>LNSMODE</p></td>
<td><ul class="simple">
<li><p>0 =&gt; act as LAC.</p></li>
<li><p>1 =&gt; act as LNS.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>REORDERTO</p></td>
<td><p>reorder timeout (in millisecs). If 0, don’t try to reorder.</p></td>
</tr>
</tbody>
</table>
<p>In addition to the standard PPP ioctls, a PPPIOCGL2TPSTATS is provided
to retrieve tunnel and session statistics from the kernel using the
PPPoX socket of the appropriate tunnel or session.</p>
<p>Sample userspace code:</p>
<blockquote>
<div><ul>
<li><p>Create session PPPoX data socket:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sockaddr_pppol2tp sax;
int fd;

/* Note, the tunnel socket must be bound already, else it
 * will not be ready
 */
sax.sa_family = AF_PPPOX;
sax.sa_protocol = PX_PROTO_OL2TP;
sax.pppol2tp.fd = tunnel_fd;
sax.pppol2tp.addr.sin_addr.s_addr = addr-&gt;sin_addr.s_addr;
sax.pppol2tp.addr.sin_port = addr-&gt;sin_port;
sax.pppol2tp.addr.sin_family = AF_INET;
sax.pppol2tp.s_tunnel  = tunnel_id;
sax.pppol2tp.s_session = session_id;
sax.pppol2tp.d_tunnel  = peer_tunnel_id;
sax.pppol2tp.d_session = peer_session_id;

/* session_fd is the fd of the session&#39;s PPPoL2TP socket.
 * tunnel_fd is the fd of the tunnel UDP / L2TPIP socket.
 */
fd = connect(session_fd, (struct sockaddr *)&amp;sax, sizeof(sax));
if (fd &lt; 0 ) {
        return -errno;
}
return 0;
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</section>
<section id="old-l2tpv2-only-api">
<h3>Old L2TPv2-only API<a class="headerlink" href="#old-l2tpv2-only-api" title="Permalink to this headline">¶</a></h3>
<p>When L2TP was first added to the Linux kernel in 2.6.23, it
implemented only L2TPv2 and did not include a netlink API. Instead,
tunnel and session instances in the kernel were managed directly using
only PPPoL2TP sockets. The PPPoL2TP socket is used as described in
section “PPPoL2TP Session Socket API” but tunnel and session instances
are automatically created on a connect() of the socket instead of
being created by a separate netlink request:</p>
<blockquote>
<div><ul class="simple">
<li><p>Tunnels are managed using a tunnel management socket which is a
dedicated PPPoL2TP socket, connected to (invalid) session
id 0. The L2TP tunnel instance is created when the PPPoL2TP
tunnel management socket is connected and is destroyed when the
socket is closed.</p></li>
<li><p>Session instances are created in the kernel when a PPPoL2TP
socket is connected to a non-zero session id. Session parameters
are set using setsockopt. The L2TP session instance is destroyed
when the socket is closed.</p></li>
</ul>
</div></blockquote>
<p>This API is still supported but its use is discouraged. Instead, new
L2TPv2 applications should use netlink to first create the tunnel and
session, then create a PPPoL2TP socket for the session.</p>
</section>
<section id="unmanaged-l2tpv3-tunnels">
<h3>Unmanaged L2TPv3 tunnels<a class="headerlink" href="#unmanaged-l2tpv3-tunnels" title="Permalink to this headline">¶</a></h3>
<p>The kernel L2TP subsystem also supports static (unmanaged) L2TPv3
tunnels. Unmanaged tunnels have no userspace tunnel socket, and
exchange no control messages with the peer to set up the tunnel; the
tunnel is configured manually at each end of the tunnel. All
configuration is done using netlink. There is no need for an L2TP
userspace application in this case – the tunnel socket is created by
the kernel and configured using parameters sent in the
<code class="docutils literal notranslate"><span class="pre">L2TP_CMD_TUNNEL_CREATE</span></code> netlink request. The <code class="docutils literal notranslate"><span class="pre">ip</span></code> utility of
<code class="docutils literal notranslate"><span class="pre">iproute2</span></code> has commands for managing static L2TPv3 tunnels; do <code class="docutils literal notranslate"><span class="pre">ip</span>
<span class="pre">l2tp</span> <span class="pre">help</span></code> for more information.</p>
</section>
<section id="debugging">
<h3>Debugging<a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h3>
<p>The L2TP subsystem offers a range of debugging interfaces through the
debugfs filesystem.</p>
<p>To access these interfaces, the debugfs filesystem must first be mounted:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># mount -t debugfs debugfs /debug
</pre></div>
</div>
<p>Files under the l2tp directory can then be accessed, providing a summary
of the current population of tunnel and session contexts existing in the
kernel:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># cat /debug/l2tp/tunnels
</pre></div>
</div>
<p>The debugfs files should not be used by applications to obtain L2TP
state information because the file format is subject to change. It is
implemented to provide extra debug information to help diagnose
problems. Applications should instead use the netlink API.</p>
<p>In addition the L2TP subsystem implements tracepoints using the standard
kernel event tracing API.  The available L2TP events can be reviewed as
follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># find /debug/tracing/events/l2tp
</pre></div>
</div>
<p>Finally, /proc/net/pppol2tp is also provided for backwards compatibility
with the original pppol2tp code. It lists information about L2TPv2
tunnels and sessions only. Its use is discouraged.</p>
</section>
</section>
<section id="internal-implementation">
<h2>Internal Implementation<a class="headerlink" href="#internal-implementation" title="Permalink to this headline">¶</a></h2>
<p>This section is for kernel developers and maintainers.</p>
<section id="sockets">
<h3>Sockets<a class="headerlink" href="#sockets" title="Permalink to this headline">¶</a></h3>
<p>UDP sockets are implemented by the networking core. When an L2TP
tunnel is created using a UDP socket, the socket is set up as an
encapsulated UDP socket by setting encap_rcv and encap_destroy
callbacks on the UDP socket. l2tp_udp_encap_recv is called when
packets are received on the socket. l2tp_udp_encap_destroy is called
when userspace closes the socket.</p>
<p>L2TPIP sockets are implemented in <a class="reference external" href="../../../net/l2tp/l2tp_ip.c">net/l2tp/l2tp_ip.c</a> and
<a class="reference external" href="../../../net/l2tp/l2tp_ip6.c">net/l2tp/l2tp_ip6.c</a>.</p>
</section>
<section id="tunnels">
<h3>Tunnels<a class="headerlink" href="#tunnels" title="Permalink to this headline">¶</a></h3>
<p>The kernel keeps a struct l2tp_tunnel context per L2TP tunnel. The
l2tp_tunnel is always associated with a UDP or L2TP/IP socket and
keeps a list of sessions in the tunnel. When a tunnel is first
registered with L2TP core, the reference count on the socket is
increased. This ensures that the socket cannot be removed while L2TP’s
data structures reference it.</p>
<p>Tunnels are identified by a unique tunnel id. The id is 16-bit for
L2TPv2 and 32-bit for L2TPv3. Internally, the id is stored as a 32-bit
value.</p>
<p>Tunnels are kept in a per-net list, indexed by tunnel id. The tunnel
id namespace is shared by L2TPv2 and L2TPv3. The tunnel context can be
derived from the socket’s sk_user_data.</p>
<p>Handling tunnel socket close is perhaps the most tricky part of the
L2TP implementation. If userspace closes a tunnel socket, the L2TP
tunnel and all of its sessions must be closed and destroyed. Since the
tunnel context holds a ref on the tunnel socket, the socket’s
sk_destruct won’t be called until the tunnel sock_put’s its
socket. For UDP sockets, when userspace closes the tunnel socket, the
socket’s encap_destroy handler is invoked, which L2TP uses to initiate
its tunnel close actions. For L2TPIP sockets, the socket’s close
handler initiates the same tunnel close actions. All sessions are
first closed. Each session drops its tunnel ref. When the tunnel ref
reaches zero, the tunnel puts its socket ref. When the socket is
eventually destroyed, its sk_destruct finally frees the L2TP tunnel
context.</p>
</section>
<section id="sessions">
<h3>Sessions<a class="headerlink" href="#sessions" title="Permalink to this headline">¶</a></h3>
<p>The kernel keeps a struct l2tp_session context for each session.  Each
session has private data which is used for data specific to the
session type. With L2TPv2, the session always carries PPP
traffic. With L2TPv3, the session can carry Ethernet frames (Ethernet
pseudowire) or other data types such as PPP, ATM, HDLC or Frame
Relay. Linux currently implements only Ethernet and PPP session types.</p>
<p>Some L2TP session types also have a socket (PPP pseudowires) while
others do not (Ethernet pseudowires). We can’t therefore use the
socket reference count as the reference count for session
contexts. The L2TP implementation therefore has its own internal
reference counts on the session contexts.</p>
<p>Like tunnels, L2TP sessions are identified by a unique
session id. Just as with tunnel ids, the session id is 16-bit for
L2TPv2 and 32-bit for L2TPv3. Internally, the id is stored as a 32-bit
value.</p>
<p>Sessions hold a ref on their parent tunnel to ensure that the tunnel
stays extant while one or more sessions references it.</p>
<p>Sessions are kept in a per-tunnel list, indexed by session id. L2TPv3
sessions are also kept in a per-net list indexed by session id,
because L2TPv3 session ids are unique across all tunnels and L2TPv3
data packets do not contain a tunnel id in the header. This list is
therefore needed to find the session context associated with a
received data packet when the tunnel context cannot be derived from
the tunnel socket.</p>
<p>Although the L2TPv3 RFC specifies that L2TPv3 session ids are not
scoped by the tunnel, the kernel does not police this for L2TPv3 UDP
tunnels and does not add sessions of L2TPv3 UDP tunnels into the
per-net session list. In the UDP receive code, we must trust that the
tunnel can be identified using the tunnel socket’s sk_user_data and
lookup the session in the tunnel’s session list instead of the per-net
session list.</p>
</section>
<section id="ppp">
<h3>PPP<a class="headerlink" href="#ppp" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="../../../net/l2tp/l2tp_ppp.c">net/l2tp/l2tp_ppp.c</a> implements the PPPoL2TP socket family. Each PPP
session has a PPPoL2TP socket.</p>
<p>The PPPoL2TP socket’s sk_user_data references the l2tp_session.</p>
<p>Userspace sends and receives PPP packets over L2TP using a PPPoL2TP
socket. Only PPP control frames pass over this socket: PPP data
packets are handled entirely by the kernel, passing between the L2TP
session and its associated <code class="docutils literal notranslate"><span class="pre">pppN</span></code> netdev through the PPP channel
interface of the kernel PPP subsystem.</p>
<p>The L2TP PPP implementation handles the closing of a PPPoL2TP socket
by closing its corresponding L2TP session. This is complicated because
it must consider racing with netlink session create/destroy requests
and pppol2tp_connect trying to reconnect with a session that is in the
process of being closed. Unlike tunnels, PPP sessions do not hold a
ref on their associated socket, so code must be careful to sock_hold
the socket where necessary. For all the details, see commit
3d609342cc04129ff7568e19316ce3d7451a27e8.</p>
</section>
<section id="ethernet">
<h3>Ethernet<a class="headerlink" href="#ethernet" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="../../../net/l2tp/l2tp_eth.c">net/l2tp/l2tp_eth.c</a> implements L2TPv3 Ethernet pseudowires. It
manages a netdev for each session.</p>
<p>L2TP Ethernet sessions are created and destroyed by netlink request,
or are destroyed when the tunnel is destroyed. Unlike PPP sessions,
Ethernet sessions do not have an associated socket.</p>
</section>
</section>
<section id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<section id="rfcs">
<h3>RFCs<a class="headerlink" href="#rfcs" title="Permalink to this headline">¶</a></h3>
<p>The kernel code implements the datapath features specified in the
following RFCs:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 26%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>RFC2661</p></td>
<td><p>L2TPv2</p></td>
<td><p><a class="reference external" href="https://tools.ietf.org/html/rfc2661">https://tools.ietf.org/html/rfc2661</a></p></td>
</tr>
<tr class="row-even"><td><p>RFC3931</p></td>
<td><p>L2TPv3</p></td>
<td><p><a class="reference external" href="https://tools.ietf.org/html/rfc3931">https://tools.ietf.org/html/rfc3931</a></p></td>
</tr>
<tr class="row-odd"><td><p>RFC4719</p></td>
<td><p>L2TPv3 Ethernet</p></td>
<td><p><a class="reference external" href="https://tools.ietf.org/html/rfc4719">https://tools.ietf.org/html/rfc4719</a></p></td>
</tr>
</tbody>
</table>
</section>
<section id="implementations">
<h3>Implementations<a class="headerlink" href="#implementations" title="Permalink to this headline">¶</a></h3>
<p>A number of open source applications use the L2TP kernel subsystem:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 79%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>iproute2</p></td>
<td><p><a class="reference external" href="https://github.com/shemminger/iproute2">https://github.com/shemminger/iproute2</a></p></td>
</tr>
<tr class="row-even"><td><p>go-l2tp</p></td>
<td><p><a class="reference external" href="https://github.com/katalix/go-l2tp">https://github.com/katalix/go-l2tp</a></p></td>
</tr>
<tr class="row-odd"><td><p>tunneldigger</p></td>
<td><p><a class="reference external" href="https://github.com/wlanslovenija/tunneldigger">https://github.com/wlanslovenija/tunneldigger</a></p></td>
</tr>
<tr class="row-even"><td><p>xl2tpd</p></td>
<td><p><a class="reference external" href="https://github.com/xelerance/xl2tpd">https://github.com/xelerance/xl2tpd</a></p></td>
</tr>
</tbody>
</table>
</section>
<section id="limitations">
<h3>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h3>
<p>The current implementation has a number of limitations:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Multiple UDP sockets with the same 5-tuple address cannot be
used. The kernel’s tunnel context is identified using private
data associated with the socket so it is important that each
socket is uniquely identified by its address.</p></li>
<li><p>Interfacing with openvswitch is not yet implemented. It may be
useful to map OVS Ethernet and VLAN ports into L2TPv3 tunnels.</p></li>
<li><p>VLAN pseudowires are implemented using an <code class="docutils literal notranslate"><span class="pre">l2tpethN</span></code> interface
configured with a VLAN sub-interface. Since L2TPv3 VLAN
pseudowires carry one and only one VLAN, it may be better to use
a single netdevice rather than an <code class="docutils literal notranslate"><span class="pre">l2tpethN</span></code> and <code class="docutils literal notranslate"><span class="pre">l2tpethN</span></code>:M
pair per VLAN session. The netlink attribute
<code class="docutils literal notranslate"><span class="pre">L2TP_ATTR_VLAN_ID</span></code> was added for this, but it was never
implemented.</p></li>
</ol>
</div></blockquote>
</section>
<section id="testing">
<h3>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h3>
<p>Unmanaged L2TPv3 Ethernet features are tested by the kernel’s built-in
selftests. See <a class="reference external" href="../../../tools/testing/selftests/net/l2tp.sh">tools/testing/selftests/net/l2tp.sh</a>.</p>
<p>Another test suite, <a class="reference external" href="https://github.com/katalix/l2tp-ktest">l2tp-ktest</a>, covers all
of the L2TP APIs and tunnel/session types. This may be integrated into
the kernel’s built-in L2TP selftests in the future.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">L2TP</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#l2tp-apis">L2TP APIs</a><ul>
<li><a class="reference internal" href="#tunnel-sockets">Tunnel Sockets</a></li>
<li><a class="reference internal" href="#netlink-api">Netlink API</a></li>
<li><a class="reference internal" href="#pppol2tp-session-socket-api">PPPoL2TP Session Socket API</a></li>
<li><a class="reference internal" href="#old-l2tpv2-only-api">Old L2TPv2-only API</a></li>
<li><a class="reference internal" href="#unmanaged-l2tpv3-tunnels">Unmanaged L2TPv3 tunnels</a></li>
<li><a class="reference internal" href="#debugging">Debugging</a></li>
</ul>
</li>
<li><a class="reference internal" href="#internal-implementation">Internal Implementation</a><ul>
<li><a class="reference internal" href="#sockets">Sockets</a></li>
<li><a class="reference internal" href="#tunnels">Tunnels</a></li>
<li><a class="reference internal" href="#sessions">Sessions</a></li>
<li><a class="reference internal" href="#ppp">PPP</a></li>
<li><a class="reference internal" href="#ethernet">Ethernet</a></li>
</ul>
</li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a><ul>
<li><a class="reference internal" href="#rfcs">RFCs</a></li>
<li><a class="reference internal" href="#implementations">Implementations</a></li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
<li><a class="reference internal" href="#testing">Testing</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/networking/l2tp.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/networking/l2tp.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>