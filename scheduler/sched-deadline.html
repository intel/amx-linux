
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Deadline Task Scheduling &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="CFS Scheduler" href="sched-design-CFS.html" />
    <link rel="prev" title="CFS Bandwidth Control" href="sched-bwc.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="deadline-task-scheduling">
<h1>Deadline Task Scheduling<a class="headerlink" href="#deadline-task-scheduling" title="Permalink to this headline">¶</a></h1>
<section id="warning">
<h2>0. WARNING<a class="headerlink" href="#warning" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Fiddling with these settings can result in an unpredictable or even unstable
system behavior. As for -rt (group) scheduling, it is assumed that root users
know what they’re doing.</p>
</div></blockquote>
</section>
<section id="overview">
<h2>1. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The SCHED_DEADLINE policy contained inside the sched_dl scheduling class is
basically an implementation of the Earliest Deadline First (EDF) scheduling
algorithm, augmented with a mechanism (called Constant Bandwidth Server, CBS)
that makes it possible to isolate the behavior of tasks between each other.</p>
</div></blockquote>
</section>
<section id="scheduling-algorithm">
<h2>2. Scheduling algorithm<a class="headerlink" href="#scheduling-algorithm" title="Permalink to this headline">¶</a></h2>
<section id="main-algorithm">
<h3>2.1 Main algorithm<a class="headerlink" href="#main-algorithm" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>SCHED_DEADLINE [18] uses three parameters, named “runtime”, “period”, and
“deadline”, to schedule tasks. A SCHED_DEADLINE task should receive
“runtime” microseconds of execution time every “period” microseconds, and
these “runtime” microseconds are available within “deadline” microseconds
from the beginning of the period.  In order to implement this behavior,
every time the task wakes up, the scheduler computes a “scheduling deadline”
consistent with the guarantee (using the CBS[2,3] algorithm). Tasks are then
scheduled using EDF[1] on these scheduling deadlines (the task with the
earliest scheduling deadline is selected for execution). Notice that the
task actually receives “runtime” time units within “deadline” if a proper
“admission control” strategy (see Section “4. Bandwidth management”) is used
(clearly, if the system is overloaded this guarantee cannot be respected).</p>
<p>Summing up, the CBS[2,3] algorithm assigns scheduling deadlines to tasks so
that each task runs for at most its runtime every period, avoiding any
interference between different tasks (bandwidth isolation), while the EDF[1]
algorithm selects the task with the earliest scheduling deadline as the one
to be executed next. Thanks to this feature, tasks that do not strictly comply
with the “traditional” real-time task model (see Section 3) can effectively
use the new policy.</p>
<p>In more details, the CBS algorithm assigns scheduling deadlines to
tasks in the following way:</p>
<blockquote>
<div><ul>
<li><p>Each SCHED_DEADLINE task is characterized by the “runtime”,
“deadline”, and “period” parameters;</p></li>
<li><p>The state of the task is described by a “scheduling deadline”, and
a “remaining runtime”. These two parameters are initially set to 0;</p></li>
<li><p>When a SCHED_DEADLINE task wakes up (becomes ready for execution),
the scheduler checks if:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>         remaining runtime                  runtime
----------------------------------    &gt;    ---------
scheduling deadline - current time           period
</pre></div>
</div>
<p>then, if the scheduling deadline is smaller than the current time, or
this condition is verified, the scheduling deadline and the
remaining runtime are re-initialized as</p>
<blockquote>
<div><p>scheduling deadline = current time + deadline
remaining runtime = runtime</p>
</div></blockquote>
<p>otherwise, the scheduling deadline and the remaining runtime are
left unchanged;</p>
</li>
<li><p>When a SCHED_DEADLINE task executes for an amount of time t, its
remaining runtime is decreased as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>remaining runtime = remaining runtime - t
</pre></div>
</div>
<p>(technically, the runtime is decreased at every tick, or when the
task is descheduled / preempted);</p>
</li>
<li><p>When the remaining runtime becomes less or equal than 0, the task is
said to be “throttled” (also known as “depleted” in real-time literature)
and cannot be scheduled until its scheduling deadline. The “replenishment
time” for this task (see next item) is set to be equal to the current
value of the scheduling deadline;</p></li>
<li><p>When the current time is equal to the replenishment time of a
throttled task, the scheduling deadline and the remaining runtime are
updated as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>scheduling deadline = scheduling deadline + period
remaining runtime = remaining runtime + runtime
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p>The SCHED_FLAG_DL_OVERRUN flag in sched_attr’s sched_flags field allows a task
to get informed about runtime overruns through the delivery of SIGXCPU
signals.</p>
</div></blockquote>
</section>
<section id="bandwidth-reclaiming">
<h3>2.2 Bandwidth reclaiming<a class="headerlink" href="#bandwidth-reclaiming" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Bandwidth reclaiming for deadline tasks is based on the GRUB (Greedy
Reclamation of Unused Bandwidth) algorithm [15, 16, 17] and it is enabled
when flag SCHED_FLAG_RECLAIM is set.</p>
<p>The following diagram illustrates the state names for tasks handled by GRUB:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                    ------------
        (d)        |   Active   |
     -------------&gt;|            |
     |             | Contending |
     |              ------------
     |                A      |
 ----------           |      |
|          |          |      |
| Inactive |          |(b)   | (a)
|          |          |      |
 ----------           |      |
     A                |      V
     |              ------------
     |             |   Active   |
     --------------|     Non    |
        (c)        | Contending |
                    ------------
</pre></div>
</div>
<p>A task can be in one of the following states:</p>
<blockquote>
<div><ul class="simple">
<li><p>ActiveContending: if it is ready for execution (or executing);</p></li>
<li><p>ActiveNonContending: if it just blocked and has not yet surpassed the 0-lag
time;</p></li>
<li><p>Inactive: if it is blocked and has surpassed the 0-lag time.</p></li>
</ul>
</div></blockquote>
<p>State transitions:</p>
<blockquote>
<div><ol class="loweralpha">
<li><p>When a task blocks, it does not become immediately inactive since its
bandwidth cannot be immediately reclaimed without breaking the
real-time guarantees. It therefore enters a transitional state called
ActiveNonContending. The scheduler arms the “inactive timer” to fire at
the 0-lag time, when the task’s bandwidth can be reclaimed without
breaking the real-time guarantees.</p>
<p>The 0-lag time for a task entering the ActiveNonContending state is
computed as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           (runtime * dl_period)
deadline - ---------------------
                dl_runtime
</pre></div>
</div>
<p>where runtime is the remaining runtime, while dl_runtime and dl_period
are the reservation parameters.</p>
</li>
<li><p>If the task wakes up before the inactive timer fires, the task re-enters
the ActiveContending state and the “inactive timer” is canceled.
In addition, if the task wakes up on a different runqueue, then
the task’s utilization must be removed from the previous runqueue’s active
utilization and must be added to the new runqueue’s active utilization.
In order to avoid races between a task waking up on a runqueue while the
“inactive timer” is running on a different CPU, the “dl_non_contending”
flag is used to indicate that a task is not on a runqueue but is active
(so, the flag is set when the task blocks and is cleared when the
“inactive timer” fires or when the task  wakes up).</p></li>
<li><p>When the “inactive timer” fires, the task enters the Inactive state and
its utilization is removed from the runqueue’s active utilization.</p></li>
<li><p>When an inactive task wakes up, it enters the ActiveContending state and
its utilization is added to the active utilization of the runqueue where
it has been enqueued.</p></li>
</ol>
</div></blockquote>
<p>For each runqueue, the algorithm GRUB keeps track of two different bandwidths:</p>
<blockquote>
<div><ul class="simple">
<li><p>Active bandwidth (running_bw): this is the sum of the bandwidths of all
tasks in active state (i.e., ActiveContending or ActiveNonContending);</p></li>
<li><p>Total bandwidth (this_bw): this is the sum of all tasks “belonging” to the
runqueue, including the tasks in Inactive state.</p></li>
</ul>
</div></blockquote>
<p>The algorithm reclaims the bandwidth of the tasks in Inactive state.
It does so by decrementing the runtime of the executing task Ti at a pace equal
to</p>
<blockquote>
<div><p>dq = -max{ Ui / Umax, (1 - Uinact - Uextra) } dt</p>
</div></blockquote>
<p>where:</p>
<blockquote>
<div><ul class="simple">
<li><p>Ui is the bandwidth of task Ti;</p></li>
<li><p>Umax is the maximum reclaimable utilization (subjected to RT throttling
limits);</p></li>
<li><p>Uinact is the (per runqueue) inactive utilization, computed as
(this_bq - running_bw);</p></li>
<li><p>Uextra is the (per runqueue) extra reclaimable utilization
(subjected to RT throttling limits).</p></li>
</ul>
</div></blockquote>
<p>Let’s now see a trivial example of two deadline tasks with runtime equal
to 4 and period equal to 8 (i.e., bandwidth equal to 0.5):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>       A            Task T1
       |
       |                               |
       |                               |
       |--------                       |----
       |       |                       V
       |---|---|---|---|---|---|---|---|---------&gt;t
       0   1   2   3   4   5   6   7   8


       A            Task T2
       |
       |                               |
       |                               |
       |       ------------------------|
       |       |                       V
       |---|---|---|---|---|---|---|---|---------&gt;t
       0   1   2   3   4   5   6   7   8


       A            running_bw
       |
     1 -----------------               ------
       |               |               |
    0.5-               -----------------
       |                               |
       |---|---|---|---|---|---|---|---|---------&gt;t
       0   1   2   3   4   5   6   7   8


- Time t = 0:

  Both tasks are ready for execution and therefore in ActiveContending state.
  Suppose Task T1 is the first task to start execution.
  Since there are no inactive tasks, its runtime is decreased as dq = -1 dt.

- Time t = 2:

  Suppose that task T1 blocks
  Task T1 therefore enters the ActiveNonContending state. Since its remaining
  runtime is equal to 2, its 0-lag time is equal to t = 4.
  Task T2 start execution, with runtime still decreased as dq = -1 dt since
  there are no inactive tasks.

- Time t = 4:

  This is the 0-lag time for Task T1. Since it didn&#39;t woken up in the
  meantime, it enters the Inactive state. Its bandwidth is removed from
  running_bw.
  Task T2 continues its execution. However, its runtime is now decreased as
  dq = - 0.5 dt because Uinact = 0.5.
  Task T2 therefore reclaims the bandwidth unused by Task T1.

- Time t = 8:

  Task T1 wakes up. It enters the ActiveContending state again, and the
  running_bw is incremented.
</pre></div>
</div>
</div></blockquote>
</section>
<section id="energy-aware-scheduling">
<h3>2.3 Energy-aware scheduling<a class="headerlink" href="#energy-aware-scheduling" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>When cpufreq’s schedutil governor is selected, SCHED_DEADLINE implements the
GRUB-PA [19] algorithm, reducing the CPU operating frequency to the minimum
value that still allows to meet the deadlines. This behavior is currently
implemented only for ARM architectures.</p>
<p>A particular care must be taken in case the time needed for changing frequency
is of the same order of magnitude of the reservation period. In such cases,
setting a fixed CPU frequency results in a lower amount of deadline misses.</p>
</div></blockquote>
</section>
</section>
<section id="scheduling-real-time-tasks">
<h2>3. Scheduling Real-Time Tasks<a class="headerlink" href="#scheduling-real-time-tasks" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This section contains a (not-thorough) summary on classical deadline
scheduling theory, and how it applies to SCHED_DEADLINE.
The reader can “safely” skip to Section 4 if only interested in seeing
how the scheduling policy can be used. Anyway, we strongly recommend
to come back here and continue reading (once the urge for testing is
satisfied :P) to be sure of fully understanding all technical details.</p>
</div>
<p>There are no limitations on what kind of task can exploit this new
scheduling discipline, even if it must be said that it is particularly
suited for periodic or sporadic real-time tasks that need guarantees on their
timing behavior, e.g., multimedia, streaming, control applications, etc.</p>
</div></blockquote>
<section id="definitions">
<h3>3.1 Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>A typical real-time task is composed of a repetition of computation phases
(task instances, or jobs) which are activated on a periodic or sporadic
fashion.
Each job J_j (where J_j is the j^th job of the task) is characterized by an
arrival time r_j (the time when the job starts), an amount of computation
time c_j needed to finish the job, and a job absolute deadline d_j, which
is the time within which the job should be finished. The maximum execution
time max{c_j} is called “Worst Case Execution Time” (WCET) for the task.
A real-time task can be periodic with period P if r_{j+1} = r_j + P, or
sporadic with minimum inter-arrival time P is r_{j+1} &gt;= r_j + P. Finally,
d_j = r_j + D, where D is the task’s relative deadline.
Summing up, a real-time task can be described as</p>
<blockquote>
<div><p>Task = (WCET, D, P)</p>
</div></blockquote>
<p>The utilization of a real-time task is defined as the ratio between its
WCET and its period (or minimum inter-arrival time), and represents
the fraction of CPU time needed to execute the task.</p>
<p>If the total utilization U=sum(WCET_i/P_i) is larger than M (with M equal
to the number of CPUs), then the scheduler is unable to respect all the
deadlines.
Note that total utilization is defined as the sum of the utilizations
WCET_i/P_i over all the real-time tasks in the system. When considering
multiple real-time tasks, the parameters of the i-th task are indicated
with the “_i” suffix.
Moreover, if the total utilization is larger than M, then we risk starving
non- real-time tasks by real-time tasks.
If, instead, the total utilization is smaller than M, then non real-time
tasks will not be starved and the system might be able to respect all the
deadlines.
As a matter of fact, in this case it is possible to provide an upper bound
for tardiness (defined as the maximum between 0 and the difference
between the finishing time of a job and its absolute deadline).
More precisely, it can be proven that using a global EDF scheduler the
maximum tardiness of each task is smaller or equal than</p>
<blockquote>
<div><p>((M − 1) · WCET_max − WCET_min)/(M − (M − 2) · U_max) + WCET_max</p>
</div></blockquote>
<p>where WCET_max = max{WCET_i} is the maximum WCET, WCET_min=min{WCET_i}
is the minimum WCET, and U_max = max{WCET_i/P_i} is the maximum
utilization[12].</p>
</div></blockquote>
</section>
<section id="schedulability-analysis-for-uniprocessor-systems">
<h3>3.2 Schedulability Analysis for Uniprocessor Systems<a class="headerlink" href="#schedulability-analysis-for-uniprocessor-systems" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>If M=1 (uniprocessor system), or in case of partitioned scheduling (each
real-time task is statically assigned to one and only one CPU), it is
possible to formally check if all the deadlines are respected.
If D_i = P_i for all tasks, then EDF is able to respect all the deadlines
of all the tasks executing on a CPU if and only if the total utilization
of the tasks running on such a CPU is smaller or equal than 1.
If D_i != P_i for some task, then it is possible to define the density of
a task as WCET_i/min{D_i,P_i}, and EDF is able to respect all the deadlines
of all the tasks running on a CPU if the sum of the densities of the tasks
running on such a CPU is smaller or equal than 1:</p>
<blockquote>
<div><p>sum(WCET_i / min{D_i, P_i}) &lt;= 1</p>
</div></blockquote>
<p>It is important to notice that this condition is only sufficient, and not
necessary: there are task sets that are schedulable, but do not respect the
condition. For example, consider the task set {Task_1,Task_2} composed by
Task_1=(50ms,50ms,100ms) and Task_2=(10ms,100ms,100ms).
EDF is clearly able to schedule the two tasks without missing any deadline
(Task_1 is scheduled as soon as it is released, and finishes just in time
to respect its deadline; Task_2 is scheduled immediately after Task_1, hence
its response time cannot be larger than 50ms + 10ms = 60ms) even if</p>
<blockquote>
<div><p>50 / min{50,100} + 10 / min{100, 100} = 50 / 50 + 10 / 100 = 1.1</p>
</div></blockquote>
<p>Of course it is possible to test the exact schedulability of tasks with
D_i != P_i (checking a condition that is both sufficient and necessary),
but this cannot be done by comparing the total utilization or density with
a constant. Instead, the so called “processor demand” approach can be used,
computing the total amount of CPU time h(t) needed by all the tasks to
respect all of their deadlines in a time interval of size t, and comparing
such a time with the interval size t. If h(t) is smaller than t (that is,
the amount of time needed by the tasks in a time interval of size t is
smaller than the size of the interval) for all the possible values of t, then
EDF is able to schedule the tasks respecting all of their deadlines. Since
performing this check for all possible values of t is impossible, it has been
proven[4,5,6] that it is sufficient to perform the test for values of t
between 0 and a maximum value L. The cited papers contain all of the
mathematical details and explain how to compute h(t) and L.
In any case, this kind of analysis is too complex as well as too
time-consuming to be performed on-line. Hence, as explained in Section
4 Linux uses an admission test based on the tasks’ utilizations.</p>
</div></blockquote>
</section>
<section id="schedulability-analysis-for-multiprocessor-systems">
<h3>3.3 Schedulability Analysis for Multiprocessor Systems<a class="headerlink" href="#schedulability-analysis-for-multiprocessor-systems" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>On multiprocessor systems with global EDF scheduling (non partitioned
systems), a sufficient test for schedulability can not be based on the
utilizations or densities: it can be shown that even if D_i = P_i task
sets with utilizations slightly larger than 1 can miss deadlines regardless
of the number of CPUs.</p>
<p>Consider a set {Task_1,…Task_{M+1}} of M+1 tasks on a system with M
CPUs, with the first task Task_1=(P,P,P) having period, relative deadline
and WCET equal to P. The remaining M tasks Task_i=(e,P-1,P-1) have an
arbitrarily small worst case execution time (indicated as “e” here) and a
period smaller than the one of the first task. Hence, if all the tasks
activate at the same time t, global EDF schedules these M tasks first
(because their absolute deadlines are equal to t + P - 1, hence they are
smaller than the absolute deadline of Task_1, which is t + P). As a
result, Task_1 can be scheduled only at time t + e, and will finish at
time t + e + P, after its absolute deadline. The total utilization of the
task set is U = M · e / (P - 1) + P / P = M · e / (P - 1) + 1, and for small
values of e this can become very close to 1. This is known as “Dhall’s
effect”[7]. Note: the example in the original paper by Dhall has been
slightly simplified here (for example, Dhall more correctly computed
lim_{e-&gt;0}U).</p>
<p>More complex schedulability tests for global EDF have been developed in
real-time literature[8,9], but they are not based on a simple comparison
between total utilization (or density) and a fixed constant. If all tasks
have D_i = P_i, a sufficient schedulability condition can be expressed in
a simple way:</p>
<blockquote>
<div><p>sum(WCET_i / P_i) &lt;= M - (M - 1) · U_max</p>
</div></blockquote>
<p>where U_max = max{WCET_i / P_i}[10]. Notice that for U_max = 1,
M - (M - 1) · U_max becomes M - M + 1 = 1 and this schedulability condition
just confirms the Dhall’s effect. A more complete survey of the literature
about schedulability tests for multi-processor real-time scheduling can be
found in [11].</p>
<p>As seen, enforcing that the total utilization is smaller than M does not
guarantee that global EDF schedules the tasks without missing any deadline
(in other words, global EDF is not an optimal scheduling algorithm). However,
a total utilization smaller than M is enough to guarantee that non real-time
tasks are not starved and that the tardiness of real-time tasks has an upper
bound[12] (as previously noted). Different bounds on the maximum tardiness
experienced by real-time tasks have been developed in various papers[13,14],
but the theoretical result that is important for SCHED_DEADLINE is that if
the total utilization is smaller or equal than M then the response times of
the tasks are limited.</p>
</div></blockquote>
</section>
<section id="relationship-with-sched-deadline-parameters">
<h3>3.4 Relationship with SCHED_DEADLINE Parameters<a class="headerlink" href="#relationship-with-sched-deadline-parameters" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Finally, it is important to understand the relationship between the
SCHED_DEADLINE scheduling parameters described in Section 2 (runtime,
deadline and period) and the real-time task parameters (WCET, D, P)
described in this section. Note that the tasks’ temporal constraints are
represented by its absolute deadlines d_j = r_j + D described above, while
SCHED_DEADLINE schedules the tasks according to scheduling deadlines (see
Section 2).
If an admission test is used to guarantee that the scheduling deadlines
are respected, then SCHED_DEADLINE can be used to schedule real-time tasks
guaranteeing that all the jobs’ deadlines of a task are respected.
In order to do this, a task must be scheduled by setting:</p>
<blockquote>
<div><ul class="simple">
<li><p>runtime &gt;= WCET</p></li>
<li><p>deadline = D</p></li>
<li><p>period &lt;= P</p></li>
</ul>
</div></blockquote>
<p>IOW, if runtime &gt;= WCET and if period is &lt;= P, then the scheduling deadlines
and the absolute deadlines (d_j) coincide, so a proper admission control
allows to respect the jobs’ absolute deadlines for this task (this is what is
called “hard schedulability property” and is an extension of Lemma 1 of [2]).
Notice that if runtime &gt; deadline the admission control will surely reject
this task, as it is not possible to respect its temporal constraints.</p>
<p>References:</p>
<blockquote>
<div><dl class="simple">
<dt>1 - C. L. Liu and J. W. Layland. Scheduling algorithms for multiprogram-</dt><dd><p>ming in a hard-real-time environment. Journal of the Association for
Computing Machinery, 20(1), 1973.</p>
</dd>
<dt>2 - L. Abeni , G. Buttazzo. Integrating Multimedia Applications in Hard</dt><dd><p>Real-Time Systems. Proceedings of the 19th IEEE Real-time Systems
Symposium, 1998. <a class="reference external" href="http://retis.sssup.it/~giorgio/paps/1998/rtss98-cbs.pdf">http://retis.sssup.it/~giorgio/paps/1998/rtss98-cbs.pdf</a></p>
</dd>
<dt>3 - L. Abeni. Server Mechanisms for Multimedia Applications. ReTiS Lab</dt><dd><p>Technical Report. <a class="reference external" href="http://disi.unitn.it/~abeni/tr-98-01.pdf">http://disi.unitn.it/~abeni/tr-98-01.pdf</a></p>
</dd>
<dt>4 - J. Y. Leung and M.L. Merril. A Note on Preemptive Scheduling of</dt><dd><p>Periodic, Real-Time Tasks. Information Processing Letters, vol. 11,
no. 3, pp. 115-118, 1980.</p>
</dd>
<dt>5 - S. K. Baruah, A. K. Mok and L. E. Rosier. Preemptively Scheduling</dt><dd><p>Hard-Real-Time Sporadic Tasks on One Processor. Proceedings of the
11th IEEE Real-time Systems Symposium, 1990.</p>
</dd>
<dt>6 - S. K. Baruah, L. E. Rosier and R. R. Howell. Algorithms and Complexity</dt><dd><p>Concerning the Preemptive Scheduling of Periodic Real-Time tasks on
One Processor. Real-Time Systems Journal, vol. 4, no. 2, pp 301-324,
1990.</p>
</dd>
<dt>7 - S. J. Dhall and C. L. Liu. On a real-time scheduling problem. Operations</dt><dd><p>research, vol. 26, no. 1, pp 127-140, 1978.</p>
</dd>
<dt>8 - T. Baker. Multiprocessor EDF and Deadline Monotonic Schedulability</dt><dd><p>Analysis. Proceedings of the 24th IEEE Real-Time Systems Symposium, 2003.</p>
</dd>
<dt>9 - T. Baker. An Analysis of EDF Schedulability on a Multiprocessor.</dt><dd><p>IEEE Transactions on Parallel and Distributed Systems, vol. 16, no. 8,
pp 760-768, 2005.</p>
</dd>
<dt>10 - J. Goossens, S. Funk and S. Baruah, Priority-Driven Scheduling of</dt><dd><p>Periodic Task Systems on Multiprocessors. Real-Time Systems Journal,
vol. 25, no. 2–3, pp. 187–205, 2003.</p>
</dd>
<dt>11 - R. Davis and A. Burns. A Survey of Hard Real-Time Scheduling for</dt><dd><p>Multiprocessor Systems. ACM Computing Surveys, vol. 43, no. 4, 2011.
<a class="reference external" href="http://www-users.cs.york.ac.uk/~robdavis/papers/MPSurveyv5.0.pdf">http://www-users.cs.york.ac.uk/~robdavis/papers/MPSurveyv5.0.pdf</a></p>
</dd>
<dt>12 - U. C. Devi and J. H. Anderson. Tardiness Bounds under Global EDF</dt><dd><p>Scheduling on a Multiprocessor. Real-Time Systems Journal, vol. 32,
no. 2, pp 133-189, 2008.</p>
</dd>
<dt>13 - P. Valente and G. Lipari. An Upper Bound to the Lateness of Soft</dt><dd><p>Real-Time Tasks Scheduled by EDF on Multiprocessors. Proceedings of
the 26th IEEE Real-Time Systems Symposium, 2005.</p>
</dd>
<dt>14 - J. Erickson, U. Devi and S. Baruah. Improved tardiness bounds for</dt><dd><p>Global EDF. Proceedings of the 22nd Euromicro Conference on
Real-Time Systems, 2010.</p>
</dd>
<dt>15 - G. Lipari, S. Baruah, Greedy reclamation of unused bandwidth in</dt><dd><p>constant-bandwidth servers, 12th IEEE Euromicro Conference on Real-Time
Systems, 2000.</p>
</dd>
<dt>16 - L. Abeni, J. Lelli, C. Scordino, L. Palopoli, Greedy CPU reclaiming for</dt><dd><p>SCHED DEADLINE. In Proceedings of the Real-Time Linux Workshop (RTLWS),
Dusseldorf, Germany, 2014.</p>
</dd>
<dt>17 - L. Abeni, G. Lipari, A. Parri, Y. Sun, Multicore CPU reclaiming: parallel</dt><dd><p>or sequential?. In Proceedings of the 31st Annual ACM Symposium on Applied
Computing, 2016.</p>
</dd>
<dt>18 - J. Lelli, C. Scordino, L. Abeni, D. Faggioli, Deadline scheduling in the</dt><dd><p>Linux kernel, Software: Practice and Experience, 46(6): 821-839, June
2016.</p>
</dd>
<dt>19 - C. Scordino, L. Abeni, J. Lelli, Energy-Aware Real-Time Scheduling in</dt><dd><p>the Linux Kernel, 33rd ACM/SIGAPP Symposium On Applied Computing (SAC
2018), Pau, France, April 2018.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</section>
</section>
<section id="bandwidth-management">
<h2>4. Bandwidth management<a class="headerlink" href="#bandwidth-management" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>As previously mentioned, in order for -deadline scheduling to be
effective and useful (that is, to be able to provide “runtime” time units
within “deadline”), it is important to have some method to keep the allocation
of the available fractions of CPU time to the various tasks under control.
This is usually called “admission control” and if it is not performed, then
no guarantee can be given on the actual scheduling of the -deadline tasks.</p>
<p>As already stated in Section 3, a necessary condition to be respected to
correctly schedule a set of real-time tasks is that the total utilization
is smaller than M. When talking about -deadline tasks, this requires that
the sum of the ratio between runtime and period for all tasks is smaller
than M. Notice that the ratio runtime/period is equivalent to the utilization
of a “traditional” real-time task, and is also often referred to as
“bandwidth”.
The interface used to control the CPU bandwidth that can be allocated
to -deadline tasks is similar to the one already used for -rt
tasks with real-time group scheduling (a.k.a. RT-throttling - see
<a class="reference internal" href="sched-rt-group.html"><span class="doc">Real-Time group scheduling</span></a>), and is based on readable/
writable control files located in procfs (for system wide settings).
Notice that per-group settings (controlled through cgroupfs) are still not
defined for -deadline tasks, because more discussion is needed in order to
figure out how we want to manage SCHED_DEADLINE bandwidth at the task group
level.</p>
<p>A main difference between deadline bandwidth management and RT-throttling
is that -deadline tasks have bandwidth on their own (while -rt ones don’t!),
and thus we don’t need a higher level throttling mechanism to enforce the
desired bandwidth. In other words, this means that interface parameters are
only used at admission control time (i.e., when the user calls
sched_setattr()). Scheduling is then performed considering actual tasks’
parameters, so that CPU bandwidth is allocated to SCHED_DEADLINE tasks
respecting their needs in terms of granularity. Therefore, using this simple
interface we can put a cap on total utilization of -deadline tasks (i.e.,
Sum (runtime_i / period_i) &lt; global_dl_utilization_cap).</p>
</div></blockquote>
<section id="system-wide-settings">
<h3>4.1 System wide settings<a class="headerlink" href="#system-wide-settings" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The system wide settings are configured under the /proc virtual file system.</p>
<p>For now the -rt knobs are used for -deadline admission control and the
-deadline runtime is accounted against the -rt runtime. We realize that this
isn’t entirely desirable; however, it is better to have a small interface for
now, and be able to change it easily later. The ideal situation (see 5.) is to
run -rt tasks from a -deadline server; in which case the -rt bandwidth is a
direct subset of dl_bw.</p>
<p>This means that, for a root_domain comprising M CPUs, -deadline tasks
can be created while the sum of their bandwidths stays below:</p>
<blockquote>
<div><p>M * (sched_rt_runtime_us / sched_rt_period_us)</p>
</div></blockquote>
<p>It is also possible to disable this bandwidth management logic, and
be thus free of oversubscribing the system up to any arbitrary level.
This is done by writing -1 in /proc/sys/kernel/sched_rt_runtime_us.</p>
</div></blockquote>
</section>
<section id="task-interface">
<h3>4.2 Task interface<a class="headerlink" href="#task-interface" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Specifying a periodic/sporadic task that executes for a given amount of
runtime at each instance, and that is scheduled according to the urgency of
its own timing constraints needs, in general, a way of declaring:</p>
<blockquote>
<div><ul class="simple">
<li><p>a (maximum/typical) instance execution time,</p></li>
<li><p>a minimum interval between consecutive instances,</p></li>
<li><p>a time constraint by which each instance must be completed.</p></li>
</ul>
</div></blockquote>
<p>Therefore:</p>
<blockquote>
<div><ul class="simple">
<li><p>a new struct sched_attr, containing all the necessary fields is
provided;</p></li>
<li><p>the new scheduling related syscalls that manipulate it, i.e.,
sched_setattr() and sched_getattr() are implemented.</p></li>
</ul>
</div></blockquote>
<p>For debugging purposes, the leftover runtime and absolute deadline of a
SCHED_DEADLINE task can be retrieved through /proc/&lt;pid&gt;/sched (entries
dl.runtime and dl.deadline, both values in ns). A programmatic way to
retrieve these values from production code is under discussion.</p>
</div></blockquote>
</section>
<section id="default-behavior">
<h3>4.3 Default behavior<a class="headerlink" href="#default-behavior" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The default value for SCHED_DEADLINE bandwidth is to have rt_runtime equal to
950000. With rt_period equal to 1000000, by default, it means that -deadline
tasks can use at most 95%, multiplied by the number of CPUs that compose the
root_domain, for each root_domain.
This means that non -deadline tasks will receive at least 5% of the CPU time,
and that -deadline tasks will receive their runtime with a guaranteed
worst-case delay respect to the “deadline” parameter. If “deadline” = “period”
and the cpuset mechanism is used to implement partitioned scheduling (see
Section 5), then this simple setting of the bandwidth management is able to
deterministically guarantee that -deadline tasks will receive their runtime
in a period.</p>
<p>Finally, notice that in order not to jeopardize the admission control a
-deadline task cannot fork.</p>
</div></blockquote>
</section>
<section id="behavior-of-sched-yield">
<h3>4.4 Behavior of sched_yield()<a class="headerlink" href="#behavior-of-sched-yield" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>When a SCHED_DEADLINE task calls sched_yield(), it gives up its
remaining runtime and is immediately throttled, until the next
period, when its runtime will be replenished (a special flag
dl_yielded is set and used to handle correctly throttling and runtime
replenishment after a call to sched_yield()).</p>
<p>This behavior of sched_yield() allows the task to wake-up exactly at
the beginning of the next period. Also, this may be useful in the
future with bandwidth reclaiming mechanisms, where sched_yield() will
make the leftoever runtime available for reclamation by other
SCHED_DEADLINE tasks.</p>
</div></blockquote>
</section>
</section>
<section id="tasks-cpu-affinity">
<h2>5. Tasks CPU affinity<a class="headerlink" href="#tasks-cpu-affinity" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>-deadline tasks cannot have an affinity mask smaller that the entire
root_domain they are created on. However, affinities can be specified
through the cpuset facility (<a class="reference internal" href="../admin-guide/cgroup-v1/cpusets.html"><span class="doc">CPUSETS</span></a>).</p>
</div></blockquote>
<section id="sched-deadline-and-cpusets-howto">
<h3>5.1 SCHED_DEADLINE and cpusets HOWTO<a class="headerlink" href="#sched-deadline-and-cpusets-howto" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>An example of a simple configuration (pin a -deadline task to CPU0)
follows (rt-app is used to create a -deadline task):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mkdir /dev/cpuset
mount -t cgroup -o cpuset cpuset /dev/cpuset
cd /dev/cpuset
mkdir cpu0
echo 0 &gt; cpu0/cpuset.cpus
echo 0 &gt; cpu0/cpuset.mems
echo 1 &gt; cpuset.cpu_exclusive
echo 0 &gt; cpuset.sched_load_balance
echo 1 &gt; cpu0/cpuset.cpu_exclusive
echo 1 &gt; cpu0/cpuset.mem_exclusive
echo $$ &gt; cpu0/tasks
rt-app -t 100000:10000:d:0 -D5 # it is now actually superfluous to specify
                               # task affinity
</pre></div>
</div>
</div></blockquote>
</section>
</section>
<section id="future-plans">
<h2>6. Future plans<a class="headerlink" href="#future-plans" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Still missing:</p>
<blockquote>
<div><ul class="simple">
<li><p>programmatic way to retrieve current runtime and absolute deadline</p></li>
<li><p>refinements to deadline inheritance, especially regarding the possibility
of retaining bandwidth isolation among non-interacting tasks. This is
being studied from both theoretical and practical points of view, and
hopefully we should be able to produce some demonstrative code soon;</p></li>
<li><p>(c)group based bandwidth management, and maybe scheduling;</p></li>
<li><p>access control for non-root users (and related security concerns to
address), which is the best way to allow unprivileged use of the mechanisms
and how to prevent non-root users “cheat” the system?</p></li>
</ul>
</div></blockquote>
<p>As already discussed, we are planning also to merge this work with the EDF
throttling patches [<a class="reference external" href="https://lore.kernel.org/r/cover.1266931410.git.fabio&#64;helm.retis">https://lore.kernel.org/r/cover.1266931410.git.fabio&#64;helm.retis</a>] but we still are in
the preliminary phases of the merge and we really seek feedback that would
help us decide on the direction it should take.</p>
</div></blockquote>
</section>
<section id="appendix-a-test-suite">
<h2>Appendix A. Test suite<a class="headerlink" href="#appendix-a-test-suite" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The SCHED_DEADLINE policy can be easily tested using two applications that
are part of a wider Linux Scheduler validation suite. The suite is
available as a GitHub repository: <a class="reference external" href="https://github.com/scheduler-tools">https://github.com/scheduler-tools</a>.</p>
<p>The first testing application is called rt-app and can be used to
start multiple threads with specific parameters. rt-app supports
SCHED_{OTHER,FIFO,RR,DEADLINE} scheduling policies and their related
parameters (e.g., niceness, priority, runtime/deadline/period). rt-app
is a valuable tool, as it can be used to synthetically recreate certain
workloads (maybe mimicking real use-cases) and evaluate how the scheduler
behaves under such workloads. In this way, results are easily reproducible.
rt-app is available at: <a class="reference external" href="https://github.com/scheduler-tools/rt-app">https://github.com/scheduler-tools/rt-app</a>.</p>
<p>Thread parameters can be specified from the command line, with something like
this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># rt-app -t 100000:10000:d -t 150000:20000:f:10 -D5
</pre></div>
</div>
<p>The above creates 2 threads. The first one, scheduled by SCHED_DEADLINE,
executes for 10ms every 100ms. The second one, scheduled at SCHED_FIFO
priority 10, executes for 20ms every 150ms. The test will run for a total
of 5 seconds.</p>
<p>More interestingly, configurations can be described with a json file that
can be passed as input to rt-app with something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># rt-app my_config.json
</pre></div>
</div>
<p>The parameters that can be specified with the second method are a superset
of the command line options. Please refer to rt-app documentation for more
details (<cite>&lt;rt-app-sources&gt;/doc/*.json</cite>).</p>
<p>The second testing application is a modification of schedtool, called
schedtool-dl, which can be used to setup SCHED_DEADLINE parameters for a
certain pid/application. schedtool-dl is available at:
<a class="reference external" href="https://github.com/scheduler-tools/schedtool-dl.git">https://github.com/scheduler-tools/schedtool-dl.git</a>.</p>
<p>The usage is straightforward:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># schedtool -E -t 10000000:100000000 -e ./my_cpuhog_app
</pre></div>
</div>
<p>With this, my_cpuhog_app is put to run inside a SCHED_DEADLINE reservation
of 10ms every 100ms (note that parameters are expressed in microseconds).
You can also use schedtool to create a reservation for an already running
application, given that you know its pid:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># schedtool -E -t 10000000:100000000 my_app_pid
</pre></div>
</div>
</div></blockquote>
</section>
<section id="appendix-b-minimal-main">
<h2>Appendix B. Minimal main()<a class="headerlink" href="#appendix-b-minimal-main" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>We provide in what follows a simple (ugly) self-contained code snippet
showing how SCHED_DEADLINE reservations can be created by a real-time
application developer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define _GNU_SOURCE
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;linux/unistd.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;pthread.h&gt;

#define gettid() syscall(__NR_gettid)

#define SCHED_DEADLINE       6

/* XXX use the proper syscall numbers */
#ifdef __x86_64__
#define __NR_sched_setattr           314
#define __NR_sched_getattr           315
#endif

#ifdef __i386__
#define __NR_sched_setattr           351
#define __NR_sched_getattr           352
#endif

#ifdef __arm__
#define __NR_sched_setattr           380
#define __NR_sched_getattr           381
#endif

static volatile int done;

struct sched_attr {
     __u32 size;

     __u32 sched_policy;
     __u64 sched_flags;

     /* SCHED_NORMAL, SCHED_BATCH */
     __s32 sched_nice;

     /* SCHED_FIFO, SCHED_RR */
     __u32 sched_priority;

     /* SCHED_DEADLINE (nsec) */
     __u64 sched_runtime;
     __u64 sched_deadline;
     __u64 sched_period;
};

int sched_setattr(pid_t pid,
               const struct sched_attr *attr,
               unsigned int flags)
{
     return syscall(__NR_sched_setattr, pid, attr, flags);
}

int sched_getattr(pid_t pid,
               struct sched_attr *attr,
               unsigned int size,
               unsigned int flags)
{
     return syscall(__NR_sched_getattr, pid, attr, size, flags);
}

void *run_deadline(void *data)
{
     struct sched_attr attr;
     int x = 0;
     int ret;
     unsigned int flags = 0;

     printf(&quot;deadline thread started [%ld]\n&quot;, gettid());

     attr.size = sizeof(attr);
     attr.sched_flags = 0;
     attr.sched_nice = 0;
     attr.sched_priority = 0;

     /* This creates a 10ms/30ms reservation */
     attr.sched_policy = SCHED_DEADLINE;
     attr.sched_runtime = 10 * 1000 * 1000;
     attr.sched_period = attr.sched_deadline = 30 * 1000 * 1000;

     ret = sched_setattr(0, &amp;attr, flags);
     if (ret &lt; 0) {
             done = 0;
             perror(&quot;sched_setattr&quot;);
             exit(-1);
     }

     while (!done) {
             x++;
     }

     printf(&quot;deadline thread dies [%ld]\n&quot;, gettid());
     return NULL;
}

int main (int argc, char **argv)
{
     pthread_t thread;

     printf(&quot;main thread [%ld]\n&quot;, gettid());

     pthread_create(&amp;thread, NULL, run_deadline, NULL);

     sleep(10);

     done = 1;
     pthread_join(thread, NULL);

     printf(&quot;main dies [%ld]\n&quot;, gettid());
     return 0;
}
</pre></div>
</div>
</div></blockquote>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Deadline Task Scheduling</a><ul>
<li><a class="reference internal" href="#warning">0. WARNING</a></li>
<li><a class="reference internal" href="#overview">1. Overview</a></li>
<li><a class="reference internal" href="#scheduling-algorithm">2. Scheduling algorithm</a><ul>
<li><a class="reference internal" href="#main-algorithm">2.1 Main algorithm</a></li>
<li><a class="reference internal" href="#bandwidth-reclaiming">2.2 Bandwidth reclaiming</a></li>
<li><a class="reference internal" href="#energy-aware-scheduling">2.3 Energy-aware scheduling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scheduling-real-time-tasks">3. Scheduling Real-Time Tasks</a><ul>
<li><a class="reference internal" href="#definitions">3.1 Definitions</a></li>
<li><a class="reference internal" href="#schedulability-analysis-for-uniprocessor-systems">3.2 Schedulability Analysis for Uniprocessor Systems</a></li>
<li><a class="reference internal" href="#schedulability-analysis-for-multiprocessor-systems">3.3 Schedulability Analysis for Multiprocessor Systems</a></li>
<li><a class="reference internal" href="#relationship-with-sched-deadline-parameters">3.4 Relationship with SCHED_DEADLINE Parameters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bandwidth-management">4. Bandwidth management</a><ul>
<li><a class="reference internal" href="#system-wide-settings">4.1 System wide settings</a></li>
<li><a class="reference internal" href="#task-interface">4.2 Task interface</a></li>
<li><a class="reference internal" href="#default-behavior">4.3 Default behavior</a></li>
<li><a class="reference internal" href="#behavior-of-sched-yield">4.4 Behavior of sched_yield()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tasks-cpu-affinity">5. Tasks CPU affinity</a><ul>
<li><a class="reference internal" href="#sched-deadline-and-cpusets-howto">5.1 SCHED_DEADLINE and cpusets HOWTO</a></li>
</ul>
</li>
<li><a class="reference internal" href="#future-plans">6. Future plans</a></li>
<li><a class="reference internal" href="#appendix-a-test-suite">Appendix A. Test suite</a></li>
<li><a class="reference internal" href="#appendix-b-minimal-main">Appendix B. Minimal main()</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/scheduler/sched-deadline.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/scheduler/sched-deadline.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>