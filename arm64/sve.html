
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Scalable Vector Extension support for AArch64 Linux &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="AArch64 TAGGED ADDRESS ABI" href="tagged-address-abi.html" />
    <link rel="prev" title="Scalable Matrix Extension support for AArch64 Linux" href="sme.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="scalable-vector-extension-support-for-aarch64-linux">
<h1>Scalable Vector Extension support for AArch64 Linux<a class="headerlink" href="#scalable-vector-extension-support-for-aarch64-linux" title="Permalink to this headline">¶</a></h1>
<p>Author: Dave Martin &lt;<a class="reference external" href="mailto:Dave&#46;Martin&#37;&#52;&#48;arm&#46;com">Dave<span>&#46;</span>Martin<span>&#64;</span>arm<span>&#46;</span>com</a>&gt;</p>
<p>Date:   4 August 2017</p>
<p>This document outlines briefly the interface provided to userspace by Linux in
order to support use of the ARM Scalable Vector Extension (SVE), including
interactions with Streaming SVE mode added by the Scalable Matrix Extension
(SME).</p>
<p>This is an outline of the most important features and issues only and not
intended to be exhaustive.</p>
<p>This document does not aim to describe the SVE architecture or programmer’s
model.  To aid understanding, a minimal description of relevant programmer’s
model features for SVE is included in Appendix A.</p>
<section id="general">
<h2>1.  General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>SVE registers Z0..Z31, P0..P15 and FFR and the current vector length VL, are
tracked per-thread.</p></li>
<li><p>In streaming mode FFR is not accessible unless HWCAP2_SME_FA64 is present
in the system, when it is not supported and these interfaces are used to
access streaming mode FFR is read and written as zero.</p></li>
<li><p>The presence of SVE is reported to userspace via HWCAP_SVE in the aux vector
AT_HWCAP entry.  Presence of this flag implies the presence of the SVE
instructions and registers, and the Linux-specific system interfaces
described in this document.  SVE is reported in /proc/cpuinfo as “sve”.</p></li>
<li><p>Support for the execution of SVE instructions in userspace can also be
detected by reading the CPU ID register ID_AA64PFR0_EL1 using an MRS
instruction, and checking that the value of the SVE field is nonzero. [3]</p>
<p>It does not guarantee the presence of the system interfaces described in the
following sections: software that needs to verify that those interfaces are
present must check for HWCAP_SVE instead.</p>
</li>
<li><p>On hardware that supports the SVE2 extensions, HWCAP2_SVE2 will also
be reported in the AT_HWCAP2 aux vector entry.  In addition to this,
optional extensions to SVE2 may be reported by the presence of:</p>
<blockquote>
<div><p>HWCAP2_SVE2
HWCAP2_SVEAES
HWCAP2_SVEPMULL
HWCAP2_SVEBITPERM
HWCAP2_SVESHA3
HWCAP2_SVESM4
HWCAP2_SVE2P1</p>
</div></blockquote>
<p>This list may be extended over time as the SVE architecture evolves.</p>
<p>These extensions are also reported via the CPU ID register ID_AA64ZFR0_EL1,
which userspace can read using an MRS instruction.  See <a class="reference internal" href="elf_hwcaps.html"><span class="doc">ARM64 ELF hwcaps</span></a> and
<a class="reference internal" href="cpu-feature-registers.html"><span class="doc">ARM64 CPU Feature Registers</span></a> for details.</p>
</li>
<li><p>On hardware that supports the SME extensions, HWCAP2_SME will also be
reported in the AT_HWCAP2 aux vector entry.  Among other things SME adds
streaming mode which provides a subset of the SVE feature set using a
separate SME vector length and the same Z/V registers.  See <a class="reference internal" href="sme.html"><span class="doc">Scalable Matrix Extension support for AArch64 Linux</span></a>
for more details.</p></li>
<li><p>Debuggers should restrict themselves to interacting with the target via the
NT_ARM_SVE regset.  The recommended way of detecting support for this regset
is to connect to a target process first and then attempt a
ptrace(PTRACE_GETREGSET, pid, NT_ARM_SVE, &amp;iov).  Note that when SME is
present and streaming SVE mode is in use the FPSIMD subset of registers
will be read via NT_ARM_SVE and NT_ARM_SVE writes will exit streaming mode
in the target.</p></li>
<li><p>Whenever SVE scalable register values (Zn, Pn, FFR) are exchanged in memory
between userspace and the kernel, the register value is encoded in memory in
an endianness-invariant layout, with bits [(8 * i + 7) : (8 * i)] encoded at
byte offset i from the start of the memory representation.  This affects for
example the signal frame (struct sve_context) and ptrace interface
(struct user_sve_header) and associated data.</p>
<p>Beware that on big-endian systems this results in a different byte order than
for the FPSIMD V-registers, which are stored as single host-endian 128-bit
values, with bits [(127 - 8 * i) : (120 - 8 * i)] of the register encoded at
byte offset i.  (struct fpsimd_context, struct user_fpsimd_state).</p>
</li>
</ul>
</section>
<section id="vector-length-terminology">
<h2>2.  Vector length terminology<a class="headerlink" href="#vector-length-terminology" title="Permalink to this headline">¶</a></h2>
<p>The size of an SVE vector (Z) register is referred to as the “vector length”.</p>
<p>To avoid confusion about the units used to express vector length, the kernel
adopts the following conventions:</p>
<ul class="simple">
<li><p>Vector length (VL) = size of a Z-register in bytes</p></li>
<li><p>Vector quadwords (VQ) = size of a Z-register in units of 128 bits</p></li>
</ul>
<p>(So, VL = 16 * VQ.)</p>
<p>The VQ convention is used where the underlying granularity is important, such
as in data structure definitions.  In most other situations, the VL convention
is used.  This is consistent with the meaning of the “VL” pseudo-register in
the SVE instruction set architecture.</p>
</section>
<section id="system-call-behaviour">
<h2>3.  System call behaviour<a class="headerlink" href="#system-call-behaviour" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>On syscall, V0..V31 are preserved (as without SVE).  Thus, bits [127:0] of
Z0..Z31 are preserved.  All other bits of Z0..Z31, and all of P0..P15 and FFR
become zero on return from a syscall.</p></li>
<li><p>The SVE registers are not used to pass arguments to or receive results from
any syscall.</p></li>
<li><p>In practice the affected registers/bits will be preserved or will be replaced
with zeros on return from a syscall, but userspace should not make
assumptions about this.  The kernel behaviour may vary on a case-by-case
basis.</p></li>
<li><p>All other SVE state of a thread, including the currently configured vector
length, the state of the PR_SVE_VL_INHERIT flag, and the deferred vector
length (if any), is preserved across all syscalls, subject to the specific
exceptions for execve() described in section 6.</p>
<p>In particular, on return from a fork() or clone(), the parent and new child
process or thread share identical SVE configuration, matching that of the
parent before the call.</p>
</li>
</ul>
</section>
<section id="signal-handling">
<h2>4.  Signal handling<a class="headerlink" href="#signal-handling" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>A new signal frame record sve_context encodes the SVE registers on signal
delivery. [1]</p></li>
<li><p>This record is supplementary to fpsimd_context.  The FPSR and FPCR registers
are only present in fpsimd_context.  For convenience, the content of V0..V31
is duplicated between sve_context and fpsimd_context.</p></li>
<li><p>The record contains a flag field which includes a flag SVE_SIG_FLAG_SM which
if set indicates that the thread is in streaming mode and the vector length
and register data (if present) describe the streaming SVE data and vector
length.</p></li>
<li><p>The signal frame record for SVE always contains basic metadata, in particular
the thread’s vector length (in sve_context.vl).</p></li>
<li><p>The SVE registers may or may not be included in the record, depending on
whether the registers are live for the thread.  The registers are present if
and only if:
sve_context.head.size &gt;= SVE_SIG_CONTEXT_SIZE(sve_vq_from_vl(sve_context.vl)).</p></li>
<li><p>If the registers are present, the remainder of the record has a vl-dependent
size and layout.  Macros SVE_SIG_* are defined [1] to facilitate access to
the members.</p></li>
<li><p>Each scalable register (Zn, Pn, FFR) is stored in an endianness-invariant
layout, with bits [(8 * i + 7) : (8 * i)] stored at byte offset i from the
start of the register’s representation in memory.</p></li>
<li><p>If the SVE context is too big to fit in sigcontext.__reserved[], then extra
space is allocated on the stack, an extra_context record is written in
__reserved[] referencing this space.  sve_context is then written in the
extra space.  Refer to [1] for further details about this mechanism.</p></li>
</ul>
</section>
<section id="signal-return">
<h2>5.  Signal return<a class="headerlink" href="#signal-return" title="Permalink to this headline">¶</a></h2>
<p>When returning from a signal handler:</p>
<ul class="simple">
<li><p>If there is no sve_context record in the signal frame, or if the record is
present but contains no register data as desribed in the previous section,
then the SVE registers/bits become non-live and take unspecified values.</p></li>
<li><p>If sve_context is present in the signal frame and contains full register
data, the SVE registers become live and are populated with the specified
data.  However, for backward compatibility reasons, bits [127:0] of Z0..Z31
are always restored from the corresponding members of fpsimd_context.vregs[]
and not from sve_context.  The remaining bits are restored from sve_context.</p></li>
<li><p>Inclusion of fpsimd_context in the signal frame remains mandatory,
irrespective of whether sve_context is present or not.</p></li>
<li><p>The vector length cannot be changed via signal return.  If sve_context.vl in
the signal frame does not match the current vector length, the signal return
attempt is treated as illegal, resulting in a forced SIGSEGV.</p></li>
<li><p>It is permitted to enter or leave streaming mode by setting or clearing
the SVE_SIG_FLAG_SM flag but applications should take care to ensure that
when doing so sve_context.vl and any register data are appropriate for the
vector length in the new mode.</p></li>
</ul>
</section>
<section id="prctl-extensions">
<h2>6.  prctl extensions<a class="headerlink" href="#prctl-extensions" title="Permalink to this headline">¶</a></h2>
<p>Some new prctl() calls are added to allow programs to manage the SVE vector
length:</p>
<p>prctl(PR_SVE_SET_VL, unsigned long arg)</p>
<blockquote>
<div><p>Sets the vector length of the calling thread and related flags, where
arg == vl | flags.  Other threads of the calling process are unaffected.</p>
<p>vl is the desired vector length, where sve_vl_valid(vl) must be true.</p>
<p>flags:</p>
<blockquote>
<div><p>PR_SVE_VL_INHERIT</p>
<blockquote>
<div><p>Inherit the current vector length across execve().  Otherwise, the
vector length is reset to the system default at execve().  (See
Section 9.)</p>
</div></blockquote>
<p>PR_SVE_SET_VL_ONEXEC</p>
<blockquote>
<div><p>Defer the requested vector length change until the next execve()
performed by this thread.</p>
<p>The effect is equivalent to implicit exceution of the following
call immediately after the next execve() (if any) by the thread:</p>
<blockquote>
<div><p>prctl(PR_SVE_SET_VL, arg &amp; ~PR_SVE_SET_VL_ONEXEC)</p>
</div></blockquote>
<p>This allows launching of a new program with a different vector
length, while avoiding runtime side effects in the caller.</p>
<p>Without PR_SVE_SET_VL_ONEXEC, the requested change takes effect
immediately.</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>Return value: a nonnegative on success, or a negative value on error:</dt><dd><dl class="simple">
<dt>EINVAL: SVE not supported, invalid vector length requested, or</dt><dd><p>invalid flags.</p>
</dd>
</dl>
</dd>
</dl>
<p>On success:</p>
<ul class="simple">
<li><p>Either the calling thread’s vector length or the deferred vector length
to be applied at the next execve() by the thread (dependent on whether
PR_SVE_SET_VL_ONEXEC is present in arg), is set to the largest value
supported by the system that is less than or equal to vl.  If vl ==
SVE_VL_MAX, the value set will be the largest value supported by the
system.</p></li>
<li><p>Any previously outstanding deferred vector length change in the calling
thread is cancelled.</p></li>
<li><p>The returned value describes the resulting configuration, encoded as for
PR_SVE_GET_VL.  The vector length reported in this value is the new
current vector length for this thread if PR_SVE_SET_VL_ONEXEC was not
present in arg; otherwise, the reported vector length is the deferred
vector length that will be applied at the next execve() by the calling
thread.</p></li>
<li><p>Changing the vector length causes all of P0..P15, FFR and all bits of
Z0..Z31 except for Z0 bits [127:0] .. Z31 bits [127:0] to become
unspecified.  Calling PR_SVE_SET_VL with vl equal to the thread’s current
vector length, or calling PR_SVE_SET_VL with the PR_SVE_SET_VL_ONEXEC
flag, does not constitute a change to the vector length for this purpose.</p></li>
</ul>
</div></blockquote>
<p>prctl(PR_SVE_GET_VL)</p>
<blockquote>
<div><p>Gets the vector length of the calling thread.</p>
<p>The following flag may be OR-ed into the result:</p>
<blockquote>
<div><p>PR_SVE_VL_INHERIT</p>
<blockquote>
<div><p>Vector length will be inherited across execve().</p>
</div></blockquote>
</div></blockquote>
<p>There is no way to determine whether there is an outstanding deferred
vector length change (which would only normally be the case between a
fork() or vfork() and the corresponding execve() in typical use).</p>
<p>To extract the vector length from the result, bitwise and it with
PR_SVE_VL_LEN_MASK.</p>
<dl class="simple">
<dt>Return value: a nonnegative value on success, or a negative value on error:</dt><dd><p>EINVAL: SVE not supported.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="ptrace-extensions">
<h2>7.  ptrace extensions<a class="headerlink" href="#ptrace-extensions" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>New regsets NT_ARM_SVE and NT_ARM_SSVE are defined for use with
PTRACE_GETREGSET and PTRACE_SETREGSET. NT_ARM_SSVE describes the
streaming mode SVE registers and NT_ARM_SVE describes the
non-streaming mode SVE registers.</p>
<p>In this description a register set is referred to as being “live” when
the target is in the appropriate streaming or non-streaming mode and is
using data beyond the subset shared with the FPSIMD Vn registers.</p>
<p>Refer to [2] for definitions.</p>
</li>
</ul>
<p>The regset data starts with struct user_sve_header, containing:</p>
<blockquote>
<div><p>size</p>
<blockquote>
<div><p>Size of the complete regset, in bytes.
This depends on vl and possibly on other things in the future.</p>
<p>If a call to PTRACE_GETREGSET requests less data than the value of
size, the caller can allocate a larger buffer and retry in order to
read the complete regset.</p>
</div></blockquote>
<p>max_size</p>
<blockquote>
<div><p>Maximum size in bytes that the regset can grow to for the target
thread.  The regset won’t grow bigger than this even if the target
thread changes its vector length etc.</p>
</div></blockquote>
<p>vl</p>
<blockquote>
<div><p>Target thread’s current vector length, in bytes.</p>
</div></blockquote>
<p>max_vl</p>
<blockquote>
<div><p>Maximum possible vector length for the target thread.</p>
</div></blockquote>
<p>flags</p>
<blockquote>
<div><p>at most one of</p>
<blockquote>
<div><p>SVE_PT_REGS_FPSIMD</p>
<blockquote>
<div><p>SVE registers are not live (GETREGSET) or are to be made
non-live (SETREGSET).</p>
<p>The payload is of type struct user_fpsimd_state, with the same
meaning as for NT_PRFPREG, starting at offset
SVE_PT_FPSIMD_OFFSET from the start of user_sve_header.</p>
<p>Extra data might be appended in the future: the size of the
payload should be obtained using SVE_PT_FPSIMD_SIZE(vq, flags).</p>
<p>vq should be obtained using sve_vq_from_vl(vl).</p>
<p>or</p>
</div></blockquote>
<p>SVE_PT_REGS_SVE</p>
<blockquote>
<div><p>SVE registers are live (GETREGSET) or are to be made live
(SETREGSET).</p>
<p>The payload contains the SVE register data, starting at offset
SVE_PT_SVE_OFFSET from the start of user_sve_header, and with
size SVE_PT_SVE_SIZE(vq, flags);</p>
</div></blockquote>
</div></blockquote>
<p>… OR-ed with zero or more of the following flags, which have the same
meaning and behaviour as the corresponding PR_SET_VL_* flags:</p>
<blockquote>
<div><p>SVE_PT_VL_INHERIT</p>
<p>SVE_PT_VL_ONEXEC (SETREGSET only).</p>
</div></blockquote>
<p>If neither FPSIMD nor SVE flags are provided then no register
payload is available, this is only possible when SME is implemented.</p>
</div></blockquote>
</div></blockquote>
<ul>
<li><p>The effects of changing the vector length and/or flags are equivalent to
those documented for PR_SVE_SET_VL.</p>
<p>The caller must make a further GETREGSET call if it needs to know what VL is
actually set by SETREGSET, unless is it known in advance that the requested
VL is supported.</p>
</li>
<li><p>In the SVE_PT_REGS_SVE case, the size and layout of the payload depends on
the header fields.  The SVE_PT_SVE_*() macros are provided to facilitate
access to the members.</p></li>
<li><p>In either case, for SETREGSET it is permissible to omit the payload, in which
case only the vector length and flags are changed (along with any
consequences of those changes).</p></li>
<li><p>In systems supporting SME when in streaming mode a GETREGSET for
NT_REG_SVE will return only the user_sve_header with no register data,
similarly a GETREGSET for NT_REG_SSVE will not return any register data
when not in streaming mode.</p></li>
<li><p>A GETREGSET for NT_ARM_SSVE will never return SVE_PT_REGS_FPSIMD.</p></li>
<li><p>For SETREGSET, if an SVE_PT_REGS_SVE payload is present and the
requested VL is not supported, the effect will be the same as if the
payload were omitted, except that an EIO error is reported.  No
attempt is made to translate the payload data to the correct layout
for the vector length actually set.  The thread’s FPSIMD state is
preserved, but the remaining bits of the SVE registers become
unspecified.  It is up to the caller to translate the payload layout
for the actual VL and retry.</p></li>
<li><p>Where SME is implemented it is not possible to GETREGSET the register
state for normal SVE when in streaming mode, nor the streaming mode
register state when in normal mode, regardless of the implementation defined
behaviour of the hardware for sharing data between the two modes.</p></li>
<li><p>Any SETREGSET of NT_ARM_SVE will exit streaming mode if the target was in
streaming mode and any SETREGSET of NT_ARM_SSVE will enter streaming mode
if the target was not in streaming mode.</p></li>
<li><p>The effect of writing a partial, incomplete payload is unspecified.</p></li>
</ul>
</section>
<section id="elf-coredump-extensions">
<h2>8.  ELF coredump extensions<a class="headerlink" href="#elf-coredump-extensions" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>NT_ARM_SVE and NT_ARM_SSVE notes will be added to each coredump for
each thread of the dumped process.  The contents will be equivalent to the
data that would have been read if a PTRACE_GETREGSET of the corresponding
type were executed for each thread when the coredump was generated.</p></li>
</ul>
</section>
<section id="system-runtime-configuration">
<h2>9.  System runtime configuration<a class="headerlink" href="#system-runtime-configuration" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>To mitigate the ABI impact of expansion of the signal frame, a policy
mechanism is provided for administrators, distro maintainers and developers
to set the default vector length for userspace processes:</p></li>
</ul>
<p>/proc/sys/abi/sve_default_vector_length</p>
<blockquote>
<div><p>Writing the text representation of an integer to this file sets the system
default vector length to the specified value, unless the value is greater
than the maximum vector length supported by the system in which case the
default vector length is set to that maximum.</p>
<p>The result can be determined by reopening the file and reading its
contents.</p>
<p>At boot, the default vector length is initially set to 64 or the maximum
supported vector length, whichever is smaller.  This determines the initial
vector length of the init process (PID 1).</p>
<p>Reading this file returns the current system default vector length.</p>
</div></blockquote>
<ul>
<li><p>At every execve() call, the new vector length of the new process is set to
the system default vector length, unless</p>
<blockquote>
<div><ul class="simple">
<li><p>PR_SVE_VL_INHERIT (or equivalently SVE_PT_VL_INHERIT) is set for the
calling thread, or</p></li>
<li><p>a deferred vector length change is pending, established via the
PR_SVE_SET_VL_ONEXEC flag (or SVE_PT_VL_ONEXEC).</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Modifying the system default vector length does not affect the vector length
of any existing process or thread that does not make an execve() call.</p></li>
</ul>
</section>
<section id="perf-extensions">
<h2>10.  Perf extensions<a class="headerlink" href="#perf-extensions" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>The arm64 specific DWARF standard [5] added the VG (Vector Granule) register
at index 46. This register is used for DWARF unwinding when variable length
SVE registers are pushed onto the stack.</p></li>
<li><p>Its value is equivalent to the current SVE vector length (VL) in bits divided
by 64.</p></li>
<li><p>The value is included in Perf samples in the regs[46] field if
PERF_SAMPLE_REGS_USER is set and the sample_regs_user mask has bit 46 set.</p></li>
<li><p>The value is the current value at the time the sample was taken, and it can
change over time.</p></li>
<li><p>If the system doesn’t support SVE when perf_event_open is called with these
settings, the event will fail to open.</p></li>
</ul>
<section id="appendix-a-sve-programmer-s-model-informative">
<h3>Appendix A.  SVE programmer’s model (informative)<a class="headerlink" href="#appendix-a-sve-programmer-s-model-informative" title="Permalink to this headline">¶</a></h3>
<p>This section provides a minimal description of the additions made by SVE to the
ARMv8-A programmer’s model that are relevant to this document.</p>
<p>Note: This section is for information only and not intended to be complete or
to replace any architectural specification.</p>
</section>
</section>
<section id="a-1-registers">
<h2>A.1.  Registers<a class="headerlink" href="#a-1-registers" title="Permalink to this headline">¶</a></h2>
<p>In A64 state, SVE adds the following:</p>
<ul>
<li><p>32 8VL-bit vector registers Z0..Z31
For each Zn, Zn bits [127:0] alias the ARMv8-A vector register Vn.</p>
<p>A register write using a Vn register name zeros all bits of the corresponding
Zn except for bits [127:0].</p>
</li>
<li><p>16 VL-bit predicate registers P0..P15</p></li>
<li><p>1 VL-bit special-purpose predicate register FFR (the “first-fault register”)</p></li>
<li><p>a VL “pseudo-register” that determines the size of each vector register</p>
<p>The SVE instruction set architecture provides no way to write VL directly.
Instead, it can be modified only by EL1 and above, by writing appropriate
system registers.</p>
</li>
<li><p>The value of VL can be configured at runtime by EL1 and above:
16 &lt;= VL &lt;= VLmax, where VL must be a multiple of 16.</p></li>
<li><p>The maximum vector length is determined by the hardware:
16 &lt;= VLmax &lt;= 256.</p>
<p>(The SVE architecture specifies 256, but permits future architecture
revisions to raise this limit.)</p>
</li>
<li><p>FPSR and FPCR are retained from ARMv8-A, and interact with SVE floating-point
operations in a similar way to the way in which they interact with ARMv8
floating-point operations:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     8VL-1                       128               0  bit index
    +----          ////            -----------------+
 Z0 |                               :       V0      |
  :                                          :
 Z7 |                               :       V7      |
 Z8 |                               :     * V8      |
  :                                       :  :
Z15 |                               :     *V15      |
Z16 |                               :      V16      |
  :                                          :
Z31 |                               :      V31      |
    +----          ////            -----------------+
                                             31    0
     VL-1                  0                +-------+
    +----       ////      --+          FPSR |       |
 P0 |                       |               +-------+
  : |                       |         *FPCR |       |
P15 |                       |               +-------+
    +----       ////      --+
FFR |                       |               +-----+
    +----       ////      --+            VL |     |
                                            +-----+
</pre></div>
</div>
</li>
</ul>
<dl class="simple">
<dt>(*) callee-save:</dt><dd><p>This only applies to bits [63:0] of Z-/V-registers.
FPCR contains callee-save and caller-save bits.  See [4] for details.</p>
</dd>
</dl>
</section>
<section id="a-2-procedure-call-standard">
<h2>A.2.  Procedure call standard<a class="headerlink" href="#a-2-procedure-call-standard" title="Permalink to this headline">¶</a></h2>
<p>The ARMv8-A base procedure call standard is extended as follows with respect to
the additional SVE register state:</p>
<ul>
<li><p>All SVE register bits that are not shared with FP/SIMD are caller-save.</p></li>
<li><p>Z8 bits [63:0] .. Z15 bits [63:0] are callee-save.</p>
<p>This follows from the way these bits are mapped to V8..V15, which are caller-
save in the base procedure call standard.</p>
</li>
</ul>
<section id="appendix-b-armv8-a-fp-simd-programmer-s-model">
<h3>Appendix B.  ARMv8-A FP/SIMD programmer’s model<a class="headerlink" href="#appendix-b-armv8-a-fp-simd-programmer-s-model" title="Permalink to this headline">¶</a></h3>
<p>Note: This section is for information only and not intended to be complete or
to replace any architectural specification.</p>
<p>Refer to [4] for more information.</p>
<p>ARMv8-A defines the following floating-point / SIMD register state:</p>
<ul class="simple">
<li><p>32 128-bit vector registers V0..V31</p></li>
<li><p>2 32-bit status/control registers FPSR, FPCR</p></li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>      127           0  bit index
     +---------------+
  V0 |               |
   : :               :
  V7 |               |
* V8 |               |
:  : :               :
*V15 |               |
 V16 |               |
   : :               :
 V31 |               |
     +---------------+

              31    0
             +-------+
        FPSR |       |
             +-------+
       *FPCR |       |
             +-------+
</pre></div>
</div>
<dl class="simple">
<dt>(*) callee-save:</dt><dd><p>This only applies to bits [63:0] of V-registers.
FPCR contains a mixture of callee-save and caller-save bits.</p>
</dd>
</dl>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>[1] arch/arm64/include/uapi/asm/sigcontext.h</dt><dd><p>AArch64 Linux signal ABI definitions</p>
</dd>
<dt>[2] arch/arm64/include/uapi/asm/ptrace.h</dt><dd><p>AArch64 Linux ptrace ABI definitions</p>
</dd>
</dl>
<p>[3] <a class="reference internal" href="cpu-feature-registers.html"><span class="doc">ARM64 CPU Feature Registers</span></a></p>
<dl class="simple">
<dt>[4] ARM IHI0055C</dt><dd><p><a class="reference external" href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055c/IHI0055C_beta_aapcs64.pdf">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055c/IHI0055C_beta_aapcs64.pdf</a>
<a class="reference external" href="http://infocenter.arm.com/help/topic/com.arm.doc.subset.swdev.abi/index.html">http://infocenter.arm.com/help/topic/com.arm.doc.subset.swdev.abi/index.html</a>
Procedure Call Standard for the ARM 64-bit Architecture (AArch64)</p>
</dd>
</dl>
<p>[5] <a class="reference external" href="https://github.com/ARM-software/abi-aa/blob/main/aadwarf64/aadwarf64.rst">https://github.com/ARM-software/abi-aa/blob/main/aadwarf64/aadwarf64.rst</a></p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Scalable Vector Extension support for AArch64 Linux</a><ul>
<li><a class="reference internal" href="#general">1.  General</a></li>
<li><a class="reference internal" href="#vector-length-terminology">2.  Vector length terminology</a></li>
<li><a class="reference internal" href="#system-call-behaviour">3.  System call behaviour</a></li>
<li><a class="reference internal" href="#signal-handling">4.  Signal handling</a></li>
<li><a class="reference internal" href="#signal-return">5.  Signal return</a></li>
<li><a class="reference internal" href="#prctl-extensions">6.  prctl extensions</a></li>
<li><a class="reference internal" href="#ptrace-extensions">7.  ptrace extensions</a></li>
<li><a class="reference internal" href="#elf-coredump-extensions">8.  ELF coredump extensions</a></li>
<li><a class="reference internal" href="#system-runtime-configuration">9.  System runtime configuration</a></li>
<li><a class="reference internal" href="#perf-extensions">10.  Perf extensions</a><ul>
<li><a class="reference internal" href="#appendix-a-sve-programmer-s-model-informative">Appendix A.  SVE programmer’s model (informative)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-1-registers">A.1.  Registers</a></li>
<li><a class="reference internal" href="#a-2-procedure-call-standard">A.2.  Procedure call standard</a><ul>
<li><a class="reference internal" href="#appendix-b-armv8-a-fp-simd-programmer-s-model">Appendix B.  ARMv8-A FP/SIMD programmer’s model</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/arm64/sve.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/arm64/sve.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>