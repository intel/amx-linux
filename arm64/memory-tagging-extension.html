
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Memory Tagging Extension (MTE) in AArch64 Linux &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Perf" href="perf.html" />
    <link rel="prev" title="Memory Layout on AArch64 Linux" href="memory.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="memory-tagging-extension-mte-in-aarch64-linux">
<h1>Memory Tagging Extension (MTE) in AArch64 Linux<a class="headerlink" href="#memory-tagging-extension-mte-in-aarch64-linux" title="Permalink to this headline">¶</a></h1>
<dl class="simple">
<dt>Authors: Vincenzo Frascino &lt;<a class="reference external" href="mailto:vincenzo&#46;frascino&#37;&#52;&#48;arm&#46;com">vincenzo<span>&#46;</span>frascino<span>&#64;</span>arm<span>&#46;</span>com</a>&gt;</dt><dd><p>Catalin Marinas &lt;<a class="reference external" href="mailto:catalin&#46;marinas&#37;&#52;&#48;arm&#46;com">catalin<span>&#46;</span>marinas<span>&#64;</span>arm<span>&#46;</span>com</a>&gt;</p>
</dd>
</dl>
<p>Date: 2020-02-25</p>
<p>This document describes the provision of the Memory Tagging Extension
functionality in AArch64 Linux.</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>ARMv8.5 based processors introduce the Memory Tagging Extension (MTE)
feature. MTE is built on top of the ARMv8.0 virtual address tagging TBI
(Top Byte Ignore) feature and allows software to access a 4-bit
allocation tag for each 16-byte granule in the physical address space.
Such memory range must be mapped with the Normal-Tagged memory
attribute. A logical tag is derived from bits 59-56 of the virtual
address used for the memory access. A CPU with MTE enabled will compare
the logical tag against the allocation tag and potentially raise an
exception on mismatch, subject to system registers configuration.</p>
</section>
<section id="userspace-support">
<h2>Userspace Support<a class="headerlink" href="#userspace-support" title="Permalink to this headline">¶</a></h2>
<p>When <code class="docutils literal notranslate"><span class="pre">CONFIG_ARM64_MTE</span></code> is selected and Memory Tagging Extension is
supported by the hardware, the kernel advertises the feature to
userspace via <code class="docutils literal notranslate"><span class="pre">HWCAP2_MTE</span></code>.</p>
<section id="prot-mte">
<h3>PROT_MTE<a class="headerlink" href="#prot-mte" title="Permalink to this headline">¶</a></h3>
<p>To access the allocation tags, a user process must enable the Tagged
memory attribute on an address range using a new <code class="docutils literal notranslate"><span class="pre">prot</span></code> flag for
<code class="docutils literal notranslate"><span class="pre">mmap()</span></code> and <code class="docutils literal notranslate"><span class="pre">mprotect()</span></code>:</p>
<p><code class="docutils literal notranslate"><span class="pre">PROT_MTE</span></code> - Pages allow access to the MTE allocation tags.</p>
<p>The allocation tag is set to 0 when such pages are first mapped in the
user address space and preserved on copy-on-write. <code class="docutils literal notranslate"><span class="pre">MAP_SHARED</span></code> is
supported and the allocation tags can be shared between processes.</p>
<p><strong>Note</strong>: <code class="docutils literal notranslate"><span class="pre">PROT_MTE</span></code> is only supported on <code class="docutils literal notranslate"><span class="pre">MAP_ANONYMOUS</span></code> and
RAM-based file mappings (<code class="docutils literal notranslate"><span class="pre">tmpfs</span></code>, <code class="docutils literal notranslate"><span class="pre">memfd</span></code>). Passing it to other
types of mapping will result in <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> returned by these system
calls.</p>
<p><strong>Note</strong>: The <code class="docutils literal notranslate"><span class="pre">PROT_MTE</span></code> flag (and corresponding memory type) cannot
be cleared by <code class="docutils literal notranslate"><span class="pre">mprotect()</span></code>.</p>
<p><strong>Note</strong>: <code class="docutils literal notranslate"><span class="pre">madvise()</span></code> memory ranges with <code class="docutils literal notranslate"><span class="pre">MADV_DONTNEED</span></code> and
<code class="docutils literal notranslate"><span class="pre">MADV_FREE</span></code> may have the allocation tags cleared (set to 0) at any
point after the system call.</p>
</section>
<section id="tag-check-faults">
<h3>Tag Check Faults<a class="headerlink" href="#tag-check-faults" title="Permalink to this headline">¶</a></h3>
<p>When <code class="docutils literal notranslate"><span class="pre">PROT_MTE</span></code> is enabled on an address range and a mismatch between
the logical and allocation tags occurs on access, there are three
configurable behaviours:</p>
<ul class="simple">
<li><p><em>Ignore</em> - This is the default mode. The CPU (and kernel) ignores the
tag check fault.</p></li>
<li><p><em>Synchronous</em> - The kernel raises a <code class="docutils literal notranslate"><span class="pre">SIGSEGV</span></code> synchronously, with
<code class="docutils literal notranslate"><span class="pre">.si_code</span> <span class="pre">=</span> <span class="pre">SEGV_MTESERR</span></code> and <code class="docutils literal notranslate"><span class="pre">.si_addr</span> <span class="pre">=</span> <span class="pre">&lt;fault-address&gt;</span></code>. The
memory access is not performed. If <code class="docutils literal notranslate"><span class="pre">SIGSEGV</span></code> is ignored or blocked
by the offending thread, the containing process is terminated with a
<code class="docutils literal notranslate"><span class="pre">coredump</span></code>.</p></li>
<li><p><em>Asynchronous</em> - The kernel raises a <code class="docutils literal notranslate"><span class="pre">SIGSEGV</span></code>, in the offending
thread, asynchronously following one or multiple tag check faults,
with <code class="docutils literal notranslate"><span class="pre">.si_code</span> <span class="pre">=</span> <span class="pre">SEGV_MTEAERR</span></code> and <code class="docutils literal notranslate"><span class="pre">.si_addr</span> <span class="pre">=</span> <span class="pre">0</span></code> (the faulting
address is unknown).</p></li>
<li><p><em>Asymmetric</em> - Reads are handled as for synchronous mode while writes
are handled as for asynchronous mode.</p></li>
</ul>
<p>The user can select the above modes, per thread, using the
<code class="docutils literal notranslate"><span class="pre">prctl(PR_SET_TAGGED_ADDR_CTRL,</span> <span class="pre">flags,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code> system call where <code class="docutils literal notranslate"><span class="pre">flags</span></code>
contains any number of the following values in the <code class="docutils literal notranslate"><span class="pre">PR_MTE_TCF_MASK</span></code>
bit-field:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">PR_MTE_TCF_NONE</span></code>  - <em>Ignore</em> tag check faults</dt><dd><p>(ignored if combined with other options)</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">PR_MTE_TCF_SYNC</span></code>  - <em>Synchronous</em> tag check fault mode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PR_MTE_TCF_ASYNC</span></code> - <em>Asynchronous</em> tag check fault mode</p></li>
</ul>
<p>If no modes are specified, tag check faults are ignored. If a single
mode is specified, the program will run in that mode. If multiple
modes are specified, the mode is selected as described in the “Per-CPU
preferred tag checking modes” section below.</p>
<p>The current tag check fault configuration can be read using the
<code class="docutils literal notranslate"><span class="pre">prctl(PR_GET_TAGGED_ADDR_CTRL,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code> system call. If
multiple modes were requested then all will be reported.</p>
<p>Tag checking can also be disabled for a user thread by setting the
<code class="docutils literal notranslate"><span class="pre">PSTATE.TCO</span></code> bit with <code class="docutils literal notranslate"><span class="pre">MSR</span> <span class="pre">TCO,</span> <span class="pre">#1</span></code>.</p>
<p><strong>Note</strong>: Signal handlers are always invoked with <code class="docutils literal notranslate"><span class="pre">PSTATE.TCO</span> <span class="pre">=</span> <span class="pre">0</span></code>,
irrespective of the interrupted context. <code class="docutils literal notranslate"><span class="pre">PSTATE.TCO</span></code> is restored on
<code class="docutils literal notranslate"><span class="pre">sigreturn()</span></code>.</p>
<p><strong>Note</strong>: There are no <em>match-all</em> logical tags available for user
applications.</p>
<p><strong>Note</strong>: Kernel accesses to the user address space (e.g. <code class="docutils literal notranslate"><span class="pre">read()</span></code>
system call) are not checked if the user thread tag checking mode is
<code class="docutils literal notranslate"><span class="pre">PR_MTE_TCF_NONE</span></code> or <code class="docutils literal notranslate"><span class="pre">PR_MTE_TCF_ASYNC</span></code>. If the tag checking mode is
<code class="docutils literal notranslate"><span class="pre">PR_MTE_TCF_SYNC</span></code>, the kernel makes a best effort to check its user
address accesses, however it cannot always guarantee it. Kernel accesses
to user addresses are always performed with an effective <code class="docutils literal notranslate"><span class="pre">PSTATE.TCO</span></code>
value of zero, regardless of the user configuration.</p>
</section>
<section id="excluding-tags-in-the-irg-addg-and-subg-instructions">
<h3>Excluding Tags in the <code class="docutils literal notranslate"><span class="pre">IRG</span></code>, <code class="docutils literal notranslate"><span class="pre">ADDG</span></code> and <code class="docutils literal notranslate"><span class="pre">SUBG</span></code> instructions<a class="headerlink" href="#excluding-tags-in-the-irg-addg-and-subg-instructions" title="Permalink to this headline">¶</a></h3>
<p>The architecture allows excluding certain tags to be randomly generated
via the <code class="docutils literal notranslate"><span class="pre">GCR_EL1.Exclude</span></code> register bit-field. By default, Linux
excludes all tags other than 0. A user thread can enable specific tags
in the randomly generated set using the <code class="docutils literal notranslate"><span class="pre">prctl(PR_SET_TAGGED_ADDR_CTRL,</span>
<span class="pre">flags,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code> system call where <code class="docutils literal notranslate"><span class="pre">flags</span></code> contains the tags bitmap
in the <code class="docutils literal notranslate"><span class="pre">PR_MTE_TAG_MASK</span></code> bit-field.</p>
<p><strong>Note</strong>: The hardware uses an exclude mask but the <code class="docutils literal notranslate"><span class="pre">prctl()</span></code>
interface provides an include mask. An include mask of <code class="docutils literal notranslate"><span class="pre">0</span></code> (exclusion
mask <code class="docutils literal notranslate"><span class="pre">0xffff</span></code>) results in the CPU always generating tag <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</section>
<section id="per-cpu-preferred-tag-checking-mode">
<h3>Per-CPU preferred tag checking mode<a class="headerlink" href="#per-cpu-preferred-tag-checking-mode" title="Permalink to this headline">¶</a></h3>
<p>On some CPUs the performance of MTE in stricter tag checking modes
is similar to that of less strict tag checking modes. This makes it
worthwhile to enable stricter checks on those CPUs when a less strict
checking mode is requested, in order to gain the error detection
benefits of the stricter checks without the performance downsides. To
support this scenario, a privileged user may configure a stricter
tag checking mode as the CPU’s preferred tag checking mode.</p>
<p>The preferred tag checking mode for each CPU is controlled by
<code class="docutils literal notranslate"><span class="pre">/sys/devices/system/cpu/cpu&lt;N&gt;/mte_tcf_preferred</span></code>, to which a
privileged user may write the value <code class="docutils literal notranslate"><span class="pre">async</span></code>, <code class="docutils literal notranslate"><span class="pre">sync</span></code> or <code class="docutils literal notranslate"><span class="pre">asymm</span></code>.  The
default preferred mode for each CPU is <code class="docutils literal notranslate"><span class="pre">async</span></code>.</p>
<p>To allow a program to potentially run in the CPU’s preferred tag
checking mode, the user program may set multiple tag check fault mode
bits in the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument to the <code class="docutils literal notranslate"><span class="pre">prctl(PR_SET_TAGGED_ADDR_CTRL,</span>
<span class="pre">flags,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code> system call. If both synchronous and asynchronous
modes are requested then asymmetric mode may also be selected by the
kernel. If the CPU’s preferred tag checking mode is in the task’s set
of provided tag checking modes, that mode will be selected. Otherwise,
one of the modes in the task’s mode will be selected by the kernel
from the task’s mode set using the preference order:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Asynchronous</p></li>
<li><p>Asymmetric</p></li>
<li><p>Synchronous</p></li>
</ol>
</div></blockquote>
<p>Note that there is no way for userspace to request multiple modes and
also disable asymmetric mode.</p>
</section>
<section id="initial-process-state">
<h3>Initial process state<a class="headerlink" href="#initial-process-state" title="Permalink to this headline">¶</a></h3>
<p>On <code class="docutils literal notranslate"><span class="pre">execve()</span></code>, the new process has the following configuration:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PR_TAGGED_ADDR_ENABLE</span></code> set to 0 (disabled)</p></li>
<li><p>No tag checking modes are selected (tag check faults ignored)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PR_MTE_TAG_MASK</span></code> set to 0 (all tags excluded)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PSTATE.TCO</span></code> set to 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PROT_MTE</span></code> not set on any of the initial memory maps</p></li>
</ul>
<p>On <code class="docutils literal notranslate"><span class="pre">fork()</span></code>, the new process inherits the parent’s configuration and
memory map attributes with the exception of the <code class="docutils literal notranslate"><span class="pre">madvise()</span></code> ranges
with <code class="docutils literal notranslate"><span class="pre">MADV_WIPEONFORK</span></code> which will have the data and tags cleared (set
to 0).</p>
</section>
<section id="the-ptrace-interface">
<h3>The <code class="docutils literal notranslate"><span class="pre">ptrace()</span></code> interface<a class="headerlink" href="#the-ptrace-interface" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">PTRACE_PEEKMTETAGS</span></code> and <code class="docutils literal notranslate"><span class="pre">PTRACE_POKEMTETAGS</span></code> allow a tracer to read
the tags from or set the tags to a tracee’s address space. The
<code class="docutils literal notranslate"><span class="pre">ptrace()</span></code> system call is invoked as <code class="docutils literal notranslate"><span class="pre">ptrace(request,</span> <span class="pre">pid,</span> <span class="pre">addr,</span>
<span class="pre">data)</span></code> where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">request</span></code> - one of <code class="docutils literal notranslate"><span class="pre">PTRACE_PEEKMTETAGS</span></code> or <code class="docutils literal notranslate"><span class="pre">PTRACE_POKEMTETAGS</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pid</span></code> - the tracee’s PID.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">addr</span></code> - address in the tracee’s address space.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code> - pointer to a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iovec</span></code> where <code class="docutils literal notranslate"><span class="pre">iov_base</span></code> points to
a buffer of <code class="docutils literal notranslate"><span class="pre">iov_len</span></code> length in the tracer’s address space.</p></li>
</ul>
<p>The tags in the tracer’s <code class="docutils literal notranslate"><span class="pre">iov_base</span></code> buffer are represented as one
4-bit tag per byte and correspond to a 16-byte MTE tag granule in the
tracee’s address space.</p>
<p><strong>Note</strong>: If <code class="docutils literal notranslate"><span class="pre">addr</span></code> is not aligned to a 16-byte granule, the kernel
will use the corresponding aligned address.</p>
<p><code class="docutils literal notranslate"><span class="pre">ptrace()</span></code> return value:</p>
<ul class="simple">
<li><p>0 - tags were copied, the tracer’s <code class="docutils literal notranslate"><span class="pre">iov_len</span></code> was updated to the
number of tags transferred. This may be smaller than the requested
<code class="docutils literal notranslate"><span class="pre">iov_len</span></code> if the requested address range in the tracee’s or the
tracer’s space cannot be accessed or does not have valid tags.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-EPERM</span></code> - the specified process cannot be traced.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-EIO</span></code> - the tracee’s address range cannot be accessed (e.g. invalid
address) and no tags copied. <code class="docutils literal notranslate"><span class="pre">iov_len</span></code> not updated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-EFAULT</span></code> - fault on accessing the tracer’s memory (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">iovec</span></code>
or <code class="docutils literal notranslate"><span class="pre">iov_base</span></code> buffer) and no tags copied. <code class="docutils literal notranslate"><span class="pre">iov_len</span></code> not updated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-EOPNOTSUPP</span></code> - the tracee’s address does not have valid tags (never
mapped with the <code class="docutils literal notranslate"><span class="pre">PROT_MTE</span></code> flag). <code class="docutils literal notranslate"><span class="pre">iov_len</span></code> not updated.</p></li>
</ul>
<p><strong>Note</strong>: There are no transient errors for the requests above, so user
programs should not retry in case of a non-zero system call return.</p>
<p><code class="docutils literal notranslate"><span class="pre">PTRACE_GETREGSET</span></code> and <code class="docutils literal notranslate"><span class="pre">PTRACE_SETREGSET</span></code> with <code class="docutils literal notranslate"><span class="pre">addr</span> <span class="pre">==</span>
<span class="pre">``NT_ARM_TAGGED_ADDR_CTRL</span></code> allow <code class="docutils literal notranslate"><span class="pre">ptrace()</span></code> access to the tagged
address ABI control and MTE configuration of a process as per the
<code class="docutils literal notranslate"><span class="pre">prctl()</span></code> options described in
<a class="reference internal" href="tagged-address-abi.html"><span class="doc">AArch64 TAGGED ADDRESS ABI</span></a> and above. The corresponding
<code class="docutils literal notranslate"><span class="pre">regset</span></code> is 1 element of 8 bytes (<code class="docutils literal notranslate"><span class="pre">sizeof(long))</span></code>).</p>
</section>
<section id="core-dump-support">
<h3>Core dump support<a class="headerlink" href="#core-dump-support" title="Permalink to this headline">¶</a></h3>
<p>The allocation tags for user memory mapped with <code class="docutils literal notranslate"><span class="pre">PROT_MTE</span></code> are dumped
in the core file as additional <code class="docutils literal notranslate"><span class="pre">PT_AARCH64_MEMTAG_MTE</span></code> segments. The
program header for such segment is defined as:</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">p_type</span></code></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">PT_AARCH64_MEMTAG_MTE</span></code></p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">p_flags</span></code></dt>
<dd class="field-even"><p>0</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">p_offset</span></code></dt>
<dd class="field-odd"><p>segment file offset</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">p_vaddr</span></code></dt>
<dd class="field-even"><p>segment virtual address, same as the corresponding
<code class="docutils literal notranslate"><span class="pre">PT_LOAD</span></code> segment</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">p_paddr</span></code></dt>
<dd class="field-odd"><p>0</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">p_filesz</span></code></dt>
<dd class="field-even"><p>segment size in file, calculated as <code class="docutils literal notranslate"><span class="pre">p_mem_sz</span> <span class="pre">/</span> <span class="pre">32</span></code>
(two 4-bit tags cover 32 bytes of memory)</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">p_memsz</span></code></dt>
<dd class="field-odd"><p>segment size in memory, same as the corresponding
<code class="docutils literal notranslate"><span class="pre">PT_LOAD</span></code> segment</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">p_align</span></code></dt>
<dd class="field-even"><p>0</p>
</dd>
</dl>
<p>The tags are stored in the core file at <code class="docutils literal notranslate"><span class="pre">p_offset</span></code> as two 4-bit tags
in a byte. With the tag granule of 16 bytes, a 4K page requires 128
bytes in the core file.</p>
</section>
</section>
<section id="example-of-correct-usage">
<h2>Example of correct usage<a class="headerlink" href="#example-of-correct-usage" title="Permalink to this headline">¶</a></h2>
<p><em>MTE Example code</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * To be compiled with -march=armv8.5-a+memtag</span>
<span class="cm"> */</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/auxv.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/prctl.h&gt;</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * From arch/arm64/include/uapi/asm/hwcap.h</span>
<span class="cm"> */</span><span class="w"></span>
<span class="cp">#define HWCAP2_MTE              (1 &lt;&lt; 18)</span>

<span class="cm">/*</span>
<span class="cm"> * From arch/arm64/include/uapi/asm/mman.h</span>
<span class="cm"> */</span><span class="w"></span>
<span class="cp">#define PROT_MTE                 0x20</span>

<span class="cm">/*</span>
<span class="cm"> * From include/uapi/linux/prctl.h</span>
<span class="cm"> */</span><span class="w"></span>
<span class="cp">#define PR_SET_TAGGED_ADDR_CTRL 55</span>
<span class="cp">#define PR_GET_TAGGED_ADDR_CTRL 56</span>
<span class="cp"># define PR_TAGGED_ADDR_ENABLE  (1UL &lt;&lt; 0)</span>
<span class="cp"># define PR_MTE_TCF_SHIFT       1</span>
<span class="cp"># define PR_MTE_TCF_NONE        (0UL &lt;&lt; PR_MTE_TCF_SHIFT)</span>
<span class="cp"># define PR_MTE_TCF_SYNC        (1UL &lt;&lt; PR_MTE_TCF_SHIFT)</span>
<span class="cp"># define PR_MTE_TCF_ASYNC       (2UL &lt;&lt; PR_MTE_TCF_SHIFT)</span>
<span class="cp"># define PR_MTE_TCF_MASK        (3UL &lt;&lt; PR_MTE_TCF_SHIFT)</span>
<span class="cp"># define PR_MTE_TAG_SHIFT       3</span>
<span class="cp"># define PR_MTE_TAG_MASK        (0xffffUL &lt;&lt; PR_MTE_TAG_SHIFT)</span>

<span class="cm">/*</span>
<span class="cm"> * Insert a random logical tag into the given pointer.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="cp">#define insert_random_tag(ptr) ({                       \</span>
<span class="cp">        uint64_t __val;                                 \</span>
<span class="cp">        asm(&quot;irg %0, %1&quot; : &quot;=r&quot; (__val) : &quot;r&quot; (ptr));   \</span>
<span class="cp">        __val;                                          \</span>
<span class="cp">})</span>

<span class="cm">/*</span>
<span class="cm"> * Set the allocation tag on the destination address.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="cp">#define set_tag(tagged_addr) do {                                      \</span>
<span class="cp">        asm volatile(&quot;stg %0, [%0]&quot; : : &quot;r&quot; (tagged_addr) : &quot;memory&quot;); \</span>
<span class="cp">} while (0)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">page_sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_PAGESIZE</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">hwcap2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getauxval</span><span class="p">(</span><span class="n">AT_HWCAP2</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* check if MTE is present */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hwcap2</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">HWCAP2_MTE</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Enable the tagged address ABI, synchronous or asynchronous MTE</span>
<span class="cm">         * tag check faults (based on per-CPU preference) and allow all</span>
<span class="cm">         * non-zero tags in the randomly generated set.</span>
<span class="cm">         */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prctl</span><span class="p">(</span><span class="n">PR_SET_TAGGED_ADDR_CTRL</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">PR_TAGGED_ADDR_ENABLE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PR_MTE_TCF_SYNC</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PR_MTE_TCF_ASYNC</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">                  </span><span class="p">(</span><span class="mh">0xfffe</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PR_MTE_TAG_SHIFT</span><span class="p">),</span><span class="w"></span>
<span class="w">                  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;prctl() failed&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">page_sz</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">MAP_PRIVATE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MAP_ANONYMOUS</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAP_FAILED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;mmap() failed&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Enable MTE on the above anonymous mmap. The flag could be passed</span>
<span class="cm">         * directly to mmap() and skip this step.</span>
<span class="cm">         */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mprotect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">page_sz</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_MTE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;mprotect() failed&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* access with the default tag (0) */</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;a[0] = %hhu a[1] = %hhu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* set the logical and allocation tags */</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">insert_random_tag</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">set_tag</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* non-zero tag access */</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;a[0] = %hhu a[1] = %hhu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * If MTE is enabled correctly the next instruction will generate an</span>
<span class="cm">         * exception.</span>
<span class="cm">         */</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Expecting SIGSEGV...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xdd</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* this should not be printed in the PR_MTE_TCF_SYNC mode */</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;...haven&#39;t got one</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_FAILURE</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Memory Tagging Extension (MTE) in AArch64 Linux</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#userspace-support">Userspace Support</a><ul>
<li><a class="reference internal" href="#prot-mte">PROT_MTE</a></li>
<li><a class="reference internal" href="#tag-check-faults">Tag Check Faults</a></li>
<li><a class="reference internal" href="#excluding-tags-in-the-irg-addg-and-subg-instructions">Excluding Tags in the <code class="docutils literal notranslate"><span class="pre">IRG</span></code>, <code class="docutils literal notranslate"><span class="pre">ADDG</span></code> and <code class="docutils literal notranslate"><span class="pre">SUBG</span></code> instructions</a></li>
<li><a class="reference internal" href="#per-cpu-preferred-tag-checking-mode">Per-CPU preferred tag checking mode</a></li>
<li><a class="reference internal" href="#initial-process-state">Initial process state</a></li>
<li><a class="reference internal" href="#the-ptrace-interface">The <code class="docutils literal notranslate"><span class="pre">ptrace()</span></code> interface</a></li>
<li><a class="reference internal" href="#core-dump-support">Core dump support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-of-correct-usage">Example of correct usage</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/arm64/memory-tagging-extension.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/arm64/memory-tagging-extension.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>