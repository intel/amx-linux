
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>OMAP2/3 Display Subsystem &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="MFP Configuration for PXA2xx/PXA3xx Processors" href="../pxa/mfp.html" />
    <link rel="prev" title="The OMAP PM interface" href="omap_pm.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="omap2-3-display-subsystem">
<h1>OMAP2/3 Display Subsystem<a class="headerlink" href="#omap2-3-display-subsystem" title="Permalink to this headline">¶</a></h1>
<p>This is an almost total rewrite of the OMAP FB driver in drivers/video/omap
(let’s call it DSS1). The main differences between DSS1 and DSS2 are DSI,
TV-out and multiple display support, but there are lots of small improvements
also.</p>
<p>The DSS2 driver (omapdss module) is in arch/arm/plat-omap/dss/, and the FB,
panel and controller drivers are in drivers/video/omap2/. DSS1 and DSS2 live
currently side by side, you can choose which one to use.</p>
<section id="features">
<h2>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<p>Working and tested features include:</p>
<ul class="simple">
<li><p>MIPI DPI (parallel) output</p></li>
<li><p>MIPI DSI output in command mode</p></li>
<li><p>MIPI DBI (RFBI) output</p></li>
<li><p>SDI output</p></li>
<li><p>TV output</p></li>
<li><p>All pieces can be compiled as a module or inside kernel</p></li>
<li><p>Use DISPC to update any of the outputs</p></li>
<li><p>Use CPU to update RFBI or DSI output</p></li>
<li><p>OMAP DISPC planes</p></li>
<li><p>RGB16, RGB24 packed, RGB24 unpacked</p></li>
<li><p>YUV2, UYVY</p></li>
<li><p>Scaling</p></li>
<li><p>Adjusting DSS FCK to find a good pixel clock</p></li>
<li><p>Use DSI DPLL to create DSS FCK</p></li>
</ul>
<p>Tested boards include:
- OMAP3 SDP board
- Beagle board
- N810</p>
</section>
<section id="omapdss-driver">
<h2>omapdss driver<a class="headerlink" href="#omapdss-driver" title="Permalink to this headline">¶</a></h2>
<p>The DSS driver does not itself have any support for Linux framebuffer, V4L or
such like the current ones, but it has an internal kernel API that upper level
drivers can use.</p>
<p>The DSS driver models OMAP’s overlays, overlay managers and displays in a
flexible way to enable non-common multi-display configuration. In addition to
modelling the hardware overlays, omapdss supports virtual overlays and overlay
managers. These can be used when updating a display with CPU or system DMA.</p>
</section>
<section id="omapdss-driver-support-for-audio">
<h2>omapdss driver support for audio<a class="headerlink" href="#omapdss-driver-support-for-audio" title="Permalink to this headline">¶</a></h2>
<p>There exist several display technologies and standards that support audio as
well. Hence, it is relevant to update the DSS device driver to provide an audio
interface that may be used by an audio driver or any other driver interested in
the functionality.</p>
<p>The audio_enable function is intended to prepare the relevant
IP for playback (e.g., enabling an audio FIFO, taking in/out of reset
some IP, enabling companion chips, etc). It is intended to be called before
audio_start. The audio_disable function performs the reverse operation and is
intended to be called after audio_stop.</p>
<p>While a given DSS device driver may support audio, it is possible that for
certain configurations audio is not supported (e.g., an HDMI display using a
VESA video timing). The audio_supported function is intended to query whether
the current configuration of the display supports audio.</p>
<p>The audio_config function is intended to configure all the relevant audio
parameters of the display. In order to make the function independent of any
specific DSS device driver, a struct omap_dss_audio is defined. Its purpose
is to contain all the required parameters for audio configuration. At the
moment, such structure contains pointers to IEC-60958 channel status word
and CEA-861 audio infoframe structures. This should be enough to support
HDMI and DisplayPort, as both are based on CEA-861 and IEC-60958.</p>
<p>The audio_enable/disable, audio_config and audio_supported functions could be
implemented as functions that may sleep. Hence, they should not be called
while holding a spinlock or a readlock.</p>
<p>The audio_start/audio_stop function is intended to effectively start/stop audio
playback after the configuration has taken place. These functions are designed
to be used in an atomic context. Hence, audio_start should return quickly and be
called only after all the needed resources for audio playback (audio FIFOs,
DMA channels, companion chips, etc) have been enabled to begin data transfers.
audio_stop is designed to only stop the audio transfers. The resources used
for playback are released using audio_disable.</p>
<p>The enum omap_dss_audio_state may be used to help the implementations of
the interface to keep track of the audio state. The initial state is _DISABLED;
then, the state transitions to _CONFIGURED, and then, when it is ready to
play audio, to _ENABLED. The state _PLAYING is used when the audio is being
rendered.</p>
</section>
<section id="panel-and-controller-drivers">
<h2>Panel and controller drivers<a class="headerlink" href="#panel-and-controller-drivers" title="Permalink to this headline">¶</a></h2>
<p>The drivers implement panel or controller specific functionality and are not
usually visible to users except through omapfb driver.  They register
themselves to the DSS driver.</p>
</section>
<section id="omapfb-driver">
<h2>omapfb driver<a class="headerlink" href="#omapfb-driver" title="Permalink to this headline">¶</a></h2>
<p>The omapfb driver implements arbitrary number of standard linux framebuffers.
These framebuffers can be routed flexibly to any overlays, thus allowing very
dynamic display architecture.</p>
<p>The driver exports some omapfb specific ioctls, which are compatible with the
ioctls in the old driver.</p>
<p>The rest of the non standard features are exported via sysfs. Whether the final
implementation will use sysfs, or ioctls, is still open.</p>
</section>
<section id="v4l2-drivers">
<h2>V4L2 drivers<a class="headerlink" href="#v4l2-drivers" title="Permalink to this headline">¶</a></h2>
<p>V4L2 is being implemented in TI.</p>
<p>From omapdss point of view the V4L2 drivers should be similar to framebuffer
driver.</p>
</section>
<section id="architecture">
<h2>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h2>
<p>Some clarification what the different components do:</p>
<blockquote>
<div><ul class="simple">
<li><p>Framebuffer is a memory area inside OMAP’s SRAM/SDRAM that contains the
pixel data for the image. Framebuffer has width and height and color
depth.</p></li>
<li><p>Overlay defines where the pixels are read from and where they go on the
screen. The overlay may be smaller than framebuffer, thus displaying only
part of the framebuffer. The position of the overlay may be changed if
the overlay is smaller than the display.</p></li>
<li><p>Overlay manager combines the overlays in to one image and feeds them to
display.</p></li>
<li><p>Display is the actual physical display device.</p></li>
</ul>
</div></blockquote>
<p>A framebuffer can be connected to multiple overlays to show the same pixel data
on all of the overlays. Note that in this case the overlay input sizes must be
the same, but, in case of video overlays, the output size can be different. Any
framebuffer can be connected to any overlay.</p>
<p>An overlay can be connected to one overlay manager. Also DISPC overlays can be
connected only to DISPC overlay managers, and virtual overlays can be only
connected to virtual overlays.</p>
<p>An overlay manager can be connected to one display. There are certain
restrictions which kinds of displays an overlay manager can be connected:</p>
<blockquote>
<div><ul class="simple">
<li><p>DISPC TV overlay manager can be only connected to TV display.</p></li>
<li><p>Virtual overlay managers can only be connected to DBI or DSI displays.</p></li>
<li><p>DISPC LCD overlay manager can be connected to all displays, except TV
display.</p></li>
</ul>
</div></blockquote>
</section>
<section id="sysfs">
<h2>Sysfs<a class="headerlink" href="#sysfs" title="Permalink to this headline">¶</a></h2>
<p>The sysfs interface is mainly used for testing. I don’t think sysfs
interface is the best for this in the final version, but I don’t quite know
what would be the best interfaces for these things.</p>
<p>The sysfs interface is divided to two parts: DSS and FB.</p>
<p>/sys/class/graphics/fb? directory:
mirror          0=off, 1=on
rotate          Rotation 0-3 for 0, 90, 180, 270 degrees
rotate_type     0 = DMA rotation, 1 = VRFB rotation
overlays        List of overlay numbers to which framebuffer pixels go
phys_addr       Physical address of the framebuffer
virt_addr       Virtual address of the framebuffer
size            Size of the framebuffer</p>
<p>/sys/devices/platform/omapdss/overlay? directory:
enabled         0=off, 1=on
input_size      width,height (ie. the framebuffer size)
manager         Destination overlay manager name
name
output_size     width,height
position        x,y
screen_width    width
global_alpha    global alpha 0-255 0=transparent 255=opaque</p>
<p>/sys/devices/platform/omapdss/manager? directory:
display                         Destination display
name
alpha_blending_enabled          0=off, 1=on
trans_key_enabled               0=off, 1=on
trans_key_type                  gfx-destination, video-source
trans_key_value                 transparency color key (RGB24)
default_color                   default background color (RGB24)</p>
<p>/sys/devices/platform/omapdss/display? directory:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>ctrl_name</p></td>
<td><p>Controller name</p></td>
</tr>
<tr class="row-even"><td><p>mirror</p></td>
<td><p>0=off, 1=on</p></td>
</tr>
<tr class="row-odd"><td><p>update_mode</p></td>
<td><p>0=off, 1=auto, 2=manual</p></td>
</tr>
<tr class="row-even"><td><p>enabled</p></td>
<td><p>0=off, 1=on</p></td>
</tr>
<tr class="row-odd"><td><p>name</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>rotate</p></td>
<td><p>Rotation 0-3 for 0, 90, 180, 270 degrees</p></td>
</tr>
<tr class="row-odd"><td><p>timings</p></td>
<td><p>Display timings (pixclock,xres/hfp/hbp/hsw,yres/vfp/vbp/vsw)
When writing, two special timings are accepted for tv-out:
“pal” and “ntsc”</p></td>
</tr>
<tr class="row-even"><td><p>panel_name</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>tear_elim</p></td>
<td><p>Tearing elimination 0=off, 1=on</p></td>
</tr>
<tr class="row-even"><td><p>output_type</p></td>
<td><p>Output type (video encoder only): “composite” or “svideo”</p></td>
</tr>
</tbody>
</table>
<p>There are also some debugfs files at &lt;debugfs&gt;/omapdss/ which show information
about clocks and registers.</p>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>The following definitions have been made for the examples below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ovl0=/sys/devices/platform/omapdss/overlay0
ovl1=/sys/devices/platform/omapdss/overlay1
ovl2=/sys/devices/platform/omapdss/overlay2

mgr0=/sys/devices/platform/omapdss/manager0
mgr1=/sys/devices/platform/omapdss/manager1

lcd=/sys/devices/platform/omapdss/display0
dvi=/sys/devices/platform/omapdss/display1
tv=/sys/devices/platform/omapdss/display2

fb0=/sys/class/graphics/fb0
fb1=/sys/class/graphics/fb1
fb2=/sys/class/graphics/fb2
</pre></div>
</div>
</section>
<section id="default-setup-on-omap3-sdp">
<h2>Default setup on OMAP3 SDP<a class="headerlink" href="#default-setup-on-omap3-sdp" title="Permalink to this headline">¶</a></h2>
<p>Here’s the default setup on OMAP3 SDP board. All planes go to LCD. DVI
and TV-out are not in use. The columns from left to right are:
framebuffers, overlays, overlay managers, displays. Framebuffers are
handled by omapfb, and the rest by the DSS:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FB0 --- GFX  -\            DVI
FB1 --- VID1 --+- LCD ---- LCD
FB2 --- VID2 -/   TV ----- TV
</pre></div>
</div>
</section>
<section id="example-switch-from-lcd-to-dvi">
<h2>Example: Switch from LCD to DVI<a class="headerlink" href="#example-switch-from-lcd-to-dvi" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>w=`cat $dvi/timings | cut -d &quot;,&quot; -f 2 | cut -d &quot;/&quot; -f 1`
h=`cat $dvi/timings | cut -d &quot;,&quot; -f 3 | cut -d &quot;/&quot; -f 1`

echo &quot;0&quot; &gt; $lcd/enabled
echo &quot;&quot; &gt; $mgr0/display
fbset -fb /dev/fb0 -xres $w -yres $h -vxres $w -vyres $h
# at this point you have to switch the dvi/lcd dip-switch from the omap board
echo &quot;dvi&quot; &gt; $mgr0/display
echo &quot;1&quot; &gt; $dvi/enabled
</pre></div>
</div>
<p>After this the configuration looks like::</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FB0 --- GFX  -\         -- DVI
FB1 --- VID1 --+- LCD -/   LCD
FB2 --- VID2 -/   TV ----- TV
</pre></div>
</div>
</section>
<section id="example-clone-gfx-overlay-to-lcd-and-tv">
<h2>Example: Clone GFX overlay to LCD and TV<a class="headerlink" href="#example-clone-gfx-overlay-to-lcd-and-tv" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>w=`cat $tv/timings | cut -d &quot;,&quot; -f 2 | cut -d &quot;/&quot; -f 1`
h=`cat $tv/timings | cut -d &quot;,&quot; -f 3 | cut -d &quot;/&quot; -f 1`

echo &quot;0&quot; &gt; $ovl0/enabled
echo &quot;0&quot; &gt; $ovl1/enabled

echo &quot;&quot; &gt; $fb1/overlays
echo &quot;0,1&quot; &gt; $fb0/overlays

echo &quot;$w,$h&quot; &gt; $ovl1/output_size
echo &quot;tv&quot; &gt; $ovl1/manager

echo &quot;1&quot; &gt; $ovl0/enabled
echo &quot;1&quot; &gt; $ovl1/enabled

echo &quot;1&quot; &gt; $tv/enabled
</pre></div>
</div>
<p>After this the configuration looks like (only relevant parts shown):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FB0 +-- GFX  ---- LCD ---- LCD
\- VID1 ---- TV  ---- TV
</pre></div>
</div>
</section>
<section id="misc-notes">
<h2>Misc notes<a class="headerlink" href="#misc-notes" title="Permalink to this headline">¶</a></h2>
<p>OMAP FB allocates the framebuffer memory using the standard dma allocator. You
can enable Contiguous Memory Allocator (CONFIG_CMA) to improve the dma
allocator, and if CMA is enabled, you use “cma=” kernel parameter to increase
the global memory area for CMA.</p>
<p>Using DSI DPLL to generate pixel clock it is possible produce the pixel clock
of 86.5MHz (max possible), and with that you get <a class="reference external" href="mailto:1280x1024&#37;&#52;&#48;57">1280x1024<span>&#64;</span>57</a> output from DVI.</p>
<p>Rotation and mirroring currently only supports RGB565 and RGB8888 modes. VRFB
does not support mirroring.</p>
<p>VRFB rotation requires much more memory than non-rotated framebuffer, so you
probably need to increase your vram setting before using VRFB rotation. Also,
many applications may not work with VRFB if they do not pay attention to all
framebuffer parameters.</p>
</section>
<section id="kernel-boot-arguments">
<h2>Kernel boot arguments<a class="headerlink" href="#kernel-boot-arguments" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>omapfb.mode=&lt;display&gt;:&lt;mode&gt;[,…]</dt><dd><ul class="simple">
<li><p>Default video mode for specified displays. For example,
“dvi:800x400MR-24&#64;60”.  See drivers/video/modedb.c.
There are also two special modes: “pal” and “ntsc” that
can be used to tv out.</p></li>
</ul>
</dd>
<dt>omapfb.vram=&lt;fbnum&gt;:&lt;size&gt;[&#64;&lt;physaddr&gt;][,…]</dt><dd><ul class="simple">
<li><p>VRAM allocated for a framebuffer. Normally omapfb allocates vram
depending on the display size. With this you can manually allocate
more or define the physical address of each framebuffer. For example,
“1:4M” to allocate 4M for fb1.</p></li>
</ul>
</dd>
<dt>omapfb.debug=&lt;y|n&gt;</dt><dd><ul class="simple">
<li><p>Enable debug printing. You have to have OMAPFB debug support enabled
in kernel config.</p></li>
</ul>
</dd>
<dt>omapfb.test=&lt;y|n&gt;</dt><dd><ul class="simple">
<li><p>Draw test pattern to framebuffer whenever framebuffer settings change.
You need to have OMAPFB debug support enabled in kernel config.</p></li>
</ul>
</dd>
<dt>omapfb.vrfb=&lt;y|n&gt;</dt><dd><ul class="simple">
<li><p>Use VRFB rotation for all framebuffers.</p></li>
</ul>
</dd>
<dt>omapfb.rotate=&lt;angle&gt;</dt><dd><ul class="simple">
<li><p>Default rotation applied to all framebuffers.
0 - 0 degree rotation
1 - 90 degree rotation
2 - 180 degree rotation
3 - 270 degree rotation</p></li>
</ul>
</dd>
<dt>omapfb.mirror=&lt;y|n&gt;</dt><dd><ul class="simple">
<li><p>Default mirror for all framebuffers. Only works with DMA rotation.</p></li>
</ul>
</dd>
<dt>omapdss.def_disp=&lt;display&gt;</dt><dd><ul class="simple">
<li><p>Name of default display, to which all overlays will be connected.
Common examples are “lcd” or “tv”.</p></li>
</ul>
</dd>
<dt>omapdss.debug=&lt;y|n&gt;</dt><dd><ul class="simple">
<li><p>Enable debug printing. You have to have DSS debug support enabled in
kernel config.</p></li>
</ul>
</dd>
</dl>
</section>
<section id="todo">
<h2>TODO<a class="headerlink" href="#todo" title="Permalink to this headline">¶</a></h2>
<p>DSS locking</p>
<p>Error checking</p>
<ul class="simple">
<li><p>Lots of checks are missing or implemented just as BUG()</p></li>
</ul>
<p>System DMA update for DSI</p>
<ul class="simple">
<li><p>Can be used for RGB16 and RGB24P modes. Probably not for RGB24U (how
to skip the empty byte?)</p></li>
</ul>
<p>OMAP1 support</p>
<ul class="simple">
<li><p>Not sure if needed</p></li>
</ul>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">OMAP2/3 Display Subsystem</a><ul>
<li><a class="reference internal" href="#features">Features</a></li>
<li><a class="reference internal" href="#omapdss-driver">omapdss driver</a></li>
<li><a class="reference internal" href="#omapdss-driver-support-for-audio">omapdss driver support for audio</a></li>
<li><a class="reference internal" href="#panel-and-controller-drivers">Panel and controller drivers</a></li>
<li><a class="reference internal" href="#omapfb-driver">omapfb driver</a></li>
<li><a class="reference internal" href="#v4l2-drivers">V4L2 drivers</a></li>
<li><a class="reference internal" href="#architecture">Architecture</a></li>
<li><a class="reference internal" href="#sysfs">Sysfs</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#default-setup-on-omap3-sdp">Default setup on OMAP3 SDP</a></li>
<li><a class="reference internal" href="#example-switch-from-lcd-to-dvi">Example: Switch from LCD to DVI</a></li>
<li><a class="reference internal" href="#example-clone-gfx-overlay-to-lcd-and-tv">Example: Clone GFX overlay to LCD and TV</a></li>
<li><a class="reference internal" href="#misc-notes">Misc notes</a></li>
<li><a class="reference internal" href="#kernel-boot-arguments">Kernel boot arguments</a></li>
<li><a class="reference internal" href="#todo">TODO</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/arm/omap/dss.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/arm/omap/dss.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>