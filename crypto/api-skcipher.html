
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Block Cipher Algorithm Definitions &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Authenticated Encryption With Associated Data (AEAD) Algorithm Definitions" href="api-aead.html" />
    <link rel="prev" title="Programming Interface" href="api.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="block-cipher-algorithm-definitions">
<h1>Block Cipher Algorithm Definitions<a class="headerlink" href="#block-cipher-algorithm-definitions" title="Permalink to this headline">¶</a></h1>
<p>These data structures define modular crypto algorithm implementations,
managed via crypto_register_alg() and crypto_unregister_alg().</p>
<dl class="type">
<dt id="c.cipher_alg">
struct <code class="sig-name descname">cipher_alg</code><a class="headerlink" href="#c.cipher_alg" title="Permalink to this definition">¶</a></dt>
<dd><p>single-block symmetric ciphers definition</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cipher_alg {
    unsigned int cia_min_keysize;
    unsigned int cia_max_keysize;
    int (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen);
    void (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
    void (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cia_min_keysize</span></code></dt><dd><p>Minimum key size supported by the transformation. This is
the smallest key length supported by this transformation
algorithm. This must be set to one of the pre-defined
values as this is not hardware specific. Possible values
for this field can be found via git grep “_MIN_KEY_SIZE”
include/crypto/</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cia_max_keysize</span></code></dt><dd><p>Maximum key size supported by the transformation. This is
the largest key length supported by this transformation
algorithm. This must be set to one of the pre-defined values
as this is not hardware specific. Possible values for this
field can be found via git grep “_MAX_KEY_SIZE”
include/crypto/</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cia_setkey</span></code></dt><dd><p>Set key for the transformation. This function is used to either
program a supplied key into the hardware or store the key in the
transformation context for programming it later. Note that this
function does modify the transformation context. This function
can be called multiple times during the existence of the
transformation object, so one must make sure the key is properly
reprogrammed into the hardware. This function is also
responsible for checking the key length for validity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cia_encrypt</span></code></dt><dd><p>Encrypt a single block. This function is used to encrypt a
single block of data, which must be <strong>cra_blocksize</strong> big. This
always operates on a full <strong>cra_blocksize</strong> and it is not possible
to encrypt a block of smaller size. The supplied buffers must
therefore also be at least of <strong>cra_blocksize</strong> size. Both the
input and output buffers are always aligned to <strong>cra_alignmask</strong>.
In case either of the input or output buffer supplied by user
of the crypto API is not aligned to <strong>cra_alignmask</strong>, the crypto
API will re-align the buffers. The re-alignment means that a
new buffer will be allocated, the data will be copied into the
new buffer, then the processing will happen on the new buffer,
then the data will be copied back into the original buffer and
finally the new buffer will be freed. In case a software
fallback was put in place in the <strong>cra_init</strong> call, this function
might need to use the fallback if the algorithm doesn’t support
all of the key sizes. In case the key was stored in
transformation context, the key might need to be re-programmed
into the hardware in this function. This function shall not
modify the transformation context, as this function may be
called in parallel with the same transformation object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cia_decrypt</span></code></dt><dd><p>Decrypt a single block. This is a reverse counterpart to
<strong>cia_encrypt</strong>, and the conditions are exactly the same.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>All fields are mandatory and must be filled.</p>
<dl class="type">
<dt id="c.compress_alg">
struct <code class="sig-name descname">compress_alg</code><a class="headerlink" href="#c.compress_alg" title="Permalink to this definition">¶</a></dt>
<dd><p>compression/decompression algorithm</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct compress_alg {
    int (*coa_compress)(struct crypto_tfm *tfm, const u8 *src, unsigned int slen, u8 *dst, unsigned int *dlen);
    int (*coa_decompress)(struct crypto_tfm *tfm, const u8 *src, unsigned int slen, u8 *dst, unsigned int *dlen);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">coa_compress</span></code></dt><dd><p>Compress a buffer of specified length, storing the resulting
data in the specified buffer. Return the length of the
compressed data in dlen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">coa_decompress</span></code></dt><dd><p>Decompress the source buffer, storing the uncompressed
data in the specified buffer. The length of the data is
returned in dlen.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>All fields are mandatory.</p>
<dl class="type">
<dt id="c.crypto_alg">
struct <code class="sig-name descname">crypto_alg</code><a class="headerlink" href="#c.crypto_alg" title="Permalink to this definition">¶</a></dt>
<dd><p>definition of a cryptograpic cipher algorithm</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct crypto_alg {
    struct list_head cra_list;
    struct list_head cra_users;
    u32 cra_flags;
    unsigned int cra_blocksize;
    unsigned int cra_ctxsize;
    unsigned int cra_alignmask;
    int cra_priority;
    refcount_t cra_refcnt;
    char cra_name[CRYPTO_MAX_ALG_NAME];
    char cra_driver_name[CRYPTO_MAX_ALG_NAME];
    const struct crypto_type *cra_type;
    union {
        struct cipher_alg cipher;
        struct compress_alg compress;
    } cra_u;
    int (*cra_init)(struct crypto_tfm *tfm);
    void (*cra_exit)(struct crypto_tfm *tfm);
    void (*cra_destroy)(struct crypto_alg *alg);
    struct module *cra_module;
#ifdef CONFIG_CRYPTO_STATS;
    union {
        struct crypto_istat_aead aead;
        struct crypto_istat_akcipher akcipher;
        struct crypto_istat_cipher cipher;
        struct crypto_istat_compress compress;
        struct crypto_istat_hash hash;
        struct crypto_istat_rng rng;
        struct crypto_istat_kpp kpp;
    } stats;
#endif ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cra_list</span></code></dt><dd><p>internally used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_users</span></code></dt><dd><p>internally used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_flags</span></code></dt><dd><p>Flags describing this transformation. See include/linux/crypto.h
CRYPTO_ALG_* flags for the flags which go in here. Those are
used for fine-tuning the description of the transformation
algorithm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_blocksize</span></code></dt><dd><p>Minimum block size of this transformation. The size in bytes
of the smallest possible unit which can be transformed with
this algorithm. The users must respect this value.
In case of HASH transformation, it is possible for a smaller
block than <strong>cra_blocksize</strong> to be passed to the crypto API for
transformation, in case of any other transformation type, an
error will be returned upon any attempt to transform smaller
than <strong>cra_blocksize</strong> chunks.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_ctxsize</span></code></dt><dd><p>Size of the operational context of the transformation. This
value informs the kernel crypto API about the memory size
needed to be allocated for the transformation context.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_alignmask</span></code></dt><dd><p>Alignment mask for the input and output data buffer. The data
buffer containing the input data for the algorithm must be
aligned to this alignment mask. The data buffer for the
output data must be aligned to this alignment mask. Note that
the Crypto API will do the re-alignment in software, but
only under special conditions and there is a performance hit.
The re-alignment happens at these occasions for different
<strong>cra_u</strong> types: cipher – For both input data and output data
buffer; ahash – For output hash destination buf; shash –
For output hash destination buf.
This is needed on hardware which is flawed by design and
cannot pick data from arbitrary addresses.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_priority</span></code></dt><dd><p>Priority of this transformation implementation. In case
multiple transformations with same <strong>cra_name</strong> are available to
the Crypto API, the kernel will use the one with highest
<strong>cra_priority</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_refcnt</span></code></dt><dd><p>internally used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_name</span></code></dt><dd><p>Generic name (usable by multiple implementations) of the
transformation algorithm. This is the name of the transformation
itself. This field is used by the kernel when looking up the
providers of particular transformation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_driver_name</span></code></dt><dd><p>Unique name of the transformation provider. This is the
name of the provider of the transformation. This can be any
arbitrary value, but in the usual case, this contains the
name of the chip or provider and the name of the
transformation algorithm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_type</span></code></dt><dd><p>Type of the cryptographic transformation. This is a pointer to
struct crypto_type, which implements callbacks common for all
transformation types. There are multiple options, such as
<code class="xref c c-type docutils literal notranslate"><span class="pre">crypto_skcipher_type</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">crypto_ahash_type</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">crypto_rng_type</span></code>.
This field might be empty. In that case, there are no common
callbacks. This is the case for: cipher, compress, shash.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_u</span></code></dt><dd><p>Callbacks implementing the transformation. This is a union of
multiple structures. Depending on the type of transformation selected
by <strong>cra_type</strong> and <strong>cra_flags</strong> above, the associated structure must be
filled with callbacks. This field might be empty. This is the case
for ahash, shash.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_u.cipher</span></code></dt><dd><p>Union member which contains a single-block symmetric cipher
definition. See <strong>struct</strong> <strong>cipher_alg</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_u.compress</span></code></dt><dd><p>Union member which contains a (de)compression algorithm.
See <strong>struct</strong> <strong>compress_alg</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_init</span></code></dt><dd><p>Initialize the cryptographic transformation object. This function
is used to initialize the cryptographic transformation object.
This function is called only once at the instantiation time, right
after the transformation context was allocated. In case the
cryptographic hardware has some special requirements which need to
be handled by software, this function shall check for the precise
requirement of the transformation and put any software fallbacks
in place.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_exit</span></code></dt><dd><p>Deinitialize the cryptographic transformation object. This is a
counterpart to <strong>cra_init</strong>, used to remove various changes set in
<strong>cra_init</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_destroy</span></code></dt><dd><p>internally used</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cra_module</span></code></dt><dd><p>Owner of this transformation implementation. Set to THIS_MODULE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats</span></code></dt><dd><p>union of all possible crypto_istat_xxx structures</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats.aead</span></code></dt><dd><p>statistics for AEAD algorithm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats.akcipher</span></code></dt><dd><p>statistics for akcipher algorithm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats.cipher</span></code></dt><dd><p>statistics for cipher algorithm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats.compress</span></code></dt><dd><p>statistics for compress algorithm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats.hash</span></code></dt><dd><p>statistics for hash algorithm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats.rng</span></code></dt><dd><p>statistics for rng algorithm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">stats.kpp</span></code></dt><dd><p>statistics for KPP algorithm</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.crypto_alg" title="crypto_alg"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_alg</span></code></a> describes a generic Crypto API algorithm and is common
for all of the transformations. Any variable not documented here shall not
be used by a cipher implementation as it is internal to the Crypto API.</p>
</section>
<section id="symmetric-key-cipher-api">
<h1>Symmetric Key Cipher API<a class="headerlink" href="#symmetric-key-cipher-api" title="Permalink to this headline">¶</a></h1>
<p>Symmetric key cipher API is used with the ciphers of type
CRYPTO_ALG_TYPE_SKCIPHER (listed as type “skcipher” in /proc/crypto).</p>
<p>Asynchronous cipher operations imply that the function invocation for a
cipher request returns immediately before the completion of the operation.
The cipher request is scheduled as a separate kernel thread and therefore
load-balanced on the different CPUs via the process scheduler. To allow
the kernel crypto API to inform the caller about the completion of a cipher
request, the caller must provide a callback function. That function is
invoked with the cipher handle when the request completes.</p>
<p>To support the asynchronous operation, additional information than just the
cipher handle must be supplied to the kernel crypto API. That additional
information is given by filling in the skcipher_request data structure.</p>
<p>For the symmetric key cipher API, the state is maintained with the tfm
cipher handle. A single tfm can be used across multiple calls and in
parallel. For asynchronous block cipher calls, context data supplied and
only used by the caller can be referenced the request data structure in
addition to the IV used for the cipher request. The maintenance of such
state information would be important for a crypto driver implementer to
have, because when calling the callback function upon completion of the
cipher operation, that callback function may need some information about
which operation just finished if it invoked multiple in parallel. This
state information is unused by the kernel crypto API.</p>
<dl class="function">
<dt id="c.crypto_alloc_skcipher">
struct crypto_skcipher * <code class="sig-name descname">crypto_alloc_skcipher</code><span class="sig-paren">(</span>const char<em> *alg_name</em>, u32<em> type</em>, u32<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_alloc_skcipher" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate symmetric key cipher handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*alg_name</span></code></dt><dd><p>is the cra_name / name or cra_driver_name / driver name of the
skcipher cipher</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">type</span></code></dt><dd><p>specifies the type of the cipher</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mask</span></code></dt><dd><p>specifies the mask for the cipher</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a cipher handle for an skcipher. The returned struct
crypto_skcipher is the cipher handle that is required for any subsequent
API invocation for that skcipher.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>allocated cipher handle in case of success; IS_ERR() is true in case</dt><dd><p>of an error, PTR_ERR() returns the error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.crypto_free_skcipher">
void <code class="sig-name descname">crypto_free_skcipher</code><span class="sig-paren">(</span>struct crypto_skcipher<em> *tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_free_skcipher" title="Permalink to this definition">¶</a></dt>
<dd><p>zeroize and free cipher handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle to be freed</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>tfm</strong> is a NULL or error pointer, this function does nothing.</p>
</div>
<dl class="function">
<dt id="c.crypto_has_skcipher">
int <code class="sig-name descname">crypto_has_skcipher</code><span class="sig-paren">(</span>const char<em> *alg_name</em>, u32<em> type</em>, u32<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_has_skcipher" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for the availability of an skcipher.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*alg_name</span></code></dt><dd><p>is the cra_name / name or cra_driver_name / driver name of the
skcipher</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">type</span></code></dt><dd><p>specifies the type of the skcipher</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mask</span></code></dt><dd><p>specifies the mask for the skcipher</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>true when the skcipher is known to the kernel crypto API; false</dt><dd><p>otherwise</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.crypto_skcipher_ivsize">
unsigned int <code class="sig-name descname">crypto_skcipher_ivsize</code><span class="sig-paren">(</span>struct crypto_skcipher<em> *tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_ivsize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain IV size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The size of the IV for the skcipher referenced by the cipher handle is
returned. This IV size may be zero if the cipher does not need an IV.</p>
<p><strong>Return</strong></p>
<p>IV size in bytes</p>
</div>
<dl class="function">
<dt id="c.crypto_skcipher_blocksize">
unsigned int <code class="sig-name descname">crypto_skcipher_blocksize</code><span class="sig-paren">(</span>struct crypto_skcipher<em> *tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_blocksize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain block size of cipher</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The block size for the skcipher referenced with the cipher handle is
returned. The caller may use that information to allocate appropriate
memory for the data returned by the encryption or decryption operation</p>
<p><strong>Return</strong></p>
<p>block size of cipher</p>
</div>
<dl class="function">
<dt id="c.crypto_skcipher_setkey">
int <code class="sig-name descname">crypto_skcipher_setkey</code><span class="sig-paren">(</span>struct crypto_skcipher<em> *tfm</em>, const u8<em> *key</em>, unsigned int<em> keylen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_setkey" title="Permalink to this definition">¶</a></dt>
<dd><p>set key for cipher</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*key</span></code></dt><dd><p>buffer holding the key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">keylen</span></code></dt><dd><p>length of the key in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller provided key is set for the skcipher referenced by the cipher
handle.</p>
<p>Note, the key length determines the cipher type. Many block ciphers implement
different cipher modes depending on the key size, such as AES-128 vs AES-192
vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128
is performed.</p>
<p><strong>Return</strong></p>
<p>0 if the setting of the key was successful; &lt; 0 if an error occurred</p>
</div>
<dl class="function">
<dt id="c.crypto_skcipher_reqtfm">
struct crypto_skcipher * <code class="sig-name descname">crypto_skcipher_reqtfm</code><span class="sig-paren">(</span>struct skcipher_request<em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_reqtfm" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain cipher handle from request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*req</span></code></dt><dd><p>skcipher_request out of which the cipher handle is to be obtained</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the crypto_skcipher handle when furnishing an skcipher_request
data structure.</p>
<p><strong>Return</strong></p>
<p>crypto_skcipher handle</p>
</div>
<dl class="function">
<dt id="c.crypto_skcipher_encrypt">
int <code class="sig-name descname">crypto_skcipher_encrypt</code><span class="sig-paren">(</span>struct skcipher_request<em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_encrypt" title="Permalink to this definition">¶</a></dt>
<dd><p>encrypt plaintext</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*req</span></code></dt><dd><p>reference to the skcipher_request handle that holds all information
needed to perform the cipher operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Encrypt plaintext data using the skcipher_request handle. That data
structure and how it is filled with data is discussed with the
skcipher_request_* functions.</p>
<p><strong>Return</strong></p>
<p>0 if the cipher operation was successful; &lt; 0 if an error occurred</p>
</div>
<dl class="function">
<dt id="c.crypto_skcipher_decrypt">
int <code class="sig-name descname">crypto_skcipher_decrypt</code><span class="sig-paren">(</span>struct skcipher_request<em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_decrypt" title="Permalink to this definition">¶</a></dt>
<dd><p>decrypt ciphertext</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*req</span></code></dt><dd><p>reference to the skcipher_request handle that holds all information
needed to perform the cipher operation</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrypt ciphertext data using the skcipher_request handle. That data
structure and how it is filled with data is discussed with the
skcipher_request_* functions.</p>
<p><strong>Return</strong></p>
<p>0 if the cipher operation was successful; &lt; 0 if an error occurred</p>
</div>
</section>
<section id="symmetric-key-cipher-request-handle">
<h1>Symmetric Key Cipher Request Handle<a class="headerlink" href="#symmetric-key-cipher-request-handle" title="Permalink to this headline">¶</a></h1>
<p>The skcipher_request data structure contains all pointers to data
required for the symmetric key cipher operation. This includes the cipher
handle (which can be used by multiple skcipher_request instances), pointer
to plaintext and ciphertext, asynchronous callback function, etc. It acts
as a handle to the skcipher_request_* API calls in a similar way as
skcipher handle to the crypto_skcipher_* API calls.</p>
<dl class="function">
<dt id="c.crypto_skcipher_reqsize">
unsigned int <code class="sig-name descname">crypto_skcipher_reqsize</code><span class="sig-paren">(</span>struct crypto_skcipher<em> *tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_reqsize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain size of the request data structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>number of bytes</p>
</div>
<dl class="function">
<dt id="c.skcipher_request_set_tfm">
void <code class="sig-name descname">skcipher_request_set_tfm</code><span class="sig-paren">(</span>struct skcipher_request<em> *req</em>, struct crypto_skcipher<em> *tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skcipher_request_set_tfm" title="Permalink to this definition">¶</a></dt>
<dd><p>update cipher handle reference in request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*req</span></code></dt><dd><p>request handle to be modified</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle that shall be added to the request handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow the caller to replace the existing skcipher handle in the request
data structure with a different one.</p>
</div>
<dl class="function">
<dt id="c.skcipher_request_alloc">
struct skcipher_request * <code class="sig-name descname">skcipher_request_alloc</code><span class="sig-paren">(</span>struct crypto_skcipher<em> *tfm</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skcipher_request_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate request data structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle to be registered with the request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>memory allocation flag that is handed to kmalloc by the API call.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the request data structure that must be used with the skcipher
encrypt and decrypt API calls. During the allocation, the provided skcipher
handle is registered in the request data structure.</p>
<p><strong>Return</strong></p>
<p>allocated request handle in case of success, or NULL if out of memory</p>
</div>
<dl class="function">
<dt id="c.skcipher_request_free">
void <code class="sig-name descname">skcipher_request_free</code><span class="sig-paren">(</span>struct skcipher_request<em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skcipher_request_free" title="Permalink to this definition">¶</a></dt>
<dd><p>zeroize and free request data structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*req</span></code></dt><dd><p>request data structure cipher handle to be freed</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.skcipher_request_set_callback">
void <code class="sig-name descname">skcipher_request_set_callback</code><span class="sig-paren">(</span>struct skcipher_request<em> *req</em>, u32<em> flags</em>, crypto_completion_t<em> compl</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skcipher_request_set_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>set asynchronous callback function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*req</span></code></dt><dd><p>request handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flags</span></code></dt><dd><p>specify zero or an ORing of the flags
CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and
increase the wait queue beyond the initial maximum size;
CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crypto_completion_t</span> <span class="pre">compl</span></code></dt><dd><p>callback function pointer to be registered with the request handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>The data pointer refers to memory that is not used by the kernel
crypto API, but provided to the callback function for it to use. Here,
the caller can provide a reference to memory the callback function can
operate on. As the callback function is invoked asynchronously to the
related functionality, it may need to access data structures of the
related functionality which can be referenced using this pointer. The
callback function can access the memory via the “data” field in the
crypto_async_request data structure provided to the callback function.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows setting the callback function that is triggered once the
cipher operation completes.</p>
<p>The callback function is registered with the skcipher_request handle and
must comply with the following template:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void callback_function(struct crypto_async_request *req, int error)
</pre></div>
</div>
</div>
<dl class="function">
<dt id="c.skcipher_request_set_crypt">
void <code class="sig-name descname">skcipher_request_set_crypt</code><span class="sig-paren">(</span>struct skcipher_request<em> *req</em>, struct scatterlist<em> *src</em>, struct scatterlist<em> *dst</em>, unsigned int<em> cryptlen</em>, void<em> *iv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skcipher_request_set_crypt" title="Permalink to this definition">¶</a></dt>
<dd><p>set data buffers</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*req</span></code></dt><dd><p>request handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*src</span></code></dt><dd><p>source scatter / gather list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*dst</span></code></dt><dd><p>destination scatter / gather list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cryptlen</span></code></dt><dd><p>number of bytes to process from <strong>src</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*iv</span></code></dt><dd><p>IV for the cipher operation which must comply with the IV size defined
by crypto_skcipher_ivsize</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows setting of the source data and destination data
scatter / gather lists.</p>
<p>For encryption, the source is treated as the plaintext and the
destination is the ciphertext. For a decryption operation, the use is
reversed - the source is the ciphertext and the destination is the plaintext.</p>
</div>
</section>
<section id="single-block-cipher-api">
<h1>Single Block Cipher API<a class="headerlink" href="#single-block-cipher-api" title="Permalink to this headline">¶</a></h1>
<p>The single block cipher API is used with the ciphers of type
CRYPTO_ALG_TYPE_CIPHER (listed as type “cipher” in /proc/crypto).</p>
<p>Using the single block cipher API calls, operations with the basic cipher
primitive can be implemented. These cipher primitives exclude any block
chaining operations including IV handling.</p>
<p>The purpose of this single block cipher API is to support the implementation
of templates or other concepts that only need to perform the cipher operation
on one block at a time. Templates invoke the underlying cipher primitive
block-wise and process either the input or the output data of these cipher
operations.</p>
<dl class="function">
<dt id="c.crypto_alloc_cipher">
struct crypto_cipher * <code class="sig-name descname">crypto_alloc_cipher</code><span class="sig-paren">(</span>const char<em> *alg_name</em>, u32<em> type</em>, u32<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_alloc_cipher" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate single block cipher handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*alg_name</span></code></dt><dd><p>is the cra_name / name or cra_driver_name / driver name of the
single block cipher</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">type</span></code></dt><dd><p>specifies the type of the cipher</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mask</span></code></dt><dd><p>specifies the mask for the cipher</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a cipher handle for a single block cipher. The returned struct
crypto_cipher is the cipher handle that is required for any subsequent API
invocation for that single block cipher.</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>allocated cipher handle in case of success; IS_ERR() is true in case</dt><dd><p>of an error, PTR_ERR() returns the error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.crypto_free_cipher">
void <code class="sig-name descname">crypto_free_cipher</code><span class="sig-paren">(</span>struct crypto_cipher<em> *tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_free_cipher" title="Permalink to this definition">¶</a></dt>
<dd><p>zeroize and free the single block cipher handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_cipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle to be freed</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.crypto_has_cipher">
int <code class="sig-name descname">crypto_has_cipher</code><span class="sig-paren">(</span>const char<em> *alg_name</em>, u32<em> type</em>, u32<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_has_cipher" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for the availability of a single block cipher</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*alg_name</span></code></dt><dd><p>is the cra_name / name or cra_driver_name / driver name of the
single block cipher</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">type</span></code></dt><dd><p>specifies the type of the cipher</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mask</span></code></dt><dd><p>specifies the mask for the cipher</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>true when the single block cipher is known to the kernel crypto API;</dt><dd><p>false otherwise</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.crypto_cipher_blocksize">
unsigned int <code class="sig-name descname">crypto_cipher_blocksize</code><span class="sig-paren">(</span>struct crypto_cipher<em> *tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_cipher_blocksize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain block size for cipher</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_cipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The block size for the single block cipher referenced with the cipher handle
tfm is returned. The caller may use that information to allocate appropriate
memory for the data returned by the encryption or decryption operation</p>
<p><strong>Return</strong></p>
<p>block size of cipher</p>
</div>
<dl class="function">
<dt id="c.crypto_cipher_setkey">
int <code class="sig-name descname">crypto_cipher_setkey</code><span class="sig-paren">(</span>struct crypto_cipher<em> *tfm</em>, const u8<em> *key</em>, unsigned int<em> keylen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_cipher_setkey" title="Permalink to this definition">¶</a></dt>
<dd><p>set key for cipher</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_cipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*key</span></code></dt><dd><p>buffer holding the key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">keylen</span></code></dt><dd><p>length of the key in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller provided key is set for the single block cipher referenced by the
cipher handle.</p>
<p>Note, the key length determines the cipher type. Many block ciphers implement
different cipher modes depending on the key size, such as AES-128 vs AES-192
vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128
is performed.</p>
<p><strong>Return</strong></p>
<p>0 if the setting of the key was successful; &lt; 0 if an error occurred</p>
</div>
<dl class="function">
<dt id="c.crypto_cipher_encrypt_one">
void <code class="sig-name descname">crypto_cipher_encrypt_one</code><span class="sig-paren">(</span>struct crypto_cipher<em> *tfm</em>, u8<em> *dst</em>, const u8<em> *src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_cipher_encrypt_one" title="Permalink to this definition">¶</a></dt>
<dd><p>encrypt one block of plaintext</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_cipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*dst</span></code></dt><dd><p>points to the buffer that will be filled with the ciphertext</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*src</span></code></dt><dd><p>buffer holding the plaintext to be encrypted</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invoke the encryption operation of one block. The caller must ensure that
the plaintext and ciphertext buffers are at least one block in size.</p>
</div>
<dl class="function">
<dt id="c.crypto_cipher_decrypt_one">
void <code class="sig-name descname">crypto_cipher_decrypt_one</code><span class="sig-paren">(</span>struct crypto_cipher<em> *tfm</em>, u8<em> *dst</em>, const u8<em> *src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_cipher_decrypt_one" title="Permalink to this definition">¶</a></dt>
<dd><p>decrypt one block of ciphertext</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_cipher</span> <span class="pre">*tfm</span></code></dt><dd><p>cipher handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*dst</span></code></dt><dd><p>points to the buffer that will be filled with the plaintext</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*src</span></code></dt><dd><p>buffer holding the ciphertext to be decrypted</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invoke the decryption operation of one block. The caller must ensure that
the plaintext and ciphertext buffers are at least one block in size.</p>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Block Cipher Algorithm Definitions</a></li>
<li><a class="reference internal" href="#symmetric-key-cipher-api">Symmetric Key Cipher API</a></li>
<li><a class="reference internal" href="#symmetric-key-cipher-request-handle">Symmetric Key Cipher Request Handle</a></li>
<li><a class="reference internal" href="#single-block-cipher-api">Single Block Cipher API</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/crypto/api-skcipher.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/crypto/api-skcipher.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>