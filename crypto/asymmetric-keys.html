
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Asymmetric / Public-key Cryptography Key Type &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Developing Cipher Algorithms" href="devel-algos.html" />
    <link rel="prev" title="Asynchronous Transfers/Transforms API" href="async-tx-api.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="asymmetric-public-key-cryptography-key-type">
<h1>Asymmetric / Public-key Cryptography Key Type<a class="headerlink" href="#asymmetric-public-key-cryptography-key-type" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The “asymmetric” key type is designed to be a container for the keys used in
public-key cryptography, without imposing any particular restrictions on the
form or mechanism of the cryptography or form of the key.</p>
<p>The asymmetric key is given a subtype that defines what sort of data is
associated with the key and provides operations to describe and destroy it.
However, no requirement is made that the key data actually be stored in the
key.</p>
<p>A completely in-kernel key retention and operation subtype can be defined, but
it would also be possible to provide access to cryptographic hardware (such as
a TPM) that might be used to both retain the relevant key and perform
operations using that key.  In such a case, the asymmetric key would then
merely be an interface to the TPM driver.</p>
<p>Also provided is the concept of a data parser.  Data parsers are responsible
for extracting information from the blobs of data passed to the instantiation
function.  The first data parser that recognises the blob gets to set the
subtype of the key and define the operations that can be done on that key.</p>
<p>A data parser may interpret the data blob as containing the bits representing a
key, or it may interpret it as a reference to a key held somewhere else in the
system (for example, a TPM).</p>
</section>
<section id="key-identification">
<h2>Key Identification<a class="headerlink" href="#key-identification" title="Permalink to this headline">¶</a></h2>
<p>If a key is added with an empty name, the instantiation data parsers are given
the opportunity to pre-parse a key and to determine the description the key
should be given from the content of the key.</p>
<p>This can then be used to refer to the key, either by complete match or by
partial match.  The key type may also use other criteria to refer to a key.</p>
<p>The asymmetric key type’s match function can then perform a wider range of
comparisons than just the straightforward comparison of the description with
the criterion string:</p>
<blockquote>
<div><ol class="arabic">
<li><p>If the criterion string is of the form “id:&lt;hexdigits&gt;” then the match
function will examine a key’s fingerprint to see if the hex digits given
after the “id:” match the tail.  For instance:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>keyctl search @s asymmetric id:5acc2142
</pre></div>
</div>
<p>will match a key with fingerprint:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1A00 2040 7601 7889 DE11  882C 3823 04AD 5ACC 2142
</pre></div>
</div>
</li>
<li><p>If the criterion string is of the form “&lt;subtype&gt;:&lt;hexdigits&gt;” then the
match will match the ID as in (1), but with the added restriction that
only keys of the specified subtype (e.g. tpm) will be matched.  For
instance:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>keyctl search @s asymmetric tpm:5acc2142
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
<p>Looking in /proc/keys, the last 8 hex digits of the key fingerprint are
displayed, along with the subtype:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1a39e171 I-----     1 perm 3f010000     0     0 asymmetric modsign.0: DSA 5acc2142 []
</pre></div>
</div>
</section>
<section id="accessing-asymmetric-keys">
<h2>Accessing Asymmetric Keys<a class="headerlink" href="#accessing-asymmetric-keys" title="Permalink to this headline">¶</a></h2>
<p>For general access to asymmetric keys from within the kernel, the following
inclusion is required:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;crypto/public_key.h&gt;
</pre></div>
</div>
<p>This gives access to functions for dealing with asymmetric / public keys.
Three enums are defined there for representing public-key cryptography
algorithms:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum pkey_algo
</pre></div>
</div>
<p>digest algorithms used by those:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum pkey_hash_algo
</pre></div>
</div>
<p>and key identifier representations:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum pkey_id_type
</pre></div>
</div>
<p>Note that the key type representation types are required because key
identifiers from different standards aren’t necessarily compatible.  For
instance, PGP generates key identifiers by hashing the key data plus some
PGP-specific metadata, whereas X.509 has arbitrary certificate identifiers.</p>
<p>The operations defined upon a key are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Signature verification.</p></li>
</ol>
</div></blockquote>
<p>Other operations are possible (such as encryption) with the same key data
required for verification, but not currently supported, and others
(eg. decryption and signature generation) require extra key data.</p>
<section id="signature-verification">
<h3>Signature Verification<a class="headerlink" href="#signature-verification" title="Permalink to this headline">¶</a></h3>
<p>An operation is provided to perform cryptographic signature verification, using
an asymmetric key to provide or to provide access to the public key:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int verify_signature(const struct key *key,
                     const struct public_key_signature *sig);
</pre></div>
</div>
<p>The caller must have already obtained the key from some source and can then use
it to check the signature.  The caller must have parsed the signature and
transferred the relevant bits to the structure pointed to by sig:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct public_key_signature {
        u8 *digest;
        u8 digest_size;
        enum pkey_hash_algo pkey_hash_algo : 8;
        u8 nr_mpi;
        union {
                MPI mpi[2];
                ...
        };
};
</pre></div>
</div>
<p>The algorithm used must be noted in sig-&gt;pkey_hash_algo, and all the MPIs that
make up the actual signature must be stored in sig-&gt;mpi[] and the count of MPIs
placed in sig-&gt;nr_mpi.</p>
<p>In addition, the data must have been digested by the caller and the resulting
hash must be pointed to by sig-&gt;digest and the size of the hash be placed in
sig-&gt;digest_size.</p>
<p>The function will return 0 upon success or -EKEYREJECTED if the signature
doesn’t match.</p>
<p>The function may also return -ENOTSUPP if an unsupported public-key algorithm
or public-key/hash algorithm combination is specified or the key doesn’t
support the operation; -EBADMSG or -ERANGE if some of the parameters have weird
data; or -ENOMEM if an allocation can’t be performed.  -EINVAL can be returned
if the key argument is the wrong type or is incompletely set up.</p>
</section>
</section>
<section id="asymmetric-key-subtypes">
<h2>Asymmetric Key Subtypes<a class="headerlink" href="#asymmetric-key-subtypes" title="Permalink to this headline">¶</a></h2>
<p>Asymmetric keys have a subtype that defines the set of operations that can be
performed on that key and that determines what data is attached as the key
payload.  The payload format is entirely at the whim of the subtype.</p>
<p>The subtype is selected by the key data parser and the parser must initialise
the data required for it.  The asymmetric key retains a reference on the
subtype module.</p>
<p>The subtype definition structure can be found in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;keys/asymmetric-subtype.h&gt;
</pre></div>
</div>
<p>and looks like the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct asymmetric_key_subtype {
        struct module           *owner;
        const char              *name;

        void (*describe)(const struct key *key, struct seq_file *m);
        void (*destroy)(void *payload);
        int (*query)(const struct kernel_pkey_params *params,
                     struct kernel_pkey_query *info);
        int (*eds_op)(struct kernel_pkey_params *params,
                      const void *in, void *out);
        int (*verify_signature)(const struct key *key,
                                const struct public_key_signature *sig);
};
</pre></div>
</div>
<p>Asymmetric keys point to this with their payload[asym_subtype] member.</p>
<p>The owner and name fields should be set to the owning module and the name of
the subtype.  Currently, the name is only used for print statements.</p>
<p>There are a number of operations defined by the subtype:</p>
<blockquote>
<div><ol class="arabic">
<li><p>describe().</p>
<p>Mandatory.  This allows the subtype to display something in /proc/keys
against the key.  For instance the name of the public key algorithm type
could be displayed.  The key type will display the tail of the key
identity string after this.</p>
</li>
<li><p>destroy().</p>
<p>Mandatory.  This should free the memory associated with the key.  The
asymmetric key will look after freeing the fingerprint and releasing the
reference on the subtype module.</p>
</li>
<li><p>query().</p>
<p>Mandatory.  This is a function for querying the capabilities of a key.</p>
</li>
<li><p>eds_op().</p>
<p>Optional.  This is the entry point for the encryption, decryption and
signature creation operations (which are distinguished by the operation ID
in the parameter struct).  The subtype may do anything it likes to
implement an operation, including offloading to hardware.</p>
</li>
<li><p>verify_signature().</p>
<p>Optional.  This is the entry point for signature verification.  The
subtype may do anything it likes to implement an operation, including
offloading to hardware.</p>
</li>
</ol>
</div></blockquote>
</section>
<section id="instantiation-data-parsers">
<h2>Instantiation Data Parsers<a class="headerlink" href="#instantiation-data-parsers" title="Permalink to this headline">¶</a></h2>
<p>The asymmetric key type doesn’t generally want to store or to deal with a raw
blob of data that holds the key data.  It would have to parse it and error
check it each time it wanted to use it.  Further, the contents of the blob may
have various checks that can be performed on it (eg. self-signatures, validity
dates) and may contain useful data about the key (identifiers, capabilities).</p>
<p>Also, the blob may represent a pointer to some hardware containing the key
rather than the key itself.</p>
<p>Examples of blob formats for which parsers could be implemented include:</p>
<blockquote>
<div><ul class="simple">
<li><p>OpenPGP packet stream [RFC 4880].</p></li>
<li><p>X.509 ASN.1 stream.</p></li>
<li><p>Pointer to TPM key.</p></li>
<li><p>Pointer to UEFI key.</p></li>
<li><p>PKCS#8 private key [RFC 5208].</p></li>
<li><p>PKCS#5 encrypted private key [RFC 2898].</p></li>
</ul>
</div></blockquote>
<p>During key instantiation each parser in the list is tried until one doesn’t
return -EBADMSG.</p>
<p>The parser definition structure can be found in:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;keys/asymmetric-parser.h&gt;
</pre></div>
</div>
<p>and looks like the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct asymmetric_key_parser {
        struct module   *owner;
        const char      *name;

        int (*parse)(struct key_preparsed_payload *prep);
};
</pre></div>
</div>
<p>The owner and name fields should be set to the owning module and the name of
the parser.</p>
<p>There is currently only a single operation defined by the parser, and it is
mandatory:</p>
<blockquote>
<div><ol class="arabic">
<li><p>parse().</p>
<p>This is called to preparse the key from the key creation and update paths.
In particular, it is called during the key creation _before_ a key is
allocated, and as such, is permitted to provide the key’s description in
the case that the caller declines to do so.</p>
<p>The caller passes a pointer to the following struct with all of the fields
cleared, except for data, datalen and quotalen [see
<a class="reference internal" href="../security/keys/core.html"><span class="doc">Kernel Key Retention Service</span></a>]:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct key_preparsed_payload {
        char            *description;
        void            *payload[4];
        const void      *data;
        size_t          datalen;
        size_t          quotalen;
};
</pre></div>
</div>
<p>The instantiation data is in a blob pointed to by data and is datalen in
size.  The parse() function is not permitted to change these two values at
all, and shouldn’t change any of the other values _unless_ they are
recognise the blob format and will not return -EBADMSG to indicate it is
not theirs.</p>
<p>If the parser is happy with the blob, it should propose a description for
the key and attach it to -&gt;description, -&gt;payload[asym_subtype] should be
set to point to the subtype to be used, -&gt;payload[asym_crypto] should be
set to point to the initialised data for that subtype,
-&gt;payload[asym_key_ids] should point to one or more hex fingerprints and
quotalen should be updated to indicate how much quota this key should
account for.</p>
<p>When clearing up, the data attached to -&gt;payload[asym_key_ids] and
-&gt;description will be <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>’d and the data attached to
-&gt;payload[asm_crypto] will be passed to the subtype’s -&gt;destroy() method
to be disposed of.  A module reference for the subtype pointed to by
-&gt;payload[asym_subtype] will be put.</p>
<p>If the data format is not recognised, -EBADMSG should be returned.  If it
is recognised, but the key cannot for some reason be set up, some other
negative error code should be returned.  On success, 0 should be returned.</p>
<p>The key’s fingerprint string may be partially matched upon.  For a
public-key algorithm such as RSA and DSA this will likely be a printable
hex version of the key’s fingerprint.</p>
</li>
</ol>
</div></blockquote>
<p>Functions are provided to register and unregister parsers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int register_asymmetric_key_parser(struct asymmetric_key_parser *parser);
void unregister_asymmetric_key_parser(struct asymmetric_key_parser *subtype);
</pre></div>
</div>
<p>Parsers may not have the same name.  The names are otherwise only used for
displaying in debugging messages.</p>
</section>
<section id="keyring-link-restrictions">
<h2>Keyring Link Restrictions<a class="headerlink" href="#keyring-link-restrictions" title="Permalink to this headline">¶</a></h2>
<p>Keyrings created from userspace using add_key can be configured to check the
signature of the key being linked.  Keys without a valid signature are not
allowed to link.</p>
<p>Several restriction methods are available:</p>
<blockquote>
<div><ol class="arabic">
<li><p>Restrict using the kernel builtin trusted keyring</p>
<ul class="simple">
<li><p>Option string used with KEYCTL_RESTRICT_KEYRING:
- “builtin_trusted”</p></li>
</ul>
<p>The kernel builtin trusted keyring will be searched for the signing key.
If the builtin trusted keyring is not configured, all links will be
rejected.  The ca_keys kernel parameter also affects which keys are used
for signature verification.</p>
</li>
<li><p>Restrict using the kernel builtin and secondary trusted keyrings</p>
<ul class="simple">
<li><p>Option string used with KEYCTL_RESTRICT_KEYRING:
- “builtin_and_secondary_trusted”</p></li>
</ul>
<p>The kernel builtin and secondary trusted keyrings will be searched for the
signing key.  If the secondary trusted keyring is not configured, this
restriction will behave like the “builtin_trusted” option.  The ca_keys
kernel parameter also affects which keys are used for signature
verification.</p>
</li>
<li><p>Restrict using a separate key or keyring</p>
<ul class="simple">
<li><p>Option string used with KEYCTL_RESTRICT_KEYRING:
- “key_or_keyring:&lt;key or keyring serial number&gt;[:chain]”</p></li>
</ul>
<p>Whenever a key link is requested, the link will only succeed if the key
being linked is signed by one of the designated keys.  This key may be
specified directly by providing a serial number for one asymmetric key, or
a group of keys may be searched for the signing key by providing the
serial number for a keyring.</p>
<p>When the “chain” option is provided at the end of the string, the keys
within the destination keyring will also be searched for signing keys.
This allows for verification of certificate chains by adding each
certificate in order (starting closest to the root) to a keyring.  For
instance, one keyring can be populated with links to a set of root
certificates, with a separate, restricted keyring set up for each
certificate chain to be validated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Create and populate a keyring for root certificates
root_id=`keyctl add keyring root-certs &quot;&quot; @s`
keyctl padd asymmetric &quot;&quot; $root_id &lt; root1.cert
keyctl padd asymmetric &quot;&quot; $root_id &lt; root2.cert

# Create and restrict a keyring for the certificate chain
chain_id=`keyctl add keyring chain &quot;&quot; @s`
keyctl restrict_keyring $chain_id asymmetric key_or_keyring:$root_id:chain

# Attempt to add each certificate in the chain, starting with the
# certificate closest to the root.
keyctl padd asymmetric &quot;&quot; $chain_id &lt; intermediateA.cert
keyctl padd asymmetric &quot;&quot; $chain_id &lt; intermediateB.cert
keyctl padd asymmetric &quot;&quot; $chain_id &lt; end-entity.cert
</pre></div>
</div>
<p>If the final end-entity certificate is successfully added to the “chain”
keyring, we can be certain that it has a valid signing chain going back to
one of the root certificates.</p>
<p>A single keyring can be used to verify a chain of signatures by
restricting the keyring after linking the root certificate:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Create a keyring for the certificate chain and add the root
chain2_id=`keyctl add keyring chain2 &quot;&quot; @s`
keyctl padd asymmetric &quot;&quot; $chain2_id &lt; root1.cert

# Restrict the keyring that already has root1.cert linked.  The cert
# will remain linked by the keyring.
keyctl restrict_keyring $chain2_id asymmetric key_or_keyring:0:chain

# Attempt to add each certificate in the chain, starting with the
# certificate closest to the root.
keyctl padd asymmetric &quot;&quot; $chain2_id &lt; intermediateA.cert
keyctl padd asymmetric &quot;&quot; $chain2_id &lt; intermediateB.cert
keyctl padd asymmetric &quot;&quot; $chain2_id &lt; end-entity.cert
</pre></div>
</div>
<p>If the final end-entity certificate is successfully added to the “chain2”
keyring, we can be certain that there is a valid signing chain going back
to the root certificate that was added before the keyring was restricted.</p>
</li>
</ol>
</div></blockquote>
<p>In all of these cases, if the signing key is found the signature of the key to
be linked will be verified using the signing key.  The requested key is added
to the keyring only if the signature is successfully verified.  -ENOKEY is
returned if the parent certificate could not be found, or -EKEYREJECTED is
returned if the signature check fails or the key is blacklisted.  Other errors
may be returned if the signature check could not be performed.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Asymmetric / Public-key Cryptography Key Type</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#key-identification">Key Identification</a></li>
<li><a class="reference internal" href="#accessing-asymmetric-keys">Accessing Asymmetric Keys</a><ul>
<li><a class="reference internal" href="#signature-verification">Signature Verification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asymmetric-key-subtypes">Asymmetric Key Subtypes</a></li>
<li><a class="reference internal" href="#instantiation-data-parsers">Instantiation Data Parsers</a></li>
<li><a class="reference internal" href="#keyring-link-restrictions">Keyring Link Restrictions</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/crypto/asymmetric-keys.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/crypto/asymmetric-keys.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>