
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Key-agreement Protocol Primitives (KPP) Cipher Algorithm Definitions &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Code Examples" href="api-samples.html" />
    <link rel="prev" title="Asymmetric Cipher Algorithm Definitions" href="api-akcipher.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="key-agreement-protocol-primitives-kpp-cipher-algorithm-definitions">
<h1>Key-agreement Protocol Primitives (KPP) Cipher Algorithm Definitions<a class="headerlink" href="#key-agreement-protocol-primitives-kpp-cipher-algorithm-definitions" title="Permalink to this headline">¶</a></h1>
<dl class="type">
<dt id="c.kpp_request">
struct <code class="sig-name descname">kpp_request</code><a class="headerlink" href="#c.kpp_request" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kpp_request {
    struct crypto_async_request base;
    struct scatterlist *src;
    struct scatterlist *dst;
    unsigned int src_len;
    unsigned int dst_len;
    void *__ctx[] ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Common attributes for async crypto requests</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src</span></code></dt><dd><p>Source data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dst</span></code></dt><dd><p>Destination data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">src_len</span></code></dt><dd><p>Size of the input buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dst_len</span></code></dt><dd><p>Size of the output buffer. It needs to be at least
as big as the expected result depending on the operation
After operation it will be updated with the actual size of the
result. In case of error where the dst sgl size was insufficient,
it will be updated to the size required for the operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__ctx</span></code></dt><dd><p>Start of private context data</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.crypto_kpp">
struct <code class="sig-name descname">crypto_kpp</code><a class="headerlink" href="#c.crypto_kpp" title="Permalink to this definition">¶</a></dt>
<dd><p>user-instantiated object which encapsulate algorithms and core processing logic</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct crypto_kpp {
    unsigned int reqsize;
    struct crypto_tfm base;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">reqsize</span></code></dt><dd><p>Request context size required by algorithm
implementation</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Common crypto API algorithm data structure</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.kpp_alg">
struct <code class="sig-name descname">kpp_alg</code><a class="headerlink" href="#c.kpp_alg" title="Permalink to this definition">¶</a></dt>
<dd><p>generic key-agreement protocol primitives</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kpp_alg {
    int (*set_secret)(struct crypto_kpp *tfm, const void *buffer, unsigned int len);
    int (*generate_public_key)(struct kpp_request *req);
    int (*compute_shared_secret)(struct kpp_request *req);
    unsigned int (*max_size)(struct crypto_kpp *tfm);
    int (*init)(struct crypto_kpp *tfm);
    void (*exit)(struct crypto_kpp *tfm);
    struct crypto_alg base;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">set_secret</span></code></dt><dd><p>Function invokes the protocol specific function to
store the secret private key along with parameters.
The implementation knows how to decode the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">generate_public_key</span></code></dt><dd><p>Function generate the public key to be sent to the
counterpart. In case of error, where output is not big
enough req-&gt;dst_len will be updated to the size
required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compute_shared_secret</span></code></dt><dd><p>Function compute the shared secret as defined by
the algorithm. The result is given back to the user.
In case of error, where output is not big enough,
req-&gt;dst_len will be updated to the size required</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_size</span></code></dt><dd><p>Function returns the size of the output buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">init</span></code></dt><dd><p>Initialize the object. This is called only once at
instantiation time. In case the cryptographic hardware
needs to be initialized. Software fallback should be
put in place here.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exit</span></code></dt><dd><p>Undo everything <strong>init</strong> did.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Common crypto API algorithm data structure</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.kpp_secret">
struct <code class="sig-name descname">kpp_secret</code><a class="headerlink" href="#c.kpp_secret" title="Permalink to this definition">¶</a></dt>
<dd><p>small header for packing secret buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct kpp_secret {
    unsigned short type;
    unsigned short len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>define type of secret. Each kpp type will define its own</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">len</span></code></dt><dd><p>specify the len of the secret, include the header, that
follows the struct</p>
</dd>
</dl>
</div>
</section>
<section id="key-agreement-protocol-primitives-kpp-cipher-api">
<h1>Key-agreement Protocol Primitives (KPP) Cipher API<a class="headerlink" href="#key-agreement-protocol-primitives-kpp-cipher-api" title="Permalink to this headline">¶</a></h1>
<p>The KPP API is used with the algorithm type
CRYPTO_ALG_TYPE_KPP (listed as type “kpp” in /proc/crypto)</p>
<dl class="function">
<dt id="c.crypto_alloc_kpp">
struct <a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp">crypto_kpp</a> * <code class="sig-name descname">crypto_alloc_kpp</code><span class="sig-paren">(</span>const char<em> *alg_name</em>, u32<em> type</em>, u32<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_alloc_kpp" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate KPP tfm handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*alg_name</span></code></dt><dd><p>is the name of the kpp algorithm (e.g. “dh”, “ecdh”)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">type</span></code></dt><dd><p>specifies the type of the algorithm</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">mask</span></code></dt><dd><p>specifies the mask for the algorithm</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a handle for kpp algorithm. The returned <a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_kpp</span></code></a>
is required for any following API invocation</p>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>allocated handle in case of success; IS_ERR() is true in case of</dt><dd><p>an error, PTR_ERR() returns the error code.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.crypto_free_kpp">
void <code class="sig-name descname">crypto_free_kpp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp">crypto_kpp</a><em> *tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_free_kpp" title="Permalink to this definition">¶</a></dt>
<dd><p>free KPP tfm handle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_kpp</span> <span class="pre">*tfm</span></code></dt><dd><p>KPP tfm handle allocated with <a class="reference internal" href="#c.crypto_alloc_kpp" title="crypto_alloc_kpp"><code class="xref c c-func docutils literal notranslate"><span class="pre">crypto_alloc_kpp()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>tfm</strong> is a NULL or error pointer, this function does nothing.</p>
</div>
<dl class="function">
<dt id="c.crypto_kpp_set_secret">
int <code class="sig-name descname">crypto_kpp_set_secret</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp">crypto_kpp</a><em> *tfm</em>, const void<em> *buffer</em>, unsigned int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_kpp_set_secret" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke kpp operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_kpp</span> <span class="pre">*tfm</span></code></dt><dd><p>tfm handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*buffer</span></code></dt><dd><p>Buffer holding the packet representation of the private
key. The structure of the packet key depends on the particular
KPP implementation. Packing and unpacking helpers are provided
for ECDH and DH (see the respective header files for those
implementations).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of the packet private key buffer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function invokes the specific kpp operation for a given alg.</p>
<p><strong>Return</strong></p>
<p>zero on success; error code in case of error</p>
</div>
<dl class="function">
<dt id="c.crypto_kpp_generate_public_key">
int <code class="sig-name descname">crypto_kpp_generate_public_key</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.kpp_request" title="kpp_request">kpp_request</a><em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_kpp_generate_public_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke kpp operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>kpp key request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function invokes the specific kpp operation for generating the public part
for a given kpp algorithm.</p>
<p>To generate a private key, the caller should use a random number generator.
The output of the requested length serves as the private key.</p>
<p><strong>Return</strong></p>
<p>zero on success; error code in case of error</p>
</div>
<dl class="function">
<dt id="c.crypto_kpp_compute_shared_secret">
int <code class="sig-name descname">crypto_kpp_compute_shared_secret</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.kpp_request" title="kpp_request">kpp_request</a><em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_kpp_compute_shared_secret" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke kpp operation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>kpp key request</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function invokes the specific kpp operation for computing the shared secret
for a given kpp algorithm.</p>
<p><strong>Return</strong></p>
<p>zero on success; error code in case of error</p>
</div>
<dl class="function">
<dt id="c.crypto_kpp_maxsize">
unsigned int <code class="sig-name descname">crypto_kpp_maxsize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp">crypto_kpp</a><em> *tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_kpp_maxsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Get len for output buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_kpp</span> <span class="pre">*tfm</span></code></dt><dd><p>KPP tfm handle allocated with <a class="reference internal" href="#c.crypto_alloc_kpp" title="crypto_alloc_kpp"><code class="xref c c-func docutils literal notranslate"><span class="pre">crypto_alloc_kpp()</span></code></a></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns the output buffer size required for a given key.
Function assumes that the key is already set in the transformation. If this
function is called without a setkey or with a failed setkey, you will end up
in a NULL dereference.</p>
</div>
</section>
<section id="key-agreement-protocol-primitives-kpp-cipher-request-handle">
<h1>Key-agreement Protocol Primitives (KPP) Cipher Request Handle<a class="headerlink" href="#key-agreement-protocol-primitives-kpp-cipher-request-handle" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="c.kpp_request_alloc">
struct <a class="reference internal" href="#c.kpp_request" title="kpp_request">kpp_request</a> * <code class="sig-name descname">kpp_request_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.crypto_kpp" title="crypto_kpp">crypto_kpp</a><em> *tfm</em>, gfp_t<em> gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kpp_request_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocates kpp request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">crypto_kpp</span> <span class="pre">*tfm</span></code></dt><dd><p>KPP tfm handle allocated with <a class="reference internal" href="#c.crypto_alloc_kpp" title="crypto_alloc_kpp"><code class="xref c c-func docutils literal notranslate"><span class="pre">crypto_alloc_kpp()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt><dd><p>allocation flags</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>allocated handle in case of success or NULL in case of an error.</p>
</div>
<dl class="function">
<dt id="c.kpp_request_free">
void <code class="sig-name descname">kpp_request_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.kpp_request" title="kpp_request">kpp_request</a><em> *req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kpp_request_free" title="Permalink to this definition">¶</a></dt>
<dd><p>zeroize and free kpp request</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>request to free</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.kpp_request_set_callback">
void <code class="sig-name descname">kpp_request_set_callback</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.kpp_request" title="kpp_request">kpp_request</a><em> *req</em>, u32<em> flgs</em>, crypto_completion_t<em> cmpl</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kpp_request_set_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets an asynchronous callback.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>request that the callback will be set for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">flgs</span></code></dt><dd><p>specify for instance if the operation may backlog</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">crypto_completion_t</span> <span class="pre">cmpl</span></code></dt><dd><p>callback which will be called</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>private data used by the caller</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback will be called when an asynchronous operation on a given
request is finished.</p>
</div>
<dl class="function">
<dt id="c.kpp_request_set_input">
void <code class="sig-name descname">kpp_request_set_input</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.kpp_request" title="kpp_request">kpp_request</a><em> *req</em>, struct scatterlist<em> *input</em>, unsigned int<em> input_len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kpp_request_set_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets input buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>kpp request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*input</span></code></dt><dd><p>ptr to input scatter list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">input_len</span></code></dt><dd><p>size of the input scatter list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets parameters required by generate_public_key</p>
</div>
<dl class="function">
<dt id="c.kpp_request_set_output">
void <code class="sig-name descname">kpp_request_set_output</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.kpp_request" title="kpp_request">kpp_request</a><em> *req</em>, struct scatterlist<em> *output</em>, unsigned int<em> output_len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kpp_request_set_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets output buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kpp_request</span> <span class="pre">*req</span></code></dt><dd><p>kpp request</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*output</span></code></dt><dd><p>ptr to output scatter list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">output_len</span></code></dt><dd><p>size of the output scatter list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets parameters required by kpp operation</p>
</div>
</section>
<section id="ecdh-helper-functions">
<h1>ECDH Helper Functions<a class="headerlink" href="#ecdh-helper-functions" title="Permalink to this headline">¶</a></h1>
<p>To use ECDH with the KPP cipher API, the following data structure and
functions should be used.</p>
<p>The ECC curves known to the ECDH implementation are specified in this
header file.</p>
<p>To use ECDH with KPP, the following functions should be used to operate on
an ECDH private key. The packet private key that can be set with
the KPP API function call of crypto_kpp_set_secret.</p>
<dl class="type">
<dt id="c.ecdh">
struct <code class="sig-name descname">ecdh</code><a class="headerlink" href="#c.ecdh" title="Permalink to this definition">¶</a></dt>
<dd><p>define an ECDH private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct ecdh {
    char *key;
    unsigned short key_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>Private ECDH key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_size</span></code></dt><dd><p>Size of the private ECDH key</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.crypto_ecdh_key_len">
unsigned int <code class="sig-name descname">crypto_ecdh_key_len</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.ecdh" title="ecdh">ecdh</a><em> *params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ecdh_key_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the size of the private ECDH key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ecdh</span> <span class="pre">*params</span></code></dt><dd><p>private ECDH key</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the packet ECDH key size. A caller can use that
with the provided ECDH private key reference to obtain the required
memory size to hold a packet key.</p>
<p><strong>Return</strong></p>
<p>size of the key in bytes</p>
</div>
<dl class="function">
<dt id="c.crypto_ecdh_encode_key">
int <code class="sig-name descname">crypto_ecdh_encode_key</code><span class="sig-paren">(</span>char<em> *buf</em>, unsigned int<em> len</em>, const struct <a class="reference internal" href="#c.ecdh" title="ecdh">ecdh</a><em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ecdh_encode_key" title="Permalink to this definition">¶</a></dt>
<dd><p>encode the private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer allocated by the caller to hold the packet ECDH
private key. The buffer should be at least crypto_ecdh_key_len
bytes in size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of the packet private key buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ecdh</span> <span class="pre">*p</span></code></dt><dd><p>Buffer with the caller-specified private key</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The ECDH implementations operate on a packet representation of the private
key.</p>
<p><strong>Return</strong></p>
<p>-EINVAL if buffer has insufficient size, 0 on success</p>
</div>
<dl class="function">
<dt id="c.crypto_ecdh_decode_key">
int <code class="sig-name descname">crypto_ecdh_decode_key</code><span class="sig-paren">(</span>const char<em> *buf</em>, unsigned int<em> len</em>, struct <a class="reference internal" href="#c.ecdh" title="ecdh">ecdh</a><em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ecdh_decode_key" title="Permalink to this definition">¶</a></dt>
<dd><p>decode a private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer holding a packet key that should be decoded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of the packet private key buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ecdh</span> <span class="pre">*p</span></code></dt><dd><p>Buffer allocated by the caller that is filled with the
unpacked ECDH private key.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The unpacking obtains the private key by pointing <strong>p</strong> to the correct location
in <strong>buf</strong>. Thus, both pointers refer to the same memory.</p>
<p><strong>Return</strong></p>
<p>-EINVAL if buffer has insufficient size, 0 on success</p>
</div>
</section>
<section id="dh-helper-functions">
<h1>DH Helper Functions<a class="headerlink" href="#dh-helper-functions" title="Permalink to this headline">¶</a></h1>
<p>To use DH with the KPP cipher API, the following data structure and
functions should be used.</p>
<p>To use DH with KPP, the following functions should be used to operate on
a DH private key. The packet private key that can be set with
the KPP API function call of crypto_kpp_set_secret.</p>
<dl class="type">
<dt id="c.dh">
struct <code class="sig-name descname">dh</code><a class="headerlink" href="#c.dh" title="Permalink to this definition">¶</a></dt>
<dd><p>define a DH private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dh {
    const void *key;
    const void *p;
    const void *g;
    unsigned int key_size;
    unsigned int p_size;
    unsigned int g_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>Private DH key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p</span></code></dt><dd><p>Diffie-Hellman parameter P</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g</span></code></dt><dd><p>Diffie-Hellman generator G</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">key_size</span></code></dt><dd><p>Size of the private DH key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">p_size</span></code></dt><dd><p>Size of DH parameter P</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g_size</span></code></dt><dd><p>Size of DH generator G</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.crypto_dh_key_len">
unsigned int <code class="sig-name descname">crypto_dh_key_len</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.dh" title="dh">dh</a><em> *params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_dh_key_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the size of the private DH key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dh</span> <span class="pre">*params</span></code></dt><dd><p>private DH key</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the packet DH key size. A caller can use that
with the provided DH private key reference to obtain the required
memory size to hold a packet key.</p>
<p><strong>Return</strong></p>
<p>size of the key in bytes</p>
</div>
<dl class="function">
<dt id="c.crypto_dh_encode_key">
int <code class="sig-name descname">crypto_dh_encode_key</code><span class="sig-paren">(</span>char<em> *buf</em>, unsigned int<em> len</em>, const struct <a class="reference internal" href="#c.dh" title="dh">dh</a><em> *params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_dh_encode_key" title="Permalink to this definition">¶</a></dt>
<dd><p>encode the private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer allocated by the caller to hold the packet DH
private key. The buffer should be at least crypto_dh_key_len
bytes in size.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of the packet private key buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dh</span> <span class="pre">*params</span></code></dt><dd><p>Buffer with the caller-specified private key</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The DH implementations operate on a packet representation of the private
key.</p>
<p><strong>Return</strong></p>
<p>-EINVAL if buffer has insufficient size, 0 on success</p>
</div>
<dl class="function">
<dt id="c.crypto_dh_decode_key">
int <code class="sig-name descname">crypto_dh_decode_key</code><span class="sig-paren">(</span>const char<em> *buf</em>, unsigned int<em> len</em>, struct <a class="reference internal" href="#c.dh" title="dh">dh</a><em> *params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_dh_decode_key" title="Permalink to this definition">¶</a></dt>
<dd><p>decode a private key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*buf</span></code></dt><dd><p>Buffer holding a packet key that should be decoded</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>Length of the packet private key buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dh</span> <span class="pre">*params</span></code></dt><dd><p>Buffer allocated by the caller that is filled with the
unpacked DH private key.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The unpacking obtains the private key by pointing <strong>p</strong> to the correct location
in <strong>buf</strong>. Thus, both pointers refer to the same memory.</p>
<p><strong>Return</strong></p>
<p>-EINVAL if buffer has insufficient size, 0 on success</p>
</div>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Key-agreement Protocol Primitives (KPP) Cipher Algorithm Definitions</a></li>
<li><a class="reference internal" href="#key-agreement-protocol-primitives-kpp-cipher-api">Key-agreement Protocol Primitives (KPP) Cipher API</a></li>
<li><a class="reference internal" href="#key-agreement-protocol-primitives-kpp-cipher-request-handle">Key-agreement Protocol Primitives (KPP) Cipher Request Handle</a></li>
<li><a class="reference internal" href="#ecdh-helper-functions">ECDH Helper Functions</a></li>
<li><a class="reference internal" href="#dh-helper-functions">DH Helper Functions</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/crypto/api-kpp.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/crypto/api-kpp.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>