
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Kernel driver vt1211 &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Kernel driver w83627ehf" href="w83627ehf.html" />
    <link rel="prev" title="Kernel driver via686a" href="via686a.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="kernel-driver-vt1211">
<h1>Kernel driver vt1211<a class="headerlink" href="#kernel-driver-vt1211" title="Permalink to this headline">¶</a></h1>
<p>Supported chips:</p>
<blockquote>
<div><ul>
<li><p>VIA VT1211</p>
<p>Prefix: ‘vt1211’</p>
<p>Addresses scanned: none, address read from Super-I/O config space</p>
<p>Datasheet: Provided by VIA upon request and under NDA</p>
</li>
</ul>
</div></blockquote>
<p>Authors: Juerg Haefliger &lt;<a class="reference external" href="mailto:juergh&#37;&#52;&#48;gmail&#46;com">juergh<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>This driver is based on the driver for kernel 2.4 by Mark D. Studebaker and
its port to kernel 2.6 by Lars Ekman.</p>
<p>Thanks to Joseph Chan and Fiona Gatt from VIA for providing documentation and
technical support.</p>
<section id="module-parameters">
<h2>Module Parameters<a class="headerlink" href="#module-parameters" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><dl class="simple">
<dt>uch_config: int</dt><dd><p>Override the BIOS default universal channel (UCH)
configuration for channels 1-5.
Legal values are in the range of 0-31. Bit 0 maps to
UCH1, bit 1 maps to UCH2 and so on. Setting a bit to 1
enables the thermal input of that particular UCH and
setting a bit to 0 enables the voltage input.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>int_mode: int</dt><dd><p>Override the BIOS default temperature interrupt mode.
The only possible value is 0 which forces interrupt
mode 0. In this mode, any pending interrupt is cleared
when the status register is read but is regenerated as
long as the temperature stays above the hysteresis
limit.</p>
</dd>
</dl>
</li>
</ul>
<p>Be aware that overriding BIOS defaults might cause some unwanted side effects!</p>
</section>
<section id="description">
<h2>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>The VIA VT1211 Super-I/O chip includes complete hardware monitoring
capabilities. It monitors 2 dedicated temperature sensor inputs (temp1 and
temp2), 1 dedicated voltage (in5) and 2 fans. Additionally, the chip
implements 5 universal input channels (UCH1-5) that can be individually
programmed to either monitor a voltage or a temperature.</p>
<p>This chip also provides manual and automatic control of fan speeds (according
to the datasheet). The driver only supports automatic control since the manual
mode doesn’t seem to work as advertised in the datasheet. In fact I couldn’t
get manual mode to work at all! Be aware that automatic mode hasn’t been
tested very well (due to the fact that my EPIA M10000 doesn’t have the fans
connected to the PWM outputs of the VT1211 :-().</p>
<p>The following table shows the relationship between the vt1211 inputs and the
sysfs nodes.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 19%" />
<col style="width: 15%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Sensor</p></th>
<th class="head"><p>Voltage Mode</p></th>
<th class="head"><p>Temp Mode</p></th>
<th class="head"><p>Default Use (from the datasheet)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Reading 1</p></td>
<td></td>
<td><p>temp1</p></td>
<td><p>Intel thermal diode</p></td>
</tr>
<tr class="row-odd"><td><p>Reading 3</p></td>
<td></td>
<td><p>temp2</p></td>
<td><p>Internal thermal diode</p></td>
</tr>
<tr class="row-even"><td><p>UCH1/Reading2</p></td>
<td><p>in0</p></td>
<td><p>temp3</p></td>
<td><p>NTC type thermistor</p></td>
</tr>
<tr class="row-odd"><td><p>UCH2</p></td>
<td><p>in1</p></td>
<td><p>temp4</p></td>
<td><p>+2.5V</p></td>
</tr>
<tr class="row-even"><td><p>UCH3</p></td>
<td><p>in2</p></td>
<td><p>temp5</p></td>
<td><p>VccP (processor core)</p></td>
</tr>
<tr class="row-odd"><td><p>UCH4</p></td>
<td><p>in3</p></td>
<td><p>temp6</p></td>
<td><p>+5V</p></td>
</tr>
<tr class="row-even"><td><p>UCH5</p></td>
<td><p>in4</p></td>
<td><p>temp7</p></td>
<td><p>+12V</p></td>
</tr>
<tr class="row-odd"><td><p>+3.3V</p></td>
<td><p>in5</p></td>
<td></td>
<td><p>Internal VCC (+3.3V)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="voltage-monitoring">
<h2>Voltage Monitoring<a class="headerlink" href="#voltage-monitoring" title="Permalink to this headline">¶</a></h2>
<p>Voltages are sampled by an 8-bit ADC with a LSB of ~10mV. The supported input
range is thus from 0 to 2.60V. Voltage values outside of this range need
external scaling resistors. This external scaling needs to be compensated for
via compute lines in sensors.conf, like:</p>
<p>compute inx &#64;*(1+R1/R2), &#64;/(1+R1/R2)</p>
<p>The board level scaling resistors according to VIA’s recommendation are as
follows. And this is of course totally dependent on the actual board
implementation :-) You will have to find documentation for your own
motherboard and edit sensors.conf accordingly.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 20%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Voltage</p></th>
<th class="head"><p>R1</p></th>
<th class="head"><p>R2</p></th>
<th class="head"><p>Divider</p></th>
<th class="head"><p>Raw Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>+2.5V</p></td>
<td><p>2K</p></td>
<td><p>10K</p></td>
<td><p>1.2</p></td>
<td><p>2083 mV</p></td>
</tr>
<tr class="row-odd"><td><p>VccP</p></td>
<td><p>—</p></td>
<td><p>—</p></td>
<td><p>1.0</p></td>
<td><p>1400 mV <a class="footnote-reference brackets" href="#id3" id="id1">1</a></p></td>
</tr>
<tr class="row-even"><td><p>+5V</p></td>
<td><p>14K</p></td>
<td><p>10K</p></td>
<td><p>2.4</p></td>
<td><p>2083 mV</p></td>
</tr>
<tr class="row-odd"><td><p>+12V</p></td>
<td><p>47K</p></td>
<td><p>10K</p></td>
<td><p>5.7</p></td>
<td><p>2105 mV</p></td>
</tr>
<tr class="row-even"><td><p>+3.3V (int)</p></td>
<td><p>2K</p></td>
<td><p>3.4K</p></td>
<td><p>1.588</p></td>
<td><p>3300 mV <a class="footnote-reference brackets" href="#id4" id="id2">2</a></p></td>
</tr>
<tr class="row-odd"><td><p>+3.3V (ext)</p></td>
<td><p>6.8K</p></td>
<td><p>10K</p></td>
<td><p>1.68</p></td>
<td><p>1964 mV</p></td>
</tr>
</tbody>
</table>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Depending on the CPU (1.4V is for a VIA C3 Nehemiah).</p>
</dd>
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>R1 and R2 for 3.3V (int) are internal to the VT1211 chip and the driver
performs the scaling and returns the properly scaled voltage value.</p>
</dd>
</dl>
<p>Each measured voltage has an associated low and high limit which triggers an
alarm when crossed.</p>
</section>
<section id="temperature-monitoring">
<h2>Temperature Monitoring<a class="headerlink" href="#temperature-monitoring" title="Permalink to this headline">¶</a></h2>
<p>Temperatures are reported in millidegree Celsius. Each measured temperature
has a high limit which triggers an alarm if crossed. There is an associated
hysteresis value with each temperature below which the temperature has to drop
before the alarm is cleared (this is only true for interrupt mode 0). The
interrupt mode can be forced to 0 in case the BIOS doesn’t do it
automatically. See the ‘Module Parameters’ section for details.</p>
<p>All temperature channels except temp2 are external. Temp2 is the VT1211
internal thermal diode and the driver does all the scaling for temp2 and
returns the temperature in millidegree Celsius. For the external channels
temp1 and temp3-temp7, scaling depends on the board implementation and needs
to be performed in userspace via sensors.conf.</p>
<p>Temp1 is an Intel-type thermal diode which requires the following formula to
convert between sysfs readings and real temperatures:</p>
<p>compute temp1 (&#64;-Offset)/Gain, (&#64;*Gain)+Offset</p>
<p>According to the VIA VT1211 BIOS porting guide, the following gain and offset
values should be used:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 24%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Diode Type</p></th>
<th class="head"><p>Offset</p></th>
<th class="head"><p>Gain</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Intel CPU</p></td>
<td><p>88.638
65.000</p></td>
<td><p>0.9528
0.9686 <a class="footnote-reference brackets" href="#id6" id="id5">3</a></p></td>
</tr>
<tr class="row-odd"><td><p>VIA C3 Ezra</p></td>
<td><p>83.869</p></td>
<td><p>0.9528</p></td>
</tr>
<tr class="row-even"><td><p>VIA C3 Ezra-T</p></td>
<td><p>73.869</p></td>
<td><p>0.9528</p></td>
</tr>
</tbody>
</table>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p>This is the formula from the lm_sensors 2.10.0 sensors.conf file. I don’t
know where it comes from or how it was derived, it’s just listed here for
completeness.</p>
</dd>
</dl>
<p>Temp3-temp7 support NTC thermistors. For these channels, the driver returns
the voltages as seen at the individual pins of UCH1-UCH5. The voltage at the
pin (Vpin) is formed by a voltage divider made of the thermistor (Rth) and a
scaling resistor (Rs):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Vpin = 2200 * Rth / (Rs + Rth)   (2200 is the ADC max limit of 2200 mV)
</pre></div>
</div>
<p>The equation for the thermistor is as follows (google it if you want to know
more about it):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Rth = Ro * exp(B * (1 / T - 1 / To))   (To is 298.15K (25C) and Ro is the
                                        nominal resistance at 25C)
</pre></div>
</div>
<p>Mingling the above two equations and assuming Rs = Ro and B = 3435 yields the
following formula for sensors.conf:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>compute tempx 1 / (1 / 298.15 - (` (2200 / @ - 1)) / 3435) - 273.15,
              2200 / (1 + (^ (3435 / 298.15 - 3435 / (273.15 + @))))
</pre></div>
</div>
</section>
<section id="fan-speed-control">
<h2>Fan Speed Control<a class="headerlink" href="#fan-speed-control" title="Permalink to this headline">¶</a></h2>
<p>The VT1211 provides 2 programmable PWM outputs to control the speeds of 2
fans. Writing a 2 to any of the two pwm[1-2]_enable sysfs nodes will put the
PWM controller in automatic mode. There is only a single controller that
controls both PWM outputs but each PWM output can be individually enabled and
disabled.</p>
<p>Each PWM has 4 associated distinct output duty-cycles: full, high, low and
off. Full and off are internally hard-wired to 255 (100%) and 0 (0%),
respectively. High and low can be programmed via
pwm[1-2]_auto_point[2-3]_pwm. Each PWM output can be associated with a
different thermal input but - and here’s the weird part - only one set of
thermal thresholds exist that controls both PWMs output duty-cycles. The
thermal thresholds are accessible via pwm[1-2]_auto_point[1-4]_temp. Note
that even though there are 2 sets of 4 auto points each, they map to the same
registers in the VT1211 and programming one set is sufficient (actually only
the first set pwm1_auto_point[1-4]_temp is writable, the second set is
read-only).</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 39%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>PWM Auto Point</p></th>
<th class="head"><p>PWM Output Duty-Cycle</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>pwm[1-2]_auto_point4_pwm</p></td>
<td><p>full speed duty-cycle (hard-wired to 255)</p></td>
</tr>
<tr class="row-odd"><td><p>pwm[1-2]_auto_point3_pwm</p></td>
<td><p>high speed duty-cycle</p></td>
</tr>
<tr class="row-even"><td><p>pwm[1-2]_auto_point2_pwm</p></td>
<td><p>low speed duty-cycle</p></td>
</tr>
<tr class="row-odd"><td><p>pwm[1-2]_auto_point1_pwm</p></td>
<td><p>off duty-cycle (hard-wired to 0)</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 60%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Temp Auto Point</p></th>
<th class="head"><p>Thermal Threshold</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>pwm[1-2]_auto_point4_temp</p></td>
<td><p>full speed temp</p></td>
</tr>
<tr class="row-odd"><td><p>pwm[1-2]_auto_point3_temp</p></td>
<td><p>high speed temp</p></td>
</tr>
<tr class="row-even"><td><p>pwm[1-2]_auto_point2_temp</p></td>
<td><p>low speed temp</p></td>
</tr>
<tr class="row-odd"><td><p>pwm[1-2]_auto_point1_temp</p></td>
<td><p>off temp</p></td>
</tr>
</tbody>
</table>
<p>Long story short, the controller implements the following algorithm to set the
PWM output duty-cycle based on the input temperature:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 35%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Thermal Threshold</p></th>
<th class="head"><p>Output Duty-Cycle
(Rising Temp)</p></th>
<th class="head"><p>Output Duty-Cycle
(Falling Temp)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>full speed duty-cycle</p></td>
<td><p>full speed duty-cycle</p></td>
</tr>
<tr class="row-odd"><td><p>full speed temp</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>high speed duty-cycle</p></td>
<td><p>full speed duty-cycle</p></td>
</tr>
<tr class="row-odd"><td><p>high speed temp</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>low speed duty-cycle</p></td>
<td><p>high speed duty-cycle</p></td>
</tr>
<tr class="row-odd"><td><p>low speed temp</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>off duty-cycle</p></td>
<td><p>low speed duty-cycle</p></td>
</tr>
<tr class="row-odd"><td><p>off temp</p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Kernel driver vt1211</a><ul>
<li><a class="reference internal" href="#module-parameters">Module Parameters</a></li>
<li><a class="reference internal" href="#description">Description</a></li>
<li><a class="reference internal" href="#voltage-monitoring">Voltage Monitoring</a></li>
<li><a class="reference internal" href="#temperature-monitoring">Temperature Monitoring</a></li>
<li><a class="reference internal" href="#fan-speed-control">Fan Speed Control</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/hwmon/vt1211.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/hwmon/vt1211.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>