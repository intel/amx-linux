
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>The Linux Hardware Monitoring kernel API &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PMBus core driver and internal API" href="pmbus-core.html" />
    <link rel="prev" title="Linux Hardware Monitoring" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="the-linux-hardware-monitoring-kernel-api">
<h1>The Linux Hardware Monitoring kernel API<a class="headerlink" href="#the-linux-hardware-monitoring-kernel-api" title="Permalink to this headline">¶</a></h1>
<p>Guenter Roeck</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes the API that can be used by hardware monitoring
drivers that want to use the hardware monitoring framework.</p>
<p>This document does not describe what a hardware monitoring (hwmon) Driver or
Device is. It also does not describe the API which can be used by user space
to communicate with a hardware monitoring device. If you want to know this
then please read the following file: <a class="reference internal" href="sysfs-interface.html"><span class="doc">Naming and data format standards for sysfs files</span></a>.</p>
<p>For additional guidelines on how to write and improve hwmon drivers, please
also read <a class="reference internal" href="submitting-patches.html"><span class="doc">How to Get Your Patch Accepted Into the Hwmon Subsystem</span></a>.</p>
</section>
<section id="the-api">
<h2>The API<a class="headerlink" href="#the-api" title="Permalink to this headline">¶</a></h2>
<p>Each hardware monitoring driver must #include &lt;linux/hwmon.h&gt; and, in most
cases, &lt;linux/hwmon-sysfs.h&gt;. linux/hwmon.h declares the following
register/unregister functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct device *
hwmon_device_register_with_groups(struct device *dev, const char *name,
                                  void *drvdata,
                                  const struct attribute_group **groups);

struct device *
devm_hwmon_device_register_with_groups(struct device *dev,
                                       const char *name, void *drvdata,
                                       const struct attribute_group **groups);

struct device *
hwmon_device_register_with_info(struct device *dev,
                                const char *name, void *drvdata,
                                const struct hwmon_chip_info *info,
                                const struct attribute_group **extra_groups);

struct device *
devm_hwmon_device_register_with_info(struct device *dev,
                                     const char *name,
                                     void *drvdata,
                                     const struct hwmon_chip_info *info,
                                     const struct attribute_group **extra_groups);

void hwmon_device_unregister(struct device *dev);

void devm_hwmon_device_unregister(struct device *dev);

char *hwmon_sanitize_name(const char *name);

char *devm_hwmon_sanitize_name(struct device *dev, const char *name);
</pre></div>
</div>
<p>hwmon_device_register_with_groups registers a hardware monitoring device.
The first parameter of this function is a pointer to the parent device.
The name parameter is a pointer to the hwmon device name. The registration
function wil create a name sysfs attribute pointing to this name.
The drvdata parameter is the pointer to the local driver data.
hwmon_device_register_with_groups will attach this pointer to the newly
allocated hwmon device. The pointer can be retrieved by the driver using
dev_get_drvdata() on the hwmon device pointer. The groups parameter is
a pointer to a list of sysfs attribute groups. The list must be NULL terminated.
hwmon_device_register_with_groups creates the hwmon device with name attribute
as well as all sysfs attributes attached to the hwmon device.
This function returns a pointer to the newly created hardware monitoring device
or PTR_ERR for failure.</p>
<p>devm_hwmon_device_register_with_groups is similar to
hwmon_device_register_with_groups. However, it is device managed, meaning the
hwmon device does not have to be removed explicitly by the removal function.</p>
<p>hwmon_device_register_with_info is the most comprehensive and preferred means
to register a hardware monitoring device. It creates the standard sysfs
attributes in the hardware monitoring core, letting the driver focus on reading
from and writing to the chip instead of having to bother with sysfs attributes.
The parent device parameter as well as the chip parameter must not be NULL. Its
parameters are described in more detail below.</p>
<p>devm_hwmon_device_register_with_info is similar to
hwmon_device_register_with_info. However, it is device managed, meaning the
hwmon device does not have to be removed explicitly by the removal function.</p>
<p>hwmon_device_unregister deregisters a registered hardware monitoring device.
The parameter of this function is the pointer to the registered hardware
monitoring device structure. This function must be called from the driver
remove function if the hardware monitoring device was registered with
hwmon_device_register_with_groups or hwmon_device_register_with_info.</p>
<p>devm_hwmon_device_unregister does not normally have to be called. It is only
needed for error handling, and only needed if the driver probe fails after
the call to devm_hwmon_device_register_with_groups or
hwmon_device_register_with_info and if the automatic (device managed)
removal would be too late.</p>
<p>All supported hwmon device registration functions only accept valid device
names. Device names including invalid characters (whitespace, ‘*’, or ‘-‘)
will be rejected. The ‘name’ parameter is mandatory.</p>
<p>If the driver doesn’t use a static device name (for example it uses
dev_name()), and therefore cannot make sure the name only contains valid
characters, hwmon_sanitize_name can be used. This convenience function
will duplicate the string and replace any invalid characters with an
underscore. It will allocate memory for the new string and it is the
responsibility of the caller to release the memory when the device is
removed.</p>
<p>devm_hwmon_sanitize_name is the resource managed version of
hwmon_sanitize_name; the memory will be freed automatically on device
removal.</p>
</section>
<section id="using-devm-hwmon-device-register-with-info">
<h2>Using devm_hwmon_device_register_with_info()<a class="headerlink" href="#using-devm-hwmon-device-register-with-info" title="Permalink to this headline">¶</a></h2>
<p>hwmon_device_register_with_info() registers a hardware monitoring device.
The parameters to this function are</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><cite><a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> *dev</cite></p></td>
<td><p>Pointer to parent device</p></td>
</tr>
<tr class="row-even"><td><p><cite>const char *name</cite></p></td>
<td><p>Device name</p></td>
</tr>
<tr class="row-odd"><td><p><cite>void *drvdata</cite></p></td>
<td><p>Driver private data</p></td>
</tr>
<tr class="row-even"><td><p><cite>const struct hwmon_chip_info *info</cite></p></td>
<td><p>Pointer to chip description.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>const struct attribute_group **extra_groups</cite></p></td>
<td><p>Null-terminated list of additional non-standard
sysfs attribute groups.</p></td>
</tr>
</tbody>
</table>
<p>This function returns a pointer to the created hardware monitoring device
on success and a negative error code for failure.</p>
<p>The hwmon_chip_info structure looks as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hwmon_chip_info {
        const struct hwmon_ops *ops;
        const struct hwmon_channel_info **info;
};
</pre></div>
</div>
<p>It contains the following fields:</p>
<ul class="simple">
<li><dl class="simple">
<dt>ops:</dt><dd><p>Pointer to device operations.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>info:</dt><dd><p>NULL-terminated list of device channel descriptors.</p>
</dd>
</dl>
</li>
</ul>
<p>The list of hwmon operations is defined as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hwmon_ops {
      umode_t (*is_visible)(const void *, enum hwmon_sensor_types type,
                            u32 attr, int);
      int (*read)(struct device *, enum hwmon_sensor_types type,
                  u32 attr, int, long *);
      int (*write)(struct device *, enum hwmon_sensor_types type,
                   u32 attr, int, long);
};
</pre></div>
</div>
<p>It defines the following operations.</p>
<ul class="simple">
<li><dl class="simple">
<dt>is_visible:</dt><dd><p>Pointer to a function to return the file mode for each supported
attribute. This function is mandatory.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>read:</dt><dd><p>Pointer to a function for reading a value from the chip. This function
is optional, but must be provided if any readable attributes exist.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>write:</dt><dd><p>Pointer to a function for writing a value to the chip. This function is
optional, but must be provided if any writeable attributes exist.</p>
</dd>
</dl>
</li>
</ul>
<p>Each sensor channel is described with struct hwmon_channel_info, which is
defined as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct hwmon_channel_info {
        enum hwmon_sensor_types type;
        u32 *config;
};
</pre></div>
</div>
<p>It contains following fields:</p>
<ul>
<li><dl>
<dt>type:</dt><dd><p>The hardware monitoring sensor type.</p>
<p>Supported sensor types are</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 74%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>hwmon_chip</p></td>
<td><p>A virtual sensor type, used to describe attributes
which are not bound to a specific input or output</p></td>
</tr>
<tr class="row-even"><td><p>hwmon_temp</p></td>
<td><p>Temperature sensor</p></td>
</tr>
<tr class="row-odd"><td><p>hwmon_in</p></td>
<td><p>Voltage sensor</p></td>
</tr>
<tr class="row-even"><td><p>hwmon_curr</p></td>
<td><p>Current sensor</p></td>
</tr>
<tr class="row-odd"><td><p>hwmon_power</p></td>
<td><p>Power sensor</p></td>
</tr>
<tr class="row-even"><td><p>hwmon_energy</p></td>
<td><p>Energy sensor</p></td>
</tr>
<tr class="row-odd"><td><p>hwmon_humidity</p></td>
<td><p>Humidity sensor</p></td>
</tr>
<tr class="row-even"><td><p>hwmon_fan</p></td>
<td><p>Fan speed sensor</p></td>
</tr>
<tr class="row-odd"><td><p>hwmon_pwm</p></td>
<td><p>PWM control</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>config:</dt><dd><p>Pointer to a 0-terminated list of configuration values for each
sensor of the given type. Each value is a combination of bit values
describing the attributes supposed by a single sensor.</p>
</dd>
</dl>
</li>
</ul>
<p>As an example, here is the complete description file for a LM75 compatible
sensor chip. The chip has a single temperature sensor. The driver wants to
register with the thermal subsystem (HWMON_C_REGISTER_TZ), and it supports
the update_interval attribute (HWMON_C_UPDATE_INTERVAL). The chip supports
reading the temperature (HWMON_T_INPUT), it has a maximum temperature
register (HWMON_T_MAX) as well as a maximum temperature hysteresis register
(HWMON_T_MAX_HYST):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const u32 lm75_chip_config[] = {
        HWMON_C_REGISTER_TZ | HWMON_C_UPDATE_INTERVAL,
        0
};

static const struct hwmon_channel_info lm75_chip = {
        .type = hwmon_chip,
        .config = lm75_chip_config,
};

static const u32 lm75_temp_config[] = {
        HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST,
        0
};

static const struct hwmon_channel_info lm75_temp = {
        .type = hwmon_temp,
        .config = lm75_temp_config,
};

static const struct hwmon_channel_info *lm75_info[] = {
        &amp;lm75_chip,
        &amp;lm75_temp,
        NULL
};

The HWMON_CHANNEL_INFO() macro can and should be used when possible.
With this macro, the above example can be simplified to

static const struct hwmon_channel_info *lm75_info[] = {
        HWMON_CHANNEL_INFO(chip,
                        HWMON_C_REGISTER_TZ | HWMON_C_UPDATE_INTERVAL),
        HWMON_CHANNEL_INFO(temp,
                        HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST),
        NULL
};

The remaining declarations are as follows.

static const struct hwmon_ops lm75_hwmon_ops = {
        .is_visible = lm75_is_visible,
        .read = lm75_read,
        .write = lm75_write,
};

static const struct hwmon_chip_info lm75_chip_info = {
        .ops = &amp;lm75_hwmon_ops,
        .info = lm75_info,
};
</pre></div>
</div>
<p>A complete list of bit values indicating individual attribute support
is defined in include/linux/hwmon.h. Definition prefixes are as follows.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>HWMON_C_xxxx</p></td>
<td><p>Chip attributes, for use with hwmon_chip.</p></td>
</tr>
<tr class="row-even"><td><p>HWMON_T_xxxx</p></td>
<td><p>Temperature attributes, for use with hwmon_temp.</p></td>
</tr>
<tr class="row-odd"><td><p>HWMON_I_xxxx</p></td>
<td><p>Voltage attributes, for use with hwmon_in.</p></td>
</tr>
<tr class="row-even"><td><p>HWMON_C_xxxx</p></td>
<td><p>Current attributes, for use with hwmon_curr.
Notice the prefix overlap with chip attributes.</p></td>
</tr>
<tr class="row-odd"><td><p>HWMON_P_xxxx</p></td>
<td><p>Power attributes, for use with hwmon_power.</p></td>
</tr>
<tr class="row-even"><td><p>HWMON_E_xxxx</p></td>
<td><p>Energy attributes, for use with hwmon_energy.</p></td>
</tr>
<tr class="row-odd"><td><p>HWMON_H_xxxx</p></td>
<td><p>Humidity attributes, for use with hwmon_humidity.</p></td>
</tr>
<tr class="row-even"><td><p>HWMON_F_xxxx</p></td>
<td><p>Fan speed attributes, for use with hwmon_fan.</p></td>
</tr>
<tr class="row-odd"><td><p>HWMON_PWM_xxxx</p></td>
<td><p>PWM control attributes, for use with hwmon_pwm.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="driver-callback-functions">
<h2>Driver callback functions<a class="headerlink" href="#driver-callback-functions" title="Permalink to this headline">¶</a></h2>
<p>Each driver provides is_visible, read, and write functions. Parameters
and return values for those functions are as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>umode_t is_visible_func(const void *data, enum hwmon_sensor_types type,
                        u32 attr, int channel)
</pre></div>
</div>
<dl class="simple">
<dt>Parameters:</dt><dd><dl class="simple">
<dt>data:</dt><dd><p>Pointer to device private data structure.</p>
</dd>
<dt>type:</dt><dd><p>The sensor type.</p>
</dd>
<dt>attr:</dt><dd><p>Attribute identifier associated with a specific attribute.
For example, the attribute value for HWMON_T_INPUT would be
hwmon_temp_input. For complete mappings of bit fields to
attribute values please see include/linux/hwmon.h.</p>
</dd>
<dt>channel:</dt><dd><p>The sensor channel number.</p>
</dd>
</dl>
</dd>
<dt>Return value:</dt><dd><p>The file mode for this attribute. Typically, this will be 0 (the
attribute will not be created), S_IRUGO, or ‘S_IRUGO | S_IWUSR’.</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int read_func(struct device *dev, enum hwmon_sensor_types type,
              u32 attr, int channel, long *val)
</pre></div>
</div>
<dl class="simple">
<dt>Parameters:</dt><dd><dl class="simple">
<dt>dev:</dt><dd><p>Pointer to the hardware monitoring device.</p>
</dd>
<dt>type:</dt><dd><p>The sensor type.</p>
</dd>
<dt>attr:</dt><dd><p>Attribute identifier associated with a specific attribute.
For example, the attribute value for HWMON_T_INPUT would be
hwmon_temp_input. For complete mappings please see
include/linux/hwmon.h.</p>
</dd>
<dt>channel:</dt><dd><p>The sensor channel number.</p>
</dd>
<dt>val:</dt><dd><p>Pointer to attribute value.</p>
</dd>
</dl>
</dd>
<dt>Return value:</dt><dd><p>0 on success, a negative error number otherwise.</p>
</dd>
</dl>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int write_func(struct device *dev, enum hwmon_sensor_types type,
               u32 attr, int channel, long val)
</pre></div>
</div>
<dl class="simple">
<dt>Parameters:</dt><dd><dl class="simple">
<dt>dev:</dt><dd><p>Pointer to the hardware monitoring device.</p>
</dd>
<dt>type:</dt><dd><p>The sensor type.</p>
</dd>
<dt>attr:</dt><dd><p>Attribute identifier associated with a specific attribute.
For example, the attribute value for HWMON_T_INPUT would be
hwmon_temp_input. For complete mappings please see
include/linux/hwmon.h.</p>
</dd>
<dt>channel:</dt><dd><p>The sensor channel number.</p>
</dd>
<dt>val:</dt><dd><p>The value to write to the chip.</p>
</dd>
</dl>
</dd>
<dt>Return value:</dt><dd><p>0 on success, a negative error number otherwise.</p>
</dd>
</dl>
</section>
<section id="driver-provided-sysfs-attributes">
<h2>Driver-provided sysfs attributes<a class="headerlink" href="#driver-provided-sysfs-attributes" title="Permalink to this headline">¶</a></h2>
<p>If the hardware monitoring device is registered with
hwmon_device_register_with_info or devm_hwmon_device_register_with_info,
it is most likely not necessary to provide sysfs attributes. Only additional
non-standard sysfs attributes need to be provided when one of those registration
functions is used.</p>
<p>The header file linux/hwmon-sysfs.h provides a number of useful macros to
declare and use hardware monitoring sysfs attributes.</p>
<p>In many cases, you can use the exsting define DEVICE_ATTR or its variants
DEVICE_ATTR_{RW,RO,WO} to declare such attributes. This is feasible if an
attribute has no additional context. However, in many cases there will be
additional information such as a sensor index which will need to be passed
to the sysfs attribute handling function.</p>
<p>SENSOR_DEVICE_ATTR and SENSOR_DEVICE_ATTR_2 can be used to define attributes
which need such additional context information. SENSOR_DEVICE_ATTR requires
one additional argument, SENSOR_DEVICE_ATTR_2 requires two.</p>
<p>Simplified variants of SENSOR_DEVICE_ATTR and SENSOR_DEVICE_ATTR_2 are available
and should be used if standard attribute permissions and function names are
feasible. Standard permissions are 0644 for SENSOR_DEVICE_ATTR[_2]_RW,
0444 for SENSOR_DEVICE_ATTR[_2]_RO, and 0200 for SENSOR_DEVICE_ATTR[_2]_WO.
Standard functions, similar to DEVICE_ATTR_{RW,RO,WO}, have _show and _store
appended to the provided function name.</p>
<p>SENSOR_DEVICE_ATTR and its variants define a struct sensor_device_attribute
variable. This structure has the following fields:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sensor_device_attribute {
        struct device_attribute dev_attr;
        int index;
};
</pre></div>
</div>
<p>You can use to_sensor_dev_attr to get the pointer to this structure from the
attribute read or write function. Its parameter is the device to which the
attribute is attached.</p>
<p>SENSOR_DEVICE_ATTR_2 and its variants define a struct sensor_device_attribute_2
variable, which is defined as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct sensor_device_attribute_2 {
        struct device_attribute dev_attr;
        u8 index;
        u8 nr;
};
</pre></div>
</div>
<p>Use to_sensor_dev_attr_2 to get the pointer to this structure. Its parameter
is the device to which the attribute is attached.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The Linux Hardware Monitoring kernel API</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#the-api">The API</a></li>
<li><a class="reference internal" href="#using-devm-hwmon-device-register-with-info">Using devm_hwmon_device_register_with_info()</a></li>
<li><a class="reference internal" href="#driver-callback-functions">Driver callback functions</a></li>
<li><a class="reference internal" href="#driver-provided-sysfs-attributes">Driver-provided sysfs attributes</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/hwmon/hwmon-kernel-api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/hwmon/hwmon-kernel-api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>