
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>The ALSA Driver API &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Writing an ALSA Driver" href="writing-an-alsa-driver.html" />
    <link rel="prev" title="ALSA Kernel API Documentation" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="the-alsa-driver-api">
<h1>The ALSA Driver API<a class="headerlink" href="#the-alsa-driver-api" title="Permalink to this headline">¶</a></h1>
<section id="management-of-cards-and-devices">
<h2>Management of Cards and Devices<a class="headerlink" href="#management-of-cards-and-devices" title="Permalink to this headline">¶</a></h2>
<section id="card-management">
<h3>Card Management<a class="headerlink" href="#card-management" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_device_initialize">
void <code class="sig-name descname">snd_device_initialize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a> for sound devices</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to initialize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>card to assign, optional</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_card_new">
int <code class="sig-name descname">snd_card_new</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *parent</em>, int<em> idx</em>, const char<em> *xid</em>, struct module<em> *module</em>, int<em> extra_size</em>, struct snd_card<em> **card_ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create and initialize a soundcard structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>the parent device object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>card index (address) [0 … (SNDRV_CARDS-1)]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*xid</span></code></dt><dd><p>card identification (ASCII string)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*module</span></code></dt><dd><p>top level module for locking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">extra_size</span></code></dt><dd><p>allocate this extra size after the main soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">**card_ret</span></code></dt><dd><p>the pointer to store the created card instance</p>
<p>The function allocates snd_card instance via kzalloc with the given
space for the driver to use freely.  The allocated struct is stored
in the given card_ret pointer.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_devm_card_new">
int <code class="sig-name descname">snd_devm_card_new</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *parent</em>, int<em> idx</em>, const char<em> *xid</em>, struct module<em> *module</em>, size_t<em> extra_size</em>, struct snd_card<em> **card_ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_devm_card_new" title="Permalink to this definition">¶</a></dt>
<dd><p>managed snd_card object creation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>the parent device object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>card index (address) [0 … (SNDRV_CARDS-1)]</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*xid</span></code></dt><dd><p>card identification (ASCII string)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*module</span></code></dt><dd><p>top level module for locking</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">extra_size</span></code></dt><dd><p>allocate this extra size after the main soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">**card_ret</span></code></dt><dd><p>the pointer to store the created card instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works like <a class="reference internal" href="#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a> but manages the allocated resource
via devres, i.e. you don’t need to free explicitly.</p>
<p>When a snd_card object is created with this function and registered via
<a class="reference internal" href="#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a>, the very first devres action to call <a class="reference internal" href="#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a>
is added automatically.  In that way, the resource disconnection is assured
at first, then released in the expected order.</p>
<p>If an error happens at the probe before <a class="reference internal" href="#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a> is called and
there have been other devres resources, you’d need to free the card manually
via <a class="reference internal" href="#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a> call in the error; otherwise it may lead to UAF due to
devres call orders.  You can use <a class="reference internal" href="#c.snd_card_free_on_error" title="snd_card_free_on_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free_on_error()</span></code></a> helper for
handling it more easily.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_card_free_on_error">
int <code class="sig-name descname">snd_card_free_on_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, int<em> ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_free_on_error" title="Permalink to this definition">¶</a></dt>
<dd><p>a small helper for handling devm probe errors</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the managed device object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">ret</span></code></dt><dd><p>the return code from the probe callback</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles the explicit <a class="reference internal" href="#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a> call at the error from
the probe callback.  It’s just a small helper for simplifying the error
handling with the managed devices.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_card_ref">
struct snd_card * <code class="sig-name descname">snd_card_ref</code><span class="sig-paren">(</span>int<em> idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the card object from the index</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>the card index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a card object corresponding to the given index or NULL if not found.
Release the object via <a class="reference internal" href="#c.snd_card_unref" title="snd_card_unref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_unref()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>a card object or NULL</p>
</div>
<dl class="function">
<dt id="c.snd_card_disconnect">
int <code class="sig-name descname">snd_card_disconnect</code><span class="sig-paren">(</span>struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect all APIs from the file-operations (user space)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>soundcard structure</p>
<p>Disconnects all APIs from the file-operations (user space).</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero, otherwise a negative error code.</p>
<p><strong>Note</strong></p>
<dl class="simple">
<dt>The current implementation replaces all active file-&gt;f_op with special</dt><dd><p>dummy file operations (they do nothing except release).</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_card_disconnect_sync">
void <code class="sig-name descname">snd_card_disconnect_sync</code><span class="sig-paren">(</span>struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_disconnect_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect card and wait until files get closed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>card object to disconnect</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This calls <a class="reference internal" href="#c.snd_card_disconnect" title="snd_card_disconnect"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_disconnect()</span></code></a> for disconnecting all belonging components
and waits until all pending files get closed.
It assures that all accesses from user-space finished so that the driver
can release its resources gracefully.</p>
</div>
<dl class="function">
<dt id="c.snd_card_free_when_closed">
int <code class="sig-name descname">snd_card_free_when_closed</code><span class="sig-paren">(</span>struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_free_when_closed" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect the card, free it later eventually</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>soundcard structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a>, this function doesn’t try to release the card
resource immediately, but tries to disconnect at first.  When the card
is still in use, the function returns before freeing the resources.
The card resources will be freed when the refcount gets to zero.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_card_free">
int <code class="sig-name descname">snd_card_free</code><span class="sig-paren">(</span>struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_free" title="Permalink to this definition">¶</a></dt>
<dd><p>frees given soundcard structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>soundcard structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function releases the soundcard structure and the all assigned
devices automatically.  That is, you don’t have to release the devices
by yourself.</p>
<p>This function waits until the all resources are properly released.</p>
<p><strong>Return</strong></p>
<p>Zero. Frees all associated devices and frees the control
interface associated to given soundcard.</p>
</div>
<dl class="function">
<dt id="c.snd_card_set_id">
void <code class="sig-name descname">snd_card_set_id</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, const char<em> *nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_set_id" title="Permalink to this definition">¶</a></dt>
<dd><p>set card identification name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*nid</span></code></dt><dd><p>new identification string</p>
<p>This function sets the card identification and checks for name
collisions.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_card_add_dev_attr">
int <code class="sig-name descname">snd_card_add_dev_attr</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, const struct attribute_group<em> *group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_add_dev_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a new sysfs attribute group to card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">*group</span></code></dt><dd><p>attribute group to append</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_card_register">
int <code class="sig-name descname">snd_card_register</code><span class="sig-paren">(</span>struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register the soundcard</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>soundcard structure</p>
<p>This function registers all the devices assigned to the soundcard.
Until calling this, the ALSA control interface is blocked from the
external accesses.  Thus, you should call this function at the end
of the initialization of the card.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero otherwise a negative error code if the registration failed.</p>
</div>
<dl class="function">
<dt id="c.snd_component_add">
int <code class="sig-name descname">snd_component_add</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, const char<em> *component</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_component_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a component string</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*component</span></code></dt><dd><p>the component id string</p>
<p>This function adds the component id string to the supported list.
The component can be referred from the alsa-lib.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero otherwise a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_card_file_add">
int <code class="sig-name descname">snd_card_file_add</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_file_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the file to the file list of the card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file pointer</p>
<p>This function adds the file to the file linked-list of the card.
This linked-list is used to keep tracking the connection state,
and to avoid the release of busy resources by hotplug.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_card_file_remove">
int <code class="sig-name descname">snd_card_file_remove</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_file_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the file from the file list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>soundcard structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file pointer</p>
<p>This function removes the file formerly added to the card via
<a class="reference internal" href="#c.snd_card_file_add" title="snd_card_file_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_file_add()</span></code></a> function.
If all files are removed and <a class="reference internal" href="#c.snd_card_free_when_closed" title="snd_card_free_when_closed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free_when_closed()</span></code></a> was
called beforehand, it processes the pending release of
resources.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_power_ref_and_wait">
int <code class="sig-name descname">snd_power_ref_and_wait</code><span class="sig-paren">(</span>struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_power_ref_and_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until the card gets powered up</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>soundcard structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Take the power_ref reference count of the given card, and
wait until the card gets powered up to SNDRV_CTL_POWER_D0 state.
The refcount is down again while sleeping until power-up, hence this
function can be used for syncing the floating control ops accesses,
typically around calling control ops.</p>
<p>The caller needs to pull down the refcount via <a class="reference internal" href="#c.snd_power_unref" title="snd_power_unref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_power_unref()</span></code></a> later
no matter whether the error is returned from this function or not.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_power_wait">
int <code class="sig-name descname">snd_power_wait</code><span class="sig-paren">(</span>struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_power_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until the card gets powered up (old form)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>soundcard structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until the card gets powered up to SNDRV_CTL_POWER_D0 state.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
</div>
</section>
<section id="device-components">
<h3>Device Components<a class="headerlink" href="#device-components" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_device_new">
int <code class="sig-name descname">snd_device_new</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, enum snd_device_type<em> type</em>, void<em> *device_data</em>, const struct snd_device_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create an ALSA device component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">snd_device_type</span> <span class="pre">type</span></code></dt><dd><p>the device type, SNDRV_DEV_XXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*device_data</span></code></dt><dd><p>the data pointer of this device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_device_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the operator table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new device component for the given data pointer.
The device will be assigned to the card and managed together
by the card.</p>
<p>The data pointer plays a role as the identifier, too, so the
pointer address must be unique and unchanged.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_device_disconnect">
void <code class="sig-name descname">snd_device_disconnect</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, void<em> *device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*device_data</span></code></dt><dd><p>the data pointer to disconnect</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turns the device into the disconnection state, invoking
dev_disconnect callback, if the device was already registered.</p>
<p>Usually called from <a class="reference internal" href="#c.snd_card_disconnect" title="snd_card_disconnect"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_disconnect()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure or if the
device not found.</p>
</div>
<dl class="function">
<dt id="c.snd_device_free">
void <code class="sig-name descname">snd_device_free</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, void<em> *device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_free" title="Permalink to this definition">¶</a></dt>
<dd><p>release the device from the card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*device_data</span></code></dt><dd><p>the data pointer to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the device from the list on the card and invokes the
callbacks, dev_disconnect and dev_free, corresponding to the state.
Then release the device.</p>
</div>
<dl class="function">
<dt id="c.snd_device_register">
int <code class="sig-name descname">snd_device_register</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, void<em> *device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*device_data</span></code></dt><dd><p>the data pointer to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers the device which was already created via
<a class="reference internal" href="#c.snd_device_new" title="snd_device_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_device_new()</span></code></a>.  Usually this is called from <a class="reference internal" href="#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a>,
but it can be called later if any new devices are created after
invocation of <a class="reference internal" href="#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure or if the
device not found.</p>
</div>
<dl class="function">
<dt id="c.snd_device_get_state">
int <code class="sig-name descname">snd_device_get_state</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, void<em> *device_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_device_get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current state of the given device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*device_data</span></code></dt><dd><p>the data pointer to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the current state of the given device object.  For the valid
device, either <strong>SNDRV_DEV_BUILD</strong>, <strong>SNDRV_DEV_REGISTERED</strong> or
<strong>SNDRV_DEV_DISCONNECTED</strong> is returned.
Or for a non-existing device, -1 is returned as an error.</p>
<p><strong>Return</strong></p>
<p>the current state, or -1 if not found</p>
</div>
</section>
<section id="module-requests-and-device-file-entries">
<h3>Module requests and Device File Entries<a class="headerlink" href="#module-requests-and-device-file-entries" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_request_card">
void <code class="sig-name descname">snd_request_card</code><span class="sig-paren">(</span>int<em> card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_request_card" title="Permalink to this definition">¶</a></dt>
<dd><p>try to load the card module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">card</span></code></dt><dd><p>the card number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tries to load the module “snd-card-X” for the given card number
via request_module.  Returns immediately if already loaded.</p>
</div>
<dl class="function">
<dt id="c.snd_lookup_minor_data">
void * <code class="sig-name descname">snd_lookup_minor_data</code><span class="sig-paren">(</span>unsigned int<em> minor</em>, int<em> type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_lookup_minor_data" title="Permalink to this definition">¶</a></dt>
<dd><p>get user data of a registered device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">minor</span></code></dt><dd><p>the minor number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>device type (SNDRV_DEVICE_TYPE_XXX)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that a minor device with the specified type is registered, and returns
its user data pointer.</p>
<p>This function increments the reference counter of the card instance
if an associated instance with the given minor number and type is found.
The caller must call <a class="reference internal" href="#c.snd_card_unref" title="snd_card_unref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_unref()</span></code></a> appropriately later.</p>
<p><strong>Return</strong></p>
<p>The user data pointer if the specified device is found. <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
otherwise.</p>
</div>
<dl class="function">
<dt id="c.snd_register_device">
int <code class="sig-name descname">snd_register_device</code><span class="sig-paren">(</span>int<em> type</em>, struct snd_card<em> *card</em>, int<em> dev</em>, const struct file_operations<em> *f_ops</em>, void<em> *private_data</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_register_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the ALSA device file for the card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>the device type, SNDRV_DEVICE_TYPE_XXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dev</span></code></dt><dd><p>the device index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*f_ops</span></code></dt><dd><p>the file operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*private_data</span></code></dt><dd><p>user pointer for f_ops-&gt;open()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>the device to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers an ALSA device file for the given card.
The operators have to be set in reg parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_unregister_device">
int <code class="sig-name descname">snd_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister the device on the given card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters the device file already registered via
<a class="reference internal" href="#c.snd_register_device" title="snd_register_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_register_device()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
</section>
<section id="memory-management-helpers">
<h3>Memory Management Helpers<a class="headerlink" href="#memory-management-helpers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.copy_to_user_fromio">
int <code class="sig-name descname">copy_to_user_fromio</code><span class="sig-paren">(</span>void __user<em> *dst</em>, const volatile void __iomem<em> *src</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_to_user_fromio" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from mmio-space to user-space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*dst</span></code></dt><dd><p>the destination pointer on user-space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">volatile</span> <span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*src</span></code></dt><dd><p>the source pointer on mmio</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the data size to copy in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies the data from mmio-space to user-space.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or non-zero on failure.</p>
</div>
<dl class="function">
<dt id="c.copy_from_user_toio">
int <code class="sig-name descname">copy_from_user_toio</code><span class="sig-paren">(</span>volatile void __iomem<em> *dst</em>, const void __user<em> *src</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.copy_from_user_toio" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from user-space to mmio-space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*dst</span></code></dt><dd><p>the destination pointer on mmio-space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*src</span></code></dt><dd><p>the source pointer on user-space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>the data size to copy in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies the data from user-space to mmio-space.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or non-zero on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_dma_alloc_dir_pages">
int <code class="sig-name descname">snd_dma_alloc_dir_pages</code><span class="sig-paren">(</span>int<em> type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *device</em>, enum dma_data_direction<em> dir</em>, size_t<em> size</em>, struct snd_dma_buffer<em> *dmab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_alloc_dir_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate the buffer area according to the given type and direction</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>the DMA buffer type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>the device pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>DMA direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the buffer size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*dmab</span></code></dt><dd><p>buffer allocation record to store the allocated data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the memory-allocator function for the corresponding
buffer type.</p>
<p><strong>Return</strong></p>
<p>Zero if the buffer with the given size is allocated successfully,
otherwise a negative value on error.</p>
</div>
<dl class="function">
<dt id="c.snd_dma_alloc_pages_fallback">
int <code class="sig-name descname">snd_dma_alloc_pages_fallback</code><span class="sig-paren">(</span>int<em> type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *device</em>, size_t<em> size</em>, struct snd_dma_buffer<em> *dmab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_alloc_pages_fallback" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate the buffer area according to the given type with fallback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>the DMA buffer type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*device</span></code></dt><dd><p>the device pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the buffer size to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*dmab</span></code></dt><dd><p>buffer allocation record to store the allocated data</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls the memory-allocator function for the corresponding
buffer type.  When no space is left, this function reduces the size and
tries to allocate again.  The size actually allocated is stored in
res_size argument.</p>
<p><strong>Return</strong></p>
<p>Zero if the buffer with the given size is allocated successfully,
otherwise a negative value on error.</p>
</div>
<dl class="function">
<dt id="c.snd_dma_free_pages">
void <code class="sig-name descname">snd_dma_free_pages</code><span class="sig-paren">(</span>struct snd_dma_buffer<em> *dmab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_free_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>release the allocated buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*dmab</span></code></dt><dd><p>the buffer allocation record to release</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the allocated buffer via snd_dma_alloc_pages().</p>
</div>
<dl class="function">
<dt id="c.snd_devm_alloc_dir_pages">
struct snd_dma_buffer * <code class="sig-name descname">snd_devm_alloc_dir_pages</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, int<em> type</em>, enum dma_data_direction<em> dir</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_devm_alloc_dir_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate the buffer and manage with devres</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>the DMA buffer type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt><dd><p>DMA direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the buffer size to allocate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate buffer pages depending on the given type and manage using devres.
The pages will be released automatically at the device removal.</p>
<p>Unlike snd_dma_alloc_pages(), this function requires the real device pointer,
hence it can’t work with SNDRV_DMA_TYPE_CONTINUOUS or
SNDRV_DMA_TYPE_VMALLOC type.</p>
<p><strong>Return</strong></p>
<p>the snd_dma_buffer object at success, or NULL if failed</p>
</div>
<dl class="function">
<dt id="c.snd_dma_buffer_mmap">
int <code class="sig-name descname">snd_dma_buffer_mmap</code><span class="sig-paren">(</span>struct snd_dma_buffer<em> *dmab</em>, struct vm_area_struct<em> *area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_buffer_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>perform mmap of the given DMA buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*dmab</span></code></dt><dd><p>buffer allocation information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*area</span></code></dt><dd><p>VM area information</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_dma_buffer_sync">
void <code class="sig-name descname">snd_dma_buffer_sync</code><span class="sig-paren">(</span>struct snd_dma_buffer<em> *dmab</em>, enum snd_dma_sync_mode<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_buffer_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>sync DMA buffer between CPU and device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*dmab</span></code></dt><dd><p>buffer allocation information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">snd_dma_sync_mode</span> <span class="pre">mode</span></code></dt><dd><p>sync mode</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_sgbuf_get_addr">
dma_addr_t <code class="sig-name descname">snd_sgbuf_get_addr</code><span class="sig-paren">(</span>struct snd_dma_buffer<em> *dmab</em>, size_t<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_sgbuf_get_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>return the physical address at the corresponding offset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*dmab</span></code></dt><dd><p>buffer allocation information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">offset</span></code></dt><dd><p>offset in the ring buffer</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the physical address</p>
</div>
<dl class="function">
<dt id="c.snd_sgbuf_get_page">
struct page * <code class="sig-name descname">snd_sgbuf_get_page</code><span class="sig-paren">(</span>struct snd_dma_buffer<em> *dmab</em>, size_t<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_sgbuf_get_page" title="Permalink to this definition">¶</a></dt>
<dd><p>return the physical page at the corresponding offset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*dmab</span></code></dt><dd><p>buffer allocation information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">offset</span></code></dt><dd><p>offset in the ring buffer</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the page pointer</p>
</div>
<dl class="function">
<dt id="c.snd_sgbuf_get_chunk_size">
unsigned int <code class="sig-name descname">snd_sgbuf_get_chunk_size</code><span class="sig-paren">(</span>struct snd_dma_buffer<em> *dmab</em>, unsigned int<em> ofs</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_sgbuf_get_chunk_size" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the max chunk size with continuous pages on sg-buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*dmab</span></code></dt><dd><p>buffer allocation information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ofs</span></code></dt><dd><p>offset in the ring buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the requested size</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the chunk size</p>
</div>
</section>
</section>
<section id="pcm-api">
<h2>PCM API<a class="headerlink" href="#pcm-api" title="Permalink to this headline">¶</a></h2>
<section id="pcm-core">
<h3>PCM Core<a class="headerlink" href="#pcm-core" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_pcm_format_name">
const char * <code class="sig-name descname">snd_pcm_format_name</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a name string for the given PCM format</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>PCM format</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the format name string</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_new_stream">
int <code class="sig-name descname">snd_pcm_new_stream</code><span class="sig-paren">(</span>struct snd_pcm<em> *pcm</em>, int<em> stream</em>, int<em> substream_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_new_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new PCM stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*pcm</span></code></dt><dd><p>the pcm instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt><dd><p>the stream direction, SNDRV_PCM_STREAM_XXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">substream_count</span></code></dt><dd><p>the number of substreams</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new stream for the pcm.
The corresponding stream on the pcm must have been empty before
calling this, i.e. zero must be given to the argument of
<a class="reference internal" href="#c.snd_pcm_new" title="snd_pcm_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_new()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_new">
int <code class="sig-name descname">snd_pcm_new</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, const char<em> *id</em>, int<em> device</em>, int<em> playback_count</em>, int<em> capture_count</em>, struct snd_pcm<em> **rpcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new PCM instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>the id string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>the device index (zero based)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">playback_count</span></code></dt><dd><p>the number of substreams for playback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">capture_count</span></code></dt><dd><p>the number of substreams for capture</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">**rpcm</span></code></dt><dd><p>the pointer to store the new pcm instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new PCM instance.</p>
<p>The pcm operators have to be set afterwards to the new instance
via <a class="reference internal" href="#c.snd_pcm_set_ops" title="snd_pcm_set_ops"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_ops()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_new_internal">
int <code class="sig-name descname">snd_pcm_new_internal</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, const char<em> *id</em>, int<em> device</em>, int<em> playback_count</em>, int<em> capture_count</em>, struct snd_pcm<em> **rpcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_new_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new internal PCM instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>the id string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>the device index (zero based - shared with normal PCMs)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">playback_count</span></code></dt><dd><p>the number of substreams for playback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">capture_count</span></code></dt><dd><p>the number of substreams for capture</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">**rpcm</span></code></dt><dd><p>the pointer to store the new pcm instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new internal PCM instance with no userspace device or procfs
entries. This is used by ASoC Back End PCMs in order to create a PCM that
will only be used internally by kernel drivers. i.e. it cannot be opened
by userspace. It provides existing ASoC components drivers with a substream
and access to any private data.</p>
<p>The pcm operators have to be set afterwards to the new instance
via <a class="reference internal" href="#c.snd_pcm_set_ops" title="snd_pcm_set_ops"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_ops()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_notify">
int <code class="sig-name descname">snd_pcm_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_pcm_notify" title="snd_pcm_notify">snd_pcm_notify</a><em> *notify</em>, int<em> nfree</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Add/remove the notify list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_notify</span> <span class="pre">*notify</span></code></dt><dd><p>PCM notify list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">nfree</span></code></dt><dd><p>0 = register, 1 = unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds the given notifier to the global list so that the callback is
called for each registered PCM devices.  This exists only for PCM OSS
emulation, so far.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_set_ops">
void <code class="sig-name descname">snd_pcm_set_ops</code><span class="sig-paren">(</span>struct snd_pcm<em> *pcm</em>, int<em> direction</em>, const struct snd_pcm_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>set the PCM operators</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*pcm</span></code></dt><dd><p>the pcm instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">direction</span></code></dt><dd><p>stream direction, SNDRV_PCM_STREAM_XXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the operator table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the given PCM operators to the pcm instance.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_set_sync">
void <code class="sig-name descname">snd_pcm_set_sync</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>set the PCM sync id</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the PCM sync identifier for the card.</p>
</div>
<dl class="function">
<dt id="c.snd_interval_refine">
int <code class="sig-name descname">snd_interval_refine</code><span class="sig-paren">(</span>struct snd_interval<em> *i</em>, const struct snd_interval<em> *v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_refine" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value of configurator</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*i</span></code></dt><dd><p>the interval value to refine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*v</span></code></dt><dd><p>the interval value to refer to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refines the interval value with the reference value.
The interval is changed to the range satisfying both intervals.
The interval status (min, max, integer, etc.) are evaluated.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_interval_div">
void <code class="sig-name descname">snd_interval_div</code><span class="sig-paren">(</span>const struct snd_interval<em> *a</em>, const struct snd_interval<em> *b</em>, struct snd_interval<em> *c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_div" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value with division</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*a</span></code></dt><dd><p>dividend</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*b</span></code></dt><dd><p>divisor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*c</span></code></dt><dd><p>quotient</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>c = a / b</p>
<p>Returns non-zero if the value is changed, zero if not changed.</p>
</div>
<dl class="function">
<dt id="c.snd_interval_muldivk">
void <code class="sig-name descname">snd_interval_muldivk</code><span class="sig-paren">(</span>const struct snd_interval<em> *a</em>, const struct snd_interval<em> *b</em>, unsigned int<em> k</em>, struct snd_interval<em> *c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_muldivk" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*a</span></code></dt><dd><p>dividend 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*b</span></code></dt><dd><p>dividend 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">k</span></code></dt><dd><p>divisor (as integer)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*c</span></code></dt><dd><p>result</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>c = a * b / k</p>
<p>Returns non-zero if the value is changed, zero if not changed.</p>
</div>
<dl class="function">
<dt id="c.snd_interval_mulkdiv">
void <code class="sig-name descname">snd_interval_mulkdiv</code><span class="sig-paren">(</span>const struct snd_interval<em> *a</em>, unsigned int<em> k</em>, const struct snd_interval<em> *b</em>, struct snd_interval<em> *c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_mulkdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*a</span></code></dt><dd><p>dividend 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">k</span></code></dt><dd><p>dividend 2 (as integer)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*b</span></code></dt><dd><p>divisor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*c</span></code></dt><dd><p>result</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>c = a * k / b</p>
<p>Returns non-zero if the value is changed, zero if not changed.</p>
</div>
<dl class="function">
<dt id="c.snd_interval_ratnum">
int <code class="sig-name descname">snd_interval_ratnum</code><span class="sig-paren">(</span>struct snd_interval<em> *i</em>, unsigned int<em> rats_count</em>, const struct snd_ratnum<em> *rats</em>, unsigned int<em> *nump</em>, unsigned int<em> *denp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_ratnum" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*i</span></code></dt><dd><p>interval to refine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rats_count</span></code></dt><dd><p>number of ratnum_t</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_ratnum</span> <span class="pre">*rats</span></code></dt><dd><p>ratnum_t array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*nump</span></code></dt><dd><p>pointer to store the resultant numerator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*denp</span></code></dt><dd><p>pointer to store the resultant denominator</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_interval_ratden">
int <code class="sig-name descname">snd_interval_ratden</code><span class="sig-paren">(</span>struct snd_interval<em> *i</em>, unsigned int<em> rats_count</em>, const struct snd_ratden<em> *rats</em>, unsigned int<em> *nump</em>, unsigned int<em> *denp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_ratden" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*i</span></code></dt><dd><p>interval to refine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rats_count</span></code></dt><dd><p>number of struct ratden</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_ratden</span> <span class="pre">*rats</span></code></dt><dd><p>struct ratden array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*nump</span></code></dt><dd><p>pointer to store the resultant numerator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*denp</span></code></dt><dd><p>pointer to store the resultant denominator</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_interval_list">
int <code class="sig-name descname">snd_interval_list</code><span class="sig-paren">(</span>struct snd_interval<em> *i</em>, unsigned int<em> count</em>, const unsigned int<em> *list</em>, unsigned int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_list" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value from the list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*i</span></code></dt><dd><p>the interval value to refine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of elements in the list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*list</span></code></dt><dd><p>the value list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>the bit-mask to evaluate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refines the interval value from the list.
When mask is non-zero, only the elements corresponding to bit 1 are
evaluated.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_interval_ranges">
int <code class="sig-name descname">snd_interval_ranges</code><span class="sig-paren">(</span>struct snd_interval<em> *i</em>, unsigned int<em> count</em>, const struct snd_interval<em> *ranges</em>, unsigned int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_interval_ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>refine the interval value from the list of ranges</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*i</span></code></dt><dd><p>the interval value to refine</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of elements in the list of ranges</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_interval</span> <span class="pre">*ranges</span></code></dt><dd><p>the ranges list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>the bit-mask to evaluate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refines the interval value from the list of ranges.
When mask is non-zero, only the elements corresponding to bit 1 are
evaluated.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_rule_add">
int <code class="sig-name descname">snd_pcm_hw_rule_add</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, unsigned int<em> cond</em>, int<em> var</em>, snd_pcm_hw_rule_func_t<em> func</em>, void<em> *private</em>, int<em> dep</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_rule_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the hw-constraint rule</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>the pcm runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">var</span></code></dt><dd><p>the variable to evaluate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_rule_func_t</span> <span class="pre">func</span></code></dt><dd><p>the evaluation function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*private</span></code></dt><dd><p>the private data pointer passed to function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dep</span></code></dt><dd><p>the dependent variables</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_mask">
int <code class="sig-name descname">snd_pcm_hw_constraint_mask</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, snd_pcm_hw_param_t<em> var</em>, u_int32_t<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the given bitmap mask constraint</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u_int32_t</span> <span class="pre">mask</span></code></dt><dd><p>the bitmap mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the constraint of the given bitmap mask to a 32-bit mask parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_mask64">
int <code class="sig-name descname">snd_pcm_hw_constraint_mask64</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, snd_pcm_hw_param_t<em> var</em>, u_int64_t<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_mask64" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the given bitmap mask constraint</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u_int64_t</span> <span class="pre">mask</span></code></dt><dd><p>the 64bit bitmap mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the constraint of the given bitmap mask to a 64-bit mask parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_integer">
int <code class="sig-name descname">snd_pcm_hw_constraint_integer</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, snd_pcm_hw_param_t<em> var</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_integer" title="Permalink to this definition">¶</a></dt>
<dd><p>apply an integer constraint to an interval</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the integer constraint</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the constraint of integer to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_minmax">
int <code class="sig-name descname">snd_pcm_hw_constraint_minmax</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, snd_pcm_hw_param_t<em> var</em>, unsigned int<em> min</em>, unsigned int<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a min/max range constraint to an interval</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the range</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt><dd><p>the minimal value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt><dd><p>the maximal value</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the min/max range constraint to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_list">
int <code class="sig-name descname">snd_pcm_hw_constraint_list</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_list" title="snd_pcm_hw_constraint_list">snd_pcm_hw_constraint_list</a><em> *l</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_list" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a list of constraints to a parameter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the list constraint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_list</span> <span class="pre">*l</span></code></dt><dd><p>list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the list of constraints to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_ranges">
int <code class="sig-name descname">snd_pcm_hw_constraint_ranges</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_ranges" title="snd_pcm_hw_constraint_ranges">snd_pcm_hw_constraint_ranges</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>apply list of range constraints to a parameter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the list of range constraints</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_ranges</span> <span class="pre">*r</span></code></dt><dd><p>ranges</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the list of range constraints to an interval parameter.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_ratnums">
int <code class="sig-name descname">snd_pcm_hw_constraint_ratnums</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_ratnums" title="snd_pcm_hw_constraint_ratnums">snd_pcm_hw_constraint_ratnums</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_ratnums" title="Permalink to this definition">¶</a></dt>
<dd><p>apply ratnums constraint to a parameter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the ratnums constraint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_ratnums</span> <span class="pre">*r</span></code></dt><dd><p>struct snd_ratnums constriants</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_ratdens">
int <code class="sig-name descname">snd_pcm_hw_constraint_ratdens</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em>, const struct <a class="reference internal" href="#c.snd_pcm_hw_constraint_ratdens" title="snd_pcm_hw_constraint_ratdens">snd_pcm_hw_constraint_ratdens</a><em> *r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_ratdens" title="Permalink to this definition">¶</a></dt>
<dd><p>apply ratdens constraint to a parameter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the ratdens constraint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_constraint_ratdens</span> <span class="pre">*r</span></code></dt><dd><p>struct snd_ratdens constriants</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_msbits">
int <code class="sig-name descname">snd_pcm_hw_constraint_msbits</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, unsigned int<em> cond</em>, unsigned int<em> width</em>, unsigned int<em> msbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_msbits" title="Permalink to this definition">¶</a></dt>
<dd><p>add a hw constraint msbits rule</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">width</span></code></dt><dd><p>sample bits width</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msbits</span></code></dt><dd><p>msbits width</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This constraint will set the number of most significant bits (msbits) if a
sample format with the specified width has been select. If width is set to 0
the msbits will be set for any sample format with a width larger than the
specified msbits.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_step">
int <code class="sig-name descname">snd_pcm_hw_constraint_step</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em>, unsigned long<em> step</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_step" title="Permalink to this definition">¶</a></dt>
<dd><p>add a hw constraint step rule</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the step constraint</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">step</span></code></dt><dd><p>step size</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_pow2">
int <code class="sig-name descname">snd_pcm_hw_constraint_pow2</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, unsigned int<em> cond</em>, snd_pcm_hw_param_t<em> var</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_pow2" title="Permalink to this definition">¶</a></dt>
<dd><p>add a hw constraint power-of-2 rule</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cond</span></code></dt><dd><p>condition bits</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>hw_params variable to apply the power-of-2 constraint</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_rule_noresample">
int <code class="sig-name descname">snd_pcm_hw_rule_noresample</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, unsigned int<em> base_rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_rule_noresample" title="Permalink to this definition">¶</a></dt>
<dd><p>add a rule to allow disabling hw resampling</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base_rate</span></code></dt><dd><p>the rate at which the hardware does not resample</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_param_value">
int <code class="sig-name descname">snd_pcm_hw_param_value</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params<em> *params</em>, snd_pcm_hw_param_t<em> var</em>, int<em> *dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_param_value" title="Permalink to this definition">¶</a></dt>
<dd><p>return <strong>params</strong> field <strong>var</strong> value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*params</span></code></dt><dd><p>the hw_params instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>parameter to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*dir</span></code></dt><dd><p>pointer to the direction (-1,0,1) or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The value for field <strong>var</strong> if it’s fixed in configuration space
defined by <strong>params</strong>. -<code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_param_first">
int <code class="sig-name descname">snd_pcm_hw_param_first</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *pcm</em>, struct snd_pcm_hw_params<em> *params</em>, snd_pcm_hw_param_t<em> var</em>, int<em> *dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_param_first" title="Permalink to this definition">¶</a></dt>
<dd><p>refine config space and return minimum value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*pcm</span></code></dt><dd><p>PCM instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*params</span></code></dt><dd><p>the hw_params instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>parameter to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*dir</span></code></dt><dd><p>pointer to the direction (-1,0,1) or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inside configuration space defined by <strong>params</strong> remove from <strong>var</strong> all
values &gt; minimum. Reduce configuration space accordingly.</p>
<p><strong>Return</strong></p>
<p>The minimum, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_param_last">
int <code class="sig-name descname">snd_pcm_hw_param_last</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *pcm</em>, struct snd_pcm_hw_params<em> *params</em>, snd_pcm_hw_param_t<em> var</em>, int<em> *dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_param_last" title="Permalink to this definition">¶</a></dt>
<dd><p>refine config space and return maximum value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*pcm</span></code></dt><dd><p>PCM instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*params</span></code></dt><dd><p>the hw_params instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>parameter to retrieve</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*dir</span></code></dt><dd><p>pointer to the direction (-1,0,1) or <code class="docutils literal notranslate"><span class="pre">NULL</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inside configuration space defined by <strong>params</strong> remove from <strong>var</strong> all
values &lt; maximum. Reduce configuration space accordingly.</p>
<p><strong>Return</strong></p>
<p>The maximum, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_ioctl">
int <code class="sig-name descname">snd_pcm_lib_ioctl</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, unsigned int<em> cmd</em>, void<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>a generic PCM ioctl callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>ioctl command</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>ioctl argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes the generic ioctl commands for PCM.
Can be passed as the ioctl callback for PCM ops.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_period_elapsed_under_stream_lock">
void <code class="sig-name descname">snd_pcm_period_elapsed_under_stream_lock</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_period_elapsed_under_stream_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>update the status of runtime for the next period under acquired lock of PCM substream.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the instance of pcm substream.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called when the batch of audio data frames as the same size as the period of
buffer is already processed in audio data transmission.</p>
<p>The call of function updates the status of runtime with the latest position of audio data
transmission, checks overrun and underrun over buffer, awaken user processes from waiting for
available audio data frames, sampling audio timestamp, and performs stop or drain the PCM
substream according to configured threshold.</p>
<p>The function is intended to use for the case that PCM driver operates audio data frames under
acquired lock of PCM substream; e.g. in callback of any operation of <code class="xref c c-type docutils literal notranslate"><span class="pre">snd_pcm_ops</span></code> in process
context. In any interrupt context, it’s preferrable to use <code class="docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code> instead
since lock of PCM substream should be acquired in advance.</p>
<p>Developer should pay enough attention that some callbacks in <code class="xref c c-type docutils literal notranslate"><span class="pre">snd_pcm_ops</span></code> are done by the call of
function:</p>
<ul class="simple">
<li><p>.pointer - to retrieve current position of audio data transmission by frame count or XRUN state.</p></li>
<li><p>.trigger - with SNDRV_PCM_TRIGGER_STOP at XRUN or DRAINING state.</p></li>
<li><p>.get_time_info - to retrieve audio time stamp if needed.</p></li>
</ul>
<p>Even if more than one periods have elapsed since the last call, you have to call this only once.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_period_elapsed">
void <code class="sig-name descname">snd_pcm_period_elapsed</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_period_elapsed" title="Permalink to this definition">¶</a></dt>
<dd><p>update the status of runtime for the next period by acquiring lock of PCM substream.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the instance of PCM substream.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is mostly similar to <code class="docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed_under_stream_lock()</span></code> except for
acquiring lock of PCM substream voluntarily.</p>
<p>It’s typically called by any type of IRQ handler when hardware IRQ occurs to notify event that
the batch of audio data frames as the same size as the period of buffer is already processed in
audio data transmission.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_add_chmap_ctls">
int <code class="sig-name descname">snd_pcm_add_chmap_ctls</code><span class="sig-paren">(</span>struct snd_pcm<em> *pcm</em>, int<em> stream</em>, const struct snd_pcm_chmap_elem<em> *chmap</em>, int<em> max_channels</em>, unsigned long<em> private_value</em>, struct snd_pcm_chmap<em> **info_ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_add_chmap_ctls" title="Permalink to this definition">¶</a></dt>
<dd><p>create channel-mapping control elements</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*pcm</span></code></dt><dd><p>the assigned PCM instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt><dd><p>stream direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_chmap_elem</span> <span class="pre">*chmap</span></code></dt><dd><p>channel map elements (for query)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max_channels</span></code></dt><dd><p>the max number of channels for the stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">private_value</span></code></dt><dd><p>the value passed to each kcontrol’s private_value field</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_chmap</span> <span class="pre">**info_ret</span></code></dt><dd><p>store struct snd_pcm_chmap instance if non-NULL</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create channel-mapping control elements assigned to the given PCM stream(s).</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error value.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_stream_lock">
void <code class="sig-name descname">snd_pcm_stream_lock</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the PCM stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks the PCM stream’s spinlock or mutex depending on the nonatomic
flag of the given substream.  This also takes the global link rw lock
(or rw sem), too, for avoiding the race with linked streams.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_stream_unlock">
void <code class="sig-name descname">snd_pcm_stream_unlock</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the PCM stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This unlocks the PCM stream that has been locked via <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_stream_lock_irq">
void <code class="sig-name descname">snd_pcm_stream_lock_irq</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_lock_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the PCM stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks the PCM stream like <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a> and disables the local
IRQ (only when nonatomic is false).  In nonatomic case, this is identical
as <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_stream_unlock_irq">
void <code class="sig-name descname">snd_pcm_stream_unlock_irq</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_unlock_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the PCM stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a counter-part of <a class="reference internal" href="#c.snd_pcm_stream_lock_irq" title="snd_pcm_stream_lock_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock_irq()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_stream_unlock_irqrestore">
void <code class="sig-name descname">snd_pcm_stream_unlock_irqrestore</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, unsigned long<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_unlock_irqrestore" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the PCM stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt><dd><p>irq flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a counter-part of <a class="reference internal" href="#c.snd_pcm_stream_lock_irqsave" title="snd_pcm_stream_lock_irqsave"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock_irqsave()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_params_choose">
int <code class="sig-name descname">snd_pcm_hw_params_choose</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *pcm</em>, struct snd_pcm_hw_params<em> *params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_params_choose" title="Permalink to this definition">¶</a></dt>
<dd><p>choose a configuration defined by <strong>params</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*pcm</span></code></dt><dd><p>PCM instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*params</span></code></dt><dd><p>the hw_params instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Choose one configuration from configuration space defined by <strong>params</strong>.
The configuration chosen is that obtained fixing in this order:
first access, first format, first subformat, min channels,
min rate, min period time, max buffer size, min tick time</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_start">
int <code class="sig-name descname">snd_pcm_start</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start all linked streams</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the PCM substream instance</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.
The stream lock must be acquired before calling this function.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_stop">
int <code class="sig-name descname">snd_pcm_stop</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, snd_pcm_state_t<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>try to stop all running streams in the substream group</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the PCM substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_state_t</span> <span class="pre">state</span></code></dt><dd><p>PCM state after stopping the stream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The state of each stream is then changed to the given state unconditionally.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_drain_done">
int <code class="sig-name descname">snd_pcm_drain_done</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_drain_done" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the DMA only when the given stream is playback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After stopping, the state is changed to SETUP.
Unlike <a class="reference internal" href="#c.snd_pcm_stop" title="snd_pcm_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stop()</span></code></a>, this affects only the given stream.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_stop_xrun">
int <code class="sig-name descname">snd_pcm_stop_xrun</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stop_xrun" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the running streams as XRUN</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the PCM substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This stops the given running substream (and all linked substreams) as XRUN.
Unlike <a class="reference internal" href="#c.snd_pcm_stop" title="snd_pcm_stop"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stop()</span></code></a>, this function takes the substream lock by itself.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_suspend_all">
int <code class="sig-name descname">snd_pcm_suspend_all</code><span class="sig-paren">(</span>struct snd_pcm<em> *pcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_suspend_all" title="Permalink to this definition">¶</a></dt>
<dd><p>trigger SUSPEND to all substreams in the given pcm</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*pcm</span></code></dt><dd><p>the PCM instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this call, all streams are changed to SUSPENDED state.</p>
<p><strong>Return</strong></p>
<p>Zero if successful (or <strong>pcm</strong> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>), or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_prepare">
int <code class="sig-name descname">snd_pcm_prepare</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, struct file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare the PCM substream to be triggerable</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the PCM substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*file</span></code></dt><dd><p>file to refer f_flags</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_kernel_ioctl">
int <code class="sig-name descname">snd_pcm_kernel_ioctl</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, unsigned int<em> cmd</em>, void<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_kernel_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute PCM ioctl in the kernel-space</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>IOCTL cmd</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>IOCTL argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function is provided primarily for OSS layer and USB gadget drivers,
and it allows only the limited set of ioctls (hw_params, sw_params,
prepare, start, drain, drop, forward).</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_default_mmap">
int <code class="sig-name descname">snd_pcm_lib_default_mmap</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, struct vm_area_struct<em> *area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_default_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Default PCM data mmap function</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*area</span></code></dt><dd><p>VMA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default mmap handler for PCM data.  When mmap pcm_ops is NULL,
this function is invoked implicitly.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_mmap_iomem">
int <code class="sig-name descname">snd_pcm_lib_mmap_iomem</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, struct vm_area_struct<em> *area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_mmap_iomem" title="Permalink to this definition">¶</a></dt>
<dd><p>Default PCM data mmap function for I/O mem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*area</span></code></dt><dd><p>VMA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When your hardware uses the iomapped pages as the hardware buffer and
wants to mmap it, pass this function as mmap pcm_ops.  Note that this
is supposed to work only on limited architectures.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_stream_linked">
int <code class="sig-name descname">snd_pcm_stream_linked</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_linked" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the substream is linked with others</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>substream to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the given substream is being linked with others</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_stream_lock_irqsave">
<code class="sig-name descname">snd_pcm_stream_lock_irqsave</code><span class="sig-paren">(</span><em>substream</em>, <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_lock_irqsave" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the PCM stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>irq flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks the PCM stream like <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a> but with the local
IRQ (only when nonatomic is false).  In nonatomic case, this is identical
as <a class="reference internal" href="#c.snd_pcm_stream_lock" title="snd_pcm_stream_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_stream_lock_irqsave_nested">
<code class="sig-name descname">snd_pcm_stream_lock_irqsave_nested</code><span class="sig-paren">(</span><em>substream</em>, <em>flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_lock_irqsave_nested" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-nested PCM stream locking</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>irq flags</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks the PCM stream like <a class="reference internal" href="#c.snd_pcm_stream_lock_irqsave" title="snd_pcm_stream_lock_irqsave"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_stream_lock_irqsave()</span></code></a> but with
the single-depth lockdep subclass.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_group_for_each_entry">
<code class="sig-name descname">snd_pcm_group_for_each_entry</code><span class="sig-paren">(</span><em>s</em>, <em>substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_group_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over the linked substreams</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code></dt><dd><p>the iterator</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">substream</span></code></dt><dd><p>the substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the all linked substreams to the given <strong>substream</strong>.
When <strong>substream</strong> isn’t linked with any others, this gives returns <strong>substream</strong>
itself once.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_running">
int <code class="sig-name descname">snd_pcm_running</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_running" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the substream is in a running state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>substream to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the given substream is in the state RUNNING, or in the
state DRAINING for playback.</p>
</div>
<dl class="function">
<dt id="c.__snd_pcm_set_state">
void <code class="sig-name descname">__snd_pcm_set_state</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, snd_pcm_state_t<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__snd_pcm_set_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the current PCM state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_state_t</span> <span class="pre">state</span></code></dt><dd><p>the current state to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call within the stream lock</p>
</div>
<dl class="function">
<dt id="c.bytes_to_samples">
ssize_t <code class="sig-name descname">bytes_to_samples</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bytes_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from bytes to samples</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">size</span></code></dt><dd><p>size in bytes</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the size in samples</p>
</div>
<dl class="function">
<dt id="c.bytes_to_frames">
snd_pcm_sframes_t <code class="sig-name descname">bytes_to_frames</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bytes_to_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from bytes to frames</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">size</span></code></dt><dd><p>size in bytes</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the size in frames</p>
</div>
<dl class="function">
<dt id="c.samples_to_bytes">
ssize_t <code class="sig-name descname">samples_to_bytes</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, ssize_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.samples_to_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from samples to bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">size</span></code></dt><dd><p>size in samples</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the byte size</p>
</div>
<dl class="function">
<dt id="c.frames_to_bytes">
ssize_t <code class="sig-name descname">frames_to_bytes</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, snd_pcm_sframes_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.frames_to_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit conversion of the size from frames to bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_sframes_t</span> <span class="pre">size</span></code></dt><dd><p>size in frames</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the byte size</p>
</div>
<dl class="function">
<dt id="c.frame_aligned">
int <code class="sig-name descname">frame_aligned</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, ssize_t<em> bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.frame_aligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the byte size is aligned to frames</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ssize_t</span> <span class="pre">bytes</span></code></dt><dd><p>size in bytes</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if aligned, or false if not</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_buffer_bytes">
size_t <code class="sig-name descname">snd_pcm_lib_buffer_bytes</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_buffer_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the buffer size of the current PCM in bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>buffer byte size</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_period_bytes">
size_t <code class="sig-name descname">snd_pcm_lib_period_bytes</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_period_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the period size of the current PCM in bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>period byte size</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_playback_avail">
snd_pcm_uframes_t <code class="sig-name descname">snd_pcm_playback_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the available (writable) space for playback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Result is between 0 … (boundary - 1)</p>
<p><strong>Return</strong></p>
<p>available frame size</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_capture_avail">
snd_pcm_uframes_t <code class="sig-name descname">snd_pcm_capture_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the available (readable) space for capture</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Result is between 0 … (boundary - 1)</p>
<p><strong>Return</strong></p>
<p>available frame size</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_playback_hw_avail">
snd_pcm_sframes_t <code class="sig-name descname">snd_pcm_playback_hw_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_hw_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the queued space for playback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>available frame size</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_capture_hw_avail">
snd_pcm_sframes_t <code class="sig-name descname">snd_pcm_capture_hw_avail</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_hw_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the free space for capture</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>available frame size</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_playback_ready">
int <code class="sig-name descname">snd_pcm_playback_ready</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the playback buffer is available</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether enough free space is available on the playback buffer.</p>
<p><strong>Return</strong></p>
<p>Non-zero if available, or zero if not.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_capture_ready">
int <code class="sig-name descname">snd_pcm_capture_ready</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the capture buffer is available</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether enough capture data is available on the capture buffer.</p>
<p><strong>Return</strong></p>
<p>Non-zero if available, or zero if not.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_playback_data">
int <code class="sig-name descname">snd_pcm_playback_data</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_data" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether any data exists on the playback buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether any data exists on the playback buffer.</p>
<p><strong>Return</strong></p>
<p>Non-zero if any data exists, or zero if not. If stop_threshold
is bigger or equal to boundary, then this function returns always non-zero.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_playback_empty">
int <code class="sig-name descname">snd_pcm_playback_empty</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_playback_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the playback buffer is empty</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the playback buffer is empty.</p>
<p><strong>Return</strong></p>
<p>Non-zero if empty, or zero if not.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_capture_empty">
int <code class="sig-name descname">snd_pcm_capture_empty</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_capture_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the capture buffer is empty</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the capture buffer is empty.</p>
<p><strong>Return</strong></p>
<p>Non-zero if empty, or zero if not.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_trigger_done">
void <code class="sig-name descname">snd_pcm_trigger_done</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, struct snd_pcm_substream<em> *master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_trigger_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark the master substream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*master</span></code></dt><dd><p>the linked master substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>When multiple substreams of the same card are linked and the hardware
supports the single-shot operation, the driver calls this in the loop
in <a class="reference internal" href="#c.snd_pcm_group_for_each_entry" title="snd_pcm_group_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_group_for_each_entry()</span></code></a> for marking the substream as “done”.
Then most of trigger operations are performed only to the given master
substream.</p>
<p>The trigger_master mark is cleared at timestamp updates at the end
of trigger operations.</p>
</div>
<dl class="function">
<dt id="c.params_channels">
unsigned int <code class="sig-name descname">params_channels</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of channels from the hw params</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of channels</p>
</div>
<dl class="function">
<dt id="c.params_rate">
unsigned int <code class="sig-name descname">params_rate</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the sample rate from the hw params</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the sample rate</p>
</div>
<dl class="function">
<dt id="c.params_period_size">
unsigned int <code class="sig-name descname">params_period_size</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_period_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the period size (in frames) from the hw params</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the period size in frames</p>
</div>
<dl class="function">
<dt id="c.params_periods">
unsigned int <code class="sig-name descname">params_periods</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_periods" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of periods from the hw params</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of periods</p>
</div>
<dl class="function">
<dt id="c.params_buffer_size">
unsigned int <code class="sig-name descname">params_buffer_size</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_buffer_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the buffer size (in frames) from the hw params</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the buffer size in frames</p>
</div>
<dl class="function">
<dt id="c.params_buffer_bytes">
unsigned int <code class="sig-name descname">params_buffer_bytes</code><span class="sig-paren">(</span>const struct snd_pcm_hw_params<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.params_buffer_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the buffer size (in bytes) from the hw params</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*p</span></code></dt><dd><p>hw params</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the buffer size in bytes</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_constraint_single">
int <code class="sig-name descname">snd_pcm_hw_constraint_single</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, snd_pcm_hw_param_t<em> var</em>, unsigned int<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_constraint_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Constrain parameter to a single value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_hw_param_t</span> <span class="pre">var</span></code></dt><dd><p>The hw_params variable to constrain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt><dd><p>The value to constrain to</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Positive if the value is changed, zero if it’s not changed, or a
negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_format_cpu_endian">
int <code class="sig-name descname">snd_pcm_format_cpu_endian</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_cpu_endian" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is CPU-endian</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the format to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is CPU-endian, 0 if
opposite, or a negative error code if endian not specified.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_set_runtime_buffer">
void <code class="sig-name descname">snd_pcm_set_runtime_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, struct snd_dma_buffer<em> *bufp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_runtime_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the PCM runtime buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*bufp</span></code></dt><dd><p>the buffer information, NULL to clear</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the buffer information to runtime-&gt;dma_buffer when <strong>bufp</strong> is non-NULL.
Otherwise it clears the current buffer information.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_gettime">
void <code class="sig-name descname">snd_pcm_gettime</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em>, struct timespec64<em> *tv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_gettime" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the timespec64 depending on the timestamp mode</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>PCM runtime instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*tv</span></code></dt><dd><p>timespec64 to fill</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_pcm_set_fixed_buffer">
int <code class="sig-name descname">snd_pcm_set_fixed_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, int<em> type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *data</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_fixed_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Preallocate and set up the fixed size PCM buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>DMA type (SNDRV_DMA_TYPE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*data</span></code></dt><dd><p>DMA type dependent data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested pre-allocation size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a variant of <a class="reference internal" href="#c.snd_pcm_set_managed_buffer" title="snd_pcm_set_managed_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_managed_buffer()</span></code></a>, but this pre-allocates
only the given sized buffer and doesn’t allow re-allocation nor dynamic
allocation of a larger buffer unlike the standard one.
The function may return -ENOMEM error, hence the caller must check it.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_set_fixed_buffer_all">
int <code class="sig-name descname">snd_pcm_set_fixed_buffer_all</code><span class="sig-paren">(</span>struct snd_pcm<em> *pcm</em>, int<em> type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *data</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_fixed_buffer_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Preallocate and set up the fixed size PCM buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*pcm</span></code></dt><dd><p>the pcm instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>DMA type (SNDRV_DMA_TYPE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*data</span></code></dt><dd><p>DMA type dependent data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested pre-allocation size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the set up of the fixed buffer via <a class="reference internal" href="#c.snd_pcm_set_fixed_buffer" title="snd_pcm_set_fixed_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_fixed_buffer()</span></code></a> for
all substream.  If any of allocation fails, it returns -ENOMEM, hence the
caller must check the return value.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_alloc_vmalloc_buffer">
int <code class="sig-name descname">snd_pcm_lib_alloc_vmalloc_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtual DMA buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the substream to allocate the buffer to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested buffer size, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates the PCM substream buffer using <a class="reference internal" href="../../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>, i.e., the memory is
contiguous in kernel virtual space, but not in physical memory.  Use this
if the buffer is accessed by kernel code but not by device DMA.</p>
<p><strong>Return</strong></p>
<p>1 if the buffer was changed, 0 if not changed, or a negative error
code.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_alloc_vmalloc_32_buffer">
int <code class="sig-name descname">snd_pcm_lib_alloc_vmalloc_32_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_alloc_vmalloc_32_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate 32-bit-addressable buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the substream to allocate the buffer to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested buffer size, in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works like <a class="reference internal" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="snd_pcm_lib_alloc_vmalloc_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_alloc_vmalloc_buffer()</span></code></a>, but uses
<a class="reference internal" href="../../core-api/mm-api.html#c.vmalloc_32" title="vmalloc_32"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc_32()</span></code></a>, i.e., the pages are allocated from 32-bit-addressable memory.</p>
<p><strong>Return</strong></p>
<p>1 if the buffer was changed, 0 if not changed, or a negative error
code.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_sgbuf_get_addr">
dma_addr_t <code class="sig-name descname">snd_pcm_sgbuf_get_addr</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, unsigned int<em> ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_sgbuf_get_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the DMA address at the corresponding offset</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ofs</span></code></dt><dd><p>byte offset</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>DMA address</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_sgbuf_get_chunk_size">
unsigned int <code class="sig-name descname">snd_pcm_sgbuf_get_chunk_size</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, unsigned int<em> ofs</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_sgbuf_get_chunk_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max size that fits within the contig. page from the given size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ofs</span></code></dt><dd><p>byte offset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>byte size to examine</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>chunk size</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_mmap_data_open">
void <code class="sig-name descname">snd_pcm_mmap_data_open</code><span class="sig-paren">(</span>struct vm_area_struct<em> *area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_mmap_data_open" title="Permalink to this definition">¶</a></dt>
<dd><p>increase the mmap counter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*area</span></code></dt><dd><p>VMA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>PCM mmap callback should handle this counter properly</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_mmap_data_close">
void <code class="sig-name descname">snd_pcm_mmap_data_close</code><span class="sig-paren">(</span>struct vm_area_struct<em> *area</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_mmap_data_close" title="Permalink to this definition">¶</a></dt>
<dd><p>decrease the mmap counter</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*area</span></code></dt><dd><p>VMA</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>PCM mmap callback should handle this counter properly</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_limit_isa_dma_size">
void <code class="sig-name descname">snd_pcm_limit_isa_dma_size</code><span class="sig-paren">(</span>int<em> dma</em>, size_t<em> *max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_limit_isa_dma_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the max size fitting with ISA DMA transfer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dma</span></code></dt><dd><p>DMA number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*max</span></code></dt><dd><p>pointer to store the max size</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_pcm_direction_name">
const char * <code class="sig-name descname">snd_pcm_direction_name</code><span class="sig-paren">(</span>int<em> direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_direction_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a string naming the direction of a stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">direction</span></code></dt><dd><p>Stream’s direction, one of SNDRV_PCM_STREAM_XXX</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a string naming the direction of the stream.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_stream_str">
const char * <code class="sig-name descname">snd_pcm_stream_str</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_stream_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a string naming the direction of a stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>A string naming the direction of the stream.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_chmap_substream">
struct snd_pcm_substream * <code class="sig-name descname">snd_pcm_chmap_substream</code><span class="sig-paren">(</span>struct snd_pcm_chmap<em> *info</em>, unsigned int<em> idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_chmap_substream" title="Permalink to this definition">¶</a></dt>
<dd><p>get the PCM substream assigned to the given chmap info</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_chmap</span> <span class="pre">*info</span></code></dt><dd><p>chmap information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">idx</span></code></dt><dd><p>the substream number index</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the matched PCM substream, or NULL if not found</p>
</div>
<dl class="function">
<dt id="c.pcm_format_to_bits">
u64 <code class="sig-name descname">pcm_format_to_bits</code><span class="sig-paren">(</span>snd_pcm_format_t<em> pcm_format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcm_format_to_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Strong-typed conversion of pcm_format to bitwise</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">pcm_format</span></code></dt><dd><p>PCM format</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>64bit mask corresponding to the given PCM format</p>
</div>
<dl class="function">
<dt id="c.pcm_for_each_format">
<code class="sig-name descname">pcm_for_each_format</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcm_for_each_format" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to iterate for each format type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code></dt><dd><p>the iterator variable in snd_pcm_format_t type</p>
</dd>
</dl>
</div>
</section>
<section id="pcm-format-helpers">
<h3>PCM Format Helpers<a class="headerlink" href="#pcm-format-helpers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_pcm_format_signed">
int <code class="sig-name descname">snd_pcm_format_signed</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_signed" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is signed linear</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the format to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is signed linear, 0 if unsigned
linear, and a negative error code for non-linear formats.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_format_unsigned">
int <code class="sig-name descname">snd_pcm_format_unsigned</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_unsigned" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is unsigned linear</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the format to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is unsigned linear, 0 if signed
linear, and a negative error code for non-linear formats.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_format_linear">
int <code class="sig-name descname">snd_pcm_format_linear</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is linear</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the format to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is linear, 0 if not.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_format_little_endian">
int <code class="sig-name descname">snd_pcm_format_little_endian</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_little_endian" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is little-endian</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the format to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is little-endian, 0 if
big-endian, or a negative error code if endian not specified.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_format_big_endian">
int <code class="sig-name descname">snd_pcm_format_big_endian</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_big_endian" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the PCM format is big-endian</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the format to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the given PCM format is big-endian, 0 if
little-endian, or a negative error code if endian not specified.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_format_width">
int <code class="sig-name descname">snd_pcm_format_width</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_width" title="Permalink to this definition">¶</a></dt>
<dd><p>return the bit-width of the format</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the format to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The bit-width of the format, or a negative error code
if unknown format.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_format_physical_width">
int <code class="sig-name descname">snd_pcm_format_physical_width</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_physical_width" title="Permalink to this definition">¶</a></dt>
<dd><p>return the physical bit-width of the format</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the format to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The physical bit-width of the format, or a negative error code
if unknown format.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_format_size">
ssize_t <code class="sig-name descname">snd_pcm_format_size</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em>, size_t<em> samples</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_size" title="Permalink to this definition">¶</a></dt>
<dd><p>return the byte size of samples on the given format</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the format to check</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">samples</span></code></dt><dd><p>sampling rate</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The byte size of the given samples for the format, or a
negative error code if unknown format.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_format_silence_64">
const unsigned char * <code class="sig-name descname">snd_pcm_format_silence_64</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_silence_64" title="Permalink to this definition">¶</a></dt>
<dd><p>return the silent data in 8 bytes array</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the format to check</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The format pattern to fill or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if error.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_format_set_silence">
int <code class="sig-name descname">snd_pcm_format_set_silence</code><span class="sig-paren">(</span>snd_pcm_format_t<em> format</em>, void<em> *data</em>, unsigned int<em> samples</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_format_set_silence" title="Permalink to this definition">¶</a></dt>
<dd><p>set the silence data on the buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_format_t</span> <span class="pre">format</span></code></dt><dd><p>the PCM format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>the buffer pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">samples</span></code></dt><dd><p>the number of samples to set silence</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the silence data on the buffer for the given samples.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_hw_limit_rates">
int <code class="sig-name descname">snd_pcm_hw_limit_rates</code><span class="sig-paren">(</span>struct snd_pcm_hardware<em> *hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_hw_limit_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>determine rate_min/rate_max fields</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hardware</span> <span class="pre">*hw</span></code></dt><dd><p>the pcm hw instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determines the rate_min and rate_max fields from the rates bits of
the given hw.</p>
<p><strong>Return</strong></p>
<p>Zero if successful.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_rate_to_rate_bit">
unsigned int <code class="sig-name descname">snd_pcm_rate_to_rate_bit</code><span class="sig-paren">(</span>unsigned int<em> rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_rate_to_rate_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>converts sample rate to SNDRV_PCM_RATE_xxx bit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate</span></code></dt><dd><p>the sample rate to convert</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The SNDRV_PCM_RATE_xxx flag that corresponds to the given rate, or
SNDRV_PCM_RATE_KNOT for an unknown rate.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_rate_bit_to_rate">
unsigned int <code class="sig-name descname">snd_pcm_rate_bit_to_rate</code><span class="sig-paren">(</span>unsigned int<em> rate_bit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_rate_bit_to_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>converts SNDRV_PCM_RATE_xxx bit to sample rate</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate_bit</span></code></dt><dd><p>the rate bit to convert</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The sample rate that corresponds to the given SNDRV_PCM_RATE_xxx flag
or 0 for an unknown rate bit.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_rate_mask_intersect">
unsigned int <code class="sig-name descname">snd_pcm_rate_mask_intersect</code><span class="sig-paren">(</span>unsigned int<em> rates_a</em>, unsigned int<em> rates_b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_rate_mask_intersect" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the intersection between two rate masks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rates_a</span></code></dt><dd><p>The first rate mask</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rates_b</span></code></dt><dd><p>The second rate mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function computes the rates that are supported by both rate masks passed
to the function. It will take care of the special handling of
SNDRV_PCM_RATE_CONTINUOUS and SNDRV_PCM_RATE_KNOT.</p>
<p><strong>Return</strong></p>
<p>A rate mask containing the rates that are supported by both rates_a
and rates_b.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_rate_range_to_bits">
unsigned int <code class="sig-name descname">snd_pcm_rate_range_to_bits</code><span class="sig-paren">(</span>unsigned int<em> rate_min</em>, unsigned int<em> rate_max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_rate_range_to_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>converts rate range to SNDRV_PCM_RATE_xxx bit</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate_min</span></code></dt><dd><p>the minimum sample rate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate_max</span></code></dt><dd><p>the maximum sample rate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function has an implicit assumption: the rates in the given range have
only the pre-defined rates like 44100 or 16000.</p>
<p><strong>Return</strong></p>
<p>The SNDRV_PCM_RATE_xxx flag that corresponds to the given rate range,
or SNDRV_PCM_RATE_KNOT for an unknown range.</p>
</div>
</section>
<section id="pcm-memory-management">
<h3>PCM Memory Management<a class="headerlink" href="#pcm-memory-management" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_pcm_lib_preallocate_free">
void <code class="sig-name descname">snd_pcm_lib_preallocate_free</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_preallocate_free" title="Permalink to this definition">¶</a></dt>
<dd><p>release the preallocated buffer of the specified substream.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the pre-allocated buffer of the given substream.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_preallocate_free_for_all">
void <code class="sig-name descname">snd_pcm_lib_preallocate_free_for_all</code><span class="sig-paren">(</span>struct snd_pcm<em> *pcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_preallocate_free_for_all" title="Permalink to this definition">¶</a></dt>
<dd><p>release all pre-allocated buffers on the pcm</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*pcm</span></code></dt><dd><p>the pcm instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all the pre-allocated buffers on the given pcm.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_preallocate_pages">
void <code class="sig-name descname">snd_pcm_lib_preallocate_pages</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, int<em> type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *data</em>, size_t<em> size</em>, size_t<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_preallocate_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>pre-allocation for the given DMA type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>DMA type (SNDRV_DMA_TYPE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*data</span></code></dt><dd><p>DMA type dependent data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested pre-allocation size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt><dd><p>the max. allowed pre-allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation for the given DMA buffer type.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_preallocate_pages_for_all">
void <code class="sig-name descname">snd_pcm_lib_preallocate_pages_for_all</code><span class="sig-paren">(</span>struct snd_pcm<em> *pcm</em>, int<em> type</em>, void<em> *data</em>, size_t<em> size</em>, size_t<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_preallocate_pages_for_all" title="Permalink to this definition">¶</a></dt>
<dd><p>pre-allocation for continuous memory type (all substreams)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*pcm</span></code></dt><dd><p>the pcm instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>DMA type (SNDRV_DMA_TYPE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>DMA type dependent data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested pre-allocation size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt><dd><p>the max. allowed pre-allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation to all substreams of the given pcm for the
specified DMA type.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_set_managed_buffer">
int <code class="sig-name descname">snd_pcm_set_managed_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, int<em> type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *data</em>, size_t<em> size</em>, size_t<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_managed_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>set up buffer management for a substream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>DMA type (SNDRV_DMA_TYPE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*data</span></code></dt><dd><p>DMA type dependent data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested pre-allocation size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt><dd><p>the max. allowed pre-allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation for the given DMA buffer type, and set the managed
buffer allocation mode to the given substream.
In this mode, PCM core will allocate a buffer automatically before PCM
hw_params ops call, and release the buffer after PCM hw_free ops call
as well, so that the driver doesn’t need to invoke the allocation and
the release explicitly in its callback.
When a buffer is actually allocated before the PCM hw_params call, it
turns on the runtime buffer_changed flag for drivers changing their h/w
parameters accordingly.</p>
<p>When <strong>size</strong> is non-zero and <strong>max</strong> is zero, this tries to allocate for only
the exact buffer size without fallback, and may return -ENOMEM.
Otherwise, the function tries to allocate smaller chunks if the allocation
fails.  This is the behavior of <a class="reference internal" href="#c.snd_pcm_set_fixed_buffer" title="snd_pcm_set_fixed_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_fixed_buffer()</span></code></a>.</p>
<p>When both <strong>size</strong> and <strong>max</strong> are zero, the function only sets up the buffer
for later dynamic allocations. It’s used typically for buffers with
SNDRV_DMA_TYPE_VMALLOC type.</p>
<p>Upon successful buffer allocation and setup, the function returns 0.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_set_managed_buffer_all">
int <code class="sig-name descname">snd_pcm_set_managed_buffer_all</code><span class="sig-paren">(</span>struct snd_pcm<em> *pcm</em>, int<em> type</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *data</em>, size_t<em> size</em>, size_t<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_set_managed_buffer_all" title="Permalink to this definition">¶</a></dt>
<dd><p>set up buffer management for all substreams for all substreams</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm</span> <span class="pre">*pcm</span></code></dt><dd><p>the pcm instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>DMA type (SNDRV_DMA_TYPE_*)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*data</span></code></dt><dd><p>DMA type dependent data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested pre-allocation size in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">max</span></code></dt><dd><p>the max. allowed pre-allocation size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do pre-allocation to all substreams of the given pcm for the specified DMA
type and size, and set the managed_buffer_alloc flag to each substream.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_malloc_pages">
int <code class="sig-name descname">snd_pcm_lib_malloc_pages</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_malloc_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate the DMA buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the substream to allocate the DMA buffer to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>the requested buffer size in bytes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates the DMA buffer on the BUS type given earlier to
snd_pcm_lib_preallocate_xxx_pages().</p>
<p><strong>Return</strong></p>
<p>1 if the buffer is changed, 0 if not changed, or a negative
code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_free_pages">
int <code class="sig-name descname">snd_pcm_lib_free_pages</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_free_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>release the allocated DMA buffer.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the substream to release the DMA buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the DMA buffer allocated via <a class="reference internal" href="#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_free_vmalloc_buffer">
int <code class="sig-name descname">snd_pcm_lib_free_vmalloc_buffer</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_free_vmalloc_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>free vmalloc buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the substream with a buffer allocated by
<a class="reference internal" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="snd_pcm_lib_alloc_vmalloc_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_alloc_vmalloc_buffer()</span></code></a></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_lib_get_vmalloc_page">
struct page * <code class="sig-name descname">snd_pcm_lib_get_vmalloc_page</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, unsigned long<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_lib_get_vmalloc_page" title="Permalink to this definition">¶</a></dt>
<dd><p>map vmalloc buffer offset to page struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the substream with a buffer allocated by
<a class="reference internal" href="#c.snd_pcm_lib_alloc_vmalloc_buffer" title="snd_pcm_lib_alloc_vmalloc_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_alloc_vmalloc_buffer()</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">offset</span></code></dt><dd><p>offset in the buffer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is to be used as the page callback in the PCM ops.</p>
<p><strong>Return</strong></p>
<p>The page struct, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</div>
</section>
<section id="pcm-dma-engine-api">
<h3>PCM DMA Engine API<a class="headerlink" href="#pcm-dma-engine-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_hwparams_to_dma_slave_config">
int <code class="sig-name descname">snd_hwparams_to_dma_slave_config</code><span class="sig-paren">(</span>const struct snd_pcm_substream<em> *substream</em>, const struct snd_pcm_hw_params<em> *params</em>, struct dma_slave_config<em> *slave_config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_hwparams_to_dma_slave_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert hw_params to dma_slave_config</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*params</span></code></dt><dd><p>hw_params</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_slave_config</span> <span class="pre">*slave_config</span></code></dt><dd><p>DMA slave config</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used to initialize a dma_slave_config from a substream
and hw_params in a dmaengine based PCM driver implementation.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_set_config_from_dai_data">
void <code class="sig-name descname">snd_dmaengine_pcm_set_config_from_dai_data</code><span class="sig-paren">(</span>const struct snd_pcm_substream<em> *substream</em>, const struct <a class="reference internal" href="#c.snd_dmaengine_dai_dma_data" title="snd_dmaengine_dai_dma_data">snd_dmaengine_dai_dma_data</a><em> *dma_data</em>, struct dma_slave_config<em> *slave_config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_set_config_from_dai_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a dma slave config using DAI DMA data.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_dmaengine_dai_dma_data</span> <span class="pre">*dma_data</span></code></dt><dd><p>DAI DMA data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_slave_config</span> <span class="pre">*slave_config</span></code></dt><dd><p>DMA slave configuration</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the {dst,src}_addr, {dst,src}_maxburst, {dst,src}_addr_width
fields of the DMA slave config from the same fields of the DAI DMA
data struct. The src and dst fields will be initialized depending on the
direction of the substream. If the substream is a playback stream the dst
fields will be initialized, if it is a capture stream the src fields will be
initialized. The {dst,src}_addr_width field will only be initialized if the
SND_DMAENGINE_PCM_DAI_FLAG_PACK flag is set or if the addr_width field of
the DAI DMA data struct is not equal to DMA_SLAVE_BUSWIDTH_UNDEFINED. If
both conditions are met the latter takes priority.</p>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_trigger">
int <code class="sig-name descname">snd_dmaengine_pcm_trigger</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, int<em> cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>dmaengine based PCM trigger implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cmd</span></code></dt><dd><p>Trigger command</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as the PCM trigger callback for dmaengine based PCM
driver implementations.</p>
<p><strong>Return</strong></p>
<p>0 on success, a negative error code otherwise</p>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_pointer_no_residue">
snd_pcm_uframes_t <code class="sig-name descname">snd_dmaengine_pcm_pointer_no_residue</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_pointer_no_residue" title="Permalink to this definition">¶</a></dt>
<dd><p>dmaengine based PCM pointer implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is deprecated and should not be used by new drivers, as its
results may be unreliable.</p>
<p><strong>Return</strong></p>
<p>PCM position in frames</p>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_pointer">
snd_pcm_uframes_t <code class="sig-name descname">snd_dmaengine_pcm_pointer</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>dmaengine based PCM pointer implementation</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as the PCM pointer callback for dmaengine based PCM
driver implementations.</p>
<p><strong>Return</strong></p>
<p>PCM position in frames</p>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_request_channel">
struct dma_chan * <code class="sig-name descname">snd_dmaengine_pcm_request_channel</code><span class="sig-paren">(</span>dma_filter_fn<em> filter_fn</em>, void<em> *filter_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_request_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Request channel for the dmaengine PCM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dma_filter_fn</span> <span class="pre">filter_fn</span></code></dt><dd><p>Filter function used to request the DMA channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*filter_data</span></code></dt><dd><p>Data passed to the DMA filter function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function request a DMA channel for usage with dmaengine PCM.</p>
<p><strong>Return</strong></p>
<p>NULL or the requested DMA channel</p>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_open">
int <code class="sig-name descname">snd_dmaengine_pcm_open</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, struct dma_chan<em> *chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a dmaengine based PCM substream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_chan</span> <span class="pre">*chan</span></code></dt><dd><p>DMA channel to use for data transfers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function should usually be called from the pcm open callback. Note that
this function will use private_data field of the substream’s runtime. So it
is not available to your pcm driver implementation.</p>
<p><strong>Return</strong></p>
<p>0 on success, a negative error code otherwise</p>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_open_request_chan">
int <code class="sig-name descname">snd_dmaengine_pcm_open_request_chan</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, dma_filter_fn<em> filter_fn</em>, void<em> *filter_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_open_request_chan" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a dmaengine based PCM substream and request channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_filter_fn</span> <span class="pre">filter_fn</span></code></dt><dd><p>Filter function used to request the DMA channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*filter_data</span></code></dt><dd><p>Data passed to the DMA filter function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will request a DMA channel using the passed filter function and
data. The function should usually be called from the pcm open callback. Note
that this function will use private_data field of the substream’s runtime. So
it is not available to your pcm driver implementation.</p>
<p><strong>Return</strong></p>
<p>0 on success, a negative error code otherwise</p>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_close">
int <code class="sig-name descname">snd_dmaengine_pcm_close</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a dmaengine based PCM substream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, a negative error code otherwise</p>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_close_release_chan">
int <code class="sig-name descname">snd_dmaengine_pcm_close_release_chan</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_close_release_chan" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a dmaengine based PCM substream and release channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the DMA channel associated with the PCM substream.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_refine_runtime_hwparams">
int <code class="sig-name descname">snd_dmaengine_pcm_refine_runtime_hwparams</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, struct <a class="reference internal" href="#c.snd_dmaengine_dai_dma_data" title="snd_dmaengine_dai_dma_data">snd_dmaengine_dai_dma_data</a><em> *dma_data</em>, struct snd_pcm_hardware<em> *hw</em>, struct dma_chan<em> *chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_refine_runtime_hwparams" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine runtime hw params</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dmaengine_dai_dma_data</span> <span class="pre">*dma_data</span></code></dt><dd><p>DAI DMA data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hardware</span> <span class="pre">*hw</span></code></dt><dd><p>PCM hw params</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_chan</span> <span class="pre">*chan</span></code></dt><dd><p>DMA channel to use for data transfers</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will query DMA capability, then refine the pcm hardware
parameters.</p>
<p><strong>Return</strong></p>
<p>0 on success, a negative error code otherwise</p>
</div>
<dl class="function">
<dt id="c.snd_pcm_substream_to_dma_direction">
enum dma_transfer_direction <code class="sig-name descname">snd_pcm_substream_to_dma_direction</code><span class="sig-paren">(</span>const struct snd_pcm_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_pcm_substream_to_dma_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Get dma_transfer_direction for a PCM substream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>DMA transfer direction</p>
</div>
<dl class="type">
<dt id="c.snd_dmaengine_dai_dma_data">
struct <code class="sig-name descname">snd_dmaengine_dai_dma_data</code><a class="headerlink" href="#c.snd_dmaengine_dai_dma_data" title="Permalink to this definition">¶</a></dt>
<dd><p>DAI DMA configuration data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_dmaengine_dai_dma_data {
    dma_addr_t addr;
    enum dma_slave_buswidth addr_width;
    u32 maxburst;
    void *filter_data;
    const char *chan_name;
    unsigned int fifo_size;
    unsigned int flags;
    void *peripheral_config;
    size_t peripheral_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">addr</span></code></dt><dd><p>Address of the DAI data source or destination register.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">addr_width</span></code></dt><dd><p>Width of the DAI data source or destination register.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">maxburst</span></code></dt><dd><p>Maximum number of words(note: words, as in units of the
src_addr_width member, not bytes) that can be send to or received from the
DAI in one burst.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">filter_data</span></code></dt><dd><p>Custom DMA channel filter data, this will usually be used when
requesting the DMA channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chan_name</span></code></dt><dd><p>Custom channel name to use when requesting DMA channel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fifo_size</span></code></dt><dd><p>FIFO size of the DAI controller in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>PCM_DAI flags, only SND_DMAENGINE_PCM_DAI_FLAG_PACK for now</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peripheral_config</span></code></dt><dd><p>peripheral configuration for programming peripheral
for dmaengine transfer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">peripheral_size</span></code></dt><dd><p>peripheral configuration buffer size</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.snd_dmaengine_pcm_config">
struct <code class="sig-name descname">snd_dmaengine_pcm_config</code><a class="headerlink" href="#c.snd_dmaengine_pcm_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration data for dmaengine based PCM</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_dmaengine_pcm_config {
    int (*prepare_slave_config)(struct snd_pcm_substream *substream,struct snd_pcm_hw_params *params, struct dma_slave_config *slave_config);
    struct dma_chan *(*compat_request_channel)(struct snd_soc_pcm_runtime *rtd, struct snd_pcm_substream *substream);
    int (*process)(struct snd_pcm_substream *substream,int channel, unsigned long hwoff, void *buf, unsigned long bytes);
    dma_filter_fn compat_filter_fn;
    struct device *dma_dev;
    const char *chan_names[SNDRV_PCM_STREAM_LAST + 1];
    const struct snd_pcm_hardware *pcm_hardware;
    unsigned int prealloc_buffer_size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">prepare_slave_config</span></code></dt><dd><p>Callback used to fill in the DMA slave_config for a
PCM substream. Will be called from the PCM drivers hwparams callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_request_channel</span></code></dt><dd><p>Callback to request a DMA channel for platforms
which do not use devicetree.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">process</span></code></dt><dd><p>Callback used to apply processing on samples transferred from/to
user space.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compat_filter_fn</span></code></dt><dd><p>Will be used as the filter function when requesting a
channel for platforms which do not use devicetree. The filter parameter
will be the DAI’s DMA data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_dev</span></code></dt><dd><p>If set, request DMA channel on this device rather than the DAI
device.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chan_names</span></code></dt><dd><p>If set, these custom DMA channel names will be requested at
registration time.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcm_hardware</span></code></dt><dd><p>snd_pcm_hardware struct to be used for the PCM.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">prealloc_buffer_size</span></code></dt><dd><p>Size of the preallocated audio buffer.</p>
</dd>
</dl>
</div>
<p><strong>Note</strong></p>
<p>If both compat_request_channel and compat_filter_fn are set
compat_request_channel will be used to request the channel and
compat_filter_fn will be ignored. Otherwise the channel will be requested
using dma_request_channel with compat_filter_fn as the filter function.</p>
</section>
</section>
<section id="control-mixer-api">
<h2>Control/Mixer API<a class="headerlink" href="#control-mixer-api" title="Permalink to this headline">¶</a></h2>
<section id="general-control-interface">
<h3>General Control Interface<a class="headerlink" href="#general-control-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_ctl_notify">
void <code class="sig-name descname">snd_ctl_notify</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, unsigned int<em> mask</em>, struct snd_ctl_elem_id<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Send notification to user-space for a control change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card to send notification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>the event mask, SNDRV_CTL_EVENT_*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*id</span></code></dt><dd><p>the ctl element id to send notification</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adds an event record with the given id and mask, appends
to the list and wakes up the user-space for notification.  This can be
called in the atomic context.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_notify_one">
void <code class="sig-name descname">snd_ctl_notify_one</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, unsigned int<em> mask</em>, struct snd_kcontrol<em> *kctl</em>, unsigned int<em> ioff</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_notify_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Send notification to user-space for a control change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card to send notification</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>the event mask, SNDRV_CTL_EVENT_*</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kctl</span></code></dt><dd><p>the pointer with the control instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ioff</span></code></dt><dd><p>the additional offset to the control index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function calls <a class="reference internal" href="#c.snd_ctl_notify" title="snd_ctl_notify"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_notify()</span></code></a> and does additional jobs
like LED state changes.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_new">
int <code class="sig-name descname">snd_ctl_new</code><span class="sig-paren">(</span>struct snd_kcontrol<em> **kctl</em>, unsigned int<em> count</em>, unsigned int<em> access</em>, struct snd_ctl_file<em> *file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new control instance with some elements</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">**kctl</span></code></dt><dd><p>the pointer to store new control instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the number of elements in this control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">access</span></code></dt><dd><p>the default access flags for elements in this control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_file</span> <span class="pre">*file</span></code></dt><dd><p>given when locking these elements</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a memory object for a new control instance. The instance has
elements as many as the given number (<strong>count</strong>). Each element has given
access permissions (<strong>access</strong>). Each element is locked when <strong>file</strong> is given.</p>
<p><strong>Return</strong></p>
<p>0 on success, error code on failure</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_new1">
struct snd_kcontrol * <code class="sig-name descname">snd_ctl_new1</code><span class="sig-paren">(</span>const struct snd_kcontrol_new<em> *ncontrol</em>, void<em> *private_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_new1" title="Permalink to this definition">¶</a></dt>
<dd><p>create a control instance from the template</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span> <span class="pre">*ncontrol</span></code></dt><dd><p>the initialization record</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*private_data</span></code></dt><dd><p>the private data to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a new struct snd_kcontrol instance and initialize from the given
template.  When the access field of ncontrol is 0, it’s assumed as
READWRITE access. When the count field is 0, it’s assumes as one.</p>
<p><strong>Return</strong></p>
<p>The pointer of the newly generated instance, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_free_one">
void <code class="sig-name descname">snd_ctl_free_one</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_free_one" title="Permalink to this definition">¶</a></dt>
<dd><p>release the control instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>the control instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the control instance created via <a class="reference internal" href="#c.snd_ctl_new" title="snd_ctl_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new()</span></code></a>
or <a class="reference internal" href="#c.snd_ctl_new1" title="snd_ctl_new1"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new1()</span></code></a>.
Don’t call this after the control was added to the card.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_add">
int <code class="sig-name descname">snd_ctl_add</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, struct snd_kcontrol<em> *kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add the control instance to the card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>the control instance to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the control instance created via <a class="reference internal" href="#c.snd_ctl_new" title="snd_ctl_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new()</span></code></a> or
<a class="reference internal" href="#c.snd_ctl_new1" title="snd_ctl_new1"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new1()</span></code></a> to the given card. Assigns also an unique
numid used for fast search.</p>
<p>It frees automatically the control which cannot be added.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_replace">
int <code class="sig-name descname">snd_ctl_replace</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, struct snd_kcontrol<em> *kcontrol</em>, bool<em> add_on_replace</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace the control instance of the card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>the control instance to replace</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">add_on_replace</span></code></dt><dd><p>add the control if not already added</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replaces the given control.  If the given control does not exist
and the add_on_replace flag is set, the control is added.  If the
control exists, it is destroyed first.</p>
<p>It frees automatically the control which cannot be added or replaced.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_remove">
int <code class="sig-name descname">snd_ctl_remove</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, struct snd_kcontrol<em> *kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the control from the card and release it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>the control instance to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the control from the card and then releases the instance.
You don’t need to call <a class="reference internal" href="#c.snd_ctl_free_one" title="snd_ctl_free_one"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_free_one()</span></code></a>. You must be in
the write lock - down_write(<code class="xref c c-type docutils literal notranslate"><span class="pre">card-&gt;controls_rwsem</span></code>).</p>
<p><strong>Return</strong></p>
<p>0 if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_remove_id">
int <code class="sig-name descname">snd_ctl_remove_id</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, struct snd_ctl_elem_id<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_remove_id" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the control of the given id and release it</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*id</span></code></dt><dd><p>the control id to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given id, removes it from the
card list and releases it.</p>
<p><strong>Return</strong></p>
<p>0 if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_remove_user_ctl">
int <code class="sig-name descname">snd_ctl_remove_user_ctl</code><span class="sig-paren">(</span>struct snd_ctl_file *<em> file</em>, struct snd_ctl_elem_id<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_remove_user_ctl" title="Permalink to this definition">¶</a></dt>
<dd><p>remove and release the unlocked user control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt><dd><p>active control handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*id</span></code></dt><dd><p>the control id to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given id, removes it from the
card list and releases it.</p>
<p><strong>Return</strong></p>
<p>0 if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_activate_id">
int <code class="sig-name descname">snd_ctl_activate_id</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, struct snd_ctl_elem_id<em> *id</em>, int<em> active</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_activate_id" title="Permalink to this definition">¶</a></dt>
<dd><p>activate/inactivate the control of the given id</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*id</span></code></dt><dd><p>the control id to activate/inactivate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">active</span></code></dt><dd><p>non-zero to activate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given id, and activate or
inactivate the control together with notification, if changed.
The given ID data is filled with full information.</p>
<p><strong>Return</strong></p>
<p>0 if unchanged, 1 if changed, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_rename_id">
int <code class="sig-name descname">snd_ctl_rename_id</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, struct snd_ctl_elem_id<em> *src_id</em>, struct snd_ctl_elem_id<em> *dst_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_rename_id" title="Permalink to this definition">¶</a></dt>
<dd><p>replace the id of a control on the card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*src_id</span></code></dt><dd><p>the old id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*dst_id</span></code></dt><dd><p>the new id</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control with the old id from the card, and replaces the
id with the new one.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_rename">
void <code class="sig-name descname">snd_ctl_rename</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, struct snd_kcontrol<em> *kctl</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>rename the control on the card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kctl</span></code></dt><dd><p>the control to rename</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the new name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Renames the specified control on the card to the new name.</p>
<p>Make sure to take the control write lock - down_write(<code class="xref c c-type docutils literal notranslate"><span class="pre">card-&gt;controls_rwsem</span></code>).</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_find_numid">
struct snd_kcontrol * <code class="sig-name descname">snd_ctl_find_numid</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, unsigned int<em> numid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_find_numid" title="Permalink to this definition">¶</a></dt>
<dd><p>find the control instance with the given number-id</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">numid</span></code></dt><dd><p>the number-id to search</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given number-id from the card.</p>
<p>The caller must down card-&gt;controls_rwsem before calling this function
(if the race condition can happen).</p>
<p><strong>Return</strong></p>
<p>The pointer of the instance if found, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_find_id">
struct snd_kcontrol * <code class="sig-name descname">snd_ctl_find_id</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, struct snd_ctl_elem_id<em> *id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_find_id" title="Permalink to this definition">¶</a></dt>
<dd><p>find the control instance with the given id</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_id</span> <span class="pre">*id</span></code></dt><dd><p>the id to search</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the control instance with the given id from the card.</p>
<p>The caller must down card-&gt;controls_rwsem before calling this function
(if the race condition can happen).</p>
<p><strong>Return</strong></p>
<p>The pointer of the instance if found, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if not.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_register_ioctl">
int <code class="sig-name descname">snd_ctl_register_ioctl</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em> fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_register_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>register the device-specific control-ioctls</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt><dd><p>ioctl callback function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>called from each device manager like pcm.c, hwdep.c, etc.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_register_ioctl_compat">
int <code class="sig-name descname">snd_ctl_register_ioctl_compat</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em> fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_register_ioctl_compat" title="Permalink to this definition">¶</a></dt>
<dd><p>register the device-specific 32bit compat control-ioctls</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt><dd><p>ioctl callback function</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_unregister_ioctl">
int <code class="sig-name descname">snd_ctl_unregister_ioctl</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em> fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_unregister_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>de-register the device-specific control-ioctls</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt><dd><p>ioctl callback function to unregister</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_unregister_ioctl_compat">
int <code class="sig-name descname">snd_ctl_unregister_ioctl_compat</code><span class="sig-paren">(</span>snd_kctl_ioctl_func_t<em> fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_unregister_ioctl_compat" title="Permalink to this definition">¶</a></dt>
<dd><p>de-register the device-specific compat 32bit control-ioctls</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">snd_kctl_ioctl_func_t</span> <span class="pre">fcn</span></code></dt><dd><p>ioctl callback function to unregister</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_request_layer">
int <code class="sig-name descname">snd_ctl_request_layer</code><span class="sig-paren">(</span>const char<em> *module_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_request_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>request to use the layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*module_name</span></code></dt><dd><p>Name of the kernel module (NULL == build-in)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero if successful, or an error code when the module cannot be loaded</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_register_layer">
void <code class="sig-name descname">snd_ctl_register_layer</code><span class="sig-paren">(</span>struct snd_ctl_layer_ops<em> *lops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_register_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>register new control layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_layer_ops</span> <span class="pre">*lops</span></code></dt><dd><p>operation structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The new layer can track all control elements and do additional
operations on top (like audio LED handling).</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_disconnect_layer">
void <code class="sig-name descname">snd_ctl_disconnect_layer</code><span class="sig-paren">(</span>struct snd_ctl_layer_ops<em> *lops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_disconnect_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>disconnect control layer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_layer_ops</span> <span class="pre">*lops</span></code></dt><dd><p>operation structure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is expected that the information about tracked cards
is freed before this call (the disconnect callback is
not called here).</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_boolean_mono_info">
int <code class="sig-name descname">snd_ctl_boolean_mono_info</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_info<em> *uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_boolean_mono_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for a standard boolean info callback with a mono channel</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>the kcontrol instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*uinfo</span></code></dt><dd><p>info to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a function that can be used as info callback for a standard
boolean control with a single mono channel.</p>
<p><strong>Return</strong></p>
<p>Zero (always successful)</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_boolean_stereo_info">
int <code class="sig-name descname">snd_ctl_boolean_stereo_info</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_info<em> *uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_boolean_stereo_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for a standard boolean info callback with stereo two channels</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>the kcontrol instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*uinfo</span></code></dt><dd><p>info to store</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a function that can be used as info callback for a standard
boolean control with stereo two channels.</p>
<p><strong>Return</strong></p>
<p>Zero (always successful)</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_enum_info">
int <code class="sig-name descname">snd_ctl_enum_info</code><span class="sig-paren">(</span>struct snd_ctl_elem_info<em> *info</em>, unsigned int<em> channels</em>, unsigned int<em> items</em>, const char *const<em> names[]</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_enum_info" title="Permalink to this definition">¶</a></dt>
<dd><p>fills the info structure for an enumerated control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*info</span></code></dt><dd><p>the structure to be filled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">channels</span></code></dt><dd><p>the number of the control’s channels; often one</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">items</span></code></dt><dd><p>the number of control values; also the size of <strong>names</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">names[]</span></code></dt><dd><p>an array containing the names of all control values</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets all required fields in <strong>info</strong> to their appropriate values.
If the control’s accessibility is not the default (readable and writable),
the caller has to fill <strong>info-&gt;access</strong>.</p>
<p><strong>Return</strong></p>
<p>Zero (always successful)</p>
</div>
</section>
<section id="ac97-codec-api">
<h3>AC97 Codec API<a class="headerlink" href="#ac97-codec-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_ac97_write">
void <code class="sig-name descname">snd_ac97_write</code><span class="sig-paren">(</span>struct snd_ac97<em> *ac97</em>, unsigned short<em> reg</em>, unsigned short<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write a value on the given register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*ac97</span></code></dt><dd><p>the ac97 instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">reg</span></code></dt><dd><p>the register to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">value</span></code></dt><dd><p>the value to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a value on the given register.  This will invoke the write
callback directly after the register check.
This function doesn’t change the register cache unlike
#snd_ca97_write_cache(), so use this only when you don’t want to
reflect the change to the suspend/resume state.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_read">
unsigned short <code class="sig-name descname">snd_ac97_read</code><span class="sig-paren">(</span>struct snd_ac97<em> *ac97</em>, unsigned short<em> reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read a value from the given register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*ac97</span></code></dt><dd><p>the ac97 instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">reg</span></code></dt><dd><p>the register to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a value from the given register.  This will invoke the read
callback directly after the register check.</p>
<p><strong>Return</strong></p>
<p>The read value.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_write_cache">
void <code class="sig-name descname">snd_ac97_write_cache</code><span class="sig-paren">(</span>struct snd_ac97<em> *ac97</em>, unsigned short<em> reg</em>, unsigned short<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_write_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>write a value on the given register and update the cache</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*ac97</span></code></dt><dd><p>the ac97 instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">reg</span></code></dt><dd><p>the register to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">value</span></code></dt><dd><p>the value to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a value on the given register and updates the register
cache.  The cached values are used for the cached-read and the
suspend/resume.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_update">
int <code class="sig-name descname">snd_ac97_update</code><span class="sig-paren">(</span>struct snd_ac97<em> *ac97</em>, unsigned short<em> reg</em>, unsigned short<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update the value on the given register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*ac97</span></code></dt><dd><p>the ac97 instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">reg</span></code></dt><dd><p>the register to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">value</span></code></dt><dd><p>the value to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compares the value with the register cache and updates the value
only when the value is changed.</p>
<p><strong>Return</strong></p>
<p>1 if the value is changed, 0 if no change, or a negative
code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_update_bits">
int <code class="sig-name descname">snd_ac97_update_bits</code><span class="sig-paren">(</span>struct snd_ac97<em> *ac97</em>, unsigned short<em> reg</em>, unsigned short<em> mask</em>, unsigned short<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_update_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>update the bits on the given register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*ac97</span></code></dt><dd><p>the ac97 instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">reg</span></code></dt><dd><p>the register to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">mask</span></code></dt><dd><p>the bit-mask to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">value</span></code></dt><dd><p>the value to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates the masked-bits on the given register only when the value
is changed.</p>
<p><strong>Return</strong></p>
<p>1 if the bits are changed, 0 if no change, or a negative
code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_get_short_name">
const char * <code class="sig-name descname">snd_ac97_get_short_name</code><span class="sig-paren">(</span>struct snd_ac97<em> *ac97</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_get_short_name" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve codec name</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*ac97</span></code></dt><dd><p>the codec instance</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The short identifying name of the codec.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_bus">
int <code class="sig-name descname">snd_ac97_bus</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, int<em> num</em>, const struct snd_ac97_bus_ops<em> *ops</em>, void<em> *private_data</em>, struct <a class="reference internal" href="#c.snd_ac97_bus" title="snd_ac97_bus">snd_ac97_bus</a><em> **rbus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>create an AC97 bus component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>the bus number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_ac97_bus_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the bus callbacks table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*private_data</span></code></dt><dd><p>private data pointer for the new instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97_bus</span> <span class="pre">**rbus</span></code></dt><dd><p>the pointer to store the new AC97 bus instance.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an AC97 bus component.  An <a class="reference internal" href="#c.snd_ac97_bus" title="snd_ac97_bus"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97_bus</span></code></a> instance is newly
allocated and initialized.</p>
<p>The ops table must include valid callbacks (at least read and
write).  The other callbacks, wait and reset, are not mandatory.</p>
<p>The clock is set to 48000.  If another clock is needed, set
<code class="docutils literal notranslate"><span class="pre">(*rbus)-&gt;clock</span></code> manually.</p>
<p>The AC97 bus instance is registered as a low-level device, so you don’t
have to release it manually.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_mixer">
int <code class="sig-name descname">snd_ac97_mixer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_ac97_bus" title="snd_ac97_bus">snd_ac97_bus</a><em> *bus</em>, struct snd_ac97_template<em> *template</em>, struct snd_ac97<em> **rac97</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_mixer" title="Permalink to this definition">¶</a></dt>
<dd><p>create an Codec97 component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the AC97 bus which codec is attached to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97_template</span> <span class="pre">*template</span></code></dt><dd><p>the template of ac97, including index, callbacks and
the private data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">**rac97</span></code></dt><dd><p>the pointer to store the new ac97 instance.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an Codec97 component.  An struct snd_ac97 instance is newly
allocated and initialized from the template.  The codec
is then initialized by the standard procedure.</p>
<p>The template must include the codec number (num) and address (addr),
and the private data (private_data).</p>
<p>The ac97 instance is registered as a low-level device, so you don’t
have to release it manually.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_update_power">
int <code class="sig-name descname">snd_ac97_update_power</code><span class="sig-paren">(</span>struct snd_ac97<em> *ac97</em>, int<em> reg</em>, int<em> powerup</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_update_power" title="Permalink to this definition">¶</a></dt>
<dd><p>update the powerdown register</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*ac97</span></code></dt><dd><p>the codec instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">reg</span></code></dt><dd><p>the rate register, e.g. AC97_PCM_FRONT_DAC_RATE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">powerup</span></code></dt><dd><p>non-zero when power up the part</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the AC97 powerdown register bits of the given part.</p>
<p><strong>Return</strong></p>
<p>Zero.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_suspend">
void <code class="sig-name descname">snd_ac97_suspend</code><span class="sig-paren">(</span>struct snd_ac97<em> *ac97</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>General suspend function for AC97 codec</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*ac97</span></code></dt><dd><p>the ac97 instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Suspends the codec, power down the chip.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_resume">
void <code class="sig-name descname">snd_ac97_resume</code><span class="sig-paren">(</span>struct snd_ac97<em> *ac97</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>General resume function for AC97 codec</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*ac97</span></code></dt><dd><p>the ac97 instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do the standard resume procedure, power up and restoring the
old register values.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_tune_hardware">
int <code class="sig-name descname">snd_ac97_tune_hardware</code><span class="sig-paren">(</span>struct snd_ac97<em> *ac97</em>, const struct ac97_quirk<em> *quirk</em>, const char<em> *override</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_tune_hardware" title="Permalink to this definition">¶</a></dt>
<dd><p>tune up the hardware</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*ac97</span></code></dt><dd><p>the ac97 instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ac97_quirk</span> <span class="pre">*quirk</span></code></dt><dd><p>quirk list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*override</span></code></dt><dd><p>explicit quirk value (overrides the list if non-NULL)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do some workaround for each pci device, such as renaming of the
headphone (true line-out) control as “Master”.
The quirk-list must be terminated with a zero-filled entry.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_set_rate">
int <code class="sig-name descname">snd_ac97_set_rate</code><span class="sig-paren">(</span>struct snd_ac97<em> *ac97</em>, int<em> reg</em>, unsigned int<em> rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_set_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>change the rate of the given input/output.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97</span> <span class="pre">*ac97</span></code></dt><dd><p>the ac97 instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">reg</span></code></dt><dd><p>the register to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate</span></code></dt><dd><p>the sample rate to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Changes the rate of the given input/output on the codec.
If the codec doesn’t support VAR, the rate must be 48000 (except
for SPDIF).</p>
<p>The valid registers are AC97_PCM_MIC_ADC_RATE,
AC97_PCM_FRONT_DAC_RATE, AC97_PCM_LR_ADC_RATE.
AC97_PCM_SURR_DAC_RATE and AC97_PCM_LFE_DAC_RATE are accepted
if the codec supports them.
AC97_SPDIF is accepted as a pseudo register to modify the SPDIF
status bits.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_pcm_assign">
int <code class="sig-name descname">snd_ac97_pcm_assign</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_ac97_bus" title="snd_ac97_bus">snd_ac97_bus</a><em> *bus</em>, unsigned short<em> pcms_count</em>, const struct ac97_pcm<em> *pcms</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_pcm_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>assign AC97 slots to given PCM streams</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ac97_bus</span> <span class="pre">*bus</span></code></dt><dd><p>the ac97 bus instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">pcms_count</span></code></dt><dd><p>count of PCMs to be assigned</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ac97_pcm</span> <span class="pre">*pcms</span></code></dt><dd><p>PCMs to be assigned</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It assigns available AC97 slots for given PCMs. If none or only
some slots are available, pcm-&gt;xxx.slots and pcm-&gt;xxx.rslots[] members
are reduced and might be zero.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_pcm_open">
int <code class="sig-name descname">snd_ac97_pcm_open</code><span class="sig-paren">(</span>struct ac97_pcm<em> *pcm</em>, unsigned int<em> rate</em>, enum ac97_pcm_cfg<em> cfg</em>, unsigned short<em> slots</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_pcm_open" title="Permalink to this definition">¶</a></dt>
<dd><p>opens the given AC97 pcm</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ac97_pcm</span> <span class="pre">*pcm</span></code></dt><dd><p>the ac97 pcm instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rate</span></code></dt><dd><p>rate in Hz, if codec does not support VRA, this value must be 48000Hz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">ac97_pcm_cfg</span> <span class="pre">cfg</span></code></dt><dd><p>output stream characteristics</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">slots</span></code></dt><dd><p>a subset of allocated slots (snd_ac97_pcm_assign) for this pcm</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It locks the specified slots and sets the given rate to AC97 registers.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_pcm_close">
int <code class="sig-name descname">snd_ac97_pcm_close</code><span class="sig-paren">(</span>struct ac97_pcm<em> *pcm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_pcm_close" title="Permalink to this definition">¶</a></dt>
<dd><p>closes the given AC97 pcm</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">ac97_pcm</span> <span class="pre">*pcm</span></code></dt><dd><p>the ac97 pcm instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It frees the locked AC97 slots.</p>
<p><strong>Return</strong></p>
<p>Zero.</p>
</div>
<dl class="function">
<dt id="c.snd_ac97_pcm_double_rate_rules">
int <code class="sig-name descname">snd_ac97_pcm_double_rate_rules</code><span class="sig-paren">(</span>struct snd_pcm_runtime<em> *runtime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ac97_pcm_double_rate_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>set double rate constraints</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_runtime</span> <span class="pre">*runtime</span></code></dt><dd><p>the runtime of the ac97 front playback pcm</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Installs the hardware constraint rules to prevent using double rates and
more than two channels at the same time.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
</section>
<section id="virtual-master-control-api">
<h3>Virtual Master Control API<a class="headerlink" href="#virtual-master-control-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_ctl_make_virtual_master">
struct snd_kcontrol * <code class="sig-name descname">snd_ctl_make_virtual_master</code><span class="sig-paren">(</span>char<em> *name</em>, const unsigned int<em> *tlv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_make_virtual_master" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a virtual master control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>name string of the control element to create</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*tlv</span></code></dt><dd><p>optional TLV int array for dB information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a virtual master control with the given name string.</p>
<p>After creating a vmaster element, you can add the follower controls
via <a class="reference internal" href="#c.snd_ctl_add_follower" title="snd_ctl_add_follower"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_add_follower()</span></code></a> or <a class="reference internal" href="#c.snd_ctl_add_follower_uncached" title="snd_ctl_add_follower_uncached"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_add_follower_uncached()</span></code></a>.</p>
<p>The optional argument <strong>tlv</strong> can be used to specify the TLV information
for dB scale of the master control.  It should be a single element
with #SNDRV_CTL_TLVT_DB_SCALE, #SNDRV_CTL_TLV_DB_MINMAX or
#SNDRV_CTL_TLVT_DB_MINMAX_MUTE type, and should be the max 0dB.</p>
<p><strong>Return</strong></p>
<p>The created control element, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> for errors (ENOMEM).</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_add_vmaster_hook">
int <code class="sig-name descname">snd_ctl_add_vmaster_hook</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, void (<em>*hook</em>)(void *private_data, int), void<em> *private_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_add_vmaster_hook" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a hook to a vmaster control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>vmaster kctl element</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*hook)(void</span> <span class="pre">*private_data,</span> <span class="pre">int)</span></code></dt><dd><p>the hook function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*private_data</span></code></dt><dd><p>the private_data pointer to be saved</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the given hook to the vmaster control element so that it’s called
at each time when the value is changed.</p>
<p><strong>Return</strong></p>
<p>Zero.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_sync_vmaster">
void <code class="sig-name descname">snd_ctl_sync_vmaster</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, bool<em> hook_only</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_sync_vmaster" title="Permalink to this definition">¶</a></dt>
<dd><p>Sync the vmaster followers and hook</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>vmaster kctl element</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">hook_only</span></code></dt><dd><p>sync only the hook</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forcibly call the put callback of each follower and call the hook function
to synchronize with the current value of the given vmaster element.
NOP when NULL is passed to <strong>kcontrol</strong>.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_apply_vmaster_followers">
int <code class="sig-name descname">snd_ctl_apply_vmaster_followers</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kctl</em>, int (<em>*func</em>)(struct snd_kcontrol *vfollower, struct snd_kcontrol *follower, void *arg), void<em> *arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_apply_vmaster_followers" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply function to each vmaster follower</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kctl</span></code></dt><dd><p>vmaster kctl element</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*func)(struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*vfollower,</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*follower,</span> <span class="pre">void</span> <span class="pre">*arg)</span></code></dt><dd><p>function to apply</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>optional function argument</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply the function <strong>func</strong> to each follower kctl of the given vmaster kctl.</p>
<p><strong>Return</strong></p>
<p>0 if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_add_follower">
int <code class="sig-name descname">snd_ctl_add_follower</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *master</em>, struct snd_kcontrol<em> *follower</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_add_follower" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a virtual follower control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*master</span></code></dt><dd><p>vmaster element</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*follower</span></code></dt><dd><p>follower element to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a virtual follower control to the given master element created via
snd_ctl_create_virtual_master() beforehand.</p>
<p>All followers must be the same type (returning the same information
via info callback).  The function doesn’t check it, so it’s your
responsibility.</p>
<p>Also, some additional limitations:
at most two channels,
logarithmic volume control (dB level) thus no linear volume,
master can only attenuate the volume without gain</p>
<p><strong>Return</strong></p>
<p>Zero if successful or a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_ctl_add_follower_uncached">
int <code class="sig-name descname">snd_ctl_add_follower_uncached</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *master</em>, struct snd_kcontrol<em> *follower</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_ctl_add_follower_uncached" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a virtual follower control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*master</span></code></dt><dd><p>vmaster element</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*follower</span></code></dt><dd><p>follower element to add</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a virtual follower control to the given master.
Unlike <a class="reference internal" href="#c.snd_ctl_add_follower" title="snd_ctl_add_follower"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_add_follower()</span></code></a>, the element added via this function
is supposed to have volatile values, and get callback is called
at each time queried from the master.</p>
<p>When the control peeks the hardware values directly and the value
can be changed by other means than the put callback of the element,
this function should be used to keep the value always up-to-date.</p>
<p><strong>Return</strong></p>
<p>Zero if successful or a negative error code.</p>
</div>
</section>
</section>
<section id="midi-api">
<h2>MIDI API<a class="headerlink" href="#midi-api" title="Permalink to this headline">¶</a></h2>
<section id="raw-midi-api">
<h3>Raw MIDI API<a class="headerlink" href="#raw-midi-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_rawmidi_receive">
int <code class="sig-name descname">snd_rawmidi_receive</code><span class="sig-paren">(</span>struct snd_rawmidi_substream<em> *substream</em>, const unsigned char<em> *buffer</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_receive" title="Permalink to this definition">¶</a></dt>
<dd><p>receive the input data from the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buffer</span></code></dt><dd><p>the buffer pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the data size to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads the data from the internal buffer.</p>
<p><strong>Return</strong></p>
<p>The size of read data, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_rawmidi_transmit_empty">
int <code class="sig-name descname">snd_rawmidi_transmit_empty</code><span class="sig-paren">(</span>struct snd_rawmidi_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the output buffer is empty</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the internal output buffer is empty, 0 if not.</p>
</div>
<dl class="function">
<dt id="c.snd_rawmidi_transmit_peek">
int <code class="sig-name descname">snd_rawmidi_transmit_peek</code><span class="sig-paren">(</span>struct snd_rawmidi_substream<em> *substream</em>, unsigned char<em> *buffer</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data from the internal buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buffer</span></code></dt><dd><p>the buffer pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>data size to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data from the internal output buffer to the given buffer.</p>
<p>Call this in the interrupt handler when the midi output is ready,
and call <a class="reference internal" href="#c.snd_rawmidi_transmit_ack" title="snd_rawmidi_transmit_ack"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit_ack()</span></code></a> after the transmission is
finished.</p>
<p><strong>Return</strong></p>
<p>The size of copied data, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_rawmidi_transmit_ack">
int <code class="sig-name descname">snd_rawmidi_transmit_ack</code><span class="sig-paren">(</span>struct snd_rawmidi_substream<em> *substream</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>acknowledge the transmission</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the transferred count</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Advances the hardware pointer for the internal output buffer with
the given size and updates the condition.
Call after the transmission is finished.</p>
<p><strong>Return</strong></p>
<p>The advanced size if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_rawmidi_transmit">
int <code class="sig-name descname">snd_rawmidi_transmit</code><span class="sig-paren">(</span>struct snd_rawmidi_substream<em> *substream</em>, unsigned char<em> *buffer</em>, int<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_transmit" title="Permalink to this definition">¶</a></dt>
<dd><p>copy from the buffer to the device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the rawmidi substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*buffer</span></code></dt><dd><p>the buffer pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>the data size to transfer</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data from the buffer to the device and advances the pointer.</p>
<p><strong>Return</strong></p>
<p>The copied size if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_rawmidi_proceed">
int <code class="sig-name descname">snd_rawmidi_proceed</code><span class="sig-paren">(</span>struct snd_rawmidi_substream<em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_proceed" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard the all pending bytes and proceed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi_substream</span> <span class="pre">*substream</span></code></dt><dd><p>rawmidi substream</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of discarded bytes</p>
</div>
<dl class="function">
<dt id="c.snd_rawmidi_new">
int <code class="sig-name descname">snd_rawmidi_new</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, char<em> *id</em>, int<em> device</em>, int<em> output_count</em>, int<em> input_count</em>, struct snd_rawmidi<em> **rrawmidi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a rawmidi instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>the id string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>the device index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">output_count</span></code></dt><dd><p>the number of output streams</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">input_count</span></code></dt><dd><p>the number of input streams</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi</span> <span class="pre">**rrawmidi</span></code></dt><dd><p>the pointer to store the new rawmidi instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new rawmidi instance.
Use <a class="reference internal" href="#c.snd_rawmidi_set_ops" title="snd_rawmidi_set_ops"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_set_ops()</span></code></a> to set the operators to the new instance.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_rawmidi_set_ops">
void <code class="sig-name descname">snd_rawmidi_set_ops</code><span class="sig-paren">(</span>struct snd_rawmidi<em> *rmidi</em>, int<em> stream</em>, const struct snd_rawmidi_ops<em> *ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_rawmidi_set_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>set the rawmidi operators</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi</span> <span class="pre">*rmidi</span></code></dt><dd><p>the rawmidi instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt><dd><p>the stream direction, SNDRV_RAWMIDI_STREAM_XXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_rawmidi_ops</span> <span class="pre">*ops</span></code></dt><dd><p>the operator table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the rawmidi operators for the given stream direction.</p>
</div>
</section>
<section id="mpu401-uart-api">
<h3>MPU401-UART API<a class="headerlink" href="#mpu401-uart-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_mpu401_uart_interrupt">
irqreturn_t <code class="sig-name descname">snd_mpu401_uart_interrupt</code><span class="sig-paren">(</span>int<em> irq</em>, void<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_mpu401_uart_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>generic MPU401-UART interrupt handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>the irq number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>mpu401 instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes the interrupt for MPU401-UART i/o.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">IRQ_HANDLED</span></code> if the interrupt was handled. <code class="docutils literal notranslate"><span class="pre">IRQ_NONE</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.snd_mpu401_uart_interrupt_tx">
irqreturn_t <code class="sig-name descname">snd_mpu401_uart_interrupt_tx</code><span class="sig-paren">(</span>int<em> irq</em>, void<em> *dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_mpu401_uart_interrupt_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>generic MPU401-UART transmit irq handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>the irq number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*dev_id</span></code></dt><dd><p>mpu401 instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes the interrupt for MPU401-UART output.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">IRQ_HANDLED</span></code> if the interrupt was handled. <code class="docutils literal notranslate"><span class="pre">IRQ_NONE</span></code> otherwise.</p>
</div>
<dl class="function">
<dt id="c.snd_mpu401_uart_new">
int <code class="sig-name descname">snd_mpu401_uart_new</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, int<em> device</em>, unsigned short<em> hardware</em>, unsigned long<em> port</em>, unsigned int<em> info_flags</em>, int<em> irq</em>, struct snd_rawmidi **<em> rrawmidi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_mpu401_uart_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create an MPU401-UART instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>the device index, zero-based</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">hardware</span></code></dt><dd><p>the hardware type, MPU401_HW_XXXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">port</span></code></dt><dd><p>the base address of MPU401 port</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">info_flags</span></code></dt><dd><p>bitflags MPU401_INFO_XXX</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">irq</span></code></dt><dd><p>the ISA irq number, -1 if not to be allocated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_rawmidi</span> <span class="pre">**</span> <span class="pre">rrawmidi</span></code></dt><dd><p>the pointer to store the new rawmidi instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new MPU-401 instance.</p>
<p>Note that the rawmidi instance is returned on the rrawmidi argument,
not the mpu401 instance itself.  To access to the mpu401 instance,
cast from rawmidi-&gt;private_data (with struct snd_mpu401 magic-cast).</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code.</p>
</div>
</section>
</section>
<section id="proc-info-api">
<h2>Proc Info API<a class="headerlink" href="#proc-info-api" title="Permalink to this headline">¶</a></h2>
<section id="proc-info-interface">
<h3>Proc Info Interface<a class="headerlink" href="#proc-info-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_info_get_line">
int <code class="sig-name descname">snd_info_get_line</code><span class="sig-paren">(</span>struct snd_info_buffer<em> *buffer</em>, char<em> *line</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_get_line" title="Permalink to this definition">¶</a></dt>
<dd><p>read one line from the procfs buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_buffer</span> <span class="pre">*buffer</span></code></dt><dd><p>the procfs buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*line</span></code></dt><dd><p>the buffer to store</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>the max. buffer size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads one line from the buffer and stores the string.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or 1 if error or EOF.</p>
</div>
<dl class="function">
<dt id="c.snd_info_get_str">
const char * <code class="sig-name descname">snd_info_get_str</code><span class="sig-paren">(</span>char<em> *dest</em>, const char<em> *src</em>, int<em> len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_get_str" title="Permalink to this definition">¶</a></dt>
<dd><p>parse a string token</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*dest</span></code></dt><dd><p>the buffer to store the string token</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*src</span></code></dt><dd><p>the original string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">len</span></code></dt><dd><p>the max. length of token - 1</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parses the original string and copy a token to the given
string buffer.</p>
<p><strong>Return</strong></p>
<p>The updated pointer of the original string so that
it can be used for the next call.</p>
</div>
<dl class="function">
<dt id="c.snd_info_create_module_entry">
struct snd_info_entry * <code class="sig-name descname">snd_info_create_module_entry</code><span class="sig-paren">(</span>struct module *<em> module</em>, const char<em> *name</em>, struct snd_info_entry<em> *parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_create_module_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>create an info entry for the given module</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt><dd><p>the module pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the file name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*parent</span></code></dt><dd><p>the parent directory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new info entry and assigns it to the given module.</p>
<p><strong>Return</strong></p>
<p>The pointer of the new instance, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_info_create_card_entry">
struct snd_info_entry * <code class="sig-name descname">snd_info_create_card_entry</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, const char<em> *name</em>, struct snd_info_entry *<em> parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_create_card_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>create an info entry for the given card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the file name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt><dd><p>the parent directory</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new info entry and assigns it to the given card.</p>
<p><strong>Return</strong></p>
<p>The pointer of the new instance, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_info_free_entry">
void <code class="sig-name descname">snd_info_free_entry</code><span class="sig-paren">(</span>struct snd_info_entry *<em> entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_free_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>release the info entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt><dd><p>the info entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the info entry.</p>
</div>
<dl class="function">
<dt id="c.snd_info_register">
int <code class="sig-name descname">snd_info_register</code><span class="sig-paren">(</span>struct snd_info_entry<em> *entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_info_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register the info entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*entry</span></code></dt><dd><p>the info entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers the proc info entry.
The all children entries are registered recursively.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_card_rw_proc_new">
int <code class="sig-name descname">snd_card_rw_proc_new</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, const char<em> *name</em>, void<em> *private_data</em>, void (<em>*read</em>)(struct snd_info_entry *, struct snd_info_buffer *), void (*write)(struct snd_info_entry *entry, struct snd_info_buffer *buffer)<span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_rw_proc_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a read/write text proc file entry for the card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the file name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*private_data</span></code></dt><dd><p>the arbitrary private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*read)(struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">snd_info_buffer</span> <span class="pre">*)</span></code></dt><dd><p>the read callback</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*write)(struct</span> <span class="pre">snd_info_entry</span> <span class="pre">*entry,</span> <span class="pre">struct</span> <span class="pre">snd_info_buffer</span> <span class="pre">*buffer)</span></code></dt><dd><p>the write callback, NULL for read-only</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This proc file entry will be registered via <a class="reference internal" href="#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a> call, and
it will be removed automatically at the card removal, too.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
</section>
</section>
<section id="compress-offload">
<h2>Compress Offload<a class="headerlink" href="#compress-offload" title="Permalink to this headline">¶</a></h2>
<section id="compress-offload-api">
<h3>Compress Offload API<a class="headerlink" href="#compress-offload-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_compr_stop_error">
int <code class="sig-name descname">snd_compr_stop_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_compr_stream" title="snd_compr_stream">snd_compr_stream</a><em> *stream</em>, snd_pcm_state_t<em> state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_compr_stop_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Report a fatal error on a stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_compr_stream</span> <span class="pre">*stream</span></code></dt><dd><p>pointer to stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">snd_pcm_state_t</span> <span class="pre">state</span></code></dt><dd><p>state to transition the stream to</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop the stream and set its state.</p>
<p>Should be called with compressed device lock held.</p>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="function">
<dt id="c.snd_compress_new">
int <code class="sig-name descname">snd_compress_new</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, int<em> device</em>, int<em> dirn</em>, const char<em> *id</em>, struct <a class="reference internal" href="#c.snd_compr" title="snd_compr">snd_compr</a><em> *compr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_compress_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create new compress device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>sound card pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>device number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dirn</span></code></dt><dd><p>device direction, should be of type enum snd_compr_direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>ID string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_compr</span> <span class="pre">*compr</span></code></dt><dd><p>compress device pointer</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero if successful, or a negative error code</p>
</div>
<dl class="type">
<dt id="c.snd_compressed_buffer">
struct <code class="sig-name descname">snd_compressed_buffer</code><a class="headerlink" href="#c.snd_compressed_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>compressed buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compressed_buffer {
    __u32 fragment_size;
    __u32 fragments;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fragment_size</span></code></dt><dd><p>size of buffer fragment in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fragments</span></code></dt><dd><p>number of such fragments</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.snd_compr_params">
struct <code class="sig-name descname">snd_compr_params</code><a class="headerlink" href="#c.snd_compr_params" title="Permalink to this definition">¶</a></dt>
<dd><p>compressed stream params</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_params {
    struct snd_compressed_buffer buffer;
    struct snd_codec codec;
    __u8 no_wake_mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>buffer description</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">codec</span></code></dt><dd><p>codec parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">no_wake_mode</span></code></dt><dd><p>dont wake on fragment elapsed</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.snd_compr_tstamp">
struct <code class="sig-name descname">snd_compr_tstamp</code><a class="headerlink" href="#c.snd_compr_tstamp" title="Permalink to this definition">¶</a></dt>
<dd><p>timestamp descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_tstamp {
    __u32 byte_offset;
    __u32 copied_total;
    __u32 pcm_frames;
    __u32 pcm_io_frames;
    __u32 sampling_rate;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">byte_offset</span></code></dt><dd><p>Byte offset in ring buffer to DSP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copied_total</span></code></dt><dd><p>Total number of bytes copied from/to ring buffer to/by DSP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcm_frames</span></code></dt><dd><p>Frames decoded or encoded by DSP. This field will evolve by
large steps and should only be used to monitor encoding/decoding
progress. It shall not be used for timing estimates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pcm_io_frames</span></code></dt><dd><p>Frames rendered or received by DSP into a mixer or an audio
output/input. This field should be used for A/V sync or time estimates.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sampling_rate</span></code></dt><dd><p>sampling rate of audio</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.snd_compr_avail">
struct <code class="sig-name descname">snd_compr_avail</code><a class="headerlink" href="#c.snd_compr_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>avail descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_avail {
    __u64 avail;
    struct snd_compr_tstamp tstamp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">avail</span></code></dt><dd><p>Number of bytes available in ring buffer for writing/reading</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tstamp</span></code></dt><dd><p>timestamp information</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.snd_compr_caps">
struct <code class="sig-name descname">snd_compr_caps</code><a class="headerlink" href="#c.snd_compr_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>caps descriptor</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_caps {
    __u32 num_codecs;
    __u32 direction;
    __u32 min_fragment_size;
    __u32 max_fragment_size;
    __u32 min_fragments;
    __u32 max_fragments;
    __u32 codecs[MAX_NUM_CODECS];
    __u32 reserved[11];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num_codecs</span></code></dt><dd><p>number of codecs supported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction</span></code></dt><dd><p>direction supported. Of type snd_compr_direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_fragment_size</span></code></dt><dd><p>minimum fragment supported by DSP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_fragment_size</span></code></dt><dd><p>maximum fragment supported by DSP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_fragments</span></code></dt><dd><p>min fragments supported by DSP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_fragments</span></code></dt><dd><p>max fragments supported by DSP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">codecs</span></code></dt><dd><p>pointer to array of codecs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">reserved</span></code></dt><dd><p>reserved field</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.snd_compr_codec_caps">
struct <code class="sig-name descname">snd_compr_codec_caps</code><a class="headerlink" href="#c.snd_compr_codec_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>query capability of codec</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_codec_caps {
    __u32 codec;
    __u32 num_descriptors;
    struct snd_codec_desc descriptor[MAX_NUM_CODEC_DESCRIPTORS];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">codec</span></code></dt><dd><p>codec for which capability is queried</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_descriptors</span></code></dt><dd><p>number of codec descriptors</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">descriptor</span></code></dt><dd><p>array of codec capability descriptor</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.sndrv_compress_encoder">
enum <code class="sig-name descname">sndrv_compress_encoder</code><a class="headerlink" href="#c.sndrv_compress_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>encoder metadata key</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SNDRV_COMPRESS_ENCODER_PADDING</span></code></dt><dd><p>no of samples appended by the encoder at the
end of the track</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SNDRV_COMPRESS_ENCODER_DELAY</span></code></dt><dd><p>no of samples inserted by the encoder at the
beginning of the track</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.snd_compr_metadata">
struct <code class="sig-name descname">snd_compr_metadata</code><a class="headerlink" href="#c.snd_compr_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>compressed stream metadata</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_metadata {
    __u32 key;
    __u32 value[8];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">key</span></code></dt><dd><p>key id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">value</span></code></dt><dd><p>key value</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.snd_enc_vorbis">
struct <code class="sig-name descname">snd_enc_vorbis</code><a class="headerlink" href="#c.snd_enc_vorbis" title="Permalink to this definition">¶</a></dt>
<dd><p>Vorbis encoder parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_enc_vorbis {
    __s32 quality;
    __u32 managed;
    __u32 max_bit_rate;
    __u32 min_bit_rate;
    __u32 downmix;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">quality</span></code></dt><dd><p>Sets encoding quality to n, between -1 (low) and 10 (high).
In the default mode of operation, the quality level is 3.
Normal quality range is 0 - 10.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">managed</span></code></dt><dd><p>Boolean. Set  bitrate  management  mode. This turns off the
normal VBR encoding, but allows hard or soft bitrate constraints to be
enforced by the encoder. This mode can be slower, and may also be
lower quality. It is primarily useful for streaming.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_bit_rate</span></code></dt><dd><p>Enabled only if managed is TRUE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">min_bit_rate</span></code></dt><dd><p>Enabled only if managed is TRUE</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">downmix</span></code></dt><dd><p>Boolean. Downmix input from stereo to mono (has no effect on
non-stereo streams). Useful for lower-bitrate encoding.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These options were extracted from the OpenMAX IL spec and Gstreamer vorbisenc
properties</p>
<p>For best quality users should specify VBR mode and set quality levels.</p>
<dl class="type">
<dt id="c.snd_enc_real">
struct <code class="sig-name descname">snd_enc_real</code><a class="headerlink" href="#c.snd_enc_real" title="Permalink to this definition">¶</a></dt>
<dd><p>RealAudio encoder parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_enc_real {
    __u32 quant_bits;
    __u32 start_region;
    __u32 num_regions;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">quant_bits</span></code></dt><dd><p>number of coupling quantization bits in the stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">start_region</span></code></dt><dd><p>coupling start region in the stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_regions</span></code></dt><dd><p>number of regions value</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These options were extracted from the OpenMAX IL spec</p>
<dl class="type">
<dt id="c.snd_enc_flac">
struct <code class="sig-name descname">snd_enc_flac</code><a class="headerlink" href="#c.snd_enc_flac" title="Permalink to this definition">¶</a></dt>
<dd><p>FLAC encoder parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_enc_flac {
    __u32 num;
    __u32 gain;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">num</span></code></dt><dd><p>serial number, valid only for OGG formats
needs to be set by application</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gain</span></code></dt><dd><p>Add replay gain tags</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These options were extracted from the FLAC online documentation
at <a class="reference external" href="http://flac.sourceforge.net/documentation_tools_flac.html">http://flac.sourceforge.net/documentation_tools_flac.html</a></p>
<p>To make the API simpler, it is assumed that the user will select quality
profiles. Additional options that affect encoding quality and speed can
be added at a later stage if needed.</p>
<p>By default the Subset format is used by encoders.</p>
<p>TAGS such as pictures, etc, cannot be handled by an offloaded encoder and are
not supported in this API.</p>
<dl class="type">
<dt id="c.snd_compr_runtime">
struct <code class="sig-name descname">snd_compr_runtime</code><a class="headerlink" href="#c.snd_compr_runtime" title="Permalink to this definition">¶</a></dt>
<dd><p>runtime stream description</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_runtime {
    snd_pcm_state_t state;
    struct snd_compr_ops *ops;
    void *buffer;
    u64 buffer_size;
    u32 fragment_size;
    u32 fragments;
    u64 total_bytes_available;
    u64 total_bytes_transferred;
    wait_queue_head_t sleep;
    void *private_data;
    unsigned char *dma_area;
    dma_addr_t dma_addr;
    size_t dma_bytes;
    struct snd_dma_buffer *dma_buffer_p;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">state</span></code></dt><dd><p>stream state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>pointer to DSP callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>pointer to kernel buffer, valid only when not in mmap mode or
DSP doesn’t implement copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer_size</span></code></dt><dd><p>size of the above buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fragment_size</span></code></dt><dd><p>size of buffer fragment in bytes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fragments</span></code></dt><dd><p>number of such fragments</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total_bytes_available</span></code></dt><dd><p>cumulative number of bytes made available in
the ring buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">total_bytes_transferred</span></code></dt><dd><p>cumulative bytes transferred by offload DSP</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sleep</span></code></dt><dd><p>poll sleep</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_data</span></code></dt><dd><p>driver private data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_area</span></code></dt><dd><p>virtual buffer address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_addr</span></code></dt><dd><p>physical buffer address (not accessible from main CPU)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_bytes</span></code></dt><dd><p>size of DMA area</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_buffer_p</span></code></dt><dd><p>runtime dma buffer pointer</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.snd_compr_stream">
struct <code class="sig-name descname">snd_compr_stream</code><a class="headerlink" href="#c.snd_compr_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>compressed stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_stream {
    const char *name;
    struct snd_compr_ops *ops;
    struct snd_compr_runtime *runtime;
    struct snd_compr *device;
    struct delayed_work error_work;
    enum snd_compr_direction direction;
    bool metadata_set;
    bool next_track;
    bool partial_drain;
    bool pause_in_draining;
    void *private_data;
    struct snd_dma_buffer dma_buffer;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>pointer to DSP callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">runtime</span></code></dt><dd><p>pointer to runtime structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device</span></code></dt><dd><p>device pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">error_work</span></code></dt><dd><p>delayed work used when closing the stream due to an error</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction</span></code></dt><dd><p>stream direction, playback/recording</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">metadata_set</span></code></dt><dd><p>metadata set flag, true when set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next_track</span></code></dt><dd><p>has userspace signal next track transition, true when set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">partial_drain</span></code></dt><dd><p>undergoing partial_drain for stream, true when set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pause_in_draining</span></code></dt><dd><p>paused during draining state, true when set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_data</span></code></dt><dd><p>pointer to DSP private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dma_buffer</span></code></dt><dd><p>allocated buffer if any</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.snd_compr_ops">
struct <code class="sig-name descname">snd_compr_ops</code><a class="headerlink" href="#c.snd_compr_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>compressed path DSP operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr_ops {
    int (*open)(struct snd_compr_stream *stream);
    int (*free)(struct snd_compr_stream *stream);
    int (*set_params)(struct snd_compr_stream *stream, struct snd_compr_params *params);
    int (*get_params)(struct snd_compr_stream *stream, struct snd_codec *params);
    int (*set_metadata)(struct snd_compr_stream *stream, struct snd_compr_metadata *metadata);
    int (*get_metadata)(struct snd_compr_stream *stream, struct snd_compr_metadata *metadata);
    int (*trigger)(struct snd_compr_stream *stream, int cmd);
    int (*pointer)(struct snd_compr_stream *stream, struct snd_compr_tstamp *tstamp);
    int (*copy)(struct snd_compr_stream *stream, char __user *buf, size_t count);
    int (*mmap)(struct snd_compr_stream *stream, struct vm_area_struct *vma);
    int (*ack)(struct snd_compr_stream *stream, size_t bytes);
    int (*get_caps) (struct snd_compr_stream *stream, struct snd_compr_caps *caps);
    int (*get_codec_caps) (struct snd_compr_stream *stream, struct snd_compr_codec_caps *codec);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt><dd><p>Open the compressed stream
This callback is mandatory and shall keep dsp ready to receive the stream
parameter</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">free</span></code></dt><dd><p>Close the compressed stream, mandatory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_params</span></code></dt><dd><p>Sets the compressed stream parameters, mandatory
This can be called in during stream creation only to set codec params
and the stream properties</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_params</span></code></dt><dd><p>retrieve the codec parameters, mandatory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set_metadata</span></code></dt><dd><p>Set the metadata values for a stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_metadata</span></code></dt><dd><p>retrieves the requested metadata values from stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trigger</span></code></dt><dd><p>Trigger operations like start, pause, resume, drain, stop.
This callback is mandatory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pointer</span></code></dt><dd><p>Retrieve current h/w pointer information. Mandatory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">copy</span></code></dt><dd><p>Copy the compressed data to/from userspace, Optional
Can’t be implemented if DSP supports mmap</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mmap</span></code></dt><dd><p>DSP mmap method to mmap DSP memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ack</span></code></dt><dd><p>Ack for DSP when data is written to audio buffer, Optional
Not valid if copy is implemented</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_caps</span></code></dt><dd><p>Retrieve DSP capabilities, mandatory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">get_codec_caps</span></code></dt><dd><p>Retrieve capabilities for a specific codec, mandatory</p>
</dd>
</dl>
</div>
<dl class="type">
<dt id="c.snd_compr">
struct <code class="sig-name descname">snd_compr</code><a class="headerlink" href="#c.snd_compr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compressed device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_compr {
    const char *name;
    struct device dev;
    struct snd_compr_ops *ops;
    void *private_data;
    struct snd_card *card;
    unsigned int direction;
    struct mutex lock;
    int device;
    bool use_pause_in_draining;
#ifdef CONFIG_SND_VERBOSE_PROCFS;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>DSP device name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>associated device instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>pointer to DSP callbacks</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_data</span></code></dt><dd><p>pointer to DSP pvt data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">card</span></code></dt><dd><p>sound card pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">direction</span></code></dt><dd><p>Playback or capture direction</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lock</span></code></dt><dd><p>device lock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device</span></code></dt><dd><p>device id</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">use_pause_in_draining</span></code></dt><dd><p>allow pause in draining, true when set</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_compr_use_pause_in_draining">
void <code class="sig-name descname">snd_compr_use_pause_in_draining</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_compr_stream" title="snd_compr_stream">snd_compr_stream</a><em> *substream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_compr_use_pause_in_draining" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow pause and resume in draining state</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_compr_stream</span> <span class="pre">*substream</span></code></dt><dd><p>compress substream to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow pause and resume in draining state.
Only HW driver supports this transition can call this API.</p>
</div>
<dl class="function">
<dt id="c.snd_compr_set_runtime_buffer">
void <code class="sig-name descname">snd_compr_set_runtime_buffer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.snd_compr_stream" title="snd_compr_stream">snd_compr_stream</a><em> *stream</em>, struct snd_dma_buffer<em> *bufp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_compr_set_runtime_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Compress runtime buffer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_compr_stream</span> <span class="pre">*stream</span></code></dt><dd><p>compress stream to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_dma_buffer</span> <span class="pre">*bufp</span></code></dt><dd><p>the buffer information, NULL to clear</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the buffer information to runtime buffer when <strong>bufp</strong> is non-NULL.
Otherwise it clears the current buffer information.</p>
</div>
</section>
</section>
<section id="asoc">
<h2>ASoC<a class="headerlink" href="#asoc" title="Permalink to this headline">¶</a></h2>
<section id="asoc-core-api">
<h3>ASoC Core API<a class="headerlink" href="#asoc-core-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_soc_kcontrol_component">
struct snd_soc_component * <code class="sig-name descname">snd_soc_kcontrol_component</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_kcontrol_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the component that registered the control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>The control for which to get the component</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function will work correctly if the control has been registered
for a component. With snd_soc_add_codec_controls() or via table based
setup for either a CODEC or component driver. Otherwise the behavior is
undefined.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_find_dai">
struct snd_soc_dai * <code class="sig-name descname">snd_soc_find_dai</code><span class="sig-paren">(</span>const struct snd_soc_dai_link_component<em> *dlc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_find_dai" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a registered DAI</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dai_link_component</span> <span class="pre">*dlc</span></code></dt><dd><p>name of the DAI or the DAI driver and optional component info to match</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will search all registered components and their DAIs to
find the DAI of the same name. The component’s of_node and name
should also match if being specified.</p>
<p><strong>Return</strong></p>
<p>pointer of DAI, or NULL if not found.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_remove_pcm_runtime">
void <code class="sig-name descname">snd_soc_remove_pcm_runtime</code><span class="sig-paren">(</span>struct snd_soc_card<em> *card</em>, struct snd_soc_pcm_runtime<em> *rtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_remove_pcm_runtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a pcm_runtime from card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*card</span></code></dt><dd><p>The ASoC card to which the pcm_runtime has</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*rtd</span></code></dt><dd><p>The pcm_runtime to remove</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes a pcm_runtime from the ASoC card.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_add_pcm_runtime">
int <code class="sig-name descname">snd_soc_add_pcm_runtime</code><span class="sig-paren">(</span>struct snd_soc_card<em> *card</em>, struct snd_soc_dai_link<em> *dai_link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_add_pcm_runtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a pcm_runtime dynamically via dai_link</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*card</span></code></dt><dd><p>The ASoC card to which the pcm_runtime is added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai_link</span> <span class="pre">*dai_link</span></code></dt><dd><p>The DAI link to find pcm_runtime</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adds a pcm_runtime ASoC card by using dai_link.</p>
<p><strong>Note</strong></p>
<p>Topology can use this API to add pcm_runtime when probing the
topology component. And machine drivers can still define static
DAI links in dai_link array.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_runtime_set_dai_fmt">
int <code class="sig-name descname">snd_soc_runtime_set_dai_fmt</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime<em> *rtd</em>, unsigned int<em> dai_fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_runtime_set_dai_fmt" title="Permalink to this definition">¶</a></dt>
<dd><p>Change DAI link format for a ASoC runtime</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*rtd</span></code></dt><dd><p>The runtime for which the DAI link format should be changed</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dai_fmt</span></code></dt><dd><p>The new DAI link format</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function updates the DAI link format for all DAIs connected to the DAI
link for the specified runtime.</p>
<p>Returns 0 on success, otherwise a negative error code.</p>
<p><strong>Note</strong></p>
<p>For setups with a static format set the dai_fmt field in the
corresponding snd_dai_link struct instead of using this function.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_set_dmi_name">
int <code class="sig-name descname">snd_soc_set_dmi_name</code><span class="sig-paren">(</span>struct snd_soc_card<em> *card</em>, const char<em> *flavour</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_set_dmi_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Register DMI names to card</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*card</span></code></dt><dd><p>The card to register DMI names</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*flavour</span></code></dt><dd><p>The flavour “differentiator” for the card amongst its peers.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>An Intel machine driver may be used by many different devices but are
difficult for userspace to differentiate, since machine drivers ususally
use their own name as the card short name and leave the card long name
blank. To differentiate such devices and fix bugs due to lack of
device-specific configurations, this function allows DMI info to be used
as the sound card long name, in the format of
“vendor-product-version-board”
(Character ‘-’ is used to separate different DMI fields here).
This will help the user space to load the device-specific Use Case Manager
(UCM) configurations for the card.</p>
<p>Possible card long names may be:
DellInc.-XPS139343-01-0310JH
ASUSTeKCOMPUTERINC.-T100TA-1.0-T100TA
Circuitco-MinnowboardMaxD0PLATFORM-D0-MinnowBoardMAX</p>
<p>This function also supports flavoring the card longname to provide
the extra differentiation, like “vendor-product-version-board-flavor”.</p>
<p>We only keep number and alphabet characters and a few separator characters
in the card long name since UCM in the user space uses the card long names
as card configuration directory names and AudoConf cannot support special
charactors like SPACE.</p>
<p>Returns 0 on success, otherwise a negative error code.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_cnew">
struct snd_kcontrol * <code class="sig-name descname">snd_soc_cnew</code><span class="sig-paren">(</span>const struct snd_kcontrol_new<em> *_template</em>, void<em> *data</em>, const char<em> *long_name</em>, const char<em> *prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_cnew" title="Permalink to this definition">¶</a></dt>
<dd><p>create new control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span> <span class="pre">*_template</span></code></dt><dd><p>control template</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>control private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*long_name</span></code></dt><dd><p>control long name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*prefix</span></code></dt><dd><p>control name prefix</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new mixer control from a template control.</p>
<p>Returns 0 for success, else error.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_add_component_controls">
int <code class="sig-name descname">snd_soc_add_component_controls</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, const struct snd_kcontrol_new<em> *controls</em>, unsigned int<em> num_controls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_add_component_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an array of controls to a component.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>Component to add controls to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span> <span class="pre">*controls</span></code></dt><dd><p>Array of controls to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_controls</span></code></dt><dd><p>Number of elements in the array</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, else error.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_add_card_controls">
int <code class="sig-name descname">snd_soc_add_card_controls</code><span class="sig-paren">(</span>struct snd_soc_card<em> *soc_card</em>, const struct snd_kcontrol_new<em> *controls</em>, int<em> num_controls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_add_card_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>add an array of controls to a SoC card. Convenience function to add a list of controls.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*soc_card</span></code></dt><dd><p>SoC card to add controls to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span> <span class="pre">*controls</span></code></dt><dd><p>array of controls to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_controls</span></code></dt><dd><p>number of elements in the array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 for success, else error.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_add_dai_controls">
int <code class="sig-name descname">snd_soc_add_dai_controls</code><span class="sig-paren">(</span>struct snd_soc_dai<em> *dai</em>, const struct snd_kcontrol_new<em> *controls</em>, int<em> num_controls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_add_dai_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>add an array of controls to a DAI. Convienience function to add a list of controls.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai</span> <span class="pre">*dai</span></code></dt><dd><p>DAI to add controls to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_kcontrol_new</span> <span class="pre">*controls</span></code></dt><dd><p>array of controls to add</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_controls</span></code></dt><dd><p>number of elements in the array</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 for success, else error.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_register_card">
int <code class="sig-name descname">snd_soc_register_card</code><span class="sig-paren">(</span>struct snd_soc_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_register_card" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a card with the ASoC core</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*card</span></code></dt><dd><p>Card to register</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_soc_unregister_card">
void <code class="sig-name descname">snd_soc_unregister_card</code><span class="sig-paren">(</span>struct snd_soc_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_unregister_card" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a card with the ASoC core</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*card</span></code></dt><dd><p>Card to unregister</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_soc_register_dai">
struct snd_soc_dai * <code class="sig-name descname">snd_soc_register_dai</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, struct snd_soc_dai_driver<em> *dai_drv</em>, bool<em> legacy_dai_naming</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_register_dai" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a DAI dynamically &amp; create its widgets</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>The component the DAIs are registered for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai_driver</span> <span class="pre">*dai_drv</span></code></dt><dd><p>DAI driver to use for the DAI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">legacy_dai_naming</span></code></dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">true</span></code>, use legacy single-name format;
if <code class="docutils literal notranslate"><span class="pre">false</span></code>, use multiple-name format;</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Topology can use this API to register DAIs when probing a component.
These DAIs’s widgets will be freed in the card cleanup and the DAIs
will be freed in the component cleanup.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_unregister_dais">
void <code class="sig-name descname">snd_soc_unregister_dais</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_unregister_dais" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister DAIs from the ASoC core</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>The component for which the DAIs should be unregistered</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_soc_register_dais">
int <code class="sig-name descname">snd_soc_register_dais</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, struct snd_soc_dai_driver<em> *dai_drv</em>, size_t<em> count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_register_dais" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a DAI with the ASoC core</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>The component the DAIs are registered for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai_driver</span> <span class="pre">*dai_drv</span></code></dt><dd><p>DAI driver to use for the DAIs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">count</span></code></dt><dd><p>Number of DAIs</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_soc_unregister_component_by_driver">
void <code class="sig-name descname">snd_soc_unregister_component_by_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct snd_soc_component_driver<em> *component_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_unregister_component_by_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister component using a given driver from the ASoC core</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The device to unregister</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_component_driver</span> <span class="pre">*component_driver</span></code></dt><dd><p>The component driver to unregister</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_soc_unregister_component">
void <code class="sig-name descname">snd_soc_unregister_component</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_unregister_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister all related component from the ASoC core</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The device to unregister</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.devm_snd_soc_register_dai">
struct snd_soc_dai * <code class="sig-name descname">devm_snd_soc_register_dai</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct snd_soc_component<em> *component</em>, struct snd_soc_dai_driver<em> *dai_drv</em>, bool<em> legacy_dai_naming</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_snd_soc_register_dai" title="Permalink to this definition">¶</a></dt>
<dd><p>resource-managed dai registration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device used to manage component</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>The component the DAIs are registered for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai_driver</span> <span class="pre">*dai_drv</span></code></dt><dd><p>DAI driver to use for the DAI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">legacy_dai_naming</span></code></dt><dd><p>if <code class="docutils literal notranslate"><span class="pre">true</span></code>, use legacy single-name format;
if <code class="docutils literal notranslate"><span class="pre">false</span></code>, use multiple-name format;</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.devm_snd_soc_register_component">
int <code class="sig-name descname">devm_snd_soc_register_component</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct snd_soc_component_driver<em> *cmpnt_drv</em>, struct snd_soc_dai_driver<em> *dai_drv</em>, int<em> num_dai</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_snd_soc_register_component" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed component registration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device used to manage component</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_component_driver</span> <span class="pre">*cmpnt_drv</span></code></dt><dd><p>Component driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai_driver</span> <span class="pre">*dai_drv</span></code></dt><dd><p>DAI driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num_dai</span></code></dt><dd><p>Number of DAIs to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a component with automatic unregistration when the device is
unregistered.</p>
</div>
<dl class="function">
<dt id="c.devm_snd_soc_register_card">
int <code class="sig-name descname">devm_snd_soc_register_card</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, struct snd_soc_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_snd_soc_register_card" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed card registration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device used to manage card</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*card</span></code></dt><dd><p>Card to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a card with automatic unregistration when the device is
unregistered.</p>
</div>
<dl class="function">
<dt id="c.devm_snd_dmaengine_pcm_register">
int <code class="sig-name descname">devm_snd_dmaengine_pcm_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct <a class="reference internal" href="#c.snd_dmaengine_pcm_config" title="snd_dmaengine_pcm_config">snd_dmaengine_pcm_config</a><em> *config</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_snd_dmaengine_pcm_register" title="Permalink to this definition">¶</a></dt>
<dd><p>resource managed dmaengine PCM registration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The parent device for the PCM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_dmaengine_pcm_config</span> <span class="pre">*config</span></code></dt><dd><p>Platform specific PCM configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>Platform specific quirks</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a dmaengine based PCM device with automatic unregistration when the
device is unregistered.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_set_sysclk">
int <code class="sig-name descname">snd_soc_component_set_sysclk</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, int<em> clk_id</em>, int<em> source</em>, unsigned int<em> freq</em>, int<em> dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_set_sysclk" title="Permalink to this definition">¶</a></dt>
<dd><p>configure COMPONENT system or master clock.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>COMPONENT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">clk_id</span></code></dt><dd><p>DAI specific clock ID</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">source</span></code></dt><dd><p>Source for the clock</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">freq</span></code></dt><dd><p>new clock frequency in Hz</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dir</span></code></dt><dd><p>new clock direction - input/output.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configures the CODEC master (MCLK) or system (SYSCLK) clocking.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_set_jack">
int <code class="sig-name descname">snd_soc_component_set_jack</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, struct snd_soc_jack<em> *jack</em>, void<em> *data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_set_jack" title="Permalink to this definition">¶</a></dt>
<dd><p>configure component jack.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>COMPONENTs</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*jack</span></code></dt><dd><p>structure to use for the jack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*data</span></code></dt><dd><p>can be used if codec driver need extra data for configuring jack</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configures and enables jack detection function.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_init_regmap">
void <code class="sig-name descname">snd_soc_component_init_regmap</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, struct regmap<em> *regmap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_init_regmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize regmap instance for the component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>The component for which to initialize the regmap instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">regmap</span> <span class="pre">*regmap</span></code></dt><dd><p>The regmap instance that should be used by the component</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows deferred assignment of the regmap instance that is
associated with the component. Only use this if the regmap instance is not
yet ready when the component is registered. The function must also be called
before the first IO attempt of the component.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_exit_regmap">
void <code class="sig-name descname">snd_soc_component_exit_regmap</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_exit_regmap" title="Permalink to this definition">¶</a></dt>
<dd><p>De-initialize regmap instance for the component</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>The component for which to de-initialize the regmap instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls regmap_exit() on the regmap instance associated to the component and
removes the regmap instance from the component.</p>
<p>This function should only be used if <a class="reference internal" href="#c.snd_soc_component_init_regmap" title="snd_soc_component_init_regmap"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_component_init_regmap()</span></code></a> was used
to initialize the regmap instance.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_read">
unsigned int <code class="sig-name descname">snd_soc_component_read</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, unsigned int<em> reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read register value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>Component to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt><dd><p>Register to read</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>read value</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_write">
int <code class="sig-name descname">snd_soc_component_write</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, unsigned int<em> reg</em>, unsigned int<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write register value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>Component to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt><dd><p>Register to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt><dd><p>Value to write to the register</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_update_bits">
int <code class="sig-name descname">snd_soc_component_update_bits</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, unsigned int<em> reg</em>, unsigned int<em> mask</em>, unsigned int<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_update_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform read/modify/write cycle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>Component to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt><dd><p>Register to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>Mask that specifies which bits to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt><dd><p>New value for the bits specified by mask</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if the operation was successful and the value of the register
changed, 0 if the operation was successful, but the value did not change.
Returns a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_update_bits_async">
int <code class="sig-name descname">snd_soc_component_update_bits_async</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, unsigned int<em> reg</em>, unsigned int<em> mask</em>, unsigned int<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_update_bits_async" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform asynchronous read/modify/write cycle</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>Component to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt><dd><p>Register to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>Mask that specifies which bits to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt><dd><p>New value for the bits specified by mask</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar to <a class="reference internal" href="#c.snd_soc_component_update_bits" title="snd_soc_component_update_bits"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_component_update_bits()</span></code></a>, but the update
operation is scheduled asynchronously. This means it may not be completed
when the function returns. To make sure that all scheduled updates have been
completed <a class="reference internal" href="#c.snd_soc_component_async_complete" title="snd_soc_component_async_complete"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_component_async_complete()</span></code></a> must be called.</p>
<p><strong>Return</strong></p>
<p>1 if the operation was successful and the value of the register
changed, 0 if the operation was successful, but the value did not change.
Returns a negative error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_read_field">
unsigned int <code class="sig-name descname">snd_soc_component_read_field</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, unsigned int<em> reg</em>, unsigned int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_read_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Read register field value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>Component to read from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt><dd><p>Register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>mask of the register field</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>read value of register field.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_write_field">
int <code class="sig-name descname">snd_soc_component_write_field</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, unsigned int<em> reg</em>, unsigned int<em> mask</em>, unsigned int<em> val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_write_field" title="Permalink to this definition">¶</a></dt>
<dd><p>write to register field</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>Component to write to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt><dd><p>Register to write</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>mask of the register field to update</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">val</span></code></dt><dd><p>value of the field to write</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 for change, otherwise 0.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_async_complete">
void <code class="sig-name descname">snd_soc_component_async_complete</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_async_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure asynchronous I/O has completed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>Component for which to wait</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function blocks until all asynchronous I/O which has previously been
scheduled using <a class="reference internal" href="#c.snd_soc_component_update_bits_async" title="snd_soc_component_update_bits_async"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_component_update_bits_async()</span></code></a> has completed.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_component_test_bits">
int <code class="sig-name descname">snd_soc_component_test_bits</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, unsigned int<em> reg</em>, unsigned int<em> mask</em>, unsigned int<em> value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_component_test_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Test register for change</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>component</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt><dd><p>Register to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>Mask that specifies which bits to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">value</span></code></dt><dd><p>Value to test against</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tests a register with a new value and checks if the new value is
different from the old value.</p>
<p><strong>Return</strong></p>
<p>1 for change, otherwise 0.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_runtime_action">
void <code class="sig-name descname">snd_soc_runtime_action</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime<em> *rtd</em>, int<em> stream</em>, int<em> action</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_runtime_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment/Decrement active count for PCM runtime components</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*rtd</span></code></dt><dd><p>ASoC PCM runtime that is activated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt><dd><p>Direction of the PCM stream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">action</span></code></dt><dd><p>Activate stream if 1. Deactivate if -1.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments/Decrements the active count for all the DAIs and components
attached to a PCM runtime.
Should typically be called when a stream is opened.</p>
<p>Must be called with the rtd-&gt;card-&gt;pcm_mutex being held</p>
</div>
<dl class="function">
<dt id="c.snd_soc_runtime_ignore_pmdown_time">
bool <code class="sig-name descname">snd_soc_runtime_ignore_pmdown_time</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime<em> *rtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_runtime_ignore_pmdown_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether to ignore the power down delay</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*rtd</span></code></dt><dd><p>The ASoC PCM runtime that should be checked.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks whether the power down delay should be ignored for a
specific PCM runtime. Returns true if the delay is 0, if it the DAI link has
been configured to ignore the delay, or if none of the components benefits
from having the delay.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_set_runtime_hwparams">
int <code class="sig-name descname">snd_soc_set_runtime_hwparams</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, const struct snd_pcm_hardware<em> *hw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_set_runtime_hwparams" title="Permalink to this definition">¶</a></dt>
<dd><p>set the runtime hardware parameters</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>the pcm substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_pcm_hardware</span> <span class="pre">*hw</span></code></dt><dd><p>the hardware parameters</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the substream runtime hardware parameters.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_runtime_calc_hw">
int <code class="sig-name descname">snd_soc_runtime_calc_hw</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime<em> *rtd</em>, struct snd_pcm_hardware<em> *hw</em>, int<em> stream</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_runtime_calc_hw" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate hw limits for a PCM stream</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*rtd</span></code></dt><dd><p>ASoC PCM runtime</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hardware</span> <span class="pre">*hw</span></code></dt><dd><p>PCM hardware parameters (output)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt><dd><p>Direction of the PCM stream</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculates the subset of stream parameters supported by all DAIs
associated with the PCM stream.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_info_enum_double">
int <code class="sig-name descname">snd_soc_info_enum_double</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_info<em> *uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_info_enum_double" title="Permalink to this definition">¶</a></dt>
<dd><p>enumerated double mixer info callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*uinfo</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information about a double enumerated
mixer control.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_get_enum_double">
int <code class="sig-name descname">snd_soc_get_enum_double</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_enum_double" title="Permalink to this definition">¶</a></dt>
<dd><p>enumerated double mixer get callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a double enumerated mixer.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_put_enum_double">
int <code class="sig-name descname">snd_soc_put_enum_double</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_enum_double" title="Permalink to this definition">¶</a></dt>
<dd><p>enumerated double mixer put callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a double enumerated mixer.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_read_signed">
int <code class="sig-name descname">snd_soc_read_signed</code><span class="sig-paren">(</span>struct snd_soc_component<em> *component</em>, unsigned int<em> reg</em>, unsigned int<em> mask</em>, unsigned int<em> shift</em>, unsigned int<em> sign_bit</em>, int<em> *signed_val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_read_signed" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a codec register and interpret as signed value</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_component</span> <span class="pre">*component</span></code></dt><dd><p>component</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">reg</span></code></dt><dd><p>Register to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>Mask to use after shifting the register value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">shift</span></code></dt><dd><p>Right shift of register value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sign_bit</span></code></dt><dd><p>Bit that describes if a number is negative or not.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*signed_val</span></code></dt><dd><p>Pointer to where the read value should be stored</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions reads a codec register. The register value is shifted right
by ‘shift’ bits and masked with the given ‘mask’. Afterwards it translates
the given registervalue into a signed integer if sign_bit is non-zero.</p>
<p>Returns 0 on sucess, otherwise an error value</p>
</div>
<dl class="function">
<dt id="c.snd_soc_info_volsw">
int <code class="sig-name descname">snd_soc_info_volsw</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_info<em> *uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_info_volsw" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer info callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*uinfo</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information about a single mixer control, or a double
mixer control that spans 2 registers.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_info_volsw_sx">
int <code class="sig-name descname">snd_soc_info_volsw_sx</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_info<em> *uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_info_volsw_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>Mixer info callback for SX TLV controls</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*uinfo</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information about a single mixer control, or a double
mixer control that spans 2 registers of the SX TLV type. SX TLV controls
have a range that represents both positive and negative values either side
of zero but without a sign bit. min is the minimum register value, max is
the number of steps.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_get_volsw">
int <code class="sig-name descname">snd_soc_get_volsw</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_volsw" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer get callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a single mixer control, or a double mixer
control that spans 2 registers.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_put_volsw">
int <code class="sig-name descname">snd_soc_put_volsw</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_volsw" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer put callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a single mixer control, or a double mixer
control that spans 2 registers.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_get_volsw_sx">
int <code class="sig-name descname">snd_soc_get_volsw_sx</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_volsw_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer get callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a single mixer control, or a double mixer
control that spans 2 registers.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_put_volsw_sx">
int <code class="sig-name descname">snd_soc_put_volsw_sx</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_volsw_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>double mixer set callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a double mixer control that spans 2 registers.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_info_volsw_range">
int <code class="sig-name descname">snd_soc_info_volsw_range</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_info<em> *uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_info_volsw_range" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer info callback with range.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*uinfo</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information, within a range, about a single
mixer control.</p>
<p>returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_put_volsw_range">
int <code class="sig-name descname">snd_soc_put_volsw_range</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_volsw_range" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer put value callback with range.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value, within a range, for a single mixer control.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_get_volsw_range">
int <code class="sig-name descname">snd_soc_get_volsw_range</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_volsw_range" title="Permalink to this definition">¶</a></dt>
<dd><p>single mixer get callback with range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value, within a range, of a single mixer control.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_limit_volume">
int <code class="sig-name descname">snd_soc_limit_volume</code><span class="sig-paren">(</span>struct snd_soc_card<em> *card</em>, const char<em> *name</em>, int<em> max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_limit_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Set new limit to an existing volume control.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*card</span></code></dt><dd><p>where to look for the control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>Name of the control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">max</span></code></dt><dd><p>new maximum limit</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 for success, else error.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_info_xr_sx">
int <code class="sig-name descname">snd_soc_info_xr_sx</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_info<em> *uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_info_xr_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>signed multi register info callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mreg control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*uinfo</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information of a control that can
span multiple codec registers which together
forms a single signed value in a MSB/LSB manner.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_get_xr_sx">
int <code class="sig-name descname">snd_soc_get_xr_sx</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_xr_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>signed multi register get callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mreg control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a control that can span
multiple codec registers which together forms a single
signed value in a MSB/LSB manner. The control supports
specifying total no of bits used to allow for bitfields
across the multiple codec registers.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_put_xr_sx">
int <code class="sig-name descname">snd_soc_put_xr_sx</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_xr_sx" title="Permalink to this definition">¶</a></dt>
<dd><p>signed multi register get callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mreg control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a control that can span
multiple codec registers which together forms a single
signed value in a MSB/LSB manner. The control supports
specifying total no of bits used to allow for bitfields
across the multiple codec registers.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_get_strobe">
int <code class="sig-name descname">snd_soc_get_strobe</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_get_strobe" title="Permalink to this definition">¶</a></dt>
<dd><p>strobe get callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback get the value of a strobe mixer control.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_put_strobe">
int <code class="sig-name descname">snd_soc_put_strobe</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_put_strobe" title="Permalink to this definition">¶</a></dt>
<dd><p>strobe put callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback strobe a register bit to high then low (or the inverse)
in one pass of a single mixer enum control.</p>
<p>Returns 1 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_new_compress">
int <code class="sig-name descname">snd_soc_new_compress</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime<em> *rtd</em>, int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_new_compress" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new compress.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*rtd</span></code></dt><dd><p>The runtime for which we will create compress</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>the device index number (zero based - shared with normal PCMs)</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, else error.</p>
</div>
</section>
<section id="asoc-dapm-api">
<h3>ASoC DAPM API<a class="headerlink" href="#asoc-dapm-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_soc_dapm_kcontrol_widget">
struct snd_soc_dapm_widget * <code class="sig-name descname">snd_soc_dapm_kcontrol_widget</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_kcontrol_widget" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the widget associated to a kcontrol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>The kcontrol</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_kcontrol_dapm">
struct snd_soc_dapm_context * <code class="sig-name descname">snd_soc_dapm_kcontrol_dapm</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_kcontrol_dapm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dapm context associated to a kcontrol</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>The kcontrol</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function must only be used on kcontrols that are known to have
been registered for a CODEC. Otherwise the behaviour is undefined.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_force_bias_level">
int <code class="sig-name descname">snd_soc_dapm_force_bias_level</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, enum snd_soc_bias_level<em> level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_force_bias_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the DAPM bias level</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>The DAPM context for which to set the level</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">snd_soc_bias_level</span> <span class="pre">level</span></code></dt><dd><p>The level to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forces the DAPM bias level to a specific state. It will call the bias level
callback of DAPM context with the specified level. This will even happen if
the context is already at the same level. Furthermore it will not go through
the normal bias level sequencing, meaning any intermediate states between the
current and the target state will not be entered.</p>
<p>Note that the change in bias level is only temporary and the next time
<a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> is called the state will be set to the level as
determined by the DAPM core. The function is mainly intended to be used to
used during probe or resume from suspend to power up the device so
initialization can be done, before the DAPM core takes over.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_set_bias_level">
int <code class="sig-name descname">snd_soc_dapm_set_bias_level</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, enum snd_soc_bias_level<em> level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_set_bias_level" title="Permalink to this definition">¶</a></dt>
<dd><p>set the bias level for the system</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">snd_soc_bias_level</span> <span class="pre">level</span></code></dt><dd><p>level to configure</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configure the bias (power) levels for the SoC audio device.</p>
<p>Returns 0 for success else error.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_dai_get_connected_widgets">
int <code class="sig-name descname">snd_soc_dapm_dai_get_connected_widgets</code><span class="sig-paren">(</span>struct snd_soc_dai<em> *dai</em>, int<em> stream</em>, struct snd_soc_dapm_widget_list<em> **list</em>, bool (<em>*custom_stop_condition</em>)(struct snd_soc_dapm_widget *, enum snd_soc_dapm_direction)<span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_dai_get_connected_widgets" title="Permalink to this definition">¶</a></dt>
<dd><p>query audio path and it’s widgets.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai</span> <span class="pre">*dai</span></code></dt><dd><p>the soc DAI.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt><dd><p>stream direction.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_widget_list</span> <span class="pre">**list</span></code></dt><dd><p>list of active widgets for this stream.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">(*custom_stop_condition)(struct</span> <span class="pre">snd_soc_dapm_widget</span> <span class="pre">*,</span> <span class="pre">enum</span> <span class="pre">snd_soc_dapm_direction)</span></code></dt><dd><p>(optional) a function meant to stop the widget graph
walk based on custom logic.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queries DAPM graph as to whether a valid audio stream path exists for
the initial stream specified by name. This takes into account
current mixer and mux kcontrol settings. Creates list of valid widgets.</p>
<p>Optionally, can be supplied with a function acting as a stopping condition.
This function takes the dapm widget currently being examined and the walk
direction as an arguments, it should return true if the walk should be
stopped and false otherwise.</p>
<p>Returns the number of valid paths or negative error.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_free_widget">
void <code class="sig-name descname">snd_soc_dapm_free_widget</code><span class="sig-paren">(</span>struct snd_soc_dapm_widget<em> *w</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_free_widget" title="Permalink to this definition">¶</a></dt>
<dd><p>Free specified widget</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_widget</span> <span class="pre">*w</span></code></dt><dd><p>widget to free</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes widget from all paths and frees memory occupied by it.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_sync_unlocked">
int <code class="sig-name descname">snd_soc_dapm_sync_unlocked</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_sync_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>scan and power dapm paths</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walks all dapm audio paths and powers widgets according to their
stream or path usage.</p>
<p>Requires external locking.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_sync">
int <code class="sig-name descname">snd_soc_dapm_sync</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>scan and power dapm paths</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walks all dapm audio paths and powers widgets according to their
stream or path usage.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_add_routes">
int <code class="sig-name descname">snd_soc_dapm_add_routes</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const struct snd_soc_dapm_route<em> *route</em>, int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_add_routes" title="Permalink to this definition">¶</a></dt>
<dd><p>Add routes between DAPM widgets</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dapm_route</span> <span class="pre">*route</span></code></dt><dd><p>audio routes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of routes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Connects 2 dapm widgets together via a named audio path. The sink is
the widget receiving the audio signal, whilst the source is the sender
of the audio signal.</p>
<p>Returns 0 for success else error. On error all resources can be freed
with a call to snd_soc_card_free().</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_del_routes">
int <code class="sig-name descname">snd_soc_dapm_del_routes</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const struct snd_soc_dapm_route<em> *route</em>, int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_del_routes" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove routes between DAPM widgets</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dapm_route</span> <span class="pre">*route</span></code></dt><dd><p>audio routes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of routes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes routes from the DAPM context.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_weak_routes">
int <code class="sig-name descname">snd_soc_dapm_weak_routes</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const struct snd_soc_dapm_route<em> *route</em>, int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_weak_routes" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark routes between DAPM widgets as weak</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dapm_route</span> <span class="pre">*route</span></code></dt><dd><p>audio routes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of routes</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark existing routes matching those specified in the passed array
as being weak, meaning that they are ignored for the purpose of
power decisions.  The main intended use case is for sidetone paths
which couple audio between other independent paths if they are both
active in order to make the combination work better at the user
level but which aren’t intended to be “used”.</p>
<p>Note that CODEC drivers should not use this as sidetone type paths
can frequently also be used as bypass paths.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_new_widgets">
int <code class="sig-name descname">snd_soc_dapm_new_widgets</code><span class="sig-paren">(</span>struct snd_soc_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_new_widgets" title="Permalink to this definition">¶</a></dt>
<dd><p>add new dapm widgets</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_card</span> <span class="pre">*card</span></code></dt><dd><p>card to be checked for new dapm widgets</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks the codec for any new dapm widgets and creates them if found.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_get_volsw">
int <code class="sig-name descname">snd_soc_dapm_get_volsw</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_get_volsw" title="Permalink to this definition">¶</a></dt>
<dd><p>dapm mixer get callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a dapm mixer control.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_put_volsw">
int <code class="sig-name descname">snd_soc_dapm_put_volsw</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_put_volsw" title="Permalink to this definition">¶</a></dt>
<dd><p>dapm mixer set callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a dapm mixer control.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_get_enum_double">
int <code class="sig-name descname">snd_soc_dapm_get_enum_double</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_get_enum_double" title="Permalink to this definition">¶</a></dt>
<dd><p>dapm enumerated double mixer get callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to get the value of a dapm enumerated double mixer control.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_put_enum_double">
int <code class="sig-name descname">snd_soc_dapm_put_enum_double</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_put_enum_double" title="Permalink to this definition">¶</a></dt>
<dd><p>dapm enumerated double mixer set callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to set the value of a dapm enumerated double mixer control.</p>
<p>Returns 0 for success.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_info_pin_switch">
int <code class="sig-name descname">snd_soc_dapm_info_pin_switch</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_info<em> *uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_info_pin_switch" title="Permalink to this definition">¶</a></dt>
<dd><p>Info for a pin switch</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_info</span> <span class="pre">*uinfo</span></code></dt><dd><p>control element information</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callback to provide information about a pin switch control.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_get_pin_switch">
int <code class="sig-name descname">snd_soc_dapm_get_pin_switch</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_get_pin_switch" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information for a pin switch</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>Value</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_put_pin_switch">
int <code class="sig-name descname">snd_soc_dapm_put_pin_switch</code><span class="sig-paren">(</span>struct snd_kcontrol<em> *kcontrol</em>, struct snd_ctl_elem_value<em> *ucontrol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_put_pin_switch" title="Permalink to this definition">¶</a></dt>
<dd><p>Set information for a pin switch</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_kcontrol</span> <span class="pre">*kcontrol</span></code></dt><dd><p>mixer control</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_ctl_elem_value</span> <span class="pre">*ucontrol</span></code></dt><dd><p>Value</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_new_control">
struct snd_soc_dapm_widget * <code class="sig-name descname">snd_soc_dapm_new_control</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const struct snd_soc_dapm_widget<em> *widget</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_new_control" title="Permalink to this definition">¶</a></dt>
<dd><p>create new dapm control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dapm_widget</span> <span class="pre">*widget</span></code></dt><dd><p>widget template</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates new DAPM control based upon a template.</p>
<p>Returns a widget pointer on success or an error pointer on failure</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_new_controls">
int <code class="sig-name descname">snd_soc_dapm_new_controls</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const struct snd_soc_dapm_widget<em> *widget</em>, int<em> num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_new_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>create new dapm controls</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_soc_dapm_widget</span> <span class="pre">*widget</span></code></dt><dd><p>widget array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">num</span></code></dt><dd><p>number of widgets</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates new DAPM controls based upon the templates.</p>
<p>Returns 0 for success else error.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_new_dai_widgets">
int <code class="sig-name descname">snd_soc_dapm_new_dai_widgets</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, struct snd_soc_dai<em> *dai</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_new_dai_widgets" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new DAPM widgets</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dai</span> <span class="pre">*dai</span></code></dt><dd><p>parent DAI</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, error code otherwise.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_stream_event">
void <code class="sig-name descname">snd_soc_dapm_stream_event</code><span class="sig-paren">(</span>struct snd_soc_pcm_runtime<em> *rtd</em>, int<em> stream</em>, int<em> event</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_stream_event" title="Permalink to this definition">¶</a></dt>
<dd><p>send a stream event to the dapm core</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_pcm_runtime</span> <span class="pre">*rtd</span></code></dt><dd><p>PCM runtime data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">stream</span></code></dt><dd><p>stream name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">event</span></code></dt><dd><p>stream event</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sends a stream event to the dapm core. The core then makes any
necessary widget power changes.</p>
<p>Returns 0 for success else error.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_enable_pin_unlocked">
int <code class="sig-name descname">snd_soc_dapm_enable_pin_unlocked</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const char<em> *pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_enable_pin_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>enable pin.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pin</span></code></dt><dd><p>pin name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables input/output pin and its parents or children widgets iff there is
a valid audio route and active audio stream.</p>
<p>Requires external locking.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_enable_pin">
int <code class="sig-name descname">snd_soc_dapm_enable_pin</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const char<em> *pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_enable_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>enable pin.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pin</span></code></dt><dd><p>pin name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables input/output pin and its parents or children widgets iff there is
a valid audio route and active audio stream.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_force_enable_pin_unlocked">
int <code class="sig-name descname">snd_soc_dapm_force_enable_pin_unlocked</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const char<em> *pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_force_enable_pin_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>force a pin to be enabled</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pin</span></code></dt><dd><p>pin name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables input/output pin regardless of any other state.  This is
intended for use with microphone bias supplies used in microphone
jack detection.</p>
<p>Requires external locking.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_force_enable_pin">
int <code class="sig-name descname">snd_soc_dapm_force_enable_pin</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const char<em> *pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_force_enable_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>force a pin to be enabled</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pin</span></code></dt><dd><p>pin name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables input/output pin regardless of any other state.  This is
intended for use with microphone bias supplies used in microphone
jack detection.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_disable_pin_unlocked">
int <code class="sig-name descname">snd_soc_dapm_disable_pin_unlocked</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const char<em> *pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_disable_pin_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>disable pin.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pin</span></code></dt><dd><p>pin name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables input/output pin and its parents or children widgets.</p>
<p>Requires external locking.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_disable_pin">
int <code class="sig-name descname">snd_soc_dapm_disable_pin</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const char<em> *pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_disable_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>disable pin.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pin</span></code></dt><dd><p>pin name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables input/output pin and its parents or children widgets.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_nc_pin_unlocked">
int <code class="sig-name descname">snd_soc_dapm_nc_pin_unlocked</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const char<em> *pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_nc_pin_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>permanently disable pin.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pin</span></code></dt><dd><p>pin name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks the specified pin as being not connected, disabling it along
any parent or child widgets.  At present this is identical to
<a class="reference internal" href="#c.snd_soc_dapm_disable_pin" title="snd_soc_dapm_disable_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_disable_pin()</span></code></a> but in future it will be extended to do
additional things such as disabling controls which only affect
paths through the pin.</p>
<p>Requires external locking.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_nc_pin">
int <code class="sig-name descname">snd_soc_dapm_nc_pin</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const char<em> *pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_nc_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>permanently disable pin.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pin</span></code></dt><dd><p>pin name</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks the specified pin as being not connected, disabling it along
any parent or child widgets.  At present this is identical to
<a class="reference internal" href="#c.snd_soc_dapm_disable_pin" title="snd_soc_dapm_disable_pin"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_disable_pin()</span></code></a> but in future it will be extended to do
additional things such as disabling controls which only affect
paths through the pin.</p>
<p><strong>NOTE</strong></p>
<p><a class="reference internal" href="#c.snd_soc_dapm_sync" title="snd_soc_dapm_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_dapm_sync()</span></code></a> needs to be called after this for DAPM to
do any widget power switching.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_get_pin_status">
int <code class="sig-name descname">snd_soc_dapm_get_pin_status</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const char<em> *pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_get_pin_status" title="Permalink to this definition">¶</a></dt>
<dd><p>get audio pin status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pin</span></code></dt><dd><p>audio signal pin endpoint (or start point)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get audio pin status - connected or disconnected.</p>
<p>Returns 1 for connected otherwise 0.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_ignore_suspend">
int <code class="sig-name descname">snd_soc_dapm_ignore_suspend</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em>, const char<em> *pin</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_ignore_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>ignore suspend status for DAPM endpoint</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*pin</span></code></dt><dd><p>audio signal pin endpoint (or start point)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark the given endpoint or pin as ignoring suspend.  When the
system is disabled a path between two endpoints flagged as ignoring
suspend will not be disabled.  The path must already be enabled via
normal means at suspend time, it will not be turned on if it was not
already enabled.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_dapm_free">
void <code class="sig-name descname">snd_soc_dapm_free</code><span class="sig-paren">(</span>struct snd_soc_dapm_context<em> *dapm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_dapm_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free dapm resources</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_dapm_context</span> <span class="pre">*dapm</span></code></dt><dd><p>DAPM context</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all dapm widgets and resources.</p>
</div>
</section>
<section id="asoc-dma-engine-api">
<h3>ASoC DMA Engine API<a class="headerlink" href="#asoc-dma-engine-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_prepare_slave_config">
int <code class="sig-name descname">snd_dmaengine_pcm_prepare_slave_config</code><span class="sig-paren">(</span>struct snd_pcm_substream<em> *substream</em>, struct snd_pcm_hw_params<em> *params</em>, struct dma_slave_config<em> *slave_config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_prepare_slave_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic prepare_slave_config callback</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_substream</span> <span class="pre">*substream</span></code></dt><dd><p>PCM substream</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_pcm_hw_params</span> <span class="pre">*params</span></code></dt><dd><p>hw_params</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dma_slave_config</span> <span class="pre">*slave_config</span></code></dt><dd><p>DMA slave config to prepare</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as a generic prepare_slave_config callback for
platforms which make use of the snd_dmaengine_dai_dma_data struct for their
DAI DMA data. Internally the function will first call
snd_hwparams_to_dma_slave_config to fill in the slave config based on the
hw_params, followed by snd_dmaengine_set_config_from_dai_data to fill in the
remaining fields based on the DAI DMA data.</p>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_register">
int <code class="sig-name descname">snd_dmaengine_pcm_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, const struct <a class="reference internal" href="#c.snd_dmaengine_pcm_config" title="snd_dmaengine_pcm_config">snd_dmaengine_pcm_config</a><em> *config</em>, unsigned int<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a dmaengine based PCM device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>The parent device for the PCM device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">snd_dmaengine_pcm_config</span> <span class="pre">*config</span></code></dt><dd><p>Platform specific PCM configuration</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt><dd><p>Platform specific quirks</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_dmaengine_pcm_unregister">
void <code class="sig-name descname">snd_dmaengine_pcm_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dmaengine_pcm_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a dmaengine based PCM device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Parent device the PCM was register with</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a dmaengine based PCM device previously registered with
snd_dmaengine_pcm_register.</p>
</div>
</section>
</section>
<section id="miscellaneous-functions">
<h2>Miscellaneous Functions<a class="headerlink" href="#miscellaneous-functions" title="Permalink to this headline">¶</a></h2>
<section id="hardware-dependent-devices-api">
<h3>Hardware-Dependent Devices API<a class="headerlink" href="#hardware-dependent-devices-api" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_hwdep_new">
int <code class="sig-name descname">snd_hwdep_new</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, char<em> *id</em>, int<em> device</em>, struct snd_hwdep<em> **rhwdep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_hwdep_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new hwdep instance</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>the id string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">device</span></code></dt><dd><p>the device index (zero-based)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_hwdep</span> <span class="pre">**rhwdep</span></code></dt><dd><p>the pointer to store the new hwdep instance</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new hwdep instance with the given index on the card.
The callbacks (hwdep-&gt;ops) must be set on the returned instance
after this call manually by the caller.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
</section>
<section id="jack-abstraction-layer-api">
<h3>Jack Abstraction Layer API<a class="headerlink" href="#jack-abstraction-layer-api" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.snd_jack_types">
enum <code class="sig-name descname">snd_jack_types</code><a class="headerlink" href="#c.snd_jack_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Jack types which can be reported</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_HEADPHONE</span></code></dt><dd><p>Headphone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_MICROPHONE</span></code></dt><dd><p>Microphone</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_HEADSET</span></code></dt><dd><p>Headset</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_LINEOUT</span></code></dt><dd><p>Line out</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_MECHANICAL</span></code></dt><dd><p>Mechanical switch</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_VIDEOOUT</span></code></dt><dd><p>Video out</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_AVOUT</span></code></dt><dd><p>AV (Audio Video) out</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_LINEIN</span></code></dt><dd><p>Line in</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_0</span></code></dt><dd><p>Button 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_1</span></code></dt><dd><p>Button 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_2</span></code></dt><dd><p>Button 2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_3</span></code></dt><dd><p>Button 3</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_4</span></code></dt><dd><p>Button 4</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SND_JACK_BTN_5</span></code></dt><dd><p>Button 5</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>These values are used as a bitmask.</p>
<p>Note that this must be kept in sync with the lookup table in
sound/core/jack.c.</p>
<dl class="function">
<dt id="c.snd_jack_add_new_kctl">
int <code class="sig-name descname">snd_jack_add_new_kctl</code><span class="sig-paren">(</span>struct snd_jack<em> *jack</em>, const char *<em> name</em>, int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_jack_add_new_kctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new snd_jack_kctl and add it to jack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_jack</span> <span class="pre">*jack</span></code></dt><dd><p>the jack instance which the kctl will attaching to</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt><dd><p>the name for the snd_kcontrol object</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>a bitmask of enum snd_jack_type values that can be detected
by this snd_jack_kctl object.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new snd_kcontrol object and adds it to the jack kctl_list.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_jack_new">
int <code class="sig-name descname">snd_jack_new</code><span class="sig-paren">(</span>struct snd_card<em> *card</em>, const char<em> *id</em>, int<em> type</em>, struct snd_jack<em> **jjack</em>, bool<em> initial_kctl</em>, bool<em> phantom_jack</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_jack_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new jack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card instance</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*id</span></code></dt><dd><p>an identifying string for this jack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">type</span></code></dt><dd><p>a bitmask of enum snd_jack_type values that can be detected by
this jack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_jack</span> <span class="pre">**jjack</span></code></dt><dd><p>Used to provide the allocated jack object to the caller.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">initial_kctl</span></code></dt><dd><p>if true, create a kcontrol and add it to the jack list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">phantom_jack</span></code></dt><dd><p>Don’t create a input device for phantom jacks.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new jack object.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.
On success <strong>jjack</strong> will be initialised.</p>
</div>
<dl class="function">
<dt id="c.snd_jack_set_parent">
void <code class="sig-name descname">snd_jack_set_parent</code><span class="sig-paren">(</span>struct snd_jack<em> *jack</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_jack_set_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parent device for a jack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_jack</span> <span class="pre">*jack</span></code></dt><dd><p>The jack to configure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*parent</span></code></dt><dd><p>The device to set as parent for the jack.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the parent for the jack devices in the device tree.  This
function is only valid prior to registration of the jack.  If no
parent is configured then the parent device will be the sound card.</p>
</div>
<dl class="function">
<dt id="c.snd_jack_set_key">
int <code class="sig-name descname">snd_jack_set_key</code><span class="sig-paren">(</span>struct snd_jack<em> *jack</em>, enum <a class="reference internal" href="#c.snd_jack_types" title="snd_jack_types">snd_jack_types</a><em> type</em>, int<em> keytype</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_jack_set_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a key mapping on a jack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_jack</span> <span class="pre">*jack</span></code></dt><dd><p>The jack to configure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">snd_jack_types</span> <span class="pre">type</span></code></dt><dd><p>Jack report type for this key</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">keytype</span></code></dt><dd><p>Input layer key type to be reported</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map a SND_JACK_BTN_* button type to an input layer key, allowing
reporting of keys on accessories via the jack abstraction.  If no
mapping is provided but keys are enabled in the jack type then
BTN_n numeric buttons will be reported.</p>
<p>If jacks are not reporting via the input API this call will have no
effect.</p>
<p>Note that this is intended to be use by simple devices with small
numbers of keys that can be reported.  It is also possible to
access the input device directly - devices with complex input
capabilities on accessories should consider doing this rather than
using this abstraction.</p>
<p>This function may only be called prior to registration of the jack.</p>
<p><strong>Return</strong></p>
<p>Zero if successful, or a negative error code on failure.</p>
</div>
<dl class="function">
<dt id="c.snd_jack_report">
void <code class="sig-name descname">snd_jack_report</code><span class="sig-paren">(</span>struct snd_jack<em> *jack</em>, int<em> status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_jack_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the current status of a jack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_jack</span> <span class="pre">*jack</span></code></dt><dd><p>The jack to report status for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt><dd><p>The current status of the jack</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function uses mutexes and should be called from a
context which can sleep (such as a workqueue).</p>
</div>
<dl class="function">
<dt id="c.snd_soc_jack_report">
void <code class="sig-name descname">snd_soc_jack_report</code><span class="sig-paren">(</span>struct snd_soc_jack<em> *jack</em>, int<em> status</em>, int<em> mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the current status for a jack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*jack</span></code></dt><dd><p>the jack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">status</span></code></dt><dd><p>a bitmask of enum snd_jack_type values that are currently detected.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">mask</span></code></dt><dd><p>a bitmask of enum snd_jack_type values that being reported.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If configured using <a class="reference internal" href="#c.snd_soc_jack_add_pins" title="snd_soc_jack_add_pins"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_soc_jack_add_pins()</span></code></a> then the associated
DAPM pins will be enabled or disabled as appropriate and DAPM
synchronised.</p>
<p><strong>Note</strong></p>
<p>This function uses mutexes and should be called from a
context which can sleep (such as a workqueue).</p>
</div>
<dl class="function">
<dt id="c.snd_soc_jack_add_zones">
int <code class="sig-name descname">snd_soc_jack_add_zones</code><span class="sig-paren">(</span>struct snd_soc_jack<em> *jack</em>, int<em> count</em>, struct snd_soc_jack_zone<em> *zones</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_add_zones" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate voltage zones with jack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*jack</span></code></dt><dd><p>ASoC jack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Number of zones</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack_zone</span> <span class="pre">*zones</span></code></dt><dd><p>Array of zones</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this function has been called the zones specified in the
array will be associated with the jack.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_jack_get_type">
int <code class="sig-name descname">snd_soc_jack_get_type</code><span class="sig-paren">(</span>struct snd_soc_jack<em> *jack</em>, int<em> micbias_voltage</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_get_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Based on the mic bias value, this function returns the type of jack from the zones declared in the jack type</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*jack</span></code></dt><dd><p>ASoC jack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">micbias_voltage</span></code></dt><dd><p>mic bias voltage at adc channel when jack is plugged in</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Based on the mic bias value passed, this function helps identify
the type of jack from the already declared jack zones</p>
</div>
<dl class="function">
<dt id="c.snd_soc_jack_add_pins">
int <code class="sig-name descname">snd_soc_jack_add_pins</code><span class="sig-paren">(</span>struct snd_soc_jack<em> *jack</em>, int<em> count</em>, struct snd_soc_jack_pin<em> *pins</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_add_pins" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate DAPM pins with an ASoC jack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*jack</span></code></dt><dd><p>ASoC jack created with snd_soc_card_jack_new_pins()</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>Number of pins</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack_pin</span> <span class="pre">*pins</span></code></dt><dd><p>Array of pins</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this function has been called the DAPM pins specified in the
pins array will have their status updated to reflect the current
state of the jack whenever the jack status is updated.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_jack_notifier_register">
void <code class="sig-name descname">snd_soc_jack_notifier_register</code><span class="sig-paren">(</span>struct snd_soc_jack<em> *jack</em>, struct notifier_block<em> *nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_notifier_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a notifier for jack status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*jack</span></code></dt><dd><p>ASoC jack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>Notifier block to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register for notification of the current status of the jack.  Note
that it is not possible to report additional jack events in the
callback from the notifier, this is intended to support
applications such as enabling electrical detection only when a
mechanical detection event has occurred.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_jack_notifier_unregister">
void <code class="sig-name descname">snd_soc_jack_notifier_unregister</code><span class="sig-paren">(</span>struct snd_soc_jack<em> *jack</em>, struct notifier_block<em> *nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_notifier_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a notifier for jack status</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*jack</span></code></dt><dd><p>ASoC jack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*nb</span></code></dt><dd><p>Notifier block to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop notifying for status changes.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_jack_add_gpios">
int <code class="sig-name descname">snd_soc_jack_add_gpios</code><span class="sig-paren">(</span>struct snd_soc_jack<em> *jack</em>, int<em> count</em>, struct snd_soc_jack_gpio<em> *gpios</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_add_gpios" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate GPIO pins with an ASoC jack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*jack</span></code></dt><dd><p>ASoC jack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>number of pins</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack_gpio</span> <span class="pre">*gpios</span></code></dt><dd><p>array of gpio pins</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will request gpio, set data direction and request irq
for each gpio in the array.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_jack_add_gpiods">
int <code class="sig-name descname">snd_soc_jack_add_gpiods</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *gpiod_dev</em>, struct snd_soc_jack<em> *jack</em>, int<em> count</em>, struct snd_soc_jack_gpio<em> *gpios</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_add_gpiods" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate GPIO descriptor pins with an ASoC jack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*gpiod_dev</span></code></dt><dd><p>GPIO consumer device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*jack</span></code></dt><dd><p>ASoC jack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>number of pins</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack_gpio</span> <span class="pre">*gpios</span></code></dt><dd><p>array of gpio pins</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will request gpio, set data direction and request irq
for each gpio in the array.</p>
</div>
<dl class="function">
<dt id="c.snd_soc_jack_free_gpios">
void <code class="sig-name descname">snd_soc_jack_free_gpios</code><span class="sig-paren">(</span>struct snd_soc_jack<em> *jack</em>, int<em> count</em>, struct snd_soc_jack_gpio<em> *gpios</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_soc_jack_free_gpios" title="Permalink to this definition">¶</a></dt>
<dd><p>Release GPIO pins’ resources of an ASoC jack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack</span> <span class="pre">*jack</span></code></dt><dd><p>ASoC jack</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count</span></code></dt><dd><p>number of pins</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_jack_gpio</span> <span class="pre">*gpios</span></code></dt><dd><p>array of gpio pins</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release gpio and irq resources for gpio pins associated with an ASoC jack.</p>
</div>
</section>
<section id="isa-dma-helpers">
<h3>ISA DMA Helpers<a class="headerlink" href="#isa-dma-helpers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_dma_program">
void <code class="sig-name descname">snd_dma_program</code><span class="sig-paren">(</span>unsigned long<em> dma</em>, unsigned long<em> addr</em>, unsigned int<em> size</em>, unsigned short<em> mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_program" title="Permalink to this definition">¶</a></dt>
<dd><p>program an ISA DMA transfer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">dma</span></code></dt><dd><p>the dma number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt><dd><p>the physical address of the buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the DMA transfer size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">mode</span></code></dt><dd><p>the DMA transfer mode, DMA_MODE_XXX</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Programs an ISA DMA transfer for the given buffer.</p>
</div>
<dl class="function">
<dt id="c.snd_dma_disable">
void <code class="sig-name descname">snd_dma_disable</code><span class="sig-paren">(</span>unsigned long<em> dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the ISA DMA transfer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">dma</span></code></dt><dd><p>the dma number</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops the ISA DMA transfer.</p>
</div>
<dl class="function">
<dt id="c.snd_dma_pointer">
unsigned int <code class="sig-name descname">snd_dma_pointer</code><span class="sig-paren">(</span>unsigned long<em> dma</em>, unsigned int<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_dma_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>return the current pointer to DMA transfer buffer in bytes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">dma</span></code></dt><dd><p>the dma number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt><dd><p>the dma transfer size</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>The current pointer in DMA transfer buffer in bytes.</p>
</div>
<dl class="function">
<dt id="c.snd_devm_request_dma">
int <code class="sig-name descname">snd_devm_request_dma</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em>, int<em> dma</em>, const char<em> *name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_devm_request_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>the managed version of <a class="reference internal" href="../../core-api/kernel-api.html#c.request_dma" title="request_dma"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_dma()</span></code></a></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>the device pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dma</span></code></dt><dd><p>the dma number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>the name string of the requester</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The requested DMA will be automatically released at unbinding via devres.</p>
<p><strong>Return</strong></p>
<p>zero on success, or a negative error code</p>
</div>
</section>
<section id="other-helper-macros">
<h3>Other Helper Macros<a class="headerlink" href="#other-helper-macros" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.snd_power_ref">
void <code class="sig-name descname">snd_power_ref</code><span class="sig-paren">(</span>struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_power_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the reference count for power control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>sound card object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The power_ref reference of the card is used for managing to block
the <a class="reference internal" href="#c.snd_power_sync_ref" title="snd_power_sync_ref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_power_sync_ref()</span></code></a> operation.  This function increments the reference.
The counterpart <a class="reference internal" href="#c.snd_power_unref" title="snd_power_unref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_power_unref()</span></code></a> has to be called appropriately later.</p>
</div>
<dl class="function">
<dt id="c.snd_power_unref">
void <code class="sig-name descname">snd_power_unref</code><span class="sig-paren">(</span>struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_power_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the reference count for power control</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>sound card object</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.snd_power_sync_ref">
void <code class="sig-name descname">snd_power_sync_ref</code><span class="sig-paren">(</span>struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_power_sync_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until the card power_ref is freed</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>sound card object</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to synchronize with the pending power_ref being
released.</p>
</div>
<dl class="function">
<dt id="c.snd_card_unref">
void <code class="sig-name descname">snd_card_unref</code><span class="sig-paren">(</span>struct snd_card<em> *card</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_card_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>Unreference the card object</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_card</span> <span class="pre">*card</span></code></dt><dd><p>the card object to unreference</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this function for the card object that was obtained via <a class="reference internal" href="#c.snd_card_ref" title="snd_card_ref"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_ref()</span></code></a>
or <a class="reference internal" href="#c.snd_lookup_minor_data" title="snd_lookup_minor_data"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_lookup_minor_data()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.snd_printk">
<code class="sig-name descname">snd_printk</code><span class="sig-paren">(</span><em>fmt</em>, <em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printk" title="Permalink to this definition">¶</a></dt>
<dd><p>printk wrapper</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fmt</span></code></dt><dd><p>format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Works like <a class="reference internal" href="../../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> but prints the file and the line of the caller
when configured with CONFIG_SND_VERBOSE_PRINTK.</p>
</div>
<dl class="function">
<dt id="c.snd_printd">
<code class="sig-name descname">snd_printd</code><span class="sig-paren">(</span><em>fmt</em>, <em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printd" title="Permalink to this definition">¶</a></dt>
<dd><p>debug printk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fmt</span></code></dt><dd><p>format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Works like <a class="reference internal" href="#c.snd_printk" title="snd_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printk()</span></code></a> for debugging purposes.
Ignored when CONFIG_SND_DEBUG is not set.</p>
</div>
<dl class="function">
<dt id="c.snd_BUG">
<code class="sig-name descname">snd_BUG</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_BUG" title="Permalink to this definition">¶</a></dt>
<dd><p>give a BUG warning message and stack trace</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Calls WARN() if CONFIG_SND_DEBUG is set.
Ignored when CONFIG_SND_DEBUG is not set.</p>
</div>
<dl class="function">
<dt id="c.snd_printd_ratelimit">
<code class="sig-name descname">snd_printd_ratelimit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printd_ratelimit" title="Permalink to this definition">¶</a></dt>
<dd><p>Suppress high rates of output when CONFIG_SND_DEBUG is enabled.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
</div>
<dl class="function">
<dt id="c.snd_BUG_ON">
<code class="sig-name descname">snd_BUG_ON</code><span class="sig-paren">(</span><em>cond</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_BUG_ON" title="Permalink to this definition">¶</a></dt>
<dd><p>debugging check macro</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">cond</span></code></dt><dd><p>condition to evaluate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Has the same behavior as WARN_ON when CONFIG_SND_DEBUG is set,
otherwise just evaluates the conditional and returns the value.</p>
</div>
<dl class="function">
<dt id="c.snd_printdd">
<code class="sig-name descname">snd_printdd</code><span class="sig-paren">(</span><em>format</em>, <em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.snd_printdd" title="Permalink to this definition">¶</a></dt>
<dd><p>debug printk</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">format</span></code></dt><dd><p>format string</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>variable arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Works like <a class="reference internal" href="#c.snd_printk" title="snd_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printk()</span></code></a> for debugging purposes.
Ignored when CONFIG_SND_DEBUG_VERBOSE is not set.</p>
</div>
<dl class="function">
<dt id="c.register_sound_special_device">
int <code class="sig-name descname">register_sound_special_device</code><span class="sig-paren">(</span>const struct file_operations<em> *fops</em>, int<em> unit</em>, struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a><em> *dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_sound_special_device" title="Permalink to this definition">¶</a></dt>
<dd><p>register a special sound node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>File operations for the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">unit</span></code></dt><dd><p>Unit number to allocate</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device pointer</p>
<p>Allocate a special sound device by minor number from the sound
subsystem.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>The allocated number is returned on success. On failure,</dt><dd><p>a negative error code is returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.register_sound_mixer">
int <code class="sig-name descname">register_sound_mixer</code><span class="sig-paren">(</span>const struct file_operations<em> *fops</em>, int<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_sound_mixer" title="Permalink to this definition">¶</a></dt>
<dd><p>register a mixer device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>File operations for the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dev</span></code></dt><dd><p>Unit number to allocate</p>
<p>Allocate a mixer device. Unit is the number of the mixer requested.
Pass -1 to request the next free mixer unit.</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>On success, the allocated number is returned. On failure,</dt><dd><p>a negative error code is returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.register_sound_dsp">
int <code class="sig-name descname">register_sound_dsp</code><span class="sig-paren">(</span>const struct file_operations<em> *fops</em>, int<em> dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_sound_dsp" title="Permalink to this definition">¶</a></dt>
<dd><p>register a DSP device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*fops</span></code></dt><dd><p>File operations for the driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">dev</span></code></dt><dd><p>Unit number to allocate</p>
<p>Allocate a DSP device. Unit is the number of the DSP requested.
Pass -1 to request the next free DSP unit.</p>
<p>This function allocates both the audio and dsp device entries together
and will always allocate them as a matching pair - eg dsp3/audio3</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="simple">
<dt>On success, the allocated number is returned. On failure,</dt><dd><p>a negative error code is returned.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.unregister_sound_special">
void <code class="sig-name descname">unregister_sound_special</code><span class="sig-paren">(</span>int<em> unit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_sound_special" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a special sound device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">unit</span></code></dt><dd><p>unit number to allocate</p>
<p>Release a sound device that was allocated with
register_sound_special(). The unit passed is the return value from
the register function.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.unregister_sound_mixer">
void <code class="sig-name descname">unregister_sound_mixer</code><span class="sig-paren">(</span>int<em> unit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_sound_mixer" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a mixer</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">unit</span></code></dt><dd><p>unit number to allocate</p>
<p>Release a sound device that was allocated with <a class="reference internal" href="#c.register_sound_mixer" title="register_sound_mixer"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_sound_mixer()</span></code></a>.
The unit passed is the return value from the register function.</p>
</dd>
</dl>
</div>
<dl class="function">
<dt id="c.unregister_sound_dsp">
void <code class="sig-name descname">unregister_sound_dsp</code><span class="sig-paren">(</span>int<em> unit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_sound_dsp" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a DSP device</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">unit</span></code></dt><dd><p>unit number to allocate</p>
<p>Release a sound device that was allocated with <a class="reference internal" href="#c.register_sound_dsp" title="register_sound_dsp"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_sound_dsp()</span></code></a>.
The unit passed is the return value from the register function.</p>
<p>Both of the allocated units are released together automatically.</p>
</dd>
</dl>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The ALSA Driver API</a><ul>
<li><a class="reference internal" href="#management-of-cards-and-devices">Management of Cards and Devices</a><ul>
<li><a class="reference internal" href="#card-management">Card Management</a></li>
<li><a class="reference internal" href="#device-components">Device Components</a></li>
<li><a class="reference internal" href="#module-requests-and-device-file-entries">Module requests and Device File Entries</a></li>
<li><a class="reference internal" href="#memory-management-helpers">Memory Management Helpers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pcm-api">PCM API</a><ul>
<li><a class="reference internal" href="#pcm-core">PCM Core</a></li>
<li><a class="reference internal" href="#pcm-format-helpers">PCM Format Helpers</a></li>
<li><a class="reference internal" href="#pcm-memory-management">PCM Memory Management</a></li>
<li><a class="reference internal" href="#pcm-dma-engine-api">PCM DMA Engine API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#control-mixer-api">Control/Mixer API</a><ul>
<li><a class="reference internal" href="#general-control-interface">General Control Interface</a></li>
<li><a class="reference internal" href="#ac97-codec-api">AC97 Codec API</a></li>
<li><a class="reference internal" href="#virtual-master-control-api">Virtual Master Control API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#midi-api">MIDI API</a><ul>
<li><a class="reference internal" href="#raw-midi-api">Raw MIDI API</a></li>
<li><a class="reference internal" href="#mpu401-uart-api">MPU401-UART API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proc-info-api">Proc Info API</a><ul>
<li><a class="reference internal" href="#proc-info-interface">Proc Info Interface</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compress-offload">Compress Offload</a><ul>
<li><a class="reference internal" href="#compress-offload-api">Compress Offload API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asoc">ASoC</a><ul>
<li><a class="reference internal" href="#asoc-core-api">ASoC Core API</a></li>
<li><a class="reference internal" href="#asoc-dapm-api">ASoC DAPM API</a></li>
<li><a class="reference internal" href="#asoc-dma-engine-api">ASoC DMA Engine API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#miscellaneous-functions">Miscellaneous Functions</a><ul>
<li><a class="reference internal" href="#hardware-dependent-devices-api">Hardware-Dependent Devices API</a></li>
<li><a class="reference internal" href="#jack-abstraction-layer-api">Jack Abstraction Layer API</a></li>
<li><a class="reference internal" href="#isa-dma-helpers">ISA DMA Helpers</a></li>
<li><a class="reference internal" href="#other-helper-macros">Other Helper Macros</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sound/kernel-api/alsa-driver-api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/sound/kernel-api/alsa-driver-api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>