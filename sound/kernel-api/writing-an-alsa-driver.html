
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Writing an ALSA Driver &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Designs and Implementations" href="../designs/index.html" />
    <link rel="prev" title="The ALSA Driver API" href="alsa-driver-api.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="writing-an-alsa-driver">
<h1>Writing an ALSA Driver<a class="headerlink" href="#writing-an-alsa-driver" title="Permalink to this headline">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Takashi Iwai &lt;<a class="reference external" href="mailto:tiwai&#37;&#52;&#48;suse&#46;de">tiwai<span>&#64;</span>suse<span>&#46;</span>de</a>&gt;</p>
</dd>
</dl>
<section id="preface">
<h2>Preface<a class="headerlink" href="#preface" title="Permalink to this headline">¶</a></h2>
<p>This document describes how to write an <a class="reference external" href="http://www.alsa-project.org/">ALSA (Advanced Linux Sound
Architecture)</a> driver. The document
focuses mainly on PCI soundcards. In the case of other device types, the
API might be different, too. However, at least the ALSA kernel API is
consistent, and therefore it would be still a bit help for writing them.</p>
<p>This document targets people who already have enough C language skills
and have basic linux kernel programming knowledge. This document doesn’t
explain the general topic of linux kernel coding and doesn’t cover
low-level driver implementation details. It only describes the standard
way to write a PCI sound driver on ALSA.</p>
<p>This document is still a draft version. Any feedback and corrections,
please!!</p>
</section>
<section id="file-tree-structure">
<h2>File Tree Structure<a class="headerlink" href="#file-tree-structure" title="Permalink to this headline">¶</a></h2>
<section id="general">
<h3>General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h3>
<p>The file tree structure of ALSA driver is depicted below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sound
        /core
                /oss
                /seq
                        /oss
        /include
        /drivers
                /mpu401
                /opl3
        /i2c
        /synth
                /emux
        /pci
                /(cards)
        /isa
                /(cards)
        /arm
        /ppc
        /sparc
        /usb
        /pcmcia /(cards)
        /soc
        /oss
</pre></div>
</div>
</section>
<section id="core-directory">
<h3>core directory<a class="headerlink" href="#core-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory contains the middle layer which is the heart of ALSA
drivers. In this directory, the native ALSA modules are stored. The
sub-directories contain different modules and are dependent upon the
kernel config.</p>
<section id="core-oss">
<h4>core/oss<a class="headerlink" href="#core-oss" title="Permalink to this headline">¶</a></h4>
<p>The codes for PCM and mixer OSS emulation modules are stored in this
directory. The rawmidi OSS emulation is included in the ALSA rawmidi
code since it’s quite small. The sequencer code is stored in
<code class="docutils literal notranslate"><span class="pre">core/seq/oss</span></code> directory (see <a class="reference internal" href="#core-seq-oss">below</a>).</p>
</section>
<section id="core-seq">
<h4>core/seq<a class="headerlink" href="#core-seq" title="Permalink to this headline">¶</a></h4>
<p>This directory and its sub-directories are for the ALSA sequencer. This
directory contains the sequencer core and primary sequencer modules such
like snd-seq-midi, snd-seq-virmidi, etc. They are compiled only when
<code class="docutils literal notranslate"><span class="pre">CONFIG_SND_SEQUENCER</span></code> is set in the kernel config.</p>
</section>
<section id="core-seq-oss">
<h4>core/seq/oss<a class="headerlink" href="#core-seq-oss" title="Permalink to this headline">¶</a></h4>
<p>This contains the OSS sequencer emulation codes.</p>
</section>
</section>
<section id="include-directory">
<h3>include directory<a class="headerlink" href="#include-directory" title="Permalink to this headline">¶</a></h3>
<p>This is the place for the public header files of ALSA drivers, which are
to be exported to user-space, or included by several files at different
directories. Basically, the private header files should not be placed in
this directory, but you may still find files there, due to historical
reasons :)</p>
</section>
<section id="drivers-directory">
<h3>drivers directory<a class="headerlink" href="#drivers-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory contains code shared among different drivers on different
architectures. They are hence supposed not to be architecture-specific.
For example, the dummy pcm driver and the serial MIDI driver are found
in this directory. In the sub-directories, there is code for components
which are independent from bus and cpu architectures.</p>
<section id="drivers-mpu401">
<h4>drivers/mpu401<a class="headerlink" href="#drivers-mpu401" title="Permalink to this headline">¶</a></h4>
<p>The MPU401 and MPU401-UART modules are stored here.</p>
</section>
<section id="drivers-opl3-and-opl4">
<h4>drivers/opl3 and opl4<a class="headerlink" href="#drivers-opl3-and-opl4" title="Permalink to this headline">¶</a></h4>
<p>The OPL3 and OPL4 FM-synth stuff is found here.</p>
</section>
</section>
<section id="i2c-directory">
<h3>i2c directory<a class="headerlink" href="#i2c-directory" title="Permalink to this headline">¶</a></h3>
<p>This contains the ALSA i2c components.</p>
<p>Although there is a standard i2c layer on Linux, ALSA has its own i2c
code for some cards, because the soundcard needs only a simple operation
and the standard i2c API is too complicated for such a purpose.</p>
</section>
<section id="synth-directory">
<h3>synth directory<a class="headerlink" href="#synth-directory" title="Permalink to this headline">¶</a></h3>
<p>This contains the synth middle-level modules.</p>
<p>So far, there is only Emu8000/Emu10k1 synth driver under the
<code class="docutils literal notranslate"><span class="pre">synth/emux</span></code> sub-directory.</p>
</section>
<section id="pci-directory">
<h3>pci directory<a class="headerlink" href="#pci-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory and its sub-directories hold the top-level card modules
for PCI soundcards and the code specific to the PCI BUS.</p>
<p>The drivers compiled from a single file are stored directly in the pci
directory, while the drivers with several source files are stored on
their own sub-directory (e.g. emu10k1, ice1712).</p>
</section>
<section id="isa-directory">
<h3>isa directory<a class="headerlink" href="#isa-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory and its sub-directories hold the top-level card modules
for ISA soundcards.</p>
</section>
<section id="arm-ppc-and-sparc-directories">
<h3>arm, ppc, and sparc directories<a class="headerlink" href="#arm-ppc-and-sparc-directories" title="Permalink to this headline">¶</a></h3>
<p>They are used for top-level card modules which are specific to one of
these architectures.</p>
</section>
<section id="usb-directory">
<h3>usb directory<a class="headerlink" href="#usb-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory contains the USB-audio driver. In the latest version, the
USB MIDI driver is integrated in the usb-audio driver.</p>
</section>
<section id="pcmcia-directory">
<h3>pcmcia directory<a class="headerlink" href="#pcmcia-directory" title="Permalink to this headline">¶</a></h3>
<p>The PCMCIA, especially PCCard drivers will go here. CardBus drivers will
be in the pci directory, because their API is identical to that of
standard PCI cards.</p>
</section>
<section id="soc-directory">
<h3>soc directory<a class="headerlink" href="#soc-directory" title="Permalink to this headline">¶</a></h3>
<p>This directory contains the codes for ASoC (ALSA System on Chip)
layer including ASoC core, codec and machine drivers.</p>
</section>
<section id="oss-directory">
<h3>oss directory<a class="headerlink" href="#oss-directory" title="Permalink to this headline">¶</a></h3>
<p>Here contains OSS/Lite codes.
All codes have been deprecated except for dmasound on m68k as of
writing this.</p>
</section>
</section>
<section id="basic-flow-for-pci-drivers">
<h2>Basic Flow for PCI Drivers<a class="headerlink" href="#basic-flow-for-pci-drivers" title="Permalink to this headline">¶</a></h2>
<section id="outline">
<h3>Outline<a class="headerlink" href="#outline" title="Permalink to this headline">¶</a></h3>
<p>The minimum flow for PCI soundcards is as follows:</p>
<ul class="simple">
<li><p>define the PCI ID table (see the section <a class="reference internal" href="#pci-entries">PCI Entries</a>).</p></li>
<li><p>create <code class="docutils literal notranslate"><span class="pre">probe</span></code> callback.</p></li>
<li><p>create <code class="docutils literal notranslate"><span class="pre">remove</span></code> callback.</p></li>
<li><p>create a <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span></code></a> structure
containing the three pointers above.</p></li>
<li><p>create an <code class="docutils literal notranslate"><span class="pre">init</span></code> function just calling the
<code class="xref c c-func docutils literal notranslate"><span class="pre">pci_register_driver()</span></code> to register the pci_driver
table defined above.</p></li>
<li><p>create an <code class="docutils literal notranslate"><span class="pre">exit</span></code> function to call the
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_unregister_driver" title="pci_unregister_driver"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_unregister_driver()</span></code></a> function.</p></li>
</ul>
</section>
<section id="full-code-example">
<h3>Full Code Example<a class="headerlink" href="#full-code-example" title="Permalink to this headline">¶</a></h3>
<p>The code example is shown below. Some parts are kept unimplemented at
this moment but will be filled in the next sections. The numbers in the
comment lines of the <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mychip_probe()</span></code> function refer
to details explained in the following section.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/init.h&gt;
#include &lt;linux/pci.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;sound/core.h&gt;
#include &lt;sound/initval.h&gt;

/* module parameters (see &quot;Module Parameters&quot;) */
/* SNDRV_CARDS: maximum number of cards supported by this module */
static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;

/* definition of the chip-specific record */
struct mychip {
        struct snd_card *card;
        /* the rest of the implementation will be in section
         * &quot;PCI Resource Management&quot;
         */
};

/* chip-specific destructor
 * (see &quot;PCI Resource Management&quot;)
 */
static int snd_mychip_free(struct mychip *chip)
{
        .... /* will be implemented later... */
}

/* component-destructor
 * (see &quot;Management of Cards and Components&quot;)
 */
static int snd_mychip_dev_free(struct snd_device *device)
{
        return snd_mychip_free(device-&gt;device_data);
}

/* chip-specific constructor
 * (see &quot;Management of Cards and Components&quot;)
 */
static int snd_mychip_create(struct snd_card *card,
                             struct pci_dev *pci,
                             struct mychip **rchip)
{
        struct mychip *chip;
        int err;
        static const struct snd_device_ops ops = {
               .dev_free = snd_mychip_dev_free,
        };

        *rchip = NULL;

        /* check PCI availability here
         * (see &quot;PCI Resource Management&quot;)
         */
        ....

        /* allocate a chip-specific data with zero filled */
        chip = kzalloc(sizeof(*chip), GFP_KERNEL);
        if (chip == NULL)
                return -ENOMEM;

        chip-&gt;card = card;

        /* rest of initialization here; will be implemented
         * later, see &quot;PCI Resource Management&quot;
         */
        ....

        err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops);
        if (err &lt; 0) {
                snd_mychip_free(chip);
                return err;
        }

        *rchip = chip;
        return 0;
}

/* constructor -- see &quot;Driver Constructor&quot; sub-section */
static int snd_mychip_probe(struct pci_dev *pci,
                            const struct pci_device_id *pci_id)
{
        static int dev;
        struct snd_card *card;
        struct mychip *chip;
        int err;

        /* (1) */
        if (dev &gt;= SNDRV_CARDS)
                return -ENODEV;
        if (!enable[dev]) {
                dev++;
                return -ENOENT;
        }

        /* (2) */
        err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                           0, &amp;card);
        if (err &lt; 0)
                return err;

        /* (3) */
        err = snd_mychip_create(card, pci, &amp;chip);
        if (err &lt; 0)
                goto error;

        /* (4) */
        strcpy(card-&gt;driver, &quot;My Chip&quot;);
        strcpy(card-&gt;shortname, &quot;My Own Chip 123&quot;);
        sprintf(card-&gt;longname, &quot;%s at 0x%lx irq %i&quot;,
                card-&gt;shortname, chip-&gt;port, chip-&gt;irq);

        /* (5) */
        .... /* implemented later */

        /* (6) */
        err = snd_card_register(card);
        if (err &lt; 0)
                goto error;

        /* (7) */
        pci_set_drvdata(pci, card);
        dev++;
        return 0;

error:
        snd_card_free(card);
        return err;
}

/* destructor -- see the &quot;Destructor&quot; sub-section */
static void snd_mychip_remove(struct pci_dev *pci)
{
        snd_card_free(pci_get_drvdata(pci));
}
</pre></div>
</div>
</section>
<section id="driver-constructor">
<h3>Driver Constructor<a class="headerlink" href="#driver-constructor" title="Permalink to this headline">¶</a></h3>
<p>The real constructor of PCI drivers is the <code class="docutils literal notranslate"><span class="pre">probe</span></code> callback. The
<code class="docutils literal notranslate"><span class="pre">probe</span></code> callback and other component-constructors which are called
from the <code class="docutils literal notranslate"><span class="pre">probe</span></code> callback cannot be used with the <code class="docutils literal notranslate"><span class="pre">__init</span></code> prefix
because any PCI device could be a hotplug device.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">probe</span></code> callback, the following scheme is often used.</p>
<section id="check-and-increment-the-device-index">
<h4>1) Check and increment the device index.<a class="headerlink" href="#check-and-increment-the-device-index" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int dev;
....
if (dev &gt;= SNDRV_CARDS)
        return -ENODEV;
if (!enable[dev]) {
        dev++;
        return -ENOENT;
}
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">enable[dev]</span></code> is the module option.</p>
<p>Each time the <code class="docutils literal notranslate"><span class="pre">probe</span></code> callback is called, check the availability of
the device. If not available, simply increment the device index and
returns. dev will be incremented also later (<a class="reference internal" href="#set-the-pci-driver-data-and-return-zero">step 7</a>).</p>
</section>
<section id="create-a-card-instance">
<h4>2) Create a card instance<a class="headerlink" href="#create-a-card-instance" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_card *card;
int err;
....
err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                   0, &amp;card);
</pre></div>
</div>
<p>The details will be explained in the section <a class="reference internal" href="#management-of-cards-and-components">Management of Cards and
Components</a>.</p>
</section>
<section id="create-a-main-component">
<h4>3) Create a main component<a class="headerlink" href="#create-a-main-component" title="Permalink to this headline">¶</a></h4>
<p>In this part, the PCI resources are allocated.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip *chip;
....
err = snd_mychip_create(card, pci, &amp;chip);
if (err &lt; 0)
        goto error;
</pre></div>
</div>
<p>The details will be explained in the section <a class="reference internal" href="#pci-resource-management">PCI Resource
Management</a>.</p>
<p>When something goes wrong, the probe function needs to deal with the
error.  In this example, we have a single error handling path placed
at the end of the function.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>error:
        snd_card_free(card);
        return err;
</pre></div>
</div>
<p>Since each component can be properly freed, the single
<a class="reference internal" href="alsa-driver-api.html#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a> call should suffice in most cases.</p>
</section>
<section id="set-the-driver-id-and-name-strings">
<h4>4) Set the driver ID and name strings.<a class="headerlink" href="#set-the-driver-id-and-name-strings" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>strcpy(card-&gt;driver, &quot;My Chip&quot;);
strcpy(card-&gt;shortname, &quot;My Own Chip 123&quot;);
sprintf(card-&gt;longname, &quot;%s at 0x%lx irq %i&quot;,
        card-&gt;shortname, chip-&gt;port, chip-&gt;irq);
</pre></div>
</div>
<p>The driver field holds the minimal ID string of the chip. This is used
by alsa-lib’s configurator, so keep it simple but unique. Even the
same driver can have different driver IDs to distinguish the
functionality of each chip type.</p>
<p>The shortname field is a string shown as more verbose name. The longname
field contains the information shown in <code class="docutils literal notranslate"><span class="pre">/proc/asound/cards</span></code>.</p>
</section>
<section id="create-other-components-such-as-mixer-midi-etc">
<h4>5) Create other components, such as mixer, MIDI, etc.<a class="headerlink" href="#create-other-components-such-as-mixer-midi-etc" title="Permalink to this headline">¶</a></h4>
<p>Here you define the basic components such as <a class="reference internal" href="#pcm-interface">PCM</a>,
mixer (e.g. <a class="reference internal" href="#api-for-ac97-codec">AC97</a>), MIDI (e.g.
<a class="reference internal" href="#midi-mpu401-uart-interface">MPU-401</a>), and other interfaces.
Also, if you want a <a class="reference internal" href="#proc-interface">proc file</a>, define it here,
too.</p>
</section>
<section id="register-the-card-instance">
<h4>6) Register the card instance.<a class="headerlink" href="#register-the-card-instance" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = snd_card_register(card);
if (err &lt; 0)
        goto error;
</pre></div>
</div>
<p>Will be explained in the section <a class="reference internal" href="#management-of-cards-and-components">Management of Cards and
Components</a>, too.</p>
</section>
<section id="set-the-pci-driver-data-and-return-zero">
<h4>7) Set the PCI driver data and return zero.<a class="headerlink" href="#set-the-pci-driver-data-and-return-zero" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pci_set_drvdata(pci, card);
dev++;
return 0;
</pre></div>
</div>
<p>In the above, the card record is stored. This pointer is used in the
remove callback and power-management callbacks, too.</p>
</section>
</section>
<section id="destructor">
<h3>Destructor<a class="headerlink" href="#destructor" title="Permalink to this headline">¶</a></h3>
<p>The destructor, remove callback, simply releases the card instance. Then
the ALSA middle layer will release all the attached components
automatically.</p>
<p>It would be typically just calling <a class="reference internal" href="alsa-driver-api.html#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void snd_mychip_remove(struct pci_dev *pci)
{
        snd_card_free(pci_get_drvdata(pci));
}
</pre></div>
</div>
<p>The above code assumes that the card pointer is set to the PCI driver
data.</p>
</section>
<section id="header-files">
<h3>Header Files<a class="headerlink" href="#header-files" title="Permalink to this headline">¶</a></h3>
<p>For the above example, at least the following include files are
necessary.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/init.h&gt;
#include &lt;linux/pci.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;sound/core.h&gt;
#include &lt;sound/initval.h&gt;
</pre></div>
</div>
<p>where the last one is necessary only when module options are defined
in the source file. If the code is split into several files, the files
without module options don’t need them.</p>
<p>In addition to these headers, you’ll need <code class="docutils literal notranslate"><span class="pre">&lt;linux/interrupt.h&gt;</span></code> for
interrupt handling, and <code class="docutils literal notranslate"><span class="pre">&lt;linux/io.h&gt;</span></code> for I/O access. If you use the
<code class="xref c c-func docutils literal notranslate"><span class="pre">mdelay()</span></code> or <code class="xref c c-func docutils literal notranslate"><span class="pre">udelay()</span></code> functions, you’ll need
to include <code class="docutils literal notranslate"><span class="pre">&lt;linux/delay.h&gt;</span></code> too.</p>
<p>The ALSA interfaces like the PCM and control APIs are defined in other
<code class="docutils literal notranslate"><span class="pre">&lt;sound/xxx.h&gt;</span></code> header files. They have to be included after
<code class="docutils literal notranslate"><span class="pre">&lt;sound/core.h&gt;</span></code>.</p>
</section>
</section>
<section id="management-of-cards-and-components">
<h2>Management of Cards and Components<a class="headerlink" href="#management-of-cards-and-components" title="Permalink to this headline">¶</a></h2>
<section id="card-instance">
<h3>Card Instance<a class="headerlink" href="#card-instance" title="Permalink to this headline">¶</a></h3>
<p>For each soundcard, a “card” record must be allocated.</p>
<p>A card record is the headquarters of the soundcard. It manages the whole
list of devices (components) on the soundcard, such as PCM, mixers,
MIDI, synthesizer, and so on. Also, the card record holds the ID and the
name strings of the card, manages the root of proc files, and controls
the power-management states and hotplug disconnections. The component
list on the card record is used to manage the correct release of
resources at destruction.</p>
<p>As mentioned above, to create a card instance, call
<a class="reference internal" href="alsa-driver-api.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_card *card;
int err;
err = snd_card_new(&amp;pci-&gt;dev, index, id, module, extra_size, &amp;card);
</pre></div>
</div>
<p>The function takes six arguments: the parent device pointer, the
card-index number, the id string, the module pointer (usually
<code class="docutils literal notranslate"><span class="pre">THIS_MODULE</span></code>), the size of extra-data space, and the pointer to
return the card instance. The extra_size argument is used to allocate
card-&gt;private_data for the chip-specific data. Note that these data are
allocated by <a class="reference internal" href="alsa-driver-api.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>.</p>
<p>The first argument, the pointer of <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>, specifies the parent
device. For PCI devices, typically <code class="docutils literal notranslate"><span class="pre">&amp;pci-&gt;</span></code> is passed there.</p>
</section>
<section id="components">
<h3>Components<a class="headerlink" href="#components" title="Permalink to this headline">¶</a></h3>
<p>After the card is created, you can attach the components (devices) to
the card instance. In an ALSA driver, a component is represented as a
struct snd_device object. A component
can be a PCM instance, a control interface, a raw MIDI interface, etc.
Each such instance has one component entry.</p>
<p>A component can be created via <a class="reference internal" href="alsa-driver-api.html#c.snd_device_new" title="snd_device_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_device_new()</span></code></a>
function.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_device_new(card, SNDRV_DEV_XXX, chip, &amp;ops);
</pre></div>
</div>
<p>This takes the card pointer, the device-level (<code class="docutils literal notranslate"><span class="pre">SNDRV_DEV_XXX</span></code>), the
data pointer, and the callback pointers (<code class="docutils literal notranslate"><span class="pre">&amp;ops</span></code>). The device-level
defines the type of components and the order of registration and
de-registration. For most components, the device-level is already
defined. For a user-defined component, you can use
<code class="docutils literal notranslate"><span class="pre">SNDRV_DEV_LOWLEVEL</span></code>.</p>
<p>This function itself doesn’t allocate the data space. The data must be
allocated manually beforehand, and its pointer is passed as the
argument. This pointer (<code class="docutils literal notranslate"><span class="pre">chip</span></code> in the above example) is used as the
identifier for the instance.</p>
<p>Each pre-defined ALSA component such as ac97 and pcm calls
<a class="reference internal" href="alsa-driver-api.html#c.snd_device_new" title="snd_device_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_device_new()</span></code></a> inside its constructor. The destructor
for each component is defined in the callback pointers. Hence, you don’t
need to take care of calling a destructor for such a component.</p>
<p>If you wish to create your own component, you need to set the destructor
function to the dev_free callback in the <code class="docutils literal notranslate"><span class="pre">ops</span></code>, so that it can be
released automatically via <a class="reference internal" href="alsa-driver-api.html#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a>. The next
example will show an implementation of chip-specific data.</p>
</section>
<section id="chip-specific-data">
<h3>Chip-Specific Data<a class="headerlink" href="#chip-specific-data" title="Permalink to this headline">¶</a></h3>
<p>Chip-specific information, e.g. the I/O port address, its resource
pointer, or the irq number, is stored in the chip-specific record.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        ....
};
</pre></div>
</div>
<p>In general, there are two ways of allocating the chip record.</p>
<section id="allocating-via-snd-card-new">
<h4>1. Allocating via <a class="reference internal" href="alsa-driver-api.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>.<a class="headerlink" href="#allocating-via-snd-card-new" title="Permalink to this headline">¶</a></h4>
<p>As mentioned above, you can pass the extra-data-length to the 5th
argument of <a class="reference internal" href="alsa-driver-api.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>, i.e.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                   sizeof(struct mychip), &amp;card);
</pre></div>
</div>
<p>struct mychip is the type of the chip record.</p>
<p>In return, the allocated record can be accessed as</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip *chip = card-&gt;private_data;
</pre></div>
</div>
<p>With this method, you don’t have to allocate twice. The record is
released together with the card instance.</p>
</section>
<section id="allocating-an-extra-device">
<h4>2. Allocating an extra device.<a class="headerlink" href="#allocating-an-extra-device" title="Permalink to this headline">¶</a></h4>
<p>After allocating a card instance via <a class="reference internal" href="alsa-driver-api.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>
(with <code class="docutils literal notranslate"><span class="pre">0</span></code> on the 4th arg), call <a class="reference internal" href="../../core-api/mm-api.html#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_card *card;
struct mychip *chip;
err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                   0, &amp;card);
.....
chip = kzalloc(sizeof(*chip), GFP_KERNEL);
</pre></div>
</div>
<p>The chip record should have the field to hold the card pointer at least,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        struct snd_card *card;
        ....
};
</pre></div>
</div>
<p>Then, set the card pointer in the returned chip instance.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>chip-&gt;card = card;
</pre></div>
</div>
<p>Next, initialize the fields, and register this chip record as a
low-level device with a specified <code class="docutils literal notranslate"><span class="pre">ops</span></code>,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct snd_device_ops ops = {
        .dev_free =        snd_mychip_dev_free,
};
....
snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops);
</pre></div>
</div>
<p><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mychip_dev_free()</span></code> is the device-destructor
function, which will call the real destructor.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_mychip_dev_free(struct snd_device *device)
{
        return snd_mychip_free(device-&gt;device_data);
}
</pre></div>
</div>
<p>where <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mychip_free()</span></code> is the real destructor.</p>
<p>The demerit of this method is the obviously more amount of codes.
The merit is, however, you can trigger the own callback at registering
and disconnecting the card via setting in snd_device_ops.
About the registering and disconnecting the card, see the subsections
below.</p>
</section>
</section>
<section id="registration-and-release">
<h3>Registration and Release<a class="headerlink" href="#registration-and-release" title="Permalink to this headline">¶</a></h3>
<p>After all components are assigned, register the card instance by calling
<a class="reference internal" href="alsa-driver-api.html#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a>. Access to the device files is
enabled at this point. That is, before
<a class="reference internal" href="alsa-driver-api.html#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a> is called, the components are safely
inaccessible from external side. If this call fails, exit the probe
function after releasing the card via <a class="reference internal" href="alsa-driver-api.html#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a>.</p>
<p>For releasing the card instance, you can call simply
<a class="reference internal" href="alsa-driver-api.html#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a>. As mentioned earlier, all components
are released automatically by this call.</p>
<p>For a device which allows hotplugging, you can use
<a class="reference internal" href="alsa-driver-api.html#c.snd_card_free_when_closed" title="snd_card_free_when_closed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free_when_closed()</span></code></a>. This one will postpone
the destruction until all devices are closed.</p>
</section>
</section>
<section id="pci-resource-management">
<h2>PCI Resource Management<a class="headerlink" href="#pci-resource-management" title="Permalink to this headline">¶</a></h2>
<section id="id1">
<h3>Full Code Example<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>In this section, we’ll complete the chip-specific constructor,
destructor and PCI entries. Example code is shown first, below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        struct snd_card *card;
        struct pci_dev *pci;

        unsigned long port;
        int irq;
};

static int snd_mychip_free(struct mychip *chip)
{
        /* disable hardware here if any */
        .... /* (not implemented in this document) */

        /* release the irq */
        if (chip-&gt;irq &gt;= 0)
                free_irq(chip-&gt;irq, chip);
        /* release the I/O ports &amp; memory */
        pci_release_regions(chip-&gt;pci);
        /* disable the PCI entry */
        pci_disable_device(chip-&gt;pci);
        /* release the data */
        kfree(chip);
        return 0;
}

/* chip-specific constructor */
static int snd_mychip_create(struct snd_card *card,
                             struct pci_dev *pci,
                             struct mychip **rchip)
{
        struct mychip *chip;
        int err;
        static const struct snd_device_ops ops = {
               .dev_free = snd_mychip_dev_free,
        };

        *rchip = NULL;

        /* initialize the PCI entry */
        err = pci_enable_device(pci);
        if (err &lt; 0)
                return err;
        /* check PCI availability (28bit DMA) */
        if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0 ||
            pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0) {
                printk(KERN_ERR &quot;error to set 28bit mask DMA\n&quot;);
                pci_disable_device(pci);
                return -ENXIO;
        }

        chip = kzalloc(sizeof(*chip), GFP_KERNEL);
        if (chip == NULL) {
                pci_disable_device(pci);
                return -ENOMEM;
        }

        /* initialize the stuff */
        chip-&gt;card = card;
        chip-&gt;pci = pci;
        chip-&gt;irq = -1;

        /* (1) PCI resource allocation */
        err = pci_request_regions(pci, &quot;My Chip&quot;);
        if (err &lt; 0) {
                kfree(chip);
                pci_disable_device(pci);
                return err;
        }
        chip-&gt;port = pci_resource_start(pci, 0);
        if (request_irq(pci-&gt;irq, snd_mychip_interrupt,
                        IRQF_SHARED, KBUILD_MODNAME, chip)) {
                printk(KERN_ERR &quot;cannot grab irq %d\n&quot;, pci-&gt;irq);
                snd_mychip_free(chip);
                return -EBUSY;
        }
        chip-&gt;irq = pci-&gt;irq;
        card-&gt;sync_irq = chip-&gt;irq;

        /* (2) initialization of the chip hardware */
        .... /*   (not implemented in this document) */

        err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops);
        if (err &lt; 0) {
                snd_mychip_free(chip);
                return err;
        }

        *rchip = chip;
        return 0;
}

/* PCI IDs */
static struct pci_device_id snd_mychip_ids[] = {
        { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,
          PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
        ....
        { 0, }
};
MODULE_DEVICE_TABLE(pci, snd_mychip_ids);

/* pci_driver definition */
static struct pci_driver driver = {
        .name = KBUILD_MODNAME,
        .id_table = snd_mychip_ids,
        .probe = snd_mychip_probe,
        .remove = snd_mychip_remove,
};

/* module initialization */
static int __init alsa_card_mychip_init(void)
{
        return pci_register_driver(&amp;driver);
}

/* module clean up */
static void __exit alsa_card_mychip_exit(void)
{
        pci_unregister_driver(&amp;driver);
}

module_init(alsa_card_mychip_init)
module_exit(alsa_card_mychip_exit)

EXPORT_NO_SYMBOLS; /* for old kernels only */
</pre></div>
</div>
</section>
<section id="some-hafta-s">
<h3>Some Hafta’s<a class="headerlink" href="#some-hafta-s" title="Permalink to this headline">¶</a></h3>
<p>The allocation of PCI resources is done in the <code class="docutils literal notranslate"><span class="pre">probe</span></code> function, and
usually an extra <code class="xref c c-func docutils literal notranslate"><span class="pre">xxx_create()</span></code> function is written for this
purpose.</p>
<p>In the case of PCI devices, you first have to call the
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_enable_device" title="pci_enable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_enable_device()</span></code></a> function before allocating
resources. Also, you need to set the proper PCI DMA mask to limit the
accessed I/O range. In some cases, you might need to call
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_set_master" title="pci_set_master"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_set_master()</span></code></a> function, too.</p>
<p>Suppose the 28bit mask, and the code to be added would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = pci_enable_device(pci);
if (err &lt; 0)
        return err;
if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0 ||
    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) &lt; 0) {
        printk(KERN_ERR &quot;error to set 28bit mask DMA\n&quot;);
        pci_disable_device(pci);
        return -ENXIO;
}
</pre></div>
</div>
</section>
<section id="resource-allocation">
<h3>Resource Allocation<a class="headerlink" href="#resource-allocation" title="Permalink to this headline">¶</a></h3>
<p>The allocation of I/O ports and irqs is done via standard kernel
functions.  These resources must be released in the destructor
function (see below).</p>
<p>Now assume that the PCI device has an I/O port with 8 bytes and an
interrupt. Then struct mychip will have the
following fields:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        struct snd_card *card;

        unsigned long port;
        int irq;
};
</pre></div>
</div>
<p>For an I/O port (and also a memory region), you need to have the
resource pointer for the standard resource management. For an irq, you
have to keep only the irq number (integer). But you need to initialize
this number as -1 before actual allocation, since irq 0 is valid. The
port address and its resource pointer can be initialized as null by
<a class="reference internal" href="../../core-api/mm-api.html#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kzalloc()</span></code></a> automatically, so you don’t have to take care of
resetting them.</p>
<p>The allocation of an I/O port is done like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = pci_request_regions(pci, &quot;My Chip&quot;);
if (err &lt; 0) {
        kfree(chip);
        pci_disable_device(pci);
        return err;
}
chip-&gt;port = pci_resource_start(pci, 0);
</pre></div>
</div>
<p>It will reserve the I/O port region of 8 bytes of the given PCI device.
The returned value, <code class="docutils literal notranslate"><span class="pre">chip-&gt;res_port</span></code>, is allocated via
<a class="reference internal" href="../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> by <code class="xref c c-func docutils literal notranslate"><span class="pre">request_region()</span></code>. The pointer
must be released via <a class="reference internal" href="../../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>, but there is a problem with
this. This issue will be explained later.</p>
<p>The allocation of an interrupt source is done like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (request_irq(pci-&gt;irq, snd_mychip_interrupt,
                IRQF_SHARED, KBUILD_MODNAME, chip)) {
        printk(KERN_ERR &quot;cannot grab irq %d\n&quot;, pci-&gt;irq);
        snd_mychip_free(chip);
        return -EBUSY;
}
chip-&gt;irq = pci-&gt;irq;
</pre></div>
</div>
<p>where <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mychip_interrupt()</span></code> is the interrupt handler
defined <a class="reference internal" href="#pcm-interrupt-handler">later</a>. Note that
<code class="docutils literal notranslate"><span class="pre">chip-&gt;irq</span></code> should be defined only when <a class="reference internal" href="../../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a>
succeeded.</p>
<p>On the PCI bus, interrupts can be shared. Thus, <code class="docutils literal notranslate"><span class="pre">IRQF_SHARED</span></code> is used
as the interrupt flag of <a class="reference internal" href="../../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a>.</p>
<p>The last argument of <a class="reference internal" href="../../core-api/genericirq.html#c.request_irq" title="request_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_irq()</span></code></a> is the data pointer
passed to the interrupt handler. Usually, the chip-specific record is
used for that, but you can use what you like, too.</p>
<p>I won’t give details about the interrupt handler at this point, but at
least its appearance can be explained now. The interrupt handler looks
usually like the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
{
        struct mychip *chip = dev_id;
        ....
        return IRQ_HANDLED;
}
</pre></div>
</div>
<p>After requesting the IRQ, you can passed it to <code class="docutils literal notranslate"><span class="pre">card-&gt;sync_irq</span></code>
field:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>card-&gt;irq = chip-&gt;irq;
</pre></div>
</div>
<p>This allows PCM core automatically performing
<a class="reference internal" href="../../core-api/genericirq.html#c.synchronize_irq" title="synchronize_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_irq()</span></code></a> at the necessary timing like <code class="docutils literal notranslate"><span class="pre">hw_free</span></code>.
See the later section <a class="reference internal" href="#sync-stop-callback">sync_stop callback</a> for details.</p>
<p>Now let’s write the corresponding destructor for the resources above.
The role of destructor is simple: disable the hardware (if already
activated) and release the resources. So far, we have no hardware part,
so the disabling code is not written here.</p>
<p>To release the resources, the “check-and-release” method is a safer way.
For the interrupt, do like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (chip-&gt;irq &gt;= 0)
        free_irq(chip-&gt;irq, chip);
</pre></div>
</div>
<p>Since the irq number can start from 0, you should initialize
<code class="docutils literal notranslate"><span class="pre">chip-&gt;irq</span></code> with a negative value (e.g. -1), so that you can check
the validity of the irq number as above.</p>
<p>When you requested I/O ports or memory regions via
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_request_region" title="pci_request_region"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_region()</span></code></a> or
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_request_regions" title="pci_request_regions"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_request_regions()</span></code></a> like in this example, release the
resource(s) using the corresponding function,
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_release_region" title="pci_release_region"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_release_region()</span></code></a> or
<a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_release_regions" title="pci_release_regions"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_release_regions()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pci_release_regions(chip-&gt;pci);
</pre></div>
</div>
<p>When you requested manually via <code class="xref c c-func docutils literal notranslate"><span class="pre">request_region()</span></code> or
<code class="xref c c-func docutils literal notranslate"><span class="pre">request_mem_region()</span></code>, you can release it via
<a class="reference internal" href="../../core-api/kernel-api.html#c.release_resource" title="release_resource"><code class="xref c c-func docutils literal notranslate"><span class="pre">release_resource()</span></code></a>. Suppose that you keep the resource
pointer returned from <code class="xref c c-func docutils literal notranslate"><span class="pre">request_region()</span></code> in
chip-&gt;res_port, the release procedure looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>release_and_free_resource(chip-&gt;res_port);
</pre></div>
</div>
<p>Don’t forget to call <a class="reference internal" href="../../driver-api/pci/pci.html#c.pci_disable_device" title="pci_disable_device"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_disable_device()</span></code></a> before the
end.</p>
<p>And finally, release the chip-specific record.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kfree(chip);
</pre></div>
</div>
<p>We didn’t implement the hardware disabling part in the above. If you
need to do this, please note that the destructor may be called even
before the initialization of the chip is completed. It would be better
to have a flag to skip hardware disabling if the hardware was not
initialized yet.</p>
<p>When the chip-data is assigned to the card using
<a class="reference internal" href="alsa-driver-api.html#c.snd_device_new" title="snd_device_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_device_new()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">SNDRV_DEV_LOWLELVEL</span></code> , its
destructor is called at the last. That is, it is assured that all other
components like PCMs and controls have already been released. You don’t
have to stop PCMs, etc. explicitly, but just call low-level hardware
stopping.</p>
<p>The management of a memory-mapped region is almost as same as the
management of an I/O port. You’ll need three fields like the
following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        ....
        unsigned long iobase_phys;
        void __iomem *iobase_virt;
};
</pre></div>
</div>
<p>and the allocation would be like below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = pci_request_regions(pci, &quot;My Chip&quot;);
if (err &lt; 0) {
        kfree(chip);
        return err;
}
chip-&gt;iobase_phys = pci_resource_start(pci, 0);
chip-&gt;iobase_virt = ioremap(chip-&gt;iobase_phys,
                                    pci_resource_len(pci, 0));
</pre></div>
</div>
<p>and the corresponding destructor would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_mychip_free(struct mychip *chip)
{
        ....
        if (chip-&gt;iobase_virt)
                iounmap(chip-&gt;iobase_virt);
        ....
        pci_release_regions(chip-&gt;pci);
        ....
}
</pre></div>
</div>
<p>Of course, a modern way with <a class="reference internal" href="../../driver-api/device-io.html#c.pci_iomap" title="pci_iomap"><code class="xref c c-func docutils literal notranslate"><span class="pre">pci_iomap()</span></code></a> will make things a
bit easier, too.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = pci_request_regions(pci, &quot;My Chip&quot;);
if (err &lt; 0) {
        kfree(chip);
        return err;
}
chip-&gt;iobase_virt = pci_iomap(pci, 0, 0);
</pre></div>
</div>
<p>which is paired with <code class="xref c c-func docutils literal notranslate"><span class="pre">pci_iounmap()</span></code> at destructor.</p>
</section>
<section id="pci-entries">
<h3>PCI Entries<a class="headerlink" href="#pci-entries" title="Permalink to this headline">¶</a></h3>
<p>So far, so good. Let’s finish the missing PCI stuff. At first, we need a
<a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_device_id</span></code></a> table for
this chipset. It’s a table of PCI vendor/device ID number, and some
masks.</p>
<p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct pci_device_id snd_mychip_ids[] = {
        { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,
          PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
        ....
        { 0, }
};
MODULE_DEVICE_TABLE(pci, snd_mychip_ids);
</pre></div>
</div>
<p>The first and second fields of the <a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_device_id</span></code></a> are the vendor
and device IDs. If you have no reason to filter the matching devices, you can
leave the remaining fields as above. The last field of the
<a class="reference internal" href="../../PCI/pci.html#c.pci_device_id" title="pci_device_id"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_device_id</span></code></a> contains private data for this entry. You can specify
any value here, for example, to define specific operations for supported
device IDs. Such an example is found in the intel8x0 driver.</p>
<p>The last entry of this list is the terminator. You must specify this
all-zero entry.</p>
<p>Then, prepare the <a class="reference internal" href="../../PCI/pci.html#c.pci_driver" title="pci_driver"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pci_driver</span></code></a>
record:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct pci_driver driver = {
        .name = KBUILD_MODNAME,
        .id_table = snd_mychip_ids,
        .probe = snd_mychip_probe,
        .remove = snd_mychip_remove,
};
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">probe</span></code> and <code class="docutils literal notranslate"><span class="pre">remove</span></code> functions have already been defined in
the previous sections. The <code class="docutils literal notranslate"><span class="pre">name</span></code> field is the name string of this
device. Note that you must not use a slash “/” in this string.</p>
<p>And at last, the module entries:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int __init alsa_card_mychip_init(void)
{
        return pci_register_driver(&amp;driver);
}

static void __exit alsa_card_mychip_exit(void)
{
        pci_unregister_driver(&amp;driver);
}

module_init(alsa_card_mychip_init)
module_exit(alsa_card_mychip_exit)
</pre></div>
</div>
<p>Note that these module entries are tagged with <code class="docutils literal notranslate"><span class="pre">__init</span></code> and <code class="docutils literal notranslate"><span class="pre">__exit</span></code>
prefixes.</p>
<p>That’s all!</p>
</section>
</section>
<section id="pcm-interface">
<h2>PCM Interface<a class="headerlink" href="#pcm-interface" title="Permalink to this headline">¶</a></h2>
<section id="id2">
<h3>General<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>The PCM middle layer of ALSA is quite powerful and it is only necessary
for each driver to implement the low-level functions to access its
hardware.</p>
<p>For accessing to the PCM layer, you need to include <code class="docutils literal notranslate"><span class="pre">&lt;sound/pcm.h&gt;</span></code>
first. In addition, <code class="docutils literal notranslate"><span class="pre">&lt;sound/pcm_params.h&gt;</span></code> might be needed if you
access to some functions related with hw_param.</p>
<p>Each card device can have up to four pcm instances. A pcm instance
corresponds to a pcm device file. The limitation of number of instances
comes only from the available bit size of the Linux’s device numbers.
Once when 64bit device number is used, we’ll have more pcm instances
available.</p>
<p>A pcm instance consists of pcm playback and capture streams, and each
pcm stream consists of one or more pcm substreams. Some soundcards
support multiple playback functions. For example, emu10k1 has a PCM
playback of 32 stereo substreams. In this case, at each open, a free
substream is (usually) automatically chosen and opened. Meanwhile, when
only one substream exists and it was already opened, the successful open
will either block or error with <code class="docutils literal notranslate"><span class="pre">EAGAIN</span></code> according to the file open
mode. But you don’t have to care about such details in your driver. The
PCM middle layer will take care of such work.</p>
</section>
<section id="id3">
<h3>Full Code Example<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>The example code below does not include any hardware access routines but
shows only the skeleton, how to build up the PCM interfaces.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;sound/pcm.h&gt;
....

/* hardware definition */
static struct snd_pcm_hardware snd_mychip_playback_hw = {
        .info = (SNDRV_PCM_INFO_MMAP |
                 SNDRV_PCM_INFO_INTERLEAVED |
                 SNDRV_PCM_INFO_BLOCK_TRANSFER |
                 SNDRV_PCM_INFO_MMAP_VALID),
        .formats =          SNDRV_PCM_FMTBIT_S16_LE,
        .rates =            SNDRV_PCM_RATE_8000_48000,
        .rate_min =         8000,
        .rate_max =         48000,
        .channels_min =     2,
        .channels_max =     2,
        .buffer_bytes_max = 32768,
        .period_bytes_min = 4096,
        .period_bytes_max = 32768,
        .periods_min =      1,
        .periods_max =      1024,
};

/* hardware definition */
static struct snd_pcm_hardware snd_mychip_capture_hw = {
        .info = (SNDRV_PCM_INFO_MMAP |
                 SNDRV_PCM_INFO_INTERLEAVED |
                 SNDRV_PCM_INFO_BLOCK_TRANSFER |
                 SNDRV_PCM_INFO_MMAP_VALID),
        .formats =          SNDRV_PCM_FMTBIT_S16_LE,
        .rates =            SNDRV_PCM_RATE_8000_48000,
        .rate_min =         8000,
        .rate_max =         48000,
        .channels_min =     2,
        .channels_max =     2,
        .buffer_bytes_max = 32768,
        .period_bytes_min = 4096,
        .period_bytes_max = 32768,
        .periods_min =      1,
        .periods_max =      1024,
};

/* open callback */
static int snd_mychip_playback_open(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        struct snd_pcm_runtime *runtime = substream-&gt;runtime;

        runtime-&gt;hw = snd_mychip_playback_hw;
        /* more hardware-initialization will be done here */
        ....
        return 0;
}

/* close callback */
static int snd_mychip_playback_close(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        /* the hardware-specific codes will be here */
        ....
        return 0;

}

/* open callback */
static int snd_mychip_capture_open(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        struct snd_pcm_runtime *runtime = substream-&gt;runtime;

        runtime-&gt;hw = snd_mychip_capture_hw;
        /* more hardware-initialization will be done here */
        ....
        return 0;
}

/* close callback */
static int snd_mychip_capture_close(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        /* the hardware-specific codes will be here */
        ....
        return 0;
}

/* hw_params callback */
static int snd_mychip_pcm_hw_params(struct snd_pcm_substream *substream,
                             struct snd_pcm_hw_params *hw_params)
{
        /* the hardware-specific codes will be here */
        ....
        return 0;
}

/* hw_free callback */
static int snd_mychip_pcm_hw_free(struct snd_pcm_substream *substream)
{
        /* the hardware-specific codes will be here */
        ....
        return 0;
}

/* prepare callback */
static int snd_mychip_pcm_prepare(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        struct snd_pcm_runtime *runtime = substream-&gt;runtime;

        /* set up the hardware with the current configuration
         * for example...
         */
        mychip_set_sample_format(chip, runtime-&gt;format);
        mychip_set_sample_rate(chip, runtime-&gt;rate);
        mychip_set_channels(chip, runtime-&gt;channels);
        mychip_set_dma_setup(chip, runtime-&gt;dma_addr,
                             chip-&gt;buffer_size,
                             chip-&gt;period_size);
        return 0;
}

/* trigger callback */
static int snd_mychip_pcm_trigger(struct snd_pcm_substream *substream,
                                  int cmd)
{
        switch (cmd) {
        case SNDRV_PCM_TRIGGER_START:
                /* do something to start the PCM engine */
                ....
                break;
        case SNDRV_PCM_TRIGGER_STOP:
                /* do something to stop the PCM engine */
                ....
                break;
        default:
                return -EINVAL;
        }
}

/* pointer callback */
static snd_pcm_uframes_t
snd_mychip_pcm_pointer(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        unsigned int current_ptr;

        /* get the current hardware pointer */
        current_ptr = mychip_get_hw_pointer(chip);
        return current_ptr;
}

/* operators */
static struct snd_pcm_ops snd_mychip_playback_ops = {
        .open =        snd_mychip_playback_open,
        .close =       snd_mychip_playback_close,
        .hw_params =   snd_mychip_pcm_hw_params,
        .hw_free =     snd_mychip_pcm_hw_free,
        .prepare =     snd_mychip_pcm_prepare,
        .trigger =     snd_mychip_pcm_trigger,
        .pointer =     snd_mychip_pcm_pointer,
};

/* operators */
static struct snd_pcm_ops snd_mychip_capture_ops = {
        .open =        snd_mychip_capture_open,
        .close =       snd_mychip_capture_close,
        .hw_params =   snd_mychip_pcm_hw_params,
        .hw_free =     snd_mychip_pcm_hw_free,
        .prepare =     snd_mychip_pcm_prepare,
        .trigger =     snd_mychip_pcm_trigger,
        .pointer =     snd_mychip_pcm_pointer,
};

/*
 *  definitions of capture are omitted here...
 */

/* create a pcm device */
static int snd_mychip_new_pcm(struct mychip *chip)
{
        struct snd_pcm *pcm;
        int err;

        err = snd_pcm_new(chip-&gt;card, &quot;My Chip&quot;, 0, 1, 1, &amp;pcm);
        if (err &lt; 0)
                return err;
        pcm-&gt;private_data = chip;
        strcpy(pcm-&gt;name, &quot;My Chip&quot;);
        chip-&gt;pcm = pcm;
        /* set operators */
        snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
                        &amp;snd_mychip_playback_ops);
        snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
                        &amp;snd_mychip_capture_ops);
        /* pre-allocation of buffers */
        /* NOTE: this may fail */
        snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
                                       &amp;chip-&gt;pci-&gt;dev,
                                       64*1024, 64*1024);
        return 0;
}
</pre></div>
</div>
</section>
<section id="pcm-constructor">
<h3>PCM Constructor<a class="headerlink" href="#pcm-constructor" title="Permalink to this headline">¶</a></h3>
<p>A pcm instance is allocated by the <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_new" title="snd_pcm_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_new()</span></code></a>
function. It would be better to create a constructor for pcm, namely,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_mychip_new_pcm(struct mychip *chip)
{
        struct snd_pcm *pcm;
        int err;

        err = snd_pcm_new(chip-&gt;card, &quot;My Chip&quot;, 0, 1, 1, &amp;pcm);
        if (err &lt; 0)
                return err;
        pcm-&gt;private_data = chip;
        strcpy(pcm-&gt;name, &quot;My Chip&quot;);
        chip-&gt;pcm = pcm;
        ....
        return 0;
}
</pre></div>
</div>
<p>The <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_new" title="snd_pcm_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_new()</span></code></a> function takes four arguments. The
first argument is the card pointer to which this pcm is assigned, and
the second is the ID string.</p>
<p>The third argument (<code class="docutils literal notranslate"><span class="pre">index</span></code>, 0 in the above) is the index of this new
pcm. It begins from zero. If you create more than one pcm instances,
specify the different numbers in this argument. For example, <code class="docutils literal notranslate"><span class="pre">index</span> <span class="pre">=</span>
<span class="pre">1</span></code> for the second PCM device.</p>
<p>The fourth and fifth arguments are the number of substreams for playback
and capture, respectively. Here 1 is used for both arguments. When no
playback or capture substreams are available, pass 0 to the
corresponding argument.</p>
<p>If a chip supports multiple playbacks or captures, you can specify more
numbers, but they must be handled properly in open/close, etc.
callbacks. When you need to know which substream you are referring to,
then it can be obtained from struct snd_pcm_substream data passed to each
callback as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_pcm_substream *substream;
int index = substream-&gt;number;
</pre></div>
</div>
<p>After the pcm is created, you need to set operators for each pcm stream.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
                &amp;snd_mychip_playback_ops);
snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
                &amp;snd_mychip_capture_ops);
</pre></div>
</div>
<p>The operators are defined typically like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct snd_pcm_ops snd_mychip_playback_ops = {
        .open =        snd_mychip_pcm_open,
        .close =       snd_mychip_pcm_close,
        .hw_params =   snd_mychip_pcm_hw_params,
        .hw_free =     snd_mychip_pcm_hw_free,
        .prepare =     snd_mychip_pcm_prepare,
        .trigger =     snd_mychip_pcm_trigger,
        .pointer =     snd_mychip_pcm_pointer,
};
</pre></div>
</div>
<p>All the callbacks are described in the <a class="reference internal" href="#operators">Operators</a> subsection.</p>
<p>After setting the operators, you probably will want to pre-allocate the
buffer and set up the managed allocation mode.
For that, simply call the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
                               &amp;chip-&gt;pci-&gt;dev,
                               64*1024, 64*1024);
</pre></div>
</div>
<p>It will allocate a buffer up to 64kB as default. Buffer management
details will be described in the later section <a class="reference internal" href="#buffer-and-memory-management">Buffer and Memory
Management</a>.</p>
<p>Additionally, you can set some extra information for this pcm in
<code class="docutils literal notranslate"><span class="pre">pcm-&gt;info_flags</span></code>. The available values are defined as
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_XXX</span></code> in <code class="docutils literal notranslate"><span class="pre">&lt;sound/asound.h&gt;</span></code>, which is used for the
hardware definition (described later). When your soundchip supports only
half-duplex, specify like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pcm-&gt;info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;
</pre></div>
</div>
</section>
<section id="and-the-destructor">
<h3>… And the Destructor?<a class="headerlink" href="#and-the-destructor" title="Permalink to this headline">¶</a></h3>
<p>The destructor for a pcm instance is not always necessary. Since the pcm
device will be released by the middle layer code automatically, you
don’t have to call the destructor explicitly.</p>
<p>The destructor would be necessary if you created special records
internally and needed to release them. In such a case, set the
destructor function to <code class="docutils literal notranslate"><span class="pre">pcm-&gt;private_free</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void mychip_pcm_free(struct snd_pcm *pcm)
{
        struct mychip *chip = snd_pcm_chip(pcm);
        /* free your own data */
        kfree(chip-&gt;my_private_pcm_data);
        /* do what you like else */
        ....
}

static int snd_mychip_new_pcm(struct mychip *chip)
{
        struct snd_pcm *pcm;
        ....
        /* allocate your own data */
        chip-&gt;my_private_pcm_data = kmalloc(...);
        /* set the destructor */
        pcm-&gt;private_data = chip;
        pcm-&gt;private_free = mychip_pcm_free;
        ....
}
</pre></div>
</div>
</section>
<section id="runtime-pointer-the-chest-of-pcm-information">
<h3>Runtime Pointer - The Chest of PCM Information<a class="headerlink" href="#runtime-pointer-the-chest-of-pcm-information" title="Permalink to this headline">¶</a></h3>
<p>When the PCM substream is opened, a PCM runtime instance is allocated
and assigned to the substream. This pointer is accessible via
<code class="docutils literal notranslate"><span class="pre">substream-&gt;runtime</span></code>. This runtime pointer holds most information you
need to control the PCM: the copy of hw_params and sw_params
configurations, the buffer pointers, mmap records, spinlocks, etc.</p>
<p>The definition of runtime instance is found in <code class="docutils literal notranslate"><span class="pre">&lt;sound/pcm.h&gt;</span></code>. Here
are the contents of this file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct _snd_pcm_runtime {
        /* -- Status -- */
        struct snd_pcm_substream *trigger_master;
        snd_timestamp_t trigger_tstamp;       /* trigger timestamp */
        int overrange;
        snd_pcm_uframes_t avail_max;
        snd_pcm_uframes_t hw_ptr_base;        /* Position at buffer restart */
        snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time*/

        /* -- HW params -- */
        snd_pcm_access_t access;      /* access mode */
        snd_pcm_format_t format;      /* SNDRV_PCM_FORMAT_* */
        snd_pcm_subformat_t subformat;        /* subformat */
        unsigned int rate;            /* rate in Hz */
        unsigned int channels;                /* channels */
        snd_pcm_uframes_t period_size;        /* period size */
        unsigned int periods;         /* periods */
        snd_pcm_uframes_t buffer_size;        /* buffer size */
        unsigned int tick_time;               /* tick time */
        snd_pcm_uframes_t min_align;  /* Min alignment for the format */
        size_t byte_align;
        unsigned int frame_bits;
        unsigned int sample_bits;
        unsigned int info;
        unsigned int rate_num;
        unsigned int rate_den;

        /* -- SW params -- */
        struct timespec tstamp_mode;  /* mmap timestamp is updated */
        unsigned int period_step;
        unsigned int sleep_min;               /* min ticks to sleep */
        snd_pcm_uframes_t start_threshold;
        snd_pcm_uframes_t stop_threshold;
        snd_pcm_uframes_t silence_threshold; /* Silence filling happens when
                                                noise is nearest than this */
        snd_pcm_uframes_t silence_size;       /* Silence filling size */
        snd_pcm_uframes_t boundary;   /* pointers wrap point */

        snd_pcm_uframes_t silenced_start;
        snd_pcm_uframes_t silenced_size;

        snd_pcm_sync_id_t sync;               /* hardware synchronization ID */

        /* -- mmap -- */
        volatile struct snd_pcm_mmap_status *status;
        volatile struct snd_pcm_mmap_control *control;
        atomic_t mmap_count;

        /* -- locking / scheduling -- */
        spinlock_t lock;
        wait_queue_head_t sleep;
        struct timer_list tick_timer;
        struct fasync_struct *fasync;

        /* -- private section -- */
        void *private_data;
        void (*private_free)(struct snd_pcm_runtime *runtime);

        /* -- hardware description -- */
        struct snd_pcm_hardware hw;
        struct snd_pcm_hw_constraints hw_constraints;

        /* -- timer -- */
        unsigned int timer_resolution;        /* timer resolution */

        /* -- DMA -- */
        unsigned char *dma_area;      /* DMA area */
        dma_addr_t dma_addr;          /* physical bus address (not accessible from main CPU) */
        size_t dma_bytes;             /* size of DMA area */

        struct snd_dma_buffer *dma_buffer_p;  /* allocated buffer */

#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
        /* -- OSS things -- */
        struct snd_pcm_oss_runtime oss;
#endif
};
</pre></div>
</div>
<p>For the operators (callbacks) of each sound driver, most of these
records are supposed to be read-only. Only the PCM middle-layer changes
/ updates them. The exceptions are the hardware description (hw) DMA
buffer information and the private data. Besides, if you use the
standard managed buffer allocation mode, you don’t need to set the
DMA buffer information by yourself.</p>
<p>In the sections below, important records are explained.</p>
<section id="hardware-description">
<h4>Hardware Description<a class="headerlink" href="#hardware-description" title="Permalink to this headline">¶</a></h4>
<p>The hardware descriptor (struct snd_pcm_hardware) contains the definitions of
the fundamental hardware configuration. Above all, you’ll need to define this
in the <a class="reference internal" href="#pcm-open-callback">PCM open callback</a>. Note that the runtime instance holds the copy of
the descriptor, not the pointer to the existing descriptor. That is,
in the open callback, you can modify the copied descriptor
(<code class="docutils literal notranslate"><span class="pre">runtime-&gt;hw</span></code>) as you need. For example, if the maximum number of
channels is 1 only on some chip models, you can still use the same
hardware descriptor and change the channels_max later:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_pcm_runtime *runtime = substream-&gt;runtime;
...
runtime-&gt;hw = snd_mychip_playback_hw; /* common definition */
if (chip-&gt;model == VERY_OLD_ONE)
        runtime-&gt;hw.channels_max = 1;
</pre></div>
</div>
<p>Typically, you’ll have a hardware descriptor as below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct snd_pcm_hardware snd_mychip_playback_hw = {
        .info = (SNDRV_PCM_INFO_MMAP |
                 SNDRV_PCM_INFO_INTERLEAVED |
                 SNDRV_PCM_INFO_BLOCK_TRANSFER |
                 SNDRV_PCM_INFO_MMAP_VALID),
        .formats =          SNDRV_PCM_FMTBIT_S16_LE,
        .rates =            SNDRV_PCM_RATE_8000_48000,
        .rate_min =         8000,
        .rate_max =         48000,
        .channels_min =     2,
        .channels_max =     2,
        .buffer_bytes_max = 32768,
        .period_bytes_min = 4096,
        .period_bytes_max = 32768,
        .periods_min =      1,
        .periods_max =      1024,
};
</pre></div>
</div>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">info</span></code> field contains the type and capabilities of this
pcm. The bit flags are defined in <code class="docutils literal notranslate"><span class="pre">&lt;sound/asound.h&gt;</span></code> as
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_XXX</span></code>. Here, at least, you have to specify whether
the mmap is supported and which interleaved format is
supported. When the hardware supports mmap, add the
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_MMAP</span></code> flag here. When the hardware supports the
interleaved or the non-interleaved formats,
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_INTERLEAVED</span></code> or <code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_NONINTERLEAVED</span></code>
flag must be set, respectively. If both are supported, you can set
both, too.</p>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">MMAP_VALID</span></code> and <code class="docutils literal notranslate"><span class="pre">BLOCK_TRANSFER</span></code> are
specified for the OSS mmap mode. Usually both are set. Of course,
<code class="docutils literal notranslate"><span class="pre">MMAP_VALID</span></code> is set only if the mmap is really supported.</p>
<p>The other possible flags are <code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_PAUSE</span></code> and
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_RESUME</span></code>. The <code class="docutils literal notranslate"><span class="pre">PAUSE</span></code> bit means that the pcm
supports the “pause” operation, while the <code class="docutils literal notranslate"><span class="pre">RESUME</span></code> bit means that
the pcm supports the full “suspend/resume” operation. If the
<code class="docutils literal notranslate"><span class="pre">PAUSE</span></code> flag is set, the <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback below must handle
the corresponding (pause push/release) commands. The suspend/resume
trigger commands can be defined even without the <code class="docutils literal notranslate"><span class="pre">RESUME</span></code>
flag. See <a class="reference internal" href="#power-management">Power Management</a> section for details.</p>
<p>When the PCM substreams can be synchronized (typically,
synchronized start/stop of a playback and a capture streams), you
can give <code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_SYNC_START</span></code>, too. In this case, you’ll
need to check the linked-list of PCM substreams in the trigger
callback. This will be described in the later section.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">formats</span></code> field contains the bit-flags of supported formats
(<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_FMTBIT_XXX</span></code>). If the hardware supports more than one
format, give all or’ed bits. In the example above, the signed 16bit
little-endian format is specified.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rates</span></code> field contains the bit-flags of supported rates
(<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_RATE_XXX</span></code>). When the chip supports continuous rates,
pass <code class="docutils literal notranslate"><span class="pre">CONTINUOUS</span></code> bit additionally. The pre-defined rate bits are
provided only for typical rates. If your chip supports
unconventional rates, you need to add the <code class="docutils literal notranslate"><span class="pre">KNOT</span></code> bit and set up
the hardware constraint manually (explained later).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rate_min</span></code> and <code class="docutils literal notranslate"><span class="pre">rate_max</span></code> define the minimum and maximum sample
rate. This should correspond somehow to <code class="docutils literal notranslate"><span class="pre">rates</span></code> bits.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">channel_min</span></code> and <code class="docutils literal notranslate"><span class="pre">channel_max</span></code> define, as you might already
expected, the minimum and maximum number of channels.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">buffer_bytes_max</span></code> defines the maximum buffer size in
bytes. There is no <code class="docutils literal notranslate"><span class="pre">buffer_bytes_min</span></code> field, since it can be
calculated from the minimum period size and the minimum number of
periods. Meanwhile, <code class="docutils literal notranslate"><span class="pre">period_bytes_min</span></code> and define the minimum and
maximum size of the period in bytes. <code class="docutils literal notranslate"><span class="pre">periods_max</span></code> and
<code class="docutils literal notranslate"><span class="pre">periods_min</span></code> define the maximum and minimum number of periods in
the buffer.</p>
<p>The “period” is a term that corresponds to a fragment in the OSS
world. The period defines the size at which a PCM interrupt is
generated. This size strongly depends on the hardware. Generally,
the smaller period size will give you more interrupts, that is,
more controls. In the case of capture, this size defines the input
latency. On the other hand, the whole buffer size defines the
output latency for the playback direction.</p>
</li>
<li><p>There is also a field <code class="docutils literal notranslate"><span class="pre">fifo_size</span></code>. This specifies the size of the
hardware FIFO, but currently it is neither used in the driver nor
in the alsa-lib. So, you can ignore this field.</p></li>
</ul>
</section>
<section id="pcm-configurations">
<h4>PCM Configurations<a class="headerlink" href="#pcm-configurations" title="Permalink to this headline">¶</a></h4>
<p>Ok, let’s go back again to the PCM runtime records. The most
frequently referred records in the runtime instance are the PCM
configurations. The PCM configurations are stored in the runtime
instance after the application sends <code class="docutils literal notranslate"><span class="pre">hw_params</span></code> data via
alsa-lib. There are many fields copied from hw_params and sw_params
structs. For example, <code class="docutils literal notranslate"><span class="pre">format</span></code> holds the format type chosen by the
application. This field contains the enum value
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_FORMAT_XXX</span></code>.</p>
<p>One thing to be noted is that the configured buffer and period sizes
are stored in “frames” in the runtime. In the ALSA world, <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">frame</span> <span class="pre">=</span>
<span class="pre">channels</span> <span class="pre">\*</span> <span class="pre">samples-size</span></code>. For conversion between frames and bytes,
you can use the <a class="reference internal" href="alsa-driver-api.html#c.frames_to_bytes" title="frames_to_bytes"><code class="xref c c-func docutils literal notranslate"><span class="pre">frames_to_bytes()</span></code></a> and
<a class="reference internal" href="alsa-driver-api.html#c.bytes_to_frames" title="bytes_to_frames"><code class="xref c c-func docutils literal notranslate"><span class="pre">bytes_to_frames()</span></code></a> helper functions.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>period_bytes = frames_to_bytes(runtime, runtime-&gt;period_size);
</pre></div>
</div>
<p>Also, many software parameters (sw_params) are stored in frames, too.
Please check the type of the field. <code class="docutils literal notranslate"><span class="pre">snd_pcm_uframes_t</span></code> is for the
frames as unsigned integer while <code class="docutils literal notranslate"><span class="pre">snd_pcm_sframes_t</span></code> is for the
frames as signed integer.</p>
</section>
<section id="dma-buffer-information">
<h4>DMA Buffer Information<a class="headerlink" href="#dma-buffer-information" title="Permalink to this headline">¶</a></h4>
<p>The DMA buffer is defined by the following four fields, <code class="docutils literal notranslate"><span class="pre">dma_area</span></code>,
<code class="docutils literal notranslate"><span class="pre">dma_addr</span></code>, <code class="docutils literal notranslate"><span class="pre">dma_bytes</span></code> and <code class="docutils literal notranslate"><span class="pre">dma_private</span></code>. The <code class="docutils literal notranslate"><span class="pre">dma_area</span></code>
holds the buffer pointer (the logical address). You can call
<a class="reference internal" href="../../core-api/kernel-api.html#c.memcpy" title="memcpy"><code class="xref c c-func docutils literal notranslate"><span class="pre">memcpy()</span></code></a> from/to this pointer. Meanwhile, <code class="docutils literal notranslate"><span class="pre">dma_addr</span></code> holds
the physical address of the buffer. This field is specified only when
the buffer is a linear buffer. <code class="docutils literal notranslate"><span class="pre">dma_bytes</span></code> holds the size of buffer
in bytes. <code class="docutils literal notranslate"><span class="pre">dma_private</span></code> is used for the ALSA DMA allocator.</p>
<p>If you use either the managed buffer allocation mode or the standard
API function <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> for allocating the buffer,
these fields are set by the ALSA middle layer, and you should <em>not</em>
change them by yourself. You can read them but not write them. On the
other hand, if you want to allocate the buffer by yourself, you’ll
need to manage it in hw_params callback. At least, <code class="docutils literal notranslate"><span class="pre">dma_bytes</span></code> is
mandatory. <code class="docutils literal notranslate"><span class="pre">dma_area</span></code> is necessary when the buffer is mmapped. If
your driver doesn’t support mmap, this field is not
necessary. <code class="docutils literal notranslate"><span class="pre">dma_addr</span></code> is also optional. You can use dma_private as
you like, too.</p>
</section>
<section id="running-status">
<h4>Running Status<a class="headerlink" href="#running-status" title="Permalink to this headline">¶</a></h4>
<p>The running status can be referred via <code class="docutils literal notranslate"><span class="pre">runtime-&gt;status</span></code>. This is
the pointer to the struct snd_pcm_mmap_status record.
For example, you can get the current
DMA hardware pointer via <code class="docutils literal notranslate"><span class="pre">runtime-&gt;status-&gt;hw_ptr</span></code>.</p>
<p>The DMA application pointer can be referred via <code class="docutils literal notranslate"><span class="pre">runtime-&gt;control</span></code>,
which points to the struct snd_pcm_mmap_control record.
However, accessing directly to this value is not recommended.</p>
</section>
<section id="private-data">
<h4>Private Data<a class="headerlink" href="#private-data" title="Permalink to this headline">¶</a></h4>
<p>You can allocate a record for the substream and store it in
<code class="docutils literal notranslate"><span class="pre">runtime-&gt;private_data</span></code>. Usually, this is done in the <a class="reference internal" href="#pcm-open-callback">PCM open
callback</a>. Don’t mix this with <code class="docutils literal notranslate"><span class="pre">pcm-&gt;private_data</span></code>. The
<code class="docutils literal notranslate"><span class="pre">pcm-&gt;private_data</span></code> usually points to the chip instance assigned
statically at the creation of PCM, while the <code class="docutils literal notranslate"><span class="pre">runtime-&gt;private_data</span></code>
points to a dynamic data structure created at the PCM open
callback.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_open(struct snd_pcm_substream *substream)
{
        struct my_pcm_data *data;
        ....
        data = kmalloc(sizeof(*data), GFP_KERNEL);
        substream-&gt;runtime-&gt;private_data = data;
        ....
}
</pre></div>
</div>
<p>The allocated object must be released in the <a class="reference internal" href="#close-callback">close callback</a>.</p>
</section>
</section>
<section id="operators">
<h3>Operators<a class="headerlink" href="#operators" title="Permalink to this headline">¶</a></h3>
<p>OK, now let me give details about each pcm callback (<code class="docutils literal notranslate"><span class="pre">ops</span></code>). In
general, every callback must return 0 if successful, or a negative
error number such as <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code>. To choose an appropriate error
number, it is advised to check what value other parts of the kernel
return when the same kind of request fails.</p>
<p>The callback function takes at least the argument with
struct snd_pcm_substream pointer. To retrieve the chip
record from the given substream instance, you can use the following
macro.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int xxx() {
        struct mychip *chip = snd_pcm_substream_chip(substream);
        ....
}
</pre></div>
</div>
<p>The macro reads <code class="docutils literal notranslate"><span class="pre">substream-&gt;private_data</span></code>, which is a copy of
<code class="docutils literal notranslate"><span class="pre">pcm-&gt;private_data</span></code>. You can override the former if you need to
assign different data records per PCM substream. For example, the
cmi8330 driver assigns different <code class="docutils literal notranslate"><span class="pre">private_data</span></code> for playback and
capture directions, because it uses two different codecs (SB- and
AD-compatible) for different directions.</p>
<section id="pcm-open-callback">
<h4>PCM open callback<a class="headerlink" href="#pcm-open-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_open(struct snd_pcm_substream *substream);
</pre></div>
</div>
<p>This is called when a pcm substream is opened.</p>
<p>At least, here you have to initialize the <code class="docutils literal notranslate"><span class="pre">runtime-&gt;hw</span></code>
record. Typically, this is done by like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_open(struct snd_pcm_substream *substream)
{
        struct mychip *chip = snd_pcm_substream_chip(substream);
        struct snd_pcm_runtime *runtime = substream-&gt;runtime;

        runtime-&gt;hw = snd_mychip_playback_hw;
        return 0;
}
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">snd_mychip_playback_hw</span></code> is the pre-defined hardware
description.</p>
<p>You can allocate a private data in this callback, as described in
<a class="reference internal" href="#private-data">Private Data</a> section.</p>
<p>If the hardware configuration needs more constraints, set the hardware
constraints here, too. See <a class="reference internal" href="#constraints">Constraints</a> for more details.</p>
</section>
<section id="close-callback">
<h4>close callback<a class="headerlink" href="#close-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_close(struct snd_pcm_substream *substream);
</pre></div>
</div>
<p>Obviously, this is called when a pcm substream is closed.</p>
<p>Any private instance for a pcm substream allocated in the <code class="docutils literal notranslate"><span class="pre">open</span></code>
callback will be released here.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_close(struct snd_pcm_substream *substream)
{
        ....
        kfree(substream-&gt;runtime-&gt;private_data);
        ....
}
</pre></div>
</div>
</section>
<section id="ioctl-callback">
<h4>ioctl callback<a class="headerlink" href="#ioctl-callback" title="Permalink to this headline">¶</a></h4>
<p>This is used for any special call to pcm ioctls. But usually you can
leave it as NULL, then PCM core calls the generic ioctl callback
function <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_lib_ioctl" title="snd_pcm_lib_ioctl"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_ioctl()</span></code></a>.  If you need to deal with the
unique setup of channel info or reset procedure, you can pass your own
callback function here.</p>
</section>
<section id="hw-params-callback">
<h4>hw_params callback<a class="headerlink" href="#hw-params-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_hw_params(struct snd_pcm_substream *substream,
                             struct snd_pcm_hw_params *hw_params);
</pre></div>
</div>
<p>This is called when the hardware parameter (<code class="docutils literal notranslate"><span class="pre">hw_params</span></code>) is set up
by the application, that is, once when the buffer size, the period
size, the format, etc. are defined for the pcm substream.</p>
<p>Many hardware setups should be done in this callback, including the
allocation of buffers.</p>
<p>Parameters to be initialized are retrieved by
<code class="xref c c-func docutils literal notranslate"><span class="pre">params_xxx()</span></code> macros.</p>
<p>When you set up the managed buffer allocation mode for the substream,
a buffer is already allocated before this callback gets
called. Alternatively, you can call a helper function below for
allocating the buffer, too.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
</pre></div>
</div>
<p><a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> is available only when the
DMA buffers have been pre-allocated. See the section <a class="reference internal" href="#buffer-types">Buffer Types</a>
for more details.</p>
<p>Note that this and <code class="docutils literal notranslate"><span class="pre">prepare</span></code> callbacks may be called multiple times
per initialization. For example, the OSS emulation may call these
callbacks at each change via its ioctl.</p>
<p>Thus, you need to be careful not to allocate the same buffers many
times, which will lead to memory leaks! Calling the helper function
above many times is OK. It will release the previous buffer
automatically when it was already allocated.</p>
<p>Another note is that this callback is non-atomic (schedulable) as
default, i.e. when no <code class="docutils literal notranslate"><span class="pre">nonatomic</span></code> flag set. This is important,
because the <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback is atomic (non-schedulable). That is,
mutexes or any schedule-related functions are not available in
<code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback. Please see the subsection <a class="reference internal" href="#atomicity">Atomicity</a> for
details.</p>
</section>
<section id="hw-free-callback">
<h4>hw_free callback<a class="headerlink" href="#hw-free-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_hw_free(struct snd_pcm_substream *substream);
</pre></div>
</div>
<p>This is called to release the resources allocated via
<code class="docutils literal notranslate"><span class="pre">hw_params</span></code>.</p>
<p>This function is always called before the close callback is called.
Also, the callback may be called multiple times, too. Keep track
whether the resource was already released.</p>
<p>When you have set up the managed buffer allocation mode for the PCM
substream, the allocated PCM buffer will be automatically released
after this callback gets called.  Otherwise you’ll have to release the
buffer manually.  Typically, when the buffer was allocated from the
pre-allocated pool, you can use the standard API function
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_lib_free_pages(substream);
</pre></div>
</div>
</section>
<section id="prepare-callback">
<h4>prepare callback<a class="headerlink" href="#prepare-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_prepare(struct snd_pcm_substream *substream);
</pre></div>
</div>
<p>This callback is called when the pcm is “prepared”. You can set the
format type, sample rate, etc. here. The difference from <code class="docutils literal notranslate"><span class="pre">hw_params</span></code>
is that the <code class="docutils literal notranslate"><span class="pre">prepare</span></code> callback will be called each time
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_prepare" title="snd_pcm_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_prepare()</span></code></a> is called, i.e. when recovering after
underruns, etc.</p>
<p>Note that this callback is now non-atomic. You can use
schedule-related functions safely in this callback.</p>
<p>In this and the following callbacks, you can refer to the values via
the runtime record, <code class="docutils literal notranslate"><span class="pre">substream-&gt;runtime</span></code>. For example, to get the
current rate, format or channels, access to <code class="docutils literal notranslate"><span class="pre">runtime-&gt;rate</span></code>,
<code class="docutils literal notranslate"><span class="pre">runtime-&gt;format</span></code> or <code class="docutils literal notranslate"><span class="pre">runtime-&gt;channels</span></code>, respectively. The
physical address of the allocated buffer is set to
<code class="docutils literal notranslate"><span class="pre">runtime-&gt;dma_area</span></code>. The buffer and period sizes are in
<code class="docutils literal notranslate"><span class="pre">runtime-&gt;buffer_size</span></code> and <code class="docutils literal notranslate"><span class="pre">runtime-&gt;period_size</span></code>, respectively.</p>
<p>Be careful that this callback will be called many times at each setup,
too.</p>
</section>
<section id="trigger-callback">
<h4>trigger callback<a class="headerlink" href="#trigger-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_trigger(struct snd_pcm_substream *substream, int cmd);
</pre></div>
</div>
<p>This is called when the pcm is started, stopped or paused.</p>
<p>Which action is specified in the second argument,
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_TRIGGER_XXX</span></code> in <code class="docutils literal notranslate"><span class="pre">&lt;sound/pcm.h&gt;</span></code>. At least, the <code class="docutils literal notranslate"><span class="pre">START</span></code>
and <code class="docutils literal notranslate"><span class="pre">STOP</span></code> commands must be defined in this callback.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>switch (cmd) {
case SNDRV_PCM_TRIGGER_START:
        /* do something to start the PCM engine */
        break;
case SNDRV_PCM_TRIGGER_STOP:
        /* do something to stop the PCM engine */
        break;
default:
        return -EINVAL;
}
</pre></div>
</div>
<p>When the pcm supports the pause operation (given in the info field of
the hardware table), the <code class="docutils literal notranslate"><span class="pre">PAUSE_PUSH</span></code> and <code class="docutils literal notranslate"><span class="pre">PAUSE_RELEASE</span></code> commands
must be handled here, too. The former is the command to pause the pcm,
and the latter to restart the pcm again.</p>
<p>When the pcm supports the suspend/resume operation, regardless of full
or partial suspend/resume support, the <code class="docutils literal notranslate"><span class="pre">SUSPEND</span></code> and <code class="docutils literal notranslate"><span class="pre">RESUME</span></code>
commands must be handled, too. These commands are issued when the
power-management status is changed. Obviously, the <code class="docutils literal notranslate"><span class="pre">SUSPEND</span></code> and
<code class="docutils literal notranslate"><span class="pre">RESUME</span></code> commands suspend and resume the pcm substream, and usually,
they are identical to the <code class="docutils literal notranslate"><span class="pre">STOP</span></code> and <code class="docutils literal notranslate"><span class="pre">START</span></code> commands, respectively.
See the <a class="reference internal" href="#power-management">Power Management</a> section for details.</p>
<p>As mentioned, this callback is atomic as default unless <code class="docutils literal notranslate"><span class="pre">nonatomic</span></code>
flag set, and you cannot call functions which may sleep. The
<code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback should be as minimal as possible, just really
triggering the DMA. The other stuff should be initialized
<code class="docutils literal notranslate"><span class="pre">hw_params</span></code> and <code class="docutils literal notranslate"><span class="pre">prepare</span></code> callbacks properly beforehand.</p>
</section>
<section id="sync-stop-callback">
<h4>sync_stop callback<a class="headerlink" href="#sync-stop-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_sync_stop(struct snd_pcm_substream *substream);
</pre></div>
</div>
<p>This callback is optional, and NULL can be passed.  It’s called after
the PCM core stops the stream and changes the stream state
<code class="docutils literal notranslate"><span class="pre">prepare</span></code>, <code class="docutils literal notranslate"><span class="pre">hw_params</span></code> or <code class="docutils literal notranslate"><span class="pre">hw_free</span></code>.
Since the IRQ handler might be still pending, we need to wait until
the pending task finishes before moving to the next step; otherwise it
might lead to a crash due to resource conflicts or access to the freed
resources.  A typical behavior is to call a synchronization function
like <a class="reference internal" href="../../core-api/genericirq.html#c.synchronize_irq" title="synchronize_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_irq()</span></code></a> here.</p>
<p>For majority of drivers that need only a call of
<a class="reference internal" href="../../core-api/genericirq.html#c.synchronize_irq" title="synchronize_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_irq()</span></code></a>, there is a simpler setup, too.
While keeping NULL to <code class="docutils literal notranslate"><span class="pre">sync_stop</span></code> PCM callback, the driver can set
<code class="docutils literal notranslate"><span class="pre">card-&gt;sync_irq</span></code> field to store the valid interrupt number after
requesting an IRQ, instead.   Then PCM core will look call
<a class="reference internal" href="../../core-api/genericirq.html#c.synchronize_irq" title="synchronize_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_irq()</span></code></a> with the given IRQ appropriately.</p>
<p>If the IRQ handler is released at the card destructor, you don’t need
to clear <code class="docutils literal notranslate"><span class="pre">card-&gt;sync_irq</span></code>, as the card itself is being released.
So, usually you’ll need to add just a single line for assigning
<code class="docutils literal notranslate"><span class="pre">card-&gt;sync_irq</span></code> in the driver code unless the driver re-acquires
the IRQ.  When the driver frees and re-acquires the IRQ dynamically
(e.g. for suspend/resume), it needs to clear and re-set
<code class="docutils literal notranslate"><span class="pre">card-&gt;sync_irq</span></code> again appropriately.</p>
</section>
<section id="pointer-callback">
<h4>pointer callback<a class="headerlink" href="#pointer-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static snd_pcm_uframes_t snd_xxx_pointer(struct snd_pcm_substream *substream)
</pre></div>
</div>
<p>This callback is called when the PCM middle layer inquires the current
hardware position on the buffer. The position must be returned in
frames, ranging from 0 to <code class="docutils literal notranslate"><span class="pre">buffer_size</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
<p>This is called usually from the buffer-update routine in the pcm
middle layer, which is invoked when <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a>
is called in the interrupt routine. Then the pcm middle layer updates
the position and calculates the available space, and wakes up the
sleeping poll threads, etc.</p>
<p>This callback is also atomic as default.</p>
</section>
<section id="copy-user-copy-kernel-and-fill-silence-ops">
<h4>copy_user, copy_kernel and fill_silence ops<a class="headerlink" href="#copy-user-copy-kernel-and-fill-silence-ops" title="Permalink to this headline">¶</a></h4>
<p>These callbacks are not mandatory, and can be omitted in most cases.
These callbacks are used when the hardware buffer cannot be in the
normal memory space. Some chips have their own buffer on the hardware
which is not mappable. In such a case, you have to transfer the data
manually from the memory buffer to the hardware buffer. Or, if the
buffer is non-contiguous on both physical and virtual memory spaces,
these callbacks must be defined, too.</p>
<p>If these two callbacks are defined, copy and set-silence operations
are done by them. The detailed will be described in the later section
<a class="reference internal" href="#buffer-and-memory-management">Buffer and Memory Management</a>.</p>
</section>
<section id="ack-callback">
<h4>ack callback<a class="headerlink" href="#ack-callback" title="Permalink to this headline">¶</a></h4>
<p>This callback is also not mandatory. This callback is called when the
<code class="docutils literal notranslate"><span class="pre">appl_ptr</span></code> is updated in read or write operations. Some drivers like
emu10k1-fx and cs46xx need to track the current <code class="docutils literal notranslate"><span class="pre">appl_ptr</span></code> for the
internal buffer, and this callback is useful only for such a purpose.</p>
<p>This callback is atomic as default.</p>
</section>
<section id="page-callback">
<h4>page callback<a class="headerlink" href="#page-callback" title="Permalink to this headline">¶</a></h4>
<p>This callback is optional too. The mmap calls this callback to get the
page fault address.</p>
<p>Since the recent changes, you need no special callback any longer for
the standard SG-buffer or vmalloc-buffer. Hence this callback should
be rarely used.</p>
</section>
<section id="mmap-calllback">
<h4>mmap calllback<a class="headerlink" href="#mmap-calllback" title="Permalink to this headline">¶</a></h4>
<p>This is another optional callback for controlling mmap behavior.
Once when defined, PCM core calls this callback when a page is
memory-mapped instead of dealing via the standard helper.
If you need special handling (due to some architecture or
device-specific issues), implement everything here as you like.</p>
</section>
</section>
<section id="pcm-interrupt-handler">
<h3>PCM Interrupt Handler<a class="headerlink" href="#pcm-interrupt-handler" title="Permalink to this headline">¶</a></h3>
<p>The rest of pcm stuff is the PCM interrupt handler. The role of PCM
interrupt handler in the sound driver is to update the buffer position
and to tell the PCM middle layer when the buffer position goes across
the prescribed period size. To inform this, call the
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> function.</p>
<p>There are several types of sound chips to generate the interrupts.</p>
<section id="interrupts-at-the-period-fragment-boundary">
<h4>Interrupts at the period (fragment) boundary<a class="headerlink" href="#interrupts-at-the-period-fragment-boundary" title="Permalink to this headline">¶</a></h4>
<p>This is the most frequently found type: the hardware generates an
interrupt at each period boundary. In this case, you can call
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> at each interrupt.</p>
<p><a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> takes the substream pointer as
its argument. Thus, you need to keep the substream pointer accessible
from the chip instance. For example, define <code class="docutils literal notranslate"><span class="pre">substream</span></code> field in the
chip record to hold the current running substream pointer, and set the
pointer value at <code class="docutils literal notranslate"><span class="pre">open</span></code> callback (and reset at <code class="docutils literal notranslate"><span class="pre">close</span></code> callback).</p>
<p>If you acquire a spinlock in the interrupt handler, and the lock is used
in other pcm callbacks, too, then you have to release the lock before
calling <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a>, because
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> calls other pcm callbacks
inside.</p>
<p>Typical code would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
{
        struct mychip *chip = dev_id;
        spin_lock(&amp;chip-&gt;lock);
        ....
        if (pcm_irq_invoked(chip)) {
                /* call updater, unlock before it */
                spin_unlock(&amp;chip-&gt;lock);
                snd_pcm_period_elapsed(chip-&gt;substream);
                spin_lock(&amp;chip-&gt;lock);
                /* acknowledge the interrupt if necessary */
        }
        ....
        spin_unlock(&amp;chip-&gt;lock);
        return IRQ_HANDLED;
}
</pre></div>
</div>
</section>
<section id="high-frequency-timer-interrupts">
<h4>High frequency timer interrupts<a class="headerlink" href="#high-frequency-timer-interrupts" title="Permalink to this headline">¶</a></h4>
<p>This happens when the hardware doesn’t generate interrupts at the period
boundary but issues timer interrupts at a fixed timer rate (e.g. es1968
or ymfpci drivers). In this case, you need to check the current hardware
position and accumulate the processed sample length at each interrupt.
When the accumulated size exceeds the period size, call
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> and reset the accumulator.</p>
<p>Typical code would be like the following.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
{
        struct mychip *chip = dev_id;
        spin_lock(&amp;chip-&gt;lock);
        ....
        if (pcm_irq_invoked(chip)) {
                unsigned int last_ptr, size;
                /* get the current hardware pointer (in frames) */
                last_ptr = get_hw_ptr(chip);
                /* calculate the processed frames since the
                 * last update
                 */
                if (last_ptr &lt; chip-&gt;last_ptr)
                        size = runtime-&gt;buffer_size + last_ptr
                                 - chip-&gt;last_ptr;
                else
                        size = last_ptr - chip-&gt;last_ptr;
                /* remember the last updated point */
                chip-&gt;last_ptr = last_ptr;
                /* accumulate the size */
                chip-&gt;size += size;
                /* over the period boundary? */
                if (chip-&gt;size &gt;= runtime-&gt;period_size) {
                        /* reset the accumulator */
                        chip-&gt;size %= runtime-&gt;period_size;
                        /* call updater */
                        spin_unlock(&amp;chip-&gt;lock);
                        snd_pcm_period_elapsed(substream);
                        spin_lock(&amp;chip-&gt;lock);
                }
                /* acknowledge the interrupt if necessary */
        }
        ....
        spin_unlock(&amp;chip-&gt;lock);
        return IRQ_HANDLED;
}
</pre></div>
</div>
</section>
<section id="on-calling-snd-pcm-period-elapsed">
<h4>On calling <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a><a class="headerlink" href="#on-calling-snd-pcm-period-elapsed" title="Permalink to this headline">¶</a></h4>
<p>In both cases, even if more than one period are elapsed, you don’t have
to call <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> many times. Call only
once. And the pcm layer will check the current hardware pointer and
update to the latest status.</p>
</section>
</section>
<section id="atomicity">
<h3>Atomicity<a class="headerlink" href="#atomicity" title="Permalink to this headline">¶</a></h3>
<p>One of the most important (and thus difficult to debug) problems in
kernel programming are race conditions. In the Linux kernel, they are
usually avoided via spin-locks, mutexes or semaphores. In general, if a
race condition can happen in an interrupt handler, it has to be managed
atomically, and you have to use a spinlock to protect the critical
session. If the critical section is not in interrupt handler code and if
taking a relatively long time to execute is acceptable, you should use
mutexes or semaphores instead.</p>
<p>As already seen, some pcm callbacks are atomic and some are not. For
example, the <code class="docutils literal notranslate"><span class="pre">hw_params</span></code> callback is non-atomic, while <code class="docutils literal notranslate"><span class="pre">trigger</span></code>
callback is atomic. This means, the latter is called already in a
spinlock held by the PCM middle layer. Please take this atomicity into
account when you choose a locking scheme in the callbacks.</p>
<p>In the atomic callbacks, you cannot use functions which may call
<code class="xref c c-func docutils literal notranslate"><span class="pre">schedule()</span></code> or go to <code class="xref c c-func docutils literal notranslate"><span class="pre">sleep()</span></code>. Semaphores and
mutexes can sleep, and hence they cannot be used inside the atomic
callbacks (e.g. <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback). To implement some delay in such a
callback, please use <code class="xref c c-func docutils literal notranslate"><span class="pre">udelay()</span></code> or <code class="xref c c-func docutils literal notranslate"><span class="pre">mdelay()</span></code>.</p>
<p>All three atomic callbacks (trigger, pointer, and ack) are called with
local interrupts disabled.</p>
<p>The recent changes in PCM core code, however, allow all PCM operations
to be non-atomic. This assumes that the all caller sides are in
non-atomic contexts. For example, the function
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_period_elapsed" title="snd_pcm_period_elapsed"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a> is called typically from the
interrupt handler. But, if you set up the driver to use a threaded
interrupt handler, this call can be in non-atomic context, too. In such
a case, you can set <code class="docutils literal notranslate"><span class="pre">nonatomic</span></code> filed of struct snd_pcm object
after creating it. When this flag is set, mutex and rwsem are used internally
in the PCM core instead of spin and rwlocks, so that you can call all PCM
functions safely in a non-atomic
context.</p>
</section>
<section id="constraints">
<h3>Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h3>
<p>If your chip supports unconventional sample rates, or only the limited
samples, you need to set a constraint for the condition.</p>
<p>For example, in order to restrict the sample rates in the some supported
values, use <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_hw_constraint_list" title="snd_pcm_hw_constraint_list"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_hw_constraint_list()</span></code></a>. You need to
call this function in the open callback.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static unsigned int rates[] =
        {4000, 10000, 22050, 44100};
static struct snd_pcm_hw_constraint_list constraints_rates = {
        .count = ARRAY_SIZE(rates),
        .list = rates,
        .mask = 0,
};

static int snd_mychip_pcm_open(struct snd_pcm_substream *substream)
{
        int err;
        ....
        err = snd_pcm_hw_constraint_list(substream-&gt;runtime, 0,
                                         SNDRV_PCM_HW_PARAM_RATE,
                                         &amp;constraints_rates);
        if (err &lt; 0)
                return err;
        ....
}
</pre></div>
</div>
<p>There are many different constraints. Look at <code class="docutils literal notranslate"><span class="pre">sound/pcm.h</span></code> for a
complete list. You can even define your own constraint rules. For
example, let’s suppose my_chip can manage a substream of 1 channel if
and only if the format is <code class="docutils literal notranslate"><span class="pre">S16_LE</span></code>, otherwise it supports any format
specified in struct snd_pcm_hardware&gt; (or in any other
constraint_list). You can build a rule like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int hw_rule_channels_by_format(struct snd_pcm_hw_params *params,
                                      struct snd_pcm_hw_rule *rule)
{
        struct snd_interval *c = hw_param_interval(params,
                      SNDRV_PCM_HW_PARAM_CHANNELS);
        struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
        struct snd_interval ch;

        snd_interval_any(&amp;ch);
        if (f-&gt;bits[0] == SNDRV_PCM_FMTBIT_S16_LE) {
                ch.min = ch.max = 1;
                ch.integer = 1;
                return snd_interval_refine(c, &amp;ch);
        }
        return 0;
}
</pre></div>
</div>
<p>Then you need to call this function to add your rule:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_hw_rule_add(substream-&gt;runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
                    hw_rule_channels_by_format, NULL,
                    SNDRV_PCM_HW_PARAM_FORMAT, -1);
</pre></div>
</div>
<p>The rule function is called when an application sets the PCM format, and
it refines the number of channels accordingly. But an application may
set the number of channels before setting the format. Thus you also need
to define the inverse rule:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int hw_rule_format_by_channels(struct snd_pcm_hw_params *params,
                                      struct snd_pcm_hw_rule *rule)
{
        struct snd_interval *c = hw_param_interval(params,
              SNDRV_PCM_HW_PARAM_CHANNELS);
        struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
        struct snd_mask fmt;

        snd_mask_any(&amp;fmt);    /* Init the struct */
        if (c-&gt;min &lt; 2) {
                fmt.bits[0] &amp;= SNDRV_PCM_FMTBIT_S16_LE;
                return snd_mask_refine(f, &amp;fmt);
        }
        return 0;
}
</pre></div>
</div>
<p>… and in the open callback:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_hw_rule_add(substream-&gt;runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,
                    hw_rule_format_by_channels, NULL,
                    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
</pre></div>
</div>
<p>One typical usage of the hw constraints is to align the buffer size
with the period size.  As default, ALSA PCM core doesn’t enforce the
buffer size to be aligned with the period size.  For example, it’d be
possible to have a combination like 256 period bytes with 999 buffer
bytes.</p>
<p>Many device chips, however, require the buffer to be a multiple of
periods.  In such a case, call
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_hw_constraint_integer" title="snd_pcm_hw_constraint_integer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_hw_constraint_integer()</span></code></a> for
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_HW_PARAM_PERIODS</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_hw_constraint_integer(substream-&gt;runtime,
                              SNDRV_PCM_HW_PARAM_PERIODS);
</pre></div>
</div>
<p>This assures that the number of periods is integer, hence the buffer
size is aligned with the period size.</p>
<p>The hw constraint is a very much powerful mechanism to define the
preferred PCM configuration, and there are relevant helpers.
I won’t give more details here, rather I would like to say, “Luke, use
the source.”</p>
</section>
</section>
<section id="control-interface">
<h2>Control Interface<a class="headerlink" href="#control-interface" title="Permalink to this headline">¶</a></h2>
<section id="id4">
<h3>General<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>The control interface is used widely for many switches, sliders, etc.
which are accessed from user-space. Its most important use is the mixer
interface. In other words, since ALSA 0.9.x, all the mixer stuff is
implemented on the control kernel API.</p>
<p>ALSA has a well-defined AC97 control module. If your chip supports only
the AC97 and nothing else, you can skip this section.</p>
<p>The control API is defined in <code class="docutils literal notranslate"><span class="pre">&lt;sound/control.h&gt;</span></code>. Include this file
if you want to add your own controls.</p>
</section>
<section id="definition-of-controls">
<h3>Definition of Controls<a class="headerlink" href="#definition-of-controls" title="Permalink to this headline">¶</a></h3>
<p>To create a new control, you need to define the following three
callbacks: <code class="docutils literal notranslate"><span class="pre">info</span></code>, <code class="docutils literal notranslate"><span class="pre">get</span></code> and <code class="docutils literal notranslate"><span class="pre">put</span></code>. Then, define a
struct snd_kcontrol_new record, such as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct snd_kcontrol_new my_control = {
        .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
        .name = &quot;PCM Playback Switch&quot;,
        .index = 0,
        .access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
        .private_value = 0xffff,
        .info = my_control_info,
        .get = my_control_get,
        .put = my_control_put
};
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">iface</span></code> field specifies the control type,
<code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_IFACE_XXX</span></code>, which is usually <code class="docutils literal notranslate"><span class="pre">MIXER</span></code>. Use <code class="docutils literal notranslate"><span class="pre">CARD</span></code>
for global controls that are not logically part of the mixer. If the
control is closely associated with some specific device on the sound
card, use <code class="docutils literal notranslate"><span class="pre">HWDEP</span></code>, <code class="docutils literal notranslate"><span class="pre">PCM</span></code>, <code class="docutils literal notranslate"><span class="pre">RAWMIDI</span></code>, <code class="docutils literal notranslate"><span class="pre">TIMER</span></code>, or <code class="docutils literal notranslate"><span class="pre">SEQUENCER</span></code>,
and specify the device number with the <code class="docutils literal notranslate"><span class="pre">device</span></code> and <code class="docutils literal notranslate"><span class="pre">subdevice</span></code>
fields.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">name</span></code> is the name identifier string. Since ALSA 0.9.x, the
control name is very important, because its role is classified from
its name. There are pre-defined standard control names. The details
are described in the <a class="reference internal" href="#control-names">Control Names</a> subsection.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">index</span></code> field holds the index number of this control. If there
are several different controls with the same name, they can be
distinguished by the index number. This is the case when several
codecs exist on the card. If the index is zero, you can omit the
definition above.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">access</span></code> field contains the access type of this control. Give
the combination of bit masks, <code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_ACCESS_XXX</span></code>,
there. The details will be explained in the <a class="reference internal" href="#access-flags">Access Flags</a>
subsection.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">private_value</span></code> field contains an arbitrary long integer value
for this record. When using the generic <code class="docutils literal notranslate"><span class="pre">info</span></code>, <code class="docutils literal notranslate"><span class="pre">get</span></code> and <code class="docutils literal notranslate"><span class="pre">put</span></code>
callbacks, you can pass a value through this field. If several small
numbers are necessary, you can combine them in bitwise. Or, it’s
possible to give a pointer (casted to unsigned long) of some record to
this field, too.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">tlv</span></code> field can be used to provide metadata about the control;
see the <a class="reference internal" href="#metadata">Metadata</a> subsection.</p>
<p>The other three are <a class="reference internal" href="#control-callbacks">Control Callbacks</a>.</p>
</section>
<section id="control-names">
<h3>Control Names<a class="headerlink" href="#control-names" title="Permalink to this headline">¶</a></h3>
<p>There are some standards to define the control names. A control is
usually defined from the three parts as “SOURCE DIRECTION FUNCTION”.</p>
<p>The first, <code class="docutils literal notranslate"><span class="pre">SOURCE</span></code>, specifies the source of the control, and is a
string such as “Master”, “PCM”, “CD” and “Line”. There are many
pre-defined sources.</p>
<p>The second, <code class="docutils literal notranslate"><span class="pre">DIRECTION</span></code>, is one of the following strings according to
the direction of the control: “Playback”, “Capture”, “Bypass Playback”
and “Bypass Capture”. Or, it can be omitted, meaning both playback and
capture directions.</p>
<p>The third, <code class="docutils literal notranslate"><span class="pre">FUNCTION</span></code>, is one of the following strings according to
the function of the control: “Switch”, “Volume” and “Route”.</p>
<p>The example of control names are, thus, “Master Capture Switch” or “PCM
Playback Volume”.</p>
<p>There are some exceptions:</p>
<section id="global-capture-and-playback">
<h4>Global capture and playback<a class="headerlink" href="#global-capture-and-playback" title="Permalink to this headline">¶</a></h4>
<p>“Capture Source”, “Capture Switch” and “Capture Volume” are used for the
global capture (input) source, switch and volume. Similarly, “Playback
Switch” and “Playback Volume” are used for the global output gain switch
and volume.</p>
</section>
<section id="tone-controls">
<h4>Tone-controls<a class="headerlink" href="#tone-controls" title="Permalink to this headline">¶</a></h4>
<p>tone-control switch and volumes are specified like “Tone Control - XXX”,
e.g. “Tone Control - Switch”, “Tone Control - Bass”, “Tone Control -
Center”.</p>
</section>
<section id="d-controls">
<h4>3D controls<a class="headerlink" href="#d-controls" title="Permalink to this headline">¶</a></h4>
<p>3D-control switches and volumes are specified like “3D Control - XXX”,
e.g. “3D Control - Switch”, “3D Control - Center”, “3D Control - Space”.</p>
</section>
<section id="mic-boost">
<h4>Mic boost<a class="headerlink" href="#mic-boost" title="Permalink to this headline">¶</a></h4>
<p>Mic-boost switch is set as “Mic Boost” or “Mic Boost (6dB)”.</p>
<p>More precise information can be found in
<code class="docutils literal notranslate"><span class="pre">Documentation/sound/designs/control-names.rst</span></code>.</p>
</section>
</section>
<section id="access-flags">
<h3>Access Flags<a class="headerlink" href="#access-flags" title="Permalink to this headline">¶</a></h3>
<p>The access flag is the bitmask which specifies the access type of the
given control. The default access type is
<code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_ACCESS_READWRITE</span></code>, which means both read and write are
allowed to this control. When the access flag is omitted (i.e. = 0), it
is considered as <code class="docutils literal notranslate"><span class="pre">READWRITE</span></code> access as default.</p>
<p>When the control is read-only, pass <code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_ACCESS_READ</span></code>
instead. In this case, you don’t have to define the <code class="docutils literal notranslate"><span class="pre">put</span></code> callback.
Similarly, when the control is write-only (although it’s a rare case),
you can use the <code class="docutils literal notranslate"><span class="pre">WRITE</span></code> flag instead, and you don’t need the <code class="docutils literal notranslate"><span class="pre">get</span></code>
callback.</p>
<p>If the control value changes frequently (e.g. the VU meter),
<code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code> flag should be given. This means that the control may be
changed without <a class="reference internal" href="#change-notification">Change notification</a>. Applications should poll such
a control constantly.</p>
<p>When the control is inactive, set the <code class="docutils literal notranslate"><span class="pre">INACTIVE</span></code> flag, too. There are
<code class="docutils literal notranslate"><span class="pre">LOCK</span></code> and <code class="docutils literal notranslate"><span class="pre">OWNER</span></code> flags to change the write permissions.</p>
</section>
<section id="control-callbacks">
<h3>Control Callbacks<a class="headerlink" href="#control-callbacks" title="Permalink to this headline">¶</a></h3>
<section id="info-callback">
<h4>info callback<a class="headerlink" href="#info-callback" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">info</span></code> callback is used to get detailed information on this
control. This must store the values of the given
struct snd_ctl_elem_info object. For example,
for a boolean control with a single element:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_myctl_mono_info(struct snd_kcontrol *kcontrol,
                        struct snd_ctl_elem_info *uinfo)
{
        uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
        uinfo-&gt;count = 1;
        uinfo-&gt;value.integer.min = 0;
        uinfo-&gt;value.integer.max = 1;
        return 0;
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">type</span></code> field specifies the type of the control. There are
<code class="docutils literal notranslate"><span class="pre">BOOLEAN</span></code>, <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code>, <code class="docutils literal notranslate"><span class="pre">ENUMERATED</span></code>, <code class="docutils literal notranslate"><span class="pre">BYTES</span></code>, <code class="docutils literal notranslate"><span class="pre">IEC958</span></code> and
<code class="docutils literal notranslate"><span class="pre">INTEGER64</span></code>. The <code class="docutils literal notranslate"><span class="pre">count</span></code> field specifies the number of elements in
this control. For example, a stereo volume would have count = 2. The
<code class="docutils literal notranslate"><span class="pre">value</span></code> field is a union, and the values stored are depending on the
type. The boolean and integer types are identical.</p>
<p>The enumerated type is a bit different from others. You’ll need to set
the string for the currently given item index.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_myctl_enum_info(struct snd_kcontrol *kcontrol,
                        struct snd_ctl_elem_info *uinfo)
{
        static char *texts[4] = {
                &quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;, &quot;Fourth&quot;
        };
        uinfo-&gt;type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
        uinfo-&gt;count = 1;
        uinfo-&gt;value.enumerated.items = 4;
        if (uinfo-&gt;value.enumerated.item &gt; 3)
                uinfo-&gt;value.enumerated.item = 3;
        strcpy(uinfo-&gt;value.enumerated.name,
               texts[uinfo-&gt;value.enumerated.item]);
        return 0;
}
</pre></div>
</div>
<p>The above callback can be simplified with a helper function,
<a class="reference internal" href="alsa-driver-api.html#c.snd_ctl_enum_info" title="snd_ctl_enum_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_enum_info()</span></code></a>. The final code looks like below.
(You can pass <code class="docutils literal notranslate"><span class="pre">ARRAY_SIZE(texts)</span></code> instead of 4 in the third argument;
it’s a matter of taste.)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_myctl_enum_info(struct snd_kcontrol *kcontrol,
                        struct snd_ctl_elem_info *uinfo)
{
        static char *texts[4] = {
                &quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;, &quot;Fourth&quot;
        };
        return snd_ctl_enum_info(uinfo, 1, 4, texts);
}
</pre></div>
</div>
<p>Some common info callbacks are available for your convenience:
<a class="reference internal" href="alsa-driver-api.html#c.snd_ctl_boolean_mono_info" title="snd_ctl_boolean_mono_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_boolean_mono_info()</span></code></a> and
<a class="reference internal" href="alsa-driver-api.html#c.snd_ctl_boolean_stereo_info" title="snd_ctl_boolean_stereo_info"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_boolean_stereo_info()</span></code></a>. Obviously, the former
is an info callback for a mono channel boolean item, just like
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_myctl_mono_info()</span></code> above, and the latter is for a
stereo channel boolean item.</p>
</section>
<section id="get-callback">
<h4>get callback<a class="headerlink" href="#get-callback" title="Permalink to this headline">¶</a></h4>
<p>This callback is used to read the current value of the control and to
return to user-space.</p>
<p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_myctl_get(struct snd_kcontrol *kcontrol,
                         struct snd_ctl_elem_value *ucontrol)
{
        struct mychip *chip = snd_kcontrol_chip(kcontrol);
        ucontrol-&gt;value.integer.value[0] = get_some_value(chip);
        return 0;
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">value</span></code> field depends on the type of control as well as on the
info callback. For example, the sb driver uses this field to store the
register offset, the bit-shift and the bit-mask. The <code class="docutils literal notranslate"><span class="pre">private_value</span></code>
field is set as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.private_value = reg | (shift &lt;&lt; 16) | (mask &lt;&lt; 24)
</pre></div>
</div>
<p>and is retrieved in callbacks like</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_sbmixer_get_single(struct snd_kcontrol *kcontrol,
                                  struct snd_ctl_elem_value *ucontrol)
{
        int reg = kcontrol-&gt;private_value &amp; 0xff;
        int shift = (kcontrol-&gt;private_value &gt;&gt; 16) &amp; 0xff;
        int mask = (kcontrol-&gt;private_value &gt;&gt; 24) &amp; 0xff;
        ....
}
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">get</span></code> callback, you have to fill all the elements if the
control has more than one elements, i.e. <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>. In the example
above, we filled only one element (<code class="docutils literal notranslate"><span class="pre">value.integer.value[0]</span></code>) since
it’s assumed as <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</section>
<section id="put-callback">
<h4>put callback<a class="headerlink" href="#put-callback" title="Permalink to this headline">¶</a></h4>
<p>This callback is used to write a value from user-space.</p>
<p>For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_myctl_put(struct snd_kcontrol *kcontrol,
                         struct snd_ctl_elem_value *ucontrol)
{
        struct mychip *chip = snd_kcontrol_chip(kcontrol);
        int changed = 0;
        if (chip-&gt;current_value !=
             ucontrol-&gt;value.integer.value[0]) {
                change_current_value(chip,
                            ucontrol-&gt;value.integer.value[0]);
                changed = 1;
        }
        return changed;
}
</pre></div>
</div>
<p>As seen above, you have to return 1 if the value is changed. If the
value is not changed, return 0 instead. If any fatal error happens,
return a negative error code as usual.</p>
<p>As in the <code class="docutils literal notranslate"><span class="pre">get</span></code> callback, when the control has more than one
elements, all elements must be evaluated in this callback, too.</p>
</section>
<section id="callbacks-are-not-atomic">
<h4>Callbacks are not atomic<a class="headerlink" href="#callbacks-are-not-atomic" title="Permalink to this headline">¶</a></h4>
<p>All these three callbacks are basically not atomic.</p>
</section>
</section>
<section id="control-constructor">
<h3>Control Constructor<a class="headerlink" href="#control-constructor" title="Permalink to this headline">¶</a></h3>
<p>When everything is ready, finally we can create a new control. To create
a control, there are two functions to be called,
<a class="reference internal" href="alsa-driver-api.html#c.snd_ctl_new1" title="snd_ctl_new1"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new1()</span></code></a> and <a class="reference internal" href="alsa-driver-api.html#c.snd_ctl_add" title="snd_ctl_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_add()</span></code></a>.</p>
<p>In the simplest way, you can do like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>err = snd_ctl_add(card, snd_ctl_new1(&amp;my_control, chip));
if (err &lt; 0)
        return err;
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">my_control</span></code> is the struct snd_kcontrol_new object defined above,
and chip is the object pointer to be passed to kcontrol-&gt;private_data which
can be referred to in callbacks.</p>
<p><a class="reference internal" href="alsa-driver-api.html#c.snd_ctl_new1" title="snd_ctl_new1"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_new1()</span></code></a> allocates a new struct snd_kcontrol instance, and
<a class="reference internal" href="alsa-driver-api.html#c.snd_ctl_add" title="snd_ctl_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_add()</span></code></a> assigns the given control component to the
card.</p>
</section>
<section id="change-notification">
<h3>Change Notification<a class="headerlink" href="#change-notification" title="Permalink to this headline">¶</a></h3>
<p>If you need to change and update a control in the interrupt routine, you
can call <a class="reference internal" href="alsa-driver-api.html#c.snd_ctl_notify" title="snd_ctl_notify"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ctl_notify()</span></code></a>. For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, id_pointer);
</pre></div>
</div>
<p>This function takes the card pointer, the event-mask, and the control id
pointer for the notification. The event-mask specifies the types of
notification, for example, in the above example, the change of control
values is notified. The id pointer is the pointer of struct snd_ctl_elem_id
to be notified. You can find some examples in <code class="docutils literal notranslate"><span class="pre">es1938.c</span></code> or <code class="docutils literal notranslate"><span class="pre">es1968.c</span></code>
for hardware volume interrupts.</p>
</section>
<section id="metadata">
<h3>Metadata<a class="headerlink" href="#metadata" title="Permalink to this headline">¶</a></h3>
<p>To provide information about the dB values of a mixer control, use on of
the <code class="docutils literal notranslate"><span class="pre">DECLARE_TLV_xxx</span></code> macros from <code class="docutils literal notranslate"><span class="pre">&lt;sound/tlv.h&gt;</span></code> to define a
variable containing this information, set the <code class="docutils literal notranslate"><span class="pre">tlv.p</span></code> field to point to
this variable, and include the <code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_ACCESS_TLV_READ</span></code> flag
in the <code class="docutils literal notranslate"><span class="pre">access</span></code> field; like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static DECLARE_TLV_DB_SCALE(db_scale_my_control, -4050, 150, 0);

static struct snd_kcontrol_new my_control = {
        ...
        .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
                  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
        ...
        .tlv.p = db_scale_my_control,
};
</pre></div>
</div>
<p>The <code class="xref c c-func docutils literal notranslate"><span class="pre">DECLARE_TLV_DB_SCALE()</span></code> macro defines information
about a mixer control where each step in the control’s value changes the
dB value by a constant dB amount. The first parameter is the name of the
variable to be defined. The second parameter is the minimum value, in
units of 0.01 dB. The third parameter is the step size, in units of 0.01
dB. Set the fourth parameter to 1 if the minimum value actually mutes
the control.</p>
<p>The <code class="xref c c-func docutils literal notranslate"><span class="pre">DECLARE_TLV_DB_LINEAR()</span></code> macro defines information
about a mixer control where the control’s value affects the output
linearly. The first parameter is the name of the variable to be defined.
The second parameter is the minimum value, in units of 0.01 dB. The
third parameter is the maximum value, in units of 0.01 dB. If the
minimum value mutes the control, set the second parameter to
<code class="docutils literal notranslate"><span class="pre">TLV_DB_GAIN_MUTE</span></code>.</p>
</section>
</section>
<section id="api-for-ac97-codec">
<h2>API for AC97 Codec<a class="headerlink" href="#api-for-ac97-codec" title="Permalink to this headline">¶</a></h2>
<section id="id5">
<h3>General<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>The ALSA AC97 codec layer is a well-defined one, and you don’t have to
write much code to control it. Only low-level control routines are
necessary. The AC97 codec API is defined in <code class="docutils literal notranslate"><span class="pre">&lt;sound/ac97_codec.h&gt;</span></code>.</p>
</section>
<section id="id6">
<h3>Full Code Example<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mychip {
        ....
        struct snd_ac97 *ac97;
        ....
};

static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97,
                                           unsigned short reg)
{
        struct mychip *chip = ac97-&gt;private_data;
        ....
        /* read a register value here from the codec */
        return the_register_value;
}

static void snd_mychip_ac97_write(struct snd_ac97 *ac97,
                                 unsigned short reg, unsigned short val)
{
        struct mychip *chip = ac97-&gt;private_data;
        ....
        /* write the given register value to the codec */
}

static int snd_mychip_ac97(struct mychip *chip)
{
        struct snd_ac97_bus *bus;
        struct snd_ac97_template ac97;
        int err;
        static struct snd_ac97_bus_ops ops = {
                .write = snd_mychip_ac97_write,
                .read = snd_mychip_ac97_read,
        };

        err = snd_ac97_bus(chip-&gt;card, 0, &amp;ops, NULL, &amp;bus);
        if (err &lt; 0)
                return err;
        memset(&amp;ac97, 0, sizeof(ac97));
        ac97.private_data = chip;
        return snd_ac97_mixer(bus, &amp;ac97, &amp;chip-&gt;ac97);
}
</pre></div>
</div>
</section>
<section id="ac97-constructor">
<h3>AC97 Constructor<a class="headerlink" href="#ac97-constructor" title="Permalink to this headline">¶</a></h3>
<p>To create an ac97 instance, first call <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_bus" title="snd_ac97_bus"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_bus()</span></code></a>
with an <code class="docutils literal notranslate"><span class="pre">ac97_bus_ops_t</span></code> record with callback functions.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_ac97_bus *bus;
static struct snd_ac97_bus_ops ops = {
      .write = snd_mychip_ac97_write,
      .read = snd_mychip_ac97_read,
};

snd_ac97_bus(card, 0, &amp;ops, NULL, &amp;pbus);
</pre></div>
</div>
<p>The bus record is shared among all belonging ac97 instances.</p>
<p>And then call <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_mixer" title="snd_ac97_mixer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_mixer()</span></code></a> with an struct snd_ac97_template
record together with the bus pointer created above.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_ac97_template ac97;
int err;

memset(&amp;ac97, 0, sizeof(ac97));
ac97.private_data = chip;
snd_ac97_mixer(bus, &amp;ac97, &amp;chip-&gt;ac97);
</pre></div>
</div>
<p>where chip-&gt;ac97 is a pointer to a newly created <code class="docutils literal notranslate"><span class="pre">ac97_t</span></code>
instance. In this case, the chip pointer is set as the private data,
so that the read/write callback functions can refer to this chip
instance. This instance is not necessarily stored in the chip
record. If you need to change the register values from the driver, or
need the suspend/resume of ac97 codecs, keep this pointer to pass to
the corresponding functions.</p>
</section>
<section id="ac97-callbacks">
<h3>AC97 Callbacks<a class="headerlink" href="#ac97-callbacks" title="Permalink to this headline">¶</a></h3>
<p>The standard callbacks are <code class="docutils literal notranslate"><span class="pre">read</span></code> and <code class="docutils literal notranslate"><span class="pre">write</span></code>. Obviously they
correspond to the functions for read and write accesses to the
hardware low-level codes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">read</span></code> callback returns the register value specified in the
argument.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97,
                                           unsigned short reg)
{
        struct mychip *chip = ac97-&gt;private_data;
        ....
        return the_register_value;
}
</pre></div>
</div>
<p>Here, the chip can be cast from <code class="docutils literal notranslate"><span class="pre">ac97-&gt;private_data</span></code>.</p>
<p>Meanwhile, the <code class="docutils literal notranslate"><span class="pre">write</span></code> callback is used to set the register
value</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void snd_mychip_ac97_write(struct snd_ac97 *ac97,
                     unsigned short reg, unsigned short val)
</pre></div>
</div>
<p>These callbacks are non-atomic like the control API callbacks.</p>
<p>There are also other callbacks: <code class="docutils literal notranslate"><span class="pre">reset</span></code>, <code class="docutils literal notranslate"><span class="pre">wait</span></code> and <code class="docutils literal notranslate"><span class="pre">init</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">reset</span></code> callback is used to reset the codec. If the chip
requires a special kind of reset, you can define this callback.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">wait</span></code> callback is used to add some waiting time in the standard
initialization of the codec. If the chip requires the extra waiting
time, define this callback.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">init</span></code> callback is used for additional initialization of the
codec.</p>
</section>
<section id="updating-registers-in-the-driver">
<h3>Updating Registers in The Driver<a class="headerlink" href="#updating-registers-in-the-driver" title="Permalink to this headline">¶</a></h3>
<p>If you need to access to the codec from the driver, you can call the
following functions: <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_write" title="snd_ac97_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_write()</span></code></a>,
<a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_read" title="snd_ac97_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_read()</span></code></a>, <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_update" title="snd_ac97_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_update()</span></code></a> and
<a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_update_bits" title="snd_ac97_update_bits"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_update_bits()</span></code></a>.</p>
<p>Both <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_write" title="snd_ac97_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_write()</span></code></a> and
<a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_update" title="snd_ac97_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_update()</span></code></a> functions are used to set a value to
the given register (<code class="docutils literal notranslate"><span class="pre">AC97_XXX</span></code>). The difference between them is that
<a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_update" title="snd_ac97_update"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_update()</span></code></a> doesn’t write a value if the given
value has been already set, while <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_write" title="snd_ac97_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_write()</span></code></a>
always rewrites the value.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_ac97_write(ac97, AC97_MASTER, 0x8080);
snd_ac97_update(ac97, AC97_MASTER, 0x8080);
</pre></div>
</div>
<p><a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_read" title="snd_ac97_read"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_read()</span></code></a> is used to read the value of the given
register. For example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>value = snd_ac97_read(ac97, AC97_MASTER);
</pre></div>
</div>
<p><a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_update_bits" title="snd_ac97_update_bits"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_update_bits()</span></code></a> is used to update some bits in
the given register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_ac97_update_bits(ac97, reg, mask, value);
</pre></div>
</div>
<p>Also, there is a function to change the sample rate (of a given register
such as <code class="docutils literal notranslate"><span class="pre">AC97_PCM_FRONT_DAC_RATE</span></code>) when VRA or DRA is supported by the
codec: <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_set_rate" title="snd_ac97_set_rate"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_set_rate()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_ac97_set_rate(ac97, AC97_PCM_FRONT_DAC_RATE, 44100);
</pre></div>
</div>
<p>The following registers are available to set the rate:
<code class="docutils literal notranslate"><span class="pre">AC97_PCM_MIC_ADC_RATE</span></code>, <code class="docutils literal notranslate"><span class="pre">AC97_PCM_FRONT_DAC_RATE</span></code>,
<code class="docutils literal notranslate"><span class="pre">AC97_PCM_LR_ADC_RATE</span></code>, <code class="docutils literal notranslate"><span class="pre">AC97_SPDIF</span></code>. When <code class="docutils literal notranslate"><span class="pre">AC97_SPDIF</span></code> is
specified, the register is not really changed but the corresponding
IEC958 status bits will be updated.</p>
</section>
<section id="clock-adjustment">
<h3>Clock Adjustment<a class="headerlink" href="#clock-adjustment" title="Permalink to this headline">¶</a></h3>
<p>In some chips, the clock of the codec isn’t 48000 but using a PCI clock
(to save a quartz!). In this case, change the field <code class="docutils literal notranslate"><span class="pre">bus-&gt;clock</span></code> to
the corresponding value. For example, intel8x0 and es1968 drivers have
their own function to read from the clock.</p>
</section>
<section id="proc-files">
<h3>Proc Files<a class="headerlink" href="#proc-files" title="Permalink to this headline">¶</a></h3>
<p>The ALSA AC97 interface will create a proc file such as
<code class="docutils literal notranslate"><span class="pre">/proc/asound/card0/codec97#0/ac97#0-0</span></code> and <code class="docutils literal notranslate"><span class="pre">ac97#0-0+regs</span></code>. You
can refer to these files to see the current status and registers of
the codec.</p>
</section>
<section id="multiple-codecs">
<h3>Multiple Codecs<a class="headerlink" href="#multiple-codecs" title="Permalink to this headline">¶</a></h3>
<p>When there are several codecs on the same card, you need to call
<a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_mixer" title="snd_ac97_mixer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_mixer()</span></code></a> multiple times with <code class="docutils literal notranslate"><span class="pre">ac97.num=1</span></code> or
greater. The <code class="docutils literal notranslate"><span class="pre">num</span></code> field specifies the codec number.</p>
<p>If you set up multiple codecs, you either need to write different
callbacks for each codec or check <code class="docutils literal notranslate"><span class="pre">ac97-&gt;num</span></code> in the callback
routines.</p>
</section>
</section>
<section id="midi-mpu401-uart-interface">
<h2>MIDI (MPU401-UART) Interface<a class="headerlink" href="#midi-mpu401-uart-interface" title="Permalink to this headline">¶</a></h2>
<section id="id7">
<h3>General<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Many soundcards have built-in MIDI (MPU401-UART) interfaces. When the
soundcard supports the standard MPU401-UART interface, most likely you
can use the ALSA MPU401-UART API. The MPU401-UART API is defined in
<code class="docutils literal notranslate"><span class="pre">&lt;sound/mpu401.h&gt;</span></code>.</p>
<p>Some soundchips have a similar but slightly different implementation of
mpu401 stuff. For example, emu10k1 has its own mpu401 routines.</p>
</section>
<section id="midi-constructor">
<h3>MIDI Constructor<a class="headerlink" href="#midi-constructor" title="Permalink to this headline">¶</a></h3>
<p>To create a rawmidi object, call <a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_new" title="snd_mpu401_uart_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_new()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_rawmidi *rmidi;
snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401, port, info_flags,
                    irq, &amp;rmidi);
</pre></div>
</div>
<p>The first argument is the card pointer, and the second is the index of
this component. You can create up to 8 rawmidi devices.</p>
<p>The third argument is the type of the hardware, <code class="docutils literal notranslate"><span class="pre">MPU401_HW_XXX</span></code>. If
it’s not a special one, you can use <code class="docutils literal notranslate"><span class="pre">MPU401_HW_MPU401</span></code>.</p>
<p>The 4th argument is the I/O port address. Many backward-compatible
MPU401 have an I/O port such as 0x330. Or, it might be a part of its own
PCI I/O region. It depends on the chip design.</p>
<p>The 5th argument is a bitflag for additional information. When the I/O
port address above is part of the PCI I/O region, the MPU401 I/O port
might have been already allocated (reserved) by the driver itself. In
such a case, pass a bit flag <code class="docutils literal notranslate"><span class="pre">MPU401_INFO_INTEGRATED</span></code>, and the
mpu401-uart layer will allocate the I/O ports by itself.</p>
<p>When the controller supports only the input or output MIDI stream, pass
the <code class="docutils literal notranslate"><span class="pre">MPU401_INFO_INPUT</span></code> or <code class="docutils literal notranslate"><span class="pre">MPU401_INFO_OUTPUT</span></code> bitflag,
respectively. Then the rawmidi instance is created as a single stream.</p>
<p><code class="docutils literal notranslate"><span class="pre">MPU401_INFO_MMIO</span></code> bitflag is used to change the access method to MMIO
(via readb and writeb) instead of iob and outb. In this case, you have
to pass the iomapped address to <a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_new" title="snd_mpu401_uart_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_new()</span></code></a>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">MPU401_INFO_TX_IRQ</span></code> is set, the output stream isn’t checked in
the default interrupt handler. The driver needs to call
<a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_interrupt_tx" title="snd_mpu401_uart_interrupt_tx"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_interrupt_tx()</span></code></a> by itself to start
processing the output stream in the irq handler.</p>
<p>If the MPU-401 interface shares its interrupt with the other logical
devices on the card, set <code class="docutils literal notranslate"><span class="pre">MPU401_INFO_IRQ_HOOK</span></code> (see
<a class="reference internal" href="#midi-interrupt-handler">below</a>).</p>
<p>Usually, the port address corresponds to the command port and port + 1
corresponds to the data port. If not, you may change the <code class="docutils literal notranslate"><span class="pre">cport</span></code>
field of struct snd_mpu401 manually afterward.
However, struct snd_mpu401 pointer is
not returned explicitly by <a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_new" title="snd_mpu401_uart_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_new()</span></code></a>. You
need to cast <code class="docutils literal notranslate"><span class="pre">rmidi-&gt;private_data</span></code> to struct snd_mpu401 explicitly,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_mpu401 *mpu;
mpu = rmidi-&gt;private_data;
</pre></div>
</div>
<p>and reset the <code class="docutils literal notranslate"><span class="pre">cport</span></code> as you like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mpu-&gt;cport = my_own_control_port;
</pre></div>
</div>
<p>The 6th argument specifies the ISA irq number that will be allocated. If
no interrupt is to be allocated (because your code is already allocating
a shared interrupt, or because the device does not use interrupts), pass
-1 instead. For a MPU-401 device without an interrupt, a polling timer
will be used instead.</p>
</section>
<section id="midi-interrupt-handler">
<h3>MIDI Interrupt Handler<a class="headerlink" href="#midi-interrupt-handler" title="Permalink to this headline">¶</a></h3>
<p>When the interrupt is allocated in
<a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_new" title="snd_mpu401_uart_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_new()</span></code></a>, an exclusive ISA interrupt
handler is automatically used, hence you don’t have anything else to do
than creating the mpu401 stuff. Otherwise, you have to set
<code class="docutils literal notranslate"><span class="pre">MPU401_INFO_IRQ_HOOK</span></code>, and call
<a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_interrupt" title="snd_mpu401_uart_interrupt"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_interrupt()</span></code></a> explicitly from your own
interrupt handler when it has determined that a UART interrupt has
occurred.</p>
<p>In this case, you need to pass the private_data of the returned rawmidi
object from <a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_new" title="snd_mpu401_uart_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_new()</span></code></a> as the second
argument of <a class="reference internal" href="alsa-driver-api.html#c.snd_mpu401_uart_interrupt" title="snd_mpu401_uart_interrupt"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_mpu401_uart_interrupt()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_mpu401_uart_interrupt(irq, rmidi-&gt;private_data, regs);
</pre></div>
</div>
</section>
</section>
<section id="rawmidi-interface">
<h2>RawMIDI Interface<a class="headerlink" href="#rawmidi-interface" title="Permalink to this headline">¶</a></h2>
<section id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>The raw MIDI interface is used for hardware MIDI ports that can be
accessed as a byte stream. It is not used for synthesizer chips that do
not directly understand MIDI.</p>
<p>ALSA handles file and buffer management. All you have to do is to write
some code to move data between the buffer and the hardware.</p>
<p>The rawmidi API is defined in <code class="docutils literal notranslate"><span class="pre">&lt;sound/rawmidi.h&gt;</span></code>.</p>
</section>
<section id="rawmidi-constructor">
<h3>RawMIDI Constructor<a class="headerlink" href="#rawmidi-constructor" title="Permalink to this headline">¶</a></h3>
<p>To create a rawmidi device, call the <a class="reference internal" href="alsa-driver-api.html#c.snd_rawmidi_new" title="snd_rawmidi_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_new()</span></code></a>
function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_rawmidi *rmidi;
err = snd_rawmidi_new(chip-&gt;card, &quot;MyMIDI&quot;, 0, outs, ins, &amp;rmidi);
if (err &lt; 0)
        return err;
rmidi-&gt;private_data = chip;
strcpy(rmidi-&gt;name, &quot;My MIDI&quot;);
rmidi-&gt;info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
                    SNDRV_RAWMIDI_INFO_INPUT |
                    SNDRV_RAWMIDI_INFO_DUPLEX;
</pre></div>
</div>
<p>The first argument is the card pointer, the second argument is the ID
string.</p>
<p>The third argument is the index of this component. You can create up to
8 rawmidi devices.</p>
<p>The fourth and fifth arguments are the number of output and input
substreams, respectively, of this device (a substream is the equivalent
of a MIDI port).</p>
<p>Set the <code class="docutils literal notranslate"><span class="pre">info_flags</span></code> field to specify the capabilities of the
device. Set <code class="docutils literal notranslate"><span class="pre">SNDRV_RAWMIDI_INFO_OUTPUT</span></code> if there is at least one
output port, <code class="docutils literal notranslate"><span class="pre">SNDRV_RAWMIDI_INFO_INPUT</span></code> if there is at least one
input port, and <code class="docutils literal notranslate"><span class="pre">SNDRV_RAWMIDI_INFO_DUPLEX</span></code> if the device can handle
output and input at the same time.</p>
<p>After the rawmidi device is created, you need to set the operators
(callbacks) for each substream. There are helper functions to set the
operators for all the substreams of a device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &amp;snd_mymidi_output_ops);
snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &amp;snd_mymidi_input_ops);
</pre></div>
</div>
<p>The operators are usually defined like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static struct snd_rawmidi_ops snd_mymidi_output_ops = {
        .open =    snd_mymidi_output_open,
        .close =   snd_mymidi_output_close,
        .trigger = snd_mymidi_output_trigger,
};
</pre></div>
</div>
<p>These callbacks are explained in the <a class="reference internal" href="#rawmidi-callbacks">RawMIDI Callbacks</a> section.</p>
<p>If there are more than one substream, you should give a unique name to
each of them:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_rawmidi_substream *substream;
list_for_each_entry(substream,
                    &amp;rmidi-&gt;streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams,
                    list {
        sprintf(substream-&gt;name, &quot;My MIDI Port %d&quot;, substream-&gt;number + 1);
}
/* same for SNDRV_RAWMIDI_STREAM_INPUT */
</pre></div>
</div>
</section>
<section id="rawmidi-callbacks">
<h3>RawMIDI Callbacks<a class="headerlink" href="#rawmidi-callbacks" title="Permalink to this headline">¶</a></h3>
<p>In all the callbacks, the private data that you’ve set for the rawmidi
device can be accessed as <code class="docutils literal notranslate"><span class="pre">substream-&gt;rmidi-&gt;private_data</span></code>.</p>
<p>If there is more than one port, your callbacks can determine the port
index from the struct snd_rawmidi_substream data passed to each
callback:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_rawmidi_substream *substream;
int index = substream-&gt;number;
</pre></div>
</div>
<section id="rawmidi-open-callback">
<h4>RawMIDI open callback<a class="headerlink" href="#rawmidi-open-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_open(struct snd_rawmidi_substream *substream);
</pre></div>
</div>
<p>This is called when a substream is opened. You can initialize the
hardware here, but you shouldn’t start transmitting/receiving data yet.</p>
</section>
<section id="rawmidi-close-callback">
<h4>RawMIDI close callback<a class="headerlink" href="#rawmidi-close-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_xxx_close(struct snd_rawmidi_substream *substream);
</pre></div>
</div>
<p>Guess what.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">open</span></code> and <code class="docutils literal notranslate"><span class="pre">close</span></code> callbacks of a rawmidi device are
serialized with a mutex, and can sleep.</p>
</section>
<section id="rawmidi-trigger-callback-for-output-substreams">
<h4>Rawmidi trigger callback for output substreams<a class="headerlink" href="#rawmidi-trigger-callback-for-output-substreams" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void snd_xxx_output_trigger(struct snd_rawmidi_substream *substream, int up);
</pre></div>
</div>
<p>This is called with a nonzero <code class="docutils literal notranslate"><span class="pre">up</span></code> parameter when there is some data
in the substream buffer that must be transmitted.</p>
<p>To read data from the buffer, call
<a class="reference internal" href="alsa-driver-api.html#c.snd_rawmidi_transmit_peek" title="snd_rawmidi_transmit_peek"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit_peek()</span></code></a>. It will return the number
of bytes that have been read; this will be less than the number of bytes
requested when there are no more data in the buffer. After the data have
been transmitted successfully, call
<a class="reference internal" href="alsa-driver-api.html#c.snd_rawmidi_transmit_ack" title="snd_rawmidi_transmit_ack"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit_ack()</span></code></a> to remove the data from the
substream buffer:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned char data;
while (snd_rawmidi_transmit_peek(substream, &amp;data, 1) == 1) {
        if (snd_mychip_try_to_transmit(data))
                snd_rawmidi_transmit_ack(substream, 1);
        else
                break; /* hardware FIFO full */
}
</pre></div>
</div>
<p>If you know beforehand that the hardware will accept data, you can use
the <a class="reference internal" href="alsa-driver-api.html#c.snd_rawmidi_transmit" title="snd_rawmidi_transmit"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_transmit()</span></code></a> function which reads some
data and removes them from the buffer at once:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>while (snd_mychip_transmit_possible()) {
        unsigned char data;
        if (snd_rawmidi_transmit(substream, &amp;data, 1) != 1)
                break; /* no more data */
        snd_mychip_transmit(data);
}
</pre></div>
</div>
<p>If you know beforehand how many bytes you can accept, you can use a
buffer size greater than one with the <code class="docutils literal notranslate"><span class="pre">snd_rawmidi_transmit*()</span></code> functions.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback must not sleep. If the hardware FIFO is full
before the substream buffer has been emptied, you have to continue
transmitting data later, either in an interrupt handler, or with a
timer if the hardware doesn’t have a MIDI transmit interrupt.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback is called with a zero <code class="docutils literal notranslate"><span class="pre">up</span></code> parameter when
the transmission of data should be aborted.</p>
</section>
<section id="rawmidi-trigger-callback-for-input-substreams">
<h4>RawMIDI trigger callback for input substreams<a class="headerlink" href="#rawmidi-trigger-callback-for-input-substreams" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void snd_xxx_input_trigger(struct snd_rawmidi_substream *substream, int up);
</pre></div>
</div>
<p>This is called with a nonzero <code class="docutils literal notranslate"><span class="pre">up</span></code> parameter to enable receiving data,
or with a zero <code class="docutils literal notranslate"><span class="pre">up</span></code> parameter do disable receiving data.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">trigger</span></code> callback must not sleep; the actual reading of data
from the device is usually done in an interrupt handler.</p>
<p>When data reception is enabled, your interrupt handler should call
<a class="reference internal" href="alsa-driver-api.html#c.snd_rawmidi_receive" title="snd_rawmidi_receive"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_rawmidi_receive()</span></code></a> for all received data:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void snd_mychip_midi_interrupt(...)
{
        while (mychip_midi_available()) {
                unsigned char data;
                data = mychip_midi_read();
                snd_rawmidi_receive(substream, &amp;data, 1);
        }
}
</pre></div>
</div>
</section>
<section id="drain-callback">
<h4>drain callback<a class="headerlink" href="#drain-callback" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void snd_xxx_drain(struct snd_rawmidi_substream *substream);
</pre></div>
</div>
<p>This is only used with output substreams. This function should wait
until all data read from the substream buffer have been transmitted.
This ensures that the device can be closed and the driver unloaded
without losing data.</p>
<p>This callback is optional. If you do not set <code class="docutils literal notranslate"><span class="pre">drain</span></code> in the struct
snd_rawmidi_ops structure, ALSA will simply wait for 50 milliseconds
instead.</p>
</section>
</section>
</section>
<section id="miscellaneous-devices">
<h2>Miscellaneous Devices<a class="headerlink" href="#miscellaneous-devices" title="Permalink to this headline">¶</a></h2>
<section id="fm-opl3">
<h3>FM OPL3<a class="headerlink" href="#fm-opl3" title="Permalink to this headline">¶</a></h3>
<p>The FM OPL3 is still used in many chips (mainly for backward
compatibility). ALSA has a nice OPL3 FM control layer, too. The OPL3 API
is defined in <code class="docutils literal notranslate"><span class="pre">&lt;sound/opl3.h&gt;</span></code>.</p>
<p>FM registers can be directly accessed through the direct-FM API, defined
in <code class="docutils literal notranslate"><span class="pre">&lt;sound/asound_fm.h&gt;</span></code>. In ALSA native mode, FM registers are
accessed through the Hardware-Dependent Device direct-FM extension API,
whereas in OSS compatible mode, FM registers can be accessed with the
OSS direct-FM compatible API in <code class="docutils literal notranslate"><span class="pre">/dev/dmfmX</span></code> device.</p>
<p>To create the OPL3 component, you have two functions to call. The first
one is a constructor for the <code class="docutils literal notranslate"><span class="pre">opl3_t</span></code> instance.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_opl3 *opl3;
snd_opl3_create(card, lport, rport, OPL3_HW_OPL3_XXX,
                integrated, &amp;opl3);
</pre></div>
</div>
<p>The first argument is the card pointer, the second one is the left port
address, and the third is the right port address. In most cases, the
right port is placed at the left port + 2.</p>
<p>The fourth argument is the hardware type.</p>
<p>When the left and right ports have been already allocated by the card
driver, pass non-zero to the fifth argument (<code class="docutils literal notranslate"><span class="pre">integrated</span></code>). Otherwise,
the opl3 module will allocate the specified ports by itself.</p>
<p>When the accessing the hardware requires special method instead of the
standard I/O access, you can create opl3 instance separately with
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_opl3_new()</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_opl3 *opl3;
snd_opl3_new(card, OPL3_HW_OPL3_XXX, &amp;opl3);
</pre></div>
</div>
<p>Then set <code class="docutils literal notranslate"><span class="pre">command</span></code>, <code class="docutils literal notranslate"><span class="pre">private_data</span></code> and <code class="docutils literal notranslate"><span class="pre">private_free</span></code> for the
private access function, the private data and the destructor. The
<code class="docutils literal notranslate"><span class="pre">l_port</span></code> and <code class="docutils literal notranslate"><span class="pre">r_port</span></code> are not necessarily set. Only the command
must be set properly. You can retrieve the data from the
<code class="docutils literal notranslate"><span class="pre">opl3-&gt;private_data</span></code> field.</p>
<p>After creating the opl3 instance via <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_opl3_new()</span></code>,
call <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_opl3_init()</span></code> to initialize the chip to the
proper state. Note that <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_opl3_create()</span></code> always calls
it internally.</p>
<p>If the opl3 instance is created successfully, then create a hwdep device
for this opl3.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_hwdep *opl3hwdep;
snd_opl3_hwdep_new(opl3, 0, 1, &amp;opl3hwdep);
</pre></div>
</div>
<p>The first argument is the <code class="docutils literal notranslate"><span class="pre">opl3_t</span></code> instance you created, and the
second is the index number, usually 0.</p>
<p>The third argument is the index-offset for the sequencer client assigned
to the OPL3 port. When there is an MPU401-UART, give 1 for here (UART
always takes 0).</p>
</section>
<section id="hardware-dependent-devices">
<h3>Hardware-Dependent Devices<a class="headerlink" href="#hardware-dependent-devices" title="Permalink to this headline">¶</a></h3>
<p>Some chips need user-space access for special controls or for loading
the micro code. In such a case, you can create a hwdep
(hardware-dependent) device. The hwdep API is defined in
<code class="docutils literal notranslate"><span class="pre">&lt;sound/hwdep.h&gt;</span></code>. You can find examples in opl3 driver or
<code class="docutils literal notranslate"><span class="pre">isa/sb/sb16_csp.c</span></code>.</p>
<p>The creation of the <code class="docutils literal notranslate"><span class="pre">hwdep</span></code> instance is done via
<a class="reference internal" href="alsa-driver-api.html#c.snd_hwdep_new" title="snd_hwdep_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_hwdep_new()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_hwdep *hw;
snd_hwdep_new(card, &quot;My HWDEP&quot;, 0, &amp;hw);
</pre></div>
</div>
<p>where the third argument is the index number.</p>
<p>You can then pass any pointer value to the <code class="docutils literal notranslate"><span class="pre">private_data</span></code>. If you
assign a private data, you should define the destructor, too. The
destructor function is set in the <code class="docutils literal notranslate"><span class="pre">private_free</span></code> field.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct mydata *p = kmalloc(sizeof(*p), GFP_KERNEL);
hw-&gt;private_data = p;
hw-&gt;private_free = mydata_free;
</pre></div>
</div>
<p>and the implementation of the destructor would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void mydata_free(struct snd_hwdep *hw)
{
        struct mydata *p = hw-&gt;private_data;
        kfree(p);
}
</pre></div>
</div>
<p>The arbitrary file operations can be defined for this instance. The file
operators are defined in the <code class="docutils literal notranslate"><span class="pre">ops</span></code> table. For example, assume that
this chip needs an ioctl.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>hw-&gt;ops.open = mydata_open;
hw-&gt;ops.ioctl = mydata_ioctl;
hw-&gt;ops.release = mydata_release;
</pre></div>
</div>
<p>And implement the callback functions as you like.</p>
</section>
<section id="iec958-s-pdif">
<h3>IEC958 (S/PDIF)<a class="headerlink" href="#iec958-s-pdif" title="Permalink to this headline">¶</a></h3>
<p>Usually the controls for IEC958 devices are implemented via the control
interface. There is a macro to compose a name string for IEC958
controls, <code class="xref c c-func docutils literal notranslate"><span class="pre">SNDRV_CTL_NAME_IEC958()</span></code> defined in
<code class="docutils literal notranslate"><span class="pre">&lt;include/asound.h&gt;</span></code>.</p>
<p>There are some standard controls for IEC958 status bits. These controls
use the type <code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_TYPE_IEC958</span></code>, and the size of element is
fixed as 4 bytes array (value.iec958.status[x]). For the <code class="docutils literal notranslate"><span class="pre">info</span></code>
callback, you don’t specify the value field for this type (the count
field must be set, though).</p>
<p>“IEC958 Playback Con Mask” is used to return the bit-mask for the IEC958
status bits of consumer mode. Similarly, “IEC958 Playback Pro Mask”
returns the bitmask for professional mode. They are read-only controls.</p>
<p>Meanwhile, “IEC958 Playback Default” control is defined for getting and
setting the current default IEC958 bits.</p>
<p>Due to historical reasons, both variants of the Playback Mask and the
Playback Default controls can be implemented on either a
<code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_IFACE_PCM</span></code> or a <code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_ELEM_IFACE_MIXER</span></code> iface.
Drivers should expose the mask and default on the same iface though.</p>
<p>In addition, you can define the control switches to enable/disable or to
set the raw bit mode. The implementation will depend on the chip, but
the control should be named as “IEC958 xxx”, preferably using the
<code class="xref c c-func docutils literal notranslate"><span class="pre">SNDRV_CTL_NAME_IEC958()</span></code> macro.</p>
<p>You can find several cases, for example, <code class="docutils literal notranslate"><span class="pre">pci/emu10k1</span></code>,
<code class="docutils literal notranslate"><span class="pre">pci/ice1712</span></code>, or <code class="docutils literal notranslate"><span class="pre">pci/cmipci.c</span></code>.</p>
</section>
</section>
<section id="buffer-and-memory-management">
<h2>Buffer and Memory Management<a class="headerlink" href="#buffer-and-memory-management" title="Permalink to this headline">¶</a></h2>
<section id="buffer-types">
<h3>Buffer Types<a class="headerlink" href="#buffer-types" title="Permalink to this headline">¶</a></h3>
<p>ALSA provides several different buffer allocation functions depending on
the bus and the architecture. All these have a consistent API. The
allocation of physically-contiguous pages is done via
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_malloc_xxx_pages()</span></code> function, where xxx is the bus
type.</p>
<p>The allocation of pages with fallback is
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_malloc_xxx_pages_fallback()</span></code>. This function tries
to allocate the specified pages but if the pages are not available, it
tries to reduce the page sizes until enough space is found.</p>
<p>The release the pages, call <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_free_xxx_pages()</span></code>
function.</p>
<p>Usually, ALSA drivers try to allocate and reserve a large contiguous
physical space at the time the module is loaded for the later use. This
is called “pre-allocation”. As already written, you can call the
following function at pcm instance construction time (in the case of PCI
bus).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
                                      &amp;pci-&gt;dev, size, max);
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">size</span></code> is the byte size to be pre-allocated and the <code class="docutils literal notranslate"><span class="pre">max</span></code> is
the maximum size to be changed via the <code class="docutils literal notranslate"><span class="pre">prealloc</span></code> proc file. The
allocator will try to get an area as large as possible within the
given size.</p>
<p>The second argument (type) and the third argument (device pointer) are
dependent on the bus. For normal devices, pass the device pointer
(typically identical as <code class="docutils literal notranslate"><span class="pre">card-&gt;dev</span></code>) to the third argument with
<code class="docutils literal notranslate"><span class="pre">SNDRV_DMA_TYPE_DEV</span></code> type.</p>
<p>For the continuous buffer unrelated to the
bus can be pre-allocated with <code class="docutils literal notranslate"><span class="pre">SNDRV_DMA_TYPE_CONTINUOUS</span></code> type.
You can pass NULL to the device pointer in that case, which is the
default mode implying to allocate with <code class="docutils literal notranslate"><span class="pre">GFP_KERNEL</span></code> flag.
If you need a restricted (lower) address, set up the coherent DMA mask
bits for the device, and pass the device pointer, like the normal
device memory allocations.  For this type, it’s still allowed to pass
NULL to the device pointer, too, if no address restriction is needed.</p>
<p>For the scatter-gather buffers, use <code class="docutils literal notranslate"><span class="pre">SNDRV_DMA_TYPE_DEV_SG</span></code> with the
device pointer (see the <a class="reference internal" href="#non-contiguous-buffers">Non-Contiguous Buffers</a> section).</p>
<p>Once the buffer is pre-allocated, you can use the allocator in the
<code class="docutils literal notranslate"><span class="pre">hw_params</span></code> callback:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_lib_malloc_pages(substream, size);
</pre></div>
</div>
<p>Note that you have to pre-allocate to use this function.</p>
<p>Most of drivers use, though, rather the newly introduced “managed
buffer allocation mode” instead of the manual allocation or release.
This is done by calling <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_set_managed_buffer_all" title="snd_pcm_set_managed_buffer_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_managed_buffer_all()</span></code></a>
instead of <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_lib_preallocate_pages_for_all" title="snd_pcm_lib_preallocate_pages_for_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_preallocate_pages_for_all()</span></code></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
                               &amp;pci-&gt;dev, size, max);
</pre></div>
</div>
<p>where passed arguments are identical in both functions.
The difference in the managed mode is that PCM core will call
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> internally already before calling
the PCM <code class="docutils literal notranslate"><span class="pre">hw_params</span></code> callback, and call <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_lib_free_pages" title="snd_pcm_lib_free_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_free_pages()</span></code></a>
after the PCM <code class="docutils literal notranslate"><span class="pre">hw_free</span></code> callback automatically.  So the driver
doesn’t have to call these functions explicitly in its callback any
longer.  This made many driver code having NULL <code class="docutils literal notranslate"><span class="pre">hw_params</span></code> and
<code class="docutils literal notranslate"><span class="pre">hw_free</span></code> entries.</p>
</section>
<section id="external-hardware-buffers">
<h3>External Hardware Buffers<a class="headerlink" href="#external-hardware-buffers" title="Permalink to this headline">¶</a></h3>
<p>Some chips have their own hardware buffers and the DMA transfer from the
host memory is not available. In such a case, you need to either 1)
copy/set the audio data directly to the external hardware buffer, or 2)
make an intermediate buffer and copy/set the data from it to the
external hardware buffer in interrupts (or in tasklets, preferably).</p>
<p>The first case works fine if the external hardware buffer is large
enough. This method doesn’t need any extra buffers and thus is more
effective. You need to define the <code class="docutils literal notranslate"><span class="pre">copy_user</span></code> and <code class="docutils literal notranslate"><span class="pre">copy_kernel</span></code>
callbacks for the data transfer, in addition to <code class="docutils literal notranslate"><span class="pre">fill_silence</span></code>
callback for playback. However, there is a drawback: it cannot be
mmapped. The examples are GUS’s GF1 PCM or emu8000’s wavetable PCM.</p>
<p>The second case allows for mmap on the buffer, although you have to
handle an interrupt or a tasklet to transfer the data from the
intermediate buffer to the hardware buffer. You can find an example in
the vxpocket driver.</p>
<p>Another case is when the chip uses a PCI memory-map region for the
buffer instead of the host memory. In this case, mmap is available only
on certain architectures like the Intel one. In non-mmap mode, the data
cannot be transferred as in the normal way. Thus you need to define the
<code class="docutils literal notranslate"><span class="pre">copy_user</span></code>, <code class="docutils literal notranslate"><span class="pre">copy_kernel</span></code> and <code class="docutils literal notranslate"><span class="pre">fill_silence</span></code> callbacks as well,
as in the cases above. The examples are found in <code class="docutils literal notranslate"><span class="pre">rme32.c</span></code> and
<code class="docutils literal notranslate"><span class="pre">rme96.c</span></code>.</p>
<p>The implementation of the <code class="docutils literal notranslate"><span class="pre">copy_user</span></code>, <code class="docutils literal notranslate"><span class="pre">copy_kernel</span></code> and
<code class="docutils literal notranslate"><span class="pre">silence</span></code> callbacks depends upon whether the hardware supports
interleaved or non-interleaved samples. The <code class="docutils literal notranslate"><span class="pre">copy_user</span></code> callback is
defined like below, a bit differently depending whether the direction
is playback or capture:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int playback_copy_user(struct snd_pcm_substream *substream,
             int channel, unsigned long pos,
             void __user *src, unsigned long count);
static int capture_copy_user(struct snd_pcm_substream *substream,
             int channel, unsigned long pos,
             void __user *dst, unsigned long count);
</pre></div>
</div>
<p>In the case of interleaved samples, the second argument (<code class="docutils literal notranslate"><span class="pre">channel</span></code>) is
not used. The third argument (<code class="docutils literal notranslate"><span class="pre">pos</span></code>) points the current position
offset in bytes.</p>
<p>The meaning of the fourth argument is different between playback and
capture. For playback, it holds the source data pointer, and for
capture, it’s the destination data pointer.</p>
<p>The last argument is the number of bytes to be copied.</p>
<p>What you have to do in this callback is again different between playback
and capture directions. In the playback case, you copy the given amount
of data (<code class="docutils literal notranslate"><span class="pre">count</span></code>) at the specified pointer (<code class="docutils literal notranslate"><span class="pre">src</span></code>) to the specified
offset (<code class="docutils literal notranslate"><span class="pre">pos</span></code>) on the hardware buffer. When coded like memcpy-like
way, the copy would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>my_memcpy_from_user(my_buffer + pos, src, count);
</pre></div>
</div>
<p>For the capture direction, you copy the given amount of data (<code class="docutils literal notranslate"><span class="pre">count</span></code>)
at the specified offset (<code class="docutils literal notranslate"><span class="pre">pos</span></code>) on the hardware buffer to the
specified pointer (<code class="docutils literal notranslate"><span class="pre">dst</span></code>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>my_memcpy_to_user(dst, my_buffer + pos, count);
</pre></div>
</div>
<p>Here the functions are named as <code class="docutils literal notranslate"><span class="pre">from_user</span></code> and <code class="docutils literal notranslate"><span class="pre">to_user</span></code> because
it’s the user-space buffer that is passed to these callbacks.  That
is, the callback is supposed to copy from/to the user-space data
directly to/from the hardware buffer.</p>
<p>Careful readers might notice that these callbacks receive the
arguments in bytes, not in frames like other callbacks.  It’s because
it would make coding easier like the examples above, and also it makes
easier to unify both the interleaved and non-interleaved cases, as
explained in the following.</p>
<p>In the case of non-interleaved samples, the implementation will be a bit
more complicated.  The callback is called for each channel, passed by
the second argument, so totally it’s called for N-channels times per
transfer.</p>
<p>The meaning of other arguments are almost same as the interleaved
case.  The callback is supposed to copy the data from/to the given
user-space buffer, but only for the given channel.  For the detailed
implementations, please check <code class="docutils literal notranslate"><span class="pre">isa/gus/gus_pcm.c</span></code> or
“pci/rme9652/rme9652.c” as examples.</p>
<p>The above callbacks are the copy from/to the user-space buffer.  There
are some cases where we want copy from/to the kernel-space buffer
instead.  In such a case, <code class="docutils literal notranslate"><span class="pre">copy_kernel</span></code> callback is called.  It’d
look like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int playback_copy_kernel(struct snd_pcm_substream *substream,
             int channel, unsigned long pos,
             void *src, unsigned long count);
static int capture_copy_kernel(struct snd_pcm_substream *substream,
             int channel, unsigned long pos,
             void *dst, unsigned long count);
</pre></div>
</div>
<p>As found easily, the only difference is that the buffer pointer is
without <code class="docutils literal notranslate"><span class="pre">__user</span></code> prefix; that is, a kernel-buffer pointer is passed
in the fourth argument.  Correspondingly, the implementation would be
a version without the user-copy, such as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>my_memcpy(my_buffer + pos, src, count);
</pre></div>
</div>
<p>Usually for the playback, another callback <code class="docutils literal notranslate"><span class="pre">fill_silence</span></code> is
defined.  It’s implemented in a similar way as the copy callbacks
above:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int silence(struct snd_pcm_substream *substream, int channel,
                   unsigned long pos, unsigned long count);
</pre></div>
</div>
<p>The meanings of arguments are the same as in the <code class="docutils literal notranslate"><span class="pre">copy_user</span></code> and
<code class="docutils literal notranslate"><span class="pre">copy_kernel</span></code> callbacks, although there is no buffer pointer
argument. In the case of interleaved samples, the channel argument has
no meaning, as well as on <code class="docutils literal notranslate"><span class="pre">copy_*</span></code> callbacks.</p>
<p>The role of <code class="docutils literal notranslate"><span class="pre">fill_silence</span></code> callback is to set the given amount
(<code class="docutils literal notranslate"><span class="pre">count</span></code>) of silence data at the specified offset (<code class="docutils literal notranslate"><span class="pre">pos</span></code>) on the
hardware buffer. Suppose that the data format is signed (that is, the
silent-data is 0), and the implementation using a memset-like function
would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>my_memset(my_buffer + pos, 0, count);
</pre></div>
</div>
<p>In the case of non-interleaved samples, again, the implementation
becomes a bit more complicated, as it’s called N-times per transfer
for each channel. See, for example, <code class="docutils literal notranslate"><span class="pre">isa/gus/gus_pcm.c</span></code>.</p>
</section>
<section id="non-contiguous-buffers">
<h3>Non-Contiguous Buffers<a class="headerlink" href="#non-contiguous-buffers" title="Permalink to this headline">¶</a></h3>
<p>If your hardware supports the page table as in emu10k1 or the buffer
descriptors as in via82xx, you can use the scatter-gather (SG) DMA. ALSA
provides an interface for handling SG-buffers. The API is provided in
<code class="docutils literal notranslate"><span class="pre">&lt;sound/pcm.h&gt;</span></code>.</p>
<p>For creating the SG-buffer handler, call
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_set_managed_buffer" title="snd_pcm_set_managed_buffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_managed_buffer()</span></code></a> or
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_set_managed_buffer_all" title="snd_pcm_set_managed_buffer_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_set_managed_buffer_all()</span></code></a> with
<code class="docutils literal notranslate"><span class="pre">SNDRV_DMA_TYPE_DEV_SG</span></code> in the PCM constructor like other PCI
pre-allocator. You need to pass <code class="docutils literal notranslate"><span class="pre">&amp;pci-&gt;dev</span></code>, where pci is
the struct pci_dev pointer of the chip as
well.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
                               &amp;pci-&gt;dev, size, max);
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_sg_buf</span></code> instance is created as
<code class="docutils literal notranslate"><span class="pre">substream-&gt;dma_private</span></code> in turn. You can cast the pointer like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_sg_buf *sgbuf = (struct snd_sg_buf *)substream-&gt;dma_private;
</pre></div>
</div>
<p>Then in <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> call, the common SG-buffer
handler will allocate the non-contiguous kernel pages of the given size
and map them onto the virtually contiguous memory. The virtual pointer
is addressed in runtime-&gt;dma_area. The physical address
(<code class="docutils literal notranslate"><span class="pre">runtime-&gt;dma_addr</span></code>) is set to zero, because the buffer is
physically non-contiguous. The physical address table is set up in
<code class="docutils literal notranslate"><span class="pre">sgbuf-&gt;table</span></code>. You can get the physical address at a certain offset
via <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_sgbuf_get_addr" title="snd_pcm_sgbuf_get_addr"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_sgbuf_get_addr()</span></code></a>.</p>
<p>If you need to release the SG-buffer data explicitly, call the
standard API function <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_lib_free_pages" title="snd_pcm_lib_free_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_free_pages()</span></code></a> as usual.</p>
</section>
<section id="vmalloc-ed-buffers">
<h3>Vmalloc’ed Buffers<a class="headerlink" href="#vmalloc-ed-buffers" title="Permalink to this headline">¶</a></h3>
<p>It’s possible to use a buffer allocated via <a class="reference internal" href="../../core-api/mm-api.html#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">vmalloc()</span></code></a>, for
example, for an intermediate buffer. In the recent version of kernel,
you can simply allocate it via standard
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_lib_malloc_pages" title="snd_pcm_lib_malloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_lib_malloc_pages()</span></code></a> and co after setting up the
buffer preallocation with <code class="docutils literal notranslate"><span class="pre">SNDRV_DMA_TYPE_VMALLOC</span></code> type.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC,
                               NULL, 0, 0);
</pre></div>
</div>
<p>The NULL is passed to the device pointer argument, which indicates
that the default pages (GFP_KERNEL and GFP_HIGHMEM) will be
allocated.</p>
<p>Also, note that zero is passed to both the size and the max size
arguments here.  Since each vmalloc call should succeed at any time,
we don’t need to pre-allocate the buffers like other continuous
pages.</p>
</section>
</section>
<section id="proc-interface">
<h2>Proc Interface<a class="headerlink" href="#proc-interface" title="Permalink to this headline">¶</a></h2>
<p>ALSA provides an easy interface for procfs. The proc files are very
useful for debugging. I recommend you set up proc files if you write a
driver and want to get a running status or register dumps. The API is
found in <code class="docutils literal notranslate"><span class="pre">&lt;sound/info.h&gt;</span></code>.</p>
<p>To create a proc file, call <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_proc_new()</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct snd_info_entry *entry;
int err = snd_card_proc_new(card, &quot;my-file&quot;, &amp;entry);
</pre></div>
</div>
<p>where the second argument specifies the name of the proc file to be
created. The above example will create a file <code class="docutils literal notranslate"><span class="pre">my-file</span></code> under the
card directory, e.g. <code class="docutils literal notranslate"><span class="pre">/proc/asound/card0/my-file</span></code>.</p>
<p>Like other components, the proc entry created via
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_proc_new()</span></code> will be registered and released
automatically in the card registration and release functions.</p>
<p>When the creation is successful, the function stores a new instance in
the pointer given in the third argument. It is initialized as a text
proc file for read only. To use this proc file as a read-only text file
as it is, set the read callback with a private data via
<code class="xref c c-func docutils literal notranslate"><span class="pre">snd_info_set_text_ops()</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd_info_set_text_ops(entry, chip, my_proc_read);
</pre></div>
</div>
<p>where the second argument (<code class="docutils literal notranslate"><span class="pre">chip</span></code>) is the private data to be used in
the callbacks. The third parameter specifies the read buffer size and
the fourth (<code class="docutils literal notranslate"><span class="pre">my_proc_read</span></code>) is the callback function, which is
defined like</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void my_proc_read(struct snd_info_entry *entry,
                         struct snd_info_buffer *buffer);
</pre></div>
</div>
<p>In the read callback, use <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_iprintf()</span></code> for output
strings, which works just like normal <code class="xref c c-func docutils literal notranslate"><span class="pre">printf()</span></code>. For
example,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void my_proc_read(struct snd_info_entry *entry,
                         struct snd_info_buffer *buffer)
{
        struct my_chip *chip = entry-&gt;private_data;

        snd_iprintf(buffer, &quot;This is my chip!\n&quot;);
        snd_iprintf(buffer, &quot;Port = %ld\n&quot;, chip-&gt;port);
}
</pre></div>
</div>
<p>The file permissions can be changed afterwards. As default, it’s set as
read only for all users. If you want to add write permission for the
user (root as default), do as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>entry-&gt;mode = S_IFREG | S_IRUGO | S_IWUSR;
</pre></div>
</div>
<p>and set the write buffer size and the callback</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>entry-&gt;c.text.write = my_proc_write;
</pre></div>
</div>
<p>For the write callback, you can use <a class="reference internal" href="alsa-driver-api.html#c.snd_info_get_line" title="snd_info_get_line"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_info_get_line()</span></code></a>
to get a text line, and <a class="reference internal" href="alsa-driver-api.html#c.snd_info_get_str" title="snd_info_get_str"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_info_get_str()</span></code></a> to retrieve
a string from the line. Some examples are found in
<code class="docutils literal notranslate"><span class="pre">core/oss/mixer_oss.c</span></code>, core/oss/and <code class="docutils literal notranslate"><span class="pre">pcm_oss.c</span></code>.</p>
<p>For a raw-data proc-file, set the attributes as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static const struct snd_info_entry_ops my_file_io_ops = {
        .read = my_file_io_read,
};

entry-&gt;content = SNDRV_INFO_CONTENT_DATA;
entry-&gt;private_data = chip;
entry-&gt;c.ops = &amp;my_file_io_ops;
entry-&gt;size = 4096;
entry-&gt;mode = S_IFREG | S_IRUGO;
</pre></div>
</div>
<p>For the raw data, <code class="docutils literal notranslate"><span class="pre">size</span></code> field must be set properly. This specifies
the maximum size of the proc file access.</p>
<p>The read/write callbacks of raw mode are more direct than the text mode.
You need to use a low-level I/O functions such as
<code class="xref c c-func docutils literal notranslate"><span class="pre">copy_from_user()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">copy_to_user()</span></code> to transfer the data.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static ssize_t my_file_io_read(struct snd_info_entry *entry,
                            void *file_private_data,
                            struct file *file,
                            char *buf,
                            size_t count,
                            loff_t pos)
{
        if (copy_to_user(buf, local_data + pos, count))
                return -EFAULT;
        return count;
}
</pre></div>
</div>
<p>If the size of the info entry has been set up properly, <code class="docutils literal notranslate"><span class="pre">count</span></code> and
<code class="docutils literal notranslate"><span class="pre">pos</span></code> are guaranteed to fit within 0 and the given size. You don’t
have to check the range in the callbacks unless any other condition is
required.</p>
</section>
<section id="power-management">
<h2>Power Management<a class="headerlink" href="#power-management" title="Permalink to this headline">¶</a></h2>
<p>If the chip is supposed to work with suspend/resume functions, you need
to add power-management code to the driver. The additional code for
power-management should be ifdef-ed with <code class="docutils literal notranslate"><span class="pre">CONFIG_PM</span></code>, or annotated
with __maybe_unused attribute; otherwise the compiler will complain
you.</p>
<p>If the driver <em>fully</em> supports suspend/resume that is, the device can be
properly resumed to its state when suspend was called, you can set the
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_RESUME</span></code> flag in the pcm info field. Usually, this is
possible when the registers of the chip can be safely saved and restored
to RAM. If this is set, the trigger callback is called with
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_TRIGGER_RESUME</span></code> after the resume callback completes.</p>
<p>Even if the driver doesn’t support PM fully but partial suspend/resume
is still possible, it’s still worthy to implement suspend/resume
callbacks. In such a case, applications would reset the status by
calling <a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_prepare" title="snd_pcm_prepare"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_prepare()</span></code></a> and restart the stream
appropriately. Hence, you can define suspend/resume callbacks below but
don’t set <code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_RESUME</span></code> info flag to the PCM.</p>
<p>Note that the trigger with SUSPEND can always be called when
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_suspend_all" title="snd_pcm_suspend_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_suspend_all()</span></code></a> is called, regardless of the
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_RESUME</span></code> flag. The <code class="docutils literal notranslate"><span class="pre">RESUME</span></code> flag affects only the
behavior of <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_resume()</span></code>. (Thus, in theory,
<code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_TRIGGER_RESUME</span></code> isn’t needed to be handled in the trigger
callback when no <code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_RESUME</span></code> flag is set. But, it’s better
to keep it for compatibility reasons.)</p>
<p>In the earlier version of ALSA drivers, a common power-management layer
was provided, but it has been removed. The driver needs to define the
suspend/resume hooks according to the bus the device is connected to. In
the case of PCI drivers, the callbacks look like below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int __maybe_unused snd_my_suspend(struct device *dev)
{
        .... /* do things for suspend */
        return 0;
}
static int __maybe_unused snd_my_resume(struct device *dev)
{
        .... /* do things for suspend */
        return 0;
}
</pre></div>
</div>
<p>The scheme of the real suspend job is as follows.</p>
<ol class="arabic simple">
<li><p>Retrieve the card and the chip data.</p></li>
<li><p>Call <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_power_change_state()</span></code> with
<code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_POWER_D3hot</span></code> to change the power status.</p></li>
<li><p>If AC97 codecs are used, call <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_suspend" title="snd_ac97_suspend"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_suspend()</span></code></a> for
each codec.</p></li>
<li><p>Save the register values if necessary.</p></li>
<li><p>Stop the hardware if necessary.</p></li>
</ol>
<p>A typical code would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int __maybe_unused mychip_suspend(struct device *dev)
{
        /* (1) */
        struct snd_card *card = dev_get_drvdata(dev);
        struct mychip *chip = card-&gt;private_data;
        /* (2) */
        snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
        /* (3) */
        snd_ac97_suspend(chip-&gt;ac97);
        /* (4) */
        snd_mychip_save_registers(chip);
        /* (5) */
        snd_mychip_stop_hardware(chip);
        return 0;
}
</pre></div>
</div>
<p>The scheme of the real resume job is as follows.</p>
<ol class="arabic simple">
<li><p>Retrieve the card and the chip data.</p></li>
<li><p>Re-initialize the chip.</p></li>
<li><p>Restore the saved registers if necessary.</p></li>
<li><p>Resume the mixer, e.g. calling <a class="reference internal" href="alsa-driver-api.html#c.snd_ac97_resume" title="snd_ac97_resume"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_ac97_resume()</span></code></a>.</p></li>
<li><p>Restart the hardware (if any).</p></li>
<li><p>Call <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_power_change_state()</span></code> with
<code class="docutils literal notranslate"><span class="pre">SNDRV_CTL_POWER_D0</span></code> to notify the processes.</p></li>
</ol>
<p>A typical code would be like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int __maybe_unused mychip_resume(struct pci_dev *pci)
{
        /* (1) */
        struct snd_card *card = dev_get_drvdata(dev);
        struct mychip *chip = card-&gt;private_data;
        /* (2) */
        snd_mychip_reinit_chip(chip);
        /* (3) */
        snd_mychip_restore_registers(chip);
        /* (4) */
        snd_ac97_resume(chip-&gt;ac97);
        /* (5) */
        snd_mychip_restart_chip(chip);
        /* (6) */
        snd_power_change_state(card, SNDRV_CTL_POWER_D0);
        return 0;
}
</pre></div>
</div>
<p>Note that, at the time this callback gets called, the PCM stream has
been already suspended via its own PM ops calling
<a class="reference internal" href="alsa-driver-api.html#c.snd_pcm_suspend_all" title="snd_pcm_suspend_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_suspend_all()</span></code></a> internally.</p>
<p>OK, we have all callbacks now. Let’s set them up. In the initialization
of the card, make sure that you can get the chip data from the card
instance, typically via <code class="docutils literal notranslate"><span class="pre">private_data</span></code> field, in case you created the
chip data individually.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_mychip_probe(struct pci_dev *pci,
                            const struct pci_device_id *pci_id)
{
        ....
        struct snd_card *card;
        struct mychip *chip;
        int err;
        ....
        err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                           0, &amp;card);
        ....
        chip = kzalloc(sizeof(*chip), GFP_KERNEL);
        ....
        card-&gt;private_data = chip;
        ....
}
</pre></div>
</div>
<p>When you created the chip data with <a class="reference internal" href="alsa-driver-api.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>, it’s
anyway accessible via <code class="docutils literal notranslate"><span class="pre">private_data</span></code> field.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int snd_mychip_probe(struct pci_dev *pci,
                            const struct pci_device_id *pci_id)
{
        ....
        struct snd_card *card;
        struct mychip *chip;
        int err;
        ....
        err = snd_card_new(&amp;pci-&gt;dev, index[dev], id[dev], THIS_MODULE,
                           sizeof(struct mychip), &amp;card);
        ....
        chip = card-&gt;private_data;
        ....
}
</pre></div>
</div>
<p>If you need a space to save the registers, allocate the buffer for it
here, too, since it would be fatal if you cannot allocate a memory in
the suspend phase. The allocated buffer should be released in the
corresponding destructor.</p>
<p>And next, set suspend/resume callbacks to the pci_driver.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static SIMPLE_DEV_PM_OPS(snd_my_pm_ops, mychip_suspend, mychip_resume);

static struct pci_driver driver = {
        .name = KBUILD_MODNAME,
        .id_table = snd_my_ids,
        .probe = snd_my_probe,
        .remove = snd_my_remove,
        .driver.pm = &amp;snd_my_pm_ops,
};
</pre></div>
</div>
</section>
<section id="module-parameters">
<h2>Module Parameters<a class="headerlink" href="#module-parameters" title="Permalink to this headline">¶</a></h2>
<p>There are standard module options for ALSA. At least, each module should
have the <code class="docutils literal notranslate"><span class="pre">index</span></code>, <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">enable</span></code> options.</p>
<p>If the module supports multiple cards (usually up to 8 = <code class="docutils literal notranslate"><span class="pre">SNDRV_CARDS</span></code>
cards), they should be arrays. The default initial values are defined
already as constants for easier programming:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
</pre></div>
</div>
<p>If the module supports only a single card, they could be single
variables, instead. <code class="docutils literal notranslate"><span class="pre">enable</span></code> option is not always necessary in this
case, but it would be better to have a dummy option for compatibility.</p>
<p>The module parameters must be declared with the standard
<code class="docutils literal notranslate"><span class="pre">module_param()</span></code>, <code class="docutils literal notranslate"><span class="pre">module_param_array()</span></code> and
<code class="xref c c-func docutils literal notranslate"><span class="pre">MODULE_PARM_DESC()</span></code> macros.</p>
<p>The typical coding would be like below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#define CARD_NAME &quot;My Chip&quot;

module_param_array(index, int, NULL, 0444);
MODULE_PARM_DESC(index, &quot;Index value for &quot; CARD_NAME &quot; soundcard.&quot;);
module_param_array(id, charp, NULL, 0444);
MODULE_PARM_DESC(id, &quot;ID string for &quot; CARD_NAME &quot; soundcard.&quot;);
module_param_array(enable, bool, NULL, 0444);
MODULE_PARM_DESC(enable, &quot;Enable &quot; CARD_NAME &quot; soundcard.&quot;);
</pre></div>
</div>
<p>Also, don’t forget to define the module description and the license.
Especially, the recent modprobe requires to define the
module license as GPL, etc., otherwise the system is shown as “tainted”.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MODULE_DESCRIPTION(&quot;Sound driver for My Chip&quot;);
MODULE_LICENSE(&quot;GPL&quot;);
</pre></div>
</div>
</section>
<section id="device-managed-resources">
<h2>Device-Managed Resources<a class="headerlink" href="#device-managed-resources" title="Permalink to this headline">¶</a></h2>
<p>In the examples above, all resources are allocated and released
manually.  But human beings are lazy in nature, especially developers
are lazier.  So there are some ways to automate the release part; it’s
the (device-)managed resources aka devres or devm family.  For
example, an object allocated via <a class="reference internal" href="../../driver-api/basics.html#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">devm_kmalloc()</span></code></a> will be
freed automatically at unbinding the device.</p>
<p>ALSA core provides also the device-managed helper, namely,
<a class="reference internal" href="alsa-driver-api.html#c.snd_devm_card_new" title="snd_devm_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_devm_card_new()</span></code></a> for creating a card object.
Call this functions instead of the normal <a class="reference internal" href="alsa-driver-api.html#c.snd_card_new" title="snd_card_new"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code></a>,
and you can forget the explicit <a class="reference internal" href="alsa-driver-api.html#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a> call, as
it’s called automagically at error and removal paths.</p>
<p>One caveat is that the call of <a class="reference internal" href="alsa-driver-api.html#c.snd_card_free" title="snd_card_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_free()</span></code></a> would be put
at the beginning of the call chain only after you call
<a class="reference internal" href="alsa-driver-api.html#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a>.</p>
<p>Also, the <code class="docutils literal notranslate"><span class="pre">private_free</span></code> callback is always called at the card free,
so be careful to put the hardware clean-up procedure in
<code class="docutils literal notranslate"><span class="pre">private_free</span></code> callback.  It might be called even before you
actually set up at an earlier error path.  For avoiding such an
invalid initialization, you can set <code class="docutils literal notranslate"><span class="pre">private_free</span></code> callback after
<a class="reference internal" href="alsa-driver-api.html#c.snd_card_register" title="snd_card_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_register()</span></code></a> call succeeds.</p>
<p>Another thing to be remarked is that you should use device-managed
helpers for each component as much as possible once when you manage
the card in that way.  Mixing up with the normal and the managed
resources may screw up the release order.</p>
</section>
<section id="how-to-put-your-driver-into-alsa-tree">
<h2>How To Put Your Driver Into ALSA Tree<a class="headerlink" href="#how-to-put-your-driver-into-alsa-tree" title="Permalink to this headline">¶</a></h2>
<section id="id8">
<h3>General<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>So far, you’ve learned how to write the driver codes. And you might have
a question now: how to put my own driver into the ALSA driver tree? Here
(finally :) the standard procedure is described briefly.</p>
<p>Suppose that you create a new PCI driver for the card “xyz”. The card
module name would be snd-xyz. The new driver is usually put into the
alsa-driver tree, <code class="docutils literal notranslate"><span class="pre">sound/pci</span></code> directory in the case of PCI
cards.</p>
<p>In the following sections, the driver code is supposed to be put into
Linux kernel tree. The two cases are covered: a driver consisting of a
single source file and one consisting of several source files.</p>
</section>
<section id="driver-with-a-single-source-file">
<h3>Driver with A Single Source File<a class="headerlink" href="#driver-with-a-single-source-file" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>Modify sound/pci/Makefile</p>
<p>Suppose you have a file xyz.c. Add the following two lines</p>
</li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd-xyz-objs := xyz.o
obj-$(CONFIG_SND_XYZ) += snd-xyz.o
</pre></div>
</div>
<ol class="arabic" start="2">
<li><p>Create the Kconfig entry</p>
<p>Add the new entry of Kconfig for your xyz driver. config SND_XYZ
tristate “Foobar XYZ” depends on SND select SND_PCM help Say Y here
to include support for Foobar XYZ soundcard. To compile this driver
as a module, choose M here: the module will be called snd-xyz. the
line, select SND_PCM, specifies that the driver xyz supports PCM. In
addition to SND_PCM, the following components are supported for
select command: SND_RAWMIDI, SND_TIMER, SND_HWDEP,
SND_MPU401_UART, SND_OPL3_LIB, SND_OPL4_LIB, SND_VX_LIB,
SND_AC97_CODEC. Add the select command for each supported
component.</p>
<p>Note that some selections imply the lowlevel selections. For example,
PCM includes TIMER, MPU401_UART includes RAWMIDI, AC97_CODEC
includes PCM, and OPL3_LIB includes HWDEP. You don’t need to give
the lowlevel selections again.</p>
<p>For the details of Kconfig script, refer to the kbuild documentation.</p>
</li>
</ol>
</section>
<section id="drivers-with-several-source-files">
<h3>Drivers with Several Source Files<a class="headerlink" href="#drivers-with-several-source-files" title="Permalink to this headline">¶</a></h3>
<p>Suppose that the driver snd-xyz have several source files. They are
located in the new subdirectory, sound/pci/xyz.</p>
<ol class="arabic simple">
<li><p>Add a new directory (<code class="docutils literal notranslate"><span class="pre">sound/pci/xyz</span></code>) in <code class="docutils literal notranslate"><span class="pre">sound/pci/Makefile</span></code>
as below</p></li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>obj-$(CONFIG_SND) += sound/pci/xyz/
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Under the directory <code class="docutils literal notranslate"><span class="pre">sound/pci/xyz</span></code>, create a Makefile</p></li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>snd-xyz-objs := xyz.o abc.o def.o
obj-$(CONFIG_SND_XYZ) += snd-xyz.o
</pre></div>
</div>
<ol class="arabic" start="3">
<li><p>Create the Kconfig entry</p>
<p>This procedure is as same as in the last section.</p>
</li>
</ol>
</section>
</section>
<section id="useful-functions">
<h2>Useful Functions<a class="headerlink" href="#useful-functions" title="Permalink to this headline">¶</a></h2>
<section id="snd-printk-and-friends">
<h3><a class="reference internal" href="alsa-driver-api.html#c.snd_printk" title="snd_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printk()</span></code></a> and friends<a class="headerlink" href="#snd-printk-and-friends" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This subsection describes a few helper functions for
decorating a bit more on the standard <a class="reference internal" href="../../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> &amp; co.
However, in general, the use of such helpers is no longer recommended.
If possible, try to stick with the standard functions like
<code class="xref c c-func docutils literal notranslate"><span class="pre">dev_err()</span></code> or <a class="reference internal" href="../../core-api/printk-basics.html#c.pr_err" title="pr_err"><code class="xref c c-func docutils literal notranslate"><span class="pre">pr_err()</span></code></a>.</p>
</div>
<p>ALSA provides a verbose version of the <a class="reference internal" href="../../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> function.
If a kernel config <code class="docutils literal notranslate"><span class="pre">CONFIG_SND_VERBOSE_PRINTK</span></code> is set, this function
prints the given message together with the file name and the line of the
caller. The <code class="docutils literal notranslate"><span class="pre">KERN_XXX</span></code> prefix is processed as well as the original
<a class="reference internal" href="../../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a> does, so it’s recommended to add this prefix,
e.g. snd_printk(KERN_ERR “Oh my, sorry, it’s extremely bad!\n”);</p>
<p>There are also <a class="reference internal" href="../../core-api/printk-basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">printk()</span></code></a>’s for debugging.
<a class="reference internal" href="alsa-driver-api.html#c.snd_printd" title="snd_printd"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printd()</span></code></a> can be used for general debugging purposes.
If <code class="docutils literal notranslate"><span class="pre">CONFIG_SND_DEBUG</span></code> is set, this function is compiled, and works
just like <a class="reference internal" href="alsa-driver-api.html#c.snd_printk" title="snd_printk"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printk()</span></code></a>. If the ALSA is compiled without
the debugging flag, it’s ignored.</p>
<p><a class="reference internal" href="alsa-driver-api.html#c.snd_printdd" title="snd_printdd"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printdd()</span></code></a> is compiled in only when
<code class="docutils literal notranslate"><span class="pre">CONFIG_SND_DEBUG_VERBOSE</span></code> is set.</p>
</section>
<section id="snd-bug">
<h3><a class="reference internal" href="alsa-driver-api.html#c.snd_BUG" title="snd_BUG"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_BUG()</span></code></a><a class="headerlink" href="#snd-bug" title="Permalink to this headline">¶</a></h3>
<p>It shows the <code class="docutils literal notranslate"><span class="pre">BUG?</span></code> message and stack trace as well as
<a class="reference internal" href="alsa-driver-api.html#c.snd_BUG_ON" title="snd_BUG_ON"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_BUG_ON()</span></code></a> at the point. It’s useful to show that a
fatal error happens there.</p>
<p>When no debug flag is set, this macro is ignored.</p>
</section>
<section id="snd-bug-on">
<h3><a class="reference internal" href="alsa-driver-api.html#c.snd_BUG_ON" title="snd_BUG_ON"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_BUG_ON()</span></code></a><a class="headerlink" href="#snd-bug-on" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="alsa-driver-api.html#c.snd_BUG_ON" title="snd_BUG_ON"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_BUG_ON()</span></code></a> macro is similar with
<code class="xref c c-func docutils literal notranslate"><span class="pre">WARN_ON()</span></code> macro. For example, snd_BUG_ON(!pointer); or
it can be used as the condition, if (snd_BUG_ON(non_zero_is_bug))
return -EINVAL;</p>
<p>The macro takes an conditional expression to evaluate. When
<code class="docutils literal notranslate"><span class="pre">CONFIG_SND_DEBUG</span></code>, is set, if the expression is non-zero, it shows
the warning message such as <code class="docutils literal notranslate"><span class="pre">BUG?</span> <span class="pre">(xxx)</span></code> normally followed by stack
trace. In both cases it returns the evaluated value.</p>
</section>
</section>
<section id="acknowledgments">
<h2>Acknowledgments<a class="headerlink" href="#acknowledgments" title="Permalink to this headline">¶</a></h2>
<p>I would like to thank Phil Kerr for his help for improvement and
corrections of this document.</p>
<p>Kevin Conder reformatted the original plain-text to the DocBook format.</p>
<p>Giuliano Pochini corrected typos and contributed the example codes in
the hardware constraints section.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Writing an ALSA Driver</a><ul>
<li><a class="reference internal" href="#preface">Preface</a></li>
<li><a class="reference internal" href="#file-tree-structure">File Tree Structure</a><ul>
<li><a class="reference internal" href="#general">General</a></li>
<li><a class="reference internal" href="#core-directory">core directory</a><ul>
<li><a class="reference internal" href="#core-oss">core/oss</a></li>
<li><a class="reference internal" href="#core-seq">core/seq</a></li>
<li><a class="reference internal" href="#core-seq-oss">core/seq/oss</a></li>
</ul>
</li>
<li><a class="reference internal" href="#include-directory">include directory</a></li>
<li><a class="reference internal" href="#drivers-directory">drivers directory</a><ul>
<li><a class="reference internal" href="#drivers-mpu401">drivers/mpu401</a></li>
<li><a class="reference internal" href="#drivers-opl3-and-opl4">drivers/opl3 and opl4</a></li>
</ul>
</li>
<li><a class="reference internal" href="#i2c-directory">i2c directory</a></li>
<li><a class="reference internal" href="#synth-directory">synth directory</a></li>
<li><a class="reference internal" href="#pci-directory">pci directory</a></li>
<li><a class="reference internal" href="#isa-directory">isa directory</a></li>
<li><a class="reference internal" href="#arm-ppc-and-sparc-directories">arm, ppc, and sparc directories</a></li>
<li><a class="reference internal" href="#usb-directory">usb directory</a></li>
<li><a class="reference internal" href="#pcmcia-directory">pcmcia directory</a></li>
<li><a class="reference internal" href="#soc-directory">soc directory</a></li>
<li><a class="reference internal" href="#oss-directory">oss directory</a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-flow-for-pci-drivers">Basic Flow for PCI Drivers</a><ul>
<li><a class="reference internal" href="#outline">Outline</a></li>
<li><a class="reference internal" href="#full-code-example">Full Code Example</a></li>
<li><a class="reference internal" href="#driver-constructor">Driver Constructor</a><ul>
<li><a class="reference internal" href="#check-and-increment-the-device-index">1) Check and increment the device index.</a></li>
<li><a class="reference internal" href="#create-a-card-instance">2) Create a card instance</a></li>
<li><a class="reference internal" href="#create-a-main-component">3) Create a main component</a></li>
<li><a class="reference internal" href="#set-the-driver-id-and-name-strings">4) Set the driver ID and name strings.</a></li>
<li><a class="reference internal" href="#create-other-components-such-as-mixer-midi-etc">5) Create other components, such as mixer, MIDI, etc.</a></li>
<li><a class="reference internal" href="#register-the-card-instance">6) Register the card instance.</a></li>
<li><a class="reference internal" href="#set-the-pci-driver-data-and-return-zero">7) Set the PCI driver data and return zero.</a></li>
</ul>
</li>
<li><a class="reference internal" href="#destructor">Destructor</a></li>
<li><a class="reference internal" href="#header-files">Header Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#management-of-cards-and-components">Management of Cards and Components</a><ul>
<li><a class="reference internal" href="#card-instance">Card Instance</a></li>
<li><a class="reference internal" href="#components">Components</a></li>
<li><a class="reference internal" href="#chip-specific-data">Chip-Specific Data</a><ul>
<li><a class="reference internal" href="#allocating-via-snd-card-new">1. Allocating via <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_card_new()</span></code>.</a></li>
<li><a class="reference internal" href="#allocating-an-extra-device">2. Allocating an extra device.</a></li>
</ul>
</li>
<li><a class="reference internal" href="#registration-and-release">Registration and Release</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pci-resource-management">PCI Resource Management</a><ul>
<li><a class="reference internal" href="#id1">Full Code Example</a></li>
<li><a class="reference internal" href="#some-hafta-s">Some Hafta’s</a></li>
<li><a class="reference internal" href="#resource-allocation">Resource Allocation</a></li>
<li><a class="reference internal" href="#pci-entries">PCI Entries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pcm-interface">PCM Interface</a><ul>
<li><a class="reference internal" href="#id2">General</a></li>
<li><a class="reference internal" href="#id3">Full Code Example</a></li>
<li><a class="reference internal" href="#pcm-constructor">PCM Constructor</a></li>
<li><a class="reference internal" href="#and-the-destructor">… And the Destructor?</a></li>
<li><a class="reference internal" href="#runtime-pointer-the-chest-of-pcm-information">Runtime Pointer - The Chest of PCM Information</a><ul>
<li><a class="reference internal" href="#hardware-description">Hardware Description</a></li>
<li><a class="reference internal" href="#pcm-configurations">PCM Configurations</a></li>
<li><a class="reference internal" href="#dma-buffer-information">DMA Buffer Information</a></li>
<li><a class="reference internal" href="#running-status">Running Status</a></li>
<li><a class="reference internal" href="#private-data">Private Data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#operators">Operators</a><ul>
<li><a class="reference internal" href="#pcm-open-callback">PCM open callback</a></li>
<li><a class="reference internal" href="#close-callback">close callback</a></li>
<li><a class="reference internal" href="#ioctl-callback">ioctl callback</a></li>
<li><a class="reference internal" href="#hw-params-callback">hw_params callback</a></li>
<li><a class="reference internal" href="#hw-free-callback">hw_free callback</a></li>
<li><a class="reference internal" href="#prepare-callback">prepare callback</a></li>
<li><a class="reference internal" href="#trigger-callback">trigger callback</a></li>
<li><a class="reference internal" href="#sync-stop-callback">sync_stop callback</a></li>
<li><a class="reference internal" href="#pointer-callback">pointer callback</a></li>
<li><a class="reference internal" href="#copy-user-copy-kernel-and-fill-silence-ops">copy_user, copy_kernel and fill_silence ops</a></li>
<li><a class="reference internal" href="#ack-callback">ack callback</a></li>
<li><a class="reference internal" href="#page-callback">page callback</a></li>
<li><a class="reference internal" href="#mmap-calllback">mmap calllback</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pcm-interrupt-handler">PCM Interrupt Handler</a><ul>
<li><a class="reference internal" href="#interrupts-at-the-period-fragment-boundary">Interrupts at the period (fragment) boundary</a></li>
<li><a class="reference internal" href="#high-frequency-timer-interrupts">High frequency timer interrupts</a></li>
<li><a class="reference internal" href="#on-calling-snd-pcm-period-elapsed">On calling <code class="xref c c-func docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#atomicity">Atomicity</a></li>
<li><a class="reference internal" href="#constraints">Constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#control-interface">Control Interface</a><ul>
<li><a class="reference internal" href="#id4">General</a></li>
<li><a class="reference internal" href="#definition-of-controls">Definition of Controls</a></li>
<li><a class="reference internal" href="#control-names">Control Names</a><ul>
<li><a class="reference internal" href="#global-capture-and-playback">Global capture and playback</a></li>
<li><a class="reference internal" href="#tone-controls">Tone-controls</a></li>
<li><a class="reference internal" href="#d-controls">3D controls</a></li>
<li><a class="reference internal" href="#mic-boost">Mic boost</a></li>
</ul>
</li>
<li><a class="reference internal" href="#access-flags">Access Flags</a></li>
<li><a class="reference internal" href="#control-callbacks">Control Callbacks</a><ul>
<li><a class="reference internal" href="#info-callback">info callback</a></li>
<li><a class="reference internal" href="#get-callback">get callback</a></li>
<li><a class="reference internal" href="#put-callback">put callback</a></li>
<li><a class="reference internal" href="#callbacks-are-not-atomic">Callbacks are not atomic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#control-constructor">Control Constructor</a></li>
<li><a class="reference internal" href="#change-notification">Change Notification</a></li>
<li><a class="reference internal" href="#metadata">Metadata</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api-for-ac97-codec">API for AC97 Codec</a><ul>
<li><a class="reference internal" href="#id5">General</a></li>
<li><a class="reference internal" href="#id6">Full Code Example</a></li>
<li><a class="reference internal" href="#ac97-constructor">AC97 Constructor</a></li>
<li><a class="reference internal" href="#ac97-callbacks">AC97 Callbacks</a></li>
<li><a class="reference internal" href="#updating-registers-in-the-driver">Updating Registers in The Driver</a></li>
<li><a class="reference internal" href="#clock-adjustment">Clock Adjustment</a></li>
<li><a class="reference internal" href="#proc-files">Proc Files</a></li>
<li><a class="reference internal" href="#multiple-codecs">Multiple Codecs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#midi-mpu401-uart-interface">MIDI (MPU401-UART) Interface</a><ul>
<li><a class="reference internal" href="#id7">General</a></li>
<li><a class="reference internal" href="#midi-constructor">MIDI Constructor</a></li>
<li><a class="reference internal" href="#midi-interrupt-handler">MIDI Interrupt Handler</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rawmidi-interface">RawMIDI Interface</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#rawmidi-constructor">RawMIDI Constructor</a></li>
<li><a class="reference internal" href="#rawmidi-callbacks">RawMIDI Callbacks</a><ul>
<li><a class="reference internal" href="#rawmidi-open-callback">RawMIDI open callback</a></li>
<li><a class="reference internal" href="#rawmidi-close-callback">RawMIDI close callback</a></li>
<li><a class="reference internal" href="#rawmidi-trigger-callback-for-output-substreams">Rawmidi trigger callback for output substreams</a></li>
<li><a class="reference internal" href="#rawmidi-trigger-callback-for-input-substreams">RawMIDI trigger callback for input substreams</a></li>
<li><a class="reference internal" href="#drain-callback">drain callback</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#miscellaneous-devices">Miscellaneous Devices</a><ul>
<li><a class="reference internal" href="#fm-opl3">FM OPL3</a></li>
<li><a class="reference internal" href="#hardware-dependent-devices">Hardware-Dependent Devices</a></li>
<li><a class="reference internal" href="#iec958-s-pdif">IEC958 (S/PDIF)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-and-memory-management">Buffer and Memory Management</a><ul>
<li><a class="reference internal" href="#buffer-types">Buffer Types</a></li>
<li><a class="reference internal" href="#external-hardware-buffers">External Hardware Buffers</a></li>
<li><a class="reference internal" href="#non-contiguous-buffers">Non-Contiguous Buffers</a></li>
<li><a class="reference internal" href="#vmalloc-ed-buffers">Vmalloc’ed Buffers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proc-interface">Proc Interface</a></li>
<li><a class="reference internal" href="#power-management">Power Management</a></li>
<li><a class="reference internal" href="#module-parameters">Module Parameters</a></li>
<li><a class="reference internal" href="#device-managed-resources">Device-Managed Resources</a></li>
<li><a class="reference internal" href="#how-to-put-your-driver-into-alsa-tree">How To Put Your Driver Into ALSA Tree</a><ul>
<li><a class="reference internal" href="#id8">General</a></li>
<li><a class="reference internal" href="#driver-with-a-single-source-file">Driver with A Single Source File</a></li>
<li><a class="reference internal" href="#drivers-with-several-source-files">Drivers with Several Source Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#useful-functions">Useful Functions</a><ul>
<li><a class="reference internal" href="#snd-printk-and-friends"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_printk()</span></code> and friends</a></li>
<li><a class="reference internal" href="#snd-bug"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_BUG()</span></code></a></li>
<li><a class="reference internal" href="#snd-bug-on"><code class="xref c c-func docutils literal notranslate"><span class="pre">snd_BUG_ON()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sound/kernel-api/writing-an-alsa-driver.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/sound/kernel-api/writing-an-alsa-driver.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>