
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Static Keys &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="TEE subsystem" href="tee.html" />
    <link rel="prev" title="Speculation" href="speculation.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="static-keys">
<h1>Static Keys<a class="headerlink" href="#static-keys" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>DEPRECATED API:</p>
<p>The use of ‘struct static_key’ directly, is now DEPRECATED. In addition
static_key_{true,false}() is also DEPRECATED. IE DO NOT use the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct static_key false = STATIC_KEY_INIT_FALSE;
struct static_key true = STATIC_KEY_INIT_TRUE;
static_key_true()
static_key_false()
</pre></div>
</div>
<p>The updated API replacements are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DEFINE_STATIC_KEY_TRUE(key);
DEFINE_STATIC_KEY_FALSE(key);
DEFINE_STATIC_KEY_ARRAY_TRUE(keys, count);
DEFINE_STATIC_KEY_ARRAY_FALSE(keys, count);
static_branch_likely()
static_branch_unlikely()
</pre></div>
</div>
</div>
<section id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>Static keys allows the inclusion of seldom used features in
performance-sensitive fast-path kernel code, via a GCC feature and a code
patching technique. A quick example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DEFINE_STATIC_KEY_FALSE(key);

...

if (static_branch_unlikely(&amp;key))
        do unlikely code
else
        do likely code

...
static_branch_enable(&amp;key);
...
static_branch_disable(&amp;key);
...
</pre></div>
</div>
<p>The static_branch_unlikely() branch will be generated into the code with as little
impact to the likely code path as possible.</p>
</section>
<section id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>Currently, tracepoints are implemented using a conditional branch. The
conditional check requires checking a global variable for each tracepoint.
Although the overhead of this check is small, it increases when the memory
cache comes under pressure (memory cache lines for these global variables may
be shared with other memory accesses). As we increase the number of tracepoints
in the kernel this overhead may become more of an issue. In addition,
tracepoints are often dormant (disabled) and provide no direct kernel
functionality. Thus, it is highly desirable to reduce their impact as much as
possible. Although tracepoints are the original motivation for this work, other
kernel code paths should be able to make use of the static keys facility.</p>
</section>
<section id="solution">
<h2>Solution<a class="headerlink" href="#solution" title="Permalink to this headline">¶</a></h2>
<p>gcc (v4.5) adds a new ‘asm goto’ statement that allows branching to a label:</p>
<p><a class="reference external" href="https://gcc.gnu.org/ml/gcc-patches/2009-07/msg01556.html">https://gcc.gnu.org/ml/gcc-patches/2009-07/msg01556.html</a></p>
<p>Using the ‘asm goto’, we can create branches that are either taken or not taken
by default, without the need to check memory. Then, at run-time, we can patch
the branch site to change the branch direction.</p>
<p>For example, if we have a simple branch that is disabled by default:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (static_branch_unlikely(&amp;key))
        printk(&quot;I am the true branch\n&quot;);
</pre></div>
</div>
<p>Thus, by default the ‘printk’ will not be emitted. And the code generated will
consist of a single atomic ‘no-op’ instruction (5 bytes on x86), in the
straight-line code path. When the branch is ‘flipped’, we will patch the
‘no-op’ in the straight-line codepath with a ‘jump’ instruction to the
out-of-line true branch. Thus, changing branch direction is expensive but
branch selection is basically ‘free’. That is the basic tradeoff of this
optimization.</p>
<p>This lowlevel patching mechanism is called ‘jump label patching’, and it gives
the basis for the static keys facility.</p>
</section>
<section id="static-key-label-api-usage-and-examples">
<h2>Static key label API, usage and examples<a class="headerlink" href="#static-key-label-api-usage-and-examples" title="Permalink to this headline">¶</a></h2>
<p>In order to make use of this optimization you must first define a key:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DEFINE_STATIC_KEY_TRUE(key);
</pre></div>
</div>
<p>or:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DEFINE_STATIC_KEY_FALSE(key);
</pre></div>
</div>
<p>The key must be global, that is, it can’t be allocated on the stack or dynamically
allocated at run-time.</p>
<p>The key is then used in code as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (static_branch_unlikely(&amp;key))
        do unlikely code
else
        do likely code
</pre></div>
</div>
<p>Or:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (static_branch_likely(&amp;key))
        do likely code
else
        do unlikely code
</pre></div>
</div>
<p>Keys defined via DEFINE_STATIC_KEY_TRUE(), or DEFINE_STATIC_KEY_FALSE, may
be used in either static_branch_likely() or static_branch_unlikely()
statements.</p>
<p>Branch(es) can be set true via:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static_branch_enable(&amp;key);
</pre></div>
</div>
<p>or false via:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static_branch_disable(&amp;key);
</pre></div>
</div>
<p>The branch(es) can then be switched via reference counts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static_branch_inc(&amp;key);
...
static_branch_dec(&amp;key);
</pre></div>
</div>
<p>Thus, ‘static_branch_inc()’ means ‘make the branch true’, and
‘static_branch_dec()’ means ‘make the branch false’ with appropriate
reference counting. For example, if the key is initialized true, a
static_branch_dec(), will switch the branch to false. And a subsequent
static_branch_inc(), will change the branch back to true. Likewise, if the
key is initialized false, a ‘static_branch_inc()’, will change the branch to
true. And then a ‘static_branch_dec()’, will again make the branch false.</p>
<p>The state and the reference count can be retrieved with ‘static_key_enabled()’
and ‘static_key_count()’.  In general, if you use these functions, they
should be protected with the same mutex used around the enable/disable
or increment/decrement function.</p>
<p>Note that switching branches results in some locks being taken,
particularly the CPU hotplug lock (in order to avoid races against
CPUs being brought in the kernel while the kernel is getting
patched). Calling the static key API from within a hotplug notifier is
thus a sure deadlock recipe. In order to still allow use of the
functionality, the following functions are provided:</p>
<blockquote>
<div><p>static_key_enable_cpuslocked()
static_key_disable_cpuslocked()
static_branch_enable_cpuslocked()
static_branch_disable_cpuslocked()</p>
</div></blockquote>
<p>These functions are <em>not</em> general purpose, and must only be used when
you really know that you’re in the above context, and no other.</p>
<p>Where an array of keys is required, it can be defined as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DEFINE_STATIC_KEY_ARRAY_TRUE(keys, count);
</pre></div>
</div>
<p>or:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DEFINE_STATIC_KEY_ARRAY_FALSE(keys, count);
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>Architecture level code patching interface, ‘jump labels’</p></li>
</ol>
<p>There are a few functions and macros that architectures must implement in order
to take advantage of this optimization. If there is no architecture support, we
simply fall back to a traditional, load, test, and jump sequence. Also, the
struct jump_entry table must be at least 4-byte aligned because the
static_key-&gt;entry field makes use of the two least significant bits.</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">HAVE_ARCH_JUMP_LABEL</span></code>,</dt><dd><p>see: arch/x86/Kconfig</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">JUMP_LABEL_NOP_SIZE</span></code>,</dt><dd><p>see: arch/x86/include/asm/jump_label.h</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__always_inline</span> <span class="pre">bool</span> <span class="pre">arch_static_branch(struct</span> <span class="pre">static_key</span> <span class="pre">*key,</span> <span class="pre">bool</span> <span class="pre">branch)</span></code>,</dt><dd><p>see: arch/x86/include/asm/jump_label.h</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__always_inline</span> <span class="pre">bool</span> <span class="pre">arch_static_branch_jump(struct</span> <span class="pre">static_key</span> <span class="pre">*key,</span> <span class="pre">bool</span> <span class="pre">branch)</span></code>,</dt><dd><p>see: arch/x86/include/asm/jump_label.h</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">arch_jump_label_transform(struct</span> <span class="pre">jump_entry</span> <span class="pre">*entry,</span> <span class="pre">enum</span> <span class="pre">jump_label_type</span> <span class="pre">type)</span></code>,</dt><dd><p>see: arch/x86/kernel/jump_label.c</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">jump_entry</span></code>,</dt><dd><p>see: arch/x86/include/asm/jump_label.h</p>
</dd>
</dl>
</li>
</ul>
<ol class="arabic simple" start="5">
<li><p>Static keys / jump label analysis, results (x86_64):</p></li>
</ol>
<p>As an example, let’s add the following branch to ‘getppid()’, such that the
system call now looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SYSCALL_DEFINE0(getppid)
{
      int pid;

+     if (static_branch_unlikely(&amp;key))
+             printk(&quot;I am the true branch\n&quot;);

      rcu_read_lock();
      pid = task_tgid_vnr(rcu_dereference(current-&gt;real_parent));
      rcu_read_unlock();

      return pid;
}
</pre></div>
</div>
<p>The resulting instructions with jump labels generated by GCC is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ffffffff81044290 &lt;sys_getppid&gt;:
ffffffff81044290:       55                      push   %rbp
ffffffff81044291:       48 89 e5                mov    %rsp,%rbp
ffffffff81044294:       e9 00 00 00 00          jmpq   ffffffff81044299 &lt;sys_getppid+0x9&gt;
ffffffff81044299:       65 48 8b 04 25 c0 b6    mov    %gs:0xb6c0,%rax
ffffffff810442a0:       00 00
ffffffff810442a2:       48 8b 80 80 02 00 00    mov    0x280(%rax),%rax
ffffffff810442a9:       48 8b 80 b0 02 00 00    mov    0x2b0(%rax),%rax
ffffffff810442b0:       48 8b b8 e8 02 00 00    mov    0x2e8(%rax),%rdi
ffffffff810442b7:       e8 f4 d9 00 00          callq  ffffffff81051cb0 &lt;pid_vnr&gt;
ffffffff810442bc:       5d                      pop    %rbp
ffffffff810442bd:       48 98                   cltq
ffffffff810442bf:       c3                      retq
ffffffff810442c0:       48 c7 c7 e3 54 98 81    mov    $0xffffffff819854e3,%rdi
ffffffff810442c7:       31 c0                   xor    %eax,%eax
ffffffff810442c9:       e8 71 13 6d 00          callq  ffffffff8171563f &lt;printk&gt;
ffffffff810442ce:       eb c9                   jmp    ffffffff81044299 &lt;sys_getppid+0x9&gt;
</pre></div>
</div>
<p>Without the jump label optimization it looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ffffffff810441f0 &lt;sys_getppid&gt;:
ffffffff810441f0:       8b 05 8a 52 d8 00       mov    0xd8528a(%rip),%eax        # ffffffff81dc9480 &lt;key&gt;
ffffffff810441f6:       55                      push   %rbp
ffffffff810441f7:       48 89 e5                mov    %rsp,%rbp
ffffffff810441fa:       85 c0                   test   %eax,%eax
ffffffff810441fc:       75 27                   jne    ffffffff81044225 &lt;sys_getppid+0x35&gt;
ffffffff810441fe:       65 48 8b 04 25 c0 b6    mov    %gs:0xb6c0,%rax
ffffffff81044205:       00 00
ffffffff81044207:       48 8b 80 80 02 00 00    mov    0x280(%rax),%rax
ffffffff8104420e:       48 8b 80 b0 02 00 00    mov    0x2b0(%rax),%rax
ffffffff81044215:       48 8b b8 e8 02 00 00    mov    0x2e8(%rax),%rdi
ffffffff8104421c:       e8 2f da 00 00          callq  ffffffff81051c50 &lt;pid_vnr&gt;
ffffffff81044221:       5d                      pop    %rbp
ffffffff81044222:       48 98                   cltq
ffffffff81044224:       c3                      retq
ffffffff81044225:       48 c7 c7 13 53 98 81    mov    $0xffffffff81985313,%rdi
ffffffff8104422c:       31 c0                   xor    %eax,%eax
ffffffff8104422e:       e8 60 0f 6d 00          callq  ffffffff81715193 &lt;printk&gt;
ffffffff81044233:       eb c9                   jmp    ffffffff810441fe &lt;sys_getppid+0xe&gt;
ffffffff81044235:       66 66 2e 0f 1f 84 00    data32 nopw %cs:0x0(%rax,%rax,1)
ffffffff8104423c:       00 00 00 00
</pre></div>
</div>
<p>Thus, the disable jump label case adds a ‘mov’, ‘test’ and ‘jne’ instruction
vs. the jump label case just has a ‘no-op’ or ‘jmp 0’. (The jmp 0, is patched
to a 5 byte atomic no-op instruction at boot-time.) Thus, the disabled jump
label case adds:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>6 (mov) + 2 (test) + 2 (jne) = 10 - 5 (5 byte jump 0) = 5 addition bytes.
</pre></div>
</div>
<p>If we then include the padding bytes, the jump label code saves, 16 total bytes
of instruction memory for this small function. In this case the non-jump label
function is 80 bytes long. Thus, we have saved 20% of the instruction
footprint. We can in fact improve this even further, since the 5-byte no-op
really can be a 2-byte no-op since we can reach the branch with a 2-byte jmp.
However, we have not yet implemented optimal no-op sizes (they are currently
hard-coded).</p>
<p>Since there are a number of static key API uses in the scheduler paths,
‘pipe-test’ (also known as ‘perf bench sched pipe’) can be used to show the
performance improvement. Testing done on 3.3.0-rc2:</p>
<p>jump label disabled:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Performance counter stats for &#39;bash -c /tmp/pipe-test&#39; (50 runs):

       855.700314 task-clock                #    0.534 CPUs utilized            ( +-  0.11% )
          200,003 context-switches          #    0.234 M/sec                    ( +-  0.00% )
                0 CPU-migrations            #    0.000 M/sec                    ( +- 39.58% )
              487 page-faults               #    0.001 M/sec                    ( +-  0.02% )
    1,474,374,262 cycles                    #    1.723 GHz                      ( +-  0.17% )
  &lt;not supported&gt; stalled-cycles-frontend
  &lt;not supported&gt; stalled-cycles-backend
    1,178,049,567 instructions              #    0.80  insns per cycle          ( +-  0.06% )
      208,368,926 branches                  #  243.507 M/sec                    ( +-  0.06% )
        5,569,188 branch-misses             #    2.67% of all branches          ( +-  0.54% )

      1.601607384 seconds time elapsed                                          ( +-  0.07% )
</pre></div>
</div>
<p>jump label enabled:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Performance counter stats for &#39;bash -c /tmp/pipe-test&#39; (50 runs):

       841.043185 task-clock                #    0.533 CPUs utilized            ( +-  0.12% )
          200,004 context-switches          #    0.238 M/sec                    ( +-  0.00% )
                0 CPU-migrations            #    0.000 M/sec                    ( +- 40.87% )
              487 page-faults               #    0.001 M/sec                    ( +-  0.05% )
    1,432,559,428 cycles                    #    1.703 GHz                      ( +-  0.18% )
  &lt;not supported&gt; stalled-cycles-frontend
  &lt;not supported&gt; stalled-cycles-backend
    1,175,363,994 instructions              #    0.82  insns per cycle          ( +-  0.04% )
      206,859,359 branches                  #  245.956 M/sec                    ( +-  0.04% )
        4,884,119 branch-misses             #    2.36% of all branches          ( +-  0.85% )

      1.579384366 seconds time elapsed
</pre></div>
</div>
<p>The percentage of saved branches is .7%, and we’ve saved 12% on
‘branch-misses’. This is where we would expect to get the most savings, since
this optimization is about reducing the number of branches. In addition, we’ve
saved .2% on instructions, and 2.8% on cycles and 1.4% on elapsed time.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Static Keys</a><ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#solution">Solution</a></li>
<li><a class="reference internal" href="#static-key-label-api-usage-and-examples">Static key label API, usage and examples</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/staging/static-keys.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/staging/static-keys.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>