
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>A Tour Through TREE_RCU’s Grace-Period Memory Ordering &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="A Tour Through TREE_RCU’s Expedited Grace Periods" href="../Expedited-Grace-Periods/Expedited-Grace-Periods.html" />
    <link rel="prev" title="RCU on Uniprocessor Systems" href="../../UP.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="a-tour-through-tree-rcu-s-grace-period-memory-ordering">
<h1>A Tour Through TREE_RCU’s Grace-Period Memory Ordering<a class="headerlink" href="#a-tour-through-tree-rcu-s-grace-period-memory-ordering" title="Permalink to this headline">¶</a></h1>
<p>August 8, 2017</p>
<p>This article was contributed by Paul E. McKenney</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document gives a rough visual overview of how Tree RCU’s
grace-period memory ordering guarantee is provided.</p>
</section>
<section id="what-is-tree-rcu-s-grace-period-memory-ordering-guarantee">
<h2>What Is Tree RCU’s Grace Period Memory Ordering Guarantee?<a class="headerlink" href="#what-is-tree-rcu-s-grace-period-memory-ordering-guarantee" title="Permalink to this headline">¶</a></h2>
<p>RCU grace periods provide extremely strong memory-ordering guarantees
for non-idle non-offline code.
Any code that happens after the end of a given RCU grace period is guaranteed
to see the effects of all accesses prior to the beginning of that grace
period that are within RCU read-side critical sections.
Similarly, any code that happens before the beginning of a given RCU grace
period is guaranteed to not see the effects of all accesses following the end
of that grace period that are within RCU read-side critical sections.</p>
<p>Note well that RCU-sched read-side critical sections include any region
of code for which preemption is disabled.
Given that each individual machine instruction can be thought of as
an extremely small region of preemption-disabled code, one can think of
<code class="docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code> as <code class="docutils literal notranslate"><span class="pre">smp_mb()</span></code> on steroids.</p>
<p>RCU updaters use this guarantee by splitting their updates into
two phases, one of which is executed before the grace period and
the other of which is executed after the grace period.
In the most common use case, phase one removes an element from
a linked RCU-protected data structure, and phase two frees that element.
For this to work, any readers that have witnessed state prior to the
phase-one update (in the common case, removal) must not witness state
following the phase-two update (in the common case, freeing).</p>
<p>The RCU implementation provides this guarantee using a network
of lock-based critical sections, memory barriers, and per-CPU
processing, as is described in the following sections.</p>
</section>
<section id="tree-rcu-grace-period-memory-ordering-building-blocks">
<h2>Tree RCU Grace Period Memory Ordering Building Blocks<a class="headerlink" href="#tree-rcu-grace-period-memory-ordering-building-blocks" title="Permalink to this headline">¶</a></h2>
<p>The workhorse for RCU’s grace-period memory ordering is the
critical section for the <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s
<code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code>. These critical sections use helper functions for lock
acquisition, including <code class="docutils literal notranslate"><span class="pre">raw_spin_lock_rcu_node()</span></code>,
<code class="docutils literal notranslate"><span class="pre">raw_spin_lock_irq_rcu_node()</span></code>, and <code class="docutils literal notranslate"><span class="pre">raw_spin_lock_irqsave_rcu_node()</span></code>.
Their lock-release counterparts are <code class="docutils literal notranslate"><span class="pre">raw_spin_unlock_rcu_node()</span></code>,
<code class="docutils literal notranslate"><span class="pre">raw_spin_unlock_irq_rcu_node()</span></code>, and
<code class="docutils literal notranslate"><span class="pre">raw_spin_unlock_irqrestore_rcu_node()</span></code>, respectively.
For completeness, a <code class="docutils literal notranslate"><span class="pre">raw_spin_trylock_rcu_node()</span></code> is also provided.
The key point is that the lock-acquisition functions, including
<code class="docutils literal notranslate"><span class="pre">raw_spin_trylock_rcu_node()</span></code>, all invoke <code class="docutils literal notranslate"><span class="pre">smp_mb__after_unlock_lock()</span></code>
immediately after successful acquisition of the lock.</p>
<p>Therefore, for any given <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure, any access
happening before one of the above lock-release functions will be seen
by all CPUs as happening before any access happening after a later
one of the above lock-acquisition functions.
Furthermore, any access happening before one of the
above lock-release function on any given CPU will be seen by all
CPUs as happening before any access happening after a later one
of the above lock-acquisition functions executing on that same CPU,
even if the lock-release and lock-acquisition functions are operating
on different <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structures.
Tree RCU uses these two ordering guarantees to form an ordering
network among all CPUs that were in any way involved in the grace
period, including any CPUs that came online or went offline during
the grace period in question.</p>
<p>The following litmus test exhibits the ordering effects of these
lock-acquisition and lock-release functions:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> 1 int x, y, z;
 2
 3 void task0(void)
 4 {
 5   raw_spin_lock_rcu_node(rnp);
 6   WRITE_ONCE(x, 1);
 7   r1 = READ_ONCE(y);
 8   raw_spin_unlock_rcu_node(rnp);
 9 }
10
11 void task1(void)
12 {
13   raw_spin_lock_rcu_node(rnp);
14   WRITE_ONCE(y, 1);
15   r2 = READ_ONCE(z);
16   raw_spin_unlock_rcu_node(rnp);
17 }
18
19 void task2(void)
20 {
21   WRITE_ONCE(z, 1);
22   smp_mb();
23   r3 = READ_ONCE(x);
24 }
25
26 WARN_ON(r1 == 0 &amp;&amp; r2 == 0 &amp;&amp; r3 == 0);
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">WARN_ON()</span></code> is evaluated at “the end of time”,
after all changes have propagated throughout the system.
Without the <code class="docutils literal notranslate"><span class="pre">smp_mb__after_unlock_lock()</span></code> provided by the
acquisition functions, this <code class="docutils literal notranslate"><span class="pre">WARN_ON()</span></code> could trigger, for example
on PowerPC.
The <code class="docutils literal notranslate"><span class="pre">smp_mb__after_unlock_lock()</span></code> invocations prevent this
<code class="docutils literal notranslate"><span class="pre">WARN_ON()</span></code> from triggering.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Quick Quiz</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>But the chain of rcu_node-structure lock acquisitions guarantees
that new readers will see all of the updater’s pre-grace-period
accesses and also guarantees that the updater’s post-grace-period
accesses will see all of the old reader’s accesses.  So why do we
need all of those calls to smp_mb__after_unlock_lock()?</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Answer</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>Because we must provide ordering for RCU’s polling grace-period
primitives, for example, <a class="reference internal" href="../../../core-api/kernel-api.html#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">get_state_synchronize_rcu()</span></code></a> and
<a class="reference internal" href="../../../core-api/kernel-api.html#c.poll_state_synchronize_rcu" title="poll_state_synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">poll_state_synchronize_rcu()</span></code></a>.  Consider this code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CPU 0                                     CPU 1
----                                      ----
WRITE_ONCE(X, 1)                          WRITE_ONCE(Y, 1)
g = get_state_synchronize_rcu()           smp_mb()
while (!poll_state_synchronize_rcu(g))    r1 = READ_ONCE(X)
        continue;
r0 = READ_ONCE(Y)
</pre></div>
</div>
<p>RCU guarantees that the outcome r0 == 0 &amp;&amp; r1 == 0 will not
happen, even if CPU 1 is in an RCU extended quiescent state
(idle or offline) and thus won’t interact directly with the RCU
core processing at all.</p>
</td>
</tr>
</tbody>
</table>
<p>This approach must be extended to include idle CPUs, which need
RCU’s grace-period memory ordering guarantee to extend to any
RCU read-side critical sections preceding and following the current
idle sojourn.
This case is handled by calls to the strongly ordered
<code class="docutils literal notranslate"><span class="pre">atomic_add_return()</span></code> read-modify-write atomic operation that
is invoked within <code class="docutils literal notranslate"><span class="pre">rcu_dynticks_eqs_enter()</span></code> at idle-entry
time and within <code class="docutils literal notranslate"><span class="pre">rcu_dynticks_eqs_exit()</span></code> at idle-exit time.
The grace-period kthread invokes <code class="docutils literal notranslate"><span class="pre">rcu_dynticks_snap()</span></code> and
<code class="docutils literal notranslate"><span class="pre">rcu_dynticks_in_eqs_since()</span></code> (both of which invoke
an <code class="docutils literal notranslate"><span class="pre">atomic_add_return()</span></code> of zero) to detect idle CPUs.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Quick Quiz</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>But what about CPUs that remain offline for the entire grace period?</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Answer</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>Such CPUs will be offline at the beginning of the grace period, so
the grace period won’t expect quiescent states from them. Races
between grace-period start and CPU-hotplug operations are mediated
by the CPU’s leaf <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code> as described
above.</p></td>
</tr>
</tbody>
</table>
<p>The approach must be extended to handle one final case, that of waking a
task blocked in <code class="docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code>. This task might be affinitied to
a CPU that is not yet aware that the grace period has ended, and thus
might not yet be subject to the grace period’s memory ordering.
Therefore, there is an <code class="docutils literal notranslate"><span class="pre">smp_mb()</span></code> after the return from
<code class="docutils literal notranslate"><span class="pre">wait_for_completion()</span></code> in the <code class="docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code> code path.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Quick Quiz</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>What? Where??? I don’t see any <code class="docutils literal notranslate"><span class="pre">smp_mb()</span></code> after the return from
<code class="docutils literal notranslate"><span class="pre">wait_for_completion()</span></code>!!!</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Answer</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>That would be because I spotted the need for that <code class="docutils literal notranslate"><span class="pre">smp_mb()</span></code> during
the creation of this documentation, and it is therefore unlikely to
hit mainline before v4.14. Kudos to Lance Roy, Will Deacon, Peter
Zijlstra, and Jonathan Cameron for asking questions that sensitized
me to the rather elaborate sequence of events that demonstrate the
need for this memory barrier.</p></td>
</tr>
</tbody>
</table>
<p>Tree RCU’s grace–period memory-ordering guarantees rely most heavily on
the <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code> field, so much so that it is
necessary to abbreviate this pattern in the diagrams in the next
section. For example, consider the <code class="docutils literal notranslate"><span class="pre">rcu_prepare_for_idle()</span></code> function
shown below, which is one of several functions that enforce ordering of
newly arrived RCU callbacks against future grace periods:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> 1 static void rcu_prepare_for_idle(void)
 2 {
 3   bool needwake;
 4   struct rcu_data *rdp = this_cpu_ptr(&amp;rcu_data);
 5   struct rcu_node *rnp;
 6   int tne;
 7
 8   lockdep_assert_irqs_disabled();
 9   if (rcu_rdp_is_offloaded(rdp))
10     return;
11
12   /* Handle nohz enablement switches conservatively. */
13   tne = READ_ONCE(tick_nohz_active);
14   if (tne != rdp-&gt;tick_nohz_enabled_snap) {
15     if (!rcu_segcblist_empty(&amp;rdp-&gt;cblist))
16       invoke_rcu_core(); /* force nohz to see update. */
17     rdp-&gt;tick_nohz_enabled_snap = tne;
18     return;
19   }
20   if (!tne)
21     return;
22
23   /*
24    * If we have not yet accelerated this jiffy, accelerate all
25    * callbacks on this CPU.
26   */
27   if (rdp-&gt;last_accelerate == jiffies)
28     return;
29   rdp-&gt;last_accelerate = jiffies;
30   if (rcu_segcblist_pend_cbs(&amp;rdp-&gt;cblist)) {
31     rnp = rdp-&gt;mynode;
32     raw_spin_lock_rcu_node(rnp); /* irqs already disabled. */
33     needwake = rcu_accelerate_cbs(rnp, rdp);
34     raw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */
35     if (needwake)
36       rcu_gp_kthread_wake();
37   }
38 }
</pre></div>
</div>
<p>But the only part of <code class="docutils literal notranslate"><span class="pre">rcu_prepare_for_idle()</span></code> that really matters for
this discussion are lines 32–34. We will therefore abbreviate this
function as follows:</p>
<figure class="align-default">
<img alt="../../../_images/rcu_node-lock.svg" src="../../../_images/rcu_node-lock.svg" /></figure>
<p>The box represents the <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code> critical
section, with the double line on top representing the additional
<code class="docutils literal notranslate"><span class="pre">smp_mb__after_unlock_lock()</span></code>.</p>
<section id="tree-rcu-grace-period-memory-ordering-components">
<h3>Tree RCU Grace Period Memory Ordering Components<a class="headerlink" href="#tree-rcu-grace-period-memory-ordering-components" title="Permalink to this headline">¶</a></h3>
<p>Tree RCU’s grace-period memory-ordering guarantee is provided by a
number of RCU components:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#callback-registry">Callback Registry</a></p></li>
<li><p><a class="reference internal" href="#grace-period-initialization">Grace-Period Initialization</a></p></li>
<li><p><a class="reference internal" href="#self-reported-quiescent-states">Self-Reported Quiescent States</a></p></li>
<li><p><a class="reference internal" href="#dynamic-tick-interface">Dynamic Tick Interface</a></p></li>
<li><p><a class="reference internal" href="#cpu-hotplug-interface">CPU-Hotplug Interface</a></p></li>
<li><p><a class="reference internal" href="#forcing-quiescent-states">Forcing Quiescent States</a></p></li>
<li><p><a class="reference internal" href="#grace-period-cleanup">Grace-Period Cleanup</a></p></li>
<li><p><a class="reference internal" href="#callback-invocation">Callback Invocation</a></p></li>
</ol>
<p>Each of the following section looks at the corresponding component in
detail.</p>
<section id="callback-registry">
<h4>Callback Registry<a class="headerlink" href="#callback-registry" title="Permalink to this headline">¶</a></h4>
<p>If RCU’s grace-period guarantee is to mean anything at all, any access
that happens before a given invocation of <code class="docutils literal notranslate"><span class="pre">call_rcu()</span></code> must also
happen before the corresponding grace period. The implementation of this
portion of RCU’s grace period guarantee is shown in the following
figure:</p>
<figure class="align-default">
<img alt="../../../_images/TreeRCU-callback-registry.svg" src="../../../_images/TreeRCU-callback-registry.svg" /></figure>
<p>Because <code class="docutils literal notranslate"><span class="pre">call_rcu()</span></code> normally acts only on CPU-local state, it
provides no ordering guarantees, either for itself or for phase one of
the update (which again will usually be removal of an element from an
RCU-protected data structure). It simply enqueues the <code class="docutils literal notranslate"><span class="pre">rcu_head</span></code>
structure on a per-CPU list, which cannot become associated with a grace
period until a later call to <code class="docutils literal notranslate"><span class="pre">rcu_accelerate_cbs()</span></code>, as shown in the
diagram above.</p>
<p>One set of code paths shown on the left invokes <code class="docutils literal notranslate"><span class="pre">rcu_accelerate_cbs()</span></code>
via <code class="docutils literal notranslate"><span class="pre">note_gp_changes()</span></code>, either directly from <code class="docutils literal notranslate"><span class="pre">call_rcu()</span></code> (if the
current CPU is inundated with queued <code class="docutils literal notranslate"><span class="pre">rcu_head</span></code> structures) or more
likely from an <code class="docutils literal notranslate"><span class="pre">RCU_SOFTIRQ</span></code> handler. Another code path in the middle
is taken only in kernels built with <code class="docutils literal notranslate"><span class="pre">CONFIG_RCU_FAST_NO_HZ=y</span></code>, which
invokes <code class="docutils literal notranslate"><span class="pre">rcu_accelerate_cbs()</span></code> via <code class="docutils literal notranslate"><span class="pre">rcu_prepare_for_idle()</span></code>. The
final code path on the right is taken only in kernels built with
<code class="docutils literal notranslate"><span class="pre">CONFIG_HOTPLUG_CPU=y</span></code>, which invokes <code class="docutils literal notranslate"><span class="pre">rcu_accelerate_cbs()</span></code> via
<code class="docutils literal notranslate"><span class="pre">rcu_advance_cbs()</span></code>, <code class="docutils literal notranslate"><span class="pre">rcu_migrate_callbacks</span></code>,
<code class="docutils literal notranslate"><span class="pre">rcutree_migrate_callbacks()</span></code>, and <code class="docutils literal notranslate"><span class="pre">takedown_cpu()</span></code>, which in turn
is invoked on a surviving CPU after the outgoing CPU has been completely
offlined.</p>
<p>There are a few other code paths within grace-period processing that
opportunistically invoke <code class="docutils literal notranslate"><span class="pre">rcu_accelerate_cbs()</span></code>. However, either way,
all of the CPU’s recently queued <code class="docutils literal notranslate"><span class="pre">rcu_head</span></code> structures are associated
with a future grace-period number under the protection of the CPU’s lead
<code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code>. In all cases, there is full
ordering against any prior critical section for that same <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code>
structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code>, and also full ordering against any of the
current task’s or CPU’s prior critical sections for any <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code>
structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code>.</p>
<p>The next section will show how this ordering ensures that any accesses
prior to the <code class="docutils literal notranslate"><span class="pre">call_rcu()</span></code> (particularly including phase one of the
update) happen before the start of the corresponding grace period.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Quick Quiz</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>But what about <code class="docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code>?</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Answer</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>The <code class="docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code> passes <code class="docutils literal notranslate"><span class="pre">call_rcu()</span></code> to <code class="docutils literal notranslate"><span class="pre">wait_rcu_gp()</span></code>,
which invokes it. So either way, it eventually comes down to
<code class="docutils literal notranslate"><span class="pre">call_rcu()</span></code>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="grace-period-initialization">
<h4>Grace-Period Initialization<a class="headerlink" href="#grace-period-initialization" title="Permalink to this headline">¶</a></h4>
<p>Grace-period initialization is carried out by the grace-period kernel
thread, which makes several passes over the <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> tree within the
<code class="docutils literal notranslate"><span class="pre">rcu_gp_init()</span></code> function. This means that showing the full flow of
ordering through the grace-period computation will require duplicating
this tree. If you find this confusing, please note that the state of the
<code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> changes over time, just like Heraclitus’s river. However,
to keep the <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> river tractable, the grace-period kernel
thread’s traversals are presented in multiple parts, starting in this
section with the various phases of grace-period initialization.</p>
<p>The first ordering-related grace-period initialization action is to
advance the <code class="docutils literal notranslate"><span class="pre">rcu_state</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;gp_seq</span></code> grace-period-number
counter, as shown below:</p>
<figure class="align-default">
<img alt="../../../_images/TreeRCU-gp-init-1.svg" src="../../../_images/TreeRCU-gp-init-1.svg" /></figure>
<p>The actual increment is carried out using <code class="docutils literal notranslate"><span class="pre">smp_store_release()</span></code>, which
helps reject false-positive RCU CPU stall detection. Note that only the
root <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure is touched.</p>
<p>The first pass through the <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> tree updates bitmasks based on
CPUs having come online or gone offline since the start of the previous
grace period. In the common case where the number of online CPUs for
this <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure has not transitioned to or from zero, this
pass will scan only the leaf <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structures. However, if the
number of online CPUs for a given leaf <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure has
transitioned from zero, <code class="docutils literal notranslate"><span class="pre">rcu_init_new_rnp()</span></code> will be invoked for the
first incoming CPU. Similarly, if the number of online CPUs for a given
leaf <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure has transitioned to zero,
<code class="docutils literal notranslate"><span class="pre">rcu_cleanup_dead_rnp()</span></code> will be invoked for the last outgoing CPU.
The diagram below shows the path of ordering if the leftmost
<code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure onlines its first CPU and if the next
<code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure has no online CPUs (or, alternatively if the
leftmost <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure offlines its last CPU and if the next
<code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure has no online CPUs).</p>
<figure class="align-default">
<img alt="../../../_images/TreeRCU-gp-init-2.svg" src="../../../_images/TreeRCU-gp-init-2.svg" /></figure>
<p>The final <code class="docutils literal notranslate"><span class="pre">rcu_gp_init()</span></code> pass through the <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> tree traverses
breadth-first, setting each <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;gp_seq</span></code> field
to the newly advanced value from the <code class="docutils literal notranslate"><span class="pre">rcu_state</span></code> structure, as shown
in the following diagram.</p>
<figure class="align-default">
<img alt="../../../_images/TreeRCU-gp-init-3.svg" src="../../../_images/TreeRCU-gp-init-3.svg" /></figure>
<p>This change will also cause each CPU’s next call to
<code class="docutils literal notranslate"><span class="pre">__note_gp_changes()</span></code> to notice that a new grace period has started,
as described in the next section. But because the grace-period kthread
started the grace period at the root (with the advancing of the
<code class="docutils literal notranslate"><span class="pre">rcu_state</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;gp_seq</span></code> field) before setting each leaf
<code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;gp_seq</span></code> field, each CPU’s observation of
the start of the grace period will happen after the actual start of the
grace period.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Quick Quiz</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>But what about the CPU that started the grace period? Why wouldn’t it
see the start of the grace period right when it started that grace
period?</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Answer</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>In some deep philosophical and overly anthromorphized sense, yes, the
CPU starting the grace period is immediately aware of having done so.
However, if we instead assume that RCU is not self-aware, then even
the CPU starting the grace period does not really become aware of the
start of this grace period until its first call to
<code class="docutils literal notranslate"><span class="pre">__note_gp_changes()</span></code>. On the other hand, this CPU potentially gets
early notification because it invokes <code class="docutils literal notranslate"><span class="pre">__note_gp_changes()</span></code> during
its last <code class="docutils literal notranslate"><span class="pre">rcu_gp_init()</span></code> pass through its leaf <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code>
structure.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="self-reported-quiescent-states">
<h4>Self-Reported Quiescent States<a class="headerlink" href="#self-reported-quiescent-states" title="Permalink to this headline">¶</a></h4>
<p>When all entities that might block the grace period have reported
quiescent states (or as described in a later section, had quiescent
states reported on their behalf), the grace period can end. Online
non-idle CPUs report their own quiescent states, as shown in the
following diagram:</p>
<figure class="align-default">
<img alt="../../../_images/TreeRCU-qs.svg" src="../../../_images/TreeRCU-qs.svg" /></figure>
<p>This is for the last CPU to report a quiescent state, which signals the
end of the grace period. Earlier quiescent states would push up the
<code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> tree only until they encountered an <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure
that is waiting for additional quiescent states. However, ordering is
nevertheless preserved because some later quiescent state will acquire
that <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code>.</p>
<p>Any number of events can lead up to a CPU invoking <code class="docutils literal notranslate"><span class="pre">note_gp_changes</span></code>
(or alternatively, directly invoking <code class="docutils literal notranslate"><span class="pre">__note_gp_changes()</span></code>), at which
point that CPU will notice the start of a new grace period while holding
its leaf <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> lock. Therefore, all execution shown in this
diagram happens after the start of the grace period. In addition, this
CPU will consider any RCU read-side critical section that started before
the invocation of <code class="docutils literal notranslate"><span class="pre">__note_gp_changes()</span></code> to have started before the
grace period, and thus a critical section that the grace period must
wait on.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Quick Quiz</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>But a RCU read-side critical section might have started after the
beginning of the grace period (the advancing of <code class="docutils literal notranslate"><span class="pre">-&gt;gp_seq</span></code> from
earlier), so why should the grace period wait on such a critical
section?</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Answer</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>It is indeed not necessary for the grace period to wait on such a
critical section. However, it is permissible to wait on it. And it is
furthermore important to wait on it, as this lazy approach is far
more scalable than a “big bang” all-at-once grace-period start could
possibly be.</p></td>
</tr>
</tbody>
</table>
<p>If the CPU does a context switch, a quiescent state will be noted by
<code class="docutils literal notranslate"><span class="pre">rcu_note_context_switch()</span></code> on the left. On the other hand, if the CPU
takes a scheduler-clock interrupt while executing in usermode, a
quiescent state will be noted by <code class="docutils literal notranslate"><span class="pre">rcu_sched_clock_irq()</span></code> on the right.
Either way, the passage through a quiescent state will be noted in a
per-CPU variable.</p>
<p>The next time an <code class="docutils literal notranslate"><span class="pre">RCU_SOFTIRQ</span></code> handler executes on this CPU (for
example, after the next scheduler-clock interrupt), <code class="docutils literal notranslate"><span class="pre">rcu_core()</span></code> will
invoke <code class="docutils literal notranslate"><span class="pre">rcu_check_quiescent_state()</span></code>, which will notice the recorded
quiescent state, and invoke <code class="docutils literal notranslate"><span class="pre">rcu_report_qs_rdp()</span></code>. If
<code class="docutils literal notranslate"><span class="pre">rcu_report_qs_rdp()</span></code> verifies that the quiescent state really does
apply to the current grace period, it invokes <code class="docutils literal notranslate"><span class="pre">rcu_report_rnp()</span></code> which
traverses up the <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> tree as shown at the bottom of the
diagram, clearing bits from each <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;qsmask</span></code>
field, and propagating up the tree when the result is zero.</p>
<p>Note that traversal passes upwards out of a given <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure
only if the current CPU is reporting the last quiescent state for the
subtree headed by that <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure. A key point is that if a
CPU’s traversal stops at a given <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure, then there will
be a later traversal by another CPU (or perhaps the same one) that
proceeds upwards from that point, and the <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> <code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code>
guarantees that the first CPU’s quiescent state happens before the
remainder of the second CPU’s traversal. Applying this line of thought
repeatedly shows that all CPUs’ quiescent states happen before the last
CPU traverses through the root <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure, the “last CPU”
being the one that clears the last bit in the root <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code>
structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;qsmask</span></code> field.</p>
</section>
<section id="dynamic-tick-interface">
<h4>Dynamic Tick Interface<a class="headerlink" href="#dynamic-tick-interface" title="Permalink to this headline">¶</a></h4>
<p>Due to energy-efficiency considerations, RCU is forbidden from
disturbing idle CPUs. CPUs are therefore required to notify RCU when
entering or leaving idle state, which they do via fully ordered
value-returning atomic operations on a per-CPU variable. The ordering
effects are as shown below:</p>
<figure class="align-default">
<img alt="../../../_images/TreeRCU-dyntick.svg" src="../../../_images/TreeRCU-dyntick.svg" /></figure>
<p>The RCU grace-period kernel thread samples the per-CPU idleness variable
while holding the corresponding CPU’s leaf <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s
<code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code>. This means that any RCU read-side critical sections that
precede the idle period (the oval near the top of the diagram above)
will happen before the end of the current grace period. Similarly, the
beginning of the current grace period will happen before any RCU
read-side critical sections that follow the idle period (the oval near
the bottom of the diagram above).</p>
<p>Plumbing this into the full grace-period execution is described
<a class="reference internal" href="#forcing-quiescent-states">below</a>.</p>
</section>
<section id="cpu-hotplug-interface">
<h4>CPU-Hotplug Interface<a class="headerlink" href="#cpu-hotplug-interface" title="Permalink to this headline">¶</a></h4>
<p>RCU is also forbidden from disturbing offline CPUs, which might well be
powered off and removed from the system completely. CPUs are therefore
required to notify RCU of their comings and goings as part of the
corresponding CPU hotplug operations. The ordering effects are shown
below:</p>
<figure class="align-default">
<img alt="../../../_images/TreeRCU-hotplug.svg" src="../../../_images/TreeRCU-hotplug.svg" /></figure>
<p>Because CPU hotplug operations are much less frequent than idle
transitions, they are heavier weight, and thus acquire the CPU’s leaf
<code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code> and update this structure’s
<code class="docutils literal notranslate"><span class="pre">-&gt;qsmaskinitnext</span></code>. The RCU grace-period kernel thread samples this
mask to detect CPUs having gone offline since the beginning of this
grace period.</p>
<p>Plumbing this into the full grace-period execution is described
<a class="reference internal" href="#forcing-quiescent-states">below</a>.</p>
</section>
<section id="forcing-quiescent-states">
<h4>Forcing Quiescent States<a class="headerlink" href="#forcing-quiescent-states" title="Permalink to this headline">¶</a></h4>
<p>As noted above, idle and offline CPUs cannot report their own quiescent
states, and therefore the grace-period kernel thread must do the
reporting on their behalf. This process is called “forcing quiescent
states”, it is repeated every few jiffies, and its ordering effects are
shown below:</p>
<figure class="align-default">
<img alt="../../../_images/TreeRCU-gp-fqs.svg" src="../../../_images/TreeRCU-gp-fqs.svg" /></figure>
<p>Each pass of quiescent state forcing is guaranteed to traverse the leaf
<code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structures, and if there are no new quiescent states due to
recently idled and/or offlined CPUs, then only the leaves are traversed.
However, if there is a newly offlined CPU as illustrated on the left or
a newly idled CPU as illustrated on the right, the corresponding
quiescent state will be driven up towards the root. As with
self-reported quiescent states, the upwards driving stops once it
reaches an <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure that has quiescent states outstanding
from other CPUs.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Quick Quiz</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>The leftmost drive to root stopped before it reached the root
<code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure, which means that there are still CPUs
subordinate to that structure on which the current grace period is
waiting. Given that, how is it possible that the rightmost drive to
root ended the grace period?</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Answer</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>Good analysis! It is in fact impossible in the absence of bugs in
RCU. But this diagram is complex enough as it is, so simplicity
overrode accuracy. You can think of it as poetic license, or you can
think of it as misdirection that is resolved in the
<a class="reference internal" href="#putting-it-all-together">stitched-together diagram</a>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="grace-period-cleanup">
<h4>Grace-Period Cleanup<a class="headerlink" href="#grace-period-cleanup" title="Permalink to this headline">¶</a></h4>
<p>Grace-period cleanup first scans the <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> tree breadth-first
advancing all the <code class="docutils literal notranslate"><span class="pre">-&gt;gp_seq</span></code> fields, then it advances the
<code class="docutils literal notranslate"><span class="pre">rcu_state</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;gp_seq</span></code> field. The ordering effects are
shown below:</p>
<figure class="align-default">
<img alt="../../../_images/TreeRCU-gp-cleanup.svg" src="../../../_images/TreeRCU-gp-cleanup.svg" /></figure>
<p>As indicated by the oval at the bottom of the diagram, once grace-period
cleanup is complete, the next grace period can begin.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Quick Quiz</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>But when precisely does the grace period end?</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Answer</strong>:</p></td>
</tr>
<tr class="row-even"><td><p>There is no useful single point at which the grace period can be said
to end. The earliest reasonable candidate is as soon as the last CPU
has reported its quiescent state, but it may be some milliseconds
before RCU becomes aware of this. The latest reasonable candidate is
once the <code class="docutils literal notranslate"><span class="pre">rcu_state</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;gp_seq</span></code> field has been
updated, but it is quite possible that some CPUs have already
completed phase two of their updates by that time. In short, if you
are going to work with RCU, you need to learn to embrace uncertainty.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="callback-invocation">
<h4>Callback Invocation<a class="headerlink" href="#callback-invocation" title="Permalink to this headline">¶</a></h4>
<p>Once a given CPU’s leaf <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;gp_seq</span></code> field has
been updated, that CPU can begin invoking its RCU callbacks that were
waiting for this grace period to end. These callbacks are identified by
<code class="docutils literal notranslate"><span class="pre">rcu_advance_cbs()</span></code>, which is usually invoked by
<code class="docutils literal notranslate"><span class="pre">__note_gp_changes()</span></code>. As shown in the diagram below, this invocation
can be triggered by the scheduling-clock interrupt
(<code class="docutils literal notranslate"><span class="pre">rcu_sched_clock_irq()</span></code> on the left) or by idle entry
(<code class="docutils literal notranslate"><span class="pre">rcu_cleanup_after_idle()</span></code> on the right, but only for kernels build
with <code class="docutils literal notranslate"><span class="pre">CONFIG_RCU_FAST_NO_HZ=y</span></code>). Either way, <code class="docutils literal notranslate"><span class="pre">RCU_SOFTIRQ</span></code> is
raised, which results in <code class="docutils literal notranslate"><span class="pre">rcu_do_batch()</span></code> invoking the callbacks,
which in turn allows those callbacks to carry out (either directly or
indirectly via wakeup) the needed phase-two processing for each update.</p>
<figure class="align-default">
<img alt="../../../_images/TreeRCU-callback-invocation.svg" src="../../../_images/TreeRCU-callback-invocation.svg" /></figure>
<p>Please note that callback invocation can also be prompted by any number
of corner-case code paths, for example, when a CPU notes that it has
excessive numbers of callbacks queued. In all cases, the CPU acquires
its leaf <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure’s <code class="docutils literal notranslate"><span class="pre">-&gt;lock</span></code> before invoking callbacks,
which preserves the required ordering against the newly completed grace
period.</p>
<p>However, if the callback function communicates to other CPUs, for
example, doing a wakeup, then it is that function’s responsibility to
maintain ordering. For example, if the callback function wakes up a task
that runs on some other CPU, proper ordering must in place in both the
callback function and the task being awakened. To see why this is
important, consider the top half of the <a class="reference internal" href="#grace-period-cleanup">grace-period
cleanup</a> diagram. The callback might be
running on a CPU corresponding to the leftmost leaf <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code>
structure, and awaken a task that is to run on a CPU corresponding to
the rightmost leaf <code class="docutils literal notranslate"><span class="pre">rcu_node</span></code> structure, and the grace-period kernel
thread might not yet have reached the rightmost leaf. In this case, the
grace period’s memory ordering might not yet have reached that CPU, so
again the callback function and the awakened task must supply proper
ordering.</p>
</section>
</section>
<section id="putting-it-all-together">
<h3>Putting It All Together<a class="headerlink" href="#putting-it-all-together" title="Permalink to this headline">¶</a></h3>
<p>A stitched-together diagram is here:</p>
<figure class="align-default">
<img alt="../../../_images/TreeRCU-gp.svg" src="../../../_images/TreeRCU-gp.svg" /></figure>
</section>
<section id="legal-statement">
<h3>Legal Statement<a class="headerlink" href="#legal-statement" title="Permalink to this headline">¶</a></h3>
<p>This work represents the view of the author and does not necessarily
represent the view of IBM.</p>
<p>Linux is a registered trademark of Linus Torvalds.</p>
<p>Other company, product, and service names may be trademarks or service
marks of others.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">A Tour Through TREE_RCU’s Grace-Period Memory Ordering</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#what-is-tree-rcu-s-grace-period-memory-ordering-guarantee">What Is Tree RCU’s Grace Period Memory Ordering Guarantee?</a></li>
<li><a class="reference internal" href="#tree-rcu-grace-period-memory-ordering-building-blocks">Tree RCU Grace Period Memory Ordering Building Blocks</a><ul>
<li><a class="reference internal" href="#tree-rcu-grace-period-memory-ordering-components">Tree RCU Grace Period Memory Ordering Components</a><ul>
<li><a class="reference internal" href="#callback-registry">Callback Registry</a></li>
<li><a class="reference internal" href="#grace-period-initialization">Grace-Period Initialization</a></li>
<li><a class="reference internal" href="#self-reported-quiescent-states">Self-Reported Quiescent States</a></li>
<li><a class="reference internal" href="#dynamic-tick-interface">Dynamic Tick Interface</a></li>
<li><a class="reference internal" href="#cpu-hotplug-interface">CPU-Hotplug Interface</a></li>
<li><a class="reference internal" href="#forcing-quiescent-states">Forcing Quiescent States</a></li>
<li><a class="reference internal" href="#grace-period-cleanup">Grace-Period Cleanup</a></li>
<li><a class="reference internal" href="#callback-invocation">Callback Invocation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#putting-it-all-together">Putting It All Together</a></li>
<li><a class="reference internal" href="#legal-statement">Legal Statement</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/RCU/Design/Memory-Ordering/Tree-RCU-Memory-Ordering.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/RCU/Design/Memory-Ordering/Tree-RCU-Memory-Ordering.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>