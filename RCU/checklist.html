
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Review Checklist for RCU Patches &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="RCU and lockdep checking" href="lockdep.html" />
    <link rel="prev" title="RCU concepts" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="review-checklist-for-rcu-patches">
<h1>Review Checklist for RCU Patches<a class="headerlink" href="#review-checklist-for-rcu-patches" title="Permalink to this headline">¶</a></h1>
<p>This document contains a checklist for producing and reviewing patches
that make use of RCU.  Violating any of the rules listed below will
result in the same sorts of problems that leaving out a locking primitive
would cause.  This list is based on experiences reviewing such patches
over a rather long period of time, but improvements are always welcome!</p>
<ol class="arabic" start="0">
<li><p>Is RCU being applied to a read-mostly situation?  If the data
structure is updated more than about 10% of the time, then you
should strongly consider some other approach, unless detailed
performance measurements show that RCU is nonetheless the right
tool for the job.  Yes, RCU does reduce read-side overhead by
increasing write-side overhead, which is exactly why normal uses
of RCU will do much more reading than updating.</p>
<p>Another exception is where performance is not an issue, and RCU
provides a simpler implementation.  An example of this situation
is the dynamic NMI code in the Linux 2.6 kernel, at least on
architectures where NMIs are rare.</p>
<p>Yet another exception is where the low real-time latency of RCU’s
read-side primitives is critically important.</p>
<p>One final exception is where RCU readers are used to prevent
the ABA problem (<a class="reference external" href="https://en.wikipedia.org/wiki/ABA_problem">https://en.wikipedia.org/wiki/ABA_problem</a>)
for lockless updates.  This does result in the mildly
counter-intuitive situation where <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> are used to protect updates, however, this
approach can provide the same simplifications to certain types
of lockless algorithms that garbage collectors do.</p>
</li>
<li><p>Does the update code have proper mutual exclusion?</p>
<p>RCU does allow <em>readers</em> to run (almost) naked, but <em>writers</em> must
still use some sort of mutual exclusion, such as:</p>
<ol class="loweralpha simple">
<li><p>locking,</p></li>
<li><p>atomic operations, or</p></li>
<li><p>restricting updates to a single task.</p></li>
</ol>
<p>If you choose #b, be prepared to describe how you have handled
memory barriers on weakly ordered machines (pretty much all of
them – even x86 allows later loads to be reordered to precede
earlier stores), and be prepared to explain why this added
complexity is worthwhile.  If you choose #c, be prepared to
explain how this single task does not become a major bottleneck
on large systems (for example, if the task is updating information
relating to itself that other tasks can read, there by definition
can be no bottleneck).  Note that the definition of “large” has
changed significantly:  Eight CPUs was “large” in the year 2000,
but a hundred CPUs was unremarkable in 2017.</p>
</li>
<li><p>Do the RCU read-side critical sections make proper use of
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and friends?  These primitives are needed
to prevent grace periods from ending prematurely, which
could result in data being unceremoniously freed out from
under your read-side code, which can greatly increase the
actuarial risk of your kernel.</p>
<p>As a rough rule of thumb, any dereference of an RCU-protected
pointer must be covered by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a>, <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a>,
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_sched()</span></code></a>, or by the appropriate update-side lock.
Explicit disabling of preemption (preempt_disable(), for example)
can serve as <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_sched()</span></code></a>, but is less readable and
prevents lockdep from detecting locking issues.</p>
<p>Please not that you <em>cannot</em> rely on code known to be built
only in non-preemptible kernels.  Such code can and will break,
especially in kernels built with CONFIG_PREEMPT_COUNT=y.</p>
<p>Letting RCU-protected pointers “leak” out of an RCU read-side
critical section is every bit as bad as letting them leak out
from under a lock.  Unless, of course, you have arranged some
other means of protection, such as a lock or a reference count
<em>before</em> letting them out of the RCU read-side critical section.</p>
</li>
<li><p>Does the update code tolerate concurrent accesses?</p>
<p>The whole point of RCU is to permit readers to run without
any locks or atomic operations.  This means that readers will
be running while updates are in progress.  There are a number
of ways to handle this concurrency, depending on the situation:</p>
<ol class="loweralpha">
<li><p>Use the RCU variants of the list and hlist update
primitives to add, remove, and replace elements on
an RCU-protected list.  Alternatively, use the other
RCU-protected data structures that have been added to
the Linux kernel.</p>
<p>This is almost always the best approach.</p>
</li>
<li><p>Proceed as in (a) above, but also maintain per-element
locks (that are acquired by both readers and writers)
that guard per-element state.  Fields that the readers
refrain from accessing can be guarded by some other lock
acquired only by updaters, if desired.</p>
<p>This also works quite well.</p>
</li>
<li><p>Make updates appear atomic to readers.  For example,
pointer updates to properly aligned fields will
appear atomic, as will individual atomic primitives.
Sequences of operations performed under a lock will <em>not</em>
appear to be atomic to RCU readers, nor will sequences
of multiple atomic primitives.  One alternative is to
move multiple individual fields to a separate structure,
thus solving the multiple-field problem by imposing an
additional level of indirection.</p>
<p>This can work, but is starting to get a bit tricky.</p>
</li>
<li><p>Carefully order the updates and the reads so that readers
see valid data at all phases of the update.  This is often
more difficult than it sounds, especially given modern
CPUs’ tendency to reorder memory references.  One must
usually liberally sprinkle memory-ordering operations
through the code, making it difficult to understand and
to test.  Where it works, it is better to use things
like smp_store_release() and smp_load_acquire(), but in
some cases the smp_mb() full memory barrier is required.</p>
<p>As noted earlier, it is usually better to group the
changing data into a separate structure, so that the
change may be made to appear atomic by updating a pointer
to reference a new structure containing updated values.</p>
</li>
</ol>
</li>
<li><p>Weakly ordered CPUs pose special challenges.  Almost all CPUs
are weakly ordered – even x86 CPUs allow later loads to be
reordered to precede earlier stores.  RCU code must take all of
the following measures to prevent memory-corruption problems:</p>
<ol class="loweralpha">
<li><p>Readers must maintain proper ordering of their memory
accesses.  The <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a> primitive ensures that
the CPU picks up the pointer before it picks up the data
that the pointer points to.  This really is necessary
on Alpha CPUs.</p>
<p>The <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a> primitive is also an excellent
documentation aid, letting the person reading the
code know exactly which pointers are protected by RCU.
Please note that compilers can also reorder code, and
they are becoming increasingly aggressive about doing
just that.  The <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a> primitive therefore also
prevents destructive compiler optimizations.  However,
with a bit of devious creativity, it is possible to
mishandle the return value from <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a>.
Please see <a class="reference internal" href="rcu_dereference.html"><span class="doc">PROPER CARE AND FEEDING OF RETURN VALUES FROM rcu_dereference()</span></a> for more information.</p>
<p>The <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a> primitive is used by the
various “_rcu()” list-traversal primitives, such
as the <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_rcu()</span></code></a>.  Note that it is
perfectly legal (if redundant) for update-side code to
use <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a> and the “_rcu()” list-traversal
primitives.  This is particularly useful in code that
is common to readers and updaters.  However, lockdep
will complain if you access <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a> outside
of an RCU read-side critical section.  See <a class="reference internal" href="lockdep.html"><span class="doc">RCU and lockdep checking</span></a>
to learn what to do about this.</p>
<p>Of course, neither <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a> nor the “_rcu()”
list-traversal primitives can substitute for a good
concurrency design coordinating among multiple updaters.</p>
</li>
<li><p>If the list macros are being used, the <a class="reference internal" href="../core-api/kernel-api.html#c.list_add_tail_rcu" title="list_add_tail_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_tail_rcu()</span></code></a>
and <a class="reference internal" href="../core-api/kernel-api.html#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_rcu()</span></code></a> primitives must be used in order
to prevent weakly ordered machines from misordering
structure initialization and pointer planting.
Similarly, if the hlist macros are being used, the
<a class="reference internal" href="../core-api/kernel-api.html#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_add_head_rcu()</span></code></a> primitive is required.</p></li>
<li><p>If the list macros are being used, the <a class="reference internal" href="../core-api/kernel-api.html#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_rcu()</span></code></a>
primitive must be used to keep <a class="reference internal" href="../core-api/kernel-api.html#c.list_del" title="list_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del()</span></code></a>’s pointer
poisoning from inflicting toxic effects on concurrent
readers.  Similarly, if the hlist macros are being used,
the <a class="reference internal" href="../core-api/kernel-api.html#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_rcu()</span></code></a> primitive is required.</p>
<p>The <a class="reference internal" href="../core-api/kernel-api.html#c.list_replace_rcu" title="list_replace_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_replace_rcu()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.hlist_replace_rcu" title="hlist_replace_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_replace_rcu()</span></code></a> primitives
may be used to replace an old structure with a new one
in their respective types of RCU-protected lists.</p>
</li>
<li><p>Rules similar to (4b) and (4c) apply to the “hlist_nulls”
type of RCU-protected linked lists.</p></li>
<li><p>Updates must ensure that initialization of a given
structure happens before pointers to that structure are
publicized.  Use the <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> primitive
when publicizing a pointer to a structure that can
be traversed by an RCU read-side critical section.</p></li>
</ol>
</li>
<li><p>If any of <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a>, call_rcu_tasks(),
call_rcu_tasks_rude(), or call_rcu_tasks_trace() is used,
the callback function may be invoked from softirq context,
and in any case with bottom halves disabled.  In particular,
this callback function cannot block.  If you need the callback
to block, run that code in a workqueue handler scheduled from
the callback.  The <a class="reference internal" href="../core-api/workqueue.html#c.queue_rcu_work" title="queue_rcu_work"><code class="xref c c-func docutils literal notranslate"><span class="pre">queue_rcu_work()</span></code></a> function does this for you
in the case of <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>.</p></li>
<li><p>Since <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> can block, it cannot be called
from any sort of irq context.  The same rule applies
for <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>, <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_expedited()</span></code></a>,
<a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu_expedited()</span></code></a>, synchronize_rcu_tasks(),
synchronize_rcu_tasks_rude(), and synchronize_rcu_tasks_trace().</p>
<p>The expedited forms of these primitives have the same semantics
as the non-expedited forms, but expediting is more CPU intensive.
Use of the expedited primitives should be restricted to rare
configuration-change operations that would not normally be
undertaken while a real-time workload is running.  Note that
IPI-sensitive real-time workloads can use the rcupdate.rcu_normal
kernel boot parameter to completely disable expedited grace
periods, though this might have performance implications.</p>
<p>In particular, if you find yourself invoking one of the expedited
primitives repeatedly in a loop, please do everyone a favor:
Restructure your code so that it batches the updates, allowing
a single non-expedited primitive to cover the entire batch.
This will very likely be faster than the loop containing the
expedited primitive, and will be much much easier on the rest
of the system, especially to real-time workloads running on the
rest of the system.  Alternatively, instead use asynchronous
primitives such as <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>.</p>
</li>
<li><p>As of v4.20, a given kernel implements only one RCU flavor, which
is RCU-sched for PREEMPTION=n and RCU-preempt for PREEMPTION=y.
If the updater uses <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> or <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, then
the corresponding readers may use:  (1) <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>, (2) any pair of primitives that disables
and re-enables softirq, for example, <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a> and
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock_bh" title="rcu_read_unlock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock_bh()</span></code></a>, or (3) any pair of primitives that disables
and re-enables preemption, for example, <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_sched()</span></code></a> and
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock_sched" title="rcu_read_unlock_sched"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock_sched()</span></code></a>.  If the updater uses <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>
or <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a>, then the corresponding readers must use
<a class="reference internal" href="../core-api/kernel-api.html#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a>, and with the same
srcu_struct.  The rules for the expedited RCU grace-period-wait
primitives are the same as for their non-expedited counterparts.</p>
<p>If the updater uses call_rcu_tasks() or synchronize_rcu_tasks(),
then the readers must refrain from executing voluntary
context switches, that is, from blocking.  If the updater uses
call_rcu_tasks_trace() or synchronize_rcu_tasks_trace(), then
the corresponding readers must use rcu_read_lock_trace() and
rcu_read_unlock_trace().  If an updater uses call_rcu_tasks_rude()
or synchronize_rcu_tasks_rude(), then the corresponding readers
must use anything that disables preemption, for example,
preempt_disable() and preempt_enable().</p>
<p>Mixing things up will result in confusion and broken kernels, and
has even resulted in an exploitable security issue.  Therefore,
when using non-obvious pairs of primitives, commenting is
of course a must.  One example of non-obvious pairing is
the XDP feature in networking, which calls BPF programs from
network-driver NAPI (softirq) context.  BPF relies heavily on RCU
protection for its data structures, but because the BPF program
invocation happens entirely within a single local_bh_disable()
section in a NAPI poll cycle, this usage is safe.  The reason
that this usage is safe is that readers can use anything that
disables BH when updaters use <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> or <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>.</p>
</li>
<li><p>Although <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> is slower than is <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>,
it usually results in simpler code.  So, unless update
performance is critically important, the updaters cannot block,
or the latency of <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> is visible from userspace,
<a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> should be used in preference to <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>.
Furthermore, <a class="reference internal" href="../core-api/kernel-api.html#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.kvfree_rcu" title="kvfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kvfree_rcu()</span></code></a> usually result
in even simpler code than does <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> without
<a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>’s multi-millisecond latency.  So please take
advantage of <a class="reference internal" href="../core-api/kernel-api.html#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a>’s and <a class="reference internal" href="../core-api/kernel-api.html#c.kvfree_rcu" title="kvfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kvfree_rcu()</span></code></a>’s “fire and forget”
memory-freeing capabilities where it applies.</p>
<p>An especially important property of the <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>
primitive is that it automatically self-limits: if grace periods
are delayed for whatever reason, then the <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>
primitive will correspondingly delay updates.  In contrast,
code using <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> should explicitly limit update rate in
cases where grace periods are delayed, as failing to do so can
result in excessive realtime latencies or even OOM conditions.</p>
<p>Ways of gaining this self-limiting property when using <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>,
<a class="reference internal" href="../core-api/kernel-api.html#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree_rcu()</span></code></a>, or <a class="reference internal" href="../core-api/kernel-api.html#c.kvfree_rcu" title="kvfree_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">kvfree_rcu()</span></code></a> include:</p>
<ol class="loweralpha">
<li><p>Keeping a count of the number of data-structure elements
used by the RCU-protected data structure, including
those waiting for a grace period to elapse.  Enforce a
limit on this number, stalling updates as needed to allow
previously deferred frees to complete.  Alternatively,
limit only the number awaiting deferred free rather than
the total number of elements.</p>
<p>One way to stall the updates is to acquire the update-side
mutex.  (Don’t try this with a spinlock – other CPUs
spinning on the lock could prevent the grace period
from ever ending.)  Another way to stall the updates
is for the updates to use a wrapper function around
the memory allocator, so that this wrapper function
simulates OOM when there is too much memory awaiting an
RCU grace period.  There are of course many other
variations on this theme.</p>
</li>
<li><p>Limiting update rate.  For example, if updates occur only
once per hour, then no explicit rate limiting is
required, unless your system is already badly broken.
Older versions of the dcache subsystem take this approach,
guarding updates with a global lock, limiting their rate.</p></li>
<li><p>Trusted update – if updates can only be done manually by
superuser or some other trusted user, then it might not
be necessary to automatically limit them.  The theory
here is that superuser already has lots of ways to crash
the machine.</p></li>
<li><p>Periodically invoke <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a>, permitting a limited
number of updates per grace period.</p></li>
</ol>
<p>The same cautions apply to <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a>, call_rcu_tasks(),
call_rcu_tasks_rude(), and call_rcu_tasks_trace().  This is
why there is an <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_barrier" title="srcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_barrier()</span></code></a>, rcu_barrier_tasks(),
rcu_barrier_tasks_rude(), and rcu_barrier_tasks_rude(),
respectively.</p>
<p>Note that although these primitives do take action to avoid
memory exhaustion when any given CPU has too many callbacks,
a determined user or administrator can still exhaust memory.
This is especially the case if a system with a large number of
CPUs has been configured to offload all of its RCU callbacks onto
a single CPU, or if the system has relatively little free memory.</p>
</li>
<li><p>All RCU list-traversal primitives, which include
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a>, <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_rcu()</span></code></a>, and
list_for_each_safe_rcu(), must be either within an RCU read-side
critical section or must be protected by appropriate update-side
locks.  RCU read-side critical sections are delimited by
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>, or by similar primitives
such as <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock_bh()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock_bh" title="rcu_read_unlock_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock_bh()</span></code></a>, in which
case the matching <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a> primitive must be used in
order to keep lockdep happy, in this case, <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference_bh" title="rcu_dereference_bh"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference_bh()</span></code></a>.</p>
<p>The reason that it is permissible to use RCU list-traversal
primitives when the update-side lock is held is that doing so
can be quite helpful in reducing code bloat when common code is
shared between readers and updaters.  Additional primitives
are provided for this case, as discussed in <a class="reference internal" href="lockdep.html"><span class="doc">RCU and lockdep checking</span></a>.</p>
<p>One exception to this rule is when data is only ever added to
the linked data structure, and is never removed during any
time that readers might be accessing that structure.  In such
cases, READ_ONCE() may be used in place of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a>
and the read-side markers (<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>,
for example) may be omitted.</p>
</li>
<li><p>Conversely, if you are in an RCU read-side critical section,
and you don’t hold the appropriate update-side lock, you <em>must</em>
use the “_rcu()” variants of the list macros.  Failing to do so
will break Alpha, cause aggressive compilers to generate bad code,
and confuse people trying to understand your code.</p></li>
<li><p>Any lock acquired by an RCU callback must be acquired elsewhere
with softirq disabled, e.g., via spin_lock_bh().  Failing to
disable softirq on a given acquisition of that lock will result
in deadlock as soon as the RCU softirq handler happens to run
your RCU callback while interrupting that acquisition’s critical
section.</p></li>
<li><p>RCU callbacks can be and are executed in parallel.  In many cases,
the callback code simply wrappers around <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>, so that this
is not an issue (or, more accurately, to the extent that it is
an issue, the memory-allocator locking handles it).  However,
if the callbacks do manipulate a shared data structure, they
must use whatever locking or other synchronization is required
to safely access and/or modify that data structure.</p>
<p>Do not assume that RCU callbacks will be executed on the same
CPU that executed the corresponding <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> or <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a>.
For example, if a given CPU goes offline while having an RCU
callback pending, then that RCU callback will execute on some
surviving CPU.  (If this was not the case, a self-spawning RCU
callback would prevent the victim CPU from ever going offline.)
Furthermore, CPUs designated by rcu_nocbs= might well <em>always</em>
have their RCU callbacks executed on some other CPUs, in fact,
for some  real-time workloads, this is the whole point of using
the rcu_nocbs= kernel boot parameter.</p>
<p>In addition, do not assume that callbacks queued in a given order
will be invoked in that order, even if they all are queued on the
same CPU.  Furthermore, do not assume that same-CPU callbacks will
be invoked serially.  For example, in recent kernels, CPUs can be
switched between offloaded and de-offloaded callback invocation,
and while a given CPU is undergoing such a switch, its callbacks
might be concurrently invoked by that CPU’s softirq handler and
that CPU’s rcuo kthread.  At such times, that CPU’s callbacks
might be executed both concurrently and out of order.</p>
</li>
<li><p>Unlike most flavors of RCU, it <em>is</em> permissible to block in an
SRCU read-side critical section (demarked by <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>
and <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a>), hence the “SRCU”: “sleepable RCU”.
Please note that if you don’t need to sleep in read-side critical
sections, you should be using RCU rather than SRCU, because RCU
is almost always faster and easier to use than is SRCU.</p>
<p>Also unlike other forms of RCU, explicit initialization and
cleanup is required either at build time via DEFINE_SRCU()
or DEFINE_STATIC_SRCU() or at runtime via <a class="reference internal" href="../core-api/kernel-api.html#c.init_srcu_struct" title="init_srcu_struct"><code class="xref c c-func docutils literal notranslate"><span class="pre">init_srcu_struct()</span></code></a>
and <a class="reference internal" href="../core-api/kernel-api.html#c.cleanup_srcu_struct" title="cleanup_srcu_struct"><code class="xref c c-func docutils literal notranslate"><span class="pre">cleanup_srcu_struct()</span></code></a>.  These last two are passed a
“struct srcu_struct” that defines the scope of a given
SRCU domain.  Once initialized, the srcu_struct is passed
to <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a>, <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a> <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a>,
<a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu_expedited()</span></code></a>, and <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a>.  A given
<a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> waits only for SRCU read-side critical
sections governed by <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a>
calls that have been passed the same srcu_struct.  This property
is what makes sleeping read-side critical sections tolerable –
a given subsystem delays only its own updates, not those of other
subsystems using SRCU.  Therefore, SRCU is less prone to OOM the
system than RCU would be if RCU’s read-side critical sections
were permitted to sleep.</p>
<p>The ability to sleep in read-side critical sections does not
come for free.  First, corresponding <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_lock()</span></code></a> and
<a class="reference internal" href="../core-api/kernel-api.html#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a> calls must be passed the same srcu_struct.
Second, grace-period-detection overhead is amortized only
over those updates sharing a given srcu_struct, rather than
being globally amortized as they are for other forms of RCU.
Therefore, SRCU should be used in preference to rw_semaphore
only in extremely read-intensive situations, or in situations
requiring SRCU’s read-side deadlock immunity or low read-side
realtime latency.  You should also consider percpu_rw_semaphore
when you need lightweight readers.</p>
<p>SRCU’s expedited primitive (<a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu_expedited()</span></code></a>)
never sends IPIs to other CPUs, so it is easier on
real-time workloads than is <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_expedited()</span></code></a>.</p>
<p>It is also permissible to sleep in RCU Tasks Trace read-side
critical, which are delimited by rcu_read_lock_trace() and
rcu_read_unlock_trace().  However, this is a specialized flavor
of RCU, and you should not use it without first checking with
its current users.  In most cases, you should instead use SRCU.</p>
<p>Note that <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_assign_pointer()</span></code></a> relates to SRCU just as it does to
other forms of RCU, but instead of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a> you should
use <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_dereference" title="srcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_dereference()</span></code></a> in order to avoid lockdep splats.</p>
</li>
<li><p>The whole point of <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, and friends
is to wait until all pre-existing readers have finished before
carrying out some otherwise-destructive operation.  It is
therefore critically important to <em>first</em> remove any path
that readers can follow that could be affected by the
destructive operation, and <em>only then</em> invoke <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>,
<a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, or friends.</p>
<p>Because these primitives only wait for pre-existing readers, it
is the caller’s responsibility to guarantee that any subsequent
readers will execute safely.</p>
</li>
<li><p>The various RCU read-side primitives do <em>not</em> necessarily contain
memory barriers.  You should therefore plan for the CPU
and the compiler to freely reorder code into and out of RCU
read-side critical sections.  It is the responsibility of the
RCU update-side primitives to deal with this.</p>
<p>For SRCU readers, you can use <a class="reference internal" href="../core-api/kernel-api.html#c.smp_mb__after_srcu_read_unlock" title="smp_mb__after_srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">smp_mb__after_srcu_read_unlock()</span></code></a>
immediately after an <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_read_unlock()</span></code></a> to get a full barrier.</p>
</li>
<li><p>Use CONFIG_PROVE_LOCKING, CONFIG_DEBUG_OBJECTS_RCU_HEAD, and the
__rcu sparse checks to validate your RCU code.  These can help
find problems as follows:</p>
<dl class="simple">
<dt>CONFIG_PROVE_LOCKING:</dt><dd><p>check that accesses to RCU-protected data structures
are carried out under the proper RCU read-side critical
section, while holding the right combination of locks,
or whatever other conditions are appropriate.</p>
</dd>
<dt>CONFIG_DEBUG_OBJECTS_RCU_HEAD:</dt><dd><p>check that you don’t pass the same object to <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>
(or friends) before an RCU grace period has elapsed
since the last time that you passed that same object to
<a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> (or friends).</p>
</dd>
<dt>__rcu sparse checks:</dt><dd><p>tag the pointer to the RCU-protected data structure
with __rcu, and sparse will warn you if you access that
pointer without the services of one of the variants
of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_dereference()</span></code></a>.</p>
</dd>
</dl>
<p>These debugging aids can help you find problems that are
otherwise extremely difficult to spot.</p>
</li>
<li><p>If you pass a callback function defined within a module to one of
<a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a>, call_rcu_tasks(), call_rcu_tasks_rude(),
or call_rcu_tasks_trace(), then it is necessary to wait for all
pending callbacks to be invoked before unloading that module.
Note that it is absolutely <em>not</em> sufficient to wait for a grace
period!  For example, <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> implementation is <em>not</em>
guaranteed to wait for callbacks registered on other CPUs via
<a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>.  Or even on the current CPU if that CPU recently
went offline and came back online.</p>
<p>You instead need to use one of the barrier functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> -&gt; <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a></p></li>
<li><p><a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a> -&gt; <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_barrier" title="srcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_barrier()</span></code></a></p></li>
<li><p>call_rcu_tasks() -&gt; rcu_barrier_tasks()</p></li>
<li><p>call_rcu_tasks_rude() -&gt; rcu_barrier_tasks_rude()</p></li>
<li><p>call_rcu_tasks_trace() -&gt; rcu_barrier_tasks_trace()</p></li>
</ul>
<p>However, these barrier functions are absolutely <em>not</em> guaranteed
to wait for a grace period.  For example, if there are no
<a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> callbacks queued anywhere in the system, <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a>
can and will return immediately.</p>
<p>So if you need to wait for both a grace period and for all
pre-existing callbacks, you will need to invoke both functions,
with the pair depending on the flavor of RCU:</p>
<ul class="simple">
<li><p>Either <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> or <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu_expedited()</span></code></a>,
together with <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a></p></li>
<li><p>Either <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu()</span></code></a> or <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_srcu_expedited()</span></code></a>,
together with and <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_barrier" title="srcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_barrier()</span></code></a></p></li>
<li><p>synchronize_rcu_tasks() and rcu_barrier_tasks()</p></li>
<li><p>synchronize_tasks_rude() and rcu_barrier_tasks_rude()</p></li>
<li><p>synchronize_tasks_trace() and rcu_barrier_tasks_trace()</p></li>
</ul>
<p>If necessary, you can use something like workqueues to execute
the requisite pair of functions concurrently.</p>
<p>See <a class="reference internal" href="rcubarrier.html"><span class="doc">RCU and Unloadable Modules</span></a> for more information.</p>
</li>
</ol>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/RCU/checklist.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/RCU/checklist.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>