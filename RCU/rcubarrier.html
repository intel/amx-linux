
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>RCU and Unloadable Modules &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PROPER CARE AND FEEDING OF RETURN VALUES FROM rcu_dereference()" href="rcu_dereference.html" />
    <link rel="prev" title="Lockdep-RCU Splat" href="lockdep-splat.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="rcu-and-unloadable-modules">
<span id="rcu-barrier"></span><h1>RCU and Unloadable Modules<a class="headerlink" href="#rcu-and-unloadable-modules" title="Permalink to this headline">¶</a></h1>
<p>[Originally published in LWN Jan. 14, 2007: <a class="reference external" href="http://lwn.net/Articles/217484/">http://lwn.net/Articles/217484/</a>]</p>
<p>RCU (read-copy update) is a synchronization mechanism that can be thought
of as a replacement for read-writer locking (among other things), but with
very low-overhead readers that are immune to deadlock, priority inversion,
and unbounded latency. RCU read-side critical sections are delimited
by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a>, which, in non-CONFIG_PREEMPTION
kernels, generate no code whatsoever.</p>
<p>This means that RCU writers are unaware of the presence of concurrent
readers, so that RCU updates to shared data must be undertaken quite
carefully, leaving an old version of the data structure in place until all
pre-existing readers have finished. These old versions are needed because
such readers might hold a reference to them. RCU updates can therefore be
rather expensive, and RCU is thus best suited for read-mostly situations.</p>
<p>How can an RCU writer possibly determine when all readers are finished,
given that readers might well leave absolutely no trace of their
presence? There is a <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> primitive that blocks until all
pre-existing readers have completed. An updater wishing to delete an
element p from a linked list might do the following, while holding an
appropriate lock, of course:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>list_del_rcu(p);
synchronize_rcu();
kfree(p);
</pre></div>
</div>
<p>But the above code cannot be used in IRQ context – the <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>
primitive must be used instead. This primitive takes a pointer to an
rcu_head struct placed within the RCU-protected data structure and
another pointer to a function that may be invoked later to free that
structure. Code to delete an element p from the linked list from IRQ
context might then be as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>list_del_rcu(p);
call_rcu(&amp;p-&gt;rcu, p_callback);
</pre></div>
</div>
<p>Since <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> never blocks, this code can safely be used from within
IRQ context. The function p_callback() might be defined as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static void p_callback(struct rcu_head *rp)
{
        struct pstruct *p = container_of(rp, struct pstruct, rcu);

        kfree(p);
}
</pre></div>
</div>
<section id="unloading-modules-that-use-call-rcu">
<h2>Unloading Modules That Use call_rcu()<a class="headerlink" href="#unloading-modules-that-use-call-rcu" title="Permalink to this headline">¶</a></h2>
<p>But what if p_callback is defined in an unloadable module?</p>
<p>If we unload the module while some RCU callbacks are pending,
the CPUs executing these callbacks are going to be severely
disappointed when they are later invoked, as fancifully depicted at
<a class="reference external" href="http://lwn.net/images/ns/kernel/rcu-drop.jpg">http://lwn.net/images/ns/kernel/rcu-drop.jpg</a>.</p>
<p>We could try placing a <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> in the module-exit code path,
but this is not sufficient. Although <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a> does wait for a
grace period to elapse, it does not wait for the callbacks to complete.</p>
<p>One might be tempted to try several back-to-back <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>
calls, but this is still not guaranteed to work. If there is a very
heavy RCU-callback load, then some of the callbacks might be deferred
in order to allow other processing to proceed. Such deferral is required
in realtime kernels in order to avoid excessive scheduling latencies.</p>
</section>
<section id="id1">
<h2>rcu_barrier()<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>We instead need the <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> primitive.  Rather than waiting for
a grace period to elapse, <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> waits for all outstanding RCU
callbacks to complete.  Please note that <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> does <strong>not</strong> imply
<a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code></a>, in particular, if there are no RCU callbacks queued
anywhere, <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> is within its rights to return immediately,
without waiting for a grace period to elapse.</p>
<p>Pseudo-code using <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> is as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Prevent any new RCU callbacks from being posted.</p></li>
<li><p>Execute <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a>.</p></li>
<li><p>Allow the module to be unloaded.</p></li>
</ol>
</div></blockquote>
<p>There is also an <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_barrier" title="srcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_barrier()</span></code></a> function for SRCU, and you of course
must match the flavor of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> with that of <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>.  If your
module uses multiple flavors of <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, then it must also use multiple
flavors of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> when unloading that module.  For example, if
it uses <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a> on srcu_struct_1, and <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a> on
srcu_struct_2, then the following three lines of code will be required
when unloading:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1 rcu_barrier();
2 srcu_barrier(&amp;srcu_struct_1);
3 srcu_barrier(&amp;srcu_struct_2);
</pre></div>
</div>
<p>The rcutorture module makes use of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> in its exit function
as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1  static void
2  rcu_torture_cleanup(void)
3  {
4    int i;
5
6    fullstop = 1;
7    if (shuffler_task != NULL) {
8     VERBOSE_PRINTK_STRING(&quot;Stopping rcu_torture_shuffle task&quot;);
9     kthread_stop(shuffler_task);
10   }
11   shuffler_task = NULL;
12
13   if (writer_task != NULL) {
14     VERBOSE_PRINTK_STRING(&quot;Stopping rcu_torture_writer task&quot;);
15     kthread_stop(writer_task);
16   }
17   writer_task = NULL;
18
19   if (reader_tasks != NULL) {
20     for (i = 0; i &lt; nrealreaders; i++) {
21       if (reader_tasks[i] != NULL) {
22         VERBOSE_PRINTK_STRING(
23           &quot;Stopping rcu_torture_reader task&quot;);
24         kthread_stop(reader_tasks[i]);
25       }
26       reader_tasks[i] = NULL;
27     }
28     kfree(reader_tasks);
29     reader_tasks = NULL;
30   }
31   rcu_torture_current = NULL;
32
33   if (fakewriter_tasks != NULL) {
34     for (i = 0; i &lt; nfakewriters; i++) {
35       if (fakewriter_tasks[i] != NULL) {
36         VERBOSE_PRINTK_STRING(
37           &quot;Stopping rcu_torture_fakewriter task&quot;);
38         kthread_stop(fakewriter_tasks[i]);
39       }
40       fakewriter_tasks[i] = NULL;
41     }
42     kfree(fakewriter_tasks);
43     fakewriter_tasks = NULL;
44   }
45
46   if (stats_task != NULL) {
47     VERBOSE_PRINTK_STRING(&quot;Stopping rcu_torture_stats task&quot;);
48     kthread_stop(stats_task);
49   }
50   stats_task = NULL;
51
52   /* Wait for all RCU callbacks to fire. */
53   rcu_barrier();
54
55   rcu_torture_stats_print(); /* -After- the stats thread is stopped! */
56
57   if (cur_ops-&gt;cleanup != NULL)
58     cur_ops-&gt;cleanup();
59   if (atomic_read(&amp;n_rcu_torture_error))
60     rcu_torture_print_module_parms(&quot;End of test: FAILURE&quot;);
61   else
62     rcu_torture_print_module_parms(&quot;End of test: SUCCESS&quot;);
63 }
</pre></div>
</div>
<p>Line 6 sets a global variable that prevents any RCU callbacks from
re-posting themselves. This will not be necessary in most cases, since
RCU callbacks rarely include calls to <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>. However, the rcutorture
module is an exception to this rule, and therefore needs to set this
global variable.</p>
<p>Lines 7-50 stop all the kernel tasks associated with the rcutorture
module. Therefore, once execution reaches line 53, no more rcutorture
RCU callbacks will be posted. The <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> call on line 53 waits
for any pre-existing callbacks to complete.</p>
<p>Then lines 55-62 print status and do operation-specific cleanup, and
then return, permitting the module-unload operation to be completed.</p>
<dl class="simple" id="rcubarrier-quiz-1">
<dt>Quick Quiz #1:</dt><dd><p>Is there any other situation where <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> might
be required?</p>
</dd>
</dl>
<p><a class="reference internal" href="#answer-rcubarrier-quiz-1"><span class="std std-ref">Answer to Quick Quiz #1</span></a></p>
<p>Your module might have additional complications. For example, if your
module invokes <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a> from timers, you will need to first cancel all
the timers, and only then invoke <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> to wait for any remaining
RCU callbacks to complete.</p>
<p>Of course, if you module uses <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>, you will need to invoke
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> before unloading.  Similarly, if your module uses
<a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a>, you will need to invoke <a class="reference internal" href="../core-api/kernel-api.html#c.srcu_barrier" title="srcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_barrier()</span></code></a> before unloading,
and on the same srcu_struct structure.  If your module uses <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>
<strong>and</strong> <a class="reference internal" href="../core-api/kernel-api.html#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_srcu()</span></code></a>, then you will need to invoke <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> <strong>and</strong>
<a class="reference internal" href="../core-api/kernel-api.html#c.srcu_barrier" title="srcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">srcu_barrier()</span></code></a>.</p>
</section>
<section id="implementing-rcu-barrier">
<h2>Implementing rcu_barrier()<a class="headerlink" href="#implementing-rcu-barrier" title="Permalink to this headline">¶</a></h2>
<p>Dipankar Sarma’s implementation of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> makes use of the fact
that RCU callbacks are never reordered once queued on one of the per-CPU
queues. His implementation queues an RCU callback on each of the per-CPU
callback queues, and then waits until they have all started executing, at
which point, all earlier RCU callbacks are guaranteed to have completed.</p>
<p>The original code for <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> was as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1  void rcu_barrier(void)
2  {
3    BUG_ON(in_interrupt());
4    /* Take cpucontrol mutex to protect against CPU hotplug */
5    mutex_lock(&amp;rcu_barrier_mutex);
6    init_completion(&amp;rcu_barrier_completion);
7    atomic_set(&amp;rcu_barrier_cpu_count, 0);
8    on_each_cpu(rcu_barrier_func, NULL, 0, 1);
9    wait_for_completion(&amp;rcu_barrier_completion);
10   mutex_unlock(&amp;rcu_barrier_mutex);
11 }
</pre></div>
</div>
<p>Line 3 verifies that the caller is in process context, and lines 5 and 10
use rcu_barrier_mutex to ensure that only one <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> is using the
global completion and counters at a time, which are initialized on lines
6 and 7. Line 8 causes each CPU to invoke rcu_barrier_func(), which is
shown below. Note that the final “1” in on_each_cpu()’s argument list
ensures that all the calls to rcu_barrier_func() will have completed
before on_each_cpu() returns. Line 9 then waits for the completion.</p>
<p>This code was rewritten in 2008 and several times thereafter, but this
still gives the general idea.</p>
<p>The rcu_barrier_func() runs on each CPU, where it invokes <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>
to post an RCU callback, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1  static void rcu_barrier_func(void *notused)
2  {
3    int cpu = smp_processor_id();
4    struct rcu_data *rdp = &amp;per_cpu(rcu_data, cpu);
5    struct rcu_head *head;
6
7    head = &amp;rdp-&gt;barrier;
8    atomic_inc(&amp;rcu_barrier_cpu_count);
9    call_rcu(head, rcu_barrier_callback);
10 }
</pre></div>
</div>
<p>Lines 3 and 4 locate RCU’s internal per-CPU rcu_data structure,
which contains the struct rcu_head that needed for the later call to
<a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>. Line 7 picks up a pointer to this struct rcu_head, and line
8 increments a global counter. This counter will later be decremented
by the callback. Line 9 then registers the rcu_barrier_callback() on
the current CPU’s queue.</p>
<p>The rcu_barrier_callback() function simply atomically decrements the
rcu_barrier_cpu_count variable and finalizes the completion when it
reaches zero, as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1 static void rcu_barrier_callback(struct rcu_head *notused)
2 {
3   if (atomic_dec_and_test(&amp;rcu_barrier_cpu_count))
4     complete(&amp;rcu_barrier_completion);
5 }
</pre></div>
</div>
<dl class="simple" id="rcubarrier-quiz-2">
<dt>Quick Quiz #2:</dt><dd><p>What happens if CPU 0’s rcu_barrier_func() executes
immediately (thus incrementing rcu_barrier_cpu_count to the
value one), but the other CPU’s rcu_barrier_func() invocations
are delayed for a full grace period? Couldn’t this result in
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> returning prematurely?</p>
</dd>
</dl>
<p><a class="reference internal" href="#answer-rcubarrier-quiz-2"><span class="std std-ref">Answer to Quick Quiz #2</span></a></p>
<p>The current <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> implementation is more complex, due to the need
to avoid disturbing idle CPUs (especially on battery-powered systems)
and the need to minimally disturb non-idle CPUs in real-time systems.
However, the code above illustrates the concepts.</p>
</section>
<section id="rcu-barrier-summary">
<h2>rcu_barrier() Summary<a class="headerlink" href="#rcu-barrier-summary" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> primitive has seen relatively little use, since most
code using RCU is in the core kernel rather than in modules. However, if
you are using RCU from an unloadable module, you need to use <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a>
so that your module may be safely unloaded.</p>
</section>
<section id="answers-to-quick-quizzes">
<h2>Answers to Quick Quizzes<a class="headerlink" href="#answers-to-quick-quizzes" title="Permalink to this headline">¶</a></h2>
<dl id="answer-rcubarrier-quiz-1">
<dt>Quick Quiz #1:</dt><dd><p>Is there any other situation where <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> might
be required?</p>
</dd>
<dt>Answer: Interestingly enough, rcu_barrier() was not originally</dt><dd><p>implemented for module unloading. Nikita Danilov was using
RCU in a filesystem, which resulted in a similar situation at
filesystem-unmount time. Dipankar Sarma coded up <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a>
in response, so that Nikita could invoke it during the
filesystem-unmount process.</p>
<p>Much later, yours truly hit the RCU module-unload problem when
implementing rcutorture, and found that <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> solves
this problem as well.</p>
</dd>
</dl>
<p><a class="reference internal" href="#rcubarrier-quiz-1"><span class="std std-ref">Back to Quick Quiz #1</span></a></p>
<dl id="answer-rcubarrier-quiz-2">
<dt>Quick Quiz #2:</dt><dd><p>What happens if CPU 0’s rcu_barrier_func() executes
immediately (thus incrementing rcu_barrier_cpu_count to the
value one), but the other CPU’s rcu_barrier_func() invocations
are delayed for a full grace period? Couldn’t this result in
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a> returning prematurely?</p>
</dd>
<dt>Answer: This cannot happen. The reason is that on_each_cpu() has its last</dt><dd><p>argument, the wait flag, set to “1”. This flag is passed through
to smp_call_function() and further to smp_call_function_on_cpu(),
causing this latter to spin until the cross-CPU invocation of
rcu_barrier_func() has completed. This by itself would prevent
a grace period from completing on non-CONFIG_PREEMPTION kernels,
since each CPU must undergo a context switch (or other quiescent
state) before the grace period can complete. However, this is
of no use in CONFIG_PREEMPTION kernels.</p>
<p>Therefore, on_each_cpu() disables preemption across its call
to smp_call_function() and also across the local call to
rcu_barrier_func(). This prevents the local CPU from context
switching, again preventing grace periods from completing. This
means that all CPUs have executed rcu_barrier_func() before
the first rcu_barrier_callback() can possibly execute, in turn
preventing rcu_barrier_cpu_count from prematurely reaching zero.</p>
<p>Currently, -rt implementations of RCU keep but a single global
queue for RCU callbacks, and thus do not suffer from this
problem. However, when the -rt RCU eventually does have per-CPU
callback queues, things will have to change. One simple change
is to add an <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code></a> before line 8 of <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_barrier()</span></code></a>
and an <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code></a> after line 8 of this same function. If
you can think of a better change, please let me know!</p>
</dd>
</dl>
<p><a class="reference internal" href="#rcubarrier-quiz-2"><span class="std std-ref">Back to Quick Quiz #2</span></a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">RCU and Unloadable Modules</a><ul>
<li><a class="reference internal" href="#unloading-modules-that-use-call-rcu">Unloading Modules That Use call_rcu()</a></li>
<li><a class="reference internal" href="#id1">rcu_barrier()</a></li>
<li><a class="reference internal" href="#implementing-rcu-barrier">Implementing rcu_barrier()</a></li>
<li><a class="reference internal" href="#rcu-barrier-summary">rcu_barrier() Summary</a></li>
<li><a class="reference internal" href="#answers-to-quick-quizzes">Answers to Quick Quizzes</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/RCU/rcubarrier.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/RCU/rcubarrier.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>