
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Runtime Power Management Framework for I/O Devices &#8212; The Linux Kernel 6.2.0-rc4+ documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="How to get s2ram working" href="s2ram.html" />
    <link rel="prev" title="Linux power supply class" href="power_supply_class.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="runtime-power-management-framework-for-i-o-devices">
<h1>Runtime Power Management Framework for I/O Devices<a class="headerlink" href="#runtime-power-management-framework-for-i-o-devices" title="Permalink to this headline">¶</a></h1>
<ol class="upperalpha simple" start="3">
<li><p>2009-2011 Rafael J. Wysocki &lt;<a class="reference external" href="mailto:rjw&#37;&#52;&#48;sisk&#46;pl">rjw<span>&#64;</span>sisk<span>&#46;</span>pl</a>&gt;, Novell Inc.</p></li>
</ol>
<ol class="upperalpha simple" start="3">
<li><p>2010 Alan Stern &lt;<a class="reference external" href="mailto:stern&#37;&#52;&#48;rowland&#46;harvard&#46;edu">stern<span>&#64;</span>rowland<span>&#46;</span>harvard<span>&#46;</span>edu</a>&gt;</p></li>
</ol>
<ol class="upperalpha simple" start="3">
<li><p>2014 Intel Corp., Rafael J. Wysocki &lt;<a class="reference external" href="mailto:rafael&#46;j&#46;wysocki&#37;&#52;&#48;intel&#46;com">rafael<span>&#46;</span>j<span>&#46;</span>wysocki<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;</p></li>
</ol>
<section id="introduction">
<h2>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Support for runtime power management (runtime PM) of I/O devices is provided
at the power management core (PM core) level by means of:</p>
<ul class="simple">
<li><p>The power management workqueue pm_wq in which bus types and device drivers can
put their PM-related work items.  It is strongly recommended that pm_wq be
used for queuing all work items related to runtime PM, because this allows
them to be synchronized with system-wide power transitions (suspend to RAM,
hibernation and resume from system sleep states).  pm_wq is declared in
include/linux/pm_runtime.h and defined in kernel/power/main.c.</p></li>
<li><p>A number of runtime PM fields in the ‘power’ member of ‘<a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>’ (which
is of the type ‘struct dev_pm_info’, defined in include/linux/pm.h) that can
be used for synchronizing runtime PM operations with one another.</p></li>
<li><p>Three device runtime PM callbacks in ‘<a class="reference internal" href="../driver-api/pm/types.html#c.dev_pm_ops" title="dev_pm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_ops</span></code></a>’ (defined in
include/linux/pm.h).</p></li>
<li><p>A set of helper functions defined in drivers/base/power/runtime.c that can be
used for carrying out runtime PM operations in such a way that the
synchronization between them is taken care of by the PM core.  Bus types and
device drivers are encouraged to use these functions.</p></li>
</ul>
<p>The runtime PM callbacks present in ‘<a class="reference internal" href="../driver-api/pm/types.html#c.dev_pm_ops" title="dev_pm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_ops</span></code></a>’, the device runtime PM
fields of ‘struct dev_pm_info’ and the core helper functions provided for
runtime PM are described below.</p>
</section>
<section id="device-runtime-pm-callbacks">
<h2>2. Device Runtime PM Callbacks<a class="headerlink" href="#device-runtime-pm-callbacks" title="Permalink to this headline">¶</a></h2>
<p>There are three device runtime PM callbacks defined in ‘<a class="reference internal" href="../driver-api/pm/types.html#c.dev_pm_ops" title="dev_pm_ops"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dev_pm_ops</span></code></a>’:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct dev_pm_ops {
      ...
      int (*runtime_suspend)(struct device *dev);
      int (*runtime_resume)(struct device *dev);
      int (*runtime_idle)(struct device *dev);
      ...
};
</pre></div>
</div>
<p>The -&gt;runtime_suspend(), -&gt;runtime_resume() and -&gt;runtime_idle() callbacks
are executed by the PM core for the device’s subsystem that may be either of
the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>PM domain of the device, if the device’s PM domain object, dev-&gt;pm_domain,
is present.</p></li>
<li><p>Device type of the device, if both dev-&gt;type and dev-&gt;type-&gt;pm are present.</p></li>
<li><p>Device class of the device, if both dev-&gt;class and dev-&gt;class-&gt;pm are
present.</p></li>
<li><p>Bus type of the device, if both dev-&gt;bus and dev-&gt;bus-&gt;pm are present.</p></li>
</ol>
</div></blockquote>
<p>If the subsystem chosen by applying the above rules doesn’t provide the relevant
callback, the PM core will invoke the corresponding driver callback stored in
dev-&gt;driver-&gt;pm directly (if present).</p>
<p>The PM core always checks which callback to use in the order given above, so the
priority order of callbacks from high to low is: PM domain, device type, class
and bus type.  Moreover, the high-priority one will always take precedence over
a low-priority one.  The PM domain, bus type, device type and class callbacks
are referred to as subsystem-level callbacks in what follows.</p>
<p>By default, the callbacks are always invoked in process context with interrupts
enabled.  However, the pm_runtime_irq_safe() helper function can be used to tell
the PM core that it is safe to run the -&gt;runtime_suspend(), -&gt;runtime_resume()
and -&gt;runtime_idle() callbacks for the given device in atomic context with
interrupts disabled.  This implies that the callback routines in question must
not block or sleep, but it also means that the synchronous helper functions
listed at the end of Section 4 may be used for that device within an interrupt
handler or generally in an atomic context.</p>
<p>The subsystem-level suspend callback, if present, is _entirely_ _responsible_
for handling the suspend of the device as appropriate, which may, but need not
include executing the device driver’s own -&gt;runtime_suspend() callback (from the
PM core’s point of view it is not necessary to implement a -&gt;runtime_suspend()
callback in a device driver as long as the subsystem-level suspend callback
knows what to do to handle the device).</p>
<blockquote>
<div><ul class="simple">
<li><p>Once the subsystem-level suspend callback (or the driver suspend callback,
if invoked directly) has completed successfully for the given device, the PM
core regards the device as suspended, which need not mean that it has been
put into a low power state.  It is supposed to mean, however, that the
device will not process data and will not communicate with the CPU(s) and
RAM until the appropriate resume callback is executed for it.  The runtime
PM status of a device after successful execution of the suspend callback is
‘suspended’.</p></li>
<li><p>If the suspend callback returns -EBUSY or -EAGAIN, the device’s runtime PM
status remains ‘active’, which means that the device _must_ be fully
operational afterwards.</p></li>
<li><p>If the suspend callback returns an error code different from -EBUSY and
-EAGAIN, the PM core regards this as a fatal error and will refuse to run
the helper functions described in Section 4 for the device until its status
is directly set to  either ‘active’, or ‘suspended’ (the PM core provides
special helper functions for this purpose).</p></li>
</ul>
</div></blockquote>
<p>In particular, if the driver requires remote wakeup capability (i.e. hardware
mechanism allowing the device to request a change of its power state, such as
PCI PME) for proper functioning and device_can_wakeup() returns ‘false’ for the
device, then -&gt;runtime_suspend() should return -EBUSY.  On the other hand, if
device_can_wakeup() returns ‘true’ for the device and the device is put into a
low-power state during the execution of the suspend callback, it is expected
that remote wakeup will be enabled for the device.  Generally, remote wakeup
should be enabled for all input devices put into low-power states at run time.</p>
<p>The subsystem-level resume callback, if present, is <strong>entirely responsible</strong> for
handling the resume of the device as appropriate, which may, but need not
include executing the device driver’s own -&gt;runtime_resume() callback (from the
PM core’s point of view it is not necessary to implement a -&gt;runtime_resume()
callback in a device driver as long as the subsystem-level resume callback knows
what to do to handle the device).</p>
<blockquote>
<div><ul class="simple">
<li><p>Once the subsystem-level resume callback (or the driver resume callback, if
invoked directly) has completed successfully, the PM core regards the device
as fully operational, which means that the device _must_ be able to complete
I/O operations as needed.  The runtime PM status of the device is then
‘active’.</p></li>
<li><p>If the resume callback returns an error code, the PM core regards this as a
fatal error and will refuse to run the helper functions described in Section
4 for the device, until its status is directly set to either ‘active’, or
‘suspended’ (by means of special helper functions provided by the PM core
for this purpose).</p></li>
</ul>
</div></blockquote>
<p>The idle callback (a subsystem-level one, if present, or the driver one) is
executed by the PM core whenever the device appears to be idle, which is
indicated to the PM core by two counters, the device’s usage counter and the
counter of ‘active’ children of the device.</p>
<blockquote>
<div><ul class="simple">
<li><p>If any of these counters is decreased using a helper function provided by
the PM core and it turns out to be equal to zero, the other counter is
checked.  If that counter also is equal to zero, the PM core executes the
idle callback with the device as its argument.</p></li>
</ul>
</div></blockquote>
<p>The action performed by the idle callback is totally dependent on the subsystem
(or driver) in question, but the expected and recommended action is to check
if the device can be suspended (i.e. if all of the conditions necessary for
suspending the device are satisfied) and to queue up a suspend request for the
device in that case.  If there is no idle callback, or if the callback returns
0, then the PM core will attempt to carry out a runtime suspend of the device,
also respecting devices configured for autosuspend.  In essence this means a
call to pm_runtime_autosuspend() (do note that drivers needs to update the
device last busy mark, pm_runtime_mark_last_busy(), to control the delay under
this circumstance).  To prevent this (for example, if the callback routine has
started a delayed suspend), the routine must return a non-zero value.  Negative
error return codes are ignored by the PM core.</p>
<p>The helper functions provided by the PM core, described in Section 4, guarantee
that the following constraints are met with respect to runtime PM callbacks for
one device:</p>
<ol class="arabic simple">
<li><p>The callbacks are mutually exclusive (e.g. it is forbidden to execute
-&gt;runtime_suspend() in parallel with -&gt;runtime_resume() or with another
instance of -&gt;runtime_suspend() for the same device) with the exception that
-&gt;runtime_suspend() or -&gt;runtime_resume() can be executed in parallel with
-&gt;runtime_idle() (although -&gt;runtime_idle() will not be started while any
of the other callbacks is being executed for the same device).</p></li>
<li><p>-&gt;runtime_idle() and -&gt;runtime_suspend() can only be executed for ‘active’
devices (i.e. the PM core will only execute -&gt;runtime_idle() or
-&gt;runtime_suspend() for the devices the runtime PM status of which is
‘active’).</p></li>
<li><p>-&gt;runtime_idle() and -&gt;runtime_suspend() can only be executed for a device
the usage counter of which is equal to zero _and_ either the counter of
‘active’ children of which is equal to zero, or the ‘power.ignore_children’
flag of which is set.</p></li>
<li><p>-&gt;runtime_resume() can only be executed for ‘suspended’ devices  (i.e. the
PM core will only execute -&gt;runtime_resume() for the devices the runtime
PM status of which is ‘suspended’).</p></li>
</ol>
<p>Additionally, the helper functions provided by the PM core obey the following
rules:</p>
<blockquote>
<div><ul class="simple">
<li><p>If -&gt;runtime_suspend() is about to be executed or there’s a pending request
to execute it, -&gt;runtime_idle() will not be executed for the same device.</p></li>
<li><p>A request to execute or to schedule the execution of -&gt;runtime_suspend()
will cancel any pending requests to execute -&gt;runtime_idle() for the same
device.</p></li>
<li><p>If -&gt;runtime_resume() is about to be executed or there’s a pending request
to execute it, the other callbacks will not be executed for the same device.</p></li>
<li><p>A request to execute -&gt;runtime_resume() will cancel any pending or
scheduled requests to execute the other callbacks for the same device,
except for scheduled autosuspends.</p></li>
</ul>
</div></blockquote>
</section>
<section id="runtime-pm-device-fields">
<h2>3. Runtime PM Device Fields<a class="headerlink" href="#runtime-pm-device-fields" title="Permalink to this headline">¶</a></h2>
<p>The following device runtime PM fields are present in ‘struct dev_pm_info’, as
defined in include/linux/pm.h:</p>
<blockquote>
<div><dl class="simple">
<dt><cite>struct timer_list suspend_timer;</cite></dt><dd><ul class="simple">
<li><p>timer used for scheduling (delayed) suspend and autosuspend requests</p></li>
</ul>
</dd>
<dt><cite>unsigned long timer_expires;</cite></dt><dd><ul class="simple">
<li><p>timer expiration time, in jiffies (if this is different from zero, the
timer is running and will expire at that time, otherwise the timer is not
running)</p></li>
</ul>
</dd>
<dt><cite>struct work_struct work;</cite></dt><dd><ul class="simple">
<li><p>work structure used for queuing up requests (i.e. work items in pm_wq)</p></li>
</ul>
</dd>
<dt><cite>wait_queue_head_t wait_queue;</cite></dt><dd><ul class="simple">
<li><p>wait queue used if any of the helper functions needs to wait for another
one to complete</p></li>
</ul>
</dd>
<dt><cite>spinlock_t lock;</cite></dt><dd><ul class="simple">
<li><p>lock used for synchronization</p></li>
</ul>
</dd>
<dt><cite>atomic_t usage_count;</cite></dt><dd><ul class="simple">
<li><p>the usage counter of the device</p></li>
</ul>
</dd>
<dt><cite>atomic_t child_count;</cite></dt><dd><ul class="simple">
<li><p>the count of ‘active’ children of the device</p></li>
</ul>
</dd>
<dt><cite>unsigned int ignore_children;</cite></dt><dd><ul class="simple">
<li><p>if set, the value of child_count is ignored (but still updated)</p></li>
</ul>
</dd>
<dt><cite>unsigned int disable_depth;</cite></dt><dd><ul class="simple">
<li><p>used for disabling the helper functions (they work normally if this is
equal to zero); the initial value of it is 1 (i.e. runtime PM is
initially disabled for all devices)</p></li>
</ul>
</dd>
<dt><cite>int runtime_error;</cite></dt><dd><ul class="simple">
<li><p>if set, there was a fatal error (one of the callbacks returned error code
as described in Section 2), so the helper functions will not work until
this flag is cleared; this is the error code returned by the failing
callback</p></li>
</ul>
</dd>
<dt><cite>unsigned int idle_notification;</cite></dt><dd><ul class="simple">
<li><p>if set, -&gt;runtime_idle() is being executed</p></li>
</ul>
</dd>
<dt><cite>unsigned int request_pending;</cite></dt><dd><ul class="simple">
<li><p>if set, there’s a pending request (i.e. a work item queued up into pm_wq)</p></li>
</ul>
</dd>
<dt><cite>enum rpm_request request;</cite></dt><dd><ul class="simple">
<li><p>type of request that’s pending (valid if request_pending is set)</p></li>
</ul>
</dd>
<dt><cite>unsigned int deferred_resume;</cite></dt><dd><ul class="simple">
<li><p>set if -&gt;runtime_resume() is about to be run while -&gt;runtime_suspend() is
being executed for that device and it is not practical to wait for the
suspend to complete; means “start a resume as soon as you’ve suspended”</p></li>
</ul>
</dd>
<dt><cite>enum rpm_status runtime_status;</cite></dt><dd><ul class="simple">
<li><p>the runtime PM status of the device; this field’s initial value is
RPM_SUSPENDED, which means that each device is initially regarded by the
PM core as ‘suspended’, regardless of its real hardware status</p></li>
</ul>
</dd>
<dt><cite>enum rpm_status last_status;</cite></dt><dd><ul class="simple">
<li><p>the last runtime PM status of the device captured before disabling runtime
PM for it (invalid initially and when disable_depth is 0)</p></li>
</ul>
</dd>
<dt><cite>unsigned int runtime_auto;</cite></dt><dd><ul class="simple">
<li><p>if set, indicates that the user space has allowed the device driver to
power manage the device at run time via the /sys/devices/…/power/control
<cite>interface;</cite> it may only be modified with the help of the
pm_runtime_allow() and pm_runtime_forbid() helper functions</p></li>
</ul>
</dd>
<dt><cite>unsigned int no_callbacks;</cite></dt><dd><ul class="simple">
<li><p>indicates that the device does not use the runtime PM callbacks (see
Section 8); it may be modified only by the pm_runtime_no_callbacks()
helper function</p></li>
</ul>
</dd>
<dt><cite>unsigned int irq_safe;</cite></dt><dd><ul class="simple">
<li><p>indicates that the -&gt;runtime_suspend() and -&gt;runtime_resume() callbacks
will be invoked with the spinlock held and interrupts disabled</p></li>
</ul>
</dd>
<dt><cite>unsigned int use_autosuspend;</cite></dt><dd><ul class="simple">
<li><p>indicates that the device’s driver supports delayed autosuspend (see
Section 9); it may be modified only by the
pm_runtime{_dont}_use_autosuspend() helper functions</p></li>
</ul>
</dd>
<dt><cite>unsigned int timer_autosuspends;</cite></dt><dd><ul class="simple">
<li><p>indicates that the PM core should attempt to carry out an autosuspend
when the timer expires rather than a normal suspend</p></li>
</ul>
</dd>
<dt><cite>int autosuspend_delay;</cite></dt><dd><ul class="simple">
<li><p>the delay time (in milliseconds) to be used for autosuspend</p></li>
</ul>
</dd>
<dt><cite>unsigned long last_busy;</cite></dt><dd><ul class="simple">
<li><p>the time (in jiffies) when the pm_runtime_mark_last_busy() helper
function was last called for this device; used in calculating inactivity
periods for autosuspend</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>All of the above fields are members of the ‘power’ member of ‘<a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code></a>’.</p>
</section>
<section id="runtime-pm-device-helper-functions">
<h2>4. Runtime PM Device Helper Functions<a class="headerlink" href="#runtime-pm-device-helper-functions" title="Permalink to this headline">¶</a></h2>
<p>The following runtime PM helper functions are defined in
drivers/base/power/runtime.c and include/linux/pm_runtime.h:</p>
<blockquote>
<div><dl class="simple">
<dt><cite>void pm_runtime_init(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>initialize the device runtime PM fields in ‘struct dev_pm_info’</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_remove(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>make sure that the runtime PM of the device will be disabled after
removing the device from device hierarchy</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_idle(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>execute the subsystem-level idle callback for the device; returns an
error code on failure, where -EINPROGRESS means that -&gt;runtime_idle() is
already being executed; if there is no callback or the callback returns 0
then run pm_runtime_autosuspend(dev) and return its result</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_suspend(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>execute the subsystem-level suspend callback for the device; returns 0 on
success, 1 if the device’s runtime PM status was already ‘suspended’, or
error code on failure, where -EAGAIN or -EBUSY means it is safe to attempt
to suspend the device again in future and -EACCES means that
‘power.disable_depth’ is different from 0</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_autosuspend(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>same as pm_runtime_suspend() except that the autosuspend delay is taken
<cite>into account;</cite> if pm_runtime_autosuspend_expiration() says the delay has
not yet expired then an autosuspend is scheduled for the appropriate time
and 0 is returned</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_resume(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>execute the subsystem-level resume callback for the device; returns 0 on
success, 1 if the device’s runtime PM status is already ‘active’ (also if
‘power.disable_depth’ is nonzero, but the status was ‘active’ when it was
changing from 0 to 1) or error code on failure, where -EAGAIN means it may
be safe to attempt to resume the device again in future, but
‘power.runtime_error’ should be checked additionally, and -EACCES means
that the callback could not be run, because ‘power.disable_depth’ was
different from 0</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_resume_and_get(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>run pm_runtime_resume(dev) and if successful, increment the device’s
usage counter; return the result of pm_runtime_resume</p></li>
</ul>
</dd>
<dt><cite>int pm_request_idle(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>submit a request to execute the subsystem-level idle callback for the
device (the request is represented by a work item in pm_wq); returns 0 on
success or error code if the request has not been queued up</p></li>
</ul>
</dd>
<dt><cite>int pm_request_autosuspend(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>schedule the execution of the subsystem-level suspend callback for the
device when the autosuspend delay has expired; if the delay has already
expired then the work item is queued up immediately</p></li>
</ul>
</dd>
<dt><cite>int pm_schedule_suspend(struct device *dev, unsigned int delay);</cite></dt><dd><ul class="simple">
<li><p>schedule the execution of the subsystem-level suspend callback for the
device in future, where ‘delay’ is the time to wait before queuing up a
suspend work item in pm_wq, in milliseconds (if ‘delay’ is zero, the work
item is queued up immediately); returns 0 on success, 1 if the device’s PM
runtime status was already ‘suspended’, or error code if the request
hasn’t been scheduled (or queued up if ‘delay’ is 0); if the execution of
-&gt;runtime_suspend() is already scheduled and not yet expired, the new
value of ‘delay’ will be used as the time to wait</p></li>
</ul>
</dd>
<dt><cite>int pm_request_resume(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>submit a request to execute the subsystem-level resume callback for the
device (the request is represented by a work item in pm_wq); returns 0 on
success, 1 if the device’s runtime PM status was already ‘active’, or
error code if the request hasn’t been queued up</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_get_noresume(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>increment the device’s usage counter</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_get(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>increment the device’s usage counter, run pm_request_resume(dev) and
return its result</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_get_sync(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>increment the device’s usage counter, run pm_runtime_resume(dev) and
return its result;
note that it does not drop the device’s usage counter on errors, so
consider using pm_runtime_resume_and_get() instead of it, especially
if its return value is checked by the caller, as this is likely to
result in cleaner code.</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_get_if_in_use(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>return -EINVAL if ‘power.disable_depth’ is nonzero; otherwise, if the
runtime PM status is RPM_ACTIVE and the runtime PM usage counter is
nonzero, increment the counter and return 1; otherwise return 0 without
changing the counter</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_get_if_active(struct device *dev, bool ign_usage_count);</cite></dt><dd><ul class="simple">
<li><p>return -EINVAL if ‘power.disable_depth’ is nonzero; otherwise, if the
runtime PM status is RPM_ACTIVE, and either ign_usage_count is true
or the device’s usage_count is non-zero, increment the counter and
return 1; otherwise return 0 without changing the counter</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_put_noidle(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>decrement the device’s usage counter</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_put(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>decrement the device’s usage counter; if the result is 0 then run
pm_request_idle(dev) and return its result</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_put_autosuspend(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>decrement the device’s usage counter; if the result is 0 then run
pm_request_autosuspend(dev) and return its result</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_put_sync(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>decrement the device’s usage counter; if the result is 0 then run
pm_runtime_idle(dev) and return its result</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_put_sync_suspend(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>decrement the device’s usage counter; if the result is 0 then run
pm_runtime_suspend(dev) and return its result</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_put_sync_autosuspend(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>decrement the device’s usage counter; if the result is 0 then run
pm_runtime_autosuspend(dev) and return its result</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_enable(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>decrement the device’s ‘power.disable_depth’ field; if that field is equal
to zero, the runtime PM helper functions can execute subsystem-level
callbacks described in Section 2 for the device</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_disable(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>increment the device’s ‘power.disable_depth’ field (if the value of that
field was previously zero, this prevents subsystem-level runtime PM
callbacks from being run for the device), make sure that all of the
pending runtime PM operations on the device are either completed or
canceled; returns 1 if there was a resume request pending and it was
necessary to execute the subsystem-level resume callback for the device
to satisfy that request, otherwise 0 is returned</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_barrier(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>check if there’s a resume request pending for the device and resume it
(synchronously) in that case, cancel any other pending runtime PM requests
regarding it and wait for all runtime PM operations on it in progress to
complete; returns 1 if there was a resume request pending and it was
necessary to execute the subsystem-level resume callback for the device to
satisfy that request, otherwise 0 is returned</p></li>
</ul>
</dd>
<dt><cite>void pm_suspend_ignore_children(struct device *dev, bool enable);</cite></dt><dd><ul class="simple">
<li><p>set/unset the power.ignore_children flag of the device</p></li>
</ul>
</dd>
<dt><cite>int pm_runtime_set_active(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>clear the device’s ‘power.runtime_error’ flag, set the device’s runtime
PM status to ‘active’ and update its parent’s counter of ‘active’
children as appropriate (it is only valid to use this function if
‘power.runtime_error’ is set or ‘power.disable_depth’ is greater than
zero); it will fail and return error code if the device has a parent
which is not active and the ‘power.ignore_children’ flag of which is unset</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_set_suspended(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>clear the device’s ‘power.runtime_error’ flag, set the device’s runtime
PM status to ‘suspended’ and update its parent’s counter of ‘active’
children as appropriate (it is only valid to use this function if
‘power.runtime_error’ is set or ‘power.disable_depth’ is greater than
zero)</p></li>
</ul>
</dd>
<dt><cite>bool pm_runtime_active(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>return true if the device’s runtime PM status is ‘active’ or its
‘power.disable_depth’ field is not equal to zero, or false otherwise</p></li>
</ul>
</dd>
<dt><cite>bool pm_runtime_suspended(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>return true if the device’s runtime PM status is ‘suspended’ and its
‘power.disable_depth’ field is equal to zero, or false otherwise</p></li>
</ul>
</dd>
<dt><cite>bool pm_runtime_status_suspended(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>return true if the device’s runtime PM status is ‘suspended’</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_allow(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>set the power.runtime_auto flag for the device and decrease its usage
counter (used by the /sys/devices/…/power/control interface to
effectively allow the device to be power managed at run time)</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_forbid(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>unset the power.runtime_auto flag for the device and increase its usage
counter (used by the /sys/devices/…/power/control interface to
effectively prevent the device from being power managed at run time)</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_no_callbacks(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>set the power.no_callbacks flag for the device and remove the runtime
PM attributes from /sys/devices/…/power (or prevent them from being
added when the device is registered)</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_irq_safe(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>set the power.irq_safe flag for the device, causing the runtime-PM
callbacks to be invoked with interrupts off</p></li>
</ul>
</dd>
<dt><cite>bool pm_runtime_is_irq_safe(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>return true if power.irq_safe flag was set for the device, causing
the runtime-PM callbacks to be invoked with interrupts off</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_mark_last_busy(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>set the power.last_busy field to the current time</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_use_autosuspend(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>set the power.use_autosuspend flag, enabling autosuspend delays; call
pm_runtime_get_sync if the flag was previously cleared and
power.autosuspend_delay is negative</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_dont_use_autosuspend(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>clear the power.use_autosuspend flag, disabling autosuspend delays;
decrement the device’s usage counter if the flag was previously set and
power.autosuspend_delay is negative; call pm_runtime_idle</p></li>
</ul>
</dd>
<dt><cite>void pm_runtime_set_autosuspend_delay(struct device *dev, int delay);</cite></dt><dd><ul class="simple">
<li><p>set the power.autosuspend_delay value to ‘delay’ (expressed in
milliseconds); if ‘delay’ is negative then runtime suspends are
prevented; if power.use_autosuspend is set, pm_runtime_get_sync may be
called or the device’s usage counter may be decremented and
pm_runtime_idle called depending on if power.autosuspend_delay is
changed to or from a negative value; if power.use_autosuspend is clear,
pm_runtime_idle is called</p></li>
</ul>
</dd>
<dt><cite>unsigned long pm_runtime_autosuspend_expiration(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>calculate the time when the current autosuspend delay period will expire,
based on power.last_busy and power.autosuspend_delay; if the delay time
is 1000 ms or larger then the expiration time is rounded up to the
nearest second; returns 0 if the delay period has already expired or
power.use_autosuspend isn’t set, otherwise returns the expiration time
in jiffies</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>It is safe to execute the following helper functions from interrupt context:</p>
<ul class="simple">
<li><p>pm_request_idle()</p></li>
<li><p>pm_request_autosuspend()</p></li>
<li><p>pm_schedule_suspend()</p></li>
<li><p>pm_request_resume()</p></li>
<li><p>pm_runtime_get_noresume()</p></li>
<li><p>pm_runtime_get()</p></li>
<li><p>pm_runtime_put_noidle()</p></li>
<li><p>pm_runtime_put()</p></li>
<li><p>pm_runtime_put_autosuspend()</p></li>
<li><p>pm_runtime_enable()</p></li>
<li><p>pm_suspend_ignore_children()</p></li>
<li><p>pm_runtime_set_active()</p></li>
<li><p>pm_runtime_set_suspended()</p></li>
<li><p>pm_runtime_suspended()</p></li>
<li><p>pm_runtime_mark_last_busy()</p></li>
<li><p>pm_runtime_autosuspend_expiration()</p></li>
</ul>
<p>If pm_runtime_irq_safe() has been called for a device then the following helper
functions may also be used in interrupt context:</p>
<ul class="simple">
<li><p>pm_runtime_idle()</p></li>
<li><p>pm_runtime_suspend()</p></li>
<li><p>pm_runtime_autosuspend()</p></li>
<li><p>pm_runtime_resume()</p></li>
<li><p>pm_runtime_get_sync()</p></li>
<li><p>pm_runtime_put_sync()</p></li>
<li><p>pm_runtime_put_sync_suspend()</p></li>
<li><p>pm_runtime_put_sync_autosuspend()</p></li>
</ul>
</section>
<section id="runtime-pm-initialization-device-probing-and-removal">
<h2>5. Runtime PM Initialization, Device Probing and Removal<a class="headerlink" href="#runtime-pm-initialization-device-probing-and-removal" title="Permalink to this headline">¶</a></h2>
<p>Initially, the runtime PM is disabled for all devices, which means that the
majority of the runtime PM helper functions described in Section 4 will return
-EAGAIN until pm_runtime_enable() is called for the device.</p>
<p>In addition to that, the initial runtime PM status of all devices is
‘suspended’, but it need not reflect the actual physical state of the device.
Thus, if the device is initially active (i.e. it is able to process I/O), its
runtime PM status must be changed to ‘active’, with the help of
pm_runtime_set_active(), before pm_runtime_enable() is called for the device.</p>
<p>However, if the device has a parent and the parent’s runtime PM is enabled,
calling pm_runtime_set_active() for the device will affect the parent, unless
the parent’s ‘power.ignore_children’ flag is set.  Namely, in that case the
parent won’t be able to suspend at run time, using the PM core’s helper
functions, as long as the child’s status is ‘active’, even if the child’s
runtime PM is still disabled (i.e. pm_runtime_enable() hasn’t been called for
the child yet or pm_runtime_disable() has been called for it).  For this reason,
once pm_runtime_set_active() has been called for the device, pm_runtime_enable()
should be called for it too as soon as reasonably possible or its runtime PM
status should be changed back to ‘suspended’ with the help of
pm_runtime_set_suspended().</p>
<p>If the default initial runtime PM status of the device (i.e. ‘suspended’)
reflects the actual state of the device, its bus type’s or its driver’s
-&gt;probe() callback will likely need to wake it up using one of the PM core’s
helper functions described in Section 4.  In that case, pm_runtime_resume()
should be used.  Of course, for this purpose the device’s runtime PM has to be
enabled earlier by calling pm_runtime_enable().</p>
<p>Note, if the device may execute pm_runtime calls during the probe (such as
if it is registered with a subsystem that may call back in) then the
pm_runtime_get_sync() call paired with a pm_runtime_put() call will be
appropriate to ensure that the device is not put back to sleep during the
probe. This can happen with systems such as the network device layer.</p>
<p>It may be desirable to suspend the device once -&gt;probe() has finished.
Therefore the driver core uses the asynchronous pm_request_idle() to submit a
request to execute the subsystem-level idle callback for the device at that
time.  A driver that makes use of the runtime autosuspend feature may want to
update the last busy mark before returning from -&gt;probe().</p>
<p>Moreover, the driver core prevents runtime PM callbacks from racing with the bus
notifier callback in __device_release_driver(), which is necessary because the
notifier is used by some subsystems to carry out operations affecting the
runtime PM functionality.  It does so by calling pm_runtime_get_sync() before
driver_sysfs_remove() and the BUS_NOTIFY_UNBIND_DRIVER notifications.  This
resumes the device if it’s in the suspended state and prevents it from
being suspended again while those routines are being executed.</p>
<p>To allow bus types and drivers to put devices into the suspended state by
calling pm_runtime_suspend() from their -&gt;remove() routines, the driver core
executes pm_runtime_put_sync() after running the BUS_NOTIFY_UNBIND_DRIVER
notifications in __device_release_driver().  This requires bus types and
drivers to make their -&gt;remove() callbacks avoid races with runtime PM directly,
but it also allows more flexibility in the handling of devices during the
removal of their drivers.</p>
<p>Drivers in -&gt;remove() callback should undo the runtime PM changes done
in -&gt;probe(). Usually this means calling pm_runtime_disable(),
pm_runtime_dont_use_autosuspend() etc.</p>
<p>The user space can effectively disallow the driver of the device to power manage
it at run time by changing the value of its /sys/devices/…/power/control
attribute to “on”, which causes pm_runtime_forbid() to be called.  In principle,
this mechanism may also be used by the driver to effectively turn off the
runtime power management of the device until the user space turns it on.
Namely, during the initialization the driver can make sure that the runtime PM
status of the device is ‘active’ and call pm_runtime_forbid().  It should be
noted, however, that if the user space has already intentionally changed the
value of /sys/devices/…/power/control to “auto” to allow the driver to power
manage the device at run time, the driver may confuse it by using
pm_runtime_forbid() this way.</p>
</section>
<section id="runtime-pm-and-system-sleep">
<h2>6. Runtime PM and System Sleep<a class="headerlink" href="#runtime-pm-and-system-sleep" title="Permalink to this headline">¶</a></h2>
<p>Runtime PM and system sleep (i.e., system suspend and hibernation, also known
as suspend-to-RAM and suspend-to-disk) interact with each other in a couple of
ways.  If a device is active when a system sleep starts, everything is
straightforward.  But what should happen if the device is already suspended?</p>
<p>The device may have different wake-up settings for runtime PM and system sleep.
For example, remote wake-up may be enabled for runtime suspend but disallowed
for system sleep (device_may_wakeup(dev) returns ‘false’).  When this happens,
the subsystem-level system suspend callback is responsible for changing the
device’s wake-up setting (it may leave that to the device driver’s system
suspend routine).  It may be necessary to resume the device and suspend it again
in order to do so.  The same is true if the driver uses different power levels
or other settings for runtime suspend and system sleep.</p>
<p>During system resume, the simplest approach is to bring all devices back to full
power, even if they had been suspended before the system suspend began.  There
are several reasons for this, including:</p>
<blockquote>
<div><ul class="simple">
<li><p>The device might need to switch power levels, wake-up settings, etc.</p></li>
<li><p>Remote wake-up events might have been lost by the firmware.</p></li>
<li><p>The device’s children may need the device to be at full power in order
to resume themselves.</p></li>
<li><p>The driver’s idea of the device state may not agree with the device’s
physical state.  This can happen during resume from hibernation.</p></li>
<li><p>The device might need to be reset.</p></li>
<li><p>Even though the device was suspended, if its usage counter was &gt; 0 then most
likely it would need a runtime resume in the near future anyway.</p></li>
</ul>
</div></blockquote>
<p>If the device had been suspended before the system suspend began and it’s
brought back to full power during resume, then its runtime PM status will have
to be updated to reflect the actual post-system sleep status.  The way to do
this is:</p>
<blockquote>
<div><ul class="simple">
<li><p>pm_runtime_disable(dev);</p></li>
<li><p>pm_runtime_set_active(dev);</p></li>
<li><p>pm_runtime_enable(dev);</p></li>
</ul>
</div></blockquote>
<p>The PM core always increments the runtime usage counter before calling the
-&gt;suspend() callback and decrements it after calling the -&gt;resume() callback.
Hence disabling runtime PM temporarily like this will not cause any runtime
suspend attempts to be permanently lost.  If the usage count goes to zero
following the return of the -&gt;resume() callback, the -&gt;runtime_idle() callback
will be invoked as usual.</p>
<p>On some systems, however, system sleep is not entered through a global firmware
or hardware operation.  Instead, all hardware components are put into low-power
states directly by the kernel in a coordinated way.  Then, the system sleep
state effectively follows from the states the hardware components end up in
and the system is woken up from that state by a hardware interrupt or a similar
mechanism entirely under the kernel’s control.  As a result, the kernel never
gives control away and the states of all devices during resume are precisely
known to it.  If that is the case and none of the situations listed above takes
place (in particular, if the system is not waking up from hibernation), it may
be more efficient to leave the devices that had been suspended before the system
suspend began in the suspended state.</p>
<p>To this end, the PM core provides a mechanism allowing some coordination between
different levels of device hierarchy.  Namely, if a system suspend .prepare()
callback returns a positive number for a device, that indicates to the PM core
that the device appears to be runtime-suspended and its state is fine, so it
may be left in runtime suspend provided that all of its descendants are also
left in runtime suspend.  If that happens, the PM core will not execute any
system suspend and resume callbacks for all of those devices, except for the
.complete() callback, which is then entirely responsible for handling the device
as appropriate.  This only applies to system suspend transitions that are not
related to hibernation (see <a class="reference internal" href="../driver-api/pm/devices.html"><span class="doc">Device Power Management Basics</span></a> for more
information).</p>
<p>The PM core does its best to reduce the probability of race conditions between
the runtime PM and system suspend/resume (and hibernation) callbacks by carrying
out the following operations:</p>
<blockquote>
<div><ul class="simple">
<li><p>During system suspend pm_runtime_get_noresume() is called for every device
right before executing the subsystem-level .prepare() callback for it and
pm_runtime_barrier() is called for every device right before executing the
subsystem-level .suspend() callback for it.  In addition to that the PM core
calls __pm_runtime_disable() with ‘false’ as the second argument for every
device right before executing the subsystem-level .suspend_late() callback
for it.</p></li>
<li><p>During system resume pm_runtime_enable() and pm_runtime_put() are called for
every device right after executing the subsystem-level .resume_early()
callback and right after executing the subsystem-level .complete() callback
for it, respectively.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="7">
<li><p>Generic subsystem callbacks</p></li>
</ol>
<p>Subsystems may wish to conserve code space by using the set of generic power
management callbacks provided by the PM core, defined in
driver/base/power/generic_ops.c:</p>
<blockquote>
<div><dl class="simple">
<dt><cite>int pm_generic_runtime_suspend(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>invoke the -&gt;runtime_suspend() callback provided by the driver of this
device and return its result, or return 0 if not defined</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_runtime_resume(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>invoke the -&gt;runtime_resume() callback provided by the driver of this
device and return its result, or return 0 if not defined</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_suspend(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>if the device has not been suspended at run time, invoke the -&gt;suspend()
callback provided by its driver and return its result, or return 0 if not
defined</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_suspend_noirq(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>if pm_runtime_suspended(dev) returns “false”, invoke the -&gt;suspend_noirq()
callback provided by the device’s driver and return its result, or return
0 if not defined</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_resume(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>invoke the -&gt;resume() callback provided by the driver of this device and,
if successful, change the device’s runtime PM status to ‘active’</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_resume_noirq(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>invoke the -&gt;resume_noirq() callback provided by the driver of this device</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_freeze(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>if the device has not been suspended at run time, invoke the -&gt;freeze()
callback provided by its driver and return its result, or return 0 if not
defined</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_freeze_noirq(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>if pm_runtime_suspended(dev) returns “false”, invoke the -&gt;freeze_noirq()
callback provided by the device’s driver and return its result, or return
0 if not defined</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_thaw(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>if the device has not been suspended at run time, invoke the -&gt;thaw()
callback provided by its driver and return its result, or return 0 if not
defined</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_thaw_noirq(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>if pm_runtime_suspended(dev) returns “false”, invoke the -&gt;thaw_noirq()
callback provided by the device’s driver and return its result, or return
0 if not defined</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_poweroff(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>if the device has not been suspended at run time, invoke the -&gt;poweroff()
callback provided by its driver and return its result, or return 0 if not
defined</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_poweroff_noirq(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>if pm_runtime_suspended(dev) returns “false”, run the -&gt;poweroff_noirq()
callback provided by the device’s driver and return its result, or return
0 if not defined</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_restore(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>invoke the -&gt;restore() callback provided by the driver of this device and,
if successful, change the device’s runtime PM status to ‘active’</p></li>
</ul>
</dd>
<dt><cite>int pm_generic_restore_noirq(struct device *dev);</cite></dt><dd><ul class="simple">
<li><p>invoke the -&gt;restore_noirq() callback provided by the device’s driver</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>These functions are the defaults used by the PM core if a subsystem doesn’t
provide its own callbacks for -&gt;runtime_idle(), -&gt;runtime_suspend(),
-&gt;runtime_resume(), -&gt;suspend(), -&gt;suspend_noirq(), -&gt;resume(),
-&gt;resume_noirq(), -&gt;freeze(), -&gt;freeze_noirq(), -&gt;thaw(), -&gt;thaw_noirq(),
-&gt;poweroff(), -&gt;poweroff_noirq(), -&gt;restore(), -&gt;restore_noirq() in the
subsystem-level dev_pm_ops structure.</p>
<p>Device drivers that wish to use the same function as a system suspend, freeze,
poweroff and runtime suspend callback, and similarly for system resume, thaw,
restore, and runtime resume, can achieve this with the help of the
UNIVERSAL_DEV_PM_OPS macro defined in include/linux/pm.h (possibly setting its
last argument to NULL).</p>
</section>
<section id="no-callback-devices">
<h2>8. “No-Callback” Devices<a class="headerlink" href="#no-callback-devices" title="Permalink to this headline">¶</a></h2>
<p>Some “devices” are only logical sub-devices of their parent and cannot be
power-managed on their own.  (The prototype example is a USB interface.  Entire
USB devices can go into low-power mode or send wake-up requests, but neither is
possible for individual interfaces.)  The drivers for these devices have no
need of runtime PM callbacks; if the callbacks did exist, -&gt;runtime_suspend()
and -&gt;runtime_resume() would always return 0 without doing anything else and
-&gt;runtime_idle() would always call pm_runtime_suspend().</p>
<p>Subsystems can tell the PM core about these devices by calling
pm_runtime_no_callbacks().  This should be done after the device structure is
initialized and before it is registered (although after device registration is
also okay).  The routine will set the device’s power.no_callbacks flag and
prevent the non-debugging runtime PM sysfs attributes from being created.</p>
<p>When power.no_callbacks is set, the PM core will not invoke the
-&gt;runtime_idle(), -&gt;runtime_suspend(), or -&gt;runtime_resume() callbacks.
Instead it will assume that suspends and resumes always succeed and that idle
devices should be suspended.</p>
<p>As a consequence, the PM core will never directly inform the device’s subsystem
or driver about runtime power changes.  Instead, the driver for the device’s
parent must take responsibility for telling the device’s driver when the
parent’s power state changes.</p>
<p>Note that, in some cases it may not be desirable for subsystems/drivers to call
pm_runtime_no_callbacks() for their devices. This could be because a subset of
the runtime PM callbacks needs to be implemented, a platform dependent PM
domain could get attached to the device or that the device is power managed
through a supplier device link. For these reasons and to avoid boilerplate code
in subsystems/drivers, the PM core allows runtime PM callbacks to be
unassigned. More precisely, if a callback pointer is NULL, the PM core will act
as though there was a callback and it returned 0.</p>
</section>
<section id="autosuspend-or-automatically-delayed-suspends">
<h2>9. Autosuspend, or automatically-delayed suspends<a class="headerlink" href="#autosuspend-or-automatically-delayed-suspends" title="Permalink to this headline">¶</a></h2>
<p>Changing a device’s power state isn’t free; it requires both time and energy.
A device should be put in a low-power state only when there’s some reason to
think it will remain in that state for a substantial time.  A common heuristic
says that a device which hasn’t been used for a while is liable to remain
unused; following this advice, drivers should not allow devices to be suspended
at runtime until they have been inactive for some minimum period.  Even when
the heuristic ends up being non-optimal, it will still prevent devices from
“bouncing” too rapidly between low-power and full-power states.</p>
<p>The term “autosuspend” is an historical remnant.  It doesn’t mean that the
device is automatically suspended (the subsystem or driver still has to call
the appropriate PM routines); rather it means that runtime suspends will
automatically be delayed until the desired period of inactivity has elapsed.</p>
<p>Inactivity is determined based on the power.last_busy field.  Drivers should
call pm_runtime_mark_last_busy() to update this field after carrying out I/O,
typically just before calling pm_runtime_put_autosuspend().  The desired length
of the inactivity period is a matter of policy.  Subsystems can set this length
initially by calling pm_runtime_set_autosuspend_delay(), but after device
registration the length should be controlled by user space, using the
/sys/devices/…/power/autosuspend_delay_ms attribute.</p>
<p>In order to use autosuspend, subsystems or drivers must call
pm_runtime_use_autosuspend() (preferably before registering the device), and
thereafter they should use the various <cite>*_autosuspend()</cite> helper functions
instead of the non-autosuspend counterparts:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Instead of: pm_runtime_suspend    use: pm_runtime_autosuspend;
Instead of: pm_schedule_suspend   use: pm_request_autosuspend;
Instead of: pm_runtime_put        use: pm_runtime_put_autosuspend;
Instead of: pm_runtime_put_sync   use: pm_runtime_put_sync_autosuspend.
</pre></div>
</div>
<p>Drivers may also continue to use the non-autosuspend helper functions; they
will behave normally, which means sometimes taking the autosuspend delay into
account (see pm_runtime_idle).</p>
<p>Under some circumstances a driver or subsystem may want to prevent a device
from autosuspending immediately, even though the usage counter is zero and the
autosuspend delay time has expired.  If the -&gt;runtime_suspend() callback
returns -EAGAIN or -EBUSY, and if the next autosuspend delay expiration time is
in the future (as it normally would be if the callback invoked
pm_runtime_mark_last_busy()), the PM core will automatically reschedule the
autosuspend.  The -&gt;runtime_suspend() callback can’t do this rescheduling
itself because no suspend requests of any kind are accepted while the device is
suspending (i.e., while the callback is running).</p>
<p>The implementation is well suited for asynchronous use in interrupt contexts.
However such use inevitably involves races, because the PM core can’t
synchronize -&gt;runtime_suspend() callbacks with the arrival of I/O requests.
This synchronization must be handled by the driver, using its private lock.
Here is a schematic pseudo-code example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo_read_or_write(struct foo_priv *foo, void *data)
{
        lock(&amp;foo-&gt;private_lock);
        add_request_to_io_queue(foo, data);
        if (foo-&gt;num_pending_requests++ == 0)
                pm_runtime_get(&amp;foo-&gt;dev);
        if (!foo-&gt;is_suspended)
                foo_process_next_request(foo);
        unlock(&amp;foo-&gt;private_lock);
}

foo_io_completion(struct foo_priv *foo, void *req)
{
        lock(&amp;foo-&gt;private_lock);
        if (--foo-&gt;num_pending_requests == 0) {
                pm_runtime_mark_last_busy(&amp;foo-&gt;dev);
                pm_runtime_put_autosuspend(&amp;foo-&gt;dev);
        } else {
                foo_process_next_request(foo);
        }
        unlock(&amp;foo-&gt;private_lock);
        /* Send req result back to the user ... */
}

int foo_runtime_suspend(struct device *dev)
{
        struct foo_priv foo = container_of(dev, ...);
        int ret = 0;

        lock(&amp;foo-&gt;private_lock);
        if (foo-&gt;num_pending_requests &gt; 0) {
                ret = -EBUSY;
        } else {
                /* ... suspend the device ... */
                foo-&gt;is_suspended = 1;
        }
        unlock(&amp;foo-&gt;private_lock);
        return ret;
}

int foo_runtime_resume(struct device *dev)
{
        struct foo_priv foo = container_of(dev, ...);

        lock(&amp;foo-&gt;private_lock);
        /* ... resume the device ... */
        foo-&gt;is_suspended = 0;
        pm_runtime_mark_last_busy(&amp;foo-&gt;dev);
        if (foo-&gt;num_pending_requests &gt; 0)
                foo_process_next_request(foo);
        unlock(&amp;foo-&gt;private_lock);
        return 0;
}
</pre></div>
</div>
<p>The important point is that after foo_io_completion() asks for an autosuspend,
the foo_runtime_suspend() callback may race with foo_read_or_write().
Therefore foo_runtime_suspend() has to check whether there are any pending I/O
requests (while holding the private lock) before allowing the suspend to
proceed.</p>
<p>In addition, the power.autosuspend_delay field can be changed by user space at
any time.  If a driver cares about this, it can call
pm_runtime_autosuspend_expiration() from within the -&gt;runtime_suspend()
callback while holding its private lock.  If the function returns a nonzero
value then the delay has not yet expired and the callback should return
-EAGAIN.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.2.0-rc4-6.2.0-rc4+</p>







<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Runtime Power Management Framework for I/O Devices</a><ul>
<li><a class="reference internal" href="#introduction">1. Introduction</a></li>
<li><a class="reference internal" href="#device-runtime-pm-callbacks">2. Device Runtime PM Callbacks</a></li>
<li><a class="reference internal" href="#runtime-pm-device-fields">3. Runtime PM Device Fields</a></li>
<li><a class="reference internal" href="#runtime-pm-device-helper-functions">4. Runtime PM Device Helper Functions</a></li>
<li><a class="reference internal" href="#runtime-pm-initialization-device-probing-and-removal">5. Runtime PM Initialization, Device Probing and Removal</a></li>
<li><a class="reference internal" href="#runtime-pm-and-system-sleep">6. Runtime PM and System Sleep</a></li>
<li><a class="reference internal" href="#no-callback-devices">8. “No-Callback” Devices</a></li>
<li><a class="reference internal" href="#autosuspend-or-automatically-delayed-suspends">9. Autosuspend, or automatically-delayed suspends</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/power/runtime_pm.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The kernel development community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/power/runtime_pm.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>